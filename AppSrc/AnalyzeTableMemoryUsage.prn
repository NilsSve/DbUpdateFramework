Compiling Program: C:\Projects\DF20\DbUpdateFramework\AppSrc\AnalyzeTableMemoryUsage.src
Memory Available: 2147483646
1>// The AnalyzeTableMemoryUsage project can be added to any workspace
1>// Simply copy it into the workspace AppSrc folder, add the project in the Studio and compile and run
1>// It is used in combination with information contained in the "Memory Use in DataFlex Web Applications" Blog
1>
1>Use Windows.pkg
Using pre-compiled package WINDOWS.PKG
Including file: windows.pkd    (C:\Program Files (x86)\DataFlex 19.1\Pkg\windows.pkd)
7602>Use cApplication.pkg
Including file: cApplication.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cApplication.pkg)
7602>>>Use Windows.pkg
7602>>>
7602>>>Use LanguageText.pkg
7602>>>Use WinUser.pkg
7602>>>Use WinShell.pkg
Including file: WinShell.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\WinShell.pkg)
7602>>>>>Use DLL.pkg
7602>>>>>
7602>>>>>External_Function PathFileExists "PathFileExistsA" shlwapi.dll ;    String sPath ;    Returns Integer // Boolean
7603>>>>>
7603>>>>>External_Function PathIsRelative "PathIsRelativeA" shlwapi.dll ;    String sPath ;    Returns Integer // Boolean
7604>>>>>
7604>>>>>External_Function PathRemoveExtension "PathRemoveExtensionA" shlwapi.dll ;    Address aPath ;    Returns Integer // void
7605>>>>>
7605>>>>>External_Function PathRemoveFileSpec "PathRemoveFileSpecA" shlwapi.dll ;    Address aPath ;    Returns Integer
7606>>>>>
7606>>>>>
7606>>>>>Define URL_UNESCAPE_INPLACE                    for |CI$00100000
7606>>>>>Define URL_ESCAPE_SEGMENT_ONLY                 for |CI$00002000
7606>>>>>
7606>>>>>External_Function UrlUnescape "UrlUnescapeA" shlwapi.dll;    Pointer pszURL;    Pointer pszUnescaped;    Pointer pcchUnescaped;    DWord dwFlags;    Returns Integer // S_OK if succesfull
7607>>>>>
7607>>>>>External_Function UrlEscape "UrlEscapeA" shlwapi.dll;    Pointer pszUrl;    Pointer pszEscaped;    Pointer pcchEscaped;    DWord dwFlags;    Returns Integer
7608>>>>>
7608>>>Use cWorkspace.pkg
Including file: cWorkspace.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cWorkspace.pkg)
7608>>>>>Use VdfBase.pkg
7608>>>>>Use tWinStructs.pkg
7608>>>>>Use LanguageText.pkg
7608>>>>>Use WinShell.pkg // Shell API functions
7608>>>>>Use seq_chnl.pkg
Including file: seq_chnl.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\seq_chnl.pkg)
7608>>>>>>>Use LanguageText.pkg
7608>>>>>>>Use VDFBase.pkg
Including file: errornum.inc    (C:\Program Files (x86)\DataFlex 19.1\Pkg\errornum.inc)
7608>>>>>>>>
7608>>>>>>>>//
7608>>>>>>>>// these will get defined in fmac
7608>>>>>>>>//
7608>>>>>>>>// already defined
7608>>>>>>>>//    #REPLACE DFERR_COMP_BAD_IMAGE_NAME                 |CI4293
7608>>>>>>>>//    #REPLACE DFERR_COMP_CONSTANT_EXPECTED              |CI4299
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_RETURN_TYPE            |CI4310
7608>>>>>>>>//    #REPLACE DFERR_COMP_IMAGE_NOT_FOUND                |CI4311
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_DATATYPE               |CI4315
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_TYPE                   |CI4317
7608>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_ARGUMENT               |CI4320
7608>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_END_OBJECT             |CI4323
7608>>>>>>>>//    #REPLACE DFERR_COMP_UNDEFINED_SYMBOL_IN_ARGUMENT   |CI4328
7608>>>>>>>>//    #REPLACE DFERR_COMP_SYMBOL_ALREADY_DEFINED         |CI4332
7608>>>>>>>>//    #REPLACE DFERR_COMP_TOO_MANY_MESSAGES              |CI4339
7608>>>>>>>>//    #REPLACE DFERR_COMP_UNRESOVLED_CONTROL_BLOCK       |CI4348
7608>>>>>>>>// new compiler errors used by fmac
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_OBJECT_DEFINTION       |CI4388 // object name used is not valid
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION     |CI4389 // property name cannot be used
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_METHOD_DEFINTION       |CI4390 // method name cannot be used
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_CODE_PLACEMENT         |CI4391 // Location of code, nesting, is wrong
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_METHOD_SYNTAX          |CI4392 // syntax is incorrect for method definition
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_MESSAGE_SYNTAX         |CI4393 // sysntax is incorrect for sending message
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_OBJECT_REFERENCE       |CI4394 // object named in message is invalid
7608>>>>>>>>//    #REPLACE DFERR_COMP_OBSOLETE_UNSUPPORTED_FEATURE   |CI4395 // Obsolete - was 101 (Moveused by fmac)
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_ARGUMENT               |CI4396 // Agument in line is incorrect
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_EXTERNAL_FUNCTION_DEFINITION |CI4397 // name cannot be used
7608>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_DEBUG_INFORMATION      |CI4500 // debug information is not provided
7608>>>>>>>>//    #REPLACE DFERR_COMP_INCOMPATIBLE_DEBUG_INFORMATION |CI4501 // debug inforamtion is is not correct
7608>>>>>>>>//    #REPLACE DFERR_COMP_RECURSIVE_STRUCT_DECLARATION   |CI4513 // recursive struct definition
7608>>>>>>>>//    #REPLACE DFERR_COMP_AMBIGUOUS_SYNTAX               |CI4514 // either Left of "'[' is not array, use '(' if indicator" or "Left of '.' is not of type struct or table"
7608>>>>>>>>
7608>>>>>>>>
7608>>>>>>>>
7608>>>>>>>
7608>>>>>>>Define DF_SEQ_CHANNEL_NOT_AVAILABLE for -2
7608>>>>>>>Define DF_SEQ_CHANNEL_ERROR         for -1
7608>>>>>>>Define DF_SEQ_CHANNEL_MIN           for 0
7608>>>>>>>Define DF_SEQ_CHANNEL_MAX           for 9
7608>>>>>>>Define DF_SEQ_START_CHANNEL         for 2 // leave 0 and 1 til last
7608>>>>>>>// so that programs that use direct_input/output
7608>>>>>>>// w/o specifying a channel will work.
7608>>>>>>>Enum_List
7608>>>>>>>    Define DF_SEQ_CHANNEL_MODE_CLOSED
7608>>>>>>>    Define DF_SEQ_CHANNEL_MODE_OPEN
7608>>>>>>>    Define DF_SEQ_CHANNEL_MODE_OUTPUT
7608>>>>>>>    Define DF_SEQ_CHANNEL_MODE_INPUT
7608>>>>>>>End_Enum_List
7608>>>>>>>
7608>>>>>>>Enum_List
7608>>>>>>>    Define DF_SEQ_CHANNEL_ERROR_MODE_NONE
7608>>>>>>>    Define DF_SEQ_CHANNEL_ERROR_MODE_ALL
7608>>>>>>>End_Enum_List
7608>>>>>>>
7608>>>>>>>Integer Seq$Channel$Error$Mode
7608>>>>>>>
7608>>>>>>>Procedure Set Seq_Channel_Error_Mode Global Integer Mode
7610>>>>>>>    Move Mode to Seq$Channel$Error$Mode
7611>>>>>>>End_Procedure
7612>>>>>>>
7612>>>>>>>Function Seq_Channel_Error_Mode Global Returns Integer
7614>>>>>>>    Function_Return Seq$Channel$Error$Mode
7615>>>>>>>End_Function
7616>>>>>>>
7616>>>>>>>Object Seq_Channel_List is an Array
7618>>>>>>>    Procedure Initialize
7621>>>>>>>        Integer Itm
7621>>>>>>>        
7621>>>>>>>        Move DF_SEQ_CHANNEL_MIN to Itm
7622>>>>>>>        
7622>>>>>>>        While Itm LE DF_SEQ_CHANNEL_MAX
7626>>>>>>>            Set Array_Value  Itm to DF_SEQ_CHANNEL_MODE_CLOSED
7627>>>>>>>            Increment Itm
7628>>>>>>>        Loop
7629>>>>>>>>
7629>>>>>>>    End_Procedure
7630>>>>>>>    
7630>>>>>>>    Send Initialize
7631>>>>>>>End_Object
7632>>>>>>>
7632>>>>>>>Set Seq_Channel_Error_Mode to DF_SEQ_CHANNEL_ERROR_MODE_ALL
7633>>>>>>>
7633>>>>>>>Function Seq_Channel_Mode Global Integer Chnl Returns Integer
7635>>>>>>>    Function_Return (Integer_Value(Seq_Channel_List(Self), Chnl))
7636>>>>>>>End_Function
7637>>>>>>>
7637>>>>>>>Procedure Set Seq_Channel_Mode Global Integer Chnl Integer Mode
7639>>>>>>>    Set Array_Value of (Seq_Channel_List(Self))  Chnl to Mode
7640>>>>>>>End_Procedure
7641>>>>>>>
7641>>>>>>>Function Seq_New_Channel Global Returns Integer
7643>>>>>>>    Integer Obj Chnl
7643>>>>>>>    
7643>>>>>>>    Move DF_SEQ_START_CHANNEL to Chnl
7644>>>>>>>    
7644>>>>>>>    While Chnl LE DF_SEQ_CHANNEL_MAX
7648>>>>>>>        If (Seq_Channel_Mode(Chnl) = DF_SEQ_CHANNEL_MODE_CLOSED) Begin
7650>>>>>>>            Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OPEN
7651>>>>>>>            Function_Return Chnl
7652>>>>>>>        End
7652>>>>>>>>
7652>>>>>>>        
7652>>>>>>>        Increment Chnl
7653>>>>>>>    Loop
7654>>>>>>>>
7654>>>>>>>    
7654>>>>>>>    // wrap back to beginning
7654>>>>>>>    Move 0 to Chnl
7655>>>>>>>    
7655>>>>>>>    While Chnl LT DF_SEQ_START_CHANNEL
7659>>>>>>>        If (Seq_Channel_Mode(Chnl) = DF_SEQ_CHANNEL_MODE_CLOSED) Begin
7661>>>>>>>            Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OPEN
7662>>>>>>>            Function_Return Chnl
7663>>>>>>>        End
7663>>>>>>>>
7663>>>>>>>        
7663>>>>>>>        Increment Chnl
7664>>>>>>>    Loop
7665>>>>>>>>
7665>>>>>>>    
7665>>>>>>>    Function_Return DF_SEQ_CHANNEL_NOT_AVAILABLE
7666>>>>>>>End_Function
7667>>>>>>>
7667>>>>>>>Procedure Seq_Release_Channel Global Integer Chnl
7669>>>>>>>    If ((Chnl >= DF_SEQ_CHANNEL_MIN) and (Chnl <= DF_SEQ_CHANNEL_MAX)) ;        Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_CLOSED
7672>>>>>>>End_Procedure
7673>>>>>>>
7673>>>>>>>Function Seq_Open_Input_Channel Global String Dvc Returns Integer
7675>>>>>>>    Integer Chnl
7675>>>>>>>    
7675>>>>>>>    Move (Seq_New_Channel()) to Chnl
7676>>>>>>>    
7676>>>>>>>    If (Chnl <= DF_SEQ_CHANNEL_ERROR) Begin
7678>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) ;            Error DFERR_CANT_OPEN_INPUT_FILE (Dvc + ":" *C_$NoOpenChannels)
7681>>>>>>>        Function_Return Chnl
7682>>>>>>>    End
7682>>>>>>>>
7682>>>>>>>    
7682>>>>>>>    Move False to Err
7683>>>>>>>    Direct_Input channel Chnl Dvc
7685>>>>>>>    
7685>>>>>>>    If (Err) Begin
7687>>>>>>>        Send Seq_Release_Channel Chnl
7688>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
7689>>>>>>>    End
7689>>>>>>>>
7689>>>>>>>    
7689>>>>>>>    Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_INPUT
7690>>>>>>>    
7690>>>>>>>    Function_Return Chnl
7691>>>>>>>End_Function
7692>>>>>>>
7692>>>>>>>Function Seq_Open_Output_Channel Global String Dvc Returns Integer
7694>>>>>>>    Integer Chnl
7694>>>>>>>    
7694>>>>>>>    Move (Seq_New_Channel()) to Chnl
7695>>>>>>>    
7695>>>>>>>    If (Chnl <= DF_SEQ_CHANNEL_ERROR) Begin
7697>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
7699>>>>>>>            Error DFERR_CANT_OPEN_OUTPUT_FILE (Dvc + ":" *C_$ChannelNotAvailable)
7700>>>>>>>>
7700>>>>>>>            Move DF_SEQ_CHANNEL_ERROR to Chnl
7701>>>>>>>        End
7701>>>>>>>>
7701>>>>>>>        
7701>>>>>>>        Function_Return Chnl
7702>>>>>>>    End
7702>>>>>>>>
7702>>>>>>>    
7702>>>>>>>    Move False to Err
7703>>>>>>>    Direct_Output channel Chnl Dvc
7705>>>>>>>    
7705>>>>>>>    If (Err) Begin
7707>>>>>>>        Send Seq_Release_Channel Chnl
7708>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
7709>>>>>>>    End
7709>>>>>>>>
7709>>>>>>>    
7709>>>>>>>    Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OUTPUT
7710>>>>>>>    
7710>>>>>>>    Function_Return Chnl
7711>>>>>>>End_Function
7712>>>>>>>
7712>>>>>>>Function Seq_Append_Output_Channel Global String Dvc Returns Integer
7714>>>>>>>    Integer Chnl
7714>>>>>>>    
7714>>>>>>>    Move (Seq_New_Channel()) to Chnl
7715>>>>>>>    
7715>>>>>>>    If (Chnl <= DF_SEQ_CHANNEL_ERROR) Begin
7717>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
7719>>>>>>>            Error DFERR_CANT_OPEN_OUTPUT_FILE (Dvc + ":" *C_$ChannelNotAvailable)
7720>>>>>>>>
7720>>>>>>>            Move DF_SEQ_CHANNEL_ERROR to Chnl
7721>>>>>>>        End
7721>>>>>>>>
7721>>>>>>>        
7721>>>>>>>        Function_Return Chnl
7722>>>>>>>    End
7722>>>>>>>>
7722>>>>>>>    
7722>>>>>>>    Move False to Err
7723>>>>>>>    Append_Output channel Chnl Dvc
7725>>>>>>>    
7725>>>>>>>    If (Err) Begin
7727>>>>>>>        Send Seq_Release_Channel Chnl
7728>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
7729>>>>>>>    End
7729>>>>>>>>
7729>>>>>>>    
7729>>>>>>>    Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OUTPUT
7730>>>>>>>    
7730>>>>>>>    Function_Return Chnl
7731>>>>>>>End_Function
7732>>>>>>>
7732>>>>>>>Procedure Seq_Close_Channel Global Integer Chnl
7734>>>>>>>    Integer Mode
7734>>>>>>>    
7734>>>>>>>    If ((Chnl >= DF_SEQ_CHANNEL_MIN) and (Chnl <= DF_SEQ_CHANNEL_MAX)) Begin
7736>>>>>>>        Move (Seq_Channel_Mode(Chnl)) to Mode
7737>>>>>>>        
7737>>>>>>>        If (Mode = DF_SEQ_CHANNEL_MODE_OUTPUT) ;            Close_Output channel Chnl
7741>>>>>>>        Else If (Mode = DF_SEQ_CHANNEL_MODE_INPUT) ;            Close_Input channel Chnl
7746>>>>>>>        // If channel not open, release it! No (fatal) Error.
7746>>>>>>>        Send Seq_Release_Channel Chnl
7747>>>>>>>    End
7747>>>>>>>>
7747>>>>>>>End_Procedure
7748>>>>>>>
7748>>>>>Use GlobalFunctionsProcedures.pkg
7748>>>>>
7748>>>>>Register_Function IsRegistered String sWorkspace Returns Boolean
7748>>>>>Register_Function VdfSystemDfPath   Returns String
7748>>>>>Register_Function VdfSystemMakePath Returns String
7748>>>>>
7748>>>>>Enum_List
7748>>>>>    Define wsWorkspaceOpened       // WS opened ok
7748>>>>>    Define wsWorkspaceNotFound     // the named WS was not found in the global list
7748>>>>>    Define wsWorkspaceFileNotFound // the WS file was not found
7748>>>>>    Define wsDataPathEmpty         // the DataPath entry was empty
7748>>>>>    Define wsFileListEmpty         // The FileList entry was empty
7748>>>>>    Define wsFileListNotExist      // The FileList.cfg file could not be found
7748>>>>>End_Enum_List
7748>>>>>
7748>>>>>Define INVALID_HANDLE_VALUE for -1
7748>>>>>Define MAX_PATH for 260   // Symbol for maximum length of a path
7748>>>>>
7748>>>>>
7748>>>>>External_Function winFindFirstFile "FindFirstFileA" Kernel32.dll ;    String sFileSpec Pointer lpsWin32FindData Returns Handle
7749>>>>>
7749>>>>>External_Function winFindNextFile "FindNextFileA" Kernel32.dll ;    Handle hFindFile Pointer lpsWin32FindData Returns Handle
7750>>>>>
7750>>>>>External_Function winFindClose "FindClose" Kernel32.dll ;    Handle hOpenFile Returns Integer
7751>>>>>
7751>>>>>Function DoesFileExist Global String sFilename Returns Boolean
7753>>>>>    tWIN32_FIND_DATA Win32FindData
7753>>>>>    tWIN32_FIND_DATA Win32FindData
7753>>>>>    String sMask
7753>>>>>    Integer iVoid
7753>>>>>    Handle hFileFind
7753>>>>>    
7753>>>>>    Move (winFindFirstFile(ToAnsi(sFilename), AddressOf(Win32FindData))) to hFileFind   // JVH 8.3.8.0 must pass Ansi filename
7754>>>>>    If (hFileFind <> INVALID_HANDLE_VALUE) Begin
7756>>>>>        Move (winFindClose(hFileFind)) to iVoid
7757>>>>>    End
7757>>>>>>
7757>>>>>    
7757>>>>>    Function_Return (hFileFind <> INVALID_HANDLE_VALUE)
7758>>>>>End_Function
7759>>>>>
7759>>>>>
7759>>>>>Use cIniFile.pkg
Including file: cIniFile.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cIniFile.pkg)
7759>>>>>>>Use Dll.pkg
7759>>>>>>>Use errornum.inc
7759>>>>>>>Use LanguageText.pkg
7759>>>>>>>Use GlobalFunctionsProcedures.pkg
7759>>>>>>>
7759>>>>>>>// it is important that psFileName is defined. If blank, the registry may be accessed. We will check all WritePrivateProfileString
7759>>>>>>>// and GetPrivateProfileString to make sure that a file is defined.
7759>>>>>>>External_Function WritePrivateProfileString "WritePrivateProfileStringA" Kernel32.dll ;    String sSection String sKeyName String sValue String sFileName Returns Integer
7760>>>>>>>
7760>>>>>>>External_Function GetPrivateProfileString "GetPrivateProfileStringA" Kernel32.dll ;    Address aSection Address aKeyName Address aDefault Pointer lpsValue Integer nSize String sFileName Returns Integer
7761>>>>>>>
7761>>>>>>>Class cIniFile is a cObject
7762>>>>>>>    Procedure Construct_Object
7764>>>>>>>        Forward Send Construct_Object
7766>>>>>>>        
7766>>>>>>>        Property String psFileName
7767>>>>>>>    End_Procedure
7768>>>>>>>    
7768>>>>>>>    Procedure WriteString String sSection String sKey String sValue
7770>>>>>>>        Boolean bSuccess
7770>>>>>>>        
7770>>>>>>>        If (trim(psFileName(Self))="") Begin
7772>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7773>>>>>>>>
7773>>>>>>>            Procedure_Return
7774>>>>>>>        End
7774>>>>>>>>
7774>>>>>>>        Move (WritePrivateProfileString(ToAnsi(sSection), ToAnsi(sKey), ToAnsi(sValue), ToAnsi(psFilename(Self)))) to bSuccess
7775>>>>>>>        If (bSuccess = False) ;            Error DFERR_INI_FILE C_$CannotWriteToTheIniFile
7778>>>>>>>    End_Procedure
7779>>>>>>>    
7779>>>>>>>    Function ReadString String sSection String sKey String sDefault Returns String
7781>>>>>>>        Integer iNumChars iSizeValue
7781>>>>>>>        String sValue
7781>>>>>>>        
7781>>>>>>>        Move (ToAnsi(sSection)) to sSection
7782>>>>>>>        Move (ToAnsi(sKey))     to sKey
7783>>>>>>>        Move (ToAnsi(sDefault)) to sDefault
7784>>>>>>>        
7784>>>>>>>        Move 2047 to iSizeValue
7785>>>>>>>        
7785>>>>>>>        Move (Pad(" ",iSizeValue)) to sValue
7786>>>>>>>        
7786>>>>>>>        If (trim(psFileName(Self))="") Begin
7788>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7789>>>>>>>>
7789>>>>>>>            Function_Return ''
7790>>>>>>>        End
7790>>>>>>>>
7790>>>>>>>        Move (GetPrivateProfileString(AddressOf(sSection), AddressOf(sKey), AddressOf(sDefault), AddressOf(sValue), iSizeValue, ToAnsi(psFilename(Self)))) to iNumChars
7791>>>>>>>        Function_Return  (ToOem(CString(sValue)))
7792>>>>>>>    End_Function
7793>>>>>>>    
7793>>>>>>>    Function SectionExists String sSection Returns Boolean
7795>>>>>>>        // A section exists only if it has at least one Key. A section with no keys is said not to exist
7795>>>>>>>        Handle hoKeys
7795>>>>>>>        Integer icKey iKey
7795>>>>>>>        
7795>>>>>>>        Get Create U_ARRAY to hoKeys
7796>>>>>>>        Send ReadSection sSection hoKeys
7797>>>>>>>        Get Item_Count of hoKeys to icKey
7798>>>>>>>        Send Destroy of hoKeys
7799>>>>>>>        
7799>>>>>>>        Function_Return (icKey >0)
7800>>>>>>>    End_Function
7801>>>>>>>    
7801>>>>>>>    Procedure ReadSection String sSection Handle hoArray
7803>>>>>>>        Integer iNumChars iSizeValue iPos
7803>>>>>>>        Pointer lpsKeys
7803>>>>>>>        String sKeys sKey
7803>>>>>>>        
7803>>>>>>>        Move 16384 to iSizeValue
7804>>>>>>>        Move (Repeat(character(0),  iSizeValue)) to sKeys
7805>>>>>>>        
7805>>>>>>>        Move (AddressOf(sKeys)) to lpsKeys
7806>>>>>>>        
7806>>>>>>>        Move (ToAnsi(sSection)) to sSection
7807>>>>>>>        
7807>>>>>>>        If (trim(psFileName(Self))="") Begin
7809>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7810>>>>>>>>
7810>>>>>>>            Procedure_Return
7811>>>>>>>        End
7811>>>>>>>>
7811>>>>>>>        Move (GetPrivateProfileString(AddressOf(sSection), 0, 0, lpsKeys, Length(sKeys), ToAnsi(psFilename(Self)))) to iNumChars
7812>>>>>>>        If (iNumChars >0) Begin
7814>>>>>>>            Repeat
7814>>>>>>>>
7814>>>>>>>                Move (Pos(Character(0),sKeys)) to iPos
7815>>>>>>>                If (iPos >1) Begin
7817>>>>>>>                    Move (Left(sKeys,iPos -1))  to sKey
7818>>>>>>>                    Move (Right(sKeys,Length(sKeys) - iPos)) to sKeys
7819>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) to (ToOem(sKey))
7820>>>>>>>                End
7820>>>>>>>>
7820>>>>>>>            Until (iPos <=1)
7822>>>>>>>        End
7822>>>>>>>>
7822>>>>>>>    End_Procedure
7823>>>>>>>    
7823>>>>>>>    Procedure ReadSections Handle hoArray
7825>>>>>>>        Integer iNumChars iSizeValue iPos
7825>>>>>>>        Pointer lpsSections
7825>>>>>>>        String sSections sSection
7825>>>>>>>        
7825>>>>>>>        Move 16384 to iSizeValue
7826>>>>>>>        
7826>>>>>>>        Move (Repeat(character(0),  iSizeValue)) to sSections
7827>>>>>>>        Move (AddressOf(sSections)) to lpsSections
7828>>>>>>>        
7828>>>>>>>        If (trim(psFileName(Self))="") Begin
7830>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7831>>>>>>>>
7831>>>>>>>            Procedure_Return
7832>>>>>>>        End
7832>>>>>>>>
7832>>>>>>>        Move (GetPrivateProfileString(0, 0, 0, lpsSections, Length(sSections), ToAnsi(psFilename(Self)))) to iNumChars
7833>>>>>>>        If (iNumChars >0) Begin
7835>>>>>>>            Repeat
7835>>>>>>>>
7835>>>>>>>                Move (Pos(Character(0),sSections)) to iPos
7836>>>>>>>                If (iPos >1) Begin
7838>>>>>>>                    Move (Left(sSections,iPos -1)) to sSection
7839>>>>>>>                    Move (Right(sSections, Length(sSections) - iPos)) to sSections
7840>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) to (ToOem(sSection))
7841>>>>>>>                End
7841>>>>>>>>
7841>>>>>>>            Until (iPos <=1)
7843>>>>>>>        End
7843>>>>>>>>
7843>>>>>>>        
7843>>>>>>>    End_Procedure
7844>>>>>>>    
7844>>>>>>>    Procedure DeleteSection String sSection
7846>>>>>>>        
7846>>>>>>>        If (trim(psFileName(Self))="") Begin
7848>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7849>>>>>>>>
7849>>>>>>>            Procedure_Return
7850>>>>>>>        End
7850>>>>>>>>
7850>>>>>>>        If (WritePrivateProfileString(ToAnsi(sSection), "", "", ToAnsi(psFilename(Self))) = 0) ;            Error DFERR_INI_FILE C_$CanNotDeleteSection
7853>>>>>>>    End_Procedure
7854>>>>>>>    
7854>>>>>>>    Procedure DeleteKey String sSection String sKey
7856>>>>>>>        Integer iVoid
7856>>>>>>>        If (trim(psFileName(Self))="") Begin
7858>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7859>>>>>>>>
7859>>>>>>>            Procedure_Return
7860>>>>>>>        End
7860>>>>>>>>
7860>>>>>>>        Move (WritePrivateProfileString(ToAnsi(sSection), ToAnsi(sKey), "", ToAnsi(psFilename(Self)))) to iVoid
7861>>>>>>>    End_Procedure
7862>>>>>>>    
7862>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
7864>>>>>>>        Handle hoKeys
7864>>>>>>>        Integer iKey
7864>>>>>>>        Boolean bExists
7864>>>>>>>        
7864>>>>>>>        Move (False) to bExists
7865>>>>>>>        
7865>>>>>>>        Move (ToAnsi(Uppercase(sKey))) to sKey
7866>>>>>>>        
7866>>>>>>>        Get Create U_ARRAY to hoKeys
7867>>>>>>>        
7867>>>>>>>        Send ReadSection sSection hoKeys
7868>>>>>>>        For iKey from 0 to (Item_Count(hoKeys) -1)
7874>>>>>>>>
7874>>>>>>>            If (sKey = Uppercase(Value(hoKeys, iKey))) Begin
7876>>>>>>>                Move (True) to bExists
7877>>>>>>>            End
7877>>>>>>>>
7877>>>>>>>        Loop
7878>>>>>>>>
7878>>>>>>>        
7878>>>>>>>        Send Destroy of hoKeys
7879>>>>>>>        
7879>>>>>>>        Function_Return bExists
7880>>>>>>>    End_Function
7881>>>>>>>    
7881>>>>>>>End_Class
7882>>>>>
7882>>>>>Class cWorkspace is a cObject
7883>>>>>    
7883>>>>>    Procedure Construct_Object
7885>>>>>        Forward Send Construct_Object
7887>>>>>        
7887>>>>>        
7887>>>>>        Property String psAppSrcPath
7888>>>>>        Property String psBitmapPath
7889>>>>>        Property String psDataPath
7890>>>>>        Property String psDdSrcPath
7891>>>>>        Property String psDescription
7892>>>>>        Property String psFileList
7893>>>>>        Property String psHelpPath
7894>>>>>        Property String psHome
7895>>>>>        Property String psIdeSrcPath
7896>>>>>        Property String psProgramPath
7897>>>>>        Property String psAppHtmlPath
7898>>>>>        Property String psWorkspaceName
7899>>>>>        Property String psWorkspaceWSFile
7900>>>>>        Property String psConnectionIni
7901>>>>>        
7901>>>>>        Property String psSystemDfPath // took from the Registry!
7902>>>>>        Property String psSystemMakePath // took from the Registry!
7903>>>>>        Property String psDfPath        // Calculated
7904>>>>>        
7904>>>>>        Property Boolean pbWorkspaceOpened False // used internally to tell if we are switching workspaces
7905>>>>>        
7905>>>>>    End_Procedure
7906>>>>>    
7906>>>>>    Function FullPathNames String sShortPathNames Returns String
7908>>>>>        String sFileName
7908>>>>>        String sFullPathNames sFullPathName sShortPathName
7908>>>>>        Pointer lpsFilePart
7908>>>>>        Integer icChar // the number of characters returned
7908>>>>>        Integer iPos
7908>>>>>        
7908>>>>>        Move (Pos(";", sShortPathNames)) to iPos
7909>>>>>        While (length(sShortPathNames) >0)
7913>>>>>            If (iPos =0) Begin
7915>>>>>                Move sShortPathNames to sShortPathName
7916>>>>>                Move "" to sShortPathNames
7917>>>>>            End
7917>>>>>>
7917>>>>>            Else Begin // multiple paths
7918>>>>>                Move (Left(sShortPathNames, iPos -1)) to sShortPathName
7919>>>>>                Move (Right(sShortPathNames, length(sShortPathNames) -iPos)) to sShortPathNames // remove this path from the paths
7920>>>>>            End
7920>>>>>>
7920>>>>>            Move (Repeat(character(0), 4096)) to sFullPathName
7921>>>>>            Move -1 to lpsFilePart
7922>>>>>            Move (GetFullPathName(sShortPathName, 4096, AddressOf(sFullPathName), AddressOf(lpsFilePart))) to icChar
7923>>>>>            Append sFullPathNames (CString(sFullPathName))
7924>>>>>            If (sShortPathNames <>"") ;                Append sFullPathNames ";"
7927>>>>>            Move (Pos(";", sShortPathNames)) to iPos
7928>>>>>        Loop
7929>>>>>>
7929>>>>>        
7929>>>>>        Function_Return sFullPathNames
7930>>>>>    End_Function
7931>>>>>    
7931>>>>>    Function GetApplicationPath Returns String
7933>>>>>        // Returns the path of the Application (no trailing "\")
7933>>>>>        String sApplicationFileName sPath
7933>>>>>        Boolean bRemoved
7933>>>>>        Integer iNumChars
7933>>>>>        String sFilename
7933>>>>>        
7933>>>>>        Move (Repeat(Character(0), 1024)) to sApplicationFileName
7934>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
7935>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
7936>>>>>        
7936>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to bRemoved
7937>>>>>        Move (CString(sApplicationFileName)) to sPath
7938>>>>>        
7938>>>>>        If (Right(sPath, 1) ="\") ;            Move (Left(sPath, Length(sPath) -1)) to sPath
7941>>>>>        Function_Return sPath
7942>>>>>    End_Function
7943>>>>>    
7943>>>>>    Procedure DoClearPaths
7945>>>>>        // Call this prior to changing from one WorkspAce to another
7945>>>>>        // if you don't, OpenWorkspaceFile will ignore the new paths.
7945>>>>>        Set psHome           to ""
7946>>>>>        Set psAppSrcPath     to ""
7947>>>>>        Set psBitmapPath     to ""
7948>>>>>        Set psDataPath       to ""
7949>>>>>        Set psDdSrcPath      to ""
7950>>>>>        Set psDescription    to ""
7951>>>>>        Set psFileList       to ""
7952>>>>>        Set psHelpPath       to ""
7953>>>>>        Set psIdeSrcPath     to ""
7954>>>>>        Set psAppHtmlPath    to ""
7955>>>>>        Set psProgramPath    to ""
7956>>>>>        Set psWorkspaceName  to ""
7957>>>>>        Set psSystemDfPath   to ""
7958>>>>>        Set psSystemMakePath to ""
7959>>>>>        Set psWorkspaceWSFile to ""
7960>>>>>        Set psConnectionIni to ""
7961>>>>>    End_Procedure
7962>>>>>    
7962>>>>>    Function OpenWorkspaceFile String sWorkspaceFile Returns Integer
7964>>>>>        String sApplicationStartPath
7964>>>>>        String sWsName // name of Workspace is inferred from the Workspacefile name
7964>>>>>        Boolean bRemoved
7964>>>>>        Handle hoIniFile
7964>>>>>        Boolean bSuccess // call succeeded?
7964>>>>>        String sOldDirectory
7964>>>>>        String sSystemDfPath sSystemMakePath
7964>>>>>        Boolean bExist // does the WS file exist?
7964>>>>>        Boolean bChangingWorkspace
7964>>>>>        
7964>>>>>        String sHome sAppSrcPath sBitmapPath sDataPath sDdSrcPath sDescription sAppHtmlPath
7964>>>>>        String sFileList sHelpPath sIdeSrcPath sProgramPath sWorkspaceName sConnectionIni
7964>>>>>        
7964>>>>>        Set psWorkspaceWSFile to ""
7965>>>>>        If (sWorkspaceFile ="") ;            Function_Return wsWorkspaceFileNotFound
7968>>>>>        
7968>>>>>        // Append extension if not supplied...
7968>>>>>        If (Uppercase(Right(Trim(sWorkspaceFile),3)) <> ".WS") Begin
7970>>>>>            Move (sWorkspaceFile-".ws") to sWorkspaceFile
7971>>>>>        End
7971>>>>>>
7971>>>>>        
7971>>>>>        Get pbWorkspaceOpened to bChangingWorkspace // if we had an existing workspace. We are changing
7972>>>>>        
7972>>>>>        If (IsFilenameQualified(sWorkspaceFile) = False) Begin
7974>>>>>            // Set the properties to the paths of the Workspace
7974>>>>>            // Find the WS file (with program)...
7974>>>>>            Get GetApplicationPath to sApplicationStartPath
7975>>>>>            
7975>>>>>            Move sWorkspaceFile to sWsName
7976>>>>>            Move (sApplicationStartPath +"\" +sWorkspaceFile) to sWorkspaceFile
7977>>>>>        End
7977>>>>>>
7977>>>>>        Else Begin
7978>>>>>            Move (ExtractFileName(sWorkspaceFile)) to sWsName
7979>>>>>            
7979>>>>>            Move sWorkspaceFile to sApplicationStartPath
7980>>>>>            Move (PathRemoveFileSpec(AddressOf(sApplicationStartPath))) to bRemoved
7981>>>>>        End
7981>>>>>>
7981>>>>>        
7981>>>>>        // Ensure that the file can be found...
7981>>>>>        //File_Exist (ToAnsi(sWorkspaceFile)) bExist        // [JVH] 8.3.8.0 Convert filename to Ansi
7981>>>>>        // [JVH] Turn off support for
7981>>>>>        // Ansi extended characters in workspace until we can
7981>>>>>        // resolve all open issues
7981>>>>>        Set psWorkspaceWSFile to sWorkspaceFile
7982>>>>>        File_Exist sWorkspaceFile bExist
7983>>>>>        If (bExist = False) ;            Function_Return wsWorkspaceFileNotFound
7986>>>>>        
7986>>>>>        Get psHome           to sHome
7987>>>>>        Get psAppSrcPath     to sAppSrcPath
7988>>>>>        Get psAppHtmlPath    to sAppHtmlPath
7989>>>>>        Get psBitmapPath     to sBitmapPath
7990>>>>>        Get psDataPath       to sDataPath
7991>>>>>        Get psDdSrcPath      to sDdSrcPath
7992>>>>>        Get psDescription    to sDescription
7993>>>>>        Get psFileList       to sFileList
7994>>>>>        Get psHelpPath       to sHelpPath
7995>>>>>        Get psIdeSrcPath     to sIdeSrcPath
7996>>>>>        Get psProgramPath    to sProgramPath
7997>>>>>        Get psSystemDfPath   to sSystemDfPath
7998>>>>>        Get psSystemMakePath to sSystemMakePath
7999>>>>>        Get psWorkspaceName  to sWorkspaceName
8000>>>>>        Get psConnectionIni to sConnectionIni
8001>>>>>        
8001>>>>>        Get_Current_Directory to sOldDirectory
8002>>>>>        // Note- this conversion is temporarily rolled back
8002>>>>>        //Move (SetCurrentDirectory(ToAnsi(CString(sApplicationStartPath)))) To bSuccess    // [JVH] 8.3.8.0 Convert AppStartPath to ANSI
8002>>>>>        Move (SetCurrentDirectory(CString(sApplicationStartPath))) to bSuccess
8003>>>>>        
8003>>>>>        Get Create U_cIniFile to hoIniFile
8004>>>>>        Set psFilename of hoIniFile to sWorkspaceFile
8005>>>>>        
8005>>>>>        If (sHome ="") ;            Get ReadString of hoIniFile "Workspace" "Home" ""          to sHome
8008>>>>>        If (sAppSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "AppSrcPath" ""    to sAppSrcPath
8011>>>>>        If (sAppHtmlPath ="") ;            Get ReadString of hoIniFile "Workspace" "AppHtmlPath" ""   to sAppHtmlPath
8014>>>>>        If (sBitmapPath ="") ;            Get ReadString of hoIniFile "Workspace" "BitmapPath" ""    to sBitmapPath
8017>>>>>        If (sDataPath ="") ;            Get ReadString of hoIniFile "Workspace" "DataPath" ""      to sDataPath
8020>>>>>        If (sDdSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "DdSrcPath" ""     to sDdSrcPath
8023>>>>>        If (sDescription ="") ;            Get ReadString of hoIniFile "Workspace" "Description" ""   to sDescription
8026>>>>>        If (sFileList ="") ;            Get ReadString of hoIniFile "Workspace" "FileList" ""      to sFileList
8029>>>>>        If (sHelpPath ="") ;            Get ReadString of hoIniFile "Workspace" "HelpPath" ""      to sHelpPath
8032>>>>>        If (sIdeSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "IdeSrcPath" ""    to sIdeSrcPath
8035>>>>>        If (sProgramPath ="") ;            Get ReadString of hoIniFile "Workspace" "ProgramPath" ""   to sProgramPath
8038>>>>>        If (sWorkspaceName ="") ;            Move (Left(sWsName, Length(sWsName) -3))                   to sWorkspaceName
8041>>>>>        If (sConnectionIni ="") ;            Get ReadString of hoIniFile "Workspace" "ConnectionIni" ""   to sConnectionIni
8044>>>>>        
8044>>>>>        If (sSystemDfPath ="") ;            Set psSystemDfPath   to (VdfSystemDfPath(Self))
8047>>>>>        If (sSystemMakePath ="") ;            Set psSystemMakePath to (VdfSystemMakePath(Self))
8050>>>>>        
8050>>>>>        Set psHome          to (FullPathNames(Self, sHome))
8051>>>>>        
8051>>>>>        // Set CWD to Home...
8051>>>>>        Move (SetCurrentDirectory(sHome)) to bSuccess
8052>>>>>        Set psAppSrcPath    to (FullPathNames(Self, sAppSrcPath))
8053>>>>>        Set psAppHtmlPath   to (FullPathNames(Self, sAppHtmlPath))
8054>>>>>        Set psBitmapPath    to (FullPathNames(Self, sBitmapPath))
8055>>>>>        Set psDataPath      to (FullPathNames(Self, sDataPath))
8056>>>>>        Set psDdSrcPath     to (FullPathNames(Self, sDdSrcPath))
8057>>>>>        Set psFileList      to (FullPathNames(Self, sFileList))
8058>>>>>        Set psHelpPath      to (FullPathNames(Self, sHelpPath))
8059>>>>>        Set psIdeSrcPath    to (FullPathNames(Self, sIdeSrcPath))
8060>>>>>        Set psProgramPath   to (FullPathNames(Self, sProgramPath))
8061>>>>>        Set psConnectionIni to (FullPathNames(Self, sConnectionIni))
8062>>>>>        
8062>>>>>        Set psWorkspaceName to sWorkspaceName
8063>>>>>        Set psDescription   to sDescription
8064>>>>>        
8064>>>>>        Send Destroy of hoIniFile // destroy dynaically created inifile object
8065>>>>>        
8065>>>>>        // Restore CWD...
8065>>>>>        Move (SetCurrentDirectory(sOldDirectory)) to sOldDirectory
8066>>>>>        
8066>>>>>        // Check for error conditions:
8066>>>>>        // DataPath and FileList must be defined; the FileList entry must point to a valid FileList.cfg
8066>>>>>        If (psDataPath(Self) = "") ;            Function_Return wsDataPathEmpty
8069>>>>>        If (psFileList(Self) = "") ;            Function_Return wsFileListEmpty
8072>>>>>        
8072>>>>>        Move (DoesFileExist(psFileList(Self))) to bExist
8073>>>>>        If (bExist = False) ;            Function_Return wsFileListNotExist
8076>>>>>        
8076>>>>>        If bChangingWorkspace ;            Close DF_ALL // if there is a WS open, we must close all the files
8079>>>>>        
8079>>>>>        Send DoAssignPaths // set psDfPath
8080>>>>>        Send DoSetPaths    // Set the application's Attributes of Filelist_Name and Open_Path
8081>>>>>        Set pbWorkspaceOpened to True
8082>>>>>        
8082>>>>>        Function_Return wsWorkspaceOpened
8083>>>>>    End_Function
8084>>>>>    
8084>>>>>    Function OpenWorkspace String sWorkspace Returns Integer
8086>>>>>        // Look in the Workspaces.ini file for the name, then open it by path
8086>>>>>        
8086>>>>>        Handle hoSections hoIniFile
8086>>>>>        Integer iWorkspace eOpened
8086>>>>>        String sWorkspaceName sPath
8086>>>>>        String sVdfRootDir
8086>>>>>        
8086>>>>>        Get Create U_Array    to hoSections
8087>>>>>        Get Create U_cIniFile to hoIniFile
8088>>>>>        
8088>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
8091>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
8094>>>>>        
8094>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
8095>>>>>        
8095>>>>>        Send ReadSections of hoIniFile hoSections
8096>>>>>        
8096>>>>>        For iWorkspace from 0 to (Item_Count(hoSections) -1)
8102>>>>>>
8102>>>>>            Get Value of hoSections iWorkspace to sWorkspaceName
8103>>>>>            If (Uppercase(sWorkspaceName) = Uppercase(sWorkspace)) Begin
8105>>>>>                Get ReadString of hoIniFile sWorkspace "Path" "" to sPath
8106>>>>>                If (Right(sPath,1) <>"\") ;                    Move (sPath +"\") to sPath
8109>>>>>                
8109>>>>>                Get OpenWorkspaceFile (sPath + sWorkspace) to eOpened
8110>>>>>                Send Destroy of hoSections
8111>>>>>                Send Destroy of hoIniFile
8112>>>>>                Function_Return eOpened
8113>>>>>            End
8113>>>>>>
8113>>>>>        Loop
8114>>>>>>
8114>>>>>        
8114>>>>>        Send Destroy of hoSections
8115>>>>>        Send Destroy of hoIniFile
8116>>>>>        Function_Return wsWorkspaceNotFound
8117>>>>>    End_Function
8118>>>>>    
8118>>>>>    Function IsRegistered String sWorkspace Returns Boolean
8120>>>>>        Boolean bRegistered
8120>>>>>        Handle hoIniFile
8120>>>>>        String sVdfRootDir
8120>>>>>        
8120>>>>>        Get Create U_cIniFile to hoIniFile
8121>>>>>        
8121>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
8124>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
8127>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
8128>>>>>        Move (SectionExists(hoIniFile, sWorkspace)) to bRegistered
8129>>>>>        
8129>>>>>        Send Destroy of hoIniFile
8130>>>>>        
8130>>>>>        Function_Return bRegistered
8131>>>>>    End_Function
8132>>>>>    
8132>>>>>    Function VdfSystemDfPath Returns String
8134>>>>>        String sSystemDfPath
8134>>>>>        Get_Profile_String "Workspaces" "SystemDfPath" to sSystemDfPath
8137>>>>>        
8137>>>>>        Function_Return sSystemDfPath
8138>>>>>    End_Function
8139>>>>>    
8139>>>>>    Function VdfSystemMakePath Returns String
8141>>>>>        String sSystemMakePath
8141>>>>>        Get_Profile_String "Workspaces" "SystemMakePath" to sSystemMakePath
8144>>>>>        
8144>>>>>        Function_Return sSystemMakePath
8145>>>>>    End_Function
8146>>>>>    
8146>>>>>    Procedure DoAssignPaths
8148>>>>>        String sDataPath sBitmapPath sHelpPath sProgramPath sSystemDfPath
8148>>>>>        
8148>>>>>        Get psDataPath     to sDataPath
8149>>>>>        Get psBitmapPath   to sBitmapPath
8150>>>>>        Get psHelpPath     to sHelpPath
8151>>>>>        Get psProgramPath  to sProgramPath
8152>>>>>        Get psSystemDfPath to sSystemDfPath
8153>>>>>        
8153>>>>>        Set psDfPath to (sDataPath +';' + sBitmapPath +';' + sHelpPath +';' + sProgramPath +';' + sSystemDfPath)
8154>>>>>        
8154>>>>>    End_Procedure
8155>>>>>    
8155>>>>>    Procedure DoSetPaths
8157>>>>>        // [JVH] must convert paths to Ansi before setting these values
8157>>>>>        // Note- this conversion is temporarily rolled back
8157>>>>>        //Set_Attribute DF_FILELIST_NAME To (ToAnsi(psFileList(self)))
8157>>>>>        //Set_Attribute DF_OPEN_PATH     To (ToAnsi(psDfPath(self)))
8157>>>>>        Set_Attribute DF_FILELIST_NAME to (psFileList(Self))
8160>>>>>        Set_Attribute DF_OPEN_PATH     to (psDfPath(Self))
8163>>>>>    End_Procedure
8164>>>>>    
8164>>>>>    Procedure EnumerateWorkspaceData Handle hoCallBack Handle hmGeneric
8166>>>>>        String sPath
8166>>>>>        
8166>>>>>        If (psWorkspaceName(Self)="") ;            Send hmGeneric to hoCallBack C_$WorkspaceNotUsed
8169>>>>>        Else Begin
8170>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceDesc, psDescription(Self)))
8171>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceName, psWorkspaceName(Self)))
8172>>>>>            Send hmGeneric to hoCallBack ""
8173>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$Filelist, psFileList(Self)))
8174>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$DataPath, psDataPath(Self)))
8175>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$ProgramPath, psProgramPath(Self)))
8176>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$HelpPath, psHelpPath(Self)))
8177>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$BitmapsPath, psBitmapPath(Self)))
8178>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$SystemPaths, psSystemDfPath(Self)))
8179>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$FullDFPath, psDfPath(Self)))
8180>>>>>        End
8180>>>>>>
8180>>>>>    End_Procedure
8181>>>>>    
8181>>>>>    Function OpenWorkspaceErrorMessage Integer eErrorCode Returns String
8183>>>>>        // Decodes the enumerated integer returned by OpenWorkspace and
8183>>>>>        // returns a corresponding message string.
8183>>>>>        String sError
8183>>>>>        
8183>>>>>        Case Begin
8183>>>>>            Case (eErrorCode = wsWorkspaceOpened)
8185>>>>>                Move C_$NoErrors to sError
8186>>>>>                Case Break
8187>>>>>            Case (eErrorCode = wsWorkspaceNotFound)
8190>>>>>                Move C_$NoWsName to sError
8191>>>>>                Case Break
8192>>>>>            Case (eErrorCode = wsWorkspaceFileNotFound)
8195>>>>>                Move C_$NoWsFileFound to sError
8196>>>>>                Case Break
8197>>>>>            Case (eErrorCode = wsDataPathEmpty)
8200>>>>>                Move C_$NoWsDataPath to sError
8201>>>>>                Case Break
8202>>>>>            Case (eErrorCode = wsFileListEmpty)
8205>>>>>                Move C_$NoWsFileList to sError
8206>>>>>                Case Break
8207>>>>>            Case (eErrorCode = wsFileListNotExist)
8210>>>>>                Move C_$NoFileListCfg to sError
8211>>>>>                Case Break
8212>>>>>            Case Else
8212>>>>>                Move C_$UnknownError to sError
8213>>>>>                Case Break
8214>>>>>        Case End
8214>>>>>        
8214>>>>>        Function_Return (sError-".")
8215>>>>>    End_Function
8216>>>>>    
8216>>>>>    Function GetWorkspaceFileName String sWorkspace Returns String
8218>>>>>        // Returns the name of the physical Workspace file for the passed Workspace name.
8218>>>>>        String sVdfRootDir
8218>>>>>        Handle hoIniFile
8218>>>>>        String sPath
8218>>>>>        String sFileName
8218>>>>>        String sWorkspacePath
8218>>>>>        
8218>>>>>        Move "" to sFileName
8219>>>>>        
8219>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
8222>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
8225>>>>>        
8225>>>>>        Get Create U_cIniFile to hoIniFile
8226>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
8227>>>>>        Get ReadString of hoIniFile sWorkspace "Path" "" to sWorkspacePath
8228>>>>>        If (sWorkspacePath <>"") Begin
8230>>>>>            If (Right(sWorkspacePath,1) <>"\") ;                Move (sWorkspacePath +"\") to sWorkspacePath
8233>>>>>            Move (sWorkspacePath +sWorkspace +".ws") to sFileName
8234>>>>>        End
8234>>>>>>
8234>>>>>        Send Destroy of hoIniFile
8235>>>>>        
8235>>>>>        Function_Return sFileName
8236>>>>>    End_Function
8237>>>>>    
8237>>>>>    Function CountOfPaths String sPaths Returns Integer
8239>>>>>        // Returns the number of paths defined in a string of paths
8239>>>>>        Integer iChar icChar icPath
8239>>>>>        
8239>>>>>        If (sPaths ="") ;            Function_Return 0
8242>>>>>        
8242>>>>>        Move (Length(sPaths) -1) to icChar
8243>>>>>        For iChar from 1 to icChar
8249>>>>>>
8249>>>>>            If (Mid(sPaths, 1, iChar) =";") ;                Increment icPath
8252>>>>>        Loop
8253>>>>>>
8253>>>>>        
8253>>>>>        Function_Return (icPath +1)
8254>>>>>    End_Function
8255>>>>>    
8255>>>>>    Function PathAtIndex String sPaths Integer iIndex Returns String
8257>>>>>        // Returns the path at the 1-based index of passed paths.
8257>>>>>        // If the path contains a trailing "\", it will be removed
8257>>>>>        Integer iChar icPath iPath iPos
8257>>>>>        String sPath
8257>>>>>        
8257>>>>>        Move (sPaths +";") to sPaths
8258>>>>>        For iPath from 1 to iIndex
8264>>>>>>
8264>>>>>            Move (Pos(";", sPaths)) to iPos
8265>>>>>            If iPos Begin
8267>>>>>                Move (Left(sPaths, iPos -1)) to sPath
8268>>>>>                If (Right(sPath,1) = '\') ;                    Move (Left(sPath, Length(sPath) -1)) to sPath
8271>>>>>                Move (Right(sPaths, Length(sPaths) -iPos)) to sPaths
8272>>>>>            End
8272>>>>>>
8272>>>>>            Else ;                Function_Return "" // index past number of paths
8274>>>>>        Loop
8275>>>>>>
8275>>>>>        
8275>>>>>        Function_Return sPath
8276>>>>>    End_Function
8277>>>>>    
8277>>>>>End_Class
8278>>>Use cCommandLine.pkg
Including file: cCommandLine.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCommandLine.pkg)
8278>>>>>Use VDFBase.pkg
8278>>>>>
8278>>>>>Class cCommandLine is a cObject
8279>>>>>    
8279>>>>>    Procedure Construct_Object
8281>>>>>        Forward Send Construct_Object
8283>>>>>        
8283>>>>>        Property Handle phoArgs // private object-handle of internal array of arguments
8284>>>>>    End_Procedure
8285>>>>>    
8285>>>>>    Procedure Private_DoCreateArgsArray
8287>>>>>        // creates the array for holding the arguments. Created upon demand only!
8287>>>>>        Integer icArg
8287>>>>>        String sArg
8287>>>>>        
8287>>>>>        Object oArgs is an Array
8289>>>>>            Delegate Set phoArgs to Self
8291>>>>>            Repeat
8291>>>>>>
8291>>>>>                CmdLine sArg
8292>>>>>>
8292>>>>>                If (sArg <> "") Begin
8294>>>>>                    Increment icArg
8295>>>>>                    Set Value  (icArg -1) to sArg
8296>>>>>                End
8296>>>>>>
8296>>>>>            Until (sArg = "")
8298>>>>>        End_Object
8299>>>>>    End_Procedure
8300>>>>>    
8300>>>>>    Function CountOfArgs Returns Integer
8302>>>>>        //Returns the number of arguments passed
8302>>>>>        If (phoArgs(Self) =0) ;            Send Private_DoCreateArgsArray
8305>>>>>        Function_Return (Item_Count(phoArgs(Self)))
8306>>>>>    End_Function
8307>>>>>    
8307>>>>>    Function Argument Integer iIndex Returns String
8309>>>>>        //Returns the one-based argument string
8309>>>>>        If (phoArgs(Self) =0) ;            Send Private_DoCreateArgsArray
8312>>>>>        Function_Return (Value(phoArgs(Self), iIndex -1))
8313>>>>>    End_Function
8314>>>>>    
8314>>>>>End_Class
8315>>>>>
8315>>>Use cRegistry.pkg
Including file: cRegistry.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cRegistry.pkg)
8315>>>>>Use Dll.pkg
8315>>>>>Use RegistryAPI.pkg
8315>>>>>
8315>>>>>Enum_List // Registry Data types
8315>>>>>    Define rdString
8315>>>>>    Define rdDword
8315>>>>>    Define rdBinary
8315>>>>>    Define rdUnknown
8315>>>>>End_Enum_List
8315>>>>>
8315>>>>>//Prototypes
8315>>>>>Register_Function phRootKey      Returns Handle // HKEY_CURRENT_USER
8315>>>>>Register_Function pfAccessRights Returns Integer // KEY_ALL_ACCESS - what access level should be used to open a Key?
8315>>>>>Register_Function phCurrentKey   Returns Handle // low-level key
8315>>>>>Register_Function pbLazyWrite    Returns Boolean // True
8315>>>>>
8315>>>>>Register_Function CountOfSubkeys      Returns Integer
8315>>>>>Register_Function CountOfValues       Returns Integer
8315>>>>>Register_Function CreateKey           String sKeyName Returns Integer   // return=error code
8315>>>>>Register_Function DeleteKey           String sKeyName Returns Boolean       // Deleted successfully?
8315>>>>>Register_Function DeleteValue         String sValueName Returns Boolean // Deleted successfully?
8315>>>>>Register_Function GetSubkeys          Handle hoArray Returns Integer    // count of Subkeys
8315>>>>>Register_Function GetValues           Handle hoArray Returns Integer    // count of Values
8315>>>>>Register_Function KeyExists           String sKeyName Returns Boolean   // does the key exist?
8315>>>>>Register_Function LongestDataLength   Returns Integer
8315>>>>>Register_Function LongestSubkeyLength Returns Integer
8315>>>>>Register_Function LongestValueLength  Returns Integer
8315>>>>>Register_Function OpenKey             String sKeyName Returns Integer
8315>>>>>Register_Function ReadBinary          String sValueName Address aValueData Integer iDataLength Returns Boolean
8315>>>>>Register_Function ReadDword           String sValueName Returns DWord
8315>>>>>Register_Function ReadString          String sValueName Returns String
8315>>>>>Register_Function ValueExists         String sValueName Returns Integer // does the Value exist?
8315>>>>>Register_Function ValueLength         String sValueName Returns Integer
8315>>>>>Register_Function ValueType           String sValueName Returns Integer // what is the datatype of the Value?
8315>>>>>Register_Procedure CloseKey
8315>>>>>Register_Procedure WriteBinary        String sValueName Address aValueData Integer iDataLength
8315>>>>>Register_Procedure WriteDword         String sValue DWord dwValueData
8315>>>>>Register_Procedure WriteString        String sValue String sValueData
8315>>>>>
8315>>>>>
8315>>>>>Class cRegistry is a cObject
8316>>>>>    Procedure Construct_Object
8318>>>>>        Forward Send Construct_Object
8320>>>>>        
8320>>>>>        Property Handle phRootKey HKEY_CURRENT_USER
8321>>>>>        Property UInteger pfAccessRights  KEY_ALL_ACCESS // what access level should be used to open a Key?
8322>>>>>        Property Handle phCurrentKey
8323>>>>>        Property Boolean pbLazyWrite True
8324>>>>>    End_Procedure
8325>>>>>    
8325>>>>>    Function CountOfSubkeys Returns Integer
8327>>>>>        DWord dwCountOfSubkeys
8327>>>>>        Integer iError
8327>>>>>        String sError
8327>>>>>        
8327>>>>>        Move 0 to dwCountOfSubkeys
8328>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, AddressOf(dwCountOfSubkeys), 0, 0, 0, 0, 0, 0, 0)) to iError
8329>>>>>        If iError Begin
8331>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8332>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8333>>>>>>
8333>>>>>        End
8333>>>>>>
8333>>>>>        Function_Return dwCountOfSubkeys
8334>>>>>    End_Function
8335>>>>>    
8335>>>>>    Function CountOfValues Returns Integer
8337>>>>>        DWord dwCountOfValues
8337>>>>>        Integer iError
8337>>>>>        String sError
8337>>>>>        
8337>>>>>        Move 0 to dwCountOfValues
8338>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, AddressOf(dwCountOfValues), 0, 0, 0, 0)) to iError
8339>>>>>        If iError Begin
8341>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8342>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8343>>>>>>
8343>>>>>        End
8343>>>>>>
8343>>>>>        
8343>>>>>        Function_Return dwCountOfValues
8344>>>>>    End_Function
8345>>>>>    
8345>>>>>    Function LongestSubkeyLength Returns Integer
8347>>>>>        DWord dwLongestSubkeyLength
8347>>>>>        Integer iError
8347>>>>>        String sError
8347>>>>>        
8347>>>>>        Move 0 to dwLongestSubkeyLength
8348>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, 0, AddressOf(dwLongestSubkeyLength), 0, 0, 0, 0, 0, 0)) to iError
8349>>>>>        If iError Begin
8351>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8352>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8353>>>>>>
8353>>>>>        End
8353>>>>>>
8353>>>>>        
8353>>>>>        Function_Return dwLongestSubkeyLength
8354>>>>>    End_Function
8355>>>>>    
8355>>>>>    Function LongestValueLength Returns Integer
8357>>>>>        DWord dwLongestValueLength
8357>>>>>        Integer iError
8357>>>>>        String sError
8357>>>>>        
8357>>>>>        Move 0 to dwLongestValueLength
8358>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestValueLength), 0, 0, 0)) to iError
8359>>>>>        If iError Begin
8361>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8362>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8363>>>>>>
8363>>>>>        End
8363>>>>>>
8363>>>>>        
8363>>>>>        Function_Return dwLongestValueLength
8364>>>>>    End_Function
8365>>>>>    
8365>>>>>    Function LongestDataLength Returns Integer
8367>>>>>        DWord dwLongestDataLength
8367>>>>>        Integer iError
8367>>>>>        String sError
8367>>>>>        
8367>>>>>        Move 0 to dwLongestDataLength
8368>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestDataLength), 0, 0)) to iError
8369>>>>>        If iError Begin
8371>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8372>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8373>>>>>>
8373>>>>>        End
8373>>>>>>
8373>>>>>        
8373>>>>>        Function_Return dwLongestDataLength
8374>>>>>    End_Function
8375>>>>>    
8375>>>>>    Function ValueType String sValueName Returns Integer
8377>>>>>        DWord dwType
8377>>>>>        Integer iError eType
8377>>>>>        String sError
8377>>>>>        
8377>>>>>        Move 0 to dwType
8378>>>>>        Move (RegQueryValueEx(phCurrentKey(Self), ToAnsi(sValueName), 0, AddressOf(dwType), 0, 0)) to iError
8379>>>>>        If iError Begin
8381>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8382>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8383>>>>>>
8383>>>>>        End
8383>>>>>>
8383>>>>>        
8383>>>>>        If (dwType = REG_SZ) ;            Move rdString to eType
8386>>>>>        Else If (dwType = REG_DWORD)  ;            Move rdDword to eType
8390>>>>>        Else If (dwType = REG_BINARY) ;            Move rdBinary to eType
8394>>>>>        Else ;            Move rdUnknown to eType
8396>>>>>        
8396>>>>>        Function_Return eType
8397>>>>>    End_Function
8398>>>>>    
8398>>>>>    Function ValueLength String sValueName Returns Integer
8400>>>>>        DWord dwSize
8400>>>>>        Integer iError
8400>>>>>        String sError
8400>>>>>        
8400>>>>>        Move 0 to dwSize
8401>>>>>        Move (RegQueryValueEx(phCurrentKey(Self), ToAnsi(sValueName), 0, 0, 0, AddressOf(dwSize))) to iError
8402>>>>>        If iError Begin
8404>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8405>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8406>>>>>>
8406>>>>>        End
8406>>>>>>
8406>>>>>        
8406>>>>>        Function_Return dwSize
8407>>>>>    End_Function
8408>>>>>    
8408>>>>>    Function CreateKey String sKeyName Returns Integer // return=error code
8410>>>>>        // Calling CreateKey for an existing Key, merely opens it without error.
8410>>>>>        Handle hKey hKeyOpened
8410>>>>>        Integer iError
8410>>>>>        String sError
8410>>>>>        
8410>>>>>        Move 0 to hKeyOpened // initialize it so we can get its address
8411>>>>>        
8411>>>>>        Get phRootKey to hKey
8412>>>>>        
8412>>>>>        Move (RegCreateKeyEx(hKey, ToAnsi(sKeyName), 0, 0, REG_OPTION_NON_VOLATILE, pfAccessRights(Self), 0, AddressOf(hKeyOpened), 0)) to iError
8413>>>>>        If (iError =0) ;            Set phCurrentKey to hKeyOpened
8416>>>>>        Else Begin
8417>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8418>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8419>>>>>>
8419>>>>>        End
8419>>>>>>
8419>>>>>        Function_Return iError
8420>>>>>    End_Function
8421>>>>>    
8421>>>>>    Procedure CloseKey
8423>>>>>        Integer iError
8423>>>>>        Handle hKey
8423>>>>>        
8423>>>>>        Get phCurrentKey to hKey
8424>>>>>        
8424>>>>>        If (hKey <>0) Begin
8426>>>>>            If (pbLazyWrite(Self)) ;                Move (RegCloseKey(hKey)) to iError
8429>>>>>            Else ;                Move (RegFlushKey(hKey)) to iError
8431>>>>>            
8431>>>>>            Set phCurrentKey to 0
8432>>>>>        End
8432>>>>>>
8432>>>>>    End_Procedure
8433>>>>>    
8433>>>>>    Function OpenKey String sKeyName Returns Boolean
8435>>>>>        Handle hKey hKeyOpened
8435>>>>>        Integer iError
8435>>>>>        
8435>>>>>        Move 0 to hKeyOpened // initialize it so we can get its address
8436>>>>>        
8436>>>>>        Get phRootKey to hKey
8437>>>>>        Move (RegOpenKeyEx(hKey, ToAnsi(sKeyName), 0, pfAccessRights(Self), AddressOf(hKeyOpened))) to iError
8438>>>>>        If (iError =0) ;            Set phCurrentKey to hKeyOpened
8441>>>>>        
8441>>>>>        Function_Return (iError=0)
8442>>>>>    End_Function
8443>>>>>    
8443>>>>>    Procedure WriteDword String sValue DWord dwValueData
8445>>>>>        Handle hKey
8445>>>>>        Integer iError
8445>>>>>        DWord dwData
8445>>>>>        String sError
8445>>>>>        
8445>>>>>        Move dwValueData to dwData
8446>>>>>        Get phCurrentKey to hKey
8447>>>>>        Move (RegSetValueEx(hKey, ToAnsi(sValue), 0, REG_DWORD, AddressOf(dwData), SizeOfType(DWord))) to iError
8448>>>>>        If iError Begin
8450>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8451>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8452>>>>>>
8452>>>>>        End
8452>>>>>>
8452>>>>>    End_Procedure
8453>>>>>    
8453>>>>>    Procedure WriteString String sValue String sValueData
8455>>>>>        Handle hKey
8455>>>>>        Integer iError cbData
8455>>>>>        String sError
8455>>>>>        
8455>>>>>        If (sValueData = "") Begin
8457>>>>>            Move (Character(0)) to sValueData
8458>>>>>            Move 1 to cbData
8459>>>>>        End
8459>>>>>>
8459>>>>>        Else Begin
8460>>>>>            Move (Length(sValueData) +1) to cbData
8461>>>>>        End
8461>>>>>>
8461>>>>>        Move (ToAnsi(sValueData)) to sValueData
8462>>>>>        Get phCurrentKey to hKey
8463>>>>>        Move (RegSetValueEx(hKey, ToAnsi(sValue), 0, REG_SZ, AddressOf(sValueData), cbData)) to iError
8464>>>>>        If iError Begin
8466>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8467>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8468>>>>>>
8468>>>>>        End
8468>>>>>>
8468>>>>>    End_Procedure
8469>>>>>    
8469>>>>>    Procedure WriteBinary String sValueName Address aValueData Integer iDataLength
8471>>>>>        Handle hKey
8471>>>>>        Integer iError
8471>>>>>        String sError
8471>>>>>        
8471>>>>>        Get phCurrentKey to hKey
8472>>>>>        Move (RegSetValueEx(hKey, ToAnsi(sValueName), 0, REG_BINARY, aValueData, iDataLength)) to iError
8473>>>>>        If iError Begin
8475>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8476>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8477>>>>>>
8477>>>>>        End
8477>>>>>>
8477>>>>>    End_Procedure
8478>>>>>    
8478>>>>>    Function ReadDword String sValueName Returns DWord
8480>>>>>        Handle hKey
8480>>>>>        Integer iError
8480>>>>>        DWord dwValueData dwValueDataLength
8480>>>>>        String sError
8480>>>>>        
8480>>>>>        Move 0           to dwValueData
8481>>>>>        Move (SizeOfType(DWord)) to dwValueDataLength
8482>>>>>        
8482>>>>>        Get phCurrentKey to hKey
8483>>>>>        Move (RegQueryValueEx(hKey, ToAnsi(sValueName), 0, 0, AddressOf(dwValueData), AddressOf(dwValueDataLength))) to iError
8484>>>>>        If iError Begin
8486>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8487>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8488>>>>>>
8488>>>>>        End
8488>>>>>>
8488>>>>>        
8488>>>>>        Function_Return dwValueData
8489>>>>>    End_Function
8490>>>>>    
8490>>>>>    Function ReadString String sValueName Returns String
8492>>>>>        Handle hKey
8492>>>>>        Integer iError
8492>>>>>        String sValueData
8492>>>>>        DWord dwValueDataLength
8492>>>>>        Pointer lpsValueData
8492>>>>>        String sError
8492>>>>>        
8492>>>>>        Move (Repeat(character(0), ValueLength(Self, sValueName))) to sValueData
8493>>>>>        Move (AddressOf(sValueData)) to lpsValueData
8494>>>>>        
8494>>>>>        Move (Length(sValueData)) to dwValueDataLength
8495>>>>>        
8495>>>>>        Get phCurrentKey to hKey
8496>>>>>        Move (RegQueryValueEx(hKey, ToAnsi(sValueName), 0, 0, lpsValueData, AddressOf(dwValueDataLength))) to iError
8497>>>>>        If iError Begin
8499>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8500>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8501>>>>>>
8501>>>>>        End
8501>>>>>>
8501>>>>>        
8501>>>>>        Function_Return (ToOem(CString(sValueData)))
8502>>>>>    End_Function
8503>>>>>    
8503>>>>>    Function ReadBinary String sValueName Address aValueData Integer iDataLength Returns Boolean
8505>>>>>        Handle hKey
8505>>>>>        Integer iError
8505>>>>>        String sError
8505>>>>>        
8505>>>>>        Get phCurrentKey to hKey
8506>>>>>        Move (RegQueryValueEx(hKey, ToAnsi(sValueName), 0, 0, aValueData, AddressOf(iDataLength))) to iError
8507>>>>>        If iError Begin
8509>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8510>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8511>>>>>>
8511>>>>>        End
8511>>>>>>
8511>>>>>        
8511>>>>>        Function_Return (iDataLength >0)
8512>>>>>    End_Function
8513>>>>>    
8513>>>>>    
8513>>>>>    // Private....
8513>>>>>    Function GetBaseKey Returns Handle
8515>>>>>        Handle hBaseKey
8515>>>>>        If (phCurrentKey(Self) = 0) ;            Get phRootKey to hBaseKey
8518>>>>>        Else ;            Get phCurrentKey to hBaseKey
8520>>>>>        
8520>>>>>        Function_Return hBaseKey
8521>>>>>    End_Function
8522>>>>>    
8522>>>>>    Function GetKey String sKeyName Returns Handle
8524>>>>>        Handle hKeyOpened
8524>>>>>        Integer iError
8524>>>>>        
8524>>>>>        Move 0 to hKeyOpened // initialize so we can get its address
8525>>>>>        
8525>>>>>        Move (RegOpenKeyEx(GetBaseKey(Self), ToAnsi(sKeyName), 0, pfAccessRights(Self), AddressOf(hKeyOpened))) to iError
8526>>>>>        
8526>>>>>        If (iError =0) ;            Function_Return hKeyOpened
8529>>>>>        Else ;            Function_Return 0
8531>>>>>    End_Function
8532>>>>>    
8532>>>>>    // Public
8532>>>>>    Function KeyExists String sKeyName Returns Boolean
8534>>>>>        Handle hKey
8534>>>>>        Integer iVoid
8534>>>>>        
8534>>>>>        Get GetKey sKeyName to hKey
8535>>>>>        If hKey ;            Move (RegCloseKey(hKey)) to iVoid
8538>>>>>        Function_Return (hKey <>0)
8539>>>>>    End_Function
8540>>>>>    
8540>>>>>    Function ValueExists String sValueName Returns Boolean
8542>>>>>        // Determines whether a Value exists for the currently-opened Key.
8542>>>>>        Integer iError
8542>>>>>        DWord dwDataType
8542>>>>>        Move 0 to dwDataType // must initialize the variable to get its address
8543>>>>>        
8543>>>>>        Move (RegQueryValueEx(phCurrentKey(Self), ToAnsi(sValueName), 0, AddressOf(dwDataType), 0, 0)) to iError
8544>>>>>        
8544>>>>>        Function_Return (iError=0)
8545>>>>>    End_Function
8546>>>>>    
8546>>>>>    Function DeleteKey String sKeyName Returns Boolean // Deleted successfully?
8548>>>>>        Function_Return (ShDeleteKey(phRootKey(Self), ToAnsi(sKeyName)) =0)
8549>>>>>    End_Function
8550>>>>>    
8550>>>>>    Function DeleteValue String sValueName Returns Boolean // Deleted successfully?
8552>>>>>        Function_Return (RegDeleteValue(phCurrentKey(Self), ToAnsi(sValueName)) =0)
8553>>>>>    End_Function
8554>>>>>    
8554>>>>>    Function GetSubkeys Handle hoArray Returns Integer // count of Values
8556>>>>>        Integer iError
8556>>>>>        Integer icValue iLongestSubkey
8556>>>>>        Handle hKey
8556>>>>>        DWord dwSubkeyNameLength
8556>>>>>        String sSubkeyName
8556>>>>>        tWinFileTime FileTime
8556>>>>>        tWinFileTime FileTime
8556>>>>>        
8556>>>>>        Get LongestSubkeyLength to iLongestSubkey
8557>>>>>        Move (Repeat(character(0), iLongestSubkey +1)) to sSubkeyName
8558>>>>>        
8558>>>>>        Get phCurrentKey to hKey
8559>>>>>        Repeat
8559>>>>>>
8559>>>>>            Move (iLongestSubkey +1) to dwSubkeyNameLength
8560>>>>>            
8560>>>>>            Move (RegEnumKeyEx(hKey, icValue, AddressOf(sSubkeyName), AddressOf(dwSubkeyNameLength), 0, 0, 0, AddressOf(FileTime))) to iError
8561>>>>>            If (iError =0) Begin
8563>>>>>                Increment icValue
8564>>>>>                Set Value of hoArray (Item_Count(hoArray)) to (ToOem(CString(sSubkeyName)))
8565>>>>>            End
8565>>>>>>
8565>>>>>        Until (iError)
8567>>>>>        Function_Return icValue
8568>>>>>        
8568>>>>>    End_Function
8569>>>>>    
8569>>>>>    Function GetValues Handle hoArray Returns Integer // count of Values
8571>>>>>        Integer iError
8571>>>>>        Integer icValue iLongestValue
8571>>>>>        Handle hKey
8571>>>>>        DWord dwValueNameLength
8571>>>>>        String sValueName sValueNameSize
8571>>>>>        Pointer lpsValueName
8571>>>>>        
8571>>>>>        Get LongestValueLength to iLongestValue
8572>>>>>        Move (Repeat(character(0), iLongestValue +1)) to sValueName
8573>>>>>        Move (AddressOf(sValueName)) to lpsValueName
8574>>>>>        
8574>>>>>        Get phCurrentKey to hKey
8575>>>>>        Repeat
8575>>>>>>
8575>>>>>            Move (iLongestValue +1) to dwValueNameLength
8576>>>>>            Move (RegEnumValue(hKey, icValue, lpsValueName, AddressOf(dwValueNameLength), 0, 0, 0, 0)) to iError
8577>>>>>            If (iError =0) Begin
8579>>>>>                Increment icValue
8580>>>>>                Set Value of hoArray (Item_Count(hoArray)) to (ToOem(CString(sValueName)))
8581>>>>>            End
8581>>>>>>
8581>>>>>        Until (iError)
8583>>>>>        Function_Return icValue
8584>>>>>        
8584>>>>>    End_Function
8585>>>>>    
8585>>>>>End_Class
8586>>>Use cVersionInfo.pkg
Including file: cVersionInfo.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cVersionInfo.pkg)
8586>>>>>Use VdfBase.pkg
8586>>>>>Use DLL.pkg
8586>>>>>Use tWinStructs.pkg
8586>>>>>Use WinKern.pkg
8586>>>>>
8586>>>>>Define VS_FF_DEBUG         for |CI$00000001
8586>>>>>Define VS_FF_PRERELEASE    for |CI$00000002
8586>>>>>Define VS_FF_PATCHED       for |CI$00000004
8586>>>>>Define VS_FF_PRIVATEBUILD  for |CI$00000008
8586>>>>>Define VS_FF_INFOINFERRED  for |CI$00000010
8586>>>>>Define VS_FF_SPECIALBUILD  for |CI$00000020
8586>>>>>
8586>>>>>External_Function GetFileVersionInfoSize "GetFileVersionInfoSizeA" version.dll ;    Pointer aFilename ;    Pointer lpdwHandle ;    Returns DWord
8587>>>>>
8587>>>>>External_Function GetFileVersionInfo "GetFileVersionInfoA" version.dll ;    Pointer sFilename ;    DWord dwHandle ;    DWord dwLen ;    Address aData ;    Returns Integer
8588>>>>>
8588>>>>>External_Function VerQueryValue "VerQueryValueA" version.dll ;    Address aBlock ;    Address aSubBlock ;    Address aaBuffer ;    Address puLen ;    Returns Integer
8589>>>>>
8589>>>>>
8589>>>>>Class cVersionInfo is a cObject
8590>>>>>    Procedure Construct_Object
8592>>>>>        Forward Send Construct_Object
8594>>>>>        
8594>>>>>        
8594>>>>>        Property Integer piVersionMajor
8595>>>>>        Property Integer piVersionMinor
8596>>>>>        Property Integer piVersionRelease
8597>>>>>        Property Integer piVersionBuild
8598>>>>>        
8598>>>>>        Property Boolean pbIncluded
8599>>>>>        Property Boolean pbSpecialBuild
8600>>>>>        Property Boolean pbPrivateBuild
8601>>>>>        
8601>>>>>    End_Procedure
8602>>>>>    
8602>>>>>    Procedure DoCreate String sFileName
8604>>>>>        DWord dwHandle
8604>>>>>        Integer iInfoSize iVerSize iSuccess iVersion iVoid iFlags
8604>>>>>        String sData
8604>>>>>        String sVersionBuffer
8604>>>>>        tWinVs_FixedFileInfo VsFixedFileInfo
8604>>>>>        tWinVs_FixedFileInfo VsFixedFileInfo
8604>>>>>        String sSubBlock
8604>>>>>        Address aVsFixedFileInfo
8604>>>>>        
8604>>>>>        Move 0 to aVsFixedFileInfo
8605>>>>>        Move 0 to dwHandle
8606>>>>>        Move 0 to iVerSize
8607>>>>>        
8607>>>>>        Move (GetFileVersionInfoSize(AddressOf(sFilename), AddressOf(dwHandle))) to iInfoSize
8608>>>>>        Set pbIncluded to (iInfoSize <>0)
8609>>>>>        
8609>>>>>        If (pbIncluded(Self)) Begin
8611>>>>>            Move (Repeat(Character(0), iInfoSize)) to sData
8612>>>>>            Move (GetFileVersionInfo(AddressOf(sFilename), 0, iInfoSize, AddressOf(sData))) to iSuccess
8613>>>>>            
8613>>>>>            If (iSuccess <>0) Begin
8615>>>>>                Move "\" to sSubBlock
8616>>>>>                If (VerQueryValue(AddressOf(sData), AddressOf(sSubBlock), AddressOf(aVsFixedFileInfo), AddressOf(iVerSize))) Begin
8618>>>>>                    Move (memcopy(AddressOf(VsFixedFileInfo), aVsFixedFileInfo, iVerSize)) to iVoid // copy the structure
8619>>>>>                    
8619>>>>>                    Move VsFixedFileInfo.dwFileVersionMS to iVersion
8620>>>>>                    Set piVersionMajor to (Hi(iVersion))
8621>>>>>                    Set piVersionMinor to (Low(iVersion))
8622>>>>>                    
8622>>>>>                    Move VsFixedFileInfo.dwFileVersionLS to iVersion
8623>>>>>                    Set piVersionRelease to (Hi(iVersion))
8624>>>>>                    Set piVersionBuild   to (Low(iVersion))
8625>>>>>                    
8625>>>>>                    Move VsFixedFileInfo.dwFileFlags to iFlags
8626>>>>>                    Set pbSpecialBuild    to (iFlags iand VS_FF_SPECIALBUILD)
8627>>>>>                    Set pbPrivateBuild    to (iFlags iand VS_FF_PRIVATEBUILD)
8628>>>>>                End
8628>>>>>>
8628>>>>>            End
8628>>>>>>
8628>>>>>            
8628>>>>>        End
8628>>>>>>
8628>>>>>    End_Procedure
8629>>>>>    
8629>>>>>End_Class
8630>>>Use GlobalFunctionsProcedures.pkg
8630>>>Use tWinStructs.pkg
8630>>>Use HelpSystemConstants.pkg // constants used by help system (not used by web)
8630>>>
8630>>>Register_Function phoWorkspace Returns Handle
8630>>>Register_Function phoCommandLine Returns Handle
8630>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
8630>>>Register_Function GetApplicationName Returns String
8630>>>Register_Function GetApplicationFileName Returns String
8630>>>
8630>>>Register_Function Statusbar_State Returns Integer
8630>>>Register_Function Toolbar_State Returns Integer
8630>>>Register_Procedure Set Statusbar_State
8630>>>Register_Procedure Set Toolbar_State
8630>>>
8630>>>
8630>>>Class cApplication is a cObject
8631>>>    Procedure Construct_Object
8633>>>        Forward Send Construct_Object
8635>>>        
8635>>>        Move Self to ghoApplication
8636>>>        
8636>>>        Property Handle phoVersionInfo
8637>>>        Property Handle phoWorkspace
8638>>>        Property Handle phoCommandLine
8639>>>        Property Handle phoMainPanel       // main panel will set this for us.
8640>>>        Property String psHelpFile         // type of file is determined by peHelpType
8641>>>        Property Integer peHelpType htWinHelp // htNoHelp htHtmlHelp htWinHelp
8642>>>        
8642>>>        Property String psCompany "Data Access Worldwide"
8643>>>        Property String psProduct "DataFlex Applications"
8644>>>        Property String psVersion C_DFVersion
8645>>>        Property String psProgram (Module_Name(desktop))
8646>>>        
8646>>>        // set to '' to stop the auto open workspace behavior
8646>>>        Property String psAutoOpenWorkspace 'Config.ws'
8647>>>        
8647>>>        
8647>>>        Property Boolean pbPreserveEnvironment True
8648>>>        
8648>>>        Object oCommandLine is a cCommandLine
8650>>>            Delegate Set phoCommandLine to Self
8652>>>        End_Object
8653>>>        
8653>>>        Object oWorkspace is a cWorkspace
8655>>>            Delegate Set phoWorkspace to Self
8657>>>        End_Object
8658>>>        
8658>>>        Object oVersionInfo is a cVersionInfo
8660>>>            Delegate Set phoVersionInfo to Self
8662>>>            Send DoCreate (GetApplicationFileName(parent(Self)))
8663>>>        End_Object
8664>>>        
8664>>>        Set pbUseWindowsFont to True
8665>>>        
8665>>>    End_Procedure
8666>>>    
8666>>>    Procedure Destroy_Object
8668>>>        If (ghoApplication=Self) Begin
8670>>>            Move 0 to ghoApplication
8671>>>        End
8671>>>>
8671>>>        Forward Send Destroy_Object
8673>>>    End_Procedure
8674>>>    
8674>>>    // Determines if the Enter key should act like the Tab key (and send msg_Next)
8674>>>    // The use of a global variable, gbKEnterNext, makes this an application-wide property
8674>>>    Procedure Set pbEnterKeyAsTabKey Boolean bNext
8676>>>        Move bNext to gbKEnterNext
8677>>>    End_Procedure
8678>>>    
8678>>>    Function pbEnterKeyAsTabKey Returns Boolean
8680>>>        Function_Return gbKEnterNext
8681>>>    End_Function
8682>>>    
8682>>>    Procedure DoLoadEnvironment Handle hoContainer Boolean bProgram
8684>>>// not used with webapp
8684>>>        Handle hoRegistry hoCommandBars
8684>>>        Handle hMonitor
8684>>>        Integer iError cxy
8684>>>        tWinWindowPlacement WindowPlacement
8684>>>        tWinWindowPlacement WindowPlacement
8684>>>        String sKey
8684>>>        Boolean bSuccess
8684>>>        String sObjectName
8684>>>        
8684>>>        If (pbPreserveEnvironment(Self)) Begin
8686>>>            Get Create U_cRegistry to hoRegistry
8687>>>            Set pfAccessRights of hoRegistry to KEY_READ
8688>>>            
8688>>>            Get RegistryKeyString to sKey
8689>>>            
8689>>>            If (bProgram = False) Begin
8691>>>                Move (sKey +"\WINDOWS") to sKey
8692>>>                Get Object_Label of hoContainer to sObjectName  // just get the local name
8693>>>                Move (sKey +"\" +sObjectName) to sKey
8694>>>            End
8694>>>>
8694>>>            Else ;                Move (sKey + "\Preferences") to sKey
8696>>>            
8696>>>            Get OpenKey of hoRegistry sKey to bSuccess
8697>>>            
8697>>>            If bSuccess Begin
8699>>>                If (ValueExists(hoRegistry, 'Placement')) Begin
8701>>>                    Get ReadBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) (SizeOfType(tWinWindowPlacement)) to bSuccess
8702>>>                    If bSuccess Begin
8704>>>                        // Do not restore size if the window is not resizable
8704>>>                        If (Border_Style(hoContainer) <> BORDER_THICK) Begin
8706>>>                            // restore always works with outer size
8706>>>                            Get GuiWindowSize     of hoContainer to cxy
8707>>>                            Move (WindowPlacement.NormalPosition.left + Low(cxy)) to WindowPlacement.NormalPosition.right
8708>>>                            Move (WindowPlacement.NormalPosition.top + Hi(cxy)) to WindowPlacement.NormalPosition.bottom
8709>>>                        End
8709>>>>
8709>>>                        
8709>>>                        // Test that the main window's placement location will appear on some connected monitor. If none
8709>>>                        // of the main window is visible then set the location to 0,0 and adjust the size....
8709>>>                        If (bProgram) Begin
8711>>>                            // Test the top left point
8711>>>                            Move (MonitorFromPoint(WindowPlacement.NormalPosition.left, WindowPlacement.NormalPosition.top, MONITOR_DEFAULTONNULL)) to hMonitor
8712>>>                            
8712>>>                            If (hMonitor = 0) Begin
8714>>>                                // test the bottom right point
8714>>>                                Move (MonitorFromPoint(WindowPlacement.NormalPosition.right, WindowPlacement.NormalPosition.bottom, MONITOR_DEFAULTONNULL)) to hMonitor
8715>>>                            End
8715>>>>
8715>>>                            
8715>>>                            // hMonitor = 0 means that the window location is not in any current monitor (probably the monitor layout has changed)
8715>>>                            // or that the window begins and ends outside all monitors (even though it may span across some monitor). We will adjust!
8715>>>                            If (hMonitor = 0) Begin
8717>>>                                Send ResetWindowPos (&WindowPlacement.NormalPosition)
8718>>>                            End
8718>>>>
8718>>>                        End
8718>>>>
8718>>>                        
8718>>>                        // Set the placement
8718>>>                        Move (SetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
8719>>>                    End
8719>>>>
8719>>>                End
8719>>>>
8719>>>                If bProgram Begin
8721>>>                    Get phoCommandBars of hoContainer to hoCommandBars
8722>>>                    If not hoCommandBars Begin
8724>>>                        If (ValueExists(hoRegistry, 'IsStatusBarVisible')) ;                            Set Statusbar_State of hoContainer to (ReadDword(hoRegistry, 'IsStatusBarVisible'))
8727>>>                        If (ValueExists(hoRegistry, 'IsToolBarVisible'))   ;                            Set Toolbar_State   of hoContainer to (ReadDword(hoRegistry, 'IsToolBarVisible'))
8730>>>                    End
8730>>>>
8730>>>                End
8730>>>>
8730>>>                
8730>>>                Send CloseKey of hoRegistry
8731>>>            End
8731>>>>
8731>>>            
8731>>>            Send Destroy of hoRegistry
8732>>>        End
8732>>>>
8732>>>    End_Procedure
8733>>>    
8733>>>    Procedure DoSaveEnvironment Handle hoContainer Boolean bProgram
8735>>>// not used with webapp
8735>>>        Handle hoRegistry
8735>>>        Integer iError
8735>>>        tWinWindowPlacement WindowPlacement
8735>>>        tWinWindowPlacement WindowPlacement
8735>>>        String sKey
8735>>>        Boolean bSuccess
8735>>>        Integer eShowCmd
8735>>>        String sObjectName
8735>>>        
8735>>>        If (pbPreserveEnvironment(Self)) Begin
8737>>>            Get Create U_cRegistry to hoRegistry
8738>>>            Get RegistryKeyString to sKey
8739>>>            
8739>>>            If (bProgram = False) Begin
8741>>>                Move (sKey +"\WINDOWS") to sKey
8742>>>                Get Object_Label of hoContainer to sObjectName  // just get the local name
8743>>>                Move (sKey +"\" +sObjectName) to sKey
8744>>>            End
8744>>>>
8744>>>            Else ;                Move (sKey +"\Preferences") to sKey
8746>>>            
8746>>>            Get CreateKey of hoRegistry sKey to iError
8747>>>            If (iError = 0) Begin
8749>>>                Move (SizeOfType(tWinWindowPlacement)) to WindowPlacement.length
8750>>>                Move (GetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
8751>>>                If bSuccess Begin
8753>>>                    // if minimized, assume restored, as we don't want to restart minimized!
8753>>>                    If (WindowPlacement.showCmd = SW_SHOWMINIMIZED) Begin
8755>>>                        Move SW_SHOWNORMAL to WindowPlacement.showCmd
8756>>>                    End
8756>>>>
8756>>>                    Send WriteBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) WindowPlacement.length
8757>>>                End
8757>>>>
8757>>>                
8757>>>                If bProgram Begin
8759>>>                    Send WriteDword of hoRegistry 'IsStatusBarVisible' (Statusbar_State(hoContainer))
8760>>>                    Send WriteDword of hoRegistry 'IsToolBarVisible'   (Toolbar_State(hoContainer))
8761>>>                End
8761>>>>
8761>>>                
8761>>>                
8761>>>                Send CloseKey of hoRegistry
8762>>>            End
8762>>>>
8762>>>            
8762>>>            Send Destroy of hoRegistry
8763>>>        End
8763>>>>
8763>>>    End_Procedure
8764>>>    
8764>>>    
8764>>>    Procedure ResetWindowPos tWinRect ByRef WindowPos
8766>>>        Integer ixySize ixSize iySize
8766>>>        Integer ixOffset iyOffset
8766>>>        
8766>>>        // first calculate the offset needed to move onto the main monitor at 0,0
8766>>>        Move (0 - WindowPos.left) to ixOffset
8767>>>        Move (0 - WindowPos.top) to iyOffset
8768>>>        
8768>>>        Move 0 to WindowPos.left
8769>>>        Move 0 to WindowPos.top
8770>>>        
8770>>>        Move (WindowPos.right + ixOffset) to WindowPos.right
8771>>>        Move (WindowPos.bottom + iyOffset) to WindowPos.bottom
8772>>>        
8772>>>        // also make sure that the size of the window is <= the size of the main monitor
8772>>>        Move (GUIScreen_Size(1)) to ixySize    // parameter of 1 means return "available" screen size
8773>>>        Move (low(ixySize))      to ixSize
8774>>>        Move (hi(ixySize))       to iySize
8775>>>        
8775>>>        Move (ixSize min WindowPos.right) to WindowPos.right
8776>>>        Move (iySize min WindowPos.bottom) to WindowPos.bottom
8777>>>    End_Procedure
8778>>>    
8778>>>    
8778>>>    Function RegistryKeyString Returns String
8780>>>        String sCompany sProduct sVersion sProgram
8780>>>        
8780>>>        Get psCompany to sCompany
8781>>>        Get psProduct to sProduct
8782>>>        Get psVersion to sVersion
8783>>>        Get psProgram to sProgram
8784>>>        
8784>>>        If (sCompany = "") ;            Move "Data Access Worldwide" to sCompany
8787>>>        If (sProduct = "") ;            Move "DataFlex Applications" to sProduct
8790>>>        If (sVersion = "") ;            Move C_DFVersion             to sVersion
8793>>>        If (sProgram ="") ;            Move (Module_Name(desktop))   to sProgram
8796>>>        
8796>>>        Function_Return ("SOFTWARE\" +sCompany +"\" +sProduct +"\" +sVersion +"\" +sProgram)
8797>>>    End_Function
8798>>>    
8798>>>    Procedure WriteString String sSubKey String sValueName String sValueData
8800>>>        String sKey
8800>>>        Handle hoRegistry
8800>>>        Integer iError
8800>>>        
8800>>>        Get Create U_cRegistry to hoRegistry
8801>>>        Get RegistryKeyString to sKey
8802>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8805>>>        Get CreateKey of hoRegistry sKey to iError
8806>>>        If (iError = 0) Begin
8808>>>            Send WriteString of hoRegistry sValueName sValueData
8809>>>            Send CloseKey of hoRegistry
8810>>>        End
8810>>>>
8810>>>        
8810>>>        Send Destroy of hoRegistry
8811>>>    End_Procedure
8812>>>    Procedure WriteDword String sSubKey String sValueName DWord dwValueData
8814>>>        String sKey
8814>>>        Handle hoRegistry
8814>>>        Integer iError
8814>>>        
8814>>>        Get Create U_cRegistry to hoRegistry
8815>>>        Get RegistryKeyString to sKey
8816>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8819>>>        Get CreateKey of hoRegistry sKey to iError
8820>>>        If (iError = 0) Begin
8822>>>            Send WriteDword of hoRegistry sValueName dwValueData
8823>>>            Send CloseKey of hoRegistry
8824>>>        End
8824>>>>
8824>>>        
8824>>>        Send Destroy of hoRegistry
8825>>>    End_Procedure
8826>>>    Procedure WriteBinary String sSubKey String sValueName Address aValueData Integer iDataLength
8828>>>        String sKey
8828>>>        Handle hoRegistry
8828>>>        Integer iError
8828>>>        
8828>>>        Get Create U_cRegistry to hoRegistry
8829>>>        Get RegistryKeyString to sKey
8830>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8833>>>        Get CreateKey of hoRegistry sKey to iError
8834>>>        If (iError = 0) Begin
8836>>>            Send WriteBinary of hoRegistry sValueName aValueData iDataLength
8837>>>            Send CloseKey of hoRegistry
8838>>>        End
8838>>>>
8838>>>        
8838>>>        Send Destroy of hoRegistry
8839>>>    End_Procedure
8840>>>    
8840>>>    // returns true if both sub-key and value exists.
8840>>>    Function ValueExists String sSubKey String sValueName Returns Boolean
8842>>>        String sKey
8842>>>        Handle hoRegistry
8842>>>        Boolean bOK
8842>>>        Get Create U_cRegistry to hoRegistry
8843>>>        Get RegistryKeyString to sKey
8844>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8847>>>        Get OpenKey of hoRegistry sKey to bOk
8848>>>        If (bOK) Begin
8850>>>            Move (ValueExists(hoRegistry, sValueName)) to bOk
8851>>>            Send CloseKey of hoRegistry
8852>>>        End
8852>>>>
8852>>>        Send Destroy of hoRegistry
8853>>>        Function_Return bOk
8854>>>    End_Function
8855>>>    
8855>>>    Function ReadString String sSubKey String sValueName String sDefault Returns String
8857>>>        String sKey sData
8857>>>        Handle hoRegistry
8857>>>        Boolean bOK
8857>>>        
8857>>>        Move sDefault to sData
8858>>>        Get Create U_cRegistry to hoRegistry
8859>>>        Get RegistryKeyString to sKey
8860>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8863>>>        Get OpenKey of hoRegistry sKey to bOk
8864>>>        If (bOK) Begin
8866>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadString of hoRegistry sValueName to sData
8869>>>            Send CloseKey of hoRegistry
8870>>>        End
8870>>>>
8870>>>        
8870>>>        Send Destroy of hoRegistry
8871>>>        Function_Return sData
8872>>>    End_Function
8873>>>    
8873>>>    Function ReadDword String sSubKey String sValueName DWord dwDefault Returns DWord
8875>>>        String sKey
8875>>>        DWord dwData
8875>>>        Handle hoRegistry
8875>>>        Boolean bOK
8875>>>        
8875>>>        Move dwDefault to dwData
8876>>>        Get Create U_cRegistry to hoRegistry
8877>>>        Get RegistryKeyString to sKey
8878>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8881>>>        Get OpenKey of hoRegistry sKey to bOk
8882>>>        If bOK Begin
8884>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadDword of hoRegistry sValueName to dwData
8887>>>            Send CloseKey of hoRegistry
8888>>>        End
8888>>>>
8888>>>        
8888>>>        Send Destroy of hoRegistry
8889>>>        Function_Return dwData
8890>>>    End_Function
8891>>>    
8891>>>    Function ReadBinary String sSubKey String sValueName Address aValueData Integer iDataLength Returns Boolean
8893>>>        String sKey
8893>>>        Handle hoRegistry
8893>>>        Boolean bOK bSuccess
8893>>>        
8893>>>        Get Create U_cRegistry to hoRegistry
8894>>>        Get RegistryKeyString to sKey
8895>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8898>>>        Get OpenKey of hoRegistry sKey to bOk
8899>>>        If bOK Begin
8901>>>            Get ReadBinary of hoRegistry sValueName aValueData iDataLength to bSuccess
8902>>>            Send CloseKey of hoRegistry
8903>>>        End
8903>>>>
8903>>>        
8903>>>        Send Destroy of hoRegistry
8904>>>        Function_Return bSuccess
8905>>>    End_Function
8906>>>    
8906>>>    Procedure DoOpenWorkspace String sWorkspace
8908>>>        // Tries to open in this order:
8908>>>        // 1) if absolute path, use that; otherwise
8908>>>        // 2) try to open in the path of the EXE; otherwise
8908>>>        // 3) load it via the Registered list
8908>>>        
8908>>>        Integer eOpened
8908>>>        String sError sWSFile
8908>>>        Handle hoWorkspace
8908>>>        Boolean bChangingWorkspace
8908>>>        
8908>>>        // As soon as an open is attempted, the application's object psAutoOpenWorkspace property
8908>>>        // is cleared. This way any attempt to manually open a workspace during its construction,
8908>>>        // which includes OnCreate, will stop the object from attempting to automatically open the
8908>>>        // workspace. This was added to make psAutoOpenWorkspace compatible with older applications.
8908>>>        // Typically these application will open a workspace in OnCreate. If this happens we assume
8908>>>        // that there should be no automatic opening of a worskpace.
8908>>>        Set psAutoOpenWorkspace to ""
8909>>>        
8909>>>        Get phoWorkspace to hoWorkspace
8910>>>        
8910>>>        Get pbWorkspaceOpened of hoWorkspace to bChangingWorkspace
8911>>>        If (bChangingWorkspace and ghoConnection) Begin
8913>>>            Send AutoDisconnect
8914>>>        End
8914>>>>
8914>>>        
8914>>>        Get OpenWorkspaceFile of hoWorkspace sWorkspace to eOpened
8915>>>        If (eOpened = wsWorkspaceFileNotFound) Begin
8917>>>            If (IsRegistered(hoWorkspace, sWorkspace) =True) Begin
8919>>>                Get OpenWorkspace of hoWorkspace sWorkspace to eOpened
8920>>>            End
8920>>>>
8920>>>        End
8920>>>>
8920>>>        If (eOpened <> wsWorkspaceOpened) Begin
8922>>>            Get OpenWorkspaceErrorMessage of hoWorkspace eOpened to sError
8923>>>            Get psWorkspaceWSFile of hoWorkspace to sWSFile
8924>>>            Error DFERR_CAPPLICATION (SFormat(C_$TheProgramCannotRun, sWorkspace) + ":\n\n" + If(sWSFile<>"",sWSfile+"\n\n","") +sError)
8925>>>>
8925>>>            Abort
8926>>>>
8926>>>        End
8926>>>>
8926>>>        Else Begin
8927>>>            Send AutoConnect
8928>>>            Send OnWorkspaceOpened
8929>>>        End
8929>>>>
8929>>>    End_Procedure
8930>>>    
8930>>>    Procedure AutoConnect
8932>>>        If (ghoConnection) Begin
8934>>>            Send AutoConnect of ghoConnection
8935>>>        End
8935>>>>
8935>>>    End_Procedure
8936>>>    
8936>>>    Procedure AutoDisconnect
8938>>>        If (ghoConnection) Begin
8940>>>            Send AutoDisconnect of ghoConnection
8941>>>        End
8941>>>>
8941>>>    End_Procedure
8942>>>    
8942>>>    // send after a workspace is successfully opened and connected
8942>>>    Procedure OnWorkspaceOpened
8944>>>    End_Procedure
8945>>>    
8945>>>    Procedure OnCreate
8947>>>        // Event called when the Application object is ready to be used
8947>>>        // to open a Workspace, etc.
8947>>>    End_Procedure
8948>>>    
8948>>>    Procedure End_Construct_Object
8950>>>        String sName
8950>>>        Forward Send End_Construct_Object
8952>>>        Send OnCreate
8953>>>        // note that psAutoOpenWorkspace will get cleared of OnCreate attempts to open a workspace
8953>>>        Get psAutoOpenWorkspace to sName
8954>>>        If (sName<>"") Begin
8956>>>            Send DoOpenWorkspace sName
8957>>>        End
8957>>>>
8957>>>    End_Procedure
8958>>>    
8958>>>    Function GetApplicationFileName Returns String
8960>>>        // Returns the filename from Windows
8960>>>        Integer iNumChars
8960>>>        String sFilename
8960>>>        
8960>>>        Move (Repeat(Character(0), 1024)) to sFileName
8961>>>        Move (GetModuleFileName(0, AddressOf(sFilename), 1024)) to iNumChars
8962>>>        
8962>>>        Function_Return (CString(sFilename))
8963>>>    End_Function
8964>>>    
8964>>>    Function GetApplicationPath Returns String
8966>>>        // Returns the path of the Application (no trailing "\")
8966>>>        String sApplicationFileName sPath
8966>>>        Boolean bRemoved
8966>>>        
8966>>>        Get GetApplicationFileName  to sApplicationFileName
8967>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to bRemoved
8968>>>        Move (CString(sApplicationFileName)) to sPath
8969>>>        
8969>>>        If (Right(sPath, 1) ="\") ;            Move (Left(sPath, Length(sPath) -1)) to sPath
8972>>>        Function_Return sPath
8973>>>    End_Function
8974>>>    
8974>>>    Function GetApplicationName Returns String
8976>>>        // Returns the name of the Application (without its Path or Extension)
8976>>>        String sApplicationFileName sApplicationName
8976>>>        Boolean bRemoved
8976>>>        Integer iVoid
8976>>>        
8976>>>        Get GetApplicationFileName to sApplicationFileName
8977>>>        Move (ExtractFileName(sApplicationFileName)) to sApplicationName
8978>>>        Move (PathRemoveExtension(AddressOf(sApplicationName))) to iVoid
8979>>>        Function_Return (CString(sApplicationName))
8980>>>    End_Function
8981>>>    
8981>>>    Function DFRootPath Returns String
8983>>>        String sRoot
8983>>>        Get_Profile_String "Defaults" "VDFRootDir" to sRoot
8986>>>        // Ensure it does not contain a trailing "\"
8986>>>        If (Right(sRoot,1) = "\") Begin
8988>>>            Move (Left(sRoot, Length(sRoot)-1)) to sRoot
8989>>>        End
8989>>>>
8989>>>        Function_Return sRoot
8990>>>    End_Function
8991>>>    
8991>>>    Function DFBinPath Returns String
8993>>>        String sRoot
8993>>>        Get DFRootPath to sRoot
8994>>>        If (sRoot<>"") Begin
8996>>>            Move (sRoot+"\bin") to sRoot
8997>>>        End
8997>>>>
8997>>>        Else Begin
8998>>>            // if the root from the registry (vdfrootdir) is empty, we will assume that the
8998>>>            // bin path must be the same as the application path.
8998>>>            Get GetApplicationPath to sRoot
8999>>>        End
8999>>>>
8999>>>        Function_Return sRoot
9000>>>    End_Function
9001>>>    
9001>>>    // this just directs to the desktop property. If you are using an application object you are
9001>>>    // encouraged to set this here.
9001>>>    Procedure Set pbUseWindowsFont Boolean bUseWindowsFont
9003>>>        Set pbUseWindowsFont of Desktop to bUseWindowsFont
9004>>>    End_Procedure
9005>>>    
9005>>>    Function pbUseWindowsFont Returns Boolean
9007>>>        Boolean bUseWindowsFont
9007>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
9008>>>        Function_Return bUseWindowsFont
9009>>>    End_Function
9010>>>    
9010>>>    // this just directs to the desktop property. If you are using an application object you are
9010>>>    // encouraged to set this here.
9010>>>    Procedure Set pbLegacyDialogRatio Boolean bLegacy
9012>>>        Set pbLegacyDialogRatio of Desktop to bLegacy
9013>>>    End_Procedure
9014>>>    
9014>>>    Function pbLegacyDialogRatio Returns Boolean
9016>>>        Boolean bLegacy
9016>>>        Get pbLegacyDialogRatio of Desktop to bLegacy
9017>>>        Function_Return bLegacy
9018>>>    End_Function
9019>>>End_Class
9020>>>
9020>>>
9020>Use cConnection.pkg
Including file: cConnection.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cConnection.pkg)
9020>>>Use vdfbase.pkg // Windows.pkg
9020>>>Use cli.pkg
Including file: cli.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cli.pkg)
9020>>>>>//                                                              
9020>>>>>//   CLI specific functionality. There are several connectivity kits     
9020>>>>>//   based on  SQL/92 CLI. Those are:                                    
9020>>>>>//    - ODBC_DRV  The Data Access CK for ODBC                            
9020>>>>>//    - DB2_DRV   The Data Access CK for DB2                             
9020>>>>>//    - MSSQLDRV  The Data Access CK for Microsoft SQL Server            
9020>>>>>//                                                                       
9020>>>>>//   This package defines the common functionality for all CLI based     
9020>>>>>//   drivers.                                                            
9020>>>>>
9020>>>>>Define DF_FILE_TABLE_CHARACTER_FORMAT   for 601
9020>>>>>Define DF_FILE_MAX_ROWS_FETCHED         for 602
9020>>>>>Define DF_FILE_PRIMARY_INDEX_TRIGGER    for 604      // Replaced by DF_FILE_GENERATE_RECORD_ID_METHOD !
9020>>>>>Define DF_FILE_TRANSLATE_OEM_TO_ANSI    for 606      // Deprecated !!! Only defined for decent error reporting
9020>>>>>Define DF_FILE_REFIND_AFTER_SAVE        for 608
9020>>>>>Define DF_FILE_TABLE_NAME               for 609
9020>>>>>Define DF_FILE_GET_RID_AFTER_CREATE     for 610
9020>>>>>Define DF_FILE_SQL_FILTER               for 611
9020>>>>>Define DF_FILE_USE_DUMMY_ZERO_DATE      for 612
9020>>>>>Define DF_FILE_GENERATE_RECORD_ID_METHOD for 614
9020>>>>>Define DF_FILE_DUMMY_UPDATE_COLUMN      for 616
9020>>>>>Define DF_FILE_FETCH_ALL_COLUMNS        for 620
9020>>>>>Define DF_FILE_DATABASE_ID              for 622
9020>>>>>Define DF_FILE_SQL_FILTER_ACTIVE        for 624
9020>>>>>Define DF_FILE_NUMBER_SQL_RELATIONS     for 626
9020>>>>>Define DF_FILE_BLOCK_SIZE               for 628
9020>>>>>Define DF_FILE_JIT_BINDING              for 630
9020>>>>>Define DF_FILE_FINDCACHE_HITS           for 632
9020>>>>>Define DF_FILE_FINDCACHE_TIMEOUTS       for 634
9020>>>>>Define DF_FILE_SQL_FILTER_EQ            for 636
9020>>>>>Define DF_FILE_RESTRUCTURE_INT_ONLY     for 638
9020>>>>>Define DF_FILE_ALLOWED_STRUCTURE_CHANGES for 640
9020>>>>>
9020>>>>>Define DF_FIELD_STORE_TIME              for 702
9020>>>>>Define DF_FIELD_TIME                    for 703
9020>>>>>Define DF_FIELD_IS_NULL                 for 704
9020>>>>>Define DF_FIELD_NULL_ALLOWED            for 706
9020>>>>>Define DF_FIELD_DEFAULT_VALUE           for 707
9020>>>>>Define DF_FIELD_FETCH_STATE             for 708
9020>>>>>Define DF_FIELD_READ_ONLY               for 710
9020>>>>>Define DF_FIELD_NATIVE_TYPE_NAME        for 711
9020>>>>>Define DF_FIELD_NATIVE_TYPE             for 712
9020>>>>>Define DF_FIELD_NO_OEM_ANSI_TRANSLATE   for 714
9020>>>>>Define DF_SQL_RELATION_COLUMN           for 716
9020>>>>>Define DF_SQL_RELATION_RELATED_SCHEMA   for 717
9020>>>>>Define DF_FIELD_NATIVE_SIZE             for 718
9020>>>>>Define DF_SQL_RELATION_RELATED_TABLE    for 719
9020>>>>>Define DF_SQL_RELATION_RELATED_COLUMN   for 721
9020>>>>>Define DF_FIELD_IS_IDENTITY             for 722
9020>>>>>
9020>>>>>Define DF_INDEX_NAME                    for 801
9020>>>>>Define DF_INDEX_UNIQUE                  for 802
9020>>>>>Define DF_INDEX_ON_BACKEND              for 804
9020>>>>>
9020>>>>>Define DF_INDEX_CLUSTERED               for 806
9020>>>>>Define DF_INDEX_SQL_PRIMARY_KEY         for 808
9020>>>>>Define DF_INDEX_SQL_TYPE                for 810
9020>>>>>Define DF_INDEX_NUMBER                  for 812
9020>>>>>
9020>>>>>Define DF_DATABASE_LOCK_STATE                    for 1001
9020>>>>>Define DF_DATABASE_ID                            for 1002
9020>>>>>Define DF_DATABASE_MYSQLTABLETYPE                for 1003
9020>>>>>Define DF_DATABASE_NUMBER_TYPES                  for 1004
9020>>>>>Define DF_DATABASE_TYPE_NAME                     for 1005
9020>>>>>Define DF_DATABASE_TYPE_ID                       for 1006
9020>>>>>Define DF_DATABASE_TYPE_CREATE_PARAMS            for 1007
9020>>>>>Define DF_DATABASE_TYPE_AUTOINC                  for 1008
9020>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_ASCII         for 1009
9020>>>>>Define DF_DATABASE_TYPE_UNSIGNED                 for 1010
9020>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_NUMERIC       for 1011
9020>>>>>Define DF_DATABASE_TYPE_MAXSIZE                  for 1012
9020>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_DATE          for 1013
9020>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_ASCII        for 1014
9020>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_TEXT          for 1015
9020>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_NUMERIC      for 1016
9020>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_BINARY        for 1017
9020>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_DATE         for 1018
9020>>>>>Define DF_DATABASE_DUMMY_ZERO_DATE_VALUE         for 1019
9020>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_TEXT         for 1020
9020>>>>>Define DF_DATABASE_DUPREC_STATE                  for 1021
9020>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_BINARY       for 1022
9020>>>>>Define DF_DATABASE_MAX_ACTIVE_STATEMENTS         for 1024
9020>>>>>Define DF_DATABASE_DRIVER_DECIMAL_SEPARATOR      for 1026
9020>>>>>Define DF_DATABASE_DRIVER_THOUSANDS_SEPARATOR    for 1028
9020>>>>>
9020>>>>>Define DF_DATABASE_DRIVER_DATE_FORMAT            for 1030
9020>>>>>Define DF_DATABASE_DRIVER_DATE_SEPARATOR         for 1032
9020>>>>>Define DF_DATABASE_IGNORE_UCASE_SUPPORT          for 1034
9020>>>>>Define DF_DATABASE_INDEX_CREATE                  for 1036
9020>>>>>Define DF_DATABASE_INDEX_DROP                    for 1038
9020>>>>>Define DF_DATABASE_INDEX_ASC                     for 1040
9020>>>>>Define DF_DATABASE_INDEX_DESC                    for 1042
9020>>>>>Define DF_DATABASE_COLUMN_CREATE_DEFAULTCLAUSE   for 1044
9020>>>>>Define DF_DATABASE_DUPREC_ERRORNUMBER            for 1046
9020>>>>>Define DF_DATABASE_USE_IDENTITY_TYPE             for 1048
9020>>>>>Define DF_DATABASE_NUMBER_NATIVE_LOCKERRORS      for 1050
9020>>>>>Define DF_DATABASE_NATIVE_LOCKERROR              for 1052
9020>>>>>Define DF_DATABASE_DEFAULT_MAX_ROWS              for 1054
9020>>>>>Define DF_DATABASE_IGNORE_WARNINGS               for 1056
9020>>>>>Define DF_DATABASE_USE_DF_LOCKERROR              for 1058
9020>>>>>Define DF_DATABASE_FIND_CACHE_TIMEOUT            for 1060
9020>>>>>Define DF_DATABASE_JIT_TRESHOLD                  for 1062
9020>>>>>Define DF_DATABASE_TRUNCATE_BINARY_ZEROES        for 1064
9020>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_DATETIME      for 1065
9020>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_DATETIME     for 1066
9020>>>>>Define DF_DATABASE_MAP_DFDATE_TO_ODBCTYPE         for 1068
9020>>>>>Define DF_DATABASE_MAP_DFDATETIME_TO_ODBCTYPE     for 1070
9020>>>>>Define DF_DATABASE_MAP_DFASCII_TO_ODBCTYPE        for 1072
9020>>>>>Define DF_DATABASE_MAP_DFTEXT_TO_ODBCTYPE         for 1074
9020>>>>>Define DF_DATABASE_MAP_DFBINARY_TO_ODBCTYPE       for 1076
9020>>>>>Define DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA for 1078
9020>>>>>
9020>>>>>Define DF_DATABASE_MAP_DFDATE_TO_SQLTYPE         for 1069
9020>>>>>Define DF_DATABASE_MAP_DFDATETIME_TO_SQLTYPE     for 1071
9020>>>>>Define DF_DATABASE_MAP_DFASCII_TO_SQLTYPE        for 1073
9020>>>>>Define DF_DATABASE_MAP_DFTEXT_TO_SQLTYPE         for 1075
9020>>>>>Define DF_DATABASE_MAP_DFBINARY_TO_SQLTYPE       for 1077
9020>>>>>Define DF_DATABASE_DEFAULT_DATABASE              for 1079
9020>>>>>
9020>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_ASCII           for 1101
9020>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_ASCII          for 1102
9020>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_NUMERIC         for 1103
9020>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_NUMERIC        for 1104
9020>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_DATE            for 1105
9020>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_DATE           for 1106
9020>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_TEXT            for 1107
9020>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_TEXT           for 1108
9020>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_BINARY          for 1109
9020>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_BINARY         for 1110
9020>>>>>Define DF_DRIVER_DUMMY_ZERO_DATE_VALUE           for 1111
9020>>>>>Define DF_DRIVER_MAX_ACTIVE_STATEMENTS           for 1112
9020>>>>>Define DF_DRIVER_CACHE_PATH                      for 1113
9020>>>>>Define DF_DRIVER_DRIVER_DECIMAL_SEPARATOR        for 1114
9020>>>>>Define DF_DRIVER_DEFAULT_TABLE_CHARACTER_FORMAT  for 1115
9020>>>>>Define DF_DRIVER_DRIVER_THOUSANDS_SEPARATOR      for 1116
9020>>>>>Define DF_DRIVER_APPLICATION_CHARACTER_FORMAT    for 1117
9020>>>>>Define DF_DRIVER_DRIVER_DATE_FORMAT              for 1118
9020>>>>>Define DF_DRIVER_LAST_ERROR_TEXT                 for 1119
9020>>>>>Define DF_DRIVER_DRIVER_DATE_SEPARATOR           for 1120
9020>>>>>Define DF_DRIVER_CONNECTION_ID                   for 1121
9020>>>>>Define DF_DRIVER_IGNORE_UCASE_SUPPORT            for 1122
9020>>>>>Define DF_DRIVER_CONNECTION_ID_STRING            for 1123
9020>>>>>Define DF_DRIVER_IGNORE_WARNINGS                 for 1124
9020>>>>>Define DF_DRIVER_USE_DF_LOCKERROR                for 1126
9020>>>>>Define DF_DRIVER_FIND_CACHE_TIMEOUT              for 1128
9020>>>>>Define DF_DRIVER_JIT_TRESHOLD                    for 1130
9020>>>>>Define DF_DRIVER_TRUNCATE_BINARY_ZEROES          for 1132
9020>>>>>Define DF_DRIVER_ERROR_DEBUG_MODE                for 1134
9020>>>>>Define DF_DRIVER_USE_CACHE                       for 1136
9020>>>>>Define DF_DRIVER_REPORT_CACHE_ERRORS             for 1138
9020>>>>>Define DF_DRIVER_USE_CACHE_EXPIRATION            for 1140
9020>>>>>Define DF_DRIVER_DEFAULT_USE_DUMMY_ZERO_DATE     for 1142
9020>>>>>Define DF_DRIVER_DEFAULT_RECORD_IDENTITY_HIDING  for 1144
9020>>>>>Define DF_DRIVER_REPORT_ACTIVE_COLUMN_ERRORS     for 1146
9020>>>>>Define DF_DRIVER_SILENT_LOGIN                    for 1148
9020>>>>>Define DF_DRIVER_DEFAULT_MAP_TO_RECNUM           for 1150
9020>>>>>Define DF_DRIVER_CONNECTION_ID_OPTIONS           for 1152
9020>>>>>Define DF_DRIVER_NUMBER_CONNECTION_IDS           for 1154
9020>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_DATETIME        for 1155
9020>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_DATETIME       for 1156
9020>>>>>Define DF_DRIVER_MATCH_CLIENT_SERVER_VERSION     for 1158
9020>>>>>Define DF_DRIVER_SQLSERVER_CLIENT_VERSION        for 1160
9020>>>>>Define DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE          for 1168
9020>>>>>Define DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE      for 1170
9020>>>>>Define DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE         for 1172
9020>>>>>Define DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE          for 1174
9020>>>>>Define DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE        for 1176
9020>>>>>Define DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA for 1178
9020>>>>>Define DF_DRIVER_LOGIN_ON_OPEN                   for 1180
9020>>>>>Define DF_DRIVER_MINIMUM_CLIENT_VERSION          for 1182
9020>>>>>
9020>>>>>Define DF_DRIVER_MAP_DFDATE_TO_SQLTYPE           for 1169
9020>>>>>Define DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE       for 1171
9020>>>>>Define DF_DRIVER_MAP_DFASCII_TO_SQLTYPE          for 1173
9020>>>>>Define DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE           for 1175
9020>>>>>Define DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE         for 1177
9020>>>>>
9020>>>>>
9020>>>>>// Replacement for logical column number that indicates all columns
9020>>>>>Define DF_ALL_COLUMNS for -1
9020>>>>>
9020>>>>>// Possible DF_FILE_GENERATE_RECORD_ID_METHOD values
9020>>>>>Define RIM_NONE            for 0
9020>>>>>Define RIM_IDENTITY_COLUMN for 1
9020>>>>>Define RIM_DISPENSER_TABLE for 2
9020>>>>>Define RIM_EXTERNAL        for 3
9020>>>>>
9020>>>>>// Possible DF_FIELD_READ_ONLY values
9020>>>>>Define RO_NO            for 0
9020>>>>>Define RO_IGNORECHANGE  for 1
9020>>>>>Define RO_ACCEPTCHANGE  for 2
9020>>>>>Define RO_ERRORONCHANGE for 3
9020>>>>>
9020>>>>>
9020>>>>>// Possible DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA values
9020>>>>>Define MAP_DF_TO_SQL_TYPE_UNKNOWN    for 0
9020>>>>>// Define MAP_DF_TO_SQL_TYPE_CK5        for 1
9020>>>>>// Define MAP_DF_TO_SQL_TYPE_CK6        for 2
9020>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2000    for 3
9020>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2005    for 4
9020>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2008    for 5
9020>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2012    for 6
9020>>>>>Define MAP_DF_TO_SQL_TYPE_DB2_LEGACY  for 7
9020>>>>>Define MAP_DF_TO_SQL_TYPE_DB2_10      for 8
9020>>>>>Define MAP_DF_TO_SQL_TYPE_ODBC_SCHEMA for 9
9020>>>>>
9020>>>>>// Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values are defined in Mssqldrv.pkg
9020>>>>>
9020>>>>>// Possible SQL Column type values
9020>>>>>//      SQL Server specific types defined in mssqldrv.pkg
9020>>>>>//      DB2 specific typesm defined in db2_drv.pkg
9020>>>>>
9020>>>>>Define SQL_UNKNOWN_TYPE   for    0
9020>>>>>Define SQL_CHAR           for    1
9020>>>>>Define SQL_NUMERIC        for    2
9020>>>>>Define SQL_DECIMAL        for    3
9020>>>>>Define SQL_INTEGER        for    4
9020>>>>>Define SQL_SMALLINT       for    5
9020>>>>>Define SQL_FLOAT          for    6
9020>>>>>Define SQL_REAL           for    7
9020>>>>>Define SQL_DOUBLE         for    8
9020>>>>>Define SQL_DATETIME       for    9
9020>>>>>Define SQL_VARCHAR        for   12
9020>>>>>Define SQL_TYPE_DATE      for   91
9020>>>>>Define SQL_TYPE_TIME      for   92
9020>>>>>Define SQL_TYPE_TIMESTAMP for   93
9020>>>>>
9020>>>>>Define SQL_DATE           for    9
9020>>>>>Define SQL_INTERVAL       for   10
9020>>>>>Define SQL_TIME           for   10
9020>>>>>Define SQL_TIMESTAMP      for   11
9020>>>>>Define SQL_LONGVARCHAR    for  (-1)
9020>>>>>Define SQL_BINARY         for  (-2)
9020>>>>>Define SQL_VARBINARY      for  (-3)
9020>>>>>Define SQL_LONGVARBINARY  for  (-4)
9020>>>>>Define SQL_BIGINT         for  (-5)
9020>>>>>Define SQL_TINYINT        for  (-6)
9020>>>>>Define SQL_BIT            for  (-7)
9020>>>>>Define SQL_WCHAR          for  (-8)
9020>>>>>Define SQL_WVARCHAR       for  (-9)
9020>>>>>Define SQL_WLONGVARCHAR   for (-10)
9020>>>>>Define SQL_GUID           for (-11)
9020>>>>>
9020>>>>>// Possible DF_INDEX_SQL_TYPE values
9020>>>>>Define DF_INDEX_CLIENT      for  1
9020>>>>>Define DF_INDEX_SERVER      for  2
9020>>>>>Define DF_INDEX_SERVER_ONLY for  3
9020>>>>>Define DF_INDEX_TEMPORARY   for  4
9020>>>>>
9020>>>>>// Possible DF_FILE_ALLOWED_STRUCTURE_CHANGES values
9020>>>>>Define ALL_TABLE_CHANGES_ALLOWED            for  0
9020>>>>>Define ONLY_TABLE_INT_FILE_CHANGES_ALLOWED  for  1
9020>>>>>Define NO_TABLE_CHANGES_ALLOWED             for  2
9020>>>>>
9020>>>>>// Driver level attributes
9020>>>>>Define DRVR_TOKEN_BASE                       for 1000
9020>>>>>Define DRVR_ATTRIBUTE_START                  for (DRVR_TOKEN_BASE + 19)
9020>>>>>Define DRVR_DEFAULT_NULLABLE_ASCII           for (DRVR_ATTRIBUTE_START)
9020>>>>>Define DRVR_DEFAULT_NULLABLE_NUMERIC         for (DRVR_ATTRIBUTE_START +  1)
9020>>>>>Define DRVR_DEFAULT_NULLABLE_DATE            for (DRVR_ATTRIBUTE_START +  2)
9020>>>>>Define DRVR_DEFAULT_NULLABLE_TEXT            for (DRVR_ATTRIBUTE_START +  3)
9020>>>>>Define DRVR_DEFAULT_NULLABLE_BINARY          for (DRVR_ATTRIBUTE_START +  4)
9020>>>>>Define DRVR_DEFAULT_DEFAULT_ASCII            for (DRVR_ATTRIBUTE_START +  5)
9020>>>>>Define DRVR_DEFAULT_DEFAULT_NUMERIC          for (DRVR_ATTRIBUTE_START +  6)
9020>>>>>Define DRVR_DEFAULT_DEFAULT_DATE             for (DRVR_ATTRIBUTE_START +  7)
9020>>>>>Define DRVR_DEFAULT_DEFAULT_TEXT             for (DRVR_ATTRIBUTE_START +  8)
9020>>>>>Define DRVR_DEFAULT_DEFAULT_BINARY           for (DRVR_ATTRIBUTE_START +  9)
9020>>>>>Define DRVR_MAX_ACTIVE_STATEMENTS            for (DRVR_ATTRIBUTE_START + 10)
9020>>>>>Define DRVR_ERROR_DEBUG_MODE                 for (DRVR_ATTRIBUTE_START + 11)
9020>>>>>Define DRVR_DRIVER_DECIMAL_SEPARATOR         for (DRVR_ATTRIBUTE_START + 12)
9020>>>>>Define DRVR_DRIVER_THOUSANDS_SEPARATOR       for (DRVR_ATTRIBUTE_START + 13)
9020>>>>>Define DRVR_DRIVER_DATE_FORMAT               for (DRVR_ATTRIBUTE_START + 14)
9020>>>>>Define DRVR_DRIVER_DATE_SEPARATOR            for (DRVR_ATTRIBUTE_START + 15)
9020>>>>>Define DRVR_USE_CACHE                        for (DRVR_ATTRIBUTE_START + 16)
9020>>>>>Define DRVR_REPORT_CACHE_ERRORS              for (DRVR_ATTRIBUTE_START + 17)
9020>>>>>Define DRVR_CACHE_PATH                       for (DRVR_ATTRIBUTE_START + 18)
9020>>>>>Define DRVR_USE_CACHE_EXPIRATION             for (DRVR_ATTRIBUTE_START + 19)
9020>>>>>Define DRVR_DEFAULT_TABLE_CHARACTER_FORMAT   for (DRVR_ATTRIBUTE_START + 20)
9020>>>>>Define DRVR_APPLICATION_CHARACTER_FORMAT     for (DRVR_ATTRIBUTE_START + 21)
9020>>>>>Define DRVR_DUMMY_ZERO_DATE_VALUE            for (DRVR_ATTRIBUTE_START + 22)
9020>>>>>Define DRVR_DEFAULT_USE_DUMMY_ZERO_DATE      for (DRVR_ATTRIBUTE_START + 23)
9020>>>>>Define DRVR_IGNORE_UCASE_SUPPORT             for (DRVR_ATTRIBUTE_START + 24)
9020>>>>>Define DRVR_LASTERRORTEXTLENGTH              for (DRVR_ATTRIBUTE_START + 25)
9020>>>>>Define DRVR_LASTERRORTEXT                    for (DRVR_ATTRIBUTE_START + 26)
9020>>>>>Define DRVR_DEFAULTRECORDIDHIDING            for (DRVR_ATTRIBUTE_START + 35)
9020>>>>>Define DRVR_REPORTACTIVECOLUMNERRORS         for (DRVR_ATTRIBUTE_START + 36)
9020>>>>>
9020>>>>>
9020>>>>>// Error Number constants
9020>>>>>Define CLIERR_GENERAL_ERROR                       for 12289
9020>>>>>Define CLIERR_CANT_INITIALIZE                     for 12290
9020>>>>>Define CLIERR_CANT_DEINITIALIZE                   for 12291
9020>>>>>Define CLIERR_BAD_OR_NO_PRIMARY_INDEX_SPECIFIED   for 12292
9020>>>>>Define CLIERR_LOGIN_UNSUCCESSFUL                  for 12293
9020>>>>>Define CLIERR_LOGOUT_UNSUCCESSFUL                 for 12294
9020>>>>>Define CLIERR_TABLE_NOT_IN_CONNECTION             for 12295
9020>>>>>Define CLIERR_NULL_VALUE_NOT_ALLOWED              for 12296
9020>>>>>Define CLIERR_SEGMENT_NUMBER_RANGE                for 12297
9020>>>>>Define CLIERR_INDEX_NUMBER_RANGE                  for 12298
9020>>>>>Define CLIERR_LOGIN_ATTRIBUTE_MUST_BE_SET         for 12299
9020>>>>>Define CLIERR_PHYSICAL_NAME_MUST_BE_SET           for 12300
9020>>>>>Define CLIERR_INVALID_REGISTRATION_FILE           for 12301
9020>>>>>Define CLIERR_LICENSE_EXPIRED                     for 12302
9020>>>>>Define CLIERR_DEADLOCK_OR_TIMEOUT                 for 12303
9020>>>>>Define CLIERR_SQL_ERROR                           for 12304
9020>>>>>Define CLIERR_SQLINVALID_CLI_STMT_HANDLE          for 12305
9020>>>>>Define CLIERR_SQLINVALID_CLI_CONN_HANDLE          for 12306
9020>>>>>Define CLIERR_SQLINVALID_DRIVER_ID                for 12307
9020>>>>>Define CLIERR_SQLINVALID_BIND_FILE                for 12308
9020>>>>>Define CLIERR_SQLINVALID_COLUMN                   for 12309
9020>>>>>Define CLIERR_SQLINVALID_ATTRIBUTE                for 12310
9020>>>>>Define CLIERR_SQLINVALID_BUFFER                   for 12311
9020>>>>>Define CLIERR_INVALID_CONFIGURATION_KEYWORD       for 12312
9020>>>>>Define CLIERR_NOUNIQUEINDEX                       for 12313
9020>>>>>Define CLIERR_UCSEGMENT_NOT_SUPPORTED             for 12314
9020>>>>>Define CLIERR_FIELDREADONLY                       for 12315
9020>>>>>Define CLIERR_DBPROPERROR                         for 12316
9020>>>>>Define CLIERR_CANTSETRECNUMINACTIVE               for 12317
9020>>>>>Define CLIERR_CANTCHANGEINACTIVECOLUMN            for 12318
9020>>>>>Define CLIERR_FIELDISINACTIVE                     for 12319
9020>>>>>Define CLIERR_NOT_INSTALLED                       for 12320
9020>>>>>Define CLIERR_CANT_FIND_TERMLIST                  for 12321
9020>>>>>Define CLIERR_CANT_READ_TERMLIST                  for 12322
9020>>>>>Define CLIERR_MAX_USERS_EXCEEDED                  for 12323
9020>>>>>Define CLIERR_USER_COUNT_FILE_ERROR               for 12324
9020>>>>>Define CLIERR_CANT_INIT_USER_COUNT                for 12325
9020>>>>>Define CLIERR_USER_COUNT_FILE_NOT_FOUND           for 12326
9020>>>>>Define CLIERR_USER_COUNT_FILE_CANT_READ           for 12327
9020>>>>>Define CLIERR_USER_COUNT_FILE_CANT_DECRYPT        for 12328
9020>>>>>Define CLIERR_USER_COUNT_FILE_BAD_VERSION         for 12329
9020>>>>>Define CLIERR_CANTCREATE_RECNUMISZERO             for 12330
9020>>>>>Define CLIERR_CANTGETCOLUMNINFO                   for 12331
9020>>>>>Define CLIERR_INVALIDDATABASEHANDLE               for 12332
9020>>>>>Define CLIERR_TYPENUMBEROUTOFRANGE                for 12333
9020>>>>>Define CLIERR_LOCKERRORNUMBEROUTOFRANGE           for 12334
9020>>>>>Define CLIERR_CONNECTIONIDOUTOFRANGE              for 12335
9020>>>>>Define CLIERR_CONNECTIONIDNOTFOUND                for 12336
9020>>>>>Define CLIERR_RELATIONOUTOFRANGE                  for 12337
9020>>>>>Define CLIERR_NOTANEXPRESSEDITION                 for 12338
9020>>>>>Define CLIERR_INVALID_CONFIGURATION_VALUE         for 12339
9020>>>>>Define CLIERR_NOCLIENTSERVERVERSIONMATCH          for 12340
9020>>>>>Define CLIERR_CONNECTIONIDALREADYEXISTS           for 12341
9020>>>>>Define CLIERR_INVALIDCONNECTSTRINGOPENOPTION      for 12342
9020>>>>>Define CLIERR_DATABASECONNECTIONLOST              for 12343
9020>>>>>Define CLIERR_STRUCTURECHANGENOTALLOWED           for 12344
9020>>>>>Define CLIERR_MINIMUMCLIENTVERSIONNOTFOUND        for 12345
9020>>>>>
9020>>>>>
9020>>>>>// Call driver Function identifiers
9020>>>>>Define CLI_CONSTRAINT             for 10000
9020>>>>>Define CLI_SETDRIVERATTRIBUTE     for 10001
9020>>>>>Define CLI_GETDRIVERATTRIBUTE     for 10002
9020>>>>>Define CLI_BROWSECONNECT          for 10003
9020>>>>>Define CLI_DATASOURCES            for 10004
9020>>>>>Define CLI_CKREVISION             for 10005
9020>>>>>Define CLI_INITDATASOURCES        for 10006
9020>>>>>Define CLI_ENUMERATE_TABLES       for 10007
9020>>>>>Define CLI_TABLENAME              for 10008
9020>>>>>Define CLI_TABLESCHEMA            for 10009
9020>>>>>Define CLI_TABLETYPE              for 10010
9020>>>>>Define CLI_TABLECOMMENT           for 10011
9020>>>>>Define CLI_ENUMERATE_COLUMNS      for 10012
9020>>>>>Define CLI_COLUMNNAME             for 10013
9020>>>>>Define CLI_DUMPSTATUS             for 10014
9020>>>>>Define CLI_READCONFIGURATION      for 10015
9020>>>>>Define CLI_GETDBATTRIBUTE0        for 10016
9020>>>>>Define CLI_GETDBATTRIBUTE         for 10017
9020>>>>>Define CLI_GETREGNAME             for 10018
9020>>>>>Define CLI_GETSERIALNUM           for 10019
9020>>>>>Define CLI_GETMAXUSERS            for 10020
9020>>>>>Define CLI_BCP                    for 10021
9020>>>>>Define CLI_DROPINDICES            for 10022
9020>>>>>Define CLI_CREATEINDICES          for 10023
9020>>>>>Define CLI_REDIRECTCONNECTION     for 10024
9020>>>>>Define CLI_CREATECONNECTIONID     for 10025
9020>>>>>Define CLI_DELETECONNECTIONID     for 10026
9020>>>>>
9020>>>>>
9020>>>>>// Init data source types
9020>>>>>Define SQL_FETCH_ALL     for  2
9020>>>>>Define SQL_FETCH_USER    for 31
9020>>>>>Define SQL_FETCH_SYSTEM  for 32
9020>>>>>
9020>>>>>
9020>>>>>// Dummy strings used in the commands
9020>>>>>String  CLI$StrDummy 255
9020>>>>>Integer CLI$IntDummy
9020>>>>>
9020>>>>>
9020>>>>>//   Setup a constraint for a file.                                    
9020>>>>>
9020>>>>>
9020>>>>>
9020>>>>>// Set or get an attribute at driver level. These attributes, when set,
9020>>>>>// will be set for the remainder of the session or until set again. To 
9020>>>>>// permanently set driver level attributes change the driver           
9020>>>>>// configuration file.                                                 
9020>>>>>
9020>>>>>
9020>>>>>
9020>>>>>
9020>>>>>
9020>>>>>
9020>>>>>
9020>>>>>// An instance of this class can be used as a broker object to
9020>>>>>// call several CLI releated methods.                         
9020>>>>>
9020>>>>>//Class cCLIHandler is a cObject
9020>>>>>Class cCLIHandler is an Array
9021>>>>>    
9021>>>>>    Procedure Construct_Object 
9023>>>>>        Forward Send Construct_object 
9025>>>>>        
9025>>>>>        Property String  psDriverID        ""
9026>>>>>    End_Procedure
9027>>>>>    
9027>>>>>    
9027>>>>>    
9027>>>>>    // The revsion of a CLI Connectivity Kit
9027>>>>>    Function CKRevision Returns String
9029>>>>>        String  sDriverID
9029>>>>>        String  sRevision
9029>>>>>        String  sVoid
9029>>>>>        Integer iRetval
9029>>>>>        
9029>>>>>        Get psDriverID to sDriverID
9030>>>>>        If (sDRiverID <> "") Begin
9032>>>>>            Move (Repeat(" ", 255)) to sRevision
9033>>>>>            Call_Driver 0 sDRiverID Function CLI_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
9038>>>>>        End
9038>>>>>>
9038>>>>>        
9038>>>>>        Function_Return sRevision
9039>>>>>    End_Function
9040>>>>>    
9040>>>>>    
9040>>>>>    
9040>>>>>    // Extarct the Nth part of a a.b.c.d revsion string.
9040>>>>>    // Returns : The part version number or -1 if there is no such part number.
9040>>>>>    //
9040>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
9042>>>>>        Integer iPartRev
9042>>>>>        Integer iCurrentPart
9042>>>>>        Integer iSeparatorPos
9042>>>>>        
9042>>>>>        If (iPartNum > 4) ;            Function_Return -1
9045>>>>>        
9045>>>>>        Move 0 to iCurrentPart
9046>>>>>        Repeat
9046>>>>>>
9046>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
9047>>>>>            If (iSeparatorPos > 0) Begin
9049>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
9050>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
9051>>>>>                Increment iCurrentPart
9052>>>>>            End
9052>>>>>>
9052>>>>>            Else If (sRevision <> "") Begin
9055>>>>>                Move sRevision to iPartRev
9056>>>>>                Move "" to sRevision
9057>>>>>                Increment iCurrentPart
9058>>>>>            End
9058>>>>>>
9058>>>>>            Else ;                Move -1 to iPartRev
9060>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
9062>>>>>        
9062>>>>>        Function_Return iPartRev
9063>>>>>    End_Function
9064>>>>>    
9064>>>>>    
9064>>>>>    
9064>>>>>    // Returns the major revision of the CK
9064>>>>>    //
9064>>>>>    Function CKMajorRevision Returns Integer
9066>>>>>        Function_Return (ExtractPartFromRevision (Self, 1, CKRevision(Self)))
9067>>>>>    End_Function
9068>>>>>    
9068>>>>>    
9068>>>>>    
9068>>>>>    // Returns the minor revision of the CK
9068>>>>>    //
9068>>>>>    Function CKMinorRevision Returns Integer
9070>>>>>        Function_Return (ExtractPartFromRevision (Self, 2, CKRevision(Self)))
9071>>>>>    End_Function
9072>>>>>    
9072>>>>>    
9072>>>>>    
9072>>>>>    // Returns the release revision of the CK
9072>>>>>    //
9072>>>>>    Function CKReleaseRevision Returns Integer
9074>>>>>        Function_Return (ExtractPartFromRevision (Self, 3, CKRevision(Self)))
9075>>>>>    End_Function
9076>>>>>    
9076>>>>>    
9076>>>>>    
9076>>>>>    // Returns the major revision of the CK
9076>>>>>    //
9076>>>>>    Function CKBuildRevision Returns Integer
9078>>>>>        Function_Return (ExtractPartFromRevision (Self, 4, CKRevision(Self)))
9079>>>>>    End_Function
9080>>>>>    
9080>>>>>    
9080>>>>>    
9080>>>>>    // Determines if the CK conforms to a passed minimal revsion.
9080>>>>>    //
9080>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
9082>>>>>        If (iMajor < CKMajorRevision(Self)) ;            Function_Return (True)
9085>>>>>        Else If (iMajor = CKMajorRevision(Self)) Begin
9088>>>>>            If (iMinor < CKMinorRevision(Self)) ;                Function_Return (True)
9091>>>>>            Else If (iMinor = CKMinorRevision(Self)) Begin
9094>>>>>                If (iRelease < CKReleaseRevision(Self)) ;                    Function_Return (True)
9097>>>>>                Else If (iRelease = CKReleaseRevision(Self) and iBuild <= CKBuildRevision(Self)) ;                    Function_Return (True)
9101>>>>>            End
9101>>>>>>
9101>>>>>        End
9101>>>>>>
9101>>>>>        
9101>>>>>        Function_Return (False)
9102>>>>>    End_Function
9103>>>>>    
9103>>>>>    
9103>>>>>    
9103>>>>>    // Returns the Connectiivty Kit registration name.
9103>>>>>    //
9103>>>>>    Function RegistrationName Returns String
9105>>>>>        String  sRegistration
9105>>>>>        String  sDRiverId
9105>>>>>        String  sVoid
9105>>>>>        Integer iRetval
9105>>>>>        
9105>>>>>        Get psDriverID to sDriverID
9106>>>>>        If (sDRiverID <> "") Begin
9108>>>>>            Move (Repeat(" ", 255)) to sRegistration
9109>>>>>            Call_Driver 0 sDRiverID Function CLI_GETREGNAME Callback 0 Passing sRegistration sVoid 0 Result iRetval
9114>>>>>        End
9114>>>>>>
9114>>>>>        
9114>>>>>        Function_Return sRegistration
9115>>>>>    End_Function
9116>>>>>    
9116>>>>>    // Returns the Connectiivty Kit serial number.
9116>>>>>    //
9116>>>>>    Function SerialNumber Returns Integer
9118>>>>>        String  sDRiverId
9118>>>>>        String  sVoid
9118>>>>>        Integer iRetval
9118>>>>>        
9118>>>>>        Get psDriverID to sDriverID
9119>>>>>        If (sDRiverID <> "") Begin
9121>>>>>            Call_Driver 0 sDRiverID Function CLI_GETSERIALNUM Callback 0 Passing sVoid sVoid 0 Result iRetval
9126>>>>>        End
9126>>>>>>
9126>>>>>        
9126>>>>>        Function_Return iRetval
9127>>>>>    End_Function
9128>>>>>    
9128>>>>>    
9128>>>>>    // Returns the Connectiivty Kit maximum number of users.
9128>>>>>    //
9128>>>>>    Function MaxUsers Returns Integer
9130>>>>>        String  sDRiverId
9130>>>>>        String  sVoid
9130>>>>>        Integer iRetval
9130>>>>>        
9130>>>>>        Get psDriverID to sDriverID
9131>>>>>        If (sDRiverID <> "") Begin
9133>>>>>            Call_Driver 0 sDRiverID Function CLI_GETMAXUSERS Callback 0 Passing sVoid sVoid 0 Result iRetval
9138>>>>>        End
9138>>>>>>
9138>>>>>        
9138>>>>>        Function_Return iRetval
9139>>>>>    End_Function
9140>>>>>    
9140>>>>>    
9140>>>>>    
9140>>>>>    // Dump the current status of the drver in the passed disk file.
9140>>>>>    //
9140>>>>>    Procedure DumpStatus String sFileName
9142>>>>>        String  sVoid
9142>>>>>        String  sDriverID
9142>>>>>        Integer iVoid
9142>>>>>        
9142>>>>>        Get psDriverID to sDriverID
9143>>>>>        If (sDriverID <> "") ;            Call_Driver 0 sDriverID Function CLI_DUMPSTATUS Callback 0 Passing sFileName sVoid iVoid Result iVoid
9150>>>>>    End_Procedure
9151>>>>>    
9151>>>>>    
9151>>>>>    
9151>>>>>    // Reset all driver level configurable attributes to the
9151>>>>>    // default value and then reread the configuration.
9151>>>>>    //
9151>>>>>    Procedure ReadConfiguration
9153>>>>>        String  sVoid
9153>>>>>        String  sDriverID
9153>>>>>        Integer iVoid
9153>>>>>        
9153>>>>>        Get psDriverID to sDriverID
9154>>>>>        If (sDriverID <> "") ;            Call_Driver 0 sDriverID Function CLI_READCONFIGURATION Callback 0 Passing sVoid sVoid iVoid Result iVoid
9161>>>>>    End_Procedure
9162>>>>>    
9162>>>>>    
9162>>>>>    
9162>>>>>    // Convert a text to the corresponding
9162>>>>>    // Generate_Record_ID_Method attribute value
9162>>>>>    //
9162>>>>>    Function TextToRIMValue String sText Returns Integer
9164>>>>>        If (sText = "None") ;            Function_Return RIM_NONE
9167>>>>>        Else If (sText = "Identity Column") ;            Function_Return RIM_IDENTITY_COLUMN
9171>>>>>        Else If (sText = "Dispenser Table") ;            Function_Return RIM_DISPENSER_TABLE
9175>>>>>        Else If (sText = "External") ;            Function_Return RIM_EXTERNAL
9179>>>>>    End_Function
9180>>>>>    
9180>>>>>    
9180>>>>>    
9180>>>>>    // Convert a Generate_Record_ID_Method attribute value to the
9180>>>>>    // corresponding text.
9180>>>>>    //
9180>>>>>    Function RIMValueToText Integer iAttrValue Returns String
9182>>>>>        If (iAttrValue = RIM_NONE) ;            Function_Return "None"
9185>>>>>        Else If (iAttrValue = RIM_IDENTITY_COLUMN) ;            Function_Return "Identity Column"
9189>>>>>        Else If (iAttrValue = RIM_DISPENSER_TABLE) ;            Function_Return "Dispenser Table"
9193>>>>>        Else If (iAttrValue = RIM_EXTERNAL) ;            Function_Return "External"
9197>>>>>    End_Function
9198>>>>>    
9198>>>>>    
9198>>>>>    
9198>>>>>    // Convert a text to the corresponding
9198>>>>>    // Generate_Record_ID_Method attribute value
9198>>>>>    //
9198>>>>>    Function TextToROValue String sText Returns Integer
9200>>>>>        If (sText = "No") ;            Function_Return RO_NO
9203>>>>>        Else If (sText = "Ignore Change") ;            Function_Return RO_IGNORECHANGE
9207>>>>>        Else If (sText = "Accept Change") ;            Function_Return RO_ACCEPTCHANGE
9211>>>>>        Else If (sText = "Error On Change") ;            Function_Return RO_ERRORONCHANGE
9215>>>>>    End_Function
9216>>>>>    
9216>>>>>    
9216>>>>>    
9216>>>>>    // Convert a Generate_Record_ID_Method attribute value to the
9216>>>>>    // corresponding text.
9216>>>>>    //
9216>>>>>    Function ROValueToText Integer iAttrValue Returns String
9218>>>>>        If (iAttrValue = RO_NO) ;            Function_Return "No"
9221>>>>>        Else If (iAttrValue = RO_IGNORECHANGE) ;            Function_Return "Ignore Change"
9225>>>>>        Else If (iAttrValue = RO_ACCEPTCHANGE) ;            Function_Return "Accept Change"
9229>>>>>        Else If (iAttrValue = RO_ERRORONCHANGE) ;            Function_Return "Error On Change"
9233>>>>>    End_Function
9234>>>>>    
9234>>>>>    
9234>>>>>    
9234>>>>>    // Return the text f the last error geneated by the driver.
9234>>>>>    //
9234>>>>>    Function LastDriverError Returns String
9236>>>>>        String  sDriverID
9236>>>>>        String  sLastError
9236>>>>>        String  sLastErrorLength
9236>>>>>        Integer iLastErrorLength
9236>>>>>        Integer iVoid
9236>>>>>        
9236>>>>>        // Initialize
9236>>>>>        Move "" to sLastError
9237>>>>>        
9237>>>>>        Get psDriverID to sDriverID
9238>>>>>        If (sDriverID <> "") Begin
9240>>>>>            // Get the text of the last error
9240>>>>>            Move (Repeat(Character(" "), 14)) to sLastErrorlength
9241>>>>>            Call_Driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastErrorLength iVoid DRVR_LASTERRORTEXTLENGTH Result iVoid
9246>>>>>            Move (Left(sLastErrorLength, Pos(Character(0), sLastErrorLength) - 1)) to iLastErrorLength
9247>>>>>            
9247>>>>>            If (iLastErrorLength > 0) Begin
9249>>>>>                Move (Repeat(Character(" "), iLastErrorLength + 1)) to sLastError
9250>>>>>                Call_Driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastError iVoid DRVR_LASTERRORTEXT Result iVoid
9255>>>>>                Move (Left(sLastError, Pos(Character(0), sLastError) - 1)) to sLastError
9256>>>>>            End
9256>>>>>>
9256>>>>>        End
9256>>>>>>
9256>>>>>        
9256>>>>>        Function_Return sLastError
9257>>>>>    End_Function
9258>>>>>    
9258>>>>>    
9258>>>>>    
9258>>>>>    // Enumerate the tables in a database
9258>>>>>    //
9258>>>>>    Function EnumerateTables String sLogin Returns Integer
9260>>>>>        String  sDriver
9260>>>>>        String  sVoid
9260>>>>>        Integer iNumTables
9260>>>>>        Integer iVoid
9260>>>>>        
9260>>>>>        Get psDriverID to sDriver
9261>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDriver Function CLI_ENUMERATE_TABLES Callback 0 Passing sLogin sVoid iVoid Result iNumTables
9268>>>>>        
9268>>>>>        Function_Return iNumTables
9269>>>>>    End_Function
9270>>>>>    
9270>>>>>    
9270>>>>>    
9270>>>>>    // Returns the name of the table enumerated at the given position
9270>>>>>    //
9270>>>>>    Function TableName Integer iIndex Returns String
9272>>>>>        String  sDriver
9272>>>>>        String  sTableName
9272>>>>>        String  sVoid
9272>>>>>        Integer iVoid
9272>>>>>        
9272>>>>>        Get psDriverID to sDriver
9273>>>>>        If (sDriver <> "") Begin
9275>>>>>            Move (Repeat(" ", 255)) to sTableName
9276>>>>>            Call_Driver 0 sDriver Function CLI_TABLENAME Callback 0 Passing sTableName sVoid iIndex Result iVoid
9281>>>>>        End
9281>>>>>>
9281>>>>>        
9281>>>>>        Function_Return sTableName
9282>>>>>    End_Function
9283>>>>>    
9283>>>>>    
9283>>>>>    
9283>>>>>    // Returns the name of the schema of the table enumerated at the given position
9283>>>>>    //
9283>>>>>    Function SchemaName Integer iIndex Returns String
9285>>>>>        String  sDriver
9285>>>>>        String  sSchemaName
9285>>>>>        String  sVoid
9285>>>>>        Integer iVoid
9285>>>>>        
9285>>>>>        Get psDriverID to sDriver
9286>>>>>        If (sDriver <> "") Begin
9288>>>>>            Move (Repeat(" ", 255)) to sSchemaName
9289>>>>>            Call_Driver 0 sDriver Function CLI_TABLESCHEMA Callback 0 Passing sSchemaName sVoid iIndex Result iVoid
9294>>>>>        End
9294>>>>>>
9294>>>>>        
9294>>>>>        Function_Return sSchemaName
9295>>>>>    End_Function
9296>>>>>    
9296>>>>>    // Returns the type of the table enumerated at the given position.
9296>>>>>    // Types can be "TABLE", "VIEW", "SYSTEM TABLE", "GLOBAL TEMPORARY",
9296>>>>>    // "LOCAL TEMPORARY", "ALIAS", "SYNONYM"
9296>>>>>    Function TableType Integer iIndex Returns String
9298>>>>>        String  sDriver
9298>>>>>        String  sTableType
9298>>>>>        String  sVoid
9298>>>>>        Integer iVoid
9298>>>>>        
9298>>>>>        Get psDriverID to sDriver
9299>>>>>        If (sDriver <> "") Begin
9301>>>>>            Move (Repeat(" ", 25)) to sTableType
9302>>>>>            Call_Driver 0 sDriver Function CLI_TABLETYPE Callback 0 Passing sTableType sVoid iIndex Result iVoid
9307>>>>>        End
9307>>>>>>
9307>>>>>        
9307>>>>>        Function_Return sTableType
9308>>>>>    End_Function
9309>>>>>    
9309>>>>>    
9309>>>>>    // Returns the comment of the table enumerated at the given position
9309>>>>>    //
9309>>>>>    Function TableComment Integer iIndex Returns String
9311>>>>>        String  sDriver
9311>>>>>        String  sTableComment
9311>>>>>        String  sVoid
9311>>>>>        Integer iVoid
9311>>>>>        
9311>>>>>        Get psDriverID to sDriver
9312>>>>>        If (sDriver <> "") Begin
9314>>>>>            Move (Repeat(" ", 1024)) to sTableComment
9315>>>>>            Call_Driver 0 sDriver Function CLI_TABLECOMMENT Callback 0 Passing sTableComment sVoid iIndex Result iVoid
9320>>>>>        End
9320>>>>>>
9320>>>>>        
9320>>>>>        Function_Return sTableComment
9321>>>>>    End_Function
9322>>>>>    
9322>>>>>    // Enumerate the columns in a table
9322>>>>>    //
9322>>>>>    Function EnumerateColumns String sLogin String sTableName Returns Integer
9324>>>>>        String  sDriver
9324>>>>>        Integer iNumColumns
9324>>>>>        Integer iVoid
9324>>>>>        
9324>>>>>        Get psDriverID to sDriver
9325>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDriver Function CLI_ENUMERATE_COLUMNS Callback 0 Passing sLogin sTablename iVoid Result iNumColumns
9332>>>>>        
9332>>>>>        Function_Return iNumColumns
9333>>>>>    End_Function
9334>>>>>    
9334>>>>>    
9334>>>>>    
9334>>>>>    // Returns the name of the column enumerated at the given position
9334>>>>>    //
9334>>>>>    Function ColumnName Integer iIndex Returns String
9336>>>>>        String  sDriver
9336>>>>>        String  sColumnName
9336>>>>>        String  sVoid
9336>>>>>        Integer iVoid
9336>>>>>        
9336>>>>>        Get psDriverID to sDriver
9337>>>>>        If (sDriver <> "") Begin
9339>>>>>            Move (Repeat(" ", 255)) to sColumnName
9340>>>>>            Call_Driver 0 sDriver Function CLI_COLUMNNAME Callback 0 Passing sColumnName sVoid iIndex Result iVoid
9345>>>>>        End
9345>>>>>>
9345>>>>>        
9345>>>>>        Function_Return sColumnName
9346>>>>>    End_Function
9347>>>>>    
9347>>>>>    // Convert a DataFlex date to a SQL date using the dummy zero date value.
9347>>>>>    //
9347>>>>>    Function CLIDFDateToSQLDate String sDriver Date dDFDate Returns String
9349>>>>>        
9349>>>>>        Integer iDriverIndex
9349>>>>>        
9349>>>>>        String sSQLDate
9349>>>>>        Integer iOrgDateFmt
9349>>>>>        Integer iOrgDateSep
9349>>>>>        
9349>>>>>        // Change date format to military, SQL dates are military dates
9349>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
9352>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
9355>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
9358>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
9361>>>>>        
9361>>>>>        If (Integer(dDFDate = 0)) Begin
9363>>>>>            // Return the dummy zero date
9363>>>>>            Get DriverIndex sDriver to iDriverIndex
9364>>>>>            If (iDriverIndex <> 0) Begin
9366>>>>>                Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sSQLDate
9369>>>>>            End
9369>>>>>>
9369>>>>>            Else Begin
9370>>>>>                Move '0001-01-01' to sSQLDate
9371>>>>>            End
9371>>>>>>
9371>>>>>        End
9371>>>>>>
9371>>>>>        Else Begin
9372>>>>>            Move dDFDate to sSQLDate
9373>>>>>        End
9373>>>>>>
9373>>>>>        
9373>>>>>        // Change date format back to original
9373>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
9376>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
9379>>>>>        
9379>>>>>        Function_Return sSQLDate
9380>>>>>    End_Function
9381>>>>>    
9381>>>>>    
9381>>>>>    
9381>>>>>    // Convert a SQL date to a DataFlex date using the dummy zero date value.
9381>>>>>    Function CLISQLDateToDFDate String sDriver String sSQLDate Returns Date
9383>>>>>        
9383>>>>>        Integer iDriverIndex
9383>>>>>        
9383>>>>>        Date dDFDate
9383>>>>>        String sDummyDateValue
9383>>>>>        Integer iOrgDateFmt
9383>>>>>        Integer iOrgDateSep
9383>>>>>        
9383>>>>>        // Change date format to military, SQL dates are military dates
9383>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
9386>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
9389>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
9392>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
9395>>>>>        
9395>>>>>        // We only need to convert if the date is the dummy zero date value
9395>>>>>        Get DriverIndex sDriver to iDriverIndex
9396>>>>>        If (iDriverIndex <> 0) Begin
9398>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDummyDateValue
9401>>>>>        End
9401>>>>>>
9401>>>>>        Else Begin
9402>>>>>            Move '0001-01-01' to sDummyDateValue
9403>>>>>        End
9403>>>>>>
9403>>>>>        If (sDummyDateValue = sSQLDate) ;            Move 0 to dDFDate
9406>>>>>        Else ;            Move sSQLDate to dDFDate
9408>>>>>        
9408>>>>>        // Change date format back to original
9408>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
9411>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
9414>>>>>        
9414>>>>>        Function_Return dDFDate
9415>>>>>    End_Function
9416>>>>>    
9416>>>>>    Function DriverIndex String sDriver Returns Integer
9418>>>>>        
9418>>>>>        String  sCurrentDriver
9418>>>>>        Integer iNumberOfDrivers iDriver iCount
9418>>>>>        
9418>>>>>        Move 0 to iDriver
9419>>>>>        
9419>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
9422>>>>>        For iCount from 1 to iNumberOfDrivers
9428>>>>>>
9428>>>>>            
9428>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
9431>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
9433>>>>>                Move iCount to iDriver
9434>>>>>            End
9434>>>>>>
9434>>>>>        Loop
9435>>>>>>
9435>>>>>        
9435>>>>>        Function_Return iDriver
9436>>>>>        
9436>>>>>    End_Function
9437>>>>>    
9437>>>>>    
9437>>>>>    // Redirect an exisitng connection. The existing connection
9437>>>>>    // will point to another database but all tables will stay
9437>>>>>    // open!
9437>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
9439>>>>>        String  sDriver
9439>>>>>        String  sVoid
9439>>>>>        Integer iResult
9439>>>>>        Integer iVoid
9439>>>>>        
9439>>>>>        Get psDriverID to sDriver
9440>>>>>        If (sDriver <> "") Begin
9442>>>>>            Call_Driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sOldConnection sNewConnection iVoid Result iResult
9447>>>>>        End
9447>>>>>>
9447>>>>>        Function_Return iResult
9448>>>>>    End_Function
9449>>>>>    
9449>>>>>    // Redirect a connection of a connection ID
9449>>>>>    // sConnectionId must contain a valid ConnectionId ("DFCONNID=MyID")
9449>>>>>    // sConnectString must contain a valid connectstring ("SERVER=MyServer;DATABASE=MyDatabase;UID=MyName;PWD=MyPassword")
9449>>>>>    //
9449>>>>>    // RedirectIDConnectString will redirect from the old connection (Server/Database the connectionId currently points to)
9449>>>>>    // to the new connection (Server/Database specified in sConnectString)
9449>>>>>    // All opened tables will be moved from old connection to new connection. (Tables must have identical structure in both connections)
9449>>>>>    //
9449>>>>>    // If bKeepLoggedIn = false, the new connection will be logged in, the old connection will be logged out
9449>>>>>    // If bKeepLoggedIn = true, connections will remain open and re-used on next redirectIdConnection
9449>>>>>    //
9449>>>>>    // Returns:
9449>>>>>    //     0 when the redirection was successful.
9449>>>>>    //     1 if the connection ID does not exist or can not be found.
9449>>>>>    //     2 login into the new connection failed.
9449>>>>>    //
9449>>>>>    Function RedirectIdConnectString String sConnectionId String sConnectString Boolean bKeepLoggedIn Returns Integer
9451>>>>>        String  sDriver
9451>>>>>        String  sVoid
9451>>>>>        Integer iResult
9451>>>>>        
9451>>>>>        Integer iOption
9451>>>>>        
9451>>>>>        // iOption
9451>>>>>        // 0 = RedirectConnection
9451>>>>>        // 1 = RedirectIdConnectString
9451>>>>>        // 2 = RedirectIdConnectStringKeepLoggedIn
9451>>>>>        If (bKeepLoggedIn) Begin
9453>>>>>            Move 2 to iOption
9454>>>>>        End
9454>>>>>>
9454>>>>>        Else Begin
9455>>>>>            Move 1 to iOption
9456>>>>>        End
9456>>>>>>
9456>>>>>        
9456>>>>>        Get psDriverID to sDriver
9457>>>>>        If (sDriver <> "") Begin
9459>>>>>            Call_Driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sConnectionId sConnectString iOption Result iResult
9464>>>>>        End
9464>>>>>>
9464>>>>>        Function_Return iResult
9465>>>>>    End_Function
9466>>>>>    
9466>>>>>    
9466>>>>>    // Create a DataFlex side connection id that can be used later on.
9466>>>>>    //
9466>>>>>    Function CreateConnectionID String sID String sConnStr Integer iOpt Returns Integer
9468>>>>>        String  sDriver
9468>>>>>        Integer iResult
9468>>>>>        Integer iOptions
9468>>>>>        
9468>>>>>        Get psDriverID to sDriver
9469>>>>>        If (Num_Arguments = 2) ;            Move 0 to iOptions
9472>>>>>        Else ;            Move iOpt to iOptions
9474>>>>>        If (sDriver <> "") Begin
9476>>>>>            Call_Driver 0 sDriver Function CLI_CREATECONNECTIONID Callback 0 Passing sID sConnStr iOptions Result iResult
9481>>>>>        End
9481>>>>>>
9481>>>>>        Function_Return iResult
9482>>>>>    End_Function
9483>>>>>    
9483>>>>>    
9483>>>>>    
9483>>>>>    // Delete a DataFlex side connection id.
9483>>>>>    //
9483>>>>>    Function DeleteConnectionID String sID Integer iIndex Returns Integer
9485>>>>>        String  sDriver
9485>>>>>        Integer iResult
9485>>>>>        String sVoid
9485>>>>>        
9485>>>>>        Get psDriverID to sDriver
9486>>>>>        If (sDriver <> "") Begin
9488>>>>>            Call_Driver 0 sDriver Function CLI_DELETECONNECTIONID Callback 0 Passing sID sVoid iIndex Result iResult
9493>>>>>        End
9493>>>>>>
9493>>>>>        Function_Return iResult
9494>>>>>    End_Function
9495>>>>>    
9495>>>>>End_Class
9496>>>
9496>>>Use Dferror.pkg
Including file: Dferror.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Dferror.pkg)
9496>>>>>Use LanguageText.pkg
9496>>>>>Use Windows.pkg
9496>>>>>Use msgbox.pkg
9496>>>>>Use GlobalFunctionsProcedures.pkg
9496>>>>>
9496>>>>>// Include or define all useful symbols.
9496>>>>>Use errornum.inc
9496>>>>>// these are kept for compatibility. Don't use them
9496>>>>>
9496>>>>>// used by error handler and UserError to pull a caption out of the error string
9496>>>>>Define C_ErrorCaption for "*CAPTION*="
9496>>>>>
9496>>>>>// This array stores the set of trapped errors as toggled ranges starting
9496>>>>>// with the errors that are trapped. The array should always contain 0 and
9496>>>>>// MAX_ERROR_NUMBER + 1, which are the limits. If an array contained the
9496>>>>>// following items...
9496>>>>>//
9496>>>>>// { 0, 5, 10, MAX_ERROR_NUMBER + 1 }.
9496>>>>>//
9496>>>>>// This would mean that errors 1 - 4 are trapped, 5 - 9 are ignored, and
9496>>>>>// 10 through the rest are trapped.
9496>>>>>//
9496>>>>>Class Trapped_Errors_Array is an array
9497>>>>>    
9497>>>>>    // Find largest error LE targetError. Assumes array is sorted.
9497>>>>>    Function findErrorLE Integer targetError Returns Integer
9499>>>>>        
9499>>>>>        Integer lowIndex hiIndex midIndex currError
9499>>>>>        
9499>>>>>        // If error is outside of boudary conditions, use
9499>>>>>        // value of closest valid error# instead.
9499>>>>>        If (targetError <= 0);            Move 1 to targetError
9502>>>>>        Else If (targetError >= MAX_ERROR_NUMBER) ;            Move ( MAX_ERROR_NUMBER - 1 ) to targetError
9506>>>>>        
9506>>>>>        Move 0 to lowIndex
9507>>>>>        Move ( item_count( Self ) - 1 ) to hiIndex
9508>>>>>        
9508>>>>>        // midIndex will contain the closest error LE to target upon exit.
9508>>>>>        Repeat
9508>>>>>>
9508>>>>>            
9508>>>>>            Move ( ( lowIndex + hiIndex ) / 2 ) to midIndex
9509>>>>>            Move ( integer_value( Self, midIndex ) )  to currError
9510>>>>>            
9510>>>>>            // midIndex is targetIndex if a match occurs
9510>>>>>            If (currError = targetError) ;                Function_Return midIndex
9513>>>>>            
9513>>>>>            // We are either on it or just below it.
9513>>>>>            If ( lowIndex = midIndex ) Begin
9515>>>>>                
9515>>>>>                If ( integer_value( Self, hiIndex ) le targetError ) ;                    Move hiIndex to midIndex
9518>>>>>                
9518>>>>>                Function_Return midIndex
9519>>>>>                
9519>>>>>            End
9519>>>>>>
9519>>>>>            
9519>>>>>            // No match, so move the boundaries.
9519>>>>>            If (currError > targetError) ;                Move ( midIndex - 1 ) to hiIndex
9522>>>>>            Else ;                Move midIndex to lowIndex
9524>>>>>            
9524>>>>>        Until lowIndex gt hiIndex
9526>>>>>        
9526>>>>>        Function_Return midIndex
9527>>>>>        
9527>>>>>    End_Function
9528>>>>>    
9528>>>>>    // Boundaries of the table are assumed to hold error limits.
9528>>>>>    Procedure initArray
9530>>>>>        Send delete_data
9531>>>>>        Set array_value 0 to 0
9532>>>>>        Set array_value 1 to ( MAX_ERROR_NUMBER + 1 )
9533>>>>>    End_Procedure
9534>>>>>    
9534>>>>>    // Return 1 if Error is trapped, 0 otherwise.
9534>>>>>    Function IsTrapped Integer Error# Returns Integer
9536>>>>>        Function_Return ( not ( mod( findErrorLE( Self, Error# ), 2 ) ) )
9537>>>>>    End_Function
9538>>>>>    
9538>>>>>    // Add the error as long as it doesn't violate boundary conditions.
9538>>>>>    // This routine leaves the array unsorted.
9538>>>>>    Procedure addError Integer Error#
9540>>>>>        If ( ( Error# lt MAX_ERROR_NUMBER ) and ( Error# gt 0 ) ) ;            Set array_value ( item_count( Self ) ) to ( Integer( Error# ) )
9543>>>>>    End_Procedure
9544>>>>>    
9544>>>>>    // Set error to flagged state.
9544>>>>>    Procedure handleError Integer Error# Integer trapFlag
9546>>>>>        
9546>>>>>        Integer prevErrIndex prevErrFlag prevErrValue nextErrValue
9546>>>>>        
9546>>>>>        If ( ( Error# gt MAX_ERROR_NUMBER ) or ( Error# lt 0 ) ) Begin
9548>>>>>            Error DFERR_ERROR_NUMBER_OUT_OF_RANGE
9549>>>>>>
9549>>>>>            Procedure_Return
9550>>>>>        End
9550>>>>>>
9550>>>>>        
9550>>>>>        Get findErrorLE Error# to prevErrIndex
9551>>>>>        Get isTrapped   Error# to prevErrFlag
9552>>>>>        
9552>>>>>        // if eq, Error already handled in some range.
9552>>>>>        If (prevErrFlag <> trapFlag) Begin
9554>>>>>            
9554>>>>>            // This is kind of complicated. If we are adding an error,
9554>>>>>            // we have to account for the error already being in the
9554>>>>>            // array as well as rejoining ranges that have been previously
9554>>>>>            // split and splitting ranges when adding a new flag.
9554>>>>>            
9554>>>>>            Get integer_value ( prevErrIndex + 1 ) to nextErrValue
9555>>>>>            Get integer_value prevErrIndex         to prevErrValue
9556>>>>>            
9556>>>>>            // Do this first so prevErrIndex stays valid.
9556>>>>>            If (nextErrValue = ( Error# + 1 )) ;                Send delete_item ( prevErrIndex + 1 )
9559>>>>>            Else ;                Send addError ( Error# + 1 )
9561>>>>>            
9561>>>>>            If ( prevErrValue lt Error# ) ;                Send addError Error#
9564>>>>>            Else ;                Send delete_item prevErrIndex
9566>>>>>        End
9566>>>>>>
9566>>>>>        Send sort_items UPWARD_DIRECTION
9567>>>>>        
9567>>>>>    End_Procedure
9568>>>>>    
9568>>>>>    // Flag error as trappable
9568>>>>>    Procedure Trap_Error Integer Error#
9570>>>>>        Send handleError Error# 1
9571>>>>>    End_Procedure
9572>>>>>    
9572>>>>>    // Flag error as non-trappable
9572>>>>>    Procedure Ignore_Error Integer Error#
9574>>>>>        Send handleError Error# 0
9575>>>>>    End_Procedure
9576>>>>>    
9576>>>>>    // Flag all errors as trappable
9576>>>>>    Procedure Trap_All
9578>>>>>        Send initArray
9579>>>>>    End_Procedure
9580>>>>>    
9580>>>>>    // Flag all errors as non-trappable
9580>>>>>    Procedure Ignore_All
9582>>>>>        Send delete_data
9583>>>>>        Set array_value 0 to 0
9584>>>>>        Set array_value 1 to 1
9585>>>>>        Set array_value 2 to ( MAX_ERROR_NUMBER + 1 )
9586>>>>>    End_Procedure
9587>>>>>    
9587>>>>>End_Class
9588>>>>>
9588>>>>>
9588>>>>>Class ErrorSystem is a cObject
9589>>>>>    
9589>>>>>    Procedure construct_object
9591>>>>>        Forward Send construct_object
9593>>>>>        
9593>>>>>        Set delegation_mode to no_delegate_or_error
9594>>>>>        
9594>>>>>        Property Integer Verbose_State            True
9595>>>>>        Property Integer Current_Error_Number     0
9596>>>>>        Property Integer Error_Line_Number        0
9597>>>>>        
9597>>>>>        // If set false, this makes the error handler work the old way which
9597>>>>>        // does not use the new unhandled dialog. Only exists for compatibility reasons
9597>>>>>        Property Boolean pbUnhandledErrorSupport       True
9598>>>>>        
9598>>>>>        // shows error numbers with user errors. Only set this true if your
9598>>>>>        // application has meaningful numbers that helps the end user. Note that
9598>>>>>        // unhandled errors always show numbers.
9598>>>>>        // this is ignored if pbUnhandledErrorSupport is false
9598>>>>>        Property Boolean pbShowErrorNumber        False
9599>>>>>        
9599>>>>>        
9599>>>>>        // This is the caption that appears for unhandled errors dialog box
9599>>>>>        Property String psUnhandledErrorCaption C_$UnhandledProgramError
9600>>>>>        
9600>>>>>        // This is the caption that appears for standard user errors
9600>>>>>        Property String psUserErrorCaption C_$Error
9601>>>>>        
9601>>>>>        // Flag which is sent when error is being processed. This
9601>>>>>        // stops error recursion.
9601>>>>>        Property Integer Error_Processing_State  False
9602>>>>>        
9602>>>>>        // array of errors that we consider User Errors
9602>>>>>        Property Integer[] pUserErrorsArray
9603>>>>>        
9603>>>>>        //  This allows us to skip find errors (GT & LT) and to only
9603>>>>>        //  ring a bell when these occur.
9603>>>>>        //
9603>>>>>        Property Integer Bell_on_Find_Error_State True
9604>>>>>        
9604>>>>>        Object TrappedErrors is a Trapped_Errors_Array
9606>>>>>            Send initArray
9607>>>>>        End_Object
9608>>>>>        
9608>>>>>        Send Trap_All
9609>>>>>        
9609>>>>>        // define the standard user error numbers
9609>>>>>        Send AddUserError 0
9610>>>>>        Send AddUserError DFERR_NUMBER_TOO_LARGE
9611>>>>>        Send AddUserError DFERR_WINDOW_RANGE
9612>>>>>        Send AddUserError DFERR_ENTRY_REQUIRED
9613>>>>>        Send AddUserError DFERR_ENTER_A_NUMBER
9614>>>>>        Send AddUserError DFERR_BAD_ENTRY
9615>>>>>        Send AddUserError DFERR_ENTER_VALID_DATE
9616>>>>>        Send AddUserError DFERR_NUMERIC_RANGE
9617>>>>>        Send AddUserError DFERR_DUPLICATE_REC
9618>>>>>        Send AddUserError DFERR_TEXT_FIELD_TOO_LONG
9619>>>>>        Send AddUserError DFERR_FIND_PRIOR_BEG_OF_FILE
9620>>>>>        Send AddUserError DFERR_FIND_PAST_END_OF_FILE
9621>>>>>        Send AddUserError DFERR_NO_REC_TO_DELETE
9622>>>>>        Send AddUserError DFERR_FIELD_NOT_INDEXED // can be invoked w/ find keys
9623>>>>>        Send AddUserError DFERR_REC_NUMBER_RANGE
9624>>>>>        Send AddUserError DFERR_ENTER_VALID_REC_ID
9625>>>>>        Send AddUserError DFERR_OPERATOR_ERROR
9626>>>>>        Send AddUserError DFERR_CANT_CHANGE_KEY_FIELD
9627>>>>>        Send AddUserError DFERR_NO_DELETE_RELATED_RECORDS_EXIST
9628>>>>>        Send AddUserError DFERR_OPERATION_NOT_ALLOWED
9629>>>>>        Send AddUserError DFERR_OPERATOR
9630>>>>>        Send AddUserError DFERR_XML_HTTP
9631>>>>>        Send AddUserError DFERR_CLIENT_SOAP_TRANSFER
9632>>>>>        Send AddUserError DFERR_CLIENT_SOAP_FAULT
9633>>>>>        Send AddUserError DFERR_TEXT_TOO_LARGE_FOR_FIELD
9634>>>>>        Send AddUserError DFERR_WINPRINT
9635>>>>>        Send AddUserError DFERR_CRYSTAL_REPORT
9636>>>>>        Send AddUserError DFERR_MAPI
9637>>>>>        Send AddUserError DFERR_FILE_ACCESS_VIOLATION
9638>>>>>        Send AddUserError DFERR_DATAFLEX_REPORTS
9639>>>>>        Send AddUserError DFERR_CANT_REFIND_RECORD
9640>>>>>        Send AddUserError 999 // This is defined as DD_DEFAULT_ERROR_NUMBER in DataDict.pkg and is the default Field_error
9641>>>>>        // number of DDs.
9641>>>>>        Move Self to Error_Object_Id
9642>>>>>    End_Procedure
9643>>>>>    
9643>>>>>    Function Help_Context Integer Context_Type Returns String
9645>>>>>        Function_Return (Current_Error_Number(Self))
9646>>>>>    End_Function
9647>>>>>    
9647>>>>>    // Catch and display error Error#.
9647>>>>>    Procedure Trap_Error Integer Error#
9649>>>>>        Send Trap_Error to ( trappedErrors( Self ) ) Error#
9650>>>>>    End_Procedure
9651>>>>>    
9651>>>>>    // Pass error Error# on to the regular DataFlex error handler.
9651>>>>>    Procedure Ignore_Error Integer Error#
9653>>>>>        Send Ignore_Error to ( trappedErrors( Self ) ) Error#
9654>>>>>    End_Procedure
9655>>>>>    
9655>>>>>    // Catch and display all errors.
9655>>>>>    Procedure Trap_All
9657>>>>>        Send Trap_All to ( trappedErrors( Self ) )
9658>>>>>    End_Procedure
9659>>>>>    
9659>>>>>    // Forward all error to regular DataFlex error handler.
9659>>>>>    Procedure Ignore_All
9661>>>>>        Send Ignore_All to ( trappedErrors( Self ) )
9662>>>>>    End_Procedure
9663>>>>>    
9663>>>>>    // Build complete error description from Flexerrs and user error message.
9663>>>>>    Function Error_Description Integer Error# String ErrMsg Returns String
9665>>>>>        String Full_Error_Text
9665>>>>>        
9665>>>>>        Move (Trim(ErrMsg)) to ErrMsg
9666>>>>>        Move (trim(error_text(DESKTOP,Error#))) to Full_Error_Text
9667>>>>>        
9667>>>>>        If (ErrMsg<>"") Begin
9669>>>>>            
9669>>>>>            If ( ( Full_Error_Text<>"" ) and ;                error_text_available( DESKTOP, Error# ) ) Begin
9671>>>>>                // Make sure last character of error text is a separating symbol.
9671>>>>>                // if not, add a "." So we have format of "error-text. error-detail"
9671>>>>>                If ( pos(right(Full_error_text,1),".,:;")=0 ) ;                    Move (Full_Error_Text - ".") to Full_Error_Text
9674>>>>>                Move (Full_Error_Text * ErrMsg) to Full_Error_Text
9675>>>>>            End
9675>>>>>>
9675>>>>>            Else ;                Move ErrMsg to Full_Error_Text
9677>>>>>            
9677>>>>>        End
9677>>>>>>
9677>>>>>        
9677>>>>>        Function_Return Full_Error_Text
9678>>>>>    End_Function
9679>>>>>    
9679>>>>>    // return true if an error number is critical
9679>>>>>    Function Is_Critical Integer Error# Returns Integer
9681>>>>>        Function_Return (".3.10.18.19.20.21.22.43.70.72.74.75.78.80.97.";            contains ("."+String(Error#)+"."))
9682>>>>>    End_Function
9683>>>>>    
9683>>>>>    // adds a user error to the array
9683>>>>>    Procedure AddUserError Integer iError
9685>>>>>        Integer[] UserErrors
9686>>>>>        Get pUserErrorsArray to UserErrors
9687>>>>>        // We assume that there are few enough user errors to worry about speed of finding
9687>>>>>        // the an array item. It always does a linear seach, which should be plenty fast.
9687>>>>>        If (SearchArray(iError,UserErrors)=-1) Begin
9689>>>>>            Move iError to UserErrors[SizeOfArray(UserErrors)]
9690>>>>>            Set pUserErrorsArray to UserErrors
9691>>>>>        End
9691>>>>>>
9691>>>>>    End_Procedure
9692>>>>>    
9692>>>>>    // removes an error from the user array
9692>>>>>    Procedure RemoveUserError Integer iError
9694>>>>>        Integer[] UserErrors
9695>>>>>        Integer iIndex iSize
9695>>>>>        Get pUserErrorsArray to UserErrors
9696>>>>>        Move (SearchArray(iError,UserErrors)) to iIndex
9697>>>>>        If (iIndex<>-1) Begin
9699>>>>>            // replace the removed error with the last error and resize the array
9699>>>>>            Move (SizeOfArray(UserErrors)) to iSize
9700>>>>>            Move UserErrors[iSize-1] to UserErrors[iIndex]
9701>>>>>            Set pUserErrorsArray to (ResizeArray(UserErrors,iSize-1))
9702>>>>>        End
9702>>>>>>
9702>>>>>    End_Procedure
9703>>>>>    
9703>>>>>    // removes all user errors
9703>>>>>    Procedure RemoveAllUserErrors
9705>>>>>        Integer[] UserErrors
9706>>>>>        Set pUserErrorsArray to UserErrors
9707>>>>>    End_Procedure
9708>>>>>    
9708>>>>>    // returns true if this is an unhandled error (i.e., not a user error
9708>>>>>    Function IsUnhandledError Integer iError Returns Boolean
9710>>>>>        Integer[] UserErrors
9711>>>>>        Get pUserErrorsArray to UserErrors
9712>>>>>        Function_Return (SearchArray(iError,UserErrors)=-1)
9713>>>>>    End_Function
9714>>>>>    
9714>>>>>    Procedure UnhandledErrorDisplay Integer iErrorLine String sMessage
9716>>>>>        String sCaption sCRLF
9716>>>>>        Move (Character(13)+Character(10)) to sCRLF
9717>>>>>        Get psUnhandledErrorCaption to sCaption
9718>>>>>        Move (Replaces("\n",sMessage,sCRLF)) to sMessage
9719>>>>>        Move (Replaces("\"+sCRLF, sMessage, "\n")) to sMessage
9720>>>>>        ErrorDisplay iErrorLine sMessage sCaption C_$OK C_$Copy
9721>>>>>    End_Procedure
9722>>>>>    
9722>>>>>    // Handle error event, displaying error info to user.
9722>>>>>    Procedure Error_Report Integer ErrNum Integer Err_Line String ErrMsg
9724>>>>>        Integer iReply iIcon
9724>>>>>        String  sErrorText sMess
9724>>>>>        String  sSource sCaption
9724>>>>>        Integer iSrcPos iSrc iTxtLen
9724>>>>>        Boolean bIsUnhandled bUnhandledSupport bCritical bVerbose
9724>>>>>        
9724>>>>>        If (Error_processing_State(Self)) Begin // don't allow error
9726>>>>>            Procedure_Return                     // recursion
9727>>>>>        End
9727>>>>>>
9727>>>>>        
9727>>>>>        Set Error_Processing_State to True // we are now in an error reporting state
9728>>>>>        
9728>>>>>        Set Current_Error_Number to ErrNum
9729>>>>>        Set Error_Line_Number    to Err_Line
9730>>>>>        
9730>>>>>        // if this is false, this will work old-style -- all errors go through message box
9730>>>>>        Get pbUnhandledErrorSupport to bUnhandledSupport
9731>>>>>        
9731>>>>>        Get Is_Critical errnum to bCritical
9732>>>>>        Get IsUnhandledError ErrNum to bIsUnhandled
9733>>>>>        
9733>>>>>        
9733>>>>>        //
9733>>>>>        //   Changes made so find errors don't report - just beep
9733>>>>>        //
9733>>>>>        
9733>>>>>        If ( Bell_On_find_Error_State(Self) and ;            ErrNum=DFERR_FIND_PRIOR_BEG_OF_FILE or ErrNum=DFERR_FIND_PAST_END_OF_FILE) Begin
9735>>>>>            Send Bell
9736>>>>>        End
9736>>>>>>
9736>>>>>        Else If not ( isTrapped( TrappedErrors( Self ), ErrNum ) ) Begin
9739>>>>>            // if trapped do nothing
9739>>>>>            
9739>>>>>            // We used to forward send. Since this is based on array, it does not understand this message, the forward was
9739>>>>>            // not understood. Since arrays don't delegate or error, nothing happened.
9739>>>>>            // An easier way to do nothing, is to do nothing, hence this line if removed
9739>>>>>            //forward send Error_Report ErrNum Err_Line ErrMsg
9739>>>>>        End
9739>>>>>>
9739>>>>>        Else Begin
9740>>>>>            
9740>>>>>            // See if source information is provided (Source = module.function). If so remove
9740>>>>>            // as detail. Must find last instance of this in string
9740>>>>>            Move (pos(C_ErrorContextSourceText,ErrMsg)) to iSrc
9741>>>>>            If iSrc Begin
9743>>>>>                Move (iSrc-1) to iSrcPos
9744>>>>>                Move (length(C_ErrorContextSourceText)) to  iTxtLen
9745>>>>>                Move ErrMsg to sSource
9746>>>>>                Repeat // this makes sure we find last instance of this
9746>>>>>>
9746>>>>>                    Move (remove(sSource, 1, iSrc-1 + iTxtLen )) to sSource // right part of string
9747>>>>>                    Move (pos(C_ErrorContextSourceText,sSource)) to iSrc           // see if it was the last
9748>>>>>                    If iSrc ;                                               // if not, track length                        Move (iSrcPos + iTxtLen + iSrc-1) to iSrcPos
9751>>>>>                Until (iSrc=0)
9753>>>>>                Move (trim(left(ErrMsg,iSrcPos))) to ErrMsg
9754>>>>>                If (right(ErrMsg,1)=',') ;                    Move (left(ErrMsg,length(ErrMsg)-1)) to ErrMsg
9757>>>>>            End
9757>>>>>>
9757>>>>>            
9757>>>>>            // the caption normally used for handled user errors
9757>>>>>            Get psUserErrorCaption to sCaption
9758>>>>>            // if an operator error this may be a Procedure UserError situation where the
9758>>>>>            // caption is passed in the error text. If so, get the caption
9758>>>>>            If (ErrNum=DFERR_OPERATOR) Begin
9760>>>>>                Move (pos(C_ErrorCaption,ErrMsg)) to iSrc
9761>>>>>                If iSrc Begin
9763>>>>>                    Move (length(C_ErrorCaption)) to  iTxtLen
9764>>>>>                    Move (remove(ErrMsg, 1, iSrc-1 + iTxtLen )) to sCaption
9765>>>>>                    Move (Left(ErrMsg,iSrc-1)) to ErrMsg
9766>>>>>                End
9766>>>>>>
9766>>>>>            End
9766>>>>>>
9766>>>>>            
9766>>>>>            Get Error_Description ErrNum ErrMsg to sErrorText
9767>>>>>            
9767>>>>>            // if the error source is identified we can get extended error
9767>>>>>            // text for our error message
9767>>>>>            If ghoErrorSource Begin
9769>>>>>                Get extended_error_Message of ghoErrorSource to sMess
9770>>>>>                If (sMess <> '') ;                    Move (sErrorText + "\n\n" + sMess ) to sErrorText
9773>>>>>            End
9773>>>>>>
9773>>>>>            
9773>>>>>            If (bUnhandledSupport) Begin
9775>>>>>                // as of 14.1, this is the preferred way to do errors
9775>>>>>                If ( bCritical or bIsUnhandled) Begin
9777>>>>>                    Move ( sErrorText + "\n\n" + C_$Error + ":" * String(ErrNum) ) to sErrorText
9778>>>>>                    If (sSource<>"") Begin
9780>>>>>                        Move (sErrorText + "\n" + C_$ErrorSource +" =" * sSource) to sErrorText
9781>>>>>                    End
9781>>>>>>
9781>>>>>                End
9781>>>>>>
9781>>>>>                Else If (pbShowErrorNumber(Self)) Begin
9784>>>>>                    // if a user error, we provide a way to see error numbers.
9784>>>>>                    Move ( sErrorText + "\n\n" + C_$Error + ":" * String(ErrNum) ) to sErrorText
9785>>>>>                End
9785>>>>>>
9785>>>>>            End
9785>>>>>>
9785>>>>>            Else Begin
9786>>>>>                // we get here if we want it to work the old (less good) way. This is provided
9786>>>>>                // only for backwards compatibility. All errors go through the message box
9786>>>>>                Get Verbose_State to bVerbose
9787>>>>>                If (bVerbose)  Begin
9789>>>>>                    Move ( sErrorText + "\n\n" + SFormat(C_$TechnicalDetails, ErrNum, Err_Line) ) to sErrorText
9790>>>>>                    If (sSource<>"") Begin
9792>>>>>                        Move (sErrorText + "\n" + C_$ErrorSource +" =" * sSource) to sErrorText
9793>>>>>                    End
9793>>>>>>
9793>>>>>                End
9793>>>>>>
9793>>>>>            End
9793>>>>>>
9793>>>>>            
9793>>>>>            If ( (bCritical or bIsUnhandled) and bUnhandledSupport) Begin
9795>>>>>                Send UnhandledErrorDisplay Err_Line sErrorText
9796>>>>>            End
9796>>>>>>
9796>>>>>            Else Begin
9797>>>>>                Move (If(bCritical,MB_IconHand,MB_IconExclamation)) to iIcon
9798>>>>>                Move (Message_Box(sErrorText, sCaption, MB_Ok, iIcon)) to iReply
9799>>>>>            End
9799>>>>>>
9799>>>>>            
9799>>>>>            // abort on critical errors
9799>>>>>            If bCritical ;                Abort
9802>>>>>            
9802>>>>>        End
9802>>>>>>
9802>>>>>        Move 0 to ghoErrorSource
9803>>>>>        Set Error_Processing_State to False // no longer reporting an error
9804>>>>>    End_Procedure
9805>>>>>    
9805>>>>>    
9805>>>>>    // The following functions are rarely or never used.
9805>>>>>    
9805>>>>>    // The functions below are used to construct a general help
9805>>>>>    // name for errors that are generated by the system.  If processing
9805>>>>>    // comes here, then there was no module specific help found.  These
9805>>>>>    // functions will provide a more general help name that appears in
9805>>>>>    // the form of SYSTEM..ERROR:#.  All global errors should be
9805>>>>>    // places in the help file under this application and module name.
9805>>>>>    
9805>>>>>    // Returns "ERROR:errornum" to supply error help.
9805>>>>>    Function Help_Name Returns String
9807>>>>>        Function_Return (Append("ERROR:",lastErr))
9808>>>>>    End_Function
9809>>>>>    
9809>>>>>    Function Application_Name Returns String
9811>>>>>        Function_Return 'SYSTEM'
9812>>>>>    End_Function
9813>>>>>    
9813>>>>>    Function Module_Name Returns String
9815>>>>>        Function_Return ''
9816>>>>>    End_Function
9817>>>>>End_Class
9818>>>>>
9818>>>>>Object Error_Info_Object is a ErrorSystem
9820>>>>>End_Object
9821>>>>>
9821>>>>>
9821>>>>>Procedure UserError Global String sMessage String sCaption
9823>>>>>    String sCapt
9823>>>>>    If (Error_Object_Id=0) Begin
9825>>>>>        Error DFERR_PROGRAM "No Error Handler"
9826>>>>>>
9826>>>>>        Procedure_Return
9827>>>>>    End
9827>>>>>>
9827>>>>>    
9827>>>>>    // Accept not passing a caption in which case the error handler's
9827>>>>>    // default caption. It had been the intention to require a caption ("" if none)
9827>>>>>    // but having no caption kind of worked where the caption would be "0". Since it
9827>>>>>    // kind of worked, I don't want to remove this which might generate runtime errors.
9827>>>>>    If (num_arguments>1) Begin
9829>>>>>        Move sCaption to sCapt
9830>>>>>    End
9830>>>>>>
9830>>>>>    
9830>>>>>    Error DFERR_OPERATOR (sMessage + If(sCapt<>"",C_ErrorCaption + sCapt,""))
9831>>>>>>
9831>>>>>    
9831>>>>>End_Procedure
9832>>>
9832>>>
9832>>>Use sql.pkg
Including file: sql.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\sql.pkg)
9832>>>>>// Embedded SQL classes for use with Data Access Worldwide CLI    
9832>>>>>// Connectivty Kits.                                              
9832>>>>>Use CLI.pkg
9832>>>>>
9832>>>>>// Global storage for results
9832>>>>>Integer SQLResult
9832>>>>>
9832>>>>>// Embedded SQL function constants
9832>>>>>Define FUNC_SQLCONNECT             for 1000000
9832>>>>>Define FUNC_SQLFILECONNECT         for 1000001
9832>>>>>Define FUNC_SQLDISCONNECT          for 1000002
9832>>>>>Define FUNC_SQLOPEN                for 1000003
9832>>>>>Define FUNC_SQLCLOSE               for 1000004
9832>>>>>Define FUNC_SQLPREPARE             for 1000005
9832>>>>>Define FUNC_SQLEXECUTE             for 1000006
9832>>>>>Define FUNC_SQLEXECDIRECT          for 1000007
9832>>>>>Define FUNC_SQLFETCH               for 1000008
9832>>>>>Define FUNC_SQLCOLUMNINFO          for 1000009
9832>>>>>Define FUNC_SQLCOLUMNVALUE         for 1000010
9832>>>>>Define FUNC_SQLBINDFILE            for 1000011
9832>>>>>Define FUNC_SQLGETDATA             for 1000012
9832>>>>>Define FUNC_SQLCOLSTRINGATTRIBLEN  for 1000013
9832>>>>>Define FUNC_SQLCOLSTRINGATTRIB     for 1000014
9832>>>>>Define FUNC_SQLCOLINTATTRIB        for 1000015
9832>>>>>Define FUNC_SQLSTMTINTATTRIB       for 1000016
9832>>>>>Define FUNC_SQLSETPROCNAME         for 1000017
9832>>>>>Define FUNC_SQLSETPROCARG          for 1000018
9832>>>>>Define FUNC_SQLCALL                for 1000019
9832>>>>>Define FUNC_SQLGETPROCARGLEN       for 1000020
9832>>>>>Define FUNC_SQLGETPROCARG          for 1000021
9832>>>>>Define FUNC_SQLGETPROCRETVALLEN    for 1000022
9832>>>>>Define FUNC_SQLGETPROCRETVAL       for 1000023
9832>>>>>Define FUNC_SQLNEXTRESULTSET       for 1000024
9832>>>>>Define FUNC_SQLBUFFERSTATUS        for 1000025
9832>>>>>Define FUNC_SQLSETPROCSCHEMA       for 1000026
9832>>>>>Define FUNC_SQLGETMESSAGE          for 1000027
9832>>>>>Define FUNC_SQLSETSTMTINTATTRIB    for 1000028
9832>>>>>
9832>>>>>// Embedded SQL statement attribute constants
9832>>>>>Define SQLSTMTATTRIB_COLUMNCOUNT    for 1
9832>>>>>Define SQLSTMTATTRIB_ROWCOUNT       for 2
9832>>>>>Define SQLSTMTATTRIB_ROWCOUNT_TYPE  for 3
9832>>>>>Define SQLSTMTATTRIB_NUMMESSAGES    for 4
9832>>>>>Define SQLSTMTATTRIB_CURSOR_TYPE    for 5
9832>>>>>
9832>>>>>// Embedded SQL possible values for SQLSTMTATTRIB_CURSOR_TYPE
9832>>>>>Define SQL_CURSOR_FORWARD_ONLY      for 0
9832>>>>>Define SQL_CURSOR_KEYSET_DRIVEN     for 1
9832>>>>>Define SQL_CURSOR_DYNAMIC           for 2
9832>>>>>Define SQL_CURSOR_STATIC            for 3
9832>>>>>
9832>>>>>
9832>>>>>// Embedded SQL column attribute constants
9832>>>>>Define SQLCOLATTRIB_SIZE           for 1
9832>>>>>Define SQLCOLATTRIB_LENGTH         for 1
9832>>>>>Define SQLCOLATTRIB_PRECISION      for 2
9832>>>>>Define SQLCOLATTRIB_LABEL          for 3
9832>>>>>Define SQLCOLATTRIB_BASECOLUMNNAME for 4
9832>>>>>Define SQLCOLATTRIB_BASETABLENAME  for 5
9832>>>>>Define SQLCOLATTRIB_SQLTYPE        for 6
9832>>>>>Define SQLCOLATTRIB_NULLABLE       for 7
9832>>>>>Define SQLCOLATTRIB_DFTYPE         for 8
9832>>>>>
9832>>>>>
9832>>>>>// Types used for conversion with ConvertToXml
9832>>>>>Define esqlTime      for 8
9832>>>>>Define esqlDatetime  for 9
9832>>>>>
9832>>>>>// Global variables holding last executed embedded SQL connection and statement handles.
9832>>>>>Integer giLastSQLhdbc
9832>>>>>Integer giLastSQLhstmt
9832>>>>>
9832>>>>>Move -1 to giLastSQLhdbc
9833>>>>>Move -1 to giLastSQLhstmt
9834>>>>>
9834>>>>>Struct tSQLColumn
9834>>>>>    Integer iSQLType
9834>>>>>    Integer iSQLSize
9834>>>>>    Integer iSQLPrecision
9834>>>>>    Integer iVariableDataType
9834>>>>>End_Struct
9834>>>>>
9834>>>>>// Statement object for embedded sql                           
9834>>>>>//   An object is created for each statement. These will be children    
9834>>>>>//   of cSQLConnection objects which manage the create and destruction  
9834>>>>>//   of these.                                                          
9834>>>>>
9834>>>>>Class cSQLStatement is a cObject
9835>>>>>    
9835>>>>>    Procedure Construct_object
9837>>>>>        Forward Send Construct_object
9839>>>>>        
9839>>>>>        Property Handle  phCLIStatementHandle   0
9840>>>>>        Property Handle  phCLIConnectionHandle  0
9841>>>>>        Property String  psDriverID             ""
9842>>>>>        
9842>>>>>        Property Integer piLastColumn      0
9843>>>>>        Property Integer piLastArgument    0
9844>>>>>        Property Integer piBindFile        0
9845>>>>>        Property Integer piColumnCount     0
9846>>>>>        
9846>>>>>        // Allocated buffer for SQLColumnValue.
9846>>>>>        // Allocated size is size of the largest (not variable length) column
9846>>>>>        Property String  psMaxColValue     ""
9847>>>>>        
9847>>>>>        // True if there is at least 1 column with a variable length data type
9847>>>>>        Property Integer piHasVariableDataType  0
9848>>>>>        
9848>>>>>        // Max size of buffer for variable length data. Default 16000
9848>>>>>        Property Integer piMaxVariableBufferLength 16000
9849>>>>>        
9849>>>>>        // Allocated buffer for SQLGetData.
9849>>>>>        Property String  psVariableBuffer  ""
9850>>>>>        
9850>>>>>        // Allocated size of psVariableBuffer
9850>>>>>        Property Integer piVariableBufferLength 0
9851>>>>>        
9851>>>>>        // Stores column properties of a result set.
9851>>>>>        Property tSQLColumn[] paSQLColumns
9852>>>>>        
9852>>>>>        // piFetchResult is set by SQLFetchRowValues and SQLFetchResultSetValues
9852>>>>>        //   0    = Fetch returned no data.
9852>>>>>        //   <> 0 = Row fetched
9852>>>>>        Property Integer piFetchResult     0
9853>>>>>        
9853>>>>>        
9853>>>>>        Property String psDummyZeroDate              '0001-01-01'
9854>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'
9855>>>>>        
9855>>>>>    End_Procedure
9856>>>>>    
9856>>>>>    // Store basic information about the statement.
9856>>>>>    Procedure StoreStatementInfo Handle hCLIStatementHandle String sDrvrId Handle hCLIConnectionHandle
9858>>>>>        
9858>>>>>        Set phCLIStatementHandle   to hCLIStatementHandle
9859>>>>>        Set phCLIConnectionHandle  to hCLIConnectionHandle
9860>>>>>        Set psDriverID             to sDrvrId
9861>>>>>        
9861>>>>>    End_Procedure
9862>>>>>    
9862>>>>>    
9862>>>>>    // Destroy the cSQLStatement object
9862>>>>>    Procedure DestroySQLStatement
9864>>>>>        Send Destroy
9865>>>>>    End_Procedure
9866>>>>>    
9866>>>>>    // Handle an error that has occurred while checking properties.
9866>>>>>    Procedure HandleError Integer ihstmt Integer ihdbc String sDrvrId String sOriginMsg
9868>>>>>        Integer iErrHandle
9868>>>>>        Integer iErrNum
9868>>>>>        String  sLocationInfo
9868>>>>>        
9868>>>>>        // Get the DataFlex statement identifier
9868>>>>>        Move Self to iErrHandle
9869>>>>>        
9869>>>>>        // Determine error number
9869>>>>>        If (ihstmt = 0) ;            Move CLIERR_SQLINVALID_CLI_STMT_HANDLE to iErrNum
9872>>>>>        Else If (ihdbc = 0) ;            Move CLIERR_SQLINVALID_CLI_CONN_HANDLE to iErrNum
9876>>>>>        Else If (sDrvrId = "") ;            Move CLIERR_SQLINVALID_DRIVER_ID to iErrNum
9880>>>>>        Else ;            Move CLIERR_SQL_ERROR to iErrNum
9882>>>>>        
9882>>>>>        // Create location ifnormation
9882>>>>>        Move "[" to sLocationInfo
9883>>>>>        If (sOriginMsg <> "") Begin
9885>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
9886>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
9887>>>>>        End
9887>>>>>>
9887>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
9888>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
9889>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
9890>>>>>        
9890>>>>>        // Generate the error
9890>>>>>        Error iErrNum sLocationInfo
9891>>>>>>
9891>>>>>    End_Procedure
9892>>>>>    
9892>>>>>    // Handle general error not related to the properties
9892>>>>>    Procedure StmtError Integer iErrNum String sErrText String sOriginMsg
9894>>>>>        Integer iErrHandle
9894>>>>>        String  sLocationInfo
9894>>>>>        
9894>>>>>        // Get the DataFlex statement identifier
9894>>>>>        Move Self to iErrHandle
9895>>>>>        
9895>>>>>        // Create location information
9895>>>>>        Move "[" to sLocationInfo
9896>>>>>        If (sOriginMsg <> "") Begin
9898>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
9899>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
9900>>>>>        End
9900>>>>>>
9900>>>>>        If (sErrtext <> "") Begin
9902>>>>>            Move (Append(sLocationInfo, sErrtext)) to sLocationInfo
9903>>>>>            Move (Append(sLocationInfo, ", "))     to sLocationInfo
9904>>>>>        End
9904>>>>>>
9904>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
9905>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
9906>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
9907>>>>>        
9907>>>>>        // Generate the error
9907>>>>>        Error iErrNum sLocationInfo
9908>>>>>>
9908>>>>>    End_Procedure
9909>>>>>    
9909>>>>>    // Handle an illegal attribute error
9909>>>>>    Procedure SQLIllegalAttribute String sErrText String sOriginMsg
9911>>>>>        Integer bReport
9911>>>>>        
9911>>>>>        Get_Attribute DF_REPORT_UNSUPPORTED_ATTRIBUTES to bReport
9914>>>>>        If (bReport) ;            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE sErrtext sOriginMsg
9917>>>>>    End_Procedure
9918>>>>>    
9918>>>>>    // Check if a column number is legal
9918>>>>>    Function SQLPrivateColumnIsLegal Integer ihdbc String sDrvrId Integer ihstmt Integer iCol Returns Integer
9920>>>>>        Integer bLegal
9920>>>>>        Integer iNumColumns
9920>>>>>        
9920>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
9921>>>>>        If (iCol > 0 and iCol <= iNumColumns) ;            Move DFTRUE to bLegal
9924>>>>>        Else ;            Move DFFALSE to bLegal
9926>>>>>        
9926>>>>>        Function_Return bLegal
9927>>>>>    End_Function
9928>>>>>    
9928>>>>>    
9928>>>>>    
9928>>>>>    // Close a statement and free all alllocated resources
9928>>>>>    Procedure SQLClose
9930>>>>>        Integer ihdbc
9930>>>>>        Integer ihstmt
9930>>>>>        Integer iVoid
9930>>>>>        String  sDrvrId
9930>>>>>        String  sEmpty
9930>>>>>        
9930>>>>>        // Initialize
9930>>>>>        Move "" to sEmpty
9931>>>>>        
9931>>>>>        // Get the cli handles
9931>>>>>        Get phCLIStatementHandle  to ihstmt
9932>>>>>        Get phCLIConnectionHandle to ihdbc
9933>>>>>        Get psDriverId            to sDrvrId
9934>>>>>        
9934>>>>>        // Free the CLI handle
9934>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
9936>>>>>            // Call the driver function to close
9936>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCLOSE ;                Callback Self ;                Passing ihdbc sEmpty ihstmt ;                Result iVoid
9941>>>>>            
9941>>>>>            Move -1 to giLastSQLhstmt
9942>>>>>            // Free the DataFlex handle
9942>>>>>            Send DestroySQLStatement
9943>>>>>        End
9943>>>>>>
9943>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLClose"
9945>>>>>    End_Procedure
9946>>>>>    
9946>>>>>    // Prepare a statement for execution
9946>>>>>    Procedure SQLPrepare String sStatement
9948>>>>>        Integer ihdbc
9948>>>>>        Integer ihstmt
9948>>>>>        Integer iVoid
9948>>>>>        String  sDrvrId
9948>>>>>        
9948>>>>>        // Get the cli handles
9948>>>>>        Get phCLIStatementHandle  to ihstmt
9949>>>>>        Get phCLIConnectionHandle to ihdbc
9950>>>>>        Get psDriverId            to sDrvrId
9951>>>>>        
9951>>>>>        // Prepare
9951>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
9953>>>>>            // Call the driver function to prepare
9953>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLPREPARE ;                Callback Self ;                Passing ihdbc sStatement ihstmt ;                Result iVoid
9958>>>>>            Set piLastArgument to 0
9959>>>>>
9959>>>>>        End
9959>>>>>>
9959>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrepare"
9961>>>>>    End_Procedure
9962>>>>>    
9962>>>>>    Procedure SQLGetStatementAttributes
9964>>>>>        Integer ihdbc ihstmt iNumColumns iCol iMaxSize
9964>>>>>        String sMaxValue
9964>>>>>        tSQLColumn[] aSQLColumns
9964>>>>>        tSQLColumn[] aSQLColumns
9965>>>>>        
9965>>>>>        Integer iSqlType
9965>>>>>        Integer iSQLSize
9965>>>>>        Integer iSQLprecision
9965>>>>>        Integer iVariableDataType
9965>>>>>        
9965>>>>>        String  sDrvrId
9965>>>>>        
9965>>>>>        Integer iHasVariableDataType
9965>>>>>        
9965>>>>>        Move 0 to iHasVariableDataType
9966>>>>>        
9966>>>>>        
9966>>>>>        // Get the cli handles
9966>>>>>        Get phCLIStatementHandle  to ihstmt
9967>>>>>        Get phCLIConnectionHandle to ihdbc
9968>>>>>        Get psDriverId            to sDrvrId
9969>>>>>        
9969>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
9970>>>>>        
9970>>>>>        Set piColumnCount to iNumColumns
9971>>>>>        
9971>>>>>        // Fill columns array
9971>>>>>        For iCol from 1 to iNumColumns
9977>>>>>>
9977>>>>>            Move 0 to iVariableDataType
9978>>>>>            
9978>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SQLTYPE ihdbc sDrvrId ihstmt to iSQLType
9979>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SIZE ihdbc sDrvrId ihstmt to iSQLSize
9980>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_PRECISION ihdbc sDrvrId ihstmt to iSQLPrecision
9981>>>>>            
9981>>>>>            If ( (iSQLType = SQL_LONGVARCHAR) or (iSQLType = SQL_WLONGVARCHAR) ) Begin
9983>>>>>                // text type
9983>>>>>                Move 1 to iVariableDataType
9984>>>>>            End
9984>>>>>>
9984>>>>>            Else Begin
9985>>>>>                If (sDrvrId = "MSSQLDRV") Begin
9987>>>>>                    // SQL Server varchar(max) and nvarchar(max) types return Size = 0
9987>>>>>                    If ( ((iSQLType = SQL_VARCHAR) and (iSQLSize = 0) ) or ;                        ((iSQLType = SQL_WVARCHAR) and (iSQLSize = 0) ) ) Begin
9989>>>>>                        
9989>>>>>                        Move 1 to iVariableDataType
9990>>>>>                    End
9990>>>>>>
9990>>>>>                End
9990>>>>>>
9990>>>>>            End
9990>>>>>>
9990>>>>>            
9990>>>>>            Move iSqlType           to aSQLColumns[iCol].iSQLType
9991>>>>>            Move iSQLSize           to aSQLColumns[iCol].iSQLSize
9992>>>>>            Move iSQLPrecision      to aSQLColumns[iCol].iSQLPrecision
9993>>>>>            Move iVariableDataType  to aSQLColumns[iCol].iVariableDataType
9994>>>>>            
9994>>>>>            If (not(iVariableDataType)) Begin
9996>>>>>                If (iSQLSize > iMaxSize) Begin
9998>>>>>                    Move iSQLSize to iMaxSize
9999>>>>>                End
9999>>>>>>
9999>>>>>            End
9999>>>>>>
9999>>>>>            Else Begin
10000>>>>>                Move 1 to iHasVariableDataType
10001>>>>>            End
10001>>>>>>
10001>>>>>            
10001>>>>>        Loop
10002>>>>>>
10002>>>>>        
10002>>>>>        Move (Repeat(' ', iMaxSize + 3)) to sMaxValue
10003>>>>>        Set psMaxColValue to sMaxValue
10004>>>>>        
10004>>>>>        Set paSQLColumns   to aSQLColumns
10005>>>>>        Set piHasVariableDataType to iHasVariableDataType
10006>>>>>        
10006>>>>>    End_Procedure
10007>>>>>    
10007>>>>>    // Execute a prepared statement
10007>>>>>    Procedure SQLExecute
10009>>>>>        Integer ihdbc
10009>>>>>        Integer ihstmt
10009>>>>>        Integer iVoid
10009>>>>>        String  sDrvrId
10009>>>>>        String  sEmpty
10009>>>>>        
10009>>>>>        // Initialize
10009>>>>>        Move "" to sEmpty
10010>>>>>        
10010>>>>>        // Get the cli handles
10010>>>>>        Get phCLIStatementHandle  to ihstmt
10011>>>>>        Get phCLIConnectionHandle to ihdbc
10012>>>>>        Get psDriverId            to sDrvrId
10013>>>>>        
10013>>>>>        // Execute
10013>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10015>>>>>            // Call the driver function to execute
10015>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLEXECUTE ;                Callback Self ;                Passing ihdbc sEmpty ihstmt ;                Result iVoid
10020>>>>>            Send SQLGetStatementAttributes
10021>>>>>            Set piLastArgument to 0
10022>>>>>        End
10022>>>>>>
10022>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecute"
10024>>>>>    End_Procedure
10025>>>>>    
10025>>>>>    
10025>>>>>    
10025>>>>>    // Prepare and execute a statement
10025>>>>>    Procedure SQLExecDirect String sStatement
10027>>>>>        Integer ihdbc
10027>>>>>        Integer ihstmt
10027>>>>>        Integer iVoid
10027>>>>>        String  sDrvrId
10027>>>>>        
10027>>>>>        // Get the cli handles
10027>>>>>        Get phCLIStatementHandle  to ihstmt
10028>>>>>        Get phCLIConnectionHandle to ihdbc
10029>>>>>        Get psDriverId            to sDrvrId
10030>>>>>        
10030>>>>>        // ExecDirect
10030>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10032>>>>>            // Call the driver function to execdirect
10032>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLEXECDIRECT ;                Callback Self ;                Passing ihdbc sStatement ihstmt ;                Result iVoid
10037>>>>>            Send SQLGetStatementAttributes
10038>>>>>        End
10038>>>>>>
10038>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecDirect"
10040>>>>>    End_Procedure
10041>>>>>    
10041>>>>>    // Fetch the next row
10041>>>>>    // Returns  : 0   = No more data
10041>>>>>    //<>0 = Success
10041>>>>>    Function SQLFetch Returns Integer
10043>>>>>        Integer ihdbc
10043>>>>>        Integer ihstmt
10043>>>>>        Integer iResult
10043>>>>>        String  sDrvrId
10043>>>>>        String  sEmpty
10043>>>>>        
10043>>>>>        // Initialize
10043>>>>>        Move "" to sEmpty
10044>>>>>        Move 0  to iResult
10045>>>>>        
10045>>>>>        // Get the cli handles
10045>>>>>        Get phCLIStatementHandle  to ihstmt
10046>>>>>        Get phCLIConnectionHandle to ihdbc
10047>>>>>        Get psDriverId            to sDrvrId
10048>>>>>        
10048>>>>>        // Fetch
10048>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10050>>>>>            Move False to Err
10051>>>>>            
10051>>>>>            // Call the driver function to fetch
10051>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
10056>>>>>            
10056>>>>>            // If something went wrong, adjust the result
10056>>>>>            If (Err) ;                Move 0 to iResult
10059>>>>>            
10059>>>>>            Set piLastcolumn to 0
10060>>>>>        End
10060>>>>>>
10060>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLFetch"
10062>>>>>        
10062>>>>>        Function_Return iResult
10063>>>>>    End_Function
10064>>>>>    
10064>>>>>    // Fetch the next row and return an array with all column values
10064>>>>>    // Returns  : Array of strings with all column values
10064>>>>>    // Sets piFetchResult property
10064>>>>>    //   0    = No more data
10064>>>>>    //   <> 0 = Success
10064>>>>>    Function SQLFetchRowValues Returns String[]
10066>>>>>        
10066>>>>>        String[] asValues
10067>>>>>        
10067>>>>>        tSQLColumn[] aSQLColumns
10067>>>>>        tSQLColumn[] aSQLColumns
10068>>>>>        
10068>>>>>        Integer ihdbc
10068>>>>>        Integer ihstmt
10068>>>>>        Integer iResult iVoid
10068>>>>>        Integer iColCount iCol
10068>>>>>        String  sDrvrId
10068>>>>>        String  sEmpty
10068>>>>>        String  sResult
10068>>>>>        String  sVariableResult
10068>>>>>        Integer iHasVariableDataType
10068>>>>>        Integer iLen
10068>>>>>        Integer iVariableBufferLength
10068>>>>>        
10068>>>>>        // Initialize
10068>>>>>        Move "" to sEmpty
10069>>>>>        Move 0  to iResult
10070>>>>>        
10070>>>>>        // Get the cli handles
10070>>>>>        Get phCLIStatementHandle  to ihstmt
10071>>>>>        Get phCLIConnectionHandle to ihdbc
10072>>>>>        Get psDriverId            to sDrvrId
10073>>>>>        
10073>>>>>        Get paSQLColumns to aSQLColumns
10074>>>>>        Get piColumnCount to iColCount
10075>>>>>        Get piHasVariableDataType to iHasVariableDataType
10076>>>>>        
10076>>>>>        If (iHasVariableDataType) Begin
10078>>>>>            
10078>>>>>            Get piVariableBufferLength      to iVariableBufferLength
10079>>>>>            Get piMaxVariableBufferLength   to iLen
10080>>>>>            
10080>>>>>            If (iLen > iVariableBufferLength) Begin
10082>>>>>                // Allocate
10082>>>>>                Move (Repeat(' ', iLen)) to sVariableResult
10083>>>>>                
10083>>>>>                Set piVariableBufferLength to iLen
10084>>>>>                Set psVariableBuffer       to sVariableResult
10085>>>>>                
10085>>>>>                Get piVariableBufferLength to iVariableBufferLength
10086>>>>>            End
10086>>>>>>
10086>>>>>        End
10086>>>>>>
10086>>>>>        
10086>>>>>        // Fetch
10086>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10088>>>>>            Move (False) to Err
10089>>>>>            
10089>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
10089>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
10089>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
10089>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
10091>>>>>                // Setup function arguments
10091>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
10096>>>>>                Move ihstmt to giLastSQLhstmt
10097>>>>>                Move ihdbc to giLastSQLhdbc
10098>>>>>            End
10098>>>>>>
10098>>>>>            
10098>>>>>            // Call the driver function to fetch
10098>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback 0 Passing ihdbc sEmpty ihstmt Result iResult
10103>>>>>            
10103>>>>>            // If something went wrong, adjust the result
10103>>>>>            If (Err) ;                Move 0 to iResult
10106>>>>>            
10106>>>>>            If (iResult) Begin
10108>>>>>                For iCol from 1 to iColCount
10114>>>>>>
10114>>>>>                    
10114>>>>>                    If (not(aSQLColumns[iCol].iVariableDataType)) Begin
10116>>>>>                        Get psMaxColValue to sResult
10117>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE Callback 0 Passing sResult sEmpty iCol Result iVoid
10122>>>>>                        
10122>>>>>                        Move sResult to asValues[iCol - 1]
10123>>>>>                    End
10123>>>>>>
10123>>>>>                    Else Begin
10124>>>>>                        Get psVariableBuffer       to sVariableResult
10125>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                            Callback 0 ;                            Passing sVariableResult iCol iVariableBufferLength ;                            Result iVoid
10130>>>>>                        
10130>>>>>                        Move sVariableResult to asValues[iCol - 1]
10131>>>>>                    End
10131>>>>>>
10131>>>>>                    
10131>>>>>                Loop
10132>>>>>>
10132>>>>>            End
10132>>>>>>
10132>>>>>        End
10132>>>>>>
10132>>>>>        Else Begin
10133>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLFetchRowValues"
10134>>>>>        End
10134>>>>>>
10134>>>>>        
10134>>>>>        Set piFetchResult to iResult
10135>>>>>        
10135>>>>>        Function_Return asValues
10136>>>>>        
10136>>>>>    End_Function
10137>>>>>    
10137>>>>>    // Fetch a complete result set.
10137>>>>>    // Returns  : 2-dimensional array of strings with result set
10137>>>>>    // Sets piFetchResult property
10137>>>>>    //   0    = No more data
10137>>>>>    //   <> 0 = Success
10137>>>>>    Function SQLFetchResultsetValues Returns String[][]
10139>>>>>        
10139>>>>>        String[][] asValues
10140>>>>>        
10140>>>>>        Integer ihdbc ihstmt iResult iVoid iColCount iCol iRow
10140>>>>>        String sDrvrId sEmpty sResult sMax
10140>>>>>        
10140>>>>>        tSQLColumn[] aSQLColumns
10140>>>>>        tSQLColumn[] aSQLColumns
10141>>>>>        String  sVariableResult
10141>>>>>        Integer iHasVariableDataType
10141>>>>>        Integer iLen
10141>>>>>        Integer iVariableBufferLength
10141>>>>>        
10141>>>>>        // Initialize
10141>>>>>        Move "" to sEmpty
10142>>>>>        Move 0  to iResult
10143>>>>>        
10143>>>>>        // Get the cli handles
10143>>>>>        Get phCLIStatementHandle  to ihstmt
10144>>>>>        Get phCLIConnectionHandle to ihdbc
10145>>>>>        Get psDriverId            to sDrvrId
10146>>>>>        
10146>>>>>        // Fetch
10146>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10148>>>>>            Move False to Err
10149>>>>>            
10149>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
10149>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
10149>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
10149>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
10151>>>>>                // Setup function arguments
10151>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
10156>>>>>                Move ihstmt to giLastSQLhstmt
10157>>>>>                Move ihdbc to giLastSQLhdbc
10158>>>>>            End
10158>>>>>>
10158>>>>>            
10158>>>>>            
10158>>>>>            Get paSQLColumns to aSQLColumns
10159>>>>>            Get piColumnCount to iColCount
10160>>>>>            Get piHasVariableDataType to iHasVariableDataType
10161>>>>>            If (iHasVariableDataType) Begin
10163>>>>>                Get piVariableBufferLength      to iVariableBufferLength
10164>>>>>                Get piMaxVariableBufferLength   to iLen
10165>>>>>                If (iLen > iVariableBufferLength) Begin
10167>>>>>                    // Allocate
10167>>>>>                    Move (Repeat(' ', iLen)) to sVariableResult
10168>>>>>                    
10168>>>>>                    Set piVariableBufferLength to iLen
10169>>>>>                    Set psVariableBuffer       to sVariableResult
10170>>>>>                    
10170>>>>>                    Get piVariableBufferLength to iVariableBufferLength
10171>>>>>                End
10171>>>>>>
10171>>>>>                Else Begin
10172>>>>>                    Set psVariableBuffer       to sVariableResult
10173>>>>>                End
10173>>>>>>
10173>>>>>            End
10173>>>>>>
10173>>>>>            
10173>>>>>            Get psMaxColValue to sMax
10174>>>>>            
10174>>>>>            // Call the driver function to fetch
10174>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
10179>>>>>            If (Err) ;                Move 0 to iResult
10182>>>>>            
10182>>>>>            While (iResult <> 0)
10186>>>>>                
10186>>>>>                For iCol from 1 to (iColCount)
10192>>>>>>
10192>>>>>                    
10192>>>>>                    If (not(aSQLColumns[iCol].iVariableDataType)) Begin
10194>>>>>                        Move sMax to sResult
10195>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                            Callback 0 ;                            Passing sResult sEmpty iCol ;                            Result iVoid
10200>>>>>                        Move sResult to asValues[iRow][iCol - 1]
10201>>>>>                    End
10201>>>>>>
10201>>>>>                    Else Begin
10202>>>>>                        //Variable data
10202>>>>>                        Move sVariableResult to sResult
10203>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                            Callback 0 ;                            Passing sResult iCol iVariableBufferLength ;                            Result iVoid
10208>>>>>                        
10208>>>>>                        Move sResult to asValues[iRow][iCol - 1]
10209>>>>>                    End
10209>>>>>>
10209>>>>>                Loop
10210>>>>>>
10210>>>>>                
10210>>>>>                Increment iRow
10211>>>>>                
10211>>>>>                // Call the driver function to fetch
10211>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
10216>>>>>                If (Err) ;                    Move 0 to iResult
10219>>>>>                
10219>>>>>            Loop
10220>>>>>>
10220>>>>>            
10220>>>>>        End
10220>>>>>>
10220>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLFetchResultsetValues"
10222>>>>>        
10222>>>>>        Set piFetchResult to iResult
10223>>>>>        
10223>>>>>        Function_Return asValues
10224>>>>>    End_Function
10225>>>>>    
10225>>>>>    // Get the next column
10225>>>>>    Function SQLNextColumn Returns String
10227>>>>>        Integer iCol
10227>>>>>        String  sResult
10227>>>>>        
10227>>>>>        Get piLastColumn to iCol
10228>>>>>        Increment iCol
10229>>>>>        Get SQLColumnValue iCol to sResult
10230>>>>>        Set piLastColumn to iCol
10231>>>>>        
10231>>>>>        Function_Return sResult
10232>>>>>    End_Function
10233>>>>>    
10233>>>>>    
10233>>>>>    // Returns the native type of a column
10233>>>>>    Function SQLColumnType Integer iCol Returns Integer
10235>>>>>        Integer ihdbc
10235>>>>>        Integer ihstmt
10235>>>>>        String  sDrvrId
10235>>>>>        Integer iSQLType
10235>>>>>        Integer iColumns
10235>>>>>        
10235>>>>>        tSQLColumn[] aSQLColumns
10235>>>>>        tSQLColumn[] aSQLColumns
10236>>>>>        
10236>>>>>        // Get the cli handles
10236>>>>>        Get phCLIStatementHandle  to ihstmt
10237>>>>>        Get phCLIConnectionHandle to ihdbc
10238>>>>>        Get psDriverId            to sDrvrId
10239>>>>>        
10239>>>>>        // Get the value
10239>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10241>>>>>            
10241>>>>>            Get paSQLColumns   to aSQLColumns
10242>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
10243>>>>>            
10243>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
10245>>>>>                Move aSQLColumns[iCol].iSQLType to iSQLType
10246>>>>>            End
10246>>>>>>
10246>>>>>            Else Begin
10247>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnType"
10248>>>>>            End
10248>>>>>>
10248>>>>>        End
10248>>>>>>
10248>>>>>        Else Begin
10249>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnType"
10250>>>>>        End
10250>>>>>>
10250>>>>>        
10250>>>>>        Function_Return iSQLType
10251>>>>>    End_Function
10252>>>>>    
10252>>>>>    // Returns the size (max length) of a column
10252>>>>>    Function SQLColumnSize Integer iCol Returns Integer
10254>>>>>        Integer ihdbc
10254>>>>>        Integer ihstmt
10254>>>>>        String  sDrvrId
10254>>>>>        Integer iSQLSize
10254>>>>>        Integer iColumns
10254>>>>>        
10254>>>>>        tSQLColumn[] aSQLColumns
10254>>>>>        tSQLColumn[] aSQLColumns
10255>>>>>        
10255>>>>>        // Get the cli handles
10255>>>>>        Get phCLIStatementHandle  to ihstmt
10256>>>>>        Get phCLIConnectionHandle to ihdbc
10257>>>>>        Get psDriverId            to sDrvrId
10258>>>>>        
10258>>>>>        // Get the value
10258>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10260>>>>>            
10260>>>>>            Get paSQLColumns   to aSQLColumns
10261>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
10262>>>>>            
10262>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
10264>>>>>                Move aSQLColumns[iCol].iSQLSize to iSQLSize
10265>>>>>            End
10265>>>>>>
10265>>>>>            Else Begin
10266>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnSize"
10267>>>>>            End
10267>>>>>>
10267>>>>>        End
10267>>>>>>
10267>>>>>        Else Begin
10268>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnSize"
10269>>>>>        End
10269>>>>>>
10269>>>>>        
10269>>>>>        Function_Return iSQLSize
10270>>>>>    End_Function
10271>>>>>    
10271>>>>>    //  Returns 1 for variable length datatypes.
10271>>>>>    //  For example SQL Server varchar(max) or text type
10271>>>>>    //  The data of variable length datatype columns should be retrieved with SQLGetData
10271>>>>>    Function SQLColumnVariableDatatype Integer iCol Returns Integer
10273>>>>>        Integer ihdbc
10273>>>>>        Integer ihstmt
10273>>>>>        String  sDrvrId
10273>>>>>        Integer iVariableDataType
10273>>>>>        Integer iColumns
10273>>>>>        
10273>>>>>        tSQLColumn[] aSQLColumns
10273>>>>>        tSQLColumn[] aSQLColumns
10274>>>>>        
10274>>>>>        // Get the cli handles
10274>>>>>        Get phCLIStatementHandle  to ihstmt
10275>>>>>        Get phCLIConnectionHandle to ihdbc
10276>>>>>        Get psDriverId            to sDrvrId
10277>>>>>        
10277>>>>>        // Get the value
10277>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10279>>>>>            
10279>>>>>            Get paSQLColumns   to aSQLColumns
10280>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
10281>>>>>            
10281>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
10283>>>>>                Move aSQLColumns[iCol].iVariableDataType to iVariableDataType
10284>>>>>            End
10284>>>>>>
10284>>>>>            Else Begin
10285>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnVariableDatatype"
10286>>>>>            End
10286>>>>>>
10286>>>>>        End
10286>>>>>>
10286>>>>>        Else Begin
10287>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnVariableDatatype"
10288>>>>>        End
10288>>>>>>
10288>>>>>        
10288>>>>>        Function_Return iVariableDataType
10289>>>>>    End_Function
10290>>>>>    
10290>>>>>    
10290>>>>>    // Return the value of a column in a fetched row of a given
10290>>>>>    // statement.
10290>>>>>    Function SQLColumnValue Integer iCol Returns String
10292>>>>>        Integer ihdbc
10292>>>>>        Integer ihstmt
10292>>>>>        String  sDrvrId
10292>>>>>        String  sResult
10292>>>>>        
10292>>>>>        Integer iVoid
10292>>>>>        Integer iColSize
10292>>>>>        Integer iColPrecision
10292>>>>>        String  sEmpty
10292>>>>>        Integer bLegalColumn
10292>>>>>        
10292>>>>>        // Initialize
10292>>>>>        Move "" to sResult
10293>>>>>        
10293>>>>>        // Get the cli handles
10293>>>>>        Get phCLIStatementHandle  to ihstmt
10294>>>>>        Get phCLIConnectionHandle to ihdbc
10295>>>>>        Get psDriverId            to sDrvrId
10296>>>>>        
10296>>>>>        // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
10296>>>>>        // in the next FUNC_SQLCOLUMNVALUE call.
10296>>>>>        // If hdbc and hstmt have not changed since the last call we don't have to set it.
10296>>>>>        If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
10298>>>>>            // Setup function arguments
10298>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback 0 ;                Passing ihdbc iCol ihstmt ;                Result iVoid
10303>>>>>            Move ihstmt to giLastSQLhstmt
10304>>>>>            Move ihdbc to giLastSQLhdbc
10305>>>>>        End
10305>>>>>>
10305>>>>>        
10305>>>>>        If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
10307>>>>>            Get psMaxColValue to sResult
10308>>>>>            // Call the driver function to get the value
10308>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                Callback 0 ;                Passing sResult sEmpty iCol ;                Result iVoid
10313>>>>>        End
10313>>>>>>
10313>>>>>        Else Begin
10314>>>>>            Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnValue"
10315>>>>>        End
10315>>>>>>
10315>>>>>        
10315>>>>>        Function_Return sResult
10316>>>>>        
10316>>>>>    End_Function
10317>>>>>    
10317>>>>>    // Add a file to the files used to place the statement result in.
10317>>>>>    Procedure SQLBindFile Integer iFileNum
10319>>>>>        Integer ihdbc
10319>>>>>        Integer ihstmt
10319>>>>>        Integer iVoid
10319>>>>>        String  sDrvrId
10319>>>>>        String  sFileType
10319>>>>>        Integer bIsOpen
10319>>>>>        
10319>>>>>        // Get the cli handles
10319>>>>>        Get phCLIStatementHandle  to ihstmt
10320>>>>>        Get phCLIConnectionHandle to ihdbc
10321>>>>>        Get psDriverId            to sDrvrId
10322>>>>>        
10322>>>>>        // If a file number is not passed see if we can use the statement's
10322>>>>>        // default file number which is usually set with SetFileConnection
10322>>>>>        If (iFileNum = 0) Begin
10324>>>>>            Get piBindFile to iFileNum
10325>>>>>            If (iFileNum = 0) Begin
10327>>>>>                // Logic error, if 0 is passed as filenumber, piBindFile should be set.
10327>>>>>                Send StmtError CLIERR_SQLINVALID_BIND_FILE "piBindFile should be set" "SQLBindFile"
10328>>>>>                
10328>>>>>                Move 0 to SQLResult
10329>>>>>                Procedure_Return
10330>>>>>            End
10330>>>>>>
10330>>>>>        End
10330>>>>>>
10330>>>>>        
10330>>>>>        // Bind the file
10330>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10332>>>>>            // Chek if the file is open
10332>>>>>            Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
10335>>>>>            If (bIsOpen) Begin
10337>>>>>                // Check if the file has the correct type
10337>>>>>                Get_Attribute DF_FILE_DRIVER of iFileNum to sFileType
10340>>>>>                If (sFileType = sDrvrId) Begin
10342>>>>>                    // Call the driver function to add a file to a statement
10342>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLBINDFILE ;                        Callback Self ;                        Passing ihdbc iFileNum ihstmt ;                        Result iVoid
10347>>>>>                End
10347>>>>>>
10347>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
10349>>>>>            End
10349>>>>>>
10349>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File not open (number =" * String(iFileNum) + ")") "SQLBindFile"
10351>>>>>        End
10351>>>>>>
10351>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLBindFile"
10353>>>>>    End_Procedure
10354>>>>>    
10354>>>>>    
10354>>>>>    
10354>>>>>    // Get data of a column.                                  
10354>>>>>    Function SQLGetData Integer iCol Integer iLen Returns String
10356>>>>>        Integer ihdbc
10356>>>>>        Integer ihstmt
10356>>>>>        Integer iVoid
10356>>>>>        Integer iColSize
10356>>>>>        Integer iResult
10356>>>>>        String  sDrvrId
10356>>>>>        String  sResult
10356>>>>>        String  sEmpty
10356>>>>>        Integer bLegalColumn
10356>>>>>        
10356>>>>>        Integer iVariableBufferLength
10356>>>>>        
10356>>>>>        // Initialize
10356>>>>>        Move "" to sEmpty
10357>>>>>        Move 0 to iResult
10358>>>>>        
10358>>>>>        // Get the cli handles
10358>>>>>        Get phCLIStatementHandle  to ihstmt
10359>>>>>        Get phCLIConnectionHandle to ihdbc
10360>>>>>        Get psDriverId            to sDrvrId
10361>>>>>        
10361>>>>>        // Get the data
10361>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10363>>>>>            // Check if the column exists
10363>>>>>            If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
10365>>>>>                If (iLen = 0) Begin
10367>>>>>                    Get SQLColumnValue iCol to sResult
10368>>>>>                End
10368>>>>>>
10368>>>>>                Else Begin
10369>>>>>                    // Add 1 for string terminator
10369>>>>>                    Move (iLen + 1) to iLen
10370>>>>>                    
10370>>>>>                    Get piVariableBufferLength to iVariableBufferLength
10371>>>>>                    If (iLen > iVariableBufferLength) Begin
10373>>>>>                        // Allocate
10373>>>>>                        Move (Repeat(' ', iLen)) to sResult
10374>>>>>                        
10374>>>>>                        Set piVariableBufferLength to iLen
10375>>>>>                        Set psVariableBuffer       to sResult
10376>>>>>                    End
10376>>>>>>
10376>>>>>                    Else Begin
10377>>>>>                        Get psVariableBuffer       to sResult
10378>>>>>                    End
10378>>>>>>
10378>>>>>                    
10378>>>>>                    
10378>>>>>                    // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
10378>>>>>                    // in the next FUNC_SQLCOLUMNVALUE call.
10378>>>>>                    // If hdbc and hstmt have not changed since the last call we don't have to set it.
10378>>>>>                    If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
10380>>>>>                        // Setup function arguments
10380>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                            Callback 0 ;                            Passing ihdbc iCol ihstmt ;                            Result iVoid
10385>>>>>                        Move ihstmt to giLastSQLhstmt
10386>>>>>                        Move ihdbc to giLastSQLhdbc
10387>>>>>                    End
10387>>>>>>
10387>>>>>                    
10387>>>>>                    Move False to Err
10388>>>>>                    // Call the driver function to get the data
10388>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                        Callback Self ;                        Passing sResult iCol iLen ;                        Result iResult
10393>>>>>                    
10393>>>>>                    // If something went wrong, adjust the result
10393>>>>>                    If (Err) Begin
10395>>>>>                        Move 0 to iResult
10396>>>>>                    End
10396>>>>>>
10396>>>>>                End
10396>>>>>>
10396>>>>>            End
10396>>>>>>
10396>>>>>            Else Begin
10397>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLGetData"
10398>>>>>            End
10398>>>>>>
10398>>>>>        End
10398>>>>>>
10398>>>>>        Else Begin
10399>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLGetData"
10400>>>>>        End
10400>>>>>>
10400>>>>>        
10400>>>>>        // Fill global result
10400>>>>>        Move iResult to SQLResult
10401>>>>>        
10401>>>>>        Function_Return sResult
10402>>>>>    End_Function
10403>>>>>    
10403>>>>>    
10403>>>>>    
10403>>>>>    // Map a column name to a number, if the name id not found no
10403>>>>>    // error is generated the returned number will be 0 (zero) in
10403>>>>>    // that case
10403>>>>>    Function SQLColumnMap String sColname Returns Integer
10405>>>>>        Integer ihdbc
10405>>>>>        Integer ihstmt
10405>>>>>        Integer iNumColumns
10405>>>>>        Integer iColCount
10405>>>>>        Integer iColNum
10405>>>>>        String  sDrvrId
10405>>>>>        String  sCurColName
10405>>>>>        
10405>>>>>        // Get the cli handles
10405>>>>>        Get phCLIStatementHandle  to ihstmt
10406>>>>>        Get phCLIConnectionHandle to ihdbc
10407>>>>>        Get psDriverId            to sDrvrId
10408>>>>>        
10408>>>>>        // Get the number by looping through the column names
10408>>>>>        Move 0 to iColNum
10409>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
10410>>>>>        For iColCount from 1 to iNumColumns
10416>>>>>>
10416>>>>>            Get SQLPrivateColAttribute iColCount SQLCOLATTRIB_LABEL ihdbc sDrvrId ihstmt to sCurColName
10417>>>>>            If (Uppercase(Trim(sColName)) = Uppercase(Trim(sCurColName))) ;                Move iColCount to iColNum
10420>>>>>            
10420>>>>>            If (iColNum) ;                Break
10423>>>>>        Loop
10424>>>>>>
10424>>>>>        
10424>>>>>        Function_Return iColNum
10425>>>>>    End_Function
10426>>>>>    
10426>>>>>    
10426>>>>>    // SQLStmtAttribute
10426>>>>>    // Moved to SQLGetStatementAttribute. 
10426>>>>>    // This function is still here for backward compatibility.
10426>>>>>
10426>>>>>    Function SQLStmtAttribute Integer iAttribId Returns String
10428>>>>>        String  sResult
10428>>>>>
10428>>>>>        Get SQLGetStmtAttribute iAttribId to sResult        
10429>>>>>        
10429>>>>>        Function_Return sResult
10430>>>>>    End_Function
10431>>>>>
10431>>>>> 
10431>>>>>   Function SQLGetStmtAttribute Integer iAttribId Returns String
10433>>>>>        Integer ihdbc
10433>>>>>        Integer ihstmt
10433>>>>>        String  sResult
10433>>>>>        String  sDrvrId
10433>>>>>        
10433>>>>>        // Initialize
10433>>>>>        Move "" to sResult
10434>>>>>        
10434>>>>>        // Get the cli handles
10434>>>>>        Get phCLIStatementHandle  to ihstmt
10435>>>>>        Get phCLIConnectionHandle to ihdbc
10436>>>>>        Get psDriverId            to sDrvrId
10437>>>>>        
10437>>>>>        // Get the attribute
10437>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") ;            Get SQLPrivateStmtAttribute iAttribId ihdbc sDrvrId ihstmt to sResult
10440>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetStmtAttribute"
10442>>>>>        
10442>>>>>        Function_Return sResult
10443>>>>>    End_Function
10444>>>>>
10444>>>>>    
10444>>>>>    Procedure SQLSetStmtAttribute Integer iAttribId String sAttribValue 
10446>>>>>
10446>>>>>        Integer ihdbc
10446>>>>>        Integer ihstmt
10446>>>>>        String  sDrvrId
10446>>>>>        
10446>>>>>        Integer iLen
10446>>>>>        Integer bLegalAttrib
10446>>>>>        Integer iVoid
10446>>>>>        Integer iAttribValue
10446>>>>>
10446>>>>>        Get phCLIStatementHandle  to ihstmt
10447>>>>>        Get phCLIConnectionHandle to ihdbc
10448>>>>>        Get psDriverId            to sDrvrId
10449>>>>>        
10449>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10451>>>>>            Case Begin
10451>>>>>                Case (iAttribId = SQLSTMTATTRIB_CURSOR_TYPE)
10453>>>>>                    Move DFTRUE to bLegalAttrib
10454>>>>>                    Break
10455>>>>>                    
10455>>>>>                Case Else
10455>>>>>                    Move DFFALSE to bLegalAttrib
10456>>>>>                    Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLSetStmtAttribute"
10457>>>>>            Case End
10457>>>>>
10457>>>>>            If (bLegalAttrib) Begin
10459>>>>>                If (iAttribId = SQLSTMTATTRIB_CURSOR_TYPE) Begin
10461>>>>>                    
10461>>>>>                    Move sAttribValue to iAttribValue // Check numeric?
10462>>>>>                    Case Begin
10462>>>>>                        Case (iAttribValue = SQL_CURSOR_FORWARD_ONLY)
10464>>>>>                        Case (iAttribValue = SQL_CURSOR_DYNAMIC)
10467>>>>>                        Case (iAttribValue = SQL_CURSOR_KEYSET_DRIVEN)
10470>>>>>                        Case (iAttribValue = SQL_CURSOR_STATIC)
10473>>>>>                            Break
10474>>>>>                            
10474>>>>>                        Case Else
10474>>>>>                            Move DFFALSE to bLegalAttrib
10475>>>>>                            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE (SFormat("Invalid value for SQLSTMTATTRIB_CURSOR_TYPE: %1", iAttribValue)) "SQLSetStmtAttribute"
10476>>>>>
10476>>>>>                    Case End
10476>>>>>                End
10476>>>>>>
10476>>>>>            End
10476>>>>>>
10476>>>>>
10476>>>>>            
10476>>>>>            If (bLegalAttrib) Begin
10478>>>>>                
10478>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                    Callback Self ;                    Passing ihdbc iVoid ihstmt ;                    Result iVoid
10483>>>>>                
10483>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLSETSTMTINTATTRIB ;                    Callback Self ;                    Passing iAttribId iAttribValue 0 ;                    Result iVoid
10488>>>>>            End
10488>>>>>>
10488>>>>>        End
10488>>>>>>
10488>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateStmtAttribute"
10490>>>>>        
10490>>>>>        
10490>>>>>        
10490>>>>>    End_Procedure
10491>>>>>    
10491>>>>>    
10491>>>>>    
10491>>>>>    Function SQLPrivateStmtAttribute Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
10493>>>>>        String  sResult
10493>>>>>        Integer iLen
10493>>>>>        Integer bLegalAttrib
10493>>>>>        
10493>>>>>        // Initialize
10493>>>>>        Move ""     to sResult
10494>>>>>        
10494>>>>>        // Get the attribute
10494>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10496>>>>>            Case Begin
10496>>>>>                Case (iAttribId = SQLSTMTATTRIB_COLUMNCOUNT)
10498>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT)
10501>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT_TYPE)
10504>>>>>                Case (iAttribId = SQLSTMTATTRIB_NUMMESSAGES)
10507>>>>>                Case (iAttribId = SQLSTMTATTRIB_CURSOR_TYPE)
10510>>>>>                    Move DFTRUE to bLegalAttrib
10511>>>>>                    Break
10512>>>>>                    
10512>>>>>                Case Else
10512>>>>>                    Move DFFALSE to bLegalAttrib
10513>>>>>                    Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateStmtAttribute"
10514>>>>>            Case End
10514>>>>>            
10514>>>>>            If (bLegalAttrib) Begin
10516>>>>>                // Setup function arguments
10516>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLSTMTINTATTRIB ;                    Callback Self ;                    Passing ihdbc iAttribId ihstmt ;                    Result sResult
10521>>>>>            End
10521>>>>>>
10521>>>>>        End
10521>>>>>>
10521>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateStmtAttribute"
10523>>>>>        
10523>>>>>        Function_Return sResult
10524>>>>>    End_Function
10525>>>>>    
10525>>>>>    
10525>>>>>    
10525>>>>>    // Get a column's attribute
10525>>>>>    Function SQLColAttribute Integer iCol Integer iAttribId Returns String
10527>>>>>        Integer ihdbc
10527>>>>>        Integer ihstmt
10527>>>>>        String  sResult
10527>>>>>        String  sDrvrId
10527>>>>>        
10527>>>>>        // Initialize
10527>>>>>        Move "" to sResult
10528>>>>>        
10528>>>>>        // Get the cli handles
10528>>>>>        Get phCLIStatementHandle  to ihstmt
10529>>>>>        Get phCLIConnectionHandle to ihdbc
10530>>>>>        Get psDriverId            to sDrvrId
10531>>>>>        
10531>>>>>        // Get the attribute
10531>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") ;            Get SQLPrivateColAttribute iCol iAttribId ihdbc sDrvrId ihstmt to sResult
10534>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLColAttribute"
10536>>>>>        
10536>>>>>        Function_Return sResult
10537>>>>>    End_Function
10538>>>>>    
10538>>>>>    Function SQLPrivateColAttribute Integer iCol Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
10540>>>>>        String  sResult
10540>>>>>        String  sEmpty
10540>>>>>        Integer bIsStringAttribute
10540>>>>>        Integer iLen
10540>>>>>        Integer iVoid
10540>>>>>        Integer bLegalAttrib
10540>>>>>        Integer bLegalColumn
10540>>>>>        
10540>>>>>        // Initialize
10540>>>>>        Move "" to sResult
10541>>>>>        Move "" to sEmpty
10542>>>>>        Move 0  to iLen
10543>>>>>        
10543>>>>>        // Get the attribute
10543>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10545>>>>>            Get SQLPrivateColumnIsLegal ihdbc sDrvrId ihstmt iCol to bLegalColumn
10546>>>>>            If (bLegalColumn) Begin
10548>>>>>                // Determine the atributes type
10548>>>>>                Case Begin
10548>>>>>                    Case (iAttribId = SQLCOLATTRIB_SIZE)
10550>>>>>                    Case (iAttribId = SQLCOLATTRIB_LENGTH)
10553>>>>>                    Case (iAttribId = SQLCOLATTRIB_PRECISION)
10556>>>>>                    Case (iAttribId = SQLCOLATTRIB_SQLTYPE)
10559>>>>>                    Case (iAttribId = SQLCOLATTRIB_NULLABLE)
10562>>>>>                    Case (iAttribId = SQLCOLATTRIB_DFTYPE)
10565>>>>>                        Move DFFALSE to bIsStringAttribute
10566>>>>>                        Move DFTRUE to bLegalAttrib
10567>>>>>                        Break
10568>>>>>                        
10568>>>>>                    Case (iAttribId = SQLCOLATTRIB_LABEL)
10571>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASECOLUMNNAME)
10574>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASETABLENAME)
10577>>>>>                        Move DFTRUE to bIsStringAttribute
10578>>>>>                        Move DFTRUE to bLegalAttrib
10579>>>>>                        Break
10580>>>>>                        
10580>>>>>                    Case Else
10580>>>>>                        Move DFFALSE to bLegalAttrib
10581>>>>>                        Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateColAttribute"
10582>>>>>                Case End
10582>>>>>                
10582>>>>>                If (bLegalAttrib) Begin
10584>>>>>                    // Setup function arguments
10584>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Self ;                        Passing ihdbc iCol ihstmt ;                        Result iVoid
10589>>>>>                    
10589>>>>>                    If (bIsStringAttribute) Begin
10591>>>>>                        // Call the driver function to get the data length
10591>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIBLEN ;                            Callback Self ;                            Passing sEmpty sEmpty iAttribId ;                            Result iLen
10596>>>>>                        
10596>>>>>                        If (iLen) Begin
10598>>>>>                            // Allocate
10598>>>>>                            Move (Repeat(' ', iLen)) to sResult
10599>>>>>                            
10599>>>>>                            // Call the driver function to get the name
10599>>>>>                            Call_Driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIB ;                                Callback Self ;                                Passing sResult sEmpty iAttribId ;                                Result iVoid
10604>>>>>                        End
10604>>>>>>
10604>>>>>                    End
10604>>>>>>
10604>>>>>                    Else Begin
10605>>>>>                        // get the attribute
10605>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLINTATTRIB ;                            Callback Self ;                            Passing sEmpty sEmpty iAttribId ;                            Result sResult
10610>>>>>                    End
10610>>>>>>
10610>>>>>                End
10610>>>>>>
10610>>>>>            End
10610>>>>>>
10610>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLPrivateColAttribute"
10612>>>>>        End
10612>>>>>>
10612>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateColAttribute"
10614>>>>>        
10614>>>>>        Function_Return sResult
10615>>>>>    End_Function
10616>>>>>    
10616>>>>>    
10616>>>>>    // Preapre for calling a stored procedure, pass the procedure name.
10616>>>>>    Procedure SQLSetProcedureName String sProcName String sSchemaArg
10618>>>>>        Integer ihdbc
10618>>>>>        Integer ihstmt
10618>>>>>        String  sDrvrId
10618>>>>>        Integer iVoid
10618>>>>>        String  sSchema
10618>>>>>        String  sEmpty
10618>>>>>        
10618>>>>>        // Initialize
10618>>>>>        Move "" to sEmpty
10619>>>>>        
10619>>>>>        // Get the cli handles
10619>>>>>        Get phCLIStatementHandle  to ihstmt
10620>>>>>        Get phCLIConnectionHandle to ihdbc
10621>>>>>        Get psDriverId            to sDrvrId
10622>>>>>        
10622>>>>>        // Call the procedure
10622>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10624>>>>>            If (Num_Arguments >= 2) ;                Move sSchemaArg to sSchema
10627>>>>>            Else ;                Move "" to sSchema
10629>>>>>            
10629>>>>>            If (sSchema <> "") Begin
10631>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCSCHEMA ;                    Callback Self ;                    Passing ihdbc sSchema ihstmt ;                    Result iVoid
10636>>>>>            End
10636>>>>>>
10636>>>>>            
10636>>>>>            // Call the procedure
10636>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCNAME ;                Callback Self ;                Passing ihdbc sProcName ihstmt ;                Result iVoid
10641>>>>>            
10641>>>>>            Set piLastArgument to 0
10642>>>>>        End
10642>>>>>>
10642>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetProcedurename"
10644>>>>>    End_Procedure
10645>>>>>    
10645>>>>>    // Pass the next argument
10645>>>>>    Procedure SQLSetNextArgument String sArgument
10647>>>>>        Integer iArgnum
10647>>>>>        
10647>>>>>        Get piLastArgument to iArgnum
10648>>>>>        Increment iArgnum
10649>>>>>        Send SQLSetArgument iArgnum sArgument
10650>>>>>        Set piLastArgument to iArgnum
10651>>>>>    End_Procedure
10652>>>>>    
10652>>>>>    
10652>>>>>    
10652>>>>>    // Set the next argument
10652>>>>>    Procedure SQLSetArgument Integer iArgnum String sArgument
10654>>>>>        Integer ihdbc
10654>>>>>        Integer ihstmt
10654>>>>>        String  sDrvrId
10654>>>>>        Integer iVoid
10654>>>>>        String  sEmpty
10654>>>>>        
10654>>>>>        // Initialize
10654>>>>>        Move "" to sEmpty
10655>>>>>        
10655>>>>>        // Get the cli handles
10655>>>>>        Get phCLIStatementHandle  to ihstmt
10656>>>>>        Get phCLIConnectionHandle to ihdbc
10657>>>>>        Get psDriverId            to sDrvrId
10658>>>>>        
10658>>>>>        // Call the procedure
10658>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10660>>>>>            // Pass the information
10660>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iArgnum ihstmt ;                Result iVoid
10665>>>>>            
10665>>>>>            // Pass the argument
10665>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCARG ;                Callback Self ;                Passing sArgument sEmpty 0 ;                Result iVoid
10670>>>>>        End
10670>>>>>>
10670>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetArgument"
10672>>>>>    End_Procedure
10673>>>>>    
10673>>>>>    Procedure SQLSetNextParameter String sParamValue Integer iParamType
10675>>>>>        Integer iParamNum 
10675>>>>>        Integer iType
10675>>>>>        
10675>>>>>        If (num_arguments < 2) Begin
10677>>>>>            Move typeString to iType
10678>>>>>        End
10678>>>>>>
10678>>>>>        Else Begin
10679>>>>>            Move iParamType to iType
10680>>>>>        End
10680>>>>>>
10680>>>>>        
10680>>>>>        Get piLastArgument to iParamNum
10681>>>>>        Increment iParamNum
10682>>>>>        Send SQLSetParameter iParamNum sParamValue iType
10683>>>>>        Set piLastArgument to iParamNum
10684>>>>>    End_Procedure
10685>>>>>
10685>>>>>    Procedure SQLSetParameter Integer iParamNum String sParamValue Integer iParamType
10687>>>>>        
10687>>>>>        Integer ihdbc
10687>>>>>        Integer ihstmt
10687>>>>>        String  sDrvrId
10687>>>>>        Integer iVoid
10687>>>>>        String  sEmpty
10687>>>>>        Integer iType
10687>>>>>        
10687>>>>>        If (num_arguments < 3) Begin
10689>>>>>            Move typeString to iType
10690>>>>>        End
10690>>>>>>
10690>>>>>        Else Begin
10691>>>>>            Move iParamType to iType
10692>>>>>        End
10692>>>>>>
10692>>>>>        
10692>>>>>        Case Begin
10692>>>>>            Case (iType = typeDate )    
10694>>>>>
10694>>>>>                If (sParamValue <> "") Begin
10696>>>>>                    ConvertToXml typeDate sParamValue to sParamValue
10697>>>>>                End
10697>>>>>>
10697>>>>>                
10697>>>>>                Break
10698>>>>>
10698>>>>>            Case (iType = typeDatetime )    
10701>>>>>
10701>>>>>                If (sParamValue <> "") Begin
10703>>>>>                    ConvertToXml esqlDatetime sParamValue to sParamValue
10704>>>>>                    Move (Replace('T',sParamValue,' ')) to sParamValue 
10705>>>>>                End
10705>>>>>>
10705>>>>>
10705>>>>>                Break
10706>>>>>
10706>>>>>            Case (iType = typeNumber )    
10709>>>>>
10709>>>>>                If (sParamValue <> "") Begin
10711>>>>>                    ConvertToXml typeNumber sParamValue to sParamValue
10712>>>>>                End
10712>>>>>>
10712>>>>>                
10712>>>>>                Break
10713>>>>>            
10713>>>>>            Case (iType = typeTime )    
10716>>>>>
10716>>>>>                If (sParamValue <> "") Begin
10718>>>>>                    ConvertToXml esqlTime sParamValue to sParamValue
10719>>>>>                End
10719>>>>>>
10719>>>>>                
10719>>>>>                Break
10720>>>>>                
10720>>>>>            Case Else
10720>>>>>                    // sParamValue is a string type or a type that must be passed as a string
10720>>>>>                    Break
10721>>>>>                
10721>>>>>        Case End
10721>>>>>        
10721>>>>>        
10721>>>>>        // Initialize
10721>>>>>        Move "" to sEmpty
10722>>>>>        
10722>>>>>        // Get the cli handles
10722>>>>>        Get phCLIStatementHandle  to ihstmt
10723>>>>>        Get phCLIConnectionHandle to ihdbc
10724>>>>>        Get psDriverId            to sDrvrId
10725>>>>>        
10725>>>>>        // Call the procedure
10725>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10727>>>>>            // Pass the information
10727>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iParamnum ihstmt ;                Result iVoid
10732>>>>>            
10732>>>>>            // Pass the argument
10732>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCARG ;                Callback Self ;                Passing sParamValue sEmpty 0 ;                Result iVoid
10737>>>>>        End
10737>>>>>>
10737>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetParameter"
10739>>>>>    End_Procedure
10740>>>>>    
10740>>>>>    
10740>>>>>    // Call a stored procedure
10740>>>>>    Procedure SQLCall
10742>>>>>        Integer ihdbc
10742>>>>>        Integer ihstmt
10742>>>>>        String  sDrvrId
10742>>>>>        Integer iVoid
10742>>>>>        String  sEmpty
10742>>>>>        
10742>>>>>        // Initialize
10742>>>>>        Move "" to sEmpty
10743>>>>>        
10743>>>>>        // Get the cli handles
10743>>>>>        Get phCLIStatementHandle  to ihstmt
10744>>>>>        Get phCLIConnectionHandle to ihdbc
10745>>>>>        Get psDriverId            to sDrvrId
10746>>>>>        
10746>>>>>        // Call the procedure
10746>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10748>>>>>            // Call the procedure
10748>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCALL ;                Callback Self ;                Passing ihdbc sEmpty ihstmt ;                Result iVoid
10753>>>>>            
10753>>>>>            Send SQLGetStatementAttributes
10754>>>>>            Set piLastArgument to 0
10755>>>>>        End
10755>>>>>>
10755>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLCall"
10757>>>>>    End_Procedure
10758>>>>>    
10758>>>>>    
10758>>>>>    // Get the next argument
10758>>>>>    Function SQLGetNextArgument Returns String
10760>>>>>        Integer iArgnum
10760>>>>>        String  sResult
10760>>>>>        
10760>>>>>        Get piLastArgument to iArgnum
10761>>>>>        Increment iArgnum
10762>>>>>        Get SQLGetArgument iArgnum to sResult
10763>>>>>        Set piLastArgument to iArgnum
10764>>>>>        
10764>>>>>        Function_Return sResult
10765>>>>>    End_Function
10766>>>>>    
10766>>>>>    
10766>>>>>    
10766>>>>>    // Get the specified argument from a procedure
10766>>>>>    Function SQLGetArgument Integer iArgnum Returns String
10768>>>>>        Integer ihdbc
10768>>>>>        Integer ihstmt
10768>>>>>        String  sDrvrId
10768>>>>>        Integer iVoid
10768>>>>>        String  sEmpty
10768>>>>>        String  sArgument
10768>>>>>        Integer iLen
10768>>>>>        
10768>>>>>        // Initialize
10768>>>>>        Move "" to sEmpty
10769>>>>>        Move "" to sArgument
10770>>>>>        
10770>>>>>        // Get the cli handles
10770>>>>>        Get phCLIStatementHandle  to ihstmt
10771>>>>>        Get phCLIConnectionHandle to ihdbc
10772>>>>>        Get psDriverId            to sDrvrId
10773>>>>>        
10773>>>>>        // Call the procedure
10773>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10775>>>>>            // Pass the information
10775>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iArgnum ihstmt ;                Result iVoid
10780>>>>>            
10780>>>>>            // Get the length
10780>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCARGLEN ;                Callback Self ;                Passing sEmpty sEmpty 0 ;                Result iLen
10785>>>>>            
10785>>>>>            If (iLen) Begin
10787>>>>>                // Allocate
10787>>>>>                Move (Repeat(' ', iLen)) to sArgument
10788>>>>>                
10788>>>>>                // Pass the argument
10788>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCARG ;                    Callback Self ;                    Passing sArgument sEmpty 0 ;                    Result iVoid
10793>>>>>            End
10793>>>>>>
10793>>>>>        End
10793>>>>>>
10793>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetArgument"
10795>>>>>        
10795>>>>>        Function_Return sArgument
10796>>>>>    End_Function
10797>>>>>    
10797>>>>>    
10797>>>>>    // Get the return value of a stored function
10797>>>>>    Function SQLReturnValue Returns String
10799>>>>>        Integer ihdbc
10799>>>>>        Integer ihstmt
10799>>>>>        String  sDrvrId
10799>>>>>        Integer iVoid
10799>>>>>        String  sEmpty
10799>>>>>        String  sRetval
10799>>>>>        Integer iLen
10799>>>>>        
10799>>>>>        // Initialize
10799>>>>>        Move "" to sEmpty
10800>>>>>        Move "" to sRetval
10801>>>>>        
10801>>>>>        // Get the cli handles
10801>>>>>        Get phCLIStatementHandle  to ihstmt
10802>>>>>        Get phCLIConnectionHandle to ihdbc
10803>>>>>        Get psDriverId            to sDrvrId
10804>>>>>        
10804>>>>>        // Call the procedure
10804>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10806>>>>>            // Get the length
10806>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCRETVALLEN ;                Callback Self ;                Passing ihdbc sEmpty ihstmt  ;                Result iLen
10811>>>>>            
10811>>>>>            If (iLen) Begin
10813>>>>>                // Allocate
10813>>>>>                Move (Repeat(' ', iLen)) to sRetval
10814>>>>>                
10814>>>>>                // Pass the argument
10814>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCRETVAL ;                    Callback Self ;                    Passing ihdbc sRetval ihstmt ;                    Result iVoid
10819>>>>>            End
10819>>>>>>
10819>>>>>        End
10819>>>>>>
10819>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLReturnValue"
10821>>>>>        
10821>>>>>        Function_Return sRetval
10822>>>>>    End_Function
10823>>>>>    
10823>>>>>    
10823>>>>>    // Switch to the next set
10823>>>>>    // Returns : 0   = No more result sets
10823>>>>>    //     <>0 = Switched to next set
10823>>>>>    Function SQLNextResultSet Returns Integer
10825>>>>>        Integer ihdbc
10825>>>>>        Integer ihstmt
10825>>>>>        String  sDrvrId
10825>>>>>        Integer iResult
10825>>>>>        String  sEmpty
10825>>>>>        
10825>>>>>        // Initialize
10825>>>>>        Move "" to sEmpty
10826>>>>>        Move 0  to iResult
10827>>>>>        
10827>>>>>        // Get the cli handles
10827>>>>>        Get phCLIStatementHandle  to ihstmt
10828>>>>>        Get phCLIConnectionHandle to ihdbc
10829>>>>>        Get psDriverId            to sDrvrId
10830>>>>>        
10830>>>>>        // Call the procedure
10830>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10832>>>>>            // Get the length
10832>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLNEXTRESULTSET ;                Callback Self ;                Passing ihdbc sEmpty ihstmt  ;                Result iResult
10837>>>>>            
10837>>>>>            Send SQLGetStatementAttributes
10838>>>>>            Set piLastArgument to 0
10839>>>>>        End
10839>>>>>>
10839>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLNextResultSet"
10841>>>>>        
10841>>>>>        Function_Return iResult
10842>>>>>    End_Function
10843>>>>>    
10843>>>>>    
10843>>>>>    // Setup a file that will be acivated after a succesfull
10843>>>>>    //fetch on the statement
10843>>>>>    Procedure SQLFetchActivatesBuffer Integer iFileNum Integer bState
10845>>>>>        Integer ihdbc
10845>>>>>        Integer ihstmt
10845>>>>>        String  sDrvrId
10845>>>>>        Integer iResult
10845>>>>>        Integer bIsOpen
10845>>>>>        Integer iVoid
10845>>>>>        String  sFileType
10845>>>>>        
10845>>>>>        // Check if file is open
10845>>>>>        Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
10848>>>>>        If (bIsOpen) Begin
10850>>>>>            // Get the cli handles
10850>>>>>            Get phCLIStatementHandle  to ihstmt
10851>>>>>            Get phCLIConnectionHandle to ihdbc
10852>>>>>            Get psDriverId            to sDrvrId
10853>>>>>            
10853>>>>>            // Call the procedure
10853>>>>>            If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10855>>>>>                // Check if the file has the correct type
10855>>>>>                Get_Attribute DF_FILE_DRIVER of iFileNum to sFileType
10858>>>>>                If (sFileType = sDrvrId) Begin
10860>>>>>                    // Setup the buffer
10860>>>>>                    Call_Driver iFileNum sDrvrId Function FUNC_SQLBUFFERSTATUS ;                        Callback Self ;                        Passing ihdbc bState ihstmt  ;                        Result iVoid
10865>>>>>                End
10865>>>>>>
10865>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
10867>>>>>            End
10867>>>>>>
10867>>>>>            Else ;                Send HandleError ihstmt ihdbc sDrvrId "SQLFetchActivatesBuffer"
10869>>>>>        End
10869>>>>>>
10869>>>>>        Else ;            Send StmtError CLIERR_SQLINVALID_BUFFER ("File not open (number =" * String(iFileNum) + ")") "SQLFetchActivatesBuffer"
10871>>>>>    End_Procedure
10872>>>>>    
10872>>>>>    
10872>>>>>    
10872>>>>>    Function SQLGetMessage Integer iMessageNum Returns String
10874>>>>>        Integer ihdbc
10874>>>>>        Integer ihstmt
10874>>>>>        String  sDrvrId
10874>>>>>        String  sMessage
10874>>>>>        Integer iVoid
10874>>>>>        
10874>>>>>        // Initialize
10874>>>>>        Move "" to sMessage
10875>>>>>        
10875>>>>>        // Get the cli handles
10875>>>>>        Get phCLIStatementHandle  to ihstmt
10876>>>>>        Get phCLIConnectionHandle to ihdbc
10877>>>>>        Get psDriverId            to sDrvrId
10878>>>>>        
10878>>>>>        // Call the procedure
10878>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
10880>>>>>            // Setup function arguments
10880>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iMessageNum ihstmt ;                Result iVoid
10885>>>>>            
10885>>>>>            Move (Repeat(' ', 1024)) to sMessage
10886>>>>>            // Get the length
10886>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLGETMESSAGE ;                Callback Self ;                Passing iVoid sMessage iVoid ;                Result iVoid
10891>>>>>        End
10891>>>>>>
10891>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetDiagRec"
10893>>>>>        
10893>>>>>        Function_Return sMessage
10894>>>>>    End_Function
10895>>>>>    
10895>>>>>    
10895>>>>>    
10895>>>>>    // Remove the component identifier from a diagnostic message
10895>>>>>    Function RemoveComponentIdentifier String sDiagMessage Returns String
10897>>>>>        While (Left(sDiagMessage, 1) = "[")
10901>>>>>            Move (Right(sDiagMessage, Length(sDiagMessage) - Pos("]", sDiagMessage))) to sDiagMessage
10902>>>>>        Loop
10903>>>>>>
10903>>>>>        
10903>>>>>        Function_Return sDiagMessage
10904>>>>>    End_Function
10905>>>>>    
10905>>>>>    
10905>>>>>    
10905>>>>>    // Convert a DataFlex date to a SQL Date. Use dummy zero dates.
10905>>>>>    Function DFDateToSQLDate Date dDFDate Integer iSQLType Returns String
10907>>>>>        
10907>>>>>        Integer iType
10907>>>>>        String  sSQLDate
10907>>>>>        Integer iOrgDateFmt
10907>>>>>        Integer iOrgDateSep
10907>>>>>        
10907>>>>>        String sDriverId
10907>>>>>        String sDummyZeroDate
10907>>>>>        String sDummyZeroDateMssqlDatetime
10907>>>>>        
10907>>>>>        // Change date format to military, SQL dates are military dates
10907>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
10910>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
10913>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
10916>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
10919>>>>>        
10919>>>>>        // We only need to convert if the date is 0
10919>>>>>        If (Integer(dDFDate = 0)) Begin
10921>>>>>            
10921>>>>>            If (num_arguments < 2) Begin
10923>>>>>                Move SQL_TYPE_TIMESTAMP to iType
10924>>>>>            End
10924>>>>>>
10924>>>>>            Else Begin
10925>>>>>                Move iSQLType to iType
10926>>>>>            End
10926>>>>>>
10926>>>>>            
10926>>>>>            
10926>>>>>            Get psDriverID to sDriverId
10927>>>>>            Get psDummyZeroDate to sDummyZeroDate
10928>>>>>            
10928>>>>>            If ( (iType = SQL_TYPE_TIMESTAMP) and (sDriverID = 'MSSQLDRV') ) Begin
10930>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
10931>>>>>                Move sDummyZeroDateMssqlDatetime to sSQLDate
10932>>>>>            End
10932>>>>>>
10932>>>>>            Else Begin
10933>>>>>                Move sDummyZeroDate to sSQLDate
10934>>>>>            End
10934>>>>>>
10934>>>>>            
10934>>>>>        End
10934>>>>>>
10934>>>>>        Else Begin
10935>>>>>            Move dDFDate to sSQLDate
10936>>>>>        End
10936>>>>>>
10936>>>>>        
10936>>>>>        // Change date format back to original
10936>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
10939>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
10942>>>>>        
10942>>>>>        Function_Return sSQLDate
10943>>>>>    End_Function
10944>>>>>    
10944>>>>>    
10944>>>>>    // Convert a SQL date to a DataFlex Date. Use dummy zero dates.
10944>>>>>    Function SQLDateToDFDate String sSQLDate Returns Date
10946>>>>>        
10946>>>>>        Integer iType
10946>>>>>        Date    dDFDate
10946>>>>>        Integer iOrgDateFmt
10946>>>>>        Integer iOrgDateSep
10946>>>>>        
10946>>>>>        String  sDriverId
10946>>>>>        String  sDummyZeroDate
10946>>>>>        String  sDummyZeroDateMssqlDatetime
10946>>>>>        
10946>>>>>        Get psDriverID to sDriverId
10947>>>>>        
10947>>>>>        Get psDummyZeroDate to sDummyZeroDate
10948>>>>>        Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
10949>>>>>        
10949>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
10952>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
10955>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
10958>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
10961>>>>>        
10961>>>>>        Move (Left(sSQLDate,10)) to sSQLDate
10962>>>>>        
10962>>>>>        If ( (sSQLDate = sDummyZeroDate) or ;            ( (sDriverId = 'MSSQLDRV') and (sSQLDate = sDummyZeroDateMssqlDatetime) ) )  Begin
10964>>>>>            Move 0 to dDFDate
10965>>>>>        End
10965>>>>>>
10965>>>>>        Else Begin
10966>>>>>            Move sSQLDate to dDFDate
10967>>>>>        End
10967>>>>>>
10967>>>>>        
10967>>>>>        // Change date format back to original
10967>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
10970>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
10973>>>>>        
10973>>>>>        Function_Return dDFDate
10974>>>>>    End_Function
10975>>>>>    
10975>>>>>End_Class
10976>>>>>
10976>>>>>
10976>>>>>// Connection object for embedded SQL                          
10976>>>>>// This provides the ability to create a connection for a driver.     
10976>>>>>// It will contain child statement objects                            
10976>>>>>
10976>>>>>Class cSQLConnection is a cObject
10977>>>>>    
10977>>>>>    Procedure Construct_object
10979>>>>>        Forward Send Construct_object
10981>>>>>        
10981>>>>>        Property Integer phCLIConnectionHandle       0
10982>>>>>        
10982>>>>>        Property String  psDriverID        ""
10983>>>>>        Property Integer piBindFile        0
10984>>>>>        
10984>>>>>        Property String psDummyZeroDate              '0001-01-01'
10985>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'
10986>>>>>        
10986>>>>>    End_Procedure
10987>>>>>    
10987>>>>>    
10987>>>>>    
10987>>>>>    // Store basic information about the connection
10987>>>>>    Procedure StoreConnectionInfo Handle hCLIConnectionHandle String sDrvrId
10989>>>>>        
10989>>>>>        String sDummyZeroDate
10989>>>>>        Integer iDriverIndex
10989>>>>>        
10989>>>>>        Set phCLIConnectionHandle to hCLIConnectionHandle
10990>>>>>        Set psDriverID            to sDrvrId
10991>>>>>        
10991>>>>>        Case Begin
10991>>>>>            Case (sDrvrId = "MSSQLDRV")
10993>>>>>                Set psDummyZeroDate to '0001-01-01'
10994>>>>>                Set psDummyZeroDateMssqlDatetime to '1753-01-01'
10995>>>>>                Break
10996>>>>>            Case (sDrvrId = "DB2_DRV")
10999>>>>>                Set psDummyZeroDate to '0001-01-01'
11000>>>>>                Break
11001>>>>>            Case (sDrvrId = "ODBC_DRV")
11004>>>>>                Get DriverIndex "ODBC_DRV" to iDriverIndex
11005>>>>>                If (iDriverIndex <> 0) Begin
11007>>>>>                    Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDummyZeroDate
11010>>>>>                End
11010>>>>>>
11010>>>>>                Else Begin
11011>>>>>                    Move '0001-01-01' to sDummyZeroDate
11012>>>>>                End
11012>>>>>>
11012>>>>>
11012>>>>>                Set psDummyZeroDate to sDummyZeroDate
11013>>>>>                Break
11014>>>>>                
11014>>>>>        Case End
11014>>>>>        
11014>>>>>    End_Procedure
11015>>>>>    
11015>>>>>    Function DriverIndex String sDriver Returns Integer
11017>>>>>        
11017>>>>>        String  sCurrentDriver
11017>>>>>        Integer iNumberOfDrivers iDriver iCount
11017>>>>>        
11017>>>>>        Move 0 to iDriver
11018>>>>>        
11018>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
11021>>>>>        For iCount from 1 to iNumberOfDrivers
11027>>>>>>
11027>>>>>            
11027>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
11030>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
11032>>>>>                Move iCount to iDriver
11033>>>>>            End
11033>>>>>>
11033>>>>>        Loop
11034>>>>>>
11034>>>>>        
11034>>>>>        Function_Return iDriver
11035>>>>>        
11035>>>>>    End_Function
11036>>>>>
11036>>>>>    
11036>>>>>    // Destroy the SQLConnection object
11036>>>>>    Procedure DestroySQLConnection
11038>>>>>        Send Destroy
11039>>>>>    End_Procedure
11040>>>>>    
11040>>>>>    
11040>>>>>    // Connect to a database server
11040>>>>>    // Returns : 1 Succesfully connected
11040>>>>>    //           0 Not connected
11040>>>>>    Function SQLConnect String sDrvrID String sConnect Returns Integer
11042>>>>>        Integer ihdbc
11042>>>>>        String  sEmpty
11042>>>>>        
11042>>>>>        // Initialize
11042>>>>>        Move "" to sEmpty
11043>>>>>        Move 0  to ihdbc
11044>>>>>        
11044>>>>>        Move False to Err
11045>>>>>        
11045>>>>>        // Call the driver function to connect
11045>>>>>        Call_Driver 0 sDrvrId Function FUNC_SQLCONNECT ;            Callback Self ;            Passing sConnect sEmpty Self ;            Result ihdbc
11050>>>>>        
11050>>>>>        // If there was an error, make result invalid
11050>>>>>        If (Err) ;            Move 0 to ihdbc
11053>>>>>        
11053>>>>>        // Check result and store it
11053>>>>>        If (ihdbc <> 0) ;            Send StoreConnectionInfo ihdbc sDrvrId
11056>>>>>        
11056>>>>>        // Return success status
11056>>>>>        Function_Return (ihdbc <> 0)
11057>>>>>    End_Function
11058>>>>>    
11058>>>>>    
11058>>>>>    // Use a connection of an already open file
11058>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
11060>>>>>        Integer ihdbc
11060>>>>>        Integer bIsOpen
11060>>>>>        String  sDrvrId
11060>>>>>        String  sEmpty
11060>>>>>        
11060>>>>>        // Initialize
11060>>>>>        Move "" to sEmpty
11061>>>>>        Move 0  to ihdbc
11062>>>>>        
11062>>>>>        // Check if file is open
11062>>>>>        Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
11065>>>>>        If (bIsOpen) Begin
11067>>>>>            // Fill the driver id, assume longest is 255 characters
11067>>>>>            Move (Repeat(' ', 255)) to sDrvrId
11068>>>>>            Get_Attribute DF_FILE_DRIVER of iFileNum to sDrvrId
11071>>>>>            
11071>>>>>            Move False to Err
11072>>>>>            
11072>>>>>            // Call the driver function to connect
11072>>>>>            Call_Driver iFileNum sDrvrId Function FUNC_SQLFILECONNECT ;                Callback Self ;                Passing sEmpty sEmpty 0 ;                Result ihdbc
11077>>>>>            
11077>>>>>            // If there was an error, make result invalid
11077>>>>>            If (Err) ;                Move 0 to ihdbc
11080>>>>>            
11080>>>>>            // Check result and store it
11080>>>>>            If (ihdbc <> 0) Begin
11082>>>>>                // Somehow Call_driver overwrites the sDrvrId variable, restore it here
11082>>>>>                Get_Attribute DF_FILE_DRIVER of iFileNum to sDrvrId
11085>>>>>                Send StoreConnectionInfo ihdbc sDrvrId
11086>>>>>                
11086>>>>>                // Set filenum so it can be used for fetching
11086>>>>>                Set piBindFile to iFileNum
11087>>>>>            End
11087>>>>>>
11087>>>>>        End
11087>>>>>>
11087>>>>>        
11087>>>>>        // Return success status
11087>>>>>        Function_Return (ihdbc <> 0)
11088>>>>>    End_Function
11089>>>>>    
11089>>>>>    
11089>>>>>    // Establish an embedded SQL connection that uses an existing connection from an earlier login or open.
11089>>>>>    // Existing connections are identified by there connectstring. (can be obtained with DF_DRIVER_SERVER_NAME attribute)
11089>>>>>    // If sConnectString exist in the list of existing connections, that connection will be used for embedded SQL.
11089>>>>>    // The connectstring must be an exact match, but can be case insensitive
11089>>>>>    // The connectstring can contain a connection id. For example: "DFCONNID=MyConnectionID"
11089>>>>>    // If no matching connectstring is found, this function will return 0
11089>>>>>    // This function will only work with CLI connectivity kits 6.2 or later
11089>>>>>    Function SQLConnectionConnect String sDrvrID String sConnectString Returns Integer
11091>>>>>        Integer ihdbc
11091>>>>>        String  sEmpty
11091>>>>>        Integer iFileNum
11091>>>>>        
11091>>>>>        // Initialize
11091>>>>>        Move "" to sEmpty
11092>>>>>        Move 0  to ihdbc
11093>>>>>        
11093>>>>>        Move False to Err
11094>>>>>        
11094>>>>>        // Call the driver function
11094>>>>>        //   Note we call FUNC_SQLFILECONNECT with iFileNum = 0.
11094>>>>>        //   This will perform SQLConnectionConnect instead of SQLFileConnect
11094>>>>>        Move 0 to iFileNum
11095>>>>>        Call_Driver iFileNum sDrvrId Function FUNC_SQLFILECONNECT ;            Callback Self ;            Passing sConnectString sEmpty Self ;            Result ihdbc
11100>>>>>        
11100>>>>>        // If there was an error, make result invalid
11100>>>>>        If (Err) ;            Move 0 to ihdbc
11103>>>>>        
11103>>>>>        // Check result and store it
11103>>>>>        If (ihdbc <> 0) ;            Send StoreConnectionInfo ihdbc sDrvrId
11106>>>>>        
11106>>>>>        // Return success status
11106>>>>>        Function_Return (ihdbc <> 0)
11107>>>>>    End_Function
11108>>>>>    
11108>>>>>    
11108>>>>>    // Disconnect from an embedded SQL server and free allocated
11108>>>>>    // resources
11108>>>>>    Procedure SQLDisconnect
11110>>>>>        Integer ihdbc
11110>>>>>        Integer iVoid
11110>>>>>        String  sDrvrId
11110>>>>>        String  sEmpty
11110>>>>>        
11110>>>>>        // Initialize
11110>>>>>        Move "" to sEmpty
11111>>>>>        
11111>>>>>        // Get the cli handle
11111>>>>>        Get phCLIConnectionHandle to ihdbc
11112>>>>>        Get psDriverId to sDrvrId
11113>>>>>        
11113>>>>>        // Free the CLI handle
11113>>>>>        If (ihdbc <> 0) Begin
11115>>>>>            // Call the driver function to disconnect
11115>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLDISCONNECT ;                Callback Self ;                Passing sEmpty sEmpty ihdbc ;                Result iVoid
11120>>>>>            
11120>>>>>            Move -1 to giLastSQLhdbc
11121>>>>>            
11121>>>>>            // Free the DataFlex handle
11121>>>>>            Send DestroySQLConnection
11122>>>>>        End
11122>>>>>>
11122>>>>>    End_Procedure
11123>>>>>    
11123>>>>>    // Create a cSQLStatement object
11123>>>>>    Function CreateSQLStatement Returns Handle
11125>>>>>        
11125>>>>>        Handle hoSQLStatement
11125>>>>>        Get Create (RefClass(cSQLStatement)) to hoSQLStatement
11126>>>>>        
11126>>>>>        // If the connection has a default Bind File, assign it to the
11126>>>>>        // statement object. The default is set when you open a file with a
11126>>>>>        // SetFileConnection command.
11126>>>>>        Set piBindFile of hoSQLStatement to (piBindFile(Self))
11127>>>>>        
11127>>>>>        Function_Return hoSQLStatement
11128>>>>>    End_Function
11129>>>>>    
11129>>>>>    
11129>>>>>    // Open a statement for use
11129>>>>>    Function SQLOpen Returns Handle
11131>>>>>        Handle  hoSQLStatement
11131>>>>>        Integer ihdbc
11131>>>>>        Integer ihstmt
11131>>>>>        Integer iVoid
11131>>>>>        String  sDrvrId
11131>>>>>        String  sEmpty
11131>>>>>        String  sDummyZeroDate
11131>>>>>        String  sDummyZeroDateMssqlDatetime
11131>>>>>        
11131>>>>>        // Initialize
11131>>>>>        Move "" to sEmpty
11132>>>>>        
11132>>>>>        // Get the cli handle to the connection
11132>>>>>        Get phCLIConnectionHandle to ihdbc
11133>>>>>        Get psDriverId  to sDrvrId
11134>>>>>        
11134>>>>>        // Allocate a new handle and populate it
11134>>>>>        If (ihdbc <> 0) Begin
11136>>>>>            // Create a new cSQLStatement object
11136>>>>>            Get CreateSQLStatement to hoSQLStatement
11137>>>>>            
11137>>>>>            // Call the driver function to allocate a cli statement handle
11137>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLOPEN ;                Callback Self ;                Passing hoSQLStatement sEmpty ihdbc ;                Result ihstmt
11142>>>>>            
11142>>>>>            // If unsuccessful destroy hoSQLStatement
11142>>>>>            If (ihstmt = 0) Begin
11144>>>>>                Send DestroySQLStatement of hoSQLStatement
11145>>>>>                Move 0 to hoSQLStatement
11146>>>>>            End
11146>>>>>>
11146>>>>>            Else Begin
11147>>>>>                Send StoreStatementInfo of hoSQLStatement ihstmt sDrvrId ihdbc
11148>>>>>                
11148>>>>>                // Store DummyZeroDate of hoSQLConnection in hoSQLStatement
11148>>>>>                Get psDummyZeroDate              to sDummyZeroDate
11149>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
11150>>>>>                
11150>>>>>                Set psDummyZeroDate              of hoSQLStatement to sDummyZeroDate
11151>>>>>                Set psDummyZeroDateMssqlDatetime of hoSQLStatement to sDummyZeroDateMssqlDatetime
11152>>>>>                
11152>>>>>            End
11152>>>>>>
11152>>>>>        End
11152>>>>>>
11152>>>>>        
11152>>>>>        Function_Return hoSQLStatement
11153>>>>>    End_Function
11154>>>>>    
11154>>>>>End_Class
11155>>>>>
11155>>>>>// Manager for embedded SQL handles.                           
11155>>>>>// We want to be able to use multiple drivers and multiple            
11155>>>>>// connections within a driver and multiple statements within a       
11155>>>>>// connection. To allow this we have placed our own handle logic on   
11155>>>>>// top of the driver handle logic. This way we can handle the         
11155>>>>>// situation where two driver handles may be equal.                   
11155>>>>>
11155>>>>>Class cSQLHandleManager is a cObject
11156>>>>>    
11156>>>>>    Procedure Construct_object
11158>>>>>        Forward Send Construct_object
11160>>>>>        
11160>>>>>        Property String  psDefaultDriver      ""
11161>>>>>        Property String  psDefaultConnection  ""
11162>>>>>        
11162>>>>>    End_Procedure
11163>>>>>    
11163>>>>>    // Create a cSQLConnection object
11163>>>>>    Function CreateSQLConnection Returns Handle
11165>>>>>        Handle hoSQLConnection
11165>>>>>        Get Create (RefClass(cSQLConnection)) to hoSQLConnection
11166>>>>>        Function_Return hoSQLConnection
11167>>>>>    End_Function
11168>>>>>    
11168>>>>>    
11168>>>>>    // Store default connection information
11168>>>>>    Procedure SQLSetConnect String sDriver String sConnect
11170>>>>>        Set psDefaultDriver      to sDriver
11171>>>>>        Set psDefaultConnection  to sConnect
11172>>>>>    End_Procedure
11173>>>>>    
11173>>>>>    
11173>>>>>    // Make a connection to an embedded SQL server
11173>>>>>    // Returns : The DataFlex handle to the connection
11173>>>>>    Function SQLConnect String sDrvrID String sConnect Returns Integer
11175>>>>>        Handle hoSQLConnection
11175>>>>>        Integer bOK
11175>>>>>        
11175>>>>>        // Check arguments
11175>>>>>        If (sDrvrID = "" and sConnect = "") Begin
11177>>>>>            Get psDefaultDriver      to sDrvrId
11178>>>>>            Get psDefaultConnection  to sConnect
11179>>>>>        End
11179>>>>>>
11179>>>>>        
11179>>>>>        // Create a cSQLConnection object
11179>>>>>        Get CreateSQLConnection to hoSQLConnection
11180>>>>>        // Connect to the database
11180>>>>>        Get SQLConnect of hoSQLConnection sDrvrID sConnect to bOK
11181>>>>>        
11181>>>>>        // If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
11181>>>>>        If (not(bOK)) Begin
11183>>>>>            Send DestroySQLConnection of hoSQLConnection
11184>>>>>            Move 0 to hoSQLConnection
11185>>>>>        End
11185>>>>>>
11185>>>>>        
11185>>>>>        Function_Return hoSQLConnection
11186>>>>>    End_Function
11187>>>>>    
11187>>>>>    
11187>>>>>    
11187>>>>>    // Make an existing connection available for use with Embedded SQL.
11187>>>>>    // The connection is identified by the number of a file
11187>>>>>    // that is open for that connection.
11187>>>>>    Function SQLFileConnect Integer iFileNum Returns Handle
11189>>>>>        Handle hoSQLConnection
11189>>>>>        Integer bOK
11189>>>>>        
11189>>>>>        // Create a cSQLConnection object
11189>>>>>        Get CreateSQLConnection to hoSQLConnection
11190>>>>>        Get SQLFileConnect of hoSQLConnection iFileNum to bOK
11191>>>>>        
11191>>>>>        // If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
11191>>>>>        If (not(bOK)) Begin
11193>>>>>            Send DestroySQLConnection of hoSQLConnection
11194>>>>>            Move 0 to hoSQLConnection
11195>>>>>        End
11195>>>>>>
11195>>>>>        
11195>>>>>        Function_Return hoSQLConnection
11196>>>>>    End_Function
11197>>>>>    
11197>>>>>    // Establish an embedded SQL connection that uses an existing connection from an earlier login or open.
11197>>>>>    // Existing connections are identified by there connectstring. (can be obtained with DF_DRIVER_SERVER_NAME attribute)
11197>>>>>    // If sConnectString exist in the list of existing connections, that connection will be used for embedded SQL.
11197>>>>>    // The connectstrings must be an exact match, but can be case insensitive
11197>>>>>    // If no matching connectstring is found, this function will return 0
11197>>>>>    // This function will only work with CLI connectivity kits 6.2 or later
11197>>>>>    Function SQLConnectionConnect String sDrvrID String sConnectString Returns Integer
11199>>>>>        Handle hoSQLConnection
11199>>>>>        Integer bOK
11199>>>>>        
11199>>>>>        // Check arguments
11199>>>>>        If (sDrvrID = "" and sConnectString = "") Begin
11201>>>>>            Get psDefaultDriver      to sDrvrId
11202>>>>>            Get psDefaultConnection  to sConnectString
11203>>>>>        End
11203>>>>>>
11203>>>>>        
11203>>>>>        // Create a cSQLConnection object
11203>>>>>        Get CreateSQLConnection to hoSQLConnection
11204>>>>>        // Connect to the database
11204>>>>>        Get SQLConnectionConnect of hoSQLConnection sDrvrID sConnectString to bOK
11205>>>>>        
11205>>>>>        // If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
11205>>>>>        If (not(bOK)) Begin
11207>>>>>            Send DestroySQLConnection of hoSQLConnection
11208>>>>>            Move 0 to hoSQLConnection
11209>>>>>        End
11209>>>>>>
11209>>>>>        
11209>>>>>        Function_Return hoSQLConnection
11210>>>>>    End_Function
11211>>>>>    
11211>>>>>    
11211>>>>>End_Class
11212>>>Use cApplication.pkg
11212>>>
11212>>>// constants
11212>>>Define C_ConnectionId for "DFCONNID=" // symbol used in INT/SERVER for connection Id
11212>>>Define C_ConnectionIdCmdLineName for "dfconnid=" // left side of name used in command line argument for dfconnid.ini file
11212>>>Define C_ConnectionIniFileName for "DFConnId.ini" // default name of connections INI file.
11212>>>Define C_ConnectionIniSectionBaseName for "connection" // normally assumes a suffix like connection1, conneciton 2, etc.
11212>>>Define C_ConnectionIniSectionId for "id" // Name of connection id
11212>>>Define C_ConnectionIniSectionDriver for "driver" // left side of [id] section for driver
11212>>>Define C_ConnectionIniSectionConnection for "connection" // left side of [id] section for connection
11212>>>Define C_ConnectionIniSectionUID for "UID"
11212>>>Define C_ConnectionIniSectionPWD for "PWD"
11212>>>Define C_ConnectionIniSectionTrusted for "trusted_connection"
11212>>>Define C_ConnectionIniSectionDisabled for "disabled"
11212>>>
11212>>>// connection ID information
11212>>>Struct tConnection
11212>>>    String sId                // connection id
11212>>>    String sString            // server-string as added via the ini file
11212>>>    String sUID               // User Id
11212>>>    String sPWD               // non-encrypted password
11212>>>    Boolean bTrustedConnection // Trusted connection
11212>>>    Integer iOptions          // connection ID options (don't use)
11212>>>    String sDriver            // name of driver
11212>>>    Integer iDriverIndex      // loaded driver index (is 1 based, 0 if none)
11212>>>    String sConnectionString  // Full connection string assembled from various strings
11212>>>    String sSection           // this is usually the section name as it appears
11212>>>    // in the connections ini file (e.g., [Connection1])
11212>>>    Boolean bDisabled         // if set, this is not an active Id
11212>>>End_Struct
11212>>>
11212>>>// used to search loaded (registered) drivers to find CLI connection handle
11212>>>Struct tDriverCLIDictionary
11212>>>    String sDriver // registered driver name
11212>>>    Handle hoCLI   // CLI handle of object created when driver was loaded
11212>>>End_Struct
11212>>>
11212>>>// privately used to write INI sections
11212>>>Struct tConnectionIniSection
11212>>>    String sSection // section INI name. Should be unique
11212>>>    String[] Keys
11212>>>    String[] Values
11212>>>End_Struct
11212>>>
11212>>>// search tConnection by case insensitive ID
11212>>>Function ComparetConnectionById Desktop tConnection C1 tConnection C2 Returns Integer
11214>>>    String sId1 sId2
11214>>>    Move (Uppercase(C1.sId)) to sId1
11215>>>    Move (Uppercase(C2.sId)) to sId2
11216>>>    If (sId1>sId2) Begin
11218>>>        Function_Return (GT)
11219>>>    End
11219>>>>
11219>>>    Else If (sId1<sId2) Begin
11222>>>        Function_Return (LT)
11223>>>    End
11223>>>>
11223>>>    Function_Return (EQ)
11224>>>End_Function
11225>>>
11225>>>Class cConnection is a cObject
11226>>>    
11226>>>    Procedure Construct_Object
11228>>>        Forward Send Construct_Object
11230>>>        
11230>>>        // If you want to do this all manually set this False
11230>>>        Property Boolean pbUseConnectionIni True
11231>>>        
11231>>>        // When using managed logins, login again if already logged in?
11231>>>        Property Boolean pbSkipDuplicateLogin True
11232>>>        
11232>>>        // can be set to false, to require a login before an open. This gets
11232>>>        // set when the driver is registered.
11232>>>        Property Boolean private_pbLoginOnOpen True
11233>>>        
11233>>>        // name of connections ini file. Only set this if you want to override
11233>>>        // the normal mechanism of getting a name.
11233>>>        Property String psConnectionIni ""
11234>>>        
11234>>>        // as a scurity precaution this can be disabled so someone cannot run a
11234>>>        // cmdline option that redirects to a different database
11234>>>        Property Boolean pbCmdLineIniAllowed True
11235>>>        
11235>>>        // normally this is dfconnid="name" but it can be customized in the case where
11235>>>        // an application would have a conflict with this.
11235>>>        Property String psConnectionIdCmdLine C_ConnectionIdCmdLineName
11236>>>        
11236>>>        // Determines AutoConnect behavior (usually sent by cApplication after workspace
11236>>>        // is opened. Default is to RegisterAll and LoginAll and abort if error). If set
11236>>>        // false, nothing happens.
11236>>>        Property Boolean pbAutoConnect True
11237>>>        
11237>>>        // is a login dialog used? If so, it must be created and registered in ghoLoginConnectDialog
11237>>>        Property Boolean pbLoginDialogRequired True
11238>>>        
11238>>>        // is encryption used? If so, it must be created and registered in ghoLoginEncryption
11238>>>        Property Boolean pbEncryptPassword True
11239>>>        
11239>>>        // class to use for driver connection objects. Advanced use for sub-classing
11239>>>        Property Handle phcDriverConnection (RefClass(cCLIHandler))
11240>>>        
11240>>>        // can be used by error trapping / handling
11240>>>        Property Integer piErrorNumber
11241>>>        Property Integer piErrorLine
11242>>>        Property String psErrorText
11243>>>        Property Handle phoOldError
11244>>>        
11244>>>        Property tDriverCLIDictionary[] pRegisteredDriversDict
11245>>>        
11245>>>        Property tConnection[] pConnections
11246>>>        
11246>>>        Move Self to ghoConnection
11247>>>        
11247>>>    End_Procedure
11248>>>    
11248>>>    // error trapping for this object
11248>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
11250>>>        Set piErrorLine to iErrorLine
11251>>>        Set piErrorNumber to iErrorNumber
11252>>>        Set psErrorText to sErrorText
11253>>>    End_Procedure
11254>>>    
11254>>>    Procedure TrapErrors
11256>>>        Set phoOldError to Error_Object_Id
11257>>>        Set piErrorNumber to 0
11258>>>        Move Self to Error_Object_Id
11259>>>    End_Procedure
11260>>>    
11260>>>    Procedure UnTrapErrors
11262>>>        Get phoOldError to Error_Object_Id
11263>>>    End_Procedure
11264>>>    
11264>>>    // Report a connections configuration error as a handled user error.
11264>>>    Procedure ConfigurationError Integer iError String sError
11266>>>        Send UserError sError C_$DriverConfigurationError
11267>>>    End_Procedure
11268>>>    
11268>>>    // Setting this property will change this new and all existing managed drivers
11268>>>    Procedure Set pbLoginOnOpen Boolean bLoginOnOpen
11270>>>        tDriverCLIDictionary[] DriverMap
11270>>>        tDriverCLIDictionary[] DriverMap
11271>>>        Integer i iDriver
11271>>>        Set private_pbLoginOnOpen to bLoginOnOpen
11272>>>        
11272>>>        // set any existing registered drivers
11272>>>        Get pRegisteredDriversDict to DriverMap
11273>>>        For i from 0 to (SizeOfArray(DriverMap)-1)
11279>>>>
11279>>>            Get DriverIndex DriverMap[i].sDriver to iDriver
11280>>>            Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to bLoginOnOpen
11283>>>        Loop
11284>>>>
11284>>>        
11284>>>    End_Procedure
11285>>>    
11285>>>    Function pbLoginOnOpen Returns Boolean
11287>>>        Boolean bLogin
11287>>>        Get private_pbLoginOnOpen to bLogin
11288>>>        Function_Return bLogin
11289>>>    End_Function
11290>>>    
11290>>>    
11290>>>    // returns the Index from list of loaded drivers for sDriver. 0 if not found
11290>>>    // This searches all loaded drivers which may include drivers that were
11290>>>    // not registered.
11290>>>    Function DriverIndex String sDriver Returns Integer
11292>>>        Integer iDrivers i
11292>>>        String sADriver
11292>>>        Move (Uppercase(sDriver)) to sDriver
11293>>>        Get_Attribute DF_NUMBER_DRIVERS to iDrivers
11296>>>        For i from 1 to iDrivers
11302>>>>
11302>>>            Get_Attribute DF_DRIVER_NAME of i to sADriver
11305>>>            If (sDriver=Uppercase(sADriver)) Begin
11307>>>                Function_Return i
11308>>>            End
11308>>>>
11308>>>        Loop
11309>>>>
11309>>>        Function_Return 0
11310>>>    End_Function
11311>>>    
11311>>>    // returns cConnectionCLIHandler object for this driver id.
11311>>>    // This must be a registered managed driver. If not found return 0
11311>>>    // This can be used to test if a driver is registered (and therefore loaded)
11311>>>    Function DriverCLIHandler String sDriver Returns Handle
11313>>>        Integer iIndex
11313>>>        tDriverCLIDictionary[] DriverMap
11313>>>        tDriverCLIDictionary[] DriverMap
11314>>>        tDriverCLIDictionary DriverItem
11314>>>        tDriverCLIDictionary DriverItem
11314>>>        Move (Trim(Uppercase(sDriver))) to sDriver
11315>>>        Move sDriver to DriverItem.sDriver
11316>>>        Get pRegisteredDriversDict to DriverMap
11317>>>        Move (SearchArray(DriverItem,DriverMap)) to iIndex
11318>>>        If (iIndex<>-1) Begin
11320>>>            Function_Return DriverMap[iIndex].hoCLI
11321>>>        End
11321>>>>
11321>>>        Function_Return 0
11322>>>    End_Function
11323>>>    
11323>>>    // low level load which does not register the driver - only loads
11323>>>    Function LoadDriver String sDriver Returns Boolean
11325>>>        Integer iErrorNumber
11325>>>        Send TrapErrors
11326>>>        Load_Driver sDriver
11327>>>        Send UnTrapErrors
11328>>>        Get piErrorNumber to iErrorNumber
11329>>>        Function_Return (iErrorNumber=0)
11330>>>    End_Function
11331>>>    
11331>>>    Function TestDriverConformance String sDriver Integer iDriver Handle hoCLI Returns Boolean
11333>>>        Integer iConformance
11333>>>        Get_Attribute DF_DRIVER_CONFORMANCE of iDriver to iConformance
11336>>>        If (not(iConformance iand 8)) Begin // bit 4 is managed driver conformance
11338>>>            Send ConfigurationError DFERR_SETUP (SFormat(C_$DriverIsNotManaged,sDriver))
11339>>>            Function_Return False
11340>>>        End
11340>>>>
11340>>>        Function_Return True
11341>>>    End_Function
11342>>>    
11342>>>    // Register this driver. Load driver if not yet loaded
11342>>>    // return cConnectionCLIHandler handle for this driver
11342>>>    // If registered, just return the handle
11342>>>    // return 0 if driver cannot be loaded
11342>>>    // If newly registered here, sends OnDriverRegistered event
11342>>>    // raise error if driver cannot be loaded or does not conform
11342>>>    Function RegisterDriver String sDriver Returns Handle
11344>>>        Integer iIndex iDriver iConformance
11344>>>        Handle hoCLI hClass
11344>>>        Boolean bOk
11344>>>        Boolean bAutoLogin
11344>>>        tDriverCLIDictionary[] DriverMap
11344>>>        tDriverCLIDictionary[] DriverMap
11345>>>        Integer iIds iRet
11345>>>        String sId
11345>>>        Get DriverCLIHandler sDriver to hoCLI
11346>>>        If (hoCLI=0) Begin // driver not registered yet
11348>>>            Get pRegisteredDriversDict to DriverMap
11349>>>            Get phcDriverConnection to hClass
11350>>>            Get CreateNamed hClass ("oCLI_"+sDriver) to hoCLI
11351>>>            Move (SizeOfArray(DriverMap)) to iIndex
11352>>>            Move (Trim(Uppercase(sDriver)))  to DriverMap[iIndex].sDriver
11353>>>            Move hoCLI to DriverMap[iIndex].hoCLI
11354>>>            Set pRegisteredDriversDict to DriverMap
11355>>>            Set psDriverID of hoCLI to DriverMap[iIndex].sDriver
11356>>>            
11356>>>            Get DriverIndex DriverMap[iIndex].sDriver to iDriver
11357>>>            Move (iDriver>0) to bOk // is driver already loaded (just not registered)
11358>>>            If not bOk Begin
11360>>>                Get LoadDriver DriverMap[iIndex].sDriver to bOk
11361>>>                If bOk Begin
11363>>>                    Get DriverIndex DriverMap[iIndex].sDriver to iDriver
11364>>>                End
11364>>>>
11364>>>                Else Begin
11365>>>                    Send ConfigurationError DFERR_SETUP (SFormat(C_$DriverNotFound,sDriver))
11366>>>                End
11366>>>>
11366>>>            End
11366>>>>
11366>>>            
11366>>>            // finally make sure loaded driver supports managed connections and any other
11366>>>            // tests that might be applied by the developer
11366>>>            If bOk Begin
11368>>>                Get TestDriverConformance sDriver iDriver hoCLI to bOk
11369>>>            End
11369>>>>
11369>>>            
11369>>>            If not bOk Begin
11371>>>                Send Destroy of hoCLI
11372>>>                Move 0 to hoCLI
11373>>>                Move (RemoveFromArray(DriverMap,iIndex)) to DriverMap
11374>>>                Set pRegisteredDriversDict to DriverMap
11375>>>            End
11375>>>>
11375>>>            Else Begin
11376>>>                // driver is loaded and valid, complete registration
11376>>>                
11376>>>                // Is auto-login on open supported?
11376>>>                Get pbLoginOnOpen to bAutoLogin
11377>>>                Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to bAutoLogin
11380>>>                
11380>>>                // remove existing connection IDs as defined in the driver.int file. If you are
11380>>>                // using registered connections, you are using registered drivers!
11380>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iIds
11383>>>                While (iIds>0)
11387>>>                    Decrement iIds
11388>>>                    Get DeleteConnectionID of hoCLI "" iIds to iRet
11389>>>                Loop
11390>>>>
11390>>>                
11390>>>                Send OnDriverRegistered sDriver iDriver hoCLI
11391>>>            End
11391>>>>
11391>>>        End
11391>>>>
11391>>>        Function_Return hoCLI
11392>>>    End_Function
11393>>>    
11393>>>    
11393>>>    
11393>>>    // returns a string array of loaded drivers (managed and unmanaged)
11393>>>    Function LoadedDrivers Returns String[]
11395>>>        Integer iDrivers i
11395>>>        String[] ArrayOfDrivers
11396>>>        Get_Attribute DF_NUMBER_DRIVERS to iDrivers
11399>>>        For i from 1 to iDrivers
11405>>>>
11405>>>            Get_Attribute DF_DRIVER_NAME of i to ArrayOfDrivers[i-1]
11408>>>        Loop
11409>>>>
11409>>>        Function_Return ArrayOfDrivers
11410>>>    End_Function
11411>>>    
11411>>>    // List of all Server connection-strings logged into this driver.
11411>>>    // This includes managed/registered strings and strings used in non-managed ways (e.g., in int file)
11411>>>    Function DriverServerNames String sDriver Returns String[]
11413>>>        Integer iConnections i iDriver
11413>>>        String[] Connections
11414>>>        Get DriverIndex sDriver to iDriver
11415>>>        If (iDriver>0) Begin
11417>>>            Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iConnections
11420>>>            For i from 0 to (iConnections-1)
11426>>>>
11426>>>                Get_Attribute DF_DRIVER_SERVER_NAME of iDriver (i+1) to Connections[i]
11429>>>            Loop
11430>>>>
11430>>>        End
11430>>>>
11430>>>        Function_Return Connections
11431>>>    End_Function
11432>>>    
11432>>>    // this does a low level login, which basically wraps the login command with some error handling
11432>>>    // and the ability to make a login silent.
11432>>>    // This is essentially a Login command surrounded by error checking and trapping
11432>>>    Function BasicLogin String sDriver String sServer String sName String sPassword Returns Integer
11434>>>        Integer iError iIndex
11434>>>        Handle hoConnect
11434>>>        Get DriverIndex sDriver to iIndex
11435>>>        If (iIndex>0) Begin
11437>>>            Send TrapErrors
11438>>>            Login sServer sName sPassword sDriver
11440>>>            Send UnTrapErrors
11441>>>            Get piErrorNumber to iError
11442>>>        End
11442>>>>
11442>>>        Else Begin
11443>>>            Move DFERR_PROGRAM to iError
11444>>>            Error iError (SFormat(C_$DriverNotFound,  sDriver))
11445>>>>
11445>>>        End
11445>>>>
11445>>>        Function_Return iError
11446>>>    End_Function
11447>>>    
11447>>>    
11447>>>    // get array of managed connections across all drivers
11447>>>    // returns array of connections in tConnection.
11447>>>    Function ConnectionIDs Returns tConnection[]
11449>>>        tConnection[] Connections
11449>>>        tConnection[] Connections
11450>>>        Get pConnections to Connections
11451>>>        Function_Return Connections
11452>>>    End_Function
11453>>>    
11453>>>    // return index of Id from pConnections array. -1 if missing
11453>>>    Function ConnectionIdIndex String sId Returns Integer
11455>>>        tConnection[] Connections
11455>>>        tConnection[] Connections
11456>>>        tConnection Connection
11456>>>        tConnection Connection
11456>>>        Integer iIndex
11456>>>        Move (trim(sId)) to Connection.sId
11457>>>        Get pConnections to Connections
11458>>>        Move (SearchArray(Connection,Connections,Desktop,RefFunc(ComparetConnectionById))) to iIndex
11459>>>        Function_Return iIndex
11460>>>    End_Function
11461>>>    
11461>>>    // return handle of cConnectionCLIHandler object for this id. 0 if none
11461>>>    Function ConnectionIdCLIHandler String sId Returns Handle
11463>>>        tConnection[] Ids
11463>>>        tConnection[] Ids
11464>>>        Integer iIndex
11464>>>        Handle hoCLI
11464>>>        Get ConnectionIds to Ids
11465>>>        Get ConnectionIdIndex sId to iIndex
11466>>>        If (iIndex<>-1) Begin
11468>>>            Get DriverCLIHandler Ids[iIndex].sDriver to hoCLI
11469>>>            Function_Return hoCLI
11470>>>        End
11470>>>>
11470>>>        Function_Return 0
11471>>>    End_Function
11472>>>    
11472>>>    // return connection info for this id. Programming error if Id does not exist
11472>>>    Function ConnectionIdInfo String sId Returns tConnection
11474>>>        tConnection[] ConnIDs
11474>>>        tConnection[] ConnIDs
11475>>>        tConnection ConnId
11475>>>        tConnection ConnId
11475>>>        Integer iIndex i
11475>>>        Handle hoCLI
11475>>>        Get ConnectionIdCLIHandler sId to hoCLI
11476>>>        If (hoCLI) Begin
11478>>>            Get ConnectionIdIndex sId to iIndex
11479>>>            Get ConnectionIDs to ConnIDs
11480>>>            Move ConnIDs[iIndex] to ConnId
11481>>>        End
11481>>>>
11481>>>        Else Begin
11482>>>            Error DFERR_PROGRAM (SFormat(C_$ConnectionIdNotFound,sId))
11483>>>>
11483>>>        End
11483>>>>
11483>>>        Function_Return ConnId
11484>>>    End_Function
11485>>>    
11485>>>    
11485>>>    // add or upate connection to pConnections. Do not call directly
11485>>>    Function AddToConnections tConnection Connection Returns Integer
11487>>>        tConnection[] Connections
11487>>>        tConnection[] Connections
11488>>>        Integer iIndex
11488>>>        Get pConnections to Connections
11489>>>        Get ConnectionIdIndex Connection.sId to iIndex
11490>>>        If (iIndex=-1) Begin
11492>>>            Move (SizeOfArray(Connections)) to iIndex
11493>>>        End
11493>>>>
11493>>>        Move Connection to Connections[iIndex]
11494>>>        Set pConnections to Connections
11495>>>        Function_Return iIndex
11496>>>    End_Function
11497>>>    
11497>>>    // Remove connection ID from pConnection. Don't call directly
11497>>>    Function RemoveFromConnections String sId Returns Boolean
11499>>>        tConnection[] Connections
11499>>>        tConnection[] Connections
11500>>>        Integer iIndex
11500>>>        Get pConnections to Connections
11501>>>        Get ConnectionIdIndex sId to iIndex
11502>>>        If (iIndex<>-1) Begin
11504>>>            Move (RemoveFromArray(Connections,iIndex)) to Connections
11505>>>            Set pConnections to Connections
11506>>>        End
11506>>>>
11506>>>        Function_Return (iIndex<>-1)
11507>>>    End_Function
11508>>>    
11508>>>    // Return the connection ID syntax used for IDs in the INT file (e.g., DFCONNID=ID1)
11508>>>    // helper so you don't have to remember this syntax. Does not verify Id
11508>>>    Function ConnectionIDServerString String sId Returns String
11510>>>        Function_Return (C_ConnectionId - sId)
11511>>>    End_Function
11512>>>    
11512>>>    // Returns Connection.Ini file name if passed from the command line.
11512>>>    // requires cApplication object
11512>>>    // It's looking for something like dfconnid=myconnid.ini
11512>>>    Function ConnectionIniFromCmdLine Returns String
11514>>>        Handle hoCmdLine
11514>>>        Integer iCount iArg iPos
11514>>>        String sArg sFile sLeft
11514>>>        Get psConnectionIdCmdLine to sLeft
11515>>>        Get phoCommandLine of ghoApplication to hoCmdLine
11516>>>        Get CountOfArgs of hoCmdLine to iCount
11517>>>        For iArg from 1 to iCount
11523>>>>
11523>>>            Get Argument of hoCmdLine iArg to sArg
11524>>>            If (Pos(Lowercase(sLeft),Trim(Lowercase(sArg)))=1) Begin
11526>>>                Move (Trim(Remove(sArg,1,Length(C_ConnectionIdCmdLineName)))) to sFile
11527>>>                Function_Return sFile
11528>>>            End
11528>>>>
11528>>>        Loop
11529>>>>
11529>>>        Function_Return ""
11530>>>    End_Function
11531>>>    
11531>>>    // get qualified version of connections INI file using the rules for
11531>>>    // acquring this name. This file may not exist.
11531>>>    Function ConnectionIniFile Returns String
11533>>>        String sConnections sPath sPName
11533>>>        Boolean bCmdLineIniAllowed
11533>>>        Handle hoWorkspace
11533>>>        
11533>>>        Get pbCmdLineIniAllowed to bCmdLineIniAllowed
11534>>>        Get phoWorkspace of ghoApplication to hoWorkspace
11535>>>        
11535>>>        // order of naming precedence
11535>>>        // 1. If defined directly via a set, use that name
11535>>>        // 2. If command line allowed and exists use that name
11535>>>        // 3. If workspace has a definition (from config.ws) use that name
11535>>>        // 4. Else the default of data\dfconnid.ini
11535>>>        
11535>>>        Get psConnectionIni to sConnections
11536>>>        If (sConnections="" and bCmdLineIniAllowed) Begin
11538>>>            Get ConnectionIniFromCmdLine to sConnections
11539>>>        End
11539>>>>
11539>>>        If (sConnections="") Begin
11541>>>            Get psConnectionIni of hoWorkspace to sConnections
11542>>>        End
11542>>>>
11542>>>        If (sConnections="") Begin
11544>>>            Move C_ConnectionIniFileName to sConnections
11545>>>        End
11545>>>>
11545>>>        Move (Trim(sConnections)) to sConnections
11546>>>        
11546>>>        If (sConnections<>"") Begin
11548>>>            // first data path
11548>>>            If (Pos("<datapath>\",Lowercase(sConnections))) Begin
11550>>>                Get psDataPath of hoWorkspace to sPath
11551>>>                Move "<datapath>\" to sPName
11552>>>            End
11552>>>>
11552>>>            // first programs path
11552>>>            Else If (Pos("<apppath>\",Lowercase(sConnections))) Begin
11555>>>                Get GetApplicationPath of hoWorkspace to sPath
11556>>>                Move "<apppath>\" to sPName
11557>>>            End
11557>>>>
11557>>>            // first workspace home path
11557>>>            Else If (Pos("<homepath>\",Lowercase(sConnections))) Begin
11560>>>                Get psHome of hoWorkspace to sPath
11561>>>                Move "<homepath>\" to sPName
11562>>>            End
11562>>>>
11562>>>            // if no special path, use first data path
11562>>>            Else If (not(IsFilenameQualified(sConnections))) Begin
11565>>>                Get psDataPath of hoWorkspace to sPath
11566>>>                Move '' to sPName
11567>>>            End
11567>>>>
11567>>>            
11567>>>            If (sPath<>"") Begin
11569>>>                Get PathAtIndex of hoWorkspace sPath 1 to sPath
11570>>>                If (sPName<>"") Begin
11572>>>                    Move (Replace(sPName, sConnections, (sPath + "\"))) to sConnections
11573>>>                End
11573>>>>
11573>>>                Else Begin
11574>>>                    Move (sPath + "\" + sConnections) to sConnections
11575>>>                End
11575>>>>
11575>>>            End
11575>>>>
11575>>>        End
11575>>>>
11575>>>        Function_Return sConnections
11576>>>    End_Function
11577>>>    
11577>>>    Procedure OnReadCredentials String sSection String sId Handle hoIni String ByRef sUID String ByRef sPWDEncrypted Boolean ByRef bTrusted
11579>>>        String sTrusted
11579>>>        If (hoIni) Begin
11581>>>            Get ReadString of hoIni sSection C_ConnectionIniSectionUID "" to sUID
11582>>>            Get ReadString of hoIni sSection C_ConnectionIniSectionPWD "" to sPWDEncrypted
11583>>>            Get ReadString of hoIni sSection C_ConnectionIniSectionTrusted "" to sTrusted
11584>>>            Move (lowercase(sTrusted)="yes") to bTrusted
11585>>>        End
11585>>>>
11585>>>    End_Procedure
11586>>>    
11586>>>    Procedure OnWriteCredentials String sSection String sId Handle hoIni String sUID String sPWDEncrypted Boolean bTrusted
11588>>>        If hoIni Begin
11590>>>            If (not(bTrusted) and  sUID<>"") Begin
11592>>>                Send WriteString of hoIni sSection C_ConnectionIniSectionUID sUID
11593>>>            End
11593>>>>
11593>>>            Else Begin
11594>>>                Send DeleteKey of hoIni sSection C_ConnectionIniSectionUID
11595>>>            End
11595>>>>
11595>>>            
11595>>>            If (not(bTrusted) and sUID<>"" and sPWDEncrypted<>"") Begin
11597>>>                Send WriteString of hoIni sSection C_ConnectionIniSectionPWD sPWDEncrypted
11598>>>            End
11598>>>>
11598>>>            Else Begin
11599>>>                Send DeleteKey of hoIni sSection C_ConnectionIniSectionPWD
11600>>>            End
11600>>>>
11600>>>            
11600>>>            If (bTrusted) Begin
11602>>>                Send WriteString of hoIni sSection C_ConnectionIniSectionTrusted "yes"
11603>>>            End
11603>>>>
11603>>>            Else Begin
11604>>>                Send DeleteKey of hoIni sSection C_ConnectionIniSectionTrusted
11605>>>            End
11605>>>>
11605>>>        End
11605>>>>
11605>>>    End_Procedure
11606>>>    
11606>>>    // returns a list of connection Ids from the connections.ini file.
11606>>>    // Driver does not have to be loaded (if not loaded, hoCLI=0)
11606>>>    // If pbUseConnectionIni is False, this does Nothing
11606>>>    // and must be augmented to do anything useful
11606>>>    Function LoadStoredConnections tConnection[] ByRef Connects Returns Boolean
11608>>>        String sConnectPath sId sConnect sDriver sUID sPWD sSection sDisabled
11608>>>        String[] Sections
11609>>>        Handle hoWorkspace hoArray hoIniFile
11609>>>        Integer i iConns iIndex
11609>>>        Boolean bUseConnectionIni bOk bTrusted bDisabled
11609>>>        tConnection ConnNew
11609>>>        tConnection ConnNew
11609>>>        
11609>>>        Get pbUseConnectionIni to bUseConnectionIni
11610>>>        
11610>>>        If bUseConnectionIni Begin
11612>>>            
11612>>>            Get ConnectionIniFile of ghoConnection to sConnectPath
11613>>>            If (sConnectPath="" or not(DoesFileExist(sConnectPath))) Begin
11615>>>                Function_Return True // if file does not exist, that's ok - no connections
11616>>>            End
11616>>>>
11616>>>            
11616>>>            Get Create (RefClass(cIniFile)) to hoIniFile
11617>>>            Get Create (RefClass(Array)) to hoArray
11618>>>            Set psFilename of hoIniFile to sConnectPath
11619>>>            
11619>>>            Send ReadSections of hoIniFile hoArray
11620>>>            
11620>>>            // create an array of all Connection sections.
11620>>>            For i from 0 to (Item_Count(hoArray) -1)
11626>>>>
11626>>>                Get Value of hoArray i to sSection
11627>>>                Move (Trim(sSection)) to sSection
11628>>>                If (Pos(Uppercase(C_ConnectionIniSectionBaseName),Uppercase(sSection))=1) Begin
11630>>>                    // make sure id is not a duplicate
11630>>>                    Move sId to ConnNew.sId
11631>>>                    Move (SearchArray(sSection, Sections, Desktop,RefFunc(DFSTRICMP))) to iIndex
11632>>>                    If (iIndex<>-1) Begin
11634>>>                        Send ConfigurationError DFERR_SETUP (SFormat(C_$ConnectionIniDupSection,sConnectPath,sSection))
11635>>>                        Function_Return False
11636>>>                    End
11636>>>>
11636>>>                    Move (trim(sSection)) to Sections[SizeOfArray(Sections)]
11637>>>                End
11637>>>>
11637>>>            Loop
11638>>>>
11638>>>            
11638>>>            For i from 0 to (SizeOfArray(Sections)-1)
11644>>>>
11644>>>                Move Sections[i] to sSection
11645>>>                
11645>>>                Get ReadString of hoIniFile sSection C_ConnectionIniSectionId "" to sId
11646>>>                If (sId="") Begin
11648>>>                    Send ConfigurationError DFERR_SETUP (SFormat(C_$ConnectionIniBadId,sConnectPath,sSection))
11649>>>                    Function_Return False
11650>>>                End
11650>>>>
11650>>>                
11650>>>                Get ReadString of hoIniFile sSection C_ConnectionIniSectionDriver "" to sDriver
11651>>>                If (sDriver="") Begin
11653>>>                    Send ConfigurationError DFERR_SETUP (SFormat(C_$ConnectionIniBadDriver,sConnectPath,sSection))
11654>>>                    Function_Return False
11655>>>                End
11655>>>>
11655>>>                
11655>>>                Get ReadString of hoIniFile sSection C_ConnectionIniSectionConnection "" to sConnect
11656>>>                If (sConnect="") Begin
11658>>>                    Send ConfigurationError DFERR_SETUP (SFormat(C_$ConnectionIniBadConnection,sConnectPath,sSection))
11659>>>                    Function_Return False
11660>>>                End
11660>>>>
11660>>>                
11660>>>                Get ReadString of hoIniFile sSection C_ConnectionIniSectionDisabled "" to sDisabled
11661>>>                Move (Lowercase(sDisabled)="yes") to bDisabled
11662>>>                
11662>>>                Send OnReadCredentials sSection sId hoIniFile (&sUID) (&sPWD) (&bTrusted)
11663>>>                
11663>>>                If (sPWD<>"") Begin
11665>>>                    Get DecryptPassword sPWD to sPWD
11666>>>                End
11666>>>>
11666>>>                
11666>>>                Move sSection to Connects[iConns].sSection
11667>>>                Move sDriver to Connects[iConns].sDriver
11668>>>                Move sId to Connects[iConns].sId
11669>>>                Move sConnect to Connects[iConns].sString
11670>>>                Move bDisabled to Connects[iConns].bDisabled
11671>>>                Move sPWD to Connects[iConns].sPWD
11672>>>                Move bTrusted to Connects[iConns].bTrustedConnection
11673>>>                Move sUID to Connects[iConns].sUID
11674>>>                
11674>>>                Increment iConns
11675>>>            Loop
11676>>>>
11676>>>            Send Destroy of hoArray
11677>>>            Send Destroy of hoIniFile
11678>>>        End
11678>>>>
11678>>>        
11678>>>        Function_Return True
11679>>>    End_Function
11680>>>    
11680>>>    Function DecryptPassword String sPWD Returns String
11682>>>        Handle hoLoginEncrypt
11682>>>        Boolean bEncryptPassword
11682>>>        Get pbEncryptPassword to bEncryptPassword
11683>>>        If (bEncryptPassword) Begin
11685>>>            Move ghoLoginEncryption to hoLoginEncrypt
11686>>>            // if not registered an error will occur - programming error
11686>>>            Get DecryptPassword of hoLoginEncrypt sPWD to sPWD
11687>>>        End
11687>>>>
11687>>>        Function_Return sPWD
11688>>>    End_Function
11689>>>    
11689>>>    Function EncryptPassword String sPWD Returns String
11691>>>        Handle hoLoginEncrypt
11691>>>        Boolean bEncryptPassword
11691>>>        Get pbEncryptPassword to bEncryptPassword
11692>>>        If (bEncryptPassword) Begin
11694>>>            Move ghoLoginEncryption to hoLoginEncrypt
11695>>>            // if not registered an error will occur - programming error
11695>>>            Get EncryptPassword of hoLoginEncrypt sPWD to sPWD
11696>>>        End
11696>>>>
11696>>>        Function_Return sPWD
11697>>>    End_Function
11698>>>    
11698>>>    // Assemble connect string based on connect string, user id, password and trusted connection
11698>>>    // If connect string already contains user id, etc. it is still appended which is consistent
11698>>>    // with odbc connection strings. The last one wins.
11698>>>    // sConnect should contain the SERVER= or DSN= information.
11698>>>    Function AssembleConnectionString String sConnect String sUID String sPWD Boolean bTrusted Returns String
11700>>>        String sConnectString
11700>>>        Move sConnect to sConnectString
11701>>>        If (bTrusted) Begin
11703>>>            Move (sConnectString+";trusted_connection=yes") to sConnectString
11704>>>        End
11704>>>>
11704>>>        Else Begin
11705>>>            If (sUID<>"") Begin
11707>>>                Move (sConnectString+";UID="+sUID) to sConnectString
11708>>>            End
11708>>>>
11708>>>            If (sPWD<>"") Begin
11710>>>                Move (sConnectString+";PWD="+sPWD) to sConnectString
11711>>>            End
11711>>>>
11711>>>        End
11711>>>>
11711>>>        Function_Return sConnectString
11712>>>    End_Function
11713>>>    
11713>>>    Function AddConnectionToDriverCLI Handle hoCLI tConnection Connection Returns Integer
11715>>>        Integer iResult iIndex
11715>>>        Get ConnectionIdIndex Connection.sId to iIndex
11716>>>        If (iIndex<>-1) Begin
11718>>>            Send ConfigurationError DFERR_SETUP (SFormat(C_$ConnectionIdAlreadyExists,Connection.sId))
11719>>>            Function_Return 1
11720>>>        End
11720>>>>
11720>>>        Get CreateConnectionID of hoCLI Connection.sId Connection.sConnectionString Connection.iOptions to iResult
11721>>>        If (iResult=0) Begin
11723>>>            Get AddToConnections Connection to iIndex
11724>>>        End
11724>>>>
11724>>>        Function_Return iResult
11725>>>    End_Function
11726>>>    
11726>>>    
11726>>>    // add a connection id for this driver.
11726>>>    // pass server string, user id, password and trusted connection info. The
11726>>>    // server string that gets added will combine all of these. The password
11726>>>    // may require decoding by calling decode password.
11726>>>    Function AddConnection String sDriver String sId String sString String sUID String sPWD Boolean bTrusted String sSection Returns Integer
11728>>>        Handle hoCLI
11728>>>        Integer iResult
11728>>>        tConnection Connection
11728>>>        tConnection Connection
11728>>>        String sConnectString
11728>>>        Get RegisterDriver sDriver to hoCLI
11729>>>        If (hoCLI=0) Begin
11731>>>            // will have raised an error
11731>>>            Function_Return False
11732>>>        End
11732>>>>
11732>>>        Get DriverIndex sDriver to Connection.iDriverIndex
11733>>>        Move sDriver to Connection.sDriver
11734>>>        Get AssembleConnectionString sString sUID sPWD bTrusted to sConnectString
11735>>>        
11735>>>        // assemble the connection struct variable.
11735>>>        Move (Trim(sSection)) to Connection.sSection
11736>>>        Move (Trim(sId)) to Connection.sId
11737>>>        Move sString to Connection.sString
11738>>>        Move sUID to Connection.sUID
11739>>>        Move sPWD to Connection.sPWD
11740>>>        Move bTrusted to Connection.bTrustedConnection
11741>>>        Move True to Connection.iOptions // login always silent.
11742>>>        Move sConnectString to Connection.sConnectionString
11743>>>        Send OnAddConnection (&Connection) // further customize connection
11744>>>        Get AddConnectionToDriverCLI hoCLI Connection to iResult
11745>>>        Function_Return (iResult=0)
11746>>>    End_Function
11747>>>    
11747>>>    // add connectionIds for all registered drivers
11747>>>    // if driver not loaded/registered, do so first
11747>>>    // If any error occurs, stop process and return false, else true
11747>>>    Function AddAllConnections Returns Boolean
11749>>>        tConnection[] Connects
11749>>>        tConnection[] Connects
11750>>>        Integer i iResult
11750>>>        Boolean bOk
11750>>>        Handle hoCLI
11750>>>        Get LoadStoredConnections (&Connects) to bOk
11751>>>        If not bOk Begin
11753>>>            Function_Return False
11754>>>        End
11754>>>>
11754>>>        
11754>>>        For i from 0 to (SizeOfArray(Connects)-1)
11760>>>>
11760>>>            If (not(Connects[i].bDisabled)) Begin
11762>>>                Get AddConnection Connects[i].sDriver Connects[i].sId Connects[i].sString Connects[i].sUID Connects[i].sPWD Connects[i].bTrustedConnection Connects[i].sSection to bOk
11763>>>                If not bOk Begin
11765>>>                    Function_Return False
11766>>>                End
11766>>>>
11766>>>            End
11766>>>>
11766>>>        Loop
11767>>>>
11767>>>        Function_Return True
11768>>>    End_Function
11769>>>    
11769>>>    // returns the DF_DATABASE_ID handle for the passed connection
11769>>>    // should only be called with data obtained from ConnectionIdInfo
11769>>>    // of ConnectionIds and not LoadStoredConnections
11769>>>    // If this returns 0, the connection is not logged in
11769>>>    Function ConnectionDatabaseIdHandle tConnection Conn Returns Handle
11771>>>        Handle hConnectionHandle
11771>>>        String sServerString
11771>>>        Get ConnectionIDServerString Conn.sId to sServerString
11772>>>        Get ServerDatabaseIdHandle Conn.sDriver Conn.iDriverIndex sServerString to hConnectionHandle
11773>>>        Function_Return hConnectionHandle
11774>>>    End_Function
11775>>>    
11775>>>    Function ServerDatabaseIdHandle String sDriver Integer iDriver String sServerString Returns Handle
11777>>>        Integer i
11777>>>        String[] ServerNames
11778>>>        Handle hConnectionHandle
11778>>>        Get DriverServerNames sDriver to ServerNames
11779>>>        Move (SearchArray(sServerString,ServerNames,Desktop,RefFunc(DFSTRICMP))) to i
11780>>>        If (i<>-1) Begin
11782>>>            Get_Attribute DF_DATABASE_ID of iDriver (i+1) to hConnectionHandle
11785>>>        End
11785>>>>
11785>>>        Function_Return hConnectionHandle
11786>>>    End_Function
11787>>>    
11787>>>    // Is connection ID logged in. Pass just the id (e.g. ID1)
11787>>>    // If connection ID is not registered, raise an error
11787>>>    Function IsConnectionIdLoggedIn String sId Returns Boolean
11789>>>        tConnection Connect
11789>>>        tConnection Connect
11789>>>        Handle hConnectionHandle
11789>>>        Get ConnectionIdInfo sId to Connect
11790>>>        Get ConnectionDatabaseIdHandle Connect to hConnectionHandle
11791>>>        Function_Return (hConnectionHandle<>0)
11792>>>    End_Function
11793>>>    
11793>>>    // login to this managed connection via connection id. return 0 if ok
11793>>>    // If ID not found, raise a program error
11793>>>    // Login by connect Id - main interface.
11793>>>    Function LoginConnectionId String sId Returns Integer
11795>>>        Integer iResult
11795>>>        Handle hoCli
11795>>>        Boolean bSkipDup bConnected
11795>>>        String sDriver sServer sError sDesc
11795>>>        tConnection Connect
11795>>>        tConnection Connect
11795>>>        Get ConnectionIdCLIHandler sId to hoCLI
11796>>>        
11796>>>        If hoCli Begin
11798>>>            Get pbSkipDuplicateLogin to bSkipDup
11799>>>            If (bSkipDup) Begin
11801>>>                Get IsConnectionIdLoggedIn sId to bConnected
11802>>>            End
11802>>>>
11802>>>            If not bConnected Begin
11804>>>                Get LoginConnectIdBase sId False to iResult
11805>>>                If (iResult) Begin
11807>>>                    Get psErrorText to sError
11808>>>                    Get ConnectionIdInfo sId to Connect
11809>>>                    Move (sDesc + sFormat("Connection Id=%1.\n\n",sId) + sError) to sError
11810>>>                    Set psErrorText to sError
11811>>>                End
11811>>>>
11811>>>            End
11811>>>>
11811>>>        End
11811>>>>
11811>>>        Else Begin
11812>>>            Error DFERR_PROGRAM (SFormat(C_$ConnectionIdNotFound,sId))
11813>>>>
11813>>>            Move 1 to iResult
11814>>>        End
11814>>>>
11814>>>        Function_Return iResult
11815>>>    End_Function
11816>>>    
11816>>>    // does unconditional login for connection Id. This
11816>>>    // can be customized.
11816>>>    Function LoginConnectIdBase String sId Boolean bSilent Returns Integer
11818>>>        Integer iError
11818>>>        Boolean bOk bSkipDialog
11818>>>        String sConn
11818>>>        tConnection Connect
11818>>>        tConnection Connect
11818>>>        Get ConnectionIdInfo sId to Connect
11819>>>        Get ConnectionIDServerString Connect.sId to sConn
11820>>>        // first try a silent login. If it works we are done
11820>>>        Get BasicLogin Connect.sDriver sConn "" "" to iError
11821>>>        If (iError=0) Begin
11823>>>            Function_Return 0
11824>>>        End
11824>>>>
11824>>>        
11824>>>        // If login failed because of incorrect client, skip the login dialog.
11824>>>        // This is the first place this version test occurs.
11824>>>        If (iError=CLIERR_NOCLIENTSERVERVERSIONMATCH or iError=CLIERR_MINIMUMCLIENTVERSIONNOTFOUND) Begin
11826>>>            Function_Return 1
11827>>>        End
11827>>>>
11827>>>        
11827>>>        // If we have a compliant login dialog, try that.
11827>>>        If (not(bSilent)) Begin
11829>>>            Get LoginConnectIdDialog Connect.sId to bOk
11830>>>        End
11830>>>>
11830>>>        Function_Return (If(bOk,0,1))
11831>>>    End_Function
11832>>>    
11832>>>    
11832>>>    Function LoginConnectIdDialog String sId Returns Boolean
11834>>>        Handle hoLoginConnectDialog bLoginDialogRequired
11834>>>        Boolean bOk
11834>>>        
11834>>>// web applications don't use an embedded database login
11834>>>        Get pbLoginDialogRequired to bLoginDialogRequired
11835>>>        If (bLoginDialogRequired) Begin
11837>>>            Move ghoLoginConnectDialog to hoLoginConnectDialog
11838>>>            // if object missing an error is raised - programming error
11838>>>            Get LoginConnectIdDialog of hoLoginConnectDialog sId to bOk
11839>>>        End
11839>>>>
11839>>>        
11839>>>        Function_Return bOk
11840>>>    End_Function
11841>>>    
11841>>>    // Change Connect string based on passed credentials
11841>>>    // Update the driver's map of connect Id/Connect strings.
11841>>>    // If there is no change in the connection string, this does nothing.
11841>>>    // This will log out and disconnect from the existing connection and connect (but
11841>>>    // not login) to the new one.
11841>>>    // The Id must exist or errors
11841>>>    Function ChangeConnectIdCredentials String sId String sUser String sPwd Boolean bTrust Returns tConnection
11843>>>        tConnection Connect
11843>>>        tConnection Connect
11843>>>        Integer iError
11843>>>        String sConnStr
11843>>>        Get ConnectionIdInfo sId to Connect
11844>>>        Get AssembleConnectionString Connect.sString sUser sPwd bTrust to Connect.sConnectionString
11845>>>        If (Connect.sConnectionString<>sConnStr) Begin
11847>>>            Send LogoutConnectionId Connect.sId
11848>>>            Send DeleteConnectionId Connect.sId
11849>>>            
11849>>>            Move bTrust to Connect.bTrustedConnection
11850>>>            Move (If(bTrust,"",sUser))  to Connect.sUID
11851>>>            Move (If(bTrust,"",sPwd)) to Connect.sPWD
11852>>>            
11852>>>            Get AddConnection Connect.sDriver Connect.sId Connect.sString Connect.sUID Connect.sPWD Connect.bTrustedConnection Connect.sSection to iError
11853>>>        End
11853>>>>
11853>>>        Function_Return Connect
11854>>>    End_Function
11855>>>    
11855>>>    // attempt connection Id login using ID with passed credentials.
11855>>>    // These credentials will update the driver's map of connect Id/Connect strings.
11855>>>    // The Id must exist or errors
11855>>>    Function LoginConnectIdNewCredentials String sId String sUser String sPwd Boolean bTrust Returns Integer
11857>>>        Integer iError
11857>>>        tConnection Connect
11857>>>        tConnection Connect
11857>>>        Get ChangeConnectIdCredentials sId sUser sPwd bTrust to Connect
11858>>>        Get LoginConnectIdBase sId True to iError // silent
11859>>>        Function_Return iError
11860>>>    End_Function
11861>>>    
11861>>>    // Store credentials for Id. By default store in connections INI file, if used.
11861>>>    // Can be augmented or overridden
11861>>>    Function StoreConnectionIdCredentials String sId String sUID String sPWD Boolean bTrusted Returns Boolean
11863>>>        String sConnectPath
11863>>>        Handle hoIniFile
11863>>>        Boolean bUseConnectionIni
11863>>>        tConnection Connect
11863>>>        tConnection Connect
11863>>>        
11863>>>        Get pbUseConnectionIni to bUseConnectionIni
11864>>>        
11864>>>        If bUseConnectionIni Begin
11866>>>            
11866>>>            Get ConnectionIniFile to sConnectPath
11867>>>            If (sConnectPath="" or not(DoesFileExist(sConnectPath))) Begin
11869>>>                Function_Return True // empty is ok
11870>>>            End
11870>>>>
11870>>>            
11870>>>            Get ConnectionIdInfo sId to Connect
11871>>>            Get Create (RefClass(cIniFile)) to hoIniFile
11872>>>            Set psFilename of hoIniFile to sConnectPath
11873>>>            
11873>>>            If (sPWD<>"") Begin
11875>>>                Get EncryptPassword sPWD to sPWD
11876>>>            End
11876>>>>
11876>>>            
11876>>>            Send OnWriteCredentials Connect.sSection sId hoIniFile sUid sPWD bTrusted
11877>>>            
11877>>>            Send Destroy of hoIniFile
11878>>>        End
11878>>>>
11878>>>        Function_Return True
11879>>>    End_Function
11880>>>    
11880>>>    // logout of this managed connection id. If Id does not exist, do nothing
11880>>>    // note that logging out closes all tables for this connection
11880>>>    Procedure LogoutConnectionId String sId
11882>>>        Handle hoCli
11882>>>        String sDriver sServer
11882>>>        Get ConnectionIdCLIHandler sId to hoCLI
11883>>>        If hoCLI Begin
11885>>>            Get psDriverID of hoCli to sDriver
11886>>>            Get ConnectionIDServerString sId to sServer
11887>>>            Logout sDriver sServer
11888>>>        End
11888>>>>
11888>>>    End_Procedure
11889>>>    
11889>>>    // delete this managed connection id. If Id does not exist, do nothing
11889>>>    // if logged in raise a programming error.
11889>>>    Procedure DeleteConnectionId String sId
11891>>>        Handle hoCli
11891>>>        Integer iResult
11891>>>        Boolean bOk bLoggedIn
11891>>>        Get ConnectionIdCLIHandler sId to hoCli
11892>>>        If hoCLI Begin
11894>>>            // if the connection is logged in, this is an error. Precede this call with
11894>>>            // LogoutConnectionId. This is not done automatically so it is clear to the
11894>>>            // developer that they are logging out of existing connections, which closes
11894>>>            // open tables.
11894>>>            Get IsConnectionIdLoggedIn sId to bLoggedIn
11895>>>            If bLoggedIn Begin
11897>>>                Error DFERR_PROGRAM (SFormat("Connection ID '%1' is still logged-in and cannot be deleted",sId))
11898>>>>
11898>>>                Procedure_Return
11899>>>            End
11899>>>>
11899>>>            Get DeleteConnectionID of hoCli sId -1 to iResult
11900>>>            Get RemoveFromConnections sId to bOk
11901>>>        End
11901>>>>
11901>>>    End_Procedure
11902>>>    
11902>>>    
11902>>>    // login to all managed connection Ids for all drivers
11902>>>    // if error return false on first failure
11902>>>    Function LoginAllConnections Returns Boolean
11904>>>        tConnection[] ConnIds
11904>>>        tConnection[] ConnIds
11905>>>        Integer i iResult
11905>>>        Get ConnectionIDs to ConnIds
11906>>>        For i from 0 to (SizeOfArray(ConnIds)-1)
11912>>>>
11912>>>            Get LoginConnectionId ConnIds[i].sId to iResult
11913>>>            If (iResult) Begin
11915>>>                Function_Return False
11916>>>            End
11916>>>>
11916>>>        Loop
11917>>>>
11917>>>        Function_Return True
11918>>>    End_Function
11919>>>    
11919>>>    // logout of all managed connections for all drivers
11919>>>    Procedure LogoutAllConnections
11921>>>        tConnection[] ConnIds
11921>>>        tConnection[] ConnIds
11922>>>        Integer i
11922>>>        Get ConnectionIDs to ConnIds
11923>>>        For i from 0 to (SizeOfArray(ConnIds)-1)
11929>>>>
11929>>>            Send LogoutConnectionId ConnIds[i].sId
11930>>>        Loop
11931>>>>
11931>>>    End_Procedure
11932>>>    
11932>>>    // "unregister" all managed connections for all drivers
11932>>>    // Logout and then delete the connection. Note there is no DeleteAllConnections
11932>>>    // because you will always want to logout and delete in a single step.
11932>>>    Procedure UnRegisterAllConnections
11934>>>        tConnection[] ConnIds
11934>>>        tConnection[] ConnIds
11935>>>        Integer i
11935>>>        Get ConnectionIDs to ConnIds
11936>>>        For i from 0 to (SizeOfArray(ConnIds)-1)
11942>>>>
11942>>>            Send LogoutConnectionId ConnIds[i].sId
11943>>>            Send DeleteConnectionId ConnIds[i].sId
11944>>>        Loop
11945>>>>
11945>>>    End_Procedure
11946>>>    
11946>>>    // you can redefine a connection-string for a logged in server and all open tables will get
11946>>>    // redirected to the new connection. You can choose to leave the old connection open so if you switch back
11946>>>    // it can be done quickly.
11946>>>    // This assumes that two servers contain the same tables with the same definitions. If they don't things
11946>>>    // will not work. It is the developer's responsibility to make sure this is the case.
11946>>>    // Use with care.
11946>>>    Function RedirectConnectionId String sId String sServer String sUID String sPWD Boolean bTrusted Boolean bKeepOpen Returns Boolean
11948>>>        Handle hoCli
11948>>>        Integer iIndex iRet
11948>>>        tConnection[] Connections
11948>>>        tConnection[] Connections
11949>>>        tConnection Connection
11949>>>        tConnection Connection
11949>>>        String sConnectString
11949>>>        
11949>>>        Get ConnectionIdIndex sId to iIndex
11950>>>        If (iIndex=-1) Begin
11952>>>            Error DFERR_PROGRAM (SFormat(C_$ConnectionIdNotFound,sId))
11953>>>>
11953>>>            Function_Return 1
11954>>>        End
11954>>>>
11954>>>        
11954>>>        Get ConnectionIdCLIHandler sId to hoCli
11955>>>        Get pConnections to Connections
11956>>>        Move Connections[iIndex] to Connection
11957>>>        
11957>>>        Get AssembleConnectionString sServer sUID sPWD bTrusted to sConnectString
11958>>>        Move sServer to Connection.sString
11959>>>        Move sUID to Connection.sUID
11960>>>        Move sPWD to Connection.sPWD
11961>>>        Move bTrusted to Connection.bTrustedConnection
11962>>>        Move sConnectString to Connection.sConnectionString
11963>>>        Get ConnectionIDServerString sId to sId
11964>>>        
11964>>>        Send TrapErrors
11965>>>        Get RedirectIdConnectString of hoCli sId sConnectString bKeepOpen to iRet
11966>>>        Send UnTrapErrors
11967>>>        // if 1, we have the ID but it must not be not logged-in. We can still
11967>>>        // switch to the non-logged in connection
11967>>>        If (iRet=0 or iRet=1) Begin
11969>>>            // if all is ok, update the connection info
11969>>>            Move Connection to Connections[iIndex]
11970>>>            Set pConnections to Connections
11971>>>            Move 0 to iRet
11972>>>            Set piErrorNumber to 0
11973>>>        End
11973>>>>
11973>>>        Function_Return (iRet=0)
11974>>>    End_Function
11975>>>    
11975>>>    // This gets sent when a mangaged driver is registerd (it might already be loaded).
11975>>>    // Can be used to set CLI driver settings like use-cache etc.
11975>>>    Procedure OnDriverRegistered String sDriver Integer iDriver Handle hoCLIHandler
11977>>>    End_Procedure
11978>>>    
11978>>>    
11978>>>    // this can be used to do whatever you want to the various connection
11978>>>    // info. You might use this to handle your own default UID/PWD enoding logic
11978>>>    // etc.
11978>>>    Procedure OnAddConnection tConnection ByRef Connection
11980>>>    End_Procedure
11981>>>    
11981>>>    Function WriteConnectionsIniString Handle hoIniFile String sSection String sKey String sValue Returns Integer
11983>>>        Integer iErrorNumber
11983>>>        Send TrapErrors
11984>>>        Send WriteString of hoIniFile sSection sKey sValue
11985>>>        Send UnTrapErrors
11986>>>        Get piErrorNumber to iErrorNumber
11987>>>        Function_Return iErrorNumber
11988>>>    End_Function
11989>>>    
11989>>>    // update the connections ini file with passed Ids. Note that the section name
11989>>>    // for each ID is not the name that will be written. It exists if this was the
11989>>>    // initial section name.
11989>>>    Function WriteConnectionsIni String sQFile tConnection[] Ids Returns Boolean
11991>>>        Integer i iErrorNumber iIndex iSec iSections
11991>>>        String  sDriver sValue sPWD sSection
11991>>>        Handle hoIniFile hoArray hoSection
11991>>>        Boolean bOk bExists
11991>>>        String[] Keys Values
11993>>>        tConnectionIniSection[] Sections
11993>>>        tConnectionIniSection[] Sections
11994>>>        tConnectionIniSection SectionTarget
11994>>>        tConnectionIniSection SectionTarget
11994>>>        
11994>>>        // if filename not passed, use the default
11994>>>        If (sQFile="") Begin
11996>>>            Get ConnectionIniFile of ghoConnection to sQFile
11997>>>        End
11997>>>>
11997>>>        
11997>>>        Get Create (RefClass(cIniFile)) to hoIniFile
11998>>>        Get Create (RefClass(Array)) to hoArray
11999>>>        Get Create (RefClass(Array)) to hoSection
12000>>>        Set psFilename of hoIniFile to sQFile
12001>>>        
12001>>>        // first save off all info from an existing section name. This section may get
12001>>>        // renamed but we want to write it out later under that new section name. Hence
12001>>>        // we must store all values.
12001>>>        For i from 0 to (SizeOfArray(Ids)-1)
12007>>>>
12007>>>            If (Ids[i].sSection<>"") Begin
12009>>>                Get SectionExists of hoIniFile Ids[i].sSection to bExists
12010>>>                If bExists Begin
12012>>>                    Move (Lowercase(Ids[i].sSection)) to sSection
12013>>>                    Move sSection to Sections[iSections].sSection
12014>>>                    Send Delete_Data of hoSection
12015>>>                    Send ReadSection of hoIniFile sSection hoSection
12016>>>                    For iSec from 0 to (Item_Count(hoSection)-1)
12022>>>>
12022>>>                        Get Value of hoSection iSec to Sections[iSections].Keys[iSec]
12023>>>                        Get ReadString of hoIniFile sSection Sections[iSections].Keys[iSec] "" to Sections[iSections].Values[iSec]
12024>>>                    Loop
12025>>>>
12025>>>                    Increment iSections
12026>>>                End
12026>>>>
12026>>>            End
12026>>>>
12026>>>        Loop
12027>>>>
12027>>>        
12027>>>        // Now remove all existing connection sections
12027>>>        Send ReadSections of hoIniFile hoArray
12028>>>        For i from 0 to (Item_Count(hoArray) -1)
12034>>>>
12034>>>            Get Value of hoArray i to sSection
12035>>>            Move (Trim(sSection)) to sSection
12036>>>            If (Pos(Uppercase(C_ConnectionIniSectionBaseName),Uppercase(sSection))=1) Begin
12038>>>                Send DeleteSection of hoIniFile sSection
12039>>>            End
12039>>>>
12039>>>            If (iErrorNumber<>0) ;                Break
12042>>>        Loop
12043>>>>
12043>>>        
12043>>>        // now write the new connections, with each connection renamed.
12043>>>        For i from 0 to (SizeOfArray(Ids)-1)
12049>>>>
12049>>>            Move (C_ConnectionIniSectionBaseName+String(i+1)) to sSection
12050>>>            
12050>>>            // if the section already existed, write all existing data back under what
12050>>>            // might be a new section name. Some of this may get overridden below
12050>>>            Move (Lowercase(Ids[i].sSection)) to SectionTarget.sSection
12051>>>            Move (SearchArray(SectionTarget,Sections)) to iIndex
12052>>>            If (iIndex<>-1) Begin
12054>>>                For iSec from 0 to (SizeOfArray(Sections[iIndex].Keys)-1)
12060>>>>
12060>>>                    Get WriteConnectionsIniString hoIniFile sSection Sections[iIndex].Keys[iSec] Sections[iIndex].Values[iSec] to iErrorNumber
12061>>>                    If iErrorNumber ;                        Break
12064>>>                Loop
12065>>>>
12065>>>            End
12065>>>>
12065>>>            If iErrorNumber ;                Break
12068>>>            
12068>>>            // now write / overwrite new data
12068>>>            Get WriteConnectionsIniString hoIniFile sSection C_ConnectionIniSectionId Ids[i].sId to iErrorNumber
12069>>>            If iErrorNumber ;                Break
12072>>>            Get WriteConnectionsIniString hoIniFile sSection C_ConnectionIniSectionDriver Ids[i].sDriver to iErrorNumber
12073>>>            If iErrorNumber ;                Break
12076>>>            Get WriteConnectionsIniString hoIniFile sSection C_ConnectionIniSectionConnection Ids[i].sString to iErrorNumber
12077>>>            If iErrorNumber ;                Break
12080>>>
12080>>>            If (Ids[i].bDisabled) Begin
12082>>>                Get WriteConnectionsIniString hoIniFile sSection C_ConnectionIniSectionDisabled "yes" to iErrorNumber
12083>>>            End
12083>>>>
12083>>>            Else Begin
12084>>>                Send DeleteKey of hoIniFile sSection C_ConnectionIniSectionDisabled
12085>>>            End
12085>>>>
12085>>>            If iErrorNumber ;                Break
12088>>>
12088>>>            Move Ids[i].sPWD to sPWD
12089>>>            If (sPWD<>"") Begin
12091>>>                Get EncryptPassword sPWD to sPWD
12092>>>            End
12092>>>>
12092>>>            
12092>>>            Send OnWriteCredentials sSection Ids[i].sId hoIniFile Ids[i].sUID sPWD Ids[i].bTrustedConnection
12093>>>        Loop
12094>>>>
12094>>>        
12094>>>        Send Destroy of hoSection
12095>>>        Send Destroy of hoArray
12096>>>        Send Destroy of hoIniFile
12097>>>        Function_Return (iErrorNumber=0)
12098>>>    End_Function
12099>>>    
12099>>>    // creates an SQL Connection handler for SQL usage. It is up to you to destroy this
12099>>>    // by default it creates a cSQLConnection object. This can be augmented to create use
12099>>>    // a different class
12099>>>    Function CreateESQLConnectionHandler Returns Handle
12101>>>        Handle hoSQLConnection
12101>>>        Get CreateNamed (RefClass(cSQLConnection)) "oSQLConnectionHandler" to hoSQLConnection
12102>>>        Function_Return hoSQLConnection
12103>>>    End_Function
12104>>>    
12104>>>    // get a new ESQL connection handle for this connection Id.
12104>>>    // Programmer must destroy this handle when done
12104>>>    // Id must exist. Programming error if it does not
12104>>>    Function SQLConnectionId String sId Returns Handle
12106>>>        Handle hoSQLConnection hoCLI
12106>>>        Integer bOK
12106>>>        String sDrvrID sServer
12106>>>        
12106>>>        Get ConnectionIdCLIHandler sId to hoCLI
12107>>>        If hoCLI Begin
12109>>>            Get ConnectionIDServerString sId to sServer
12110>>>            Get psDriverID of hoCLI to sDrvrId
12111>>>            Get CreateESQLConnectionHandler to hoSQLConnection
12112>>>            
12112>>>            // force it to use existing connection
12112>>>            Get SQLConnectionConnect of hoSQLConnection sDrvrID sServer to bOK
12113>>>            
12113>>>            If (not(bOK)) Begin
12115>>>                Send DestroySQLConnection of hoSQLConnection
12116>>>                Move 0 to hoSQLConnection
12117>>>            End
12117>>>>
12117>>>        End
12117>>>>
12117>>>        Else Begin
12118>>>            Error DFERR_PROGRAM (SFormat(C_$ConnectionIdNotFound,sId))
12119>>>>
12119>>>        End
12119>>>>
12119>>>        Function_Return hoSQLConnection
12120>>>    End_Function
12121>>>    
12121>>>    // these are interfaces that do not require connection Ids. You can pass a
12121>>>    // driver and a server connect string. Generally there are ID versions of these
12121>>>    // that should be used when possible.
12121>>>    
12121>>>    // is this connection to a server logged in. Pass driver and connect string
12121>>>    // connect string should be INT style. Either full string or DFCONNID=xx
12121>>>    // if driver not loaded, raise an error
12121>>>    Function IsDriverConnectionLoggedIn String sDriver String sConnect Returns Boolean
12123>>>        Handle hConnectionHandle hoCLI
12123>>>        Integer iDriver
12123>>>        Get DriverCLIHandler sDriver to hoCLI
12124>>>        If (hoCLI) Begin
12126>>>            Get DriverIndex sDriver to iDriver
12127>>>            Get ServerDatabaseIdHandle sDriver iDriver sConnect to hConnectionHandle
12128>>>        End
12128>>>>
12128>>>        Else Begin
12129>>>            Error DFERR_PROGRAM (SFormat(C_$DriverNotFound,sDriver))
12130>>>>
12130>>>        End
12130>>>>
12130>>>        Function_Return (hConnectionHandle<>0)
12131>>>    End_Function
12132>>>    
12132>>>    // login to this managed connection via driver and connection string.
12132>>>    // Normally you'd not use this and use LoginConnectionId
12132>>>    // If pbSkipDuplicateLogin=T it will skip the login if it is already connected
12132>>>    // If driver not loaded, attempt to load it.
12132>>>    // If it cannot be loaded, raise a configuration Error
12132>>>    // This is low level - use carefully
12132>>>    Function LoginServer String sDriver String sConnectString String sUID String sPWD Boolean bSilent Returns Integer
12134>>>        Integer iResult iDriver
12134>>>        Handle hoCli
12134>>>        Boolean bSkipDup bConnected bOldSilent
12134>>>        Get RegisterDriver sDriver to hoCLI
12135>>>        If hoCli Begin
12137>>>            Get pbSkipDuplicateLogin to bSkipDup
12138>>>            If (bSkipDup) Begin
12140>>>                Get IsDriverConnectionLoggedIn sDriver sConnectString to bConnected
12141>>>            End
12141>>>>
12141>>>            If not bConnected Begin
12143>>>                Get DriverIndex sDriver to iDriver
12144>>>                // note that passing the server as dfconnid=Id will not recognize bSilent
12144>>>                Get_Attribute DF_DRIVER_SILENT_LOGIN of iDriver to bOldSilent
12147>>>                Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriver to bSilent
12150>>>                Get BasicLogin sDriver sConnectString sUID sPWD to iResult
12151>>>                Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriver to bOldSilent
12154>>>            End
12154>>>>
12154>>>        End
12154>>>>
12154>>>        Else Begin
12155>>>            // if driver cannot be loaded, an error will be raised in RegisterDriver
12155>>>            Move 1 to iResult
12156>>>        End
12156>>>>
12156>>>        Function_Return iResult
12157>>>    End_Function
12158>>>    
12158>>>    // can connect using any server connect string for this driver
12158>>>    // returns new  ESQL connection handler, which the developer must destroy.
12158>>>    Function SQLConnection String sDriver String sConnect Returns Handle
12160>>>        Handle hoSQLConnection
12160>>>        String sDrvrID
12160>>>        Handle hoCLI
12160>>>        Boolean bOk
12160>>>        
12160>>>        // will raise configuration error if driver cannot be loaded
12160>>>        Get RegisterDriver sDriver to hoCLI
12161>>>        If hoCli Begin
12163>>>            Get CreateESQLConnectionHandler to hoSQLConnection
12164>>>            
12164>>>            // force it to use existing connection
12164>>>            Get SQLConnectionConnect of hoSQLConnection sDriver sConnect to bOK
12165>>>            
12165>>>            If (not(bOK)) Begin
12167>>>                Send DestroySQLConnection of hoSQLConnection
12168>>>                Move 0 to hoSQLConnection
12169>>>            End
12169>>>>
12169>>>            
12169>>>        End
12169>>>>
12169>>>        Function_Return hoSQLConnection
12170>>>    End_Function
12171>>>    
12171>>>    // get a new ESQL connection handle for this open table. Programmer must
12171>>>    // destroy this handle when done
12171>>>    Function SQLConnectionByTable Handle hoTable Returns Handle
12173>>>        Handle hoSQLConnection
12173>>>        Boolean bOk
12173>>>        
12173>>>        Get CreateESQLConnectionHandler to hoSQLConnection
12174>>>        Get SQLFileConnect of hoSQLConnection hoTable to bOk
12175>>>        If (not(bOK)) Begin
12177>>>            Send DestroySQLConnection of hoSQLConnection
12178>>>            Move 0 to hoSQLConnection
12179>>>        End
12179>>>>
12179>>>        
12179>>>        Function_Return hoSQLConnection
12180>>>    End_Function
12181>>>    
12181>>>    // load all managed drivers and set up all managed connections. Abort if a failure
12181>>>    // if you don't want automatic abort, use RegisterAllDrivers and AddAllConnections
12181>>>    // This should succeed - if not it's a programming error
12181>>>    Procedure RegisterAllConnections
12183>>>        Boolean bOk
12183>>>        Get AddAllConnections to bOk
12184>>>        If not bOk Begin
12186>>>            Send UserError "Could not load and register managed drivers. The application cannot be run"
12187>>>            Abort
12188>>>>
12188>>>        End
12188>>>>
12188>>>    End_Procedure
12189>>>    
12189>>>    // Login to all managed connections in all managed drivers. Abort if any fail
12189>>>    // if you don't want automatic abort, use the function LoginAllConnections or
12189>>>    // LoginConnectionId
12189>>>    Procedure LoginAll
12191>>>        Boolean bOk
12191>>>        Integer iError
12191>>>        String sError
12191>>>        Get LoginAllConnections to bOk
12192>>>        If not bOk Begin
12194>>>            Get psErrorText to sError
12195>>>            Get piErrorNumber to iError
12196>>>            Send UserError (C_$LoginAllFailedWillAbort + "\n\n" + sError)
12197>>>            Abort
12198>>>>
12198>>>        End
12198>>>>
12198>>>    End_Procedure
12199>>>    
12199>>>    // Standard Auto-connect behavior.
12199>>>    // if pbAutoConnect is T it does a registerAll & LoginAll and aborts if an error occurs
12199>>>    // if pbAutoConnect is F, it does nothing.
12199>>>    // Note that RegisterAll and LoginIn don't do anything if managed connections are not used.
12199>>>    // This is called by cApplication when a workspace is opened.
12199>>>    Procedure AutoConnect
12201>>>        Boolean bAutoConnect
12201>>>        Get pbAutoConnect to bAutoConnect
12202>>>        If bAutoConnect Begin
12204>>>            Send RegisterAllConnections // might abort on failure
12205>>>            Send LoginAll // might abort on failure
12206>>>        End
12206>>>>
12206>>>    End_Procedure
12207>>>    
12207>>>    // This is called by cApplication when a workspace is opened.
12207>>>    Procedure AutoDisconnect
12209>>>        Boolean bAutoConnect
12209>>>        Get pbAutoConnect to bAutoConnect
12210>>>        If bAutoConnect Begin
12212>>>            Send UnRegisterAllConnections
12213>>>        End
12213>>>>
12213>>>    End_Procedure
12214>>>    
12214>>>    // EnumerateConnections:
12214>>>    // List the current registered connection ids.
12214>>>    //
12214>>>    Procedure EnumerateConnections Handle hoCallBack Handle hmGeneric
12216>>>        tConnection[] ConnIds
12216>>>        tConnection[] ConnIds
12217>>>        Integer i iConnIds
12217>>>        String sConnectionsIni
12217>>>        
12217>>>        Get ConnectionIniFile to sConnectionsIni
12218>>>        
12218>>>        Send hmGeneric of hoCallBack C_$ManagedConnections
12219>>>        Send hmGeneric of hoCallBack (SFormat(C_$ManagedConnectionsIniFile, ConnectionIniFile(Self)))
12220>>>        
12220>>>        Get ConnectionIDs to ConnIds
12221>>>        Move (SizeOfArray(ConnIds)) to iConnIds
12222>>>        If (iConnIds=0) Begin
12224>>>            Send hmGeneric of hoCallBack C_$ManagedConnectionsNone
12225>>>        End
12225>>>>
12225>>>        Else Begin
12226>>>            For i from 0 to (iConnIds-1)
12232>>>>
12232>>>                Send hmGeneric of hoCallBack (SFormat(C_$ManagedConnectionsIdLine, ConnIds[i].sId, ConnIds[i].sString, ConnIds[i].sDriver))
12233>>>            Loop
12234>>>>
12234>>>        End
12234>>>>
12234>>>    End_Procedure
12235>>>    
12235>>>End_Class
12236>
12236>Use seq_chnl.pkg
12236>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\gFormatNumbers.pkg)
12236>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cFormatter.pkg)
12236>>>>>Use VDFBase.pkg
12236>>>>>
12236>>>>>Class cFormatter is an cObject
12237>>>>>    
12237>>>>>    Procedure Construct_object
12239>>>>>        Integer iCh
12239>>>>>        Forward Send construct_object
12241>>>>>        Property String  psCurrencySymbol
12242>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
12243>>>>>        
12243>>>>>        Property String  psLeft
12244>>>>>        Property String  psright
12245>>>>>        Property Integer pbThousandsSep
12246>>>>>        Property Integer piPoints
12247>>>>>        
12247>>>>>        Property String  psCurPosLeft
12248>>>>>        Property String  psCurPosright
12249>>>>>        Property Integer pbCurPosThousandsSep
12250>>>>>        Property Integer piCurPosPoints
12251>>>>>        
12251>>>>>        Property String  psCurNegLeft
12252>>>>>        Property String  psCurNegright
12253>>>>>        Property Integer pbCurNegThousandsSep
12254>>>>>        Property Integer piCurNegPoints
12255>>>>>        
12255>>>>>        Property String  psNumPosLeft
12256>>>>>        Property String  psNumPosright
12257>>>>>        Property Integer pbNumPosThousandsSep
12258>>>>>        Property Integer piNumPosPoints
12259>>>>>        
12259>>>>>        Property String  psNumNegLeft
12260>>>>>        Property String  psNumNegright
12261>>>>>        Property Integer pbNumNegThousandsSep
12262>>>>>        Property Integer piNumNegPoints
12263>>>>>        
12263>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
12264>>>>>        Send SetFormat  ",#.*"           False // numeric
12265>>>>>        
12265>>>>>    End_Procedure
12266>>>>>    
12266>>>>>    // internal
12266>>>>>    // parse passed format string and set temporary properties with result
12266>>>>>    Procedure ParseFormat String sFmt
12268>>>>>        
12268>>>>>        String sLeft sRight sDigit
12268>>>>>        Integer bSep iPos i iDigits
12268>>>>>        
12268>>>>>        // replace any literals. A "/" followed by anything.
12268>>>>>        // some literals are special. $ . , / #
12268>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
12269>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
12270>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
12271>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
12272>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
12273>>>>>        Move (Character(9)) to sDigit
12274>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
12275>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
12276>>>>>        
12276>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
12277>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
12280>>>>>        
12280>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
12281>>>>>        
12281>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
12282>>>>>        
12282>>>>>        // Move all the special literals back into place before parsing
12282>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
12283>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
12284>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
12285>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
12286>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
12287>>>>>        
12287>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
12289>>>>>            Move 1 to i                        // look for first non # to right and count the #s
12290>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
12292>>>>>                Move -2 to iDigits
12293>>>>>                Increment i
12294>>>>>            End
12294>>>>>>
12294>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
12298>>>>>                Increment i
12299>>>>>            Loop
12300>>>>>>
12300>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
12301>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
12304>>>>>            //
12304>>>>>            Move 1 to i                           // find the first non-# to the left of the point
12305>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
12309>>>>>                Increment i
12310>>>>>            Loop
12311>>>>>>
12311>>>>>            Move (left(sFmt,iPos-i)) to sLeft
12312>>>>>        End
12312>>>>>>
12312>>>>>        Else Begin                             // we have no decinal
12313>>>>>            Move 0 to iDigits                  // so points is none
12314>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
12315>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
12317>>>>>                Move sFmt to sLeft
12318>>>>>                Move ""   to sRight
12319>>>>>            End
12319>>>>>>
12319>>>>>            Else Begin
12320>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
12321>>>>>                Move 1 to i
12322>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
12326>>>>>                    Increment i
12327>>>>>                Loop
12328>>>>>>
12328>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
12329>>>>>            End
12329>>>>>>
12329>>>>>        End
12329>>>>>>
12329>>>>>        // set temporary format properties and exit
12329>>>>>        Set pbThousandsSep to bSep
12330>>>>>        Set psLeft         to sLeft
12331>>>>>        Set psRight        to sRight
12332>>>>>        Set piPoints       to iDigits
12333>>>>>    End_Procedure
12334>>>>>    
12334>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
12334>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
12334>>>>>    //
12334>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
12334>>>>>    Procedure SetFormat String sFmt Integer bCurrency
12336>>>>>        String sPos sNeg
12336>>>>>        Integer iPos
12336>>>>>        
12336>>>>>        Move (Pos(";",sFmt)) to iPos
12337>>>>>        If iPos Begin
12339>>>>>            Move (left(sFmt,iPos-1))    to sPos
12340>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
12341>>>>>        End
12341>>>>>>
12341>>>>>        Else Begin
12342>>>>>            Move sFmt         to sPos
12343>>>>>            Move ("-" + sFmt) to sNeg
12344>>>>>        End
12344>>>>>>
12344>>>>>        Send ParseFormat sPos
12345>>>>>        If bCurrency Begin
12347>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
12348>>>>>            Set psCurPosLeft         to (psLeft(Self))
12349>>>>>            Set psCurPosRight        to (psRight(Self))
12350>>>>>            Set piCurPosPoints       to (piPoints(Self))
12351>>>>>        End
12351>>>>>>
12351>>>>>        Else Begin
12352>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
12353>>>>>            Set psNumPosLeft         to (psLeft(Self))
12354>>>>>            Set psNumPosRight        to (psRight(Self))
12355>>>>>            Set piNumPosPoints       to (piPoints(Self))
12356>>>>>        End
12356>>>>>>
12356>>>>>        
12356>>>>>        Send ParseFormat sNeg
12357>>>>>        If bCurrency Begin
12359>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
12360>>>>>            Set psCurNegLeft         to (psLeft(Self))
12361>>>>>            Set psCurNegRight        to (psRight(Self))
12362>>>>>            Set piCurNegPoints       to (piPoints(Self))
12363>>>>>        End
12363>>>>>>
12363>>>>>        Else Begin
12364>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
12365>>>>>            Set psNumNegLeft         to (psLeft(Self))
12366>>>>>            Set psNumNegRight        to (psRight(Self))
12367>>>>>            Set piNumNegPoints       to (piPoints(Self))
12368>>>>>        End
12368>>>>>>
12368>>>>>    End_Procedure
12369>>>>>    
12369>>>>>    // low level formatting. Pass parameters
12369>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
12371>>>>>        String  sLeft sRight sNumber sSep sDec
12371>>>>>        Integer bIsNegative iDec iLen iCh
12371>>>>>        
12371>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
12374>>>>>        Move (Character(iCh)) to sDec
12375>>>>>        
12375>>>>>        Move (abs(nNumber)) to sNumber
12376>>>>>        Move (Pos(sDec,sNumber)) to iDec
12377>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
12378>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
12379>>>>>        // format for decimal separator
12379>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
12382>>>>>        
12382>>>>>        // format for thousand sep.
12382>>>>>        If bSep Begin
12384>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
12387>>>>>            Move (Character(iCh)) to sSep
12388>>>>>            Move (Length(sLeft)) to iLen
12389>>>>>            While (iLen>3)
12393>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
12394>>>>>                Move (iLen-3) to iLen
12395>>>>>            Loop
12396>>>>>>
12396>>>>>        End
12396>>>>>>
12396>>>>>        // if decimal points or -2 (allow anything) and there are points to show
12396>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
12399>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
12400>>>>>    End_Function
12401>>>>>    
12401>>>>>    // Public: Format for currency
12401>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
12403>>>>>        String  sLeft sRight
12403>>>>>        Integer bSep
12403>>>>>        If (nNumber<0) Begin
12405>>>>>            Get pbCurNegThousandsSep to bSep
12406>>>>>            Get psCurNegLeft         to sLeft
12407>>>>>            Get psCurNegRight        to sRight
12408>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
12411>>>>>        End
12411>>>>>>
12411>>>>>        Else Begin
12412>>>>>            Get pbCurPosThousandsSep to bSep
12413>>>>>            Get psCurPosLeft         to sLeft
12414>>>>>            Get psCurPosRight        to sRight
12415>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
12418>>>>>        End
12418>>>>>>
12418>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
12419>>>>>    End_Function
12420>>>>>    
12420>>>>>    // Public: Format for numeric
12420>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
12422>>>>>        String  sLeft sRight
12422>>>>>        Integer bSep
12422>>>>>        If (nNumber<0) Begin
12424>>>>>            Get pbNumNegThousandsSep to bSep
12425>>>>>            Get psNumNegLeft         to sLeft
12426>>>>>            Get psNumNegRight        to sRight
12427>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
12430>>>>>        End
12430>>>>>>
12430>>>>>        Else Begin
12431>>>>>            Get pbNumPosThousandsSep to bSep
12432>>>>>            Get psNumPosLeft         to sLeft
12433>>>>>            Get psNumPosRight        to sRight
12434>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
12437>>>>>        End
12437>>>>>>
12437>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
12438>>>>>    End_Function
12439>>>>>    
12439>>>>>    
12439>>>>>    // Public: Format passing format string
12439>>>>>    Function FormatVal Number nNumber String sFmt Returns String
12441>>>>>        Integer iPos bIsNeg
12441>>>>>        String  sLeft sRight
12441>>>>>        Integer iPoints bSep
12441>>>>>        Move (nNumber<0) to bIsNeg
12442>>>>>        Move (Pos(";",sFmt)) to iPos
12443>>>>>        Case Begin
12443>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
12446>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
12450>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
12454>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
12456>>>>>        Case End
12456>>>>>        Send ParseFormat sFmt
12457>>>>>        Get pbThousandsSep to bSep
12458>>>>>        Get psLeft         to sLeft
12459>>>>>        Get psRight        to sRight
12460>>>>>        Get piPoints       to iPoints
12461>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
12462>>>>>    End_Function
12463>>>>>    
12463>>>>>End_Class
12464>>>
12464>>>Global_Variable Handle ghoFormatter
12464>>>Get Create of desktop U_cFormatter to ghoFormatter
12465>>>
12465>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
12467>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
12468>>>End_Function
12469>>>
12469>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
12471>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
12472>>>End_Function
12473>>>
12473>>>Function FormatValue Global Number nNum String sFmt Returns String
12475>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
12476>>>End_Function
12477>>>
12477>>>Procedure SetCurrencyFormat Global String sFmt
12479>>>    Send SetFormat of ghoFormatter sFmt True
12480>>>End_Procedure
12481>>>
12481>>>Procedure SetNumberFormat Global String sFmt
12483>>>    Send SetFormat of ghoFormatter sFmt False
12484>>>End_Procedure
12485>>>
12485>>>
12485>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\db2_drv.pkg)
12485>>>// DB2_DRV.PKG                                                          
12485>>>//   Package that declares DB2 driver constants and functions.          
12485>>>//   This package can be used by developers who want to add DB2 driver  
12485>>>//   specific code to a DataFlex application.                           
12485>>>
12485>>>Use Cli.pkg
12485>>>
12485>>>// Driver attributes
12485>>>
12485>>>
12485>>>// Driver Indentification
12485>>>
12485>>>// Error number constants
12485>>>
12485>>>// Call driver function identifiers
12485>>>
12485>>>// DB2 specific data types
12485>>>Define SQL_CLOB           for   (-99)
12485>>>Define SQL_BLOB           for   (-98)
12485>>>Define SQL_XML            for   (-370)
12485>>>// DB2 Graphic types are Unicode types
12485>>>Define SQL_GRAPHIC        for   (-95)
12485>>>Define SQL_VARGRAPHIC     for   (-96)
12485>>>Define SQL_LONGVARGRAPHIC for   (-97)
12485>>>Define SQL_DBCLOB         for   (-350)
12485>>>
12485>>>
12485>>>// Extra DB2 commands
12485>>>
12485>>>
12485>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
12485>>>//   Setup a constraint for a file.                                     
12485>>>
12485>>>
12485>>>
12485>>>Class cDB2Handler is a cCLIHandler
12486>>>    
12486>>>    Procedure Construct_Object
12488>>>        Forward Send Construct_Object
12490>>>        
12490>>>        Set psDriverID to DB2_DRV_ID
12491>>>    End_Procedure
12492>>>    
12492>>>    
12492>>>    
12492>>>    // Reset the datasource list to the beginning
12492>>>    Procedure SeedDataSources
12494>>>        String  sDriver
12494>>>        String  sVoid
12494>>>        Integer iRetval
12494>>>        
12494>>>        Get psDriverID to sDriver
12495>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
12502>>>    End_Procedure
12503>>>    
12503>>>    
12503>>>    
12503>>>    // Call the driver's data sources function
12503>>>    Function DataSources Returns String
12505>>>        String  sDriver
12505>>>        String  sDataSource
12505>>>        String  sDescription
12505>>>        Integer iLength
12505>>>        Integer iRetval
12505>>>        
12505>>>        Get psDriverID to sDriver
12506>>>        If (sDriver <> "") Begin
12508>>>            Move 8192 to iLength
12509>>>            Move (Repeat(" ", iLength)) to sDataSource
12510>>>            Move (Repeat(" ", iLength)) to sDescription
12511>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
12516>>>        End
12516>>>>
12516>>>        
12516>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
12519>>>        Else ;            Function_Return ""
12521>>>    End_Function
12522>>>    
12522>>>End_Class
12523>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\MSSqldrv.pkg)
12523>>>//     Package that declares MS SQL driver constants and functions.
12523>>>//     This package can be used by developers who want to add Data Access
12523>>>//     MS SQL Client specific code to a DataFlex application.
12523>>>
12523>>>Use Cli.pkg
12523>>>Use SQL.pkg
12523>>>
12523>>>//   Driver Indentification
12523>>>
12523>>>//   Error number constants
12523>>>
12523>>>
12523>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
12523>>>
12523>>>
12523>>>
12523>>>
12523>>>
12523>>>
12523>>>// SQL Server spcific types.
12523>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
12523>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
12523>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
12523>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
12523>>>
12523>>>// SQL Server spcific types.
12523>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
12523>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
12523>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
12523>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
12523>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
12523>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
12523>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
12523>>>
12523>>>
12523>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
12523>>>//
12523>>>//     Setup a constraint for a file.
12523>>>
12523>>>
12523>>>Class cMSSQLHandler is a cCLIHandler
12524>>>    
12524>>>    Procedure Construct_Object
12526>>>        Forward Send Construct_Object
12528>>>        
12528>>>        Set psDriverID to MSSQLDRV_ID
12529>>>    End_Procedure
12530>>>    
12530>>>    
12530>>>    
12530>>>    //   Extract the list from the out connect string.
12530>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
12532>>>        String  sItem
12532>>>        Integer iStart
12532>>>        Integer iEnd
12532>>>        
12532>>>        If (hoStore = 0) ;            Move Current_object to hoStore
12535>>>        
12535>>>        Send Delete_Data to hoStore
12536>>>        Move (Pos("{", sOutConnStr)) to iStart
12537>>>        While (iStart > 0)
12541>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
12542>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
12545>>>            Else Begin
12546>>>                Move (Pos(",", sOutConnStr)) to iStart
12547>>>                Move (Pos("}", sOutConnStr)) to iEnd
12548>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
12551>>>                
12551>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
12554>>>                
12554>>>                If (iStart = iEnd) ;                    Move 0 to iStart
12557>>>            End
12557>>>>
12557>>>        Loop
12558>>>>
12558>>>        
12558>>>        Function_Return (Item_Count(hoStore))
12559>>>    End_Function
12560>>>    
12560>>>    
12560>>>    
12560>>>    //   Call the driver's browse connect function
12560>>>    Function BrowseConnect String sInConnStr Returns String
12562>>>        String  sDriver
12562>>>        String  sOutConnStr
12562>>>        Integer iArg
12562>>>        Integer iRetval
12562>>>        
12562>>>        Get psDriverID to sDriver
12563>>>        If (sDriver <> "") Begin
12565>>>            Move (Repeat(" ", 8192)) to sOutConnStr
12566>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
12571>>>        End
12571>>>>
12571>>>        
12571>>>        Function_Return sOutConnStr
12572>>>    End_Function// BrowseConnect
12573>>>    
12573>>>    
12573>>>    Function BrowseConnectLocal String sInConnStr Returns String
12575>>>        String  sDriver
12575>>>        String  sOutConnStr
12575>>>        Integer iArg
12575>>>        Integer iRetval
12575>>>        
12575>>>        Move 1 to iArg // Browses only local
12576>>>        
12576>>>        Get psDriverID to sDriver
12577>>>        If (sDriver <> "") Begin
12579>>>            Move (Repeat(" ", 8192)) to sOutConnStr
12580>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
12585>>>        End
12585>>>>
12585>>>        
12585>>>        Function_Return sOutConnStr
12586>>>    End_Function// BrowseConnect
12587>>>    
12587>>>    
12587>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
12589>>>        
12589>>>        String  sServerList
12589>>>        Integer iNumServers
12589>>>        Integer iDriver
12589>>>        Integer iClientVersion
12589>>>        String  sDriver
12589>>>        
12589>>>        Get DriverIndex MSSQLDRV_ID to iDriver
12590>>>        
12590>>>        If (iDriver) Begin
12592>>>            
12592>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
12595>>>            
12595>>>            Get SqlServerClientDriverName iClientVersion to sDriver
12596>>>            
12596>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
12597>>>            If (iNetworkLocal = 0) Begin
12599>>>                Get BrowseConnect sDriver to sServerList
12600>>>            End
12600>>>>
12600>>>            Else Begin
12601>>>                Get BrowseConnectLocal sDriver to sServerList
12602>>>            End
12602>>>>
12602>>>            Get ExtractList sServerList Current_object to iNumServers
12603>>>        End
12603>>>>
12603>>>        
12603>>>        Function_Return iNumServers
12604>>>        
12604>>>    End_Function
12605>>>    
12605>>>    //   Enumerate the available SQL Server database servers
12605>>>    //   This function will return all SQL Server instances on the network.
12605>>>    //   This may take a long time.
12605>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
12605>>>    Function EnumerateServers Returns Integer
12607>>>        
12607>>>        Integer iNumServers
12607>>>        Integer iNetworkLocal
12607>>>        
12607>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
12608>>>        
12608>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
12609>>>        
12609>>>        Function_Return iNumServers
12610>>>        
12610>>>    End_Function
12611>>>    
12611>>>    
12611>>>    //   Enumerate the available SQL Server database servers
12611>>>    //   This function will return only return SQL Server instance on the local machine
12611>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
12611>>>    Function EnumerateServersLocal Returns Integer
12613>>>        
12613>>>        Integer iNumServers
12613>>>        Integer iNetworkLocal
12613>>>        
12613>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
12614>>>        
12614>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
12615>>>        
12615>>>        Function_Return iNumServers
12616>>>        
12616>>>    End_Function
12617>>>    
12617>>>    
12617>>>    
12617>>>    //   Enumerate database in a given server.
12617>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
12619>>>        Integer hoSQL
12619>>>        String  sConnect
12619>>>        String  sDatabase
12619>>>        Integer hdbc
12619>>>        Integer hstmt
12619>>>        Integer iFetchResult
12619>>>        
12619>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
12622>>>        If (Num_Arguments < 2) ;            Move "" to sUser
12625>>>        
12625>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
12628>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
12630>>>        
12630>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
12632>>>            Move Current_Object to hoSQL
12633>>>        End_Object
12634>>>        
12634>>>        If (hoSQL <> 0) Begin
12636>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
12637>>>            If (hdbc <> 0) Begin
12639>>>                Get SQLOpen of hdbc to hstmt
12640>>>                If (hstmt <> 0) Begin
12642>>>                    //   We could do a direct select on the sysdatabases table but we use
12642>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
12642>>>                    //   approach in case meta data might change, the stored procedure will
12642>>>                    //   stay the same.
12642>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
12643>>>                    Send SQLCall to hstmt
12644>>>                    Repeat
12644>>>>
12644>>>                        Get SQLFetch of hstmt to iFetchResult
12645>>>                        If (iFetchResult <> 0) Begin
12647>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
12648>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
12649>>>                        End
12649>>>>
12649>>>                    Until (iFetchResult = 0)
12651>>>                    
12651>>>                    Send SQLClose to hstmt
12652>>>                End
12652>>>>
12652>>>                Send SQLDisconnect to hdbc
12653>>>            End
12653>>>>
12653>>>        End
12653>>>>
12653>>>        Send Destroy_Object to hoSQL
12654>>>        
12654>>>        Function_Return (Item_Count(Current_Object))
12655>>>    End_Function
12656>>>    
12656>>>    
12656>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
12658>>>        
12658>>>        String  sSqlServerClientVersionName
12658>>>        
12658>>>        
12658>>>        Case Begin
12658>>>            
12658>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
12660>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
12661>>>                Case Break
12662>>>                
12662>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
12665>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
12666>>>                Case Break
12667>>>            
12667>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
12670>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
12671>>>                Case Break
12672>>>            
12672>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
12675>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
12676>>>                Case Break
12677>>>            
12677>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
12680>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
12681>>>                Case Break
12682>>>            
12682>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
12685>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
12686>>>                Case Break
12687>>>            
12687>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
12690>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
12691>>>                Case Break
12692>>>            
12692>>>            Case Else
12692>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
12693>>>                
12693>>>        Case End
12693>>>        
12693>>>        
12693>>>        Function_Return sSqlServerClientVersionName
12694>>>        
12694>>>    End_Function
12695>>>
12695>>>
12695>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
12697>>>        
12697>>>        String  sSqlServerClientDriverName
12697>>>        
12697>>>        Case Begin
12697>>>            
12697>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
12699>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
12700>>>                Case Break
12701>>>                
12701>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
12704>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
12705>>>                Case Break
12706>>>            
12706>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
12709>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
12710>>>                Case Break
12711>>>            
12711>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
12714>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
12715>>>                Case Break
12716>>>            
12716>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
12719>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
12720>>>                Case Break
12721>>>            
12721>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
12724>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
12725>>>                Case Break
12726>>>            
12726>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
12729>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
12730>>>                Case Break
12731>>>            
12731>>>            Case Else
12731>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
12732>>>                
12732>>>        Case End
12732>>>        
12732>>>        
12732>>>        Function_Return sSqlServerClientDriverName
12733>>>        
12733>>>    End_Function
12734>>>    
12734>>>    
12734>>>End_Class
12735>>>
12735>>>
12735>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\odbc_drv.pkg)
12735>>>//   Package that declares ODBC driver constants and functions.         
12735>>>//   This package can be used by developers who want to add Data Access 
12735>>>//   ODBC Client specific code to a DataFlex application.               
12735>>>
12735>>>Use Cli.pkg
12735>>>
12735>>>// Driver Indentification
12735>>>
12735>>>// Error number constants
12735>>>
12735>>>// Call driver function identifiers
12735>>>
12735>>>Class cODBCHandler is a cCLIHandler
12736>>>    
12736>>>    Procedure Construct_Object
12738>>>        Forward Send Construct_Object
12740>>>        
12740>>>        Set psDriverID to ODBC_DRV_ID
12741>>>    End_Procedure
12742>>>    
12742>>>    
12742>>>    
12742>>>    // Setup the type of data sources returned by the datasources function
12742>>>    Procedure Set DataSourceType Integer iNewType
12744>>>        String  sDriver
12744>>>        String  sVoid
12744>>>        Integer iRetval
12744>>>        
12744>>>        Get psDriverID to sDriver
12745>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
12752>>>    End_Procedure
12753>>>    
12753>>>    
12753>>>    // Call the driver's data sources function
12753>>>    Function DataSources Returns String
12755>>>        String  sDriver
12755>>>        String  sDataSource
12755>>>        String  sDescription
12755>>>        Integer iLength
12755>>>        Integer iRetval
12755>>>        
12755>>>        Get psDriverID to sDriver
12756>>>        If (sDriver <> "") Begin
12758>>>            Move 8192 to iLength
12759>>>            Move (Repeat(" ", iLength)) to sDataSource
12760>>>            Move (Repeat(" ", iLength)) to sDescription
12761>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
12766>>>        End
12766>>>>
12766>>>        
12766>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
12769>>>        Else ;            Function_Return ""
12771>>>    End_Function
12772>>>    
12772>>>End_Class
12773>>>
12773>
12773>Use Dfcursor.pkg
Including file: Dfcursor.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Dfcursor.pkg)
12773>>>//  create a desktop object named Cursor_control that understands
12773>>>//   Send Cursor_Wait to (cursor_Control(self))
12773>>>//            creates hourclass cursor
12773>>>//   Send Cursor_ready to (cursor_Control(self))
12773>>>//            restores regular cursor
12773>>>//
12773>>>Use Cursor.pkg
Including file: Cursor.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Cursor.pkg)
12773>>>>>Use Windows.pkg
12773>>>>>Use WinUser.pkg
12773>>>>>
12773>>>>>// Standard Cursor IDs
12773>>>>>
12773>>>>>
12773>>>>>
12773>>>>>
12773>>>>>
12773>>>>>Class CursorShape is a DFBaseToolPanel //BasicPanel
12774>>>>>    
12774>>>>>    Procedure Construct_Object
12776>>>>>        Property Handle ClassCursorHandle 0
12777>>>>>        Set Visible_State to False
12778>>>>>        Set Size to 1 1
12779>>>>>    End_Procedure
12780>>>>>    
12780>>>>>    Procedure Set Cursor Integer CursorType
12782>>>>>        Handle CursorID hWnd
12782>>>>>        Longptr retval lpCursorType
12782>>>>>        Get Window_Handle to hWnd
12783>>>>>        If (CursorType = 0) Begin
12785>>>>>            Send Release_Mouse_Capture
12786>>>>>            Move (SetClassLongPtr(hWnd, GCL_HCURSOR, ClassCursorHandle(Self))) to retval
12787>>>>>            Set ClassCursorHandle to 0
12788>>>>>            Send Page_Object False
12789>>>>>        End
12789>>>>>>
12789>>>>>        Else Begin
12790>>>>>            Send Page_Object True
12791>>>>>            Get Window_Handle to hWnd
12792>>>>>            If (ClassCursorHandle(Self) = 0) ;                Set ClassCursorHandle to (GetClassLongPtr(hWnd, GCL_HCURSOR))
12795>>>>>            
12795>>>>>            Move CursorType to lpCursorType    // Move to Longptr type to avoid conversion from integer to pointer in the next line
12796>>>>>            Move (LoadCursor(0,lpCursorType)) to CursorID
12797>>>>>            
12797>>>>>            Move (SetClassLongPtr(hWnd, GCL_HCURSOR, CursorID )) to retval
12798>>>>>            Move (SetCursor(CursorID)) to retval
12799>>>>>            Send Set_Mouse_Capture
12800>>>>>        End
12800>>>>>>
12800>>>>>    End_Procedure
12801>>>>>    
12801>>>>>    Procedure Mouse_Up
12803>>>>>        Handle retval
12803>>>>>        Send Set_Mouse_Capture
12804>>>>>        Move (SetCursor(GetClassLongPtr(Window_Handle(Self), GCL_HCURSOR))) to retval
12805>>>>>    End_Procedure
12806>>>>>    
12806>>>>>    Procedure Cursor_Wait
12808>>>>>        Set cursor to IDC_WAIT
12809>>>>>    End_Procedure
12810>>>>>    
12810>>>>>    Procedure Cursor_Ready
12812>>>>>        Set cursor to 0
12813>>>>>    End_Procedure
12814>>>>>    
12814>>>>>    
12814>>>>>End_Class
12815>>>
12815>>>Object Cursor_Control is a CursorShape
12817>>>End_Object
12818>>>
12818>Use cProcessStatusPanel.pkg
Including file: cProcessStatusPanel.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cProcessStatusPanel.pkg)
12818>>>// cProcessStatusPanel.pkg
12818>>>//
12818>>>// Class used to create StatusPanels.
12818>>>//
12818>>>// This class does not provide any of the inner objects that make up a status panel. Instead an
12818>>>// interface is provided that is used to update the various areas of status panel. At this level,
12818>>>// those areas (title area, message area, action area, button area) are logical. You create the
12818>>>// physical objects at the object level and then bind these objects to the interface.
12818>>>// Take a look at StatPnl.pkg to see how this is used.
12818>>>//
12818>>>// the standard Interface for status panels are:
12818>>>//
12818>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
12818>>>// Send Start_StatusPanel      - start the status panel
12818>>>// Send Stop_StatusPanel       - stop the status panel
12818>>>// Send Update_StatusPanel     - update the status panel's action area
12818>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
12818>>>//
12818>>>// Get/Set Caption_Text - updates the caption bar
12818>>>// Get/Set Title_Text   - updates the title area
12818>>>// Get/Set Message_Text - updates the Message area
12818>>>// Get/Set Action_Text  - updates the action area
12818>>>// Get/Set Button_Text  - updates the button area
12818>>>//
12818>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
12818>>>// Send EnableCancelButton - code must be provided in the cancel button object to enable/disable cancel button
12818>>>//
12818>>>
12818>>>Use cStatusPanel.pkg
Including file: cStatusPanel.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cStatusPanel.pkg)
12818>>>>>// This is an abstract class that can be used to create status panels. The interface at this level
12818>>>>>// is very simple. You can start, stop, request a cancel and allow the object to paint.
12818>>>>>//
12818>>>>>// Look at cProcessStatusPanel.pkg to see how this is used.
12818>>>>>
12818>>>>>Use Windows.pkg
12818>>>>>
12818>>>>>
12818>>>>>
12818>>>>>
12818>>>>>Class cStatusPanel is a FloatingPanel
12819>>>>>    
12819>>>>>    Procedure Construct_Object
12821>>>>>        Forward Send Construct_object
12823>>>>>        
12823>>>>>        Property Boolean pbCancel False
12824>>>>>        
12824>>>>>        Set Extended_Window_Style to WS_EX_DLGMODALFRAME True // kills sysmenu as long as there is no icon
12825>>>>>        Set Icon to '' // this must be cleared so there will be no icon
12826>>>>>        Set locate_mode to CENTER_ON_PANEL
12827>>>>>        Set Border_Style  to Border_Dialog
12828>>>>>        // should be scoped so it will not try to change the focus if there is no focusable button inside
12828>>>>>        Set Scope_State to True
12829>>>>>        
12829>>>>>        On_Key KEXIT_APPLICATION Send Close_Panel
12830>>>>>    End_Procedure
12831>>>>>    
12831>>>>>    // this is private and required. Never send this.
12831>>>>>    Procedure Deactivate_Group
12833>>>>>        If (Active_State(Self)) Begin
12835>>>>>            Send SuspendGUI of Desktop False
12836>>>>>        End
12836>>>>>>
12836>>>>>        Forward Send Deactivate_Group
12838>>>>>    End_Procedure
12839>>>>>    
12839>>>>>    // Send this message to stop the panel
12839>>>>>    Procedure Deactivate
12841>>>>>        If (Active_State(Self)) Begin
12843>>>>>            Send SuspendGUI of Desktop False
12844>>>>>        End
12844>>>>>>
12844>>>>>        Forward Send Deactivate
12846>>>>>    End_Procedure
12847>>>>>    
12847>>>>>    // Send this message to start the panel
12847>>>>>    Procedure Activate
12849>>>>>        If not (Active_State(Self)) Begin
12851>>>>>            Set pbCancel to False
12852>>>>>            Send SuspendGUI of Desktop True
12853>>>>>        End
12853>>>>>>
12853>>>>>        Forward Send Activate
12855>>>>>    End_Procedure
12856>>>>>    
12856>>>>>    // This allows the panel to paint when used in a tight loop, which is what status panels are
12856>>>>>    // used for. Any time you update the panel or wish to check for a cancel, you should call this.
12856>>>>>    Procedure ProcessEvents
12858>>>>>        If (Active_State(Self)) Begin
12860>>>>>            Send PumpMsgQueue of Desktop
12861>>>>>        End
12861>>>>>>
12861>>>>>    End_Procedure
12862>>>>>    
12862>>>>>    // note close panel does not actually close the panel. It just sets pbCancel to True, informing the
12862>>>>>    // process using this that it wants to close. It is then up the process close the panel.
12862>>>>>    Procedure Close_Panel
12864>>>>>        Set pbCancel to True
12865>>>>>    End_Procedure
12866>>>>>    
12866>>>>>End_Class
12867>>>
12867>>>
12867>>>
12867>>>Class cProcessStatusPanel is a cStatusPanel
12868>>>    
12868>>>    Procedure Construct_Object
12870>>>        Forward Send Construct_object
12872>>>        // determines if panel can be canceled
12872>>>        Property Boolean Allow_Cancel_State True
12873>>>    End_Procedure
12874>>>    
12874>>>    // Any of the properties that change the text of a status panel must also send
12874>>>    // ProcessEvents which allows the panel to process painting messages. The ProcessEvents
12874>>>    // is essential when using status panels within a tight loop
12874>>>    
12874>>>    Procedure Set Caption_text String sText
12876>>>        Set Label to sText
12877>>>        Send ProcessEvents
12878>>>    End_Procedure
12879>>>    
12879>>>    Function Caption_Text Returns String
12881>>>        Function_Return (Label(Self))
12882>>>    End_Function
12883>>>    
12883>>>    Procedure Set Message_Text String sText
12885>>>        Send ProcessEvents
12886>>>    End_Procedure
12887>>>    
12887>>>    Function Message_Text Returns String
12889>>>    End_Function
12890>>>    
12890>>>    Procedure Set Action_Text String sText
12892>>>        Send ProcessEvents
12893>>>    End_Procedure
12894>>>    
12894>>>    Function Action_Text Returns String
12896>>>    End_Function
12897>>>    
12897>>>    Procedure Set Button_Text String sText
12899>>>        Send ProcessEvents
12900>>>    End_Procedure
12901>>>    
12901>>>    Function Button_Text Returns String
12903>>>    End_Function
12904>>>    
12904>>>    Procedure Set Title_Text String sText
12906>>>        Send ProcessEvents
12907>>>    End_Procedure
12908>>>    
12908>>>    Function Title_Text Returns String
12910>>>    End_Function
12911>>>    
12911>>>    // initializes values for caption, title & message
12911>>>    Procedure Initialize_StatusPanel String sCaption String sTitle String sMessage
12913>>>        Set Caption_text to sCaption
12914>>>        Set Title_Text   to sTitle
12915>>>        Set Message_Text to sMessage
12916>>>    End_Procedure
12917>>>    
12917>>>    // update the status panel's action area
12917>>>    Procedure Update_StatusPanel String sAction
12919>>>        Set Action_Text to sAction
12920>>>    End_Procedure
12921>>>    
12921>>>    // stop the status panel
12921>>>    Procedure Close_Panel
12923>>>        If (Allow_cancel_state(Self)) Begin
12925>>>            Forward Send Close_Panel
12927>>>        End
12927>>>>
12927>>>    End_Procedure
12928>>>    
12928>>>    // Code must be provided in the cancel button object to enable/disable cancel button
12928>>>    Procedure EnableCancelButton Boolean bEnable
12930>>>    End_Procedure
12931>>>    
12931>>>    // check for cancel (if cancel or pbCancel is set, close the panel)
12931>>>    Function Check_StatusPanel Returns Integer
12933>>>        Boolean bCancel
12933>>>        If (Active_state(Self)) Begin
12935>>>            Send ProcessEvents
12936>>>            Get pbCancel to bCancel
12937>>>            If bCancel Begin
12939>>>                Send Stop_StatusPanel // the old status panel removed this when canceled.
12940>>>            End
12940>>>>
12940>>>        End
12940>>>>
12940>>>        Function_Return (If(bCancel, MSG_CANCEL, 0)) // the old check status panel returns msg_cancel
12941>>>    End_Function
12942>>>    
12942>>>    // start the status panel
12942>>>    Procedure Start_StatusPanel
12944>>>        If not (Active_state(Self)) Begin
12946>>>            Send EnableCancelButton (Allow_cancel_state(Self))
12947>>>            Send Activate
12948>>>        End
12948>>>>
12948>>>    End_Procedure
12949>>>    
12949>>>    // stop the status panel
12949>>>    Procedure Stop_StatusPanel
12951>>>        If (Active_state(Self)) Begin
12953>>>            Send Deactivate
12954>>>        End
12954>>>>
12954>>>    End_Procedure
12955>>>    
12955>>>End_Class
12956>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cProgressBar.pkg)
12956>>>Use Windows.pkg
12956>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cWinControl.pkg)
12956>>>>>Use Windows.pkg
12956>>>>>
12956>>>>>// Key State Masks for Mouse Messages
12956>>>>>
12956>>>>>Define MK_LBUTTON  for |CI$0001
12956>>>>>Define MK_RBUTTON  for |CI$0002
12956>>>>>Define MK_SHIFT    for |CI$0004
12956>>>>>Define MK_CONTROL  for |CI$0008
12956>>>>>Define MK_MBUTTON  for |CI$0010
12956>>>>>Define MK_XBUTTON1 for |CI$0020
12956>>>>>Define MK_XBUTTON2 for |CI$0040
12956>>>>>
12956>>>>>Enum_List // Mouse Key Flags
12956>>>>>    Define mkLeft    for MK_LBUTTON
12956>>>>>    Define mkMiddle  for MK_MBUTTON
12956>>>>>    Define mkRight   for MK_RBUTTON
12956>>>>>    Define mkX1      for MK_XBUTTON1
12956>>>>>    Define mkX2      for MK_XBUTTON2
12956>>>>>    Define mkShift   for MK_SHIFT
12956>>>>>    Define mkControl for MK_CONTROL
12956>>>>>End_Enum_List
12956>>>>>
12956>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
12956>>>>>    Define mbLeft
12956>>>>>    Define mbMiddle
12956>>>>>    Define mbRight
12956>>>>>    Define mbX1
12956>>>>>    Define mbX2
12956>>>>>End_Enum_List
12956>>>>>
12956>>>>>Class cWinControl is a DfBaseControl
12957>>>>>    Procedure Construct_Object
12959>>>>>        Forward Send Construct_Object
12961>>>>>        Property Integer private_pbEnabled True
12962>>>>>        Property Integer private_pbVisible True
12963>>>>>    End_Procedure
12964>>>>>    
12964>>>>>    Procedure End_Construct_Object
12966>>>>>        Forward Send End_Construct_Object
12968>>>>>        
12968>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
12969>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
12970>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
12971>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
12972>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
12973>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
12974>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
12975>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
12976>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
12977>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
12978>>>>>    End_Procedure
12979>>>>>    
12979>>>>>    Procedure Notify Longptr wParam Longptr lParam
12981>>>>>        //Intentionally cancelled
12981>>>>>    End_Procedure
12982>>>>>    
12982>>>>>    Procedure Command Integer wParam Integer lParam
12984>>>>>        //Intentionally cancelled
12984>>>>>    End_Procedure
12985>>>>>    
12985>>>>>    Procedure DoRecreateWindow
12987>>>>>        // Recreates the window
12987>>>>>        If (Window_Handle(Self)) Begin
12989>>>>>            // attempt to do this without disturbing the focus tree.
12989>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
12990>>>>>            Send Page 1      //                       Send Page_Object 1
12991>>>>>        End
12991>>>>>>
12991>>>>>    End_Procedure
12992>>>>>    
12992>>>>>    Procedure DoUpdateWindow
12994>>>>>        // Forces windows to update the window by bypassing WM_PAINT
12994>>>>>        Handle hWnd
12994>>>>>        
12994>>>>>        Get Window_Handle to hWnd
12995>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
12998>>>>>    End_Procedure
12999>>>>>    
12999>>>>>    Procedure Page Integer iState
13001>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
13002>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
13003>>>>>        Forward Send Page iState
13005>>>>>    End_Procedure
13006>>>>>    
13006>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
13008>>>>>        Integer x y eButton
13008>>>>>        
13008>>>>>        Move (Hi(lParam))  to y
13009>>>>>        Move (Low(lParam)) to x
13010>>>>>        
13010>>>>>        Send OnMouseUp mbLeft x y wParam
13011>>>>>    End_Procedure
13012>>>>>    
13012>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
13014>>>>>        Integer x y eButton
13014>>>>>        
13014>>>>>        Move (Hi(lParam))  to y
13015>>>>>        Move (Low(lParam)) to x
13016>>>>>        
13016>>>>>        Send OnMouseUp mbMiddle x y wParam
13017>>>>>    End_Procedure
13018>>>>>    
13018>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
13020>>>>>        Integer x y eButton
13020>>>>>        
13020>>>>>        Move (Hi(lParam))  to y
13021>>>>>        Move (Low(lParam)) to x
13022>>>>>        
13022>>>>>        Send OnMouseUp mbRight x y wParam
13023>>>>>    End_Procedure
13024>>>>>    
13024>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
13026>>>>>        Integer x y eButton fKeys
13026>>>>>        
13026>>>>>        Move (Hi(lParam))  to y
13027>>>>>        Move (Low(lParam)) to x
13028>>>>>        
13028>>>>>        Send OnMouseDown mbLeft x y wParam
13029>>>>>    End_Procedure
13030>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
13032>>>>>        Integer x y eButton
13032>>>>>        
13032>>>>>        Move (Hi(lParam))  to y
13033>>>>>        Move (Low(lParam)) to x
13034>>>>>        
13034>>>>>        Send OnMouseDown mbMiddle x y wParam
13035>>>>>    End_Procedure
13036>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
13038>>>>>        Integer x y eButton
13038>>>>>        
13038>>>>>        Move (Hi(lParam))  to y
13039>>>>>        Move (Low(lParam)) to x
13040>>>>>        
13040>>>>>        Send OnMouseDown mbRight x y wParam
13041>>>>>    End_Procedure
13042>>>>>    
13042>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
13044>>>>>        Integer x y eButton
13044>>>>>        
13044>>>>>        Move (Hi(lParam))  to y
13045>>>>>        Move (Low(lParam)) to x
13046>>>>>        
13046>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
13047>>>>>    End_Procedure
13048>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
13050>>>>>        Integer x y eButton
13050>>>>>        
13050>>>>>        Move (Hi(lParam))  to y
13051>>>>>        Move (Low(lParam)) to x
13052>>>>>        
13052>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
13053>>>>>    End_Procedure
13054>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
13056>>>>>        Integer x y eButton
13056>>>>>        
13056>>>>>        Move (Hi(lParam))  to y
13057>>>>>        Move (Low(lParam)) to x
13058>>>>>        
13058>>>>>        Send OnMouseDoubleClick mbRight x y wParam
13059>>>>>    End_Procedure
13060>>>>>    
13060>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
13062>>>>>        Integer x y eButton
13062>>>>>        
13062>>>>>        Move (Hi(lParam))  to y
13063>>>>>        Move (Low(lParam)) to x
13064>>>>>        
13064>>>>>        Send OnMouseMove x y wParam
13065>>>>>    End_Procedure
13066>>>>>    
13066>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
13068>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
13068>>>>>        //String sButton
13068>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
13068>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
13068>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
13068>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
13068>>>>>        
13068>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
13068>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
13068>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
13068>>>>>    End_Procedure
13069>>>>>    
13069>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
13071>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
13071>>>>>        //String sButton
13071>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
13071>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
13071>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
13071>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
13071>>>>>        
13071>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
13071>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
13071>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
13071>>>>>    End_Procedure
13072>>>>>    
13072>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
13074>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
13074>>>>>        //String sButton
13074>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
13074>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
13074>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
13074>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
13074>>>>>        
13074>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
13074>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
13074>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
13074>>>>>    End_Procedure
13075>>>>>    
13075>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
13077>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
13077>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
13077>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
13077>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
13077>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
13077>>>>>        
13077>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
13077>>>>>    End_Procedure
13078>>>>>    
13078>>>>>    Procedure Set pbEnabled Boolean bEnabled
13080>>>>>        Handle hWnd
13080>>>>>        
13080>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
13082>>>>>            Set private_pbEnabled to bEnabled
13083>>>>>            Get Window_Handle to hWnd
13084>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
13087>>>>>        End
13087>>>>>>
13087>>>>>    End_Procedure
13088>>>>>    Function pbEnabled Returns Boolean
13090>>>>>        Function_Return (private_pbEnabled(Self))
13091>>>>>    End_Function
13092>>>>>    
13092>>>>>    Procedure Set pbVisible Boolean bVisible
13094>>>>>        Handle  hWnd
13094>>>>>        Integer iVoid
13094>>>>>        
13094>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
13096>>>>>            Set private_pbVisible to bVisible
13097>>>>>            Get Window_Handle to hWnd
13098>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
13101>>>>>        End
13101>>>>>>
13101>>>>>    End_Procedure
13102>>>>>    Function pbVisible Returns Boolean
13104>>>>>        Function_Return (private_pbVisible(Self))
13105>>>>>    End_Function
13106>>>>>    
13106>>>>>End_Class
13107>>>Use CommCtrl.pkg
13107>>>
13107>>>//{ OverrideProperty=pbEnabled DesignTime=False }
13107>>>Class cProgressBar is a cWinControl
13108>>>    
13108>>>    Procedure Construct_Object
13110>>>        Forward Send Construct_Object
13112>>>        Property Integer private_piMinimum
13113>>>        Property Integer private_piMaximum   100
13114>>>        Property Integer private_piAdvanceBy 10
13115>>>        Property Integer private_piPosition
13116>>>        Property Integer private_pbVertical  False
13117>>>        Property Integer private_pbSmooth    False
13118>>>        Property Integer private_piBackColor clDefault
13119>>>        Property Integer private_piBarColor  clDefault
13120>>>        
13120>>>        Send Define_ToolTip_Support_Mixin
13121>>>        
13121>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
13122>>>        Set Focus_Mode to NonFocusable
13123>>>        Set Skip_State to True
13124>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
13125>>>    End_Procedure
13126>>>    
13126>>>    Import_Class_Protocol ToolTip_Support_Mixin
13127>>>    
13127>>>    Procedure Set piMinimum Integer iMin
13129>>>        Integer iMax
13129>>>        
13129>>>        Set private_piMinimum to iMin
13130>>>        Get private_piMaximum to iMax
13131>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
13132>>>    End_Procedure
13133>>>    Function piMinimum Returns Integer
13135>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
13138>>>        Else;            Function_Return (private_piMinimum(Self))
13140>>>    End_Function
13141>>>    
13141>>>    Procedure Set piMaximum Integer iMax
13143>>>        Integer iMin
13143>>>        
13143>>>        Set private_piMaximum to iMax
13144>>>        Get private_piMinimum to iMin
13145>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
13146>>>    End_Procedure
13147>>>    Function piMaximum Returns Integer
13149>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
13152>>>        Else;            Function_Return (private_piMaximum(Self))
13154>>>    End_Function
13155>>>    
13155>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
13157>>>        Set private_piAdvanceBy to iAdvanceBy
13158>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
13159>>>    End_Procedure
13160>>>    Function piAdvanceBy Returns Integer
13162>>>        Function_Return (private_piAdvanceBy(Self))
13163>>>    End_Function
13164>>>    
13164>>>    Procedure Set piPosition Integer iPos
13166>>>        Set private_piPosition to iPos
13167>>>        Send Windows_Message PBM_SETPOS iPos 0
13168>>>    End_Procedure
13169>>>    
13169>>>    Function piPosition Returns Integer
13171>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
13174>>>        Else;            Function_Return (private_piPosition(Self))
13176>>>    End_Function
13177>>>    
13177>>>    Procedure Set pbVertical Boolean bVertical
13179>>>        If (private_pbVertical(Self) <> bVertical) Begin
13181>>>            Set private_pbVertical to bVertical
13182>>>            Send DoRecreateWindow
13183>>>        End
13183>>>>
13183>>>    End_Procedure
13184>>>    
13184>>>    Function pbVertical Returns Boolean
13186>>>        Function_Return (private_pbVertical(Self))
13187>>>    End_Function
13188>>>    
13188>>>    Procedure Set pbSmooth Boolean bSmooth
13190>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
13192>>>            Set private_pbSmooth to bSmooth
13193>>>            Send DoRecreateWindow
13194>>>        End
13194>>>>
13194>>>    End_Procedure
13195>>>    Function pbSmooth Returns Boolean
13197>>>        Function_Return (private_pbSmooth(Self))
13198>>>    End_Function
13199>>>    
13199>>>    Procedure Set piBackColor Integer rgbColor
13201>>>        Set private_piBackColor to rgbColor
13202>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
13203>>>    End_Procedure
13204>>>    Function piBackColor Returns Integer
13206>>>        Function_Return (private_piBackColor(Self))
13207>>>    End_Function
13208>>>    
13208>>>    Procedure Set piBarColor Integer rgbColor
13210>>>        Set private_piBarColor to rgbColor
13211>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
13212>>>    End_Procedure
13213>>>    Function piBarColor Returns Integer
13215>>>        Function_Return (private_piBarColor(Self))
13216>>>    End_Function
13217>>>    
13217>>>    Procedure DoAdvance
13219>>>        Send Windows_Message PBM_STEPIT 0 0
13220>>>    End_Procedure
13221>>>    
13221>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
13223>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
13224>>>    End_Procedure
13225>>>    
13225>>>    Procedure private_DoInitWindow
13227>>>        Set piBarColor  to (private_piBarColor(Self))
13228>>>        Set piBackColor to (private_piBackColor(Self))
13229>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
13230>>>        Set piMinimum   to (private_piMinimum(Self))
13231>>>        Set piMaximum   to (private_piMaximum(Self))
13232>>>        Set piPosition  to (private_piPosition(Self))
13233>>>    End_Procedure
13234>>>    
13234>>>    Procedure Page_Object Integer iState
13236>>>        Handle hWnd
13236>>>        
13236>>>        Get Window_Handle to hWnd
13237>>>        If (hWnd=0 and iState) Begin
13239>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
13240>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
13241>>>            Forward Send Page_Object True
13243>>>        End
13243>>>>
13243>>>        Else ;            Forward Send Page_Object iState
13246>>>        
13246>>>        // Handle tooltip support....
13246>>>        If (iState = 0) Begin
13248>>>            Send RequestDeleteToolTip
13249>>>        End
13249>>>>
13249>>>        Else Begin
13250>>>            Send RequestAddToolTip
13251>>>        End
13251>>>>
13251>>>    End_Procedure
13252>>>    
13252>>>    Procedure Page Integer iState
13254>>>        Forward Send Page iState
13256>>>        If (iState =1);            Send private_DoInitWindow
13259>>>    End_Procedure
13260>>>    
13260>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
13260>>>    // method to perform AddToolTip because it is often the case that Page_Object
13260>>>    // is implemented in a mixin class.
13260>>>    Procedure RequestAddToolTip
13262>>>        Send AddToolTip
13263>>>    End_Procedure
13264>>>    
13264>>>    
13264>>>    // Called by Page_Object. Handles tooltip removal.
13264>>>    Procedure RequestDeleteToolTip
13266>>>        Send DeleteToolTip
13267>>>    End_Procedure
13268>>>End_Class
13269>
13269>
13269>Global_Variable Handle ghoAnalysisStatusPanel
13269>
13269>Struct tSqlVarTypes
13269>    Integer iType
13269>    String sTypeName
13269>    String sTypeReplaceName
13269>End_Struct
13269>
13269>Struct tTableMemoryUseData
13269>    String sTableName
13269>    Integer iExpectedMemUse
13269>End_Struct
13269>    
13269>
13269>// Object to show progress while process runs
13269>Object oAnalysisStatusPanel is a cProcessStatusPanel
13271>    Set Size to 93 326
13272>    Set Locate_Mode to Center_On_Panel
13273>
13273>    Move Self to ghoAnalysisStatusPanel 
13274>
13274>    Object oTitleTxt is a TextBox
13276>        Set location to 10 11
13277>        Set size to 17 304
13278>        Set Justification_Mode to JMode_Left
13279>    End_Object
13280>
13280>    Object oMessageTxt is a TextBox
13282>        Set location to 29 11
13283>        Set size to 17 304
13284>    End_Object
13285>
13285>    Object oActionTxt is a TextBox
13287>        Set Size to 7 30
13288>        Set location to 45 10
13289>    End_Object
13290>
13290>    Object oProgressBar is a cProgressBar
13292>        Set Size to 14 222
13293>        Set Location to 59 52
13294>        Set Skip_State to True
13295>    End_Object
13296>
13296>    Object oStopButton is a Button
13298>        Set Location to 76 138
13299>        Set Label to C_$Cancel
13300>        
13300>        Procedure OnClick
13303>            Send Close_panel
13304>        End_Procedure
13305>    
13305>    End_Object
13306>
13306>    // These messages bind the standard cProcessStatusPanel interface to the actual
13306>    // objects defined within this instance of the status panel.
13306>    
13306>    // note: all of the messages that change text should be forwarded
13306>    // as the forwarded messages allows the panel to paint when in a tight loop
13306>
13306>    Procedure Set Message_Text String sText
13309>        Set Label of oMessageTxt to sText
13310>        Forward Set Message_Text to sText
13312>    End_Procedure
13313>    
13313>    Function Message_Text Returns String
13316>        Function_Return (Label(oMessageTxt))
13317>    End_Function
13318>    
13318>    Procedure Set Action_Text String sText
13321>        Set Label of oActionTxt to sText
13322>        Forward Set Action_Text to sText
13324>    End_Procedure
13325>    
13325>    Function Action_Text Returns String
13328>        Function_Return (Label(oActionTxt))
13329>    End_Function
13330>    
13330>    Procedure Set Button_Text String sText
13333>        Set Label of oStopButton to sText
13334>        Forward Set Button_Text to sText
13336>    End_Procedure
13337>    
13337>    Function Button_Text Returns String
13340>        Function_Return (Label(oStopButton))
13341>    End_Function
13342>    
13342>    Procedure Set Title_Text String sText
13345>        Set Label of oTitleTxt to sText
13346>        Forward Set Title_Text to sText
13348>    End_Procedure
13349>    
13349>    Function Title_Text Returns String
13352>        Function_Return (Label(oTitleTxt))
13353>    End_Function
13354>
13354>    // gets called when status panel is activated passing whether a button should appear
13354>    Procedure EnableCancelButton Boolean bEnable
13357>        Set Enabled_State of oStopButton to bEnable
13358>    End_Procedure
13359>   
13359>    //
13359>    // Messages used in the Analysis status panel
13359>    //
13359>    
13359>    // Procedure DisplayAnalysisTask
13359>    // Updates the text in the status panel
13359>    // -------------------------------------------------------------    
13359>    Procedure DisplayAnalysisTask String sText 
13362>        Set Title_Text to sText
13363>    End_Procedure    
13364>    
13364>    
13364>    // Procedure AdvanceProgress
13364>    // Advance the progress bar
13364>    // -------------------------------------------------------------    
13364>    Procedure AdvanceProgress
13367>        Integer iCurPosition iMax iMin
13367>        Integer iPace
13367>        
13367>        Send Update_StatusPanel ""
13368>    
13368>        Get piMaximum of oProgressBar to iMax
13369>        Get piPosition of oProgressBar to iCurPosition    
13370>        Get piAdvanceBy of oProgressBar to iPace
13371>        If ((iCurPosition + iPace) > iMax) Begin
13373>            Get piMinimum of oProgressBar to iMin
13374>            Set piPosition of oProgressBar to iMin
13375>        End
13375>        
13375>        Send DoAdvance of oProgressBar
13376>    End_Procedure    
13377>    
13377>    
13377>    // Procedure StartProgressBar
13377>    // Displays the progress bar on the panel
13377>    // -------------------------------------------------------------    
13377>    Procedure StartProgressBar
13380>        Set piPosition of oProgressBar to 0
13381>        Set Visible_State of oProgressBar to True
13382>    End_Procedure   
13383>    
13383>    
13383>    // Procedure StopProgressBar
13383>    // Hides the progress bar on the panel
13383>    // -------------------------------------------------------------    
13383>    Procedure StopProgressBar
13386>        Set Visible_State of oProgressBar to False
13387>    End_Procedure   
13388>    
13388>        
13388>    // Procedure StartAnalysisPanel
13388>    // Initialize status panel for analysis
13388>    // -------------------------------------------------------------    
13388>    Procedure StartAnalysisPanel
13391>        // set cursor to hourglass
13391>        Send Cursor_Wait of Cursor_Control
13392>        
13392>        // disable cancel button
13392>        Set Allow_Cancel_State to False
13393>                    
13393>        // display status panel
13393>        Send Initialize_StatusPanel "Analyzing Table Memory Usage - Progress" "Initializing analysis..." ""
13394>        Send Start_StatusPanel 
13395>    End_Procedure
13396>    
13396>    
13396>    // Procedure StopAnalysisPanel
13396>    // Initialize status panel for analysis
13396>    // -------------------------------------------------------------    
13396>    Procedure StopAnalysisPanel
13399>        // remove status panel
13399>        Send Stop_StatusPanel 
13400>        
13400>        // enable cancel button (default)
13400>        Set Allow_Cancel_State to True
13401>        
13401>        // set cursor back to normal
13401>        Send Cursor_Ready of Cursor_Control
13402>    End_Procedure   
13403>      
13403>End_Object
13404>
13404>
13404>
13404>// Analysis process
13404>Object oAnalysisApplication is a cApplication
13406>    
13406>    Object oConnection is a cConnection
13408>        Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\LoginEncryption.pkg)
13408>>>Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cLoginEncryption.pkg)
13408>>>>>Use cCryptographer.pkg
Including file: cCryptographer.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCryptographer.pkg)
13408>>>>>>>Use VdfBase.pkg
13408>>>>>>>
13408>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\CryptographerConstants.pkg)
13408>>>>>>>>>//   Author  : Ulbe Stellema
13408>>>>>>>>>// Algorithm classes
13408>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
13408>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
13408>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
13408>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
13408>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
13408>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
13408>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
13408>>>>>>>>>
13408>>>>>>>>>// Algorithm types
13408>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
13408>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
13408>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
13408>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
13408>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
13408>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
13408>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
13408>>>>>>>>>
13408>>>>>>>>>// Generic sub-ids
13408>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
13408>>>>>>>>>
13408>>>>>>>>>// RSA sub-ids
13408>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
13408>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
13408>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
13408>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
13408>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
13408>>>>>>>>>
13408>>>>>>>>>// DSS sub-ids
13408>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
13408>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
13408>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
13408>>>>>>>>>
13408>>>>>>>>>// DES sub_ids
13408>>>>>>>>>Define ALG_SID_DES                      for 1
13408>>>>>>>>>Define ALG_SID_3DES                     for 3
13408>>>>>>>>>Define ALG_SID_DESX                     for 4
13408>>>>>>>>>Define ALG_SID_IDEA                     for 5
13408>>>>>>>>>Define ALG_SID_CAST                     for 6
13408>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
13408>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
13408>>>>>>>>>Define ALG_SID_3DES_112                 for 9
13408>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
13408>>>>>>>>>Define ALG_SID_RC5                      for 13
13408>>>>>>>>>Define ALG_SID_AES_128                  for 14
13408>>>>>>>>>Define ALG_SID_AES_192                  for 15
13408>>>>>>>>>Define ALG_SID_AES_256                  for 16
13408>>>>>>>>>Define ALG_SID_AES                      for 17
13408>>>>>>>>>
13408>>>>>>>>>// Fortezza sub-ids
13408>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
13408>>>>>>>>>Define ALG_SID_TEK                      for 11
13408>>>>>>>>>
13408>>>>>>>>>// RC2 sub-ids
13408>>>>>>>>>Define ALG_SID_RC2                      for 2
13408>>>>>>>>>
13408>>>>>>>>>// Stream cipher sub-ids
13408>>>>>>>>>Define ALG_SID_RC4                      for 1
13408>>>>>>>>>Define ALG_SID_SEAL                     for 2
13408>>>>>>>>>
13408>>>>>>>>>// Diffie-Hellman sub-ids
13408>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
13408>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
13408>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
13408>>>>>>>>>Define ALG_SID_KEA                      for 4
13408>>>>>>>>>
13408>>>>>>>>>// Hash sub ids
13408>>>>>>>>>Define ALG_SID_MD2                      for 1
13408>>>>>>>>>Define ALG_SID_MD4                      for 2
13408>>>>>>>>>Define ALG_SID_MD5                      for 3
13408>>>>>>>>>Define ALG_SID_SHA                      for 4
13408>>>>>>>>>Define ALG_SID_SHA1                     for 4
13408>>>>>>>>>Define ALG_SID_MAC                      for 5
13408>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
13408>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
13408>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
13408>>>>>>>>>Define ALG_SID_HMAC                     for 9
13408>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
13408>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
13408>>>>>>>>>Define ALG_SID_SHA_256                  for 12
13408>>>>>>>>>Define ALG_SID_SHA_384                  for 13
13408>>>>>>>>>Define ALG_SID_SHA_512                  for 14
13408>>>>>>>>>
13408>>>>>>>>>// secure channel sub ids
13408>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
13408>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
13408>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
13408>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
13408>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
13408>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
13408>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
13408>>>>>>>>>
13408>>>>>>>>>// algorithm identifier definitions
13408>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
13408>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
13408>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
13408>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
13408>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
13408>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
13408>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
13408>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
13408>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
13408>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
13408>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
13408>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
13408>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
13408>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
13408>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
13408>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
13408>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
13408>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
13408>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
13408>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
13408>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
13408>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
13408>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
13408>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
13408>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
13408>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
13408>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
13408>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
13408>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
13408>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
13408>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
13408>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
13408>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
13408>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
13408>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
13408>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
13408>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
13408>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
13408>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
13408>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
13408>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
13408>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
13408>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
13408>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
13408>>>>>>>>>
13408>>>>>>>>>// Providers
13408>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
13408>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
13408>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
13408>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
13408>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
13408>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
13408>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
13408>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
13408>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
13408>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
13408>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
13408>>>>>>>>>
13408>>>>>>>>>// dwFlags definitions for CryptAcquireContext
13408>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
13408>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
13408>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
13408>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
13408>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
13408>>>>>>>>>
13408>>>>>>>>>// dwFlag definitions for CryptGenKey
13408>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
13408>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
13408>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
13408>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
13408>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
13408>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
13408>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
13408>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
13408>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
13408>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
13408>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
13408>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
13408>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
13408>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
13408>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
13408>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
13408>>>>>>>>>
13408>>>>>>>>>// Provider types
13408>>>>>>>>>Define PROV_RSA_FULL                    for 1
13408>>>>>>>>>Define PROV_RSA_SIG                     for 2
13408>>>>>>>>>Define PROV_DSS                         for 3
13408>>>>>>>>>Define PROV_FORTEZZA                    for 4
13408>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
13408>>>>>>>>>Define PROV_SSL                         for 6
13408>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
13408>>>>>>>>>Define PROV_DSS_DH                      for 13
13408>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
13408>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
13408>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
13408>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
13408>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
13408>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
13408>>>>>>>>>Define PROV_RNG                         for 21
13408>>>>>>>>>Define PROV_INTEL_SEC                   for 22
13408>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
13408>>>>>>>>>Define PROV_RSA_AES                     for 24
13408>>>>>>>>>
13408>>>>>>>>>// KP_MODE
13408>>>>>>>>>// KP_MODE
13408>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
13408>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
13408>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
13408>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
13408>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
13408>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
13408>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
13408>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
13408>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
13408>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
13408>>>>>>>>>
13408>>>>>>>>>// dwParam definitions for CryptGetKeyParam
13408>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
13408>>>>>>>>>Define KP_SALT                          for 2       // Salt value
13408>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
13408>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
13408>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
13408>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
13408>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
13408>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
13408>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
13408>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
13408>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
13408>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
13408>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
13408>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
13408>>>>>>>>>Define KP_Y                             for 15      // Y value
13408>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
13408>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
13408>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
13408>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
13408>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
13408>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
13408>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
13408>>>>>>>>>Define KP_RP                            for 23
13408>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
13408>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
13408>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
13408>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
13408>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
13408>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
13408>>>>>>>>>Define KP_KEYVAL                        for 30
13408>>>>>>>>>Define KP_ADMIN_PIN                     for 31
13408>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
13408>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
13408>>>>>>>>>Define KP_PREHASH                       for 34
13408>>>>>>>>>Define KP_ROUNDS                        for 35
13408>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
13408>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
13408>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
13408>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
13408>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
13408>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
13408>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
13408>>>>>>>>>
13408>>>>>>>>>// dwParam definitions for CryptGetHashParam
13408>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
13408>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
13408>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
13408>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
13408>>>>>>>>>
13408>>>>>>>>>// key BLOB types
13408>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
13408>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
13408>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
13408>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
13408>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
13408>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
13408>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
13408>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
13408>>>>>>>>>
13408>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
13408>>>>>>>>>
13408>>>>>>>>>//  Structure cryptimportkey
13408>>>>>>>>>Struct PUBLICKEYSTRUC
13408>>>>>>>>>    UChar    bType
13408>>>>>>>>>    UChar    bVersion
13408>>>>>>>>>    UShort   reserved
13408>>>>>>>>>    UInteger aiKeyAlg
13408>>>>>>>>>End_Struct
13408>>>>>>>>>
13408>>>>>>>>>Struct tPLAINTEXTKEYBLOB
13408>>>>>>>>>    PUBLICKEYSTRUC hdr
13408>>>>>>>>>    PUBLICKEYSTRUC hdr
13408>>>>>>>>>    UInteger       dwKeySize
13408>>>>>>>>>//    UChar[]        rgbKeyData
13408>>>>>>>>>End_Struct
13408>>>>>>>>>
13408>>>>>>>>>
13408>>>>>>>>>
13408>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
13408>>>>>>>>>Struct HMAC_INFO
13408>>>>>>>>>    UInteger HashAlgid
13408>>>>>>>>>    Pointer pbInnerString
13408>>>>>>>>>    DWord cbInnerString
13408>>>>>>>>>    Pointer pbOuterString
13408>>>>>>>>>    DWord cbOuterString
13408>>>>>>>>>End_Struct
13408>>>>>>>>>
13408>>>>>>>>>
13408>>>>>>>>>External_Function CryptAcquireContext "CryptAcquireContextA" advapi32.dll ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
13409>>>>>>>>>
13409>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
13410>>>>>>>>>
13410>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
13411>>>>>>>>>
13411>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
13412>>>>>>>>>
13412>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
13413>>>>>>>>>
13413>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
13414>>>>>>>>>
13414>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
13415>>>>>>>>>
13415>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
13416>>>>>>>>>
13416>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
13417>>>>>>>>>
13417>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
13418>>>>>>>>>    
13418>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
13419>>>>>>>>>
13419>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
13420>>>>>>>>>
13420>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
13421>>>>>>>>>
13421>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
13422>>>>>>>>>    
13422>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
13423>>>>>>>>>    
13423>>>>>>>
13423>>>>>>>Class cCryptographer is a cObject
13424>>>>>>>    
13424>>>>>>>    Procedure Construct_Object
13426>>>>>>>        Forward Send Construct_Object
13428>>>>>>>        
13428>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
13429>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
13430>>>>>>>        Property Integer    piCipher    CALG_RC4
13431>>>>>>>        Property Integer    piHash      CALG_MD5
13432>>>>>>>        
13432>>>>>>>        // Private properties
13432>>>>>>>        Property Handle     Private_phProv
13433>>>>>>>    End_Procedure
13434>>>>>>>    
13434>>>>>>>    
13434>>>>>>>    // Acquire key container handle
13434>>>>>>>    Function AcquireContext Returns Handle
13436>>>>>>>        Integer iProvider
13436>>>>>>>        String sProvider
13436>>>>>>>        Handle hProv
13436>>>>>>>        Boolean bOk
13436>>>>>>>        Address addrProv
13436>>>>>>>        
13436>>>>>>>        Move 0 to hProv
13437>>>>>>>        Get piProvider to iProvider
13438>>>>>>>        Get psProvider to sProvider
13439>>>>>>>        
13439>>>>>>>        //  Determine address to be passed as provider
13439>>>>>>>        If (Trim(sProvider) <> "") Begin
13441>>>>>>>            Move (AddressOf(sProvider)) to addrProv
13442>>>>>>>        End
13442>>>>>>>>
13442>>>>>>>        Else Begin
13443>>>>>>>            Move 0 to addrProv
13444>>>>>>>        End
13444>>>>>>>>
13444>>>>>>>        
13444>>>>>>>        //  Acquire Crypto Context
13444>>>>>>>        Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
13445>>>>>>>        If (not(bOk) or hProv = 0) Begin
13447>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
13448>>>>>>>        End
13448>>>>>>>>
13448>>>>>>>        
13448>>>>>>>        If (not(bOk) or hProv = 0) Begin
13450>>>>>>>            // Fallback to original
13450>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,0)) to bOk
13451>>>>>>>            
13451>>>>>>>            If (not(bOk) or hProv = 0) Begin
13453>>>>>>>                Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET)) to bOk
13454>>>>>>>            End
13454>>>>>>>>
13454>>>>>>>        End
13454>>>>>>>>
13454>>>>>>>        Set Private_phProv to hProv
13455>>>>>>>        
13455>>>>>>>        Function_Return hProv
13456>>>>>>>    End_Function
13457>>>>>>>    
13457>>>>>>>    // Releases key container handle
13457>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
13459>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
13460>>>>>>>    End_Function
13461>>>>>>>    
13461>>>>>>>    // Creates hash object
13461>>>>>>>    Function CreateHash Handle hProv Returns Handle
13463>>>>>>>        Integer iAlgorithm
13463>>>>>>>        Handle hHash
13463>>>>>>>        Boolean bOk
13463>>>>>>>        
13463>>>>>>>        Move 0 to hHash
13464>>>>>>>        Get piHash to iAlgorithm
13465>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
13466>>>>>>>        
13466>>>>>>>        Function_Return hHash
13467>>>>>>>    End_Function
13468>>>>>>>    
13468>>>>>>>    // Destroys the hash object
13468>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
13470>>>>>>>        Function_Return (CryptDestroyHash(hHash))
13471>>>>>>>    End_Function
13472>>>>>>>    
13472>>>>>>>    // Adds data to hash object
13472>>>>>>>    Function HashData Handle hHash String sData Returns Boolean
13474>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(sData),Length(sData),0))
13475>>>>>>>    End_Function
13476>>>>>>>    
13476>>>>>>>    // Generates session key
13476>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
13478>>>>>>>        Integer iAlgorithm
13478>>>>>>>        Handle hKey
13478>>>>>>>        Boolean bOk
13478>>>>>>>        
13478>>>>>>>        Move 0 to hKey
13479>>>>>>>        Get piCipher to iAlgorithm
13480>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
13481>>>>>>>        
13481>>>>>>>        Function_Return hKey
13482>>>>>>>    End_Function
13483>>>>>>>    
13483>>>>>>>    // Imports a plain text key
13483>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
13485>>>>>>>        tPLAINTEXTKEYBLOB blobhead
13485>>>>>>>        tPLAINTEXTKEYBLOB blobhead
13485>>>>>>>        Boolean   bSuccess
13485>>>>>>>        Handle    hKey
13485>>>>>>>        Integer   iHeadSize iKeySize
13485>>>>>>>        UChar[]   ucaKeyblob
13486>>>>>>>        Integer iVoid
13486>>>>>>>        
13486>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
13487>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
13488>>>>>>>        
13488>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
13489>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
13490>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
13491>>>>>>>        Move iKeySize           to blobhead.dwKeySize
13492>>>>>>>        
13492>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
13493>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
13494>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
13495>>>>>>>        
13495>>>>>>>        Move 0 to hKey
13496>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
13497>>>>>>>        If (not(bSuccess)) Begin
13499>>>>>>>            Move (ShowLastError()) to iVoid
13500>>>>>>>        End
13500>>>>>>>>
13500>>>>>>>        
13500>>>>>>>        Function_Return hKey
13501>>>>>>>    End_Function
13502>>>>>>>    
13502>>>>>>>    // Destroys the key
13502>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
13504>>>>>>>        Function_Return (CryptDestroyKey(hKey))
13505>>>>>>>    End_Function
13506>>>>>>>    
13506>>>>>>>    // Retrieves key data
13506>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
13508>>>>>>>        Integer iBuffer iLen
13508>>>>>>>        Boolean bOk
13508>>>>>>>        
13508>>>>>>>        Move (SizeOfType(Integer)) to iLen
13509>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
13510>>>>>>>        Function_Return iBuffer
13511>>>>>>>    End_Function
13512>>>>>>>    
13512>>>>>>>    // Retrieves a hash value
13512>>>>>>>    Function HashValue Handle lhHash Returns String
13514>>>>>>>        String  lsHash
13514>>>>>>>        Integer liResult
13514>>>>>>>        DWord   dwDataLen
13514>>>>>>>        
13514>>>>>>>        Move 0 to dwDataLen
13515>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
13516>>>>>>>        If (liResult = 0) ;            Function_Return ""
13519>>>>>>>        
13519>>>>>>>        Move (Repeat(Character(0),dwDataLen)) to lsHash
13520>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(lsHash),AddressOf(dwDataLen),0)) to liResult
13521>>>>>>>        If (liResult = 0) ;            Function_Return ""
13524>>>>>>>        
13524>>>>>>>        Function_Return lsHash
13525>>>>>>>    End_Function
13526>>>>>>>
13526>>>>>>>    // Encrypts data
13526>>>>>>>    Function Encrypt String sPassword String sData Returns String
13528>>>>>>>        Handle hProv hHash hKey
13528>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
13528>>>>>>>        Boolean bOk
13528>>>>>>>        
13528>>>>>>>        Get AcquireContext to hProv
13529>>>>>>>        If (hProv) Begin
13531>>>>>>>            Get CreateHash hProv to hHash
13532>>>>>>>            If (hHash) Begin
13534>>>>>>>                Get HashData hHash sPassword to bOk
13535>>>>>>>                If (bOk) Begin
13537>>>>>>>                    Get piCipher to iAlgorithm
13538>>>>>>>                    Get DeriveKey hProv hHash to hKey
13539>>>>>>>                End
13539>>>>>>>>
13539>>>>>>>                Get DestroyHash hHash to bOk
13540>>>>>>>            End
13540>>>>>>>>
13540>>>>>>>            
13540>>>>>>>            If (hKey) Begin
13542>>>>>>>                //  First call to determine resulting data size
13542>>>>>>>                Move (Length(sData)) to iDataLen
13543>>>>>>>                Move (Length(sData)) to iCipherLen
13544>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
13545>>>>>>>                
13545>>>>>>>                //  Reserve space in string
13545>>>>>>>                If (iDataLen < iCipherLen) Begin
13547>>>>>>>                    Move (sData + Repeat(" ", iCipherLen - iDataLen)) to sData
13548>>>>>>>                End
13548>>>>>>>>
13548>>>>>>>                
13548>>>>>>>                //  Call to really decrypt
13548>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen),Length(sData))) to bOk
13549>>>>>>>                //If (not(bOk)) Begin
13549>>>>>>>                //Move "" to sData
13549>>>>>>>                //Move (GetLastError()) to iErr
13549>>>>>>>                //End
13549>>>>>>>                
13549>>>>>>>                Get DestroyKey hKey to bOk
13550>>>>>>>            End 
13550>>>>>>>>
13550>>>>>>>            Get ReleaseContext hProv to bOk
13551>>>>>>>        End 
13551>>>>>>>>
13551>>>>>>>        Function_Return sData
13552>>>>>>>    End_Function
13553>>>>>>>    
13553>>>>>>>    // Decrypts data
13553>>>>>>>    Function Decrypt String sPassword String sData Returns String
13555>>>>>>>        Handle hProv hHash hKey
13555>>>>>>>        Integer iAlgorithm iDataLen
13555>>>>>>>        Boolean bOk
13555>>>>>>>        
13555>>>>>>>        Get AcquireContext to hProv
13556>>>>>>>        If (hProv) Begin
13558>>>>>>>            Get CreateHash hProv to hHash
13559>>>>>>>            If (hHash) Begin
13561>>>>>>>                Get HashData hHash sPassword to bOk
13562>>>>>>>                If (bOk) Begin
13564>>>>>>>                    Get piCipher to iAlgorithm
13565>>>>>>>                    Get DeriveKey hProv hHash to hKey
13566>>>>>>>                End
13566>>>>>>>>
13566>>>>>>>                Get DestroyHash hHash to bOk
13567>>>>>>>            End
13567>>>>>>>>
13567>>>>>>>            
13567>>>>>>>            If (hKey) Begin
13569>>>>>>>                Move (Length(sData)) to iDataLen
13570>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen))) to bOk
13571>>>>>>>                //  Resulting dat can be shorter as the input string, in that case we shorten the result string
13571>>>>>>>                If (Length(sData) > iDataLen) Begin
13573>>>>>>>                    Move (Left(sData, iDataLen)) to sData
13574>>>>>>>                End
13574>>>>>>>>
13574>>>>>>>                
13574>>>>>>>                Get DestroyKey hKey to bOk
13575>>>>>>>            End
13575>>>>>>>>
13575>>>>>>>            Get ReleaseContext hProv to bOk
13576>>>>>>>        End
13576>>>>>>>>
13576>>>>>>>        Function_Return sData
13577>>>>>>>    End_Function
13578>>>>>>>    
13578>>>>>>>    //  Generates random data.
13578>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
13580>>>>>>>        Handle hProv
13580>>>>>>>        UChar[] uaResult
13581>>>>>>>        Boolean bRes
13581>>>>>>>        
13581>>>>>>>        Get AcquireContext to hProv
13582>>>>>>>        
13582>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
13583>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
13584>>>>>>>        
13584>>>>>>>        Get ReleaseContext hProv to bRes
13585>>>>>>>        
13585>>>>>>>        Function_Return uaResult
13586>>>>>>>    End_Function
13587>>>>>>>    
13587>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
13587>>>>>>>    Function GenerateRandomString Integer iLenght Returns String
13589>>>>>>>        String sResult
13589>>>>>>>        UChar[] aData
13590>>>>>>>        Address pBase64
13590>>>>>>>        Integer iVoid
13590>>>>>>>        
13590>>>>>>>        Get GenerateRandom iLenght to aData
13591>>>>>>>        
13591>>>>>>>        Move (Base64Encode(AddressOf(aData), iLenght)) to pBase64
13592>>>>>>>        Move pBase64 to sResult
13593>>>>>>>        Move (Free(pBase64)) to iVoid
13594>>>>>>>        
13594>>>>>>>        Function_Return (Left(sResult, iLenght))
13595>>>>>>>    End_Function
13596>>>>>>>    
13596>>>>>>>End_Class
13597>>>>>
13597>>>>>Class cLoginEncryption is a cObject
13598>>>>>    
13598>>>>>    Procedure Construct_Object
13600>>>>>        Forward Send Construct_Object
13602>>>>>        // this must be set to a multi (40ish) character random key
13602>>>>>        Property String psEncryptPassword ""
13603>>>>>        
13603>>>>>        Object oDataCrypter is a cCryptographer
13605>>>>>            Set piHash to CALG_SHA_256
13606>>>>>            Set piCipher to CALG_AES_256
13607>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
13608>>>>>            Set piProvider to PROV_RSA_AES
13609>>>>>        End_Object
13610>>>>>    End_Procedure
13611>>>>>    
13611>>>>>    // This can be augmented to return a password encryption key using any
13611>>>>>    // hidden mechanism desired.
13611>>>>>    Function GetEncryptionPassword Returns String
13613>>>>>        String sPassword
13613>>>>>        Get psEncryptPassword to sPassword
13614>>>>>        Function_Return sPassword
13615>>>>>    End_Function
13616>>>>>    
13616>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
13616>>>>>    //
13616>>>>>    // Params:
13616>>>>>    //   sPlainText     String to encrypt.
13616>>>>>    // Returns:
13616>>>>>    //   Base64 encoded hash.
13616>>>>>    Function EncryptPassword String sPlainText Returns String
13618>>>>>        String sEncryptPassword sBinary sBase64
13618>>>>>        Address pBase64
13618>>>>>        Integer iVoid
13618>>>>>        
13618>>>>>        //  Encrypt Key
13618>>>>>        Get GetEncryptionPassword to sEncryptPassword
13619>>>>>        If (sEncryptPassword = "") Begin
13621>>>>>            Error DFERR_PROGRAM "No encryption password set"
13622>>>>>>
13622>>>>>        End
13622>>>>>>
13622>>>>>        
13622>>>>>        Get Encrypt of oDataCrypter sEncryptPassword sPlainText to sBinary
13623>>>>>        
13623>>>>>        If (sPlainText = sBinary or sBinary = "") Begin
13625>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
13626>>>>>>
13626>>>>>            Function_Return ""
13627>>>>>        End
13627>>>>>>
13627>>>>>        
13627>>>>>        //  Encode binary hash to Base64
13627>>>>>        Move (Base64Encode(AddressOf(sBinary), Length(sBinary))) to pBase64
13628>>>>>        Move pBase64 to sBase64
13629>>>>>        Move (Free(pBase64)) to iVoid
13630>>>>>        
13630>>>>>        Function_Return sBase64
13631>>>>>    End_Function
13632>>>>>    
13632>>>>>    
13632>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
13632>>>>>    //
13632>>>>>    // Params:
13632>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
13632>>>>>    // Returns:
13632>>>>>    //   Readable plain text password
13632>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
13634>>>>>        String sEncryptPassword sPlainText sBinary
13634>>>>>        Boolean bIsHex
13634>>>>>        Integer iLen iVoid
13634>>>>>        Address pBinary
13634>>>>>        
13634>>>>>        If (sBase64EncryptedPassword <> "") Begin
13636>>>>>            //  Decode from Base64
13636>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
13637>>>>>            
13637>>>>>            Move (Repeat(Character(0), iLen)) to sBinary
13638>>>>>            Move (CopyMemory(AddressOf(sBinary), pBinary, iLen)) to iVoid
13639>>>>>            
13639>>>>>            Move (Free(pBinary)) to iVoid
13640>>>>>            
13640>>>>>            //  Encrypted binary hash to string
13640>>>>>            Get GetEncryptionPassword to sEncryptPassword
13641>>>>>            Get Decrypt of oDataCrypter sEncryptPassword sBinary to sPlainText
13642>>>>>        End
13642>>>>>>
13642>>>>>        
13642>>>>>        Function_Return sPlainText
13643>>>>>    End_Function
13644>>>>>End_Class
13645>>>
13645>>>Object oLoginEncryption is a cLoginEncryption
13647>>>
13647>>>    // this must be created in your appsrc directory and must contain an encryption
13647>>>    // key that is set to psEncryptPassword. It will look something like this
13647>>>    //
13647>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
13647>>>    //  
Including file: LoginEncryptionKey.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\LoginEncryptionKey.inc)
13647>>>>// Studio generated login encryption key
13647>>>>Set psEncryptPassword to "%sLm*XHVF>f0yB.:.PHrBx6L)8x70i7zAN{q._WC"
13648>>>>
13648>>>    
13648>>>    // use this to register this object to your cConnection Object. This object
13648>>>    // must be created after the cConnection object
13648>>>    Move Self to ghoLoginEncryption
13649>>>End_Object
13650>        Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\DatabaseLoginDialog.dg)
13650>>>
13650>>>Use Windows.pkg
13650>>>Use cConnection.pkg
13650>>>Use dfLine.pkg
Including file: Dfline.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Dfline.pkg)
13650>>>>>Use windows.pkg
13650>>>>>
13650>>>>>//
13650>>>>>// Line Styles
13650>>>>>//
13650>>>>>Enumeration_List
13650>>>>>    Define lnDIP        // grey (Shadow) top line, light bottom (highlight)
13650>>>>>    Define lnBUMP       // light top (highlight), grey (Shadow) bottom
13650>>>>>    Define lnSINGLE     // Single dark line
13650>>>>>    Define lnCUSTOM     // create your own with line_color1 & 2.
13650>>>>>End_Enumeration_List
13650>>>>>
13650>>>>>Class LineControl is a DFBaseLineControl
13651>>>>>    
13651>>>>>    Procedure Construct_Object
13653>>>>>        Forward Send Construct_Object
13655>>>>>        Property Integer Line_Color1  COLOR_BTNSHADOW
13656>>>>>        Property Integer Line_Color2  COLOR_BTNHIGHLIGHT
13657>>>>>        // we do not want control to participate in forward backwards object navigation
13657>>>>>        Set Skip_State to True
13658>>>>>    End_Procedure
13659>>>>>    
13659>>>>>    Procedure Notify Longptr wParam Longptr lParam
13661>>>>>    End_Procedure
13662>>>>>    
13662>>>>>    Procedure Set Line_Color1 Integer theColor
13664>>>>>        Set top_line_color to theColor
13665>>>>>    End_Procedure
13666>>>>>    
13666>>>>>    Procedure Set Line_Color2 Integer theColor
13668>>>>>        Set bottom_line_color to theColor
13669>>>>>    End_Procedure
13670>>>>>    
13670>>>>>    Function Line_Color1 Returns Integer
13672>>>>>        Function_Return (top_line_color(Self))
13673>>>>>    End_Function
13674>>>>>    
13674>>>>>    Function Line_Color2 Returns Integer
13676>>>>>        Function_Return (bottom_line_color(Self))
13677>>>>>    End_Function
13678>>>>>End_Class
13679>>>>>
13679>>>
13679>>>Object oDatabaseLoginDialog is a ModalPanel
13681>>>    Set Label to "Database Login"
13682>>>    Set Location to 2 2
13683>>>    Set Size to 110 211
13684>>>    
13684>>>    Property String psId
13686>>>    Property Boolean pbOk False
13688>>>    Property Boolean pbChanged False
13690>>>    Property Boolean pbAllowRemember True
13692>>>    
13692>>>    // this registers this object with the cConnection object.
13692>>>    Move Self to ghoLoginConnectDialog
13693>>>    
13693>>>    Object oUserIDForm is a Form
13695>>>        Set Label to "User Name"
13696>>>        Set Size to 12 85
13697>>>        Set Location to 34 79
13698>>>        Set Label_Col_Offset to 64
13699>>>        Set peAnchors to anTopLeftRight
13700>>>    End_Object
13701>>>    
13701>>>    Object oPwdForm is a Form
13703>>>        Set Size to 12 85
13704>>>        Set Location to 49 79
13705>>>        Set Label_Col_Offset to 64
13706>>>        Set Password_State to True
13707>>>        Set peAnchors to anTopLeftRight
13708>>>        Set Label to "Password"
13709>>>    End_Object
13710>>>    
13710>>>    Object oTrustedConnection is a CheckBox
13712>>>        Set Size to 10 50
13713>>>        Set Location to 65 79
13714>>>        Set Label to "Trusted Connection"
13715>>>    End_Object
13716>>>    
13716>>>    Object oRemember is a CheckBox
13718>>>        Set Size to 10 50
13719>>>        Set Location to 79 14
13720>>>        Set Label to "Remember and don't ask again"
13721>>>        Set Checked_State to True
13722>>>    End_Object
13723>>>    
13723>>>    Object oLogin_btn is a Button
13725>>>        Set Label to "&Login"
13726>>>        Set Location to 92 102
13727>>>        Set peAnchors to anBottomRight
13728>>>        Set Default_State to True
13729>>>        
13729>>>        Procedure OnClick
13732>>>            Boolean bTrust
13732>>>            String sUser sPwd sConn sErr sId
13732>>>            Integer iError
13732>>>            Get psId to sId
13733>>>            Get Value of oUserIDForm to sUser
13734>>>            Get Value of oPwdForm to sPwd
13735>>>            Get Checked_State of oTrustedConnection to bTrust
13736>>>            
13736>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
13737>>>            If (iError=0) Begin
13739>>>                Set pbOk to True
13740>>>                Set pbChanged to True
13741>>>                Send Close_Panel
13742>>>            End
13742>>>>
13742>>>            Else Begin
13743>>>                Get psErrorText of ghoConnection to sErr
13744>>>                Send UserError sErr "Login Error"
13745>>>            End
13745>>>>
13745>>>        End_Procedure
13746>>>    End_Object
13747>>>    
13747>>>    Object oCancel_btn is a Button
13749>>>        Set Label to "&Cancel"
13750>>>        Set Location to 92 157
13751>>>        Set peAnchors to anBottomRight
13752>>>        
13752>>>        Procedure OnClick
13755>>>            Send Close_Panel
13756>>>        End_Procedure
13757>>>    End_Object
13758>>>    
13758>>>    Object oConnectionIdInfo is a TextBox
13760>>>        Set Size to 10 50
13761>>>        Set Location to 4 14
13762>>>        Set Label to 'Connection Id='
13763>>>    End_Object
13764>>>    
13764>>>    Object oConnectionServerInfo is a TextBox
13766>>>        Set Size to 10 50
13767>>>        Set Location to 16 14
13768>>>        Set Label to 'Server'
13769>>>    End_Object
13770>>>    
13770>>>    Object oLineControl1 is a LineControl
13772>>>        Set Size to 2 202
13773>>>        Set Location to 29 5
13774>>>    End_Object
13775>>>    
13775>>>    Function LoginConnectIdDialog String sId Returns Boolean
13778>>>        Boolean bOk bChanged bTrusted bAllowRemember bRemember
13778>>>        String sUser sPwd sDescription
13778>>>        tConnection Connect
13778>>>        tConnection Connect
13778>>>        
13778>>>        Get pbAllowRemember to bAllowRemember
13779>>>        
13779>>>        
13779>>>        If not bAllowRemember Begin
13781>>>            Set Enabled_State of oRemember to bRemember
13782>>>            Set Visible_State of oRemember to bRemember
13783>>>        End
13783>>>>
13783>>>        
13783>>>        Get ConnectionIdInfo of ghoConnection sId to Connect
13784>>>        Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
13785>>>        Set Value of oConnectionServerInfo to Connect.sString
13786>>>        
13786>>>        Set psId to sId
13787>>>        Set pbOk to False
13788>>>        Set pbChanged to False
13789>>>        Set Value of oUserIDForm to Connect.sUID
13790>>>        Set Value of oPwdForm to ""
13791>>>        
13791>>>        Send Popup
13792>>>        
13792>>>        Get pbOk to bOk
13793>>>        Get pbChanged to bChanged
13794>>>        If (bChanged and bOk) Begin
13796>>>            If bAllowRemember Begin
13798>>>                Get Checked_State of oRemember to bRemember
13799>>>                If bRemember Begin
13801>>>                    Get Checked_State of oTrustedConnection to bTrusted
13802>>>                    If not (bTrusted) Begin
13804>>>                        Get Value of oUserIDForm to sUser
13805>>>                        Get Value of oPwdForm to sPwd
13806>>>                    End
13806>>>>
13806>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
13807>>>                End
13807>>>>
13807>>>            End
13807>>>>
13807>>>        End
13807>>>>
13807>>>        Function_Return bOk
13808>>>    End_Function
13809>>>    
13809>>>    
13809>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
13810>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
13811>>>End_Object
13812>>>
13812>    End_Object
13813>
13813>
13813>    Property tSqlVarTypes[] ptMsSqlVarTypes
13815>    Property tSqlVarTypes[] ptDB2VarTypes
13817>    Property tSqlVarTypes[] ptODBCVarTypes
13819>
13819>    Property tTableMemoryUseData[] paTableMemoryUseData
13821>    Property Number pnBufSizeTotalWS
13823>    Property Number pnBufSizeSaveWS
13825>
13825>
13825>    Procedure DoInit
13828>        Integer iType
13828>        tSqlVarTypes[] msSQLVarTypes db2SQLVarTypes mysqlVarTypes
13828>        tSqlVarTypes[] msSQLVarTypes db2SQLVarTypes mysqlVarTypes
13831>        
13831>        // initialize MSSQL types
13831>        Move SQL_VARCHARMAX to msSQLVarTypes[iType].iType
13832>        Move "VarChar(max)" to msSQLVarTypes[iType].sTypeName
13833>        Move "VarChar" to msSQLVarTypes[iType].sTypeReplaceName
13834>        Increment iType
13835>        
13835>        Move SQL_WVARCHARMAX to msSQLVarTypes[iType].iType
13836>        Move "nVarChar(max)" to msSQLVarTypes[iType].sTypeName
13837>        Move "nVarChar" to msSQLVarTypes[iType].sTypeReplaceName
13838>        Increment iType
13839>        
13839>        Move SQL_VARBINARYMAX to msSQLVarTypes[iType].iType
13840>        Move "nVarBinary(max)" to msSQLVarTypes[iType].sTypeName
13841>        Move "nVarBinary" to msSQLVarTypes[iType].sTypeReplaceName
13842>        
13842>        Set ptMsSqlVarTypes to msSQLVarTypes
13843>
13843>        // initialize DB2 types
13843>        Move 0 to iType
13844>        
13844>        Move SQL_LONGVARCHAR to db2SQLVarTypes[iType].iType
13845>        Move "LongVarChar" to db2SQLVarTypes[iType].sTypeName
13846>        Move "VarChar" to db2SQLVarTypes[iType].sTypeReplaceName
13847>        Increment iType
13848>        
13848>        Move SQL_LONGVARBINARY to db2SQLVarTypes[iType].iType
13849>        Move "LongVarBinary" to db2SQLVarTypes[iType].sTypeName
13850>        Move "VarBinary" to db2SQLVarTypes[iType].sTypeReplaceName
13851>        Increment iType
13852>        
13852>        Move SQL_LONGVARGRAPHIC to db2SQLVarTypes[iType].iType
13853>        Move "LongVarGraphic" to db2SQLVarTypes[iType].sTypeName
13854>        Move "VarGraphic" to db2SQLVarTypes[iType].sTypeReplaceName
13855>        Increment iType
13856>
13856>        Set ptDB2VarTypes to db2SQLVarTypes
13857>        
13857>         // initialize MySQL types
13857>        Move 0 to iType
13858>        
13858>        Move SQL_LONGVARCHAR to mysqlVarTypes[iType].iType
13859>        Move "LongVarChar" to mysqlVarTypes[iType].sTypeName
13860>        Move "VarChar" to mysqlVarTypes[iType].sTypeReplaceName
13861>        Increment iType
13862>        
13862>        Move SQL_LONGVARBINARY to mysqlVarTypes[iType].iType
13863>        Move "LongVarBinary" to mysqlVarTypes[iType].sTypeName
13864>        Move "VarBinary" to mysqlVarTypes[iType].sTypeReplaceName
13865>        Increment iType
13866>        
13866>        Set ptODBCVarTypes to mysqlVarTypes
13867>    End_Procedure
13868>    
13868>    
13868>    Object oLogFile is a cObject
13870>        Property String psLogFile "TableStructLog.txt"
13872>        Property String psLogFileWithPath ""
13874>        Property Integer piChOut
13876>
13876>        // initialize output
13876>        Procedure InitializeOutput
13879>            String sDataPath sLogFile sWorkspaceDescription
13879>            Integer iChOut
13879>            Date dToday
13879>            
13879>            Move (Seq_New_Channel()) to iChOut
13880>            
13880>            Get psDataPath of (oWorkspace(oAnalysisApplication)) to sDataPath
13881>            Get PathAtIndex of (oWorkspace(oAnalysisApplication)) sDataPath 1 to sDataPath
13882>            Get psLogFile to sLogFile
13883>
13883>            Move (If(Right(sDataPath,1) <> "\", sDataPath - "\", sDataPath)) to sDataPath            
13884>            Set psLogFileWithPath to (sDataPath + sLogFile)
13885>            Set piChOut to iChOut
13886>            
13886>            Direct_Output channel iChOut sLogFile
13888>            Get psDescription of (oWorkspace(oAnalysisApplication)) to sWorkspaceDescription
13889>            Writeln channel iChOut "Workspace: " sWorkspaceDescription
13893>            Writeln channel iChOut "Data Path: " sDataPath
13897>            Move (CurrentDateTime()) to dToday
13898>            Writeln channel iChOut "Date Analyzed: " (String(dToday))
13902>            Writeln channel iChOut ""  // insert spacer line
13905>        End_Procedure
13906>        
13906>        // close output and display log file
13906>        Procedure ShowLog
13909>            String sLogFile
13909>            Integer iChOut
13909>            
13909>            Get psLogFileWithPath to sLogFile
13910>            Get piChOut to iChOut
13911>            
13911>            Close_Output channel iChOut
13913>            Send Seq_Release_Channel iChOut 
13914>            
13914>            Runprogram Background "notepad.exe" sLogFile
13915>        End_Procedure
13916>    
13916>    End_Object
13917>    
13917>    // Check if filelist entry is for an alias table:
13917>    // Master Table (alias) means that logical table name <> root name
13917>    // At the moment, the ".int" suffix is not supported
13917>    Function IsAliasTable String sTableName String sLogicalName String ByRef sDriver Returns String
13920>        Boolean bIsAlias
13920>        
13920>        Move (trim(sTableName)) to sTableName
13921>        Move (trim(sLogicalName)) to sLogicalName
13922>        
13922>        // root name could contain "MSSQLDRV:"
13922>        If (Lowercase(sTableName) contains "mssqldrv:") Begin
13924>            Move "mssqldrv" to sDriver
13925>            Move (Right(sTableName, Length(sTableName)-9)) to sTableName
13926>        End
13926>        // root name could contain "DB2_DRV:"
13926>        Else If (Lowercase(sTableName) contains "db2_drv:") Begin
13929>            Move "db2_drv" to sDriver
13930>            Move (Right(sTableName, Length(sTableName)-8)) to sTableName
13931>        End
13931>        // root name could contain "ODBC_DRV:"
13931>        Else If (Lowercase(sTableName) contains "odbc_drv:") Begin
13934>            Move "odbc_drv" to sDriver
13935>            Move (Right(sTableName, Length(sTableName)-9)) to sTableName
13936>        End
13936>        Else Begin
13937>            Move "dataflex" to sDriver
13938>        End
13938>        
13938>        Move (trim(Lowercase(sTableName)) <> Trim(Lowercase(sLogicalName))) to bIsAlias
13939>        
13939>        Function_Return bIsAlias
13940>    End_Function
13941>    
13941>    Procedure AnalyzeTable Handle hTable
13944>        Integer iChOut i iColumns iBlockSize iType iColLen iColNativeLen iCount
13944>        Number nBufSizeSave nBufSizeTotal nBufSizeSaveWS nBufSizeTotalWS
13944>        Integer iIndex iTypeCount
13944>        Boolean bIsAlias bErrorOpenFile
13944>        String sTableName sLogicalName sColName sLine sType sTypeChange sDriver sCurrentType
13944>        tTableMemoryUseData[] TableMemoryUseData
13944>        tTableMemoryUseData[] TableMemoryUseData
13945>        tSqlVarTypes[] varTypes
13945>        tSqlVarTypes[] varTypes
13946>        
13946>        // trap open table error so it's not fatal
13946>        Move False to Err
13947>        Send Ignore_All to Error_Object_Id        
13948>        Open hTable
13950>        Move Err to bErrorOpenFile
13951>        Send Trap_All of Error_Object_Id
13952>        
13952>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
13955>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
13958>        
13958>        If (bErrorOpenFile = False) Begin
13960>        Send DisplayAnalysisTask of ghoAnalysisStatusPanel ("Table - " + sTableName)
13961>
13961>        // only analyze master tables
13961>        Get IsAliasTable sTableName sLogicalName (&sDriver) to bIsAlias
13962>        If (not (bIsAlias)) Begin
13964>            Get piChOut of oLogFile to iChOut
13965>            
13965>            If (sDriver <> "dataflex") Begin
13967>                Get_Attribute DF_FILE_BLOCK_SIZE of hTable to iBlockSize
13970>            End
13970>            Else Begin
13971>                Move 0 to iBlockSize
13972>            End
13972>            
13972>            Writeln channel iChOut "Table: " sTableName
13976>            
13976>            // get array of types to check, based on driver
13976>            If (sDriver = "mssqldrv") Begin
13978>                Get ptMsSqlVarTypes to varTypes
13979>            End
13979>            Else If (sDriver = "db2_drv") Begin
13982>                Get ptDB2VarTypes to varTypes
13983>            End
13983>            Else If (sDriver = "odbc_drv") Begin
13986>                Get ptODBCVarTypes to varTypes
13987>            End
13987>            Move (SizeOfArray(varTypes)) to iTypeCount
13988>        
13988>            // identify problem columns
13988>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
13991>            Writeln channel iChOut "Columns: " (String(iColumns))
13995>            For i from 1 to iColumns
14001>                If (sDriver <> "dataflex") Begin
14003>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable i to iType
14006>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable i to sCurrentType
14009>                End
14009>                Get_Attribute DF_FIELD_LENGTH of hTable i to iColLen
14012>                Get_Attribute DF_FIELD_NATIVE_LENGTH of hTable i to iColNativeLen
14015>                Move (nBufSizeTotal + iColNativeLen) to nBufSizeTotal
14016>
14016>                // check for types that could have high memory use
14016>                For iIndex from 0 to (iTypeCount-1)
14022>                    If (iType = varTypes[iIndex].iType) Begin
14024>                        If (iColLen <= 8000) Begin
14026>                            Get_Attribute DF_FIELD_NAME of hTable i to sColName
14029>                            Move (nBufSizeSave + iColNativeLen - iColLen) to nBufSizeSave
14030>                            
14030>                            Move ("    Column '" + sColName + "' " + varTypes[iIndex].sTypeName + ", length used = " + ;                                (String(iColLen)) + ", recommend change to " + varTypes[iIndex].sTypeReplaceName) to sLine
14031>                            Writeln channel iChOut sLine
14034>                        End
14034>                        Else If (iColLen > 8000 and iColLen < 16000) Begin
14037>                            Move ("    Column '" + sColName + "' " + varTypes[iIndex].sTypeName + ", length used = " + ;                                (String(iColLen)) + ", column will use significant memory") to sLine
14038>                            Writeln channel iChOut sLine
14041>                        End
14041>                    End
14041>                Loop
14042>            Loop
14043>            
14043>            Writeln channel iChOut "Block Size: " (String(iBlockSize))
14047>            Writeln channel iChOut "Total Buffer Size: " (FormatNumber(nBufSizeTotal, 0))
14051>            Writeln channel iChOut "Expected Memory Use: " (FormatNumber(nBufSizeTotal * (iBlockSize+1), 0))
14055>            If (nBufSizeSave > 0) Begin
14057>                Writeln channel iChOut "Potential Memory Reduction: " (FormatNumber(nBufSizeSave * (iBlockSize+1), 0))
14061>            End
14061>            Writeln channel iChOut ""  // insert spacer line
14064>            
14064>            // save workspace totals
14064>            Get pnBufSizeTotalWS to nBufSizeTotalWS
14065>            Set pnBufSizeTotalWS to (nBufSizeTotalWS + (nBufSizeTotal * (iBlockSize+1)))
14066>            If (nBufSizeSave > 0) Begin
14068>                Get pnBufSizeSaveWS to nBufSizeSaveWS
14069>                Set pnBufSizeSaveWS to (nBufSizeSaveWS + (nBufSizeSave * (iBlockSize+1.00)))
14070>            End
14070>            
14070>            // store table if expected memory use > 5 MB
14070>            Get paTableMemoryUseData to TableMemoryUseData
14071>            Move (SizeOfArray(TableMemoryUseData)) to iCount
14072>            If ((nBufSizeTotal * (iBlockSize+1)) > 5000000) Begin
14074>                Move sTableName to TableMemoryUseData[iCount].sTableName
14075>                Move (nBufSizeTotal * (iBlockSize+1)) to TableMemoryUseData[iCount].iExpectedMemUse
14076>            End
14076>            Set paTableMemoryUseData to TableMemoryUseData
14077>            End
14077>        End
14077>    End_Procedure
14078>    
14078>    Procedure Go
14081>        Handle hTable
14081>        Integer iChOut i iCount
14081>        Number nBufSizeSaveWS nBufSizeTotalWS
14081>        tTableMemoryUseData[] TableMemoryUseData 
14081>        tTableMemoryUseData[] TableMemoryUseData 
14082>        
14082>        Send AdvanceProgress of ghoAnalysisStatusPanel
14083>        
14083>        Send DoInit
14084>        Send InitializeOutput of oLogFile
14085>        
14085>        Send AdvanceProgress of ghoAnalysisStatusPanel
14086>        
14086>        Repeat
14086>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
14089>            If (hTable > 0 and (hTable <> 50)) Begin
14091>                Send AnalyzeTable hTable
14092>            End
14092>            Send AdvanceProgress of ghoAnalysisStatusPanel
14093>        Until (hTable = 0)
14095>        
14095>        // write out analysis summary
14095>        Get piChOut of oLogFile to iChOut
14096>        Get pnBufSizeTotalWS to nBufSizeTotalWS
14097>        Get pnBufSizeSaveWS to nBufSizeSaveWS
14098>        Writeln channel iChOut "Total Expected Memory Use: " (FormatNumber(nBufSizeTotalWS, 0))
14102>        Writeln channel iChOut "Potential Memory Reduction: " (FormatNumber(nBufSizeSaveWS, 0))
14106>        
14106>        Get paTableMemoryUseData to TableMemoryUseData
14107>        Move (SizeOfArray(TableMemoryUseData)) to iCount
14108>        If (iCount > 0) Begin
14110>            Writeln channel iChOut ""  // insert spacer line
14113>            Writeln channel iChOut "Tables to Examine for Further Optimization:"
14116>            Writeln channel iChOut ""  // insert spacer line
14119>            For i from 0 to (iCount-1)
14125>                Writeln channel iChOut TableMemoryUseData[i].sTableName " / " (FormatNumber(TableMemoryUseData[i].iExpectedMemUse, 0))
14130>            Loop
14131>        End
14131>        
14131>        Send ShowLog of oLogFile
14132>    End_Procedure
14133>
14133>End_Object
14134>
14134>
14134>Send Info_Box "Press OK to start analysis..." "Analyze Table Memory Usage"
14135>Send StartAnalysisPanel of ghoAnalysisStatusPanel
14136>Send StartProgressBar of ghoAnalysisStatusPanel
14137>
14137>Send Go of oAnalysisApplication
14138>
14138>Send StopProgressBar of ghoAnalysisStatusPanel
14139>Send StopAnalysisPanel of ghoAnalysisStatusPanel
14140>
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 12997
Total Resources: 0
Total Commands : 14139
Total Windows  : 0
Total Pages    : 0
Static Data    : 141017
Message area   : 75512
Total Blocks   : 6869
