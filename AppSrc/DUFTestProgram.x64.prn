Compiling Program: C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFTestProgram.src
Memory Available: 61067149312
1>    CompilerLevelWarning All On
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.x64.pkd    (C:\Program Files\DataFlex 24.0\Pkg\dfallent.x64.pkd)
73440>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJStandardCommandBarSystem.pkg)
73440>>>// these are all the packages used in a standard MDI menubar/toolbar system
73440>>>
73440>>>Use cCJCommandBarSystem.pkg
73440>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJStandardMenuItemClasses.pkg)
73440>>>>>Use Dfpanel.pkg
73440>>>>>Use cCJCommandBarSystem.pkg
73440>>>>>Use LanguageText.pkg
73440>>>>>
73440>>>>>
73440>>>>>Class cCJUndoMenuItem is a cCJMenuItem
73441>>>>>    
73441>>>>>    Procedure Construct_Object
73443>>>>>        Forward Send Construct_Object
73445>>>>>        Set psCaption   to C_$CaptionUndo
73446>>>>>        Set psToolTip to C_$ToolTipUndo
73447>>>>>        Set psDescription to C_$DescUndo
73448>>>>>        Set psImage to "ActionUndo.ico"
73449>>>>>        Set pbActiveUpdate to True
73450>>>>>        Set psCategory to C_$CategoryEdit
73451>>>>>        Set psShortcut to C_$Key_Ctrl_Z
73452>>>>>    End_Procedure
73453>>>>>    
73453>>>>>    Procedure OnExecute Variant vCommandBarControl
73455>>>>>        Send Undo of (focus(Self))
73456>>>>>    End_Procedure
73457>>>>>    
73457>>>>>    Function IsEnabled Returns Boolean
73459>>>>>        Boolean bEnabled
73459>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
73460>>>>>        Function_Return bEnabled
73461>>>>>    End_Function
73462>>>>>    
73462>>>>>End_Class
73463>>>>>
73463>>>>>
73463>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
73464>>>>>    
73464>>>>>    Procedure Construct_Object
73466>>>>>        Forward Send Construct_Object
73468>>>>>        Set psCaption   to C_$CaptionDelete
73469>>>>>        Set psToolTip to C_$ToolTipDelete
73470>>>>>        Set psDescription to C_$DescDelete
73471>>>>>        Set psImage to "actionDelete.ico"
73472>>>>>        Set psShortcut to C_$Key_Delete
73473>>>>>        Set pbActiveUpdate to True
73474>>>>>        Set psCategory to C_$CategoryEdit
73475>>>>>    End_Procedure
73476>>>>>    
73476>>>>>    
73476>>>>>    Procedure OnExecute Variant vCommandBarControl
73478>>>>>        Send Delete of (focus(Self))
73479>>>>>    End_Procedure
73480>>>>>    
73480>>>>>    Function IsEnabled Returns Boolean
73482>>>>>        Boolean bEnabled
73482>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
73483>>>>>        Function_Return bEnabled
73484>>>>>    End_Function
73485>>>>>    
73485>>>>>End_Class
73486>>>>>
73486>>>>>
73486>>>>>Class cCJCutMenuItem is a cCJMenuItem
73487>>>>>    
73487>>>>>    Procedure Construct_Object
73489>>>>>        Forward Send Construct_Object
73491>>>>>        Set psCaption   to C_$CaptionCut
73492>>>>>        Set psToolTip to C_$TooltipCut
73493>>>>>        Set psDescription to C_$DescCut
73494>>>>>        Set psImage to "actionCut.ico"
73495>>>>>        Set psShortcut to C_$Key_Ctrl_X
73496>>>>>        Set pbActiveUpdate to True
73497>>>>>        Set psCategory to C_$CategoryEdit
73498>>>>>    End_Procedure
73499>>>>>    
73499>>>>>    
73499>>>>>    Procedure OnExecute Variant vCommandBarControl
73501>>>>>        Send Cut of (focus(Self))
73502>>>>>    End_Procedure
73503>>>>>    
73503>>>>>    Function IsEnabled Returns Boolean
73505>>>>>        Boolean bEnabled
73505>>>>>        Get CanCut of (Focus(Self)) to bEnabled
73506>>>>>        Function_Return bEnabled
73507>>>>>    End_Function
73508>>>>>    
73508>>>>>End_Class
73509>>>>>
73509>>>>>
73509>>>>>Class cCJCopyMenuItem is a cCJMenuItem
73510>>>>>    
73510>>>>>    Procedure Construct_Object
73512>>>>>        Forward Send Construct_Object
73514>>>>>        Set psCaption   to C_$CaptionCopy
73515>>>>>        Set psToolTip to C_$ToolTipCopy
73516>>>>>        Set psDescription to C_$DescCopy
73517>>>>>        Set psImage to "actionCopy.ico"
73518>>>>>        Set psShortcut to C_$Key_Ctrl_C
73519>>>>>        Set pbActiveUpdate to True
73520>>>>>        Set psCategory to C_$CategoryEdit
73521>>>>>    End_Procedure
73522>>>>>    
73522>>>>>    
73522>>>>>    Procedure OnExecute Variant vCommandBarControl
73524>>>>>        Send Copy of (focus(Self))
73525>>>>>    End_Procedure
73526>>>>>    
73526>>>>>    Function IsEnabled Returns Boolean
73528>>>>>        Boolean bEnabled
73528>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
73529>>>>>        Function_Return bEnabled
73530>>>>>    End_Function
73531>>>>>    
73531>>>>>End_Class
73532>>>>>
73532>>>>>
73532>>>>>Class cCJPasteMenuItem is a cCJMenuItem
73533>>>>>    
73533>>>>>    Procedure Construct_Object
73535>>>>>        Forward Send Construct_Object
73537>>>>>        Set psCaption   to C_$CaptionPaste
73538>>>>>        Set psToolTip to C_$ToolTipPaste
73539>>>>>        Set psDescription to C_$DescPaste
73540>>>>>        Set psImage to "actionPaste.ico"
73541>>>>>        Set pbActiveUpdate to True
73542>>>>>        Set psShortcut to C_$Key_Ctrl_V
73543>>>>>        Set psCategory to C_$CategoryEdit
73544>>>>>    End_Procedure
73545>>>>>    
73545>>>>>    
73545>>>>>    Procedure OnExecute Variant vCommandBarControl
73547>>>>>        Send Paste of (focus(Self))
73548>>>>>    End_Procedure
73549>>>>>    
73549>>>>>    Function IsEnabled Returns Boolean
73551>>>>>        Boolean bEnabled
73551>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
73552>>>>>        Function_Return bEnabled
73553>>>>>    End_Function
73554>>>>>    
73554>>>>>End_Class
73555>>>>>
73555>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
73556>>>>>    
73556>>>>>    Procedure Construct_Object
73558>>>>>        Forward Send Construct_Object
73560>>>>>        Set psCaption   to C_$CaptionSelectAll
73561>>>>>        Set psToolTip to C_$ToolTipSelectAll
73562>>>>>        Set psDescription to C_$DescSelectAll
73563>>>>>        Set pbActiveUpdate to True
73564>>>>>        Set psShortcut to C_$Key_Ctrl_A
73565>>>>>        Set psCategory to C_$CategoryEdit
73566>>>>>    End_Procedure
73567>>>>>    
73567>>>>>    
73567>>>>>    Procedure OnExecute Variant vCommandBarControl
73569>>>>>        Send Select_All of (focus(Self))
73570>>>>>    End_Procedure
73571>>>>>    
73571>>>>>    Function IsEnabled Returns Boolean
73573>>>>>        Boolean bEnabled
73573>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
73574>>>>>        Function_Return bEnabled
73575>>>>>    End_Function
73576>>>>>    
73576>>>>>End_Class
73577>>>>>
73577>>>>>
73577>>>>>Class cCJExitMenuItem is a cCJMenuItem
73578>>>>>    
73578>>>>>    Procedure Construct_Object
73580>>>>>        Forward Send Construct_Object
73582>>>>>        Set psCaption to C_$CaptionExit
73583>>>>>        Set psToolTip to C_$ToolTipExit
73584>>>>>        Set psDescription to C_$ToolTipExit
73585>>>>>        Set psShortcut to C_$Key_Alt_F4
73586>>>>>        Set psCategory to C_$CategoryFile
73587>>>>>    End_Procedure
73588>>>>>    
73588>>>>>    Procedure OnExecute Variant vCommandBarControl
73590>>>>>        Send Exit_Application of Desktop
73591>>>>>    End_Procedure
73592>>>>>    
73592>>>>>End_Class
73593>>>>>
73593>>>>>Class cCJHelpMenuItem is a cCJMenuItem
73594>>>>>    
73594>>>>>    Procedure Construct_Object
73596>>>>>        Forward Send Construct_Object
73598>>>>>        Set psCaption to C_$CaptionHelp
73599>>>>>        Set psDescription to C_$ToolTipHelp
73600>>>>>        Set psToolTip to C_$DescHelp
73601>>>>>        Set psImage to "ActionHelp.ico"
73602>>>>>        Set psShortcut to "F1"
73603>>>>>        Set psCategory to C_$CategoryHelp
73604>>>>>    End_Procedure
73605>>>>>    
73605>>>>>    Procedure OnExecute Variant vCommandBarControl
73607>>>>>        Send Help of (Focus(Self))
73608>>>>>    End_Procedure
73609>>>>>    
73609>>>>>End_Class
73610>>>>>
73610>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
73611>>>>>    
73611>>>>>    Procedure Construct_Object
73613>>>>>        Forward Send Construct_Object
73615>>>>>        Set psCaption to C_$CaptionAddStatusbar
73616>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
73617>>>>>        Set psDescription to  C_$DescAddStatusbar
73618>>>>>        Set psCategory to C_$CategoryWindow
73619>>>>>    End_Procedure
73620>>>>>    
73620>>>>>    Procedure OnExecute Variant vCommandBarControl
73622>>>>>        Handle hoCommandBars hoClientArea
73622>>>>>        Get CommandBarSystemObject to hoCommandBars
73623>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73624>>>>>        If hoClientArea Begin
73626>>>>>            // the clientarea's parent panel has message
73626>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
73627>>>>>        End
73627>>>>>>
73627>>>>>    End_Procedure
73628>>>>>    
73628>>>>>    Function IsChecked Returns Boolean
73630>>>>>        Boolean bOn
73630>>>>>        Handle hoCommandBars hoClientArea
73630>>>>>        Get CommandBarSystemObject to hoCommandBars
73631>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73632>>>>>        If hoClientArea Begin
73634>>>>>            // the clientarea's parent panel has message
73634>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
73635>>>>>        End
73635>>>>>>
73635>>>>>        Function_Return bOn
73636>>>>>    End_Function
73637>>>>>End_Class
73638>>>>>
73638>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
73639>>>>>    
73639>>>>>    Procedure Construct_Object
73641>>>>>        Forward Send Construct_Object
73643>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
73644>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
73645>>>>>        Set psDescription to C_$DescAutoArrangeIcons
73646>>>>>        Set psCategory to C_$CategoryWindow
73647>>>>>    End_Procedure
73648>>>>>    
73648>>>>>    Procedure OnExecute Variant vCommandBarControl
73650>>>>>        Handle hoCommandBars hoClientArea
73650>>>>>        Get CommandBarSystemObject to hoCommandBars
73651>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73652>>>>>        If hoClientArea Begin
73654>>>>>            // the clientarea's parent panel has message
73654>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
73655>>>>>        End
73655>>>>>>
73655>>>>>    End_Procedure
73656>>>>>    
73656>>>>>    Function IsChecked Returns Boolean
73658>>>>>        Boolean bOn
73658>>>>>        Handle hoCommandBars hoClientArea
73658>>>>>        Get CommandBarSystemObject to hoCommandBars
73659>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73660>>>>>        If hoClientArea Begin
73662>>>>>            // the clientarea's parent panel has message
73662>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
73663>>>>>        End
73663>>>>>>
73663>>>>>        Function_Return bOn
73664>>>>>    End_Function
73665>>>>>End_Class
73666>>>>>
73666>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
73667>>>>>    
73667>>>>>    Procedure Construct_Object
73669>>>>>        Forward Send Construct_Object
73671>>>>>        Set psCaption to C_$CaptionRestoreMenus
73672>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
73673>>>>>        Set psDescription to C_$DescRestoreMenus
73674>>>>>        Set psCategory to C_$CategoryWindow
73675>>>>>    End_Procedure
73676>>>>>    
73676>>>>>    Procedure OnExecute Variant vCommandBarControl
73678>>>>>        Handle hoCommandBars
73678>>>>>        Get CommandBarSystemObject to hoCommandBars
73679>>>>>        Send RestoreLayout of hoCommandBars
73680>>>>>    End_Procedure
73681>>>>>    
73681>>>>>End_Class
73682>>>>>
73682>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
73683>>>>>    
73683>>>>>    Procedure Construct_Object
73685>>>>>        Forward Send Construct_Object
73687>>>>>        Set psCaption to C_$CaptionCascade
73688>>>>>        Set psToolTip to C_$ToolTipCascade
73689>>>>>        Set psDescription to  C_$DescCascade
73690>>>>>        Set psImage to "ActionCascade.ico"
73691>>>>>        Set psCategory to C_$CategoryWindow
73692>>>>>    End_Procedure
73693>>>>>    
73693>>>>>    Procedure OnExecute Variant vCommandBarControl
73695>>>>>        Handle hoCommandBars hoClientArea
73695>>>>>        Get CommandBarSystemObject to hoCommandBars
73696>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73697>>>>>        If hoClientArea Begin
73699>>>>>            Send Cascade_Windows of hoClientArea
73700>>>>>        End
73700>>>>>>
73700>>>>>    End_Procedure
73701>>>>>End_Class
73702>>>>>
73702>>>>>Class cCJTileHorizontally is a cCJMenuItem
73703>>>>>    
73703>>>>>    Procedure Construct_Object
73705>>>>>        Forward Send Construct_Object
73707>>>>>        Set psCaption to C_$CaptionTileHorizontally
73708>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
73709>>>>>        Set psDescription to  C_$DescTileHorizontally
73710>>>>>        Set psImage to "ActionTileHorizontally.ico"
73711>>>>>        Set psCategory to C_$CategoryWindow
73712>>>>>    End_Procedure
73713>>>>>    
73713>>>>>    Procedure OnExecute Variant vCommandBarControl
73715>>>>>        Handle hoCommandBars hoClientArea
73715>>>>>        Get CommandBarSystemObject to hoCommandBars
73716>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73717>>>>>        If hoClientArea Begin
73719>>>>>            Send Tile_Windows_Horizontal of hoClientArea
73720>>>>>        End
73720>>>>>>
73720>>>>>    End_Procedure
73721>>>>>End_Class
73722>>>>>
73722>>>>>Class cCJTileVertically is a cCJMenuItem
73723>>>>>    
73723>>>>>    Procedure Construct_Object
73725>>>>>        Forward Send Construct_Object
73727>>>>>        Set psCaption to C_$CaptionTileVertically
73728>>>>>        Set psToolTip to C_$ToolTipTileVertically
73729>>>>>        Set psDescription to  C_$DescTileVertically
73730>>>>>        Set psImage to "ActionTileVertically.ico"
73731>>>>>        Set psCategory to C_$CategoryWindow
73732>>>>>    End_Procedure
73733>>>>>    
73733>>>>>    Procedure OnExecute Variant vCommandBarControl
73735>>>>>        Handle hoCommandBars hoClientArea
73735>>>>>        Get CommandBarSystemObject to hoCommandBars
73736>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73737>>>>>        If hoClientArea Begin
73739>>>>>            Send Tile_Windows_Vertical of hoClientArea
73740>>>>>        End
73740>>>>>>
73740>>>>>    End_Procedure
73741>>>>>End_Class
73742>>>>>
73742>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
73743>>>>>    
73743>>>>>    Procedure Construct_Object
73745>>>>>        Forward Send Construct_Object
73747>>>>>        Set psCaption to C_$CaptionMinimizeWindows
73748>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
73749>>>>>        Set psDescription to  C_$DescMinimizeWindows
73750>>>>>        Set psCategory to C_$CategoryWindow
73751>>>>>    End_Procedure
73752>>>>>    
73752>>>>>    Procedure OnExecute Variant vCommandBarControl
73754>>>>>        Handle hoCommandBars hoClientArea
73754>>>>>        Get CommandBarSystemObject to hoCommandBars
73755>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73756>>>>>        If hoClientArea Begin
73758>>>>>            // the clientarea's parent panel has message
73758>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
73759>>>>>        End
73759>>>>>>
73759>>>>>    End_Procedure
73760>>>>>End_Class
73761>>>>>
73761>>>>>
73761>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
73762>>>>>    
73762>>>>>    Procedure Construct_Object
73764>>>>>        Forward Send Construct_Object
73766>>>>>        Set psCaption to C_$CaptionRestoreWindows
73767>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
73768>>>>>        Set psDescription to  C_$DescRestoreWindows
73769>>>>>        Set psCategory to C_$CategoryWindow
73770>>>>>    End_Procedure
73771>>>>>    
73771>>>>>    Procedure OnExecute Variant vCommandBarControl
73773>>>>>        Handle hoCommandBars hoClientArea
73773>>>>>        Get CommandBarSystemObject to hoCommandBars
73774>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73775>>>>>        If hoClientArea Begin
73777>>>>>            // the clientarea's parent panel has message
73777>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
73778>>>>>        End
73778>>>>>>
73778>>>>>    End_Procedure
73779>>>>>End_Class
73780>>>>>
73780>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
73781>>>>>    
73781>>>>>    Procedure Construct_Object
73783>>>>>        Forward Send Construct_Object
73785>>>>>        Set psCaption to C_$CaptionArrangeIcons
73786>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
73787>>>>>        Set psDescription to  C_$DescArrangeIcons
73788>>>>>        Set psCategory to C_$CategoryWindow
73789>>>>>    End_Procedure
73790>>>>>    
73790>>>>>    Procedure OnExecute Variant vCommandBarControl
73792>>>>>        Handle hoCommandBars hoClientArea
73792>>>>>        Get CommandBarSystemObject to hoCommandBars
73793>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73794>>>>>        If hoClientArea Begin
73796>>>>>            Send Arrange_Icons of hoClientArea
73797>>>>>        End
73797>>>>>>
73797>>>>>    End_Procedure
73798>>>>>    
73798>>>>>End_Class
73799>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJAboutMenuItem.pkg)
73799>>>>>Use cCJCommandBarSystem.pkg
73799>>>>>Use LanguageText.pkg
73799>>>>>
73799>>>>>// It is expected that if you use this class that you provide an about object that is
73799>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
73799>>>>>// because you may wish to create your own custom about package.
73799>>>>>
73799>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
73800>>>>>
73800>>>>>    Procedure Construct_Object
73802>>>>>        Forward Send Construct_Object
73804>>>>>        Set psCaption to C_$CaptionAbout
73805>>>>>        Set psDescription to C_$ToolTipAbout
73806>>>>>        Set psToolTip to C_$DescAbout
73807>>>>>        Set psImage to "ActionAbout.ico"
73808>>>>>        Set psCategory to C_$CategoryHelp
73809>>>>>    End_Procedure
73810>>>>>    
73810>>>>>    Procedure OnExecute Variant vCommandBarControl
73812>>>>>        Handle hoCommandBars hoClientArea
73812>>>>>        Get CommandBarSystemObject to hoCommandBars
73813>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73814>>>>>        If hoClientArea Begin
73816>>>>>            Send Activate_About of hoClientArea
73817>>>>>        End
73817>>>>>>
73817>>>>>    End_Procedure
73818>>>>>
73818>>>>>End_Class
73819>>>>>
73819>>>>>
73819>>>Use cCJDeoMenuItemClasses.pkg
73819>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJMDIWindowsMenuItem.pkg)
73819>>>>>Use cCJCommandBarSystem.pkg
73819>>>>>
73819>>>>>Register_Function Client_ID Returns Integer
73819>>>>>
73819>>>>>// only used by cCJMDIWIndowsMenuItem
73819>>>>>Class cCJMDIWindowItem is a cCJMenuItem
73820>>>>>    
73820>>>>>    Procedure Construct_Object
73822>>>>>        Forward Send Construct_Object
73824>>>>>        Property Handle phWindow 0 // object id of view
73825>>>>>        Set pbControlFlagNoMovable to True
73826>>>>>        Set pbActiveUpdate to True
73827>>>>>    End_Procedure
73828>>>>>    
73828>>>>>    Procedure OnExecute Variant vCommandBarControl
73830>>>>>        Handle hWindow
73830>>>>>        Get phWindow to hWindow
73831>>>>>        Send Activate_View of hWindow
73832>>>>>    End_Procedure
73833>>>>>    
73833>>>>>End_Class
73834>>>>>
73834>>>>>
73834>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
73835>>>>>    
73835>>>>>    Procedure Construct_Object
73837>>>>>        Forward Send Construct_Object
73839>>>>>        Property Handle[] phArrayOfWindows
73840>>>>>        Set peControlType to xtpControlPopup
73841>>>>>        Set psCategory to C_$CategoryWindow
73842>>>>>    End_Procedure
73843>>>>>    
73843>>>>>    // This adds MDI windows to the existing menu items.
73843>>>>>    // This removes any existing windows menus and always adds a new set to the end
73843>>>>>    
73843>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
73845>>>>>        Handle  hClientArea hView
73845>>>>>        String  sLabel
73845>>>>>        Integer i iWindows
73845>>>>>        Handle[] hArrayOfWindows
73846>>>>>        Variant vItem
73846>>>>>        
73846>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
73846>>>>>        // also assume that destroying an action removes all menu instances of that action
73846>>>>>        Get phArrayOfWindows to hArrayOfWindows
73847>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
73848>>>>>        For i from 0 to (iWindows-1)
73854>>>>>>
73854>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
73855>>>>>        Loop
73856>>>>>>
73856>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
73857>>>>>        
73857>>>>>        // Add all views to this menu. Create the action and add the item
73857>>>>>        Move 0 to i
73858>>>>>        Get Client_Id to hClientArea // object id of client area
73859>>>>>        If (hClientArea > 0) Begin
73861>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
73862>>>>>            While (hView <> 0)
73866>>>>>                If (Active_State(hView)) Begin
73868>>>>>                    // create the action
73868>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
73869>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
73870>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
73871>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
73872>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
73874>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
73875>>>>>                    End
73875>>>>>>
73875>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
73876>>>>>                    If (i=0) Begin
73878>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
73879>>>>>                    End
73879>>>>>>
73879>>>>>                    // Create a menu item for this action
73879>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
73880>>>>>                    Increment i
73881>>>>>                End
73881>>>>>>
73881>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
73882>>>>>            Loop
73883>>>>>>
73883>>>>>        End
73883>>>>>>
73883>>>>>        
73883>>>>>        Set phArrayOfWindows to hArrayOfWindows
73884>>>>>        
73884>>>>>    End_Procedure
73885>>>>>    
73885>>>>>End_Class
73886>Use cCJCommandBarSystem.pkg
73886>Use cDbUpdateHandler.pkg
Including file: cDbUpdateHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.pkg)
73886>>>//****************************************************************************
73886>>>// $Module type: Class
73886>>>// $Module name: cDbUpdateHandler
73886>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
73886>>>// Web-site    : http://www.rdctools.com
73886>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
73886>>>//
73886>>>// Purpose     : A framework for doing automated code based updates of a database from within
73886>>>//               a program, when it is started.
73886>>>//
73886>>>// Description : Place _one_ object of this class right after the cApplication object.
73886>>>//               Then inside this object place a series of cDbUpdateVersion objects
73886>>>//               as childs. One child object for each new database update.
73886>>>//
73886>>>//               - OnPreUpdate is a pre-processing event called
73886>>>//               before any database changes are started.
73886>>>//               - OnPostUpdate is a post-processing event called after all
73886>>>//               database changes have taken place.
73886>>>//
73886>>>// Note        : If tables have been opened prior to an object of this class
73886>>>//               (e.g. in the cApplication object), those tables will be closed.
73886>>>//               In that case you need to use the OnPostUpdate hook event to re-open
73886>>>//               tables after the last update has finished.
73886>>>//
73886>>>// Security    : Before an update is attempted; three things are checked to ensure the
73886>>>//               database is not in use. Aka nobody else is running the application.
73886>>>//               - All tables are tested for "Open in Exclusive_Mode"
73886>>>//               - The DataFlex license User Count is checked - cannot be more than 1, unless the
73886>>>//                 pbCheckDataFlexUserCount is set to False (Default = True)
73886>>>//               - A special user count file ("DbUpdateUserCount.ucf") is created in the Programs
73886>>>//                 folder and a bit-lock is performed for each start of the application and this
73886>>>//                 user counter is checked before an update is attempted.
73886>>>//                 Important: Even if it seems like both garters & suspenders are used to guard
73886>>>//                            against the database being "in use", there is no such guarantee! The
73886>>>//                            database could e.g. be open in "Microsoft SQL Server Management Studio"
73886>>>//                            and there is no way of telling. SO BE CAUTIOUS before attempting an update!
73886>>>//                 A second "user count file" is also used - "DbUpdateLock.ucf". It is used to
73886>>>//                 lock everybody else out (with a Stop box) while the database is being updated. The lock will
73886>>>//                 automatically be released after the update is completed.
73886>>>//
73886>>>//
73886>>>// Usage       :  Use cDbUpdateHandler.pkg
73886>>>//                Object oDatabaseUpdateHandler is a cDbUpdateHandler
73886>>>//                    // Declare the table that contains a "database version" field.
73886>>>//                    Declare_Datafile Sys
73886>>>//                    // Either one of these syntaxes is fine:
73886>>>//                    Set Data_File_Field to File_Field Sys.DbUpdateVersion
73886>>>//                    Set Data_File_Field to (RefTable(Sys)) (RefTable(Sys.DbUpdateVersion))
73886>>>//
73886>>>//                    // Don't forget to increase the pnVersionNumber property for each
73886>>>//                    // cDbUpdateVersion object!
73886>>>//                    // The VersionTableColumn field/column specified above will be updated automatically
73886>>>//                    // with the value of pnVersionNumber after each update has been finished.
73886>>>//                    Object oVersionUpdate1.1 is a cDbUpdateVersion
73886>>>//                        Set pnVersionNumber to 1.1
73886>>>//                        Use VersionUpdate1_1.pkg
73886>>>//                    End_Object
73886>>>//
73886>>>//                    Object oVersionUpdate1.2 is a cDbUpdateVersion
73886>>>//                        Set pnVersionNumber to 1.2
73886>>>//                        Use VersionUpdate1_2.pkg
73886>>>//                    End_Object
73886>>>//
73886>>>//                End_Object
73886>>>//
73886>>>// *** To use the pbRestoreIntFilesNow & pbSaveIntFilesNow properties, the pbUseIntFilesBackup property needs to be True.
73886>>>//     Sample Code:
73886>>>//                Object oApplication is a cApplication
73886>>>//                    Set peHelpType to htHtmlHelp
73886>>>//                
73886>>>//                    Object oConnection is a cConnection
73886>>>//                        Use LoginEncryption.pkg
73886>>>//                        Use DatabaseLoginDialog.dg
73886>>>//                    End_Object
73886>>>//                
73886>>>//                    Property Boolean pbRestoreIntFilesNow False
73886>>>//                    Property Boolean pbSaveIntFilesNow False
73886>>>//                    // This allows the program to have the parameter "-restore" passed on the command line.
73886>>>//                    // If found, it will call the "RestoreIntFiles" of the cDbUpdateHandler object.
73886>>>//                    Procedure OnCreate
73886>>>//                        Handle hoCmdLine
73886>>>//                        Integer iSize iCount
73886>>>//                        String sParam
73886>>>//                        
73886>>>//                        Get phoCommandLine to hoCmdLine
73886>>>//                        Get CountOfArgs of hoCmdLine to iSize
73886>>>//                        For iCount from 1 to iSize
73886>>>//                            Get Argument of hoCmdLine iCount to sParam
73886>>>//                            If (Lowercase(sParam) contains "restore") Begin
73886>>>//                                Set pbRestoreIntFilesNow to True
73886>>>//                            End
73886>>>//                            Else If (Lowercase(sParam) contains "save") Begin
73886>>>//                                Set pbSaveIntFilesNow to True
73886>>>//                            End
73886>>>//                        Loop
73886>>>//                    End_Procedure
73886>>>//                
73886>>>//                End_Object
73886>>>//
73886>>>//                Object oDbUpdateHandler is a cDbUpdateHandler
73886>>>//                    Set piDbVersionFileNumber  to 255
73886>>>//                    Set piDbVersionFieldNumber to 1
73886>>>//                    Set phIntFilesTable to 256
73886>>>//                    Set pbUseIntFilesBackup to True
73886>>>//                    Set pbExitIfDebuggerActive to False
73886>>>//                
73886>>>//                    Procedure OnCreate
73886>>>//                        String sVersionInfo sErrorText
73886>>>//                        Boolean bRestoreIntFilesNow bSaveIntFilesNow bOK
73886>>>//                        
73886>>>//                        Get pbRestoreIntFilesNow of ghoApplication to bRestoreIntFilesNow
73886>>>//                        If (bRestoreIntFilesNow = True) Begin
73886>>>//                            Send RestoreIntFiles
73886>>>//                        End
73886>>>//                        Get pbSaveIntFilesNow of ghoApplication to bSaveIntFilesNow
73886>>>//                        If (bSaveIntFilesNow = True) Begin
73886>>>//                            Get SaveUpdateIntFiles (&sErrorText) to bOK
73886>>>//                        End 
73886>>>//                        
73886>>>//                        // To check for correct the driver and db client versions, when the program starts (each-Time it is started!)
73886>>>//                        Get MinMSSQLDRV_And_ClientVersion "24.0.29.10" SQLSERVER2019CLIENT True True to sVersionInfo
73886>>>//                    End_Procedure
73886>>>// ******************
73886>>>
73886>>>
73886>>>
73886>>>//
73886>>>// $Rev History:
73886>>>//    2016-09-27  Module header created
73886>>>//    2016-09-28  Removed the Master/Alias logic. All update code must
73886>>>//                take place before any tables have been opened, or errors
73886>>>//                could occur if the client database is out of sync with the
73886>>>//                compiled program.
73886>>>//                Added user counting checks + lockout while database is being
73886>>>//                updated.
73886>>>//    2016-10-03  Changed the class name from cDatabaseUpdateHandler to cDbUpdateHandler,
73886>>>//                as it is more in line with the child class cDbUpdateVersion name.
73886>>>//    2016-10-06  Moved constant declarations, structs etc. to separate cDbUpdateHandler.inc file
73886>>>//****************************************************************************
73886>>>Use VdfBase.pkg
73886>>>Use Dferror.pkg
73886>>>Use seq_chnl.pkg
73886>>>Use Datadict.pkg
73886>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
73886>>>>>// *** The Database Update Framework Include file for Languages ***
73886>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
73886>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
73886>>>>>//
73886>>>>>Use LanguageText.Pkg
73886>>>>>
73886>>>>>    // *** cSQLConnectionsIniFile.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
73886>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
73886>>>>>    // *** cSQLConnectionsHandler.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_SetupErrorcConnection     for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
73886>>>>>    Define CS_DUF_CannotLoginToServer       for "Could not login to the database server. Can't continue. Program will now exit."
73886>>>>>    Define CS_DUF_ErrorText                 for "\n\nError Text:"
73886>>>>>    // *** cDbUpdateFunctionLibrary.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_ConnectError              for "SQL error. Could not connect to the SQL database manager"
73886>>>>>    Define CS_DUF_AttachError               for "Could not attach to the database:"
73886>>>>>    Define CS_DUF_DeletingIndex             for "Deleting index"
73886>>>>>    Define CS_DUF_CopyingData               for "Copying data"
73886>>>>>    Define CS_DUF_CreatingIndex             for "Creating index"
73886>>>>>    Define CS_DUF_LoginToDbServerFailed     for  "Login failed to the database server. The following connect string was used:\n"
73886>>>>>    Define CS_DUF_DoYouWantToExit           for "Do you want to stop the database update and exit?"  
73886>>>>>    Define CS_DUF_NoIntFilesFound           for "No .int files found! Nothing was changed."
73886>>>>>    // *** cDbUpdateVersion.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_UpdateVersion             for "Updating database"
73886>>>>>    Define CS_DUF_UpdateFromVersion         for "from version"
73886>>>>>    Define CS_DUF_UpdateToVersion           for "to version:"
73886>>>>>    Define CS_DUF_DbUpdateTableMissing      for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
73886>>>>>    // *** cDbUpdateHandler.inc Language Constants ***
73886>>>>>    Define CS_DUF_DatabaseInUseShort        for "There are others using the application/database. Are you sure you still want to update the database?"
73886>>>>>    Define CS_DUF_DatabaseNeedsUpdate       for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
73886>>>>>    Define CS_DUF_HeaderUpdateText          for "Important!"
73886>>>>>    Define CS_DUF_DatabaseInUseText         for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
73886>>>>>    Define CS_DUF_WorkingHeaderText         for "Working!"
73886>>>>>    Define CS_DUF_WorkingUpdateText         for "The database is being updated. Please wait..."
73886>>>>>    Define CS_DUF_DatabaseUpdatedText       for "Ready! The database was updated."
73886>>>>>    Define CS_DUF_DatabaseCheckedText       for "Ready! The database was checked but no updates was needed."
73886>>>>>    Define CS_DUF_DbUpdatedErrorText        for "One or more errors occured while the database was updated. Please check the logfile in the data-folder.\n\nThe program will now close."
73886>>>>>    Define CS_DUF_UpdateInProgressTxt       for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
73886>>>>>    // *** cDbUpdateHandler.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_DatabaseConnStringSpec    for "The database specified in the connection string: '"
73886>>>>>    Define CS_DUF_DatabaseDoesntExist       for "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit."
73886>>>>>    // *** cDbUpdateLogFile.pkg Class Language Constants ***   
73886>>>>>    Define CS_DUF_LogFileNotFound           for "Could not locate the log file:\n\n"
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
73886>>>>>// StatPnl.pkg - creates the standard status_panel object.
73886>>>>>//
73886>>>>>//
73886>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
73886>>>>>// invoke the standard status panel. The standard has always been that the package name
73886>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
73886>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
73886>>>>>// prior revisions has been replace with status panel that is part of the application.
73886>>>>>// This should work much better and faster than the old sentinel based solution.
73886>>>>>// While the way this operates has changed, the interface has not and therefore this should work
73886>>>>>// with most applications.
73886>>>>>//
73886>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
73886>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
73886>>>>>// a cleaner more robust interface.
73886>>>>>//
73886>>>>>//
73886>>>>>// Compatibility Note:
73886>>>>>//
73886>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
73886>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
73886>>>>>//
73886>>>>>// If for some reason you application will not work using this as a replacement for the old status
73886>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
73886>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
73886>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
73886>>>>>//
73886>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
73886>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
73886>>>>>//
73886>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
73886>>>>>// can still access the new object via the ghoStatusPanel handle.
73886>>>>>//
73886>>>>>//
73886>>>>>// Creating your own Status Panel objects
73886>>>>>//
73886>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
73886>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
73886>>>>>// with a different file and object name and direct your status panel request to the new object.
73886>>>>>//
73886>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
73886>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
73886>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
73886>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
73886>>>>>// e.g.
73886>>>>>//       Procedure UpdateStatusBar
73886>>>>>//           Send DoAdvance of oProgressBar
73886>>>>>//           Send ProcessEvents
73886>>>>>//       End_Procedure
73886>>>>>//
73886>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
73886>>>>>// messages this will be done for you.
73886>>>>>//
73886>>>>>// the standard Interface for status panels are:
73886>>>>>//
73886>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
73886>>>>>// Send Start_StatusPanel      - start the status panel
73886>>>>>// Send Stop_StatusPanel       - stop the status panel
73886>>>>>// Send Update_StatusPanel     - update the status panel's action area
73886>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
73886>>>>>//
73886>>>>>// Get/Set Caption_Text - updates the caption bar
73886>>>>>// Get/Set Title_Text   - updates the title area
73886>>>>>// Get/Set Message_Text - updates the Message area
73886>>>>>// Get/Set Action_Text  - updates the action area
73886>>>>>// Get/Set Button_Text  - updates the button area
73886>>>>>//
73886>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
73886>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
73886>>>>>//
73886>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
73886>>>>>Use cProcessStatusPanel.pkg
73886>>>>>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJSkinFramework.pkg)
73886>>>>>>>Use windows.pkg
73886>>>>>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJComSkinFramework.pkg)
73886>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v22.0.0\Bin\Codejock.SkinFramework.Unicode.x64.v22.0.0.ocx
73886>>>>>>>>>Use FlexCom20.pkg
73886>>>>>>>>>
73886>>>>>>>>>// Changes to Imported package
73886>>>>>>>>>//     OLEXTPxx to XTPxx
73886>>>>>>>>>//     OLExtpxx to xtpxx
73886>>>>>>>>>//     OLESkinFramework to SkinFramework
73886>>>>>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
73886>>>>>>>>>//     cCom classes to cCJ
73886>>>>>>>>>//     cCJAutomationObject back to cComAutomationObject
73886>>>>>>>>>//     cCJActiveXControl back to cComActiveXControl
73886>>>>>>>>>//     cCJSkinFramework to cCJComSkinFramework
73886>>>>>>>>>//     Use statements as noted below (classes moved to these files)
73886>>>>>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
73886>>>>>>>>>
73886>>>>>>>>>// These have been extracted from this class and moved into seperate packages
73886>>>>>>>>>// because other Codejock classes use these.
73886>>>>>>>>>Use cCJColorManager.pkg     // cCJColorManager
73886>>>>>>>>>
73886>>>>>>>>>
73886>>>>>>>>>Define SkinFrameworkApplyOptions for Integer
73886>>>>>>>>>    Define xtpSkinApplyMetrics for 1
73886>>>>>>>>>    Define xtpSkinApplyFrame for 2
73886>>>>>>>>>    Define xtpSkinApplyColors for 4
73886>>>>>>>>>    Define xtpSkinApplyMenus for 8
73886>>>>>>>>>
73886>>>>>>>>>// CLSID: {C0DE2200-28D7-4F2C-87A7-7266367B4655}
73886>>>>>>>>>// Dispatch interface for SkinFramework Control
73886>>>>>>>>>Class cCJ_DSkinFramework is a Mixin
73887>>>>>>>>>
73887>>>>>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
73889>>>>>>>>>        SkinFrameworkApplyOptions retVal
73889>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
73890>>>>>>>>>        Function_Return retVal
73891>>>>>>>>>    End_Function
73892>>>>>>>>>
73892>>>>>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
73894>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
73895>>>>>>>>>    End_Procedure
73896>>>>>>>>>
73896>>>>>>>>>    Function ComAutoApplyNewWindows Returns Boolean
73898>>>>>>>>>        Boolean retVal
73898>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
73899>>>>>>>>>        Function_Return retVal
73900>>>>>>>>>    End_Function
73901>>>>>>>>>
73901>>>>>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
73903>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
73904>>>>>>>>>    End_Procedure
73905>>>>>>>>>
73905>>>>>>>>>    Function ComAutoApplyNewThreads Returns Boolean
73907>>>>>>>>>        Boolean retVal
73907>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
73908>>>>>>>>>        Function_Return retVal
73909>>>>>>>>>    End_Function
73910>>>>>>>>>
73910>>>>>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
73912>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
73913>>>>>>>>>    End_Procedure
73914>>>>>>>>>
73914>>>>>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
73916>>>>>>>>>        Handle hDispatchDriver
73916>>>>>>>>>        Boolean retVal
73916>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73917>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73918>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
73919>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
73920>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
73921>>>>>>>>>        Function_Return retVal
73922>>>>>>>>>    End_Function
73923>>>>>>>>>
73923>>>>>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
73925>>>>>>>>>        Handle hDispatchDriver
73925>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73926>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73927>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73928>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
73929>>>>>>>>>    End_Procedure
73930>>>>>>>>>
73930>>>>>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
73932>>>>>>>>>        Handle hDispatchDriver
73932>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73933>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73934>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73935>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
73936>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
73937>>>>>>>>>    End_Procedure
73938>>>>>>>>>
73938>>>>>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
73940>>>>>>>>>        Handle hDispatchDriver
73940>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73941>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73942>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73943>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
73944>>>>>>>>>    End_Procedure
73945>>>>>>>>>
73945>>>>>>>>>    Procedure ComRemoveAllWindows
73947>>>>>>>>>        Handle hDispatchDriver
73947>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73948>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
73949>>>>>>>>>    End_Procedure
73950>>>>>>>>>
73950>>>>>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
73952>>>>>>>>>        Handle hDispatchDriver
73952>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73953>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73954>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
73955>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
73956>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
73957>>>>>>>>>    End_Procedure
73958>>>>>>>>>
73958>>>>>>>>>    Procedure ComRemoveWindowClass String llClassName
73960>>>>>>>>>        Handle hDispatchDriver
73960>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73961>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73962>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
73963>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
73964>>>>>>>>>    End_Procedure
73965>>>>>>>>>
73965>>>>>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
73967>>>>>>>>>        Handle hDispatchDriver
73967>>>>>>>>>        Variant retVal
73967>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73968>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73969>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
73970>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
73971>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
73972>>>>>>>>>        Function_Return retVal
73973>>>>>>>>>    End_Function
73974>>>>>>>>>
73974>>>>>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
73976>>>>>>>>>        Handle hDispatchDriver
73976>>>>>>>>>        Variant retVal
73976>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73977>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73978>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
73979>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
73980>>>>>>>>>        Function_Return retVal
73981>>>>>>>>>    End_Function
73982>>>>>>>>>
73982>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
73984>>>>>>>>>        Handle hDispatchDriver
73984>>>>>>>>>        OLE_COLOR retVal
73984>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73985>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73986>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
73987>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
73988>>>>>>>>>        Function_Return retVal
73989>>>>>>>>>    End_Function
73990>>>>>>>>>
73990>>>>>>>>>    Procedure ComExcludeModule String llModuleName
73992>>>>>>>>>        Handle hDispatchDriver
73992>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73993>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73994>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
73995>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
73996>>>>>>>>>    End_Procedure
73997>>>>>>>>>
73997>>>>>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
73999>>>>>>>>>        Handle hDispatchDriver
73999>>>>>>>>>        Variant retVal
73999>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74000>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74001>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
74002>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
74003>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
74004>>>>>>>>>        Function_Return retVal
74005>>>>>>>>>    End_Function
74006>>>>>>>>>
74006>>>>>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
74008>>>>>>>>>        Handle hDispatchDriver
74008>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74009>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74010>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74011>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
74012>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
74013>>>>>>>>>    End_Procedure
74014>>>>>>>>>
74014>>>>>>>>>    Procedure ComAboutBox
74016>>>>>>>>>        Handle hDispatchDriver
74016>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74017>>>>>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
74018>>>>>>>>>    End_Procedure
74019>>>>>>>>>End_Class
74020>>>>>>>>>
74020>>>>>>>>>// CLSID: {C0DE2200-4463-4030-B324-AC6A8075FEC8}
74020>>>>>>>>>// Event interface for SkinFramework Control
74020>>>>>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
74021>>>>>>>>>
74021>>>>>>>>>    Procedure RegisterComEvents
74023>>>>>>>>>    End_Procedure
74024>>>>>>>>>End_Class
74025>>>>>>>>>
74025>>>>>>>>>// CoClass
74025>>>>>>>>>// ProgID: Codejock.SkinFramework.22.0.0
74025>>>>>>>>>// CLSID: {C0DE2200-2217-42EE-B1B0-82C890431F17}
74025>>>>>>>>>// SkinFramework Control
74025>>>>>>>>>Class cCJComSkinFramework is a cComActiveXControl
74026>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFramework
74027>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
74028>>>>>>>>>
74028>>>>>>>>>    Procedure Construct_Object
74030>>>>>>>>>        Forward Send Construct_Object
74032>>>>>>>>>        Set psProgID to "{C0DE2200-2217-42EE-B1B0-82C890431F17}"
74033>>>>>>>>>        Set psEventId to "{C0DE2200-4463-4030-B324-AC6A8075FEC8}"
74034>>>>>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2022 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v22.0"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
74035>>>>>>>>>        Set peAutoCreate to acAutoCreate
74036>>>>>>>>>    End_Procedure
74037>>>>>>>>>End_Class
74038>>>>>>>>>
74038>>>>>>>>>// CLSID: {C0DE2200-CA9A-4AA9-8601-0AB7F551AA3D}
74038>>>>>>>>>// SkinFramework Global Settings
74038>>>>>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
74039>>>>>>>>>
74039>>>>>>>>>    Function ComLicense Returns String
74041>>>>>>>>>        String retVal
74041>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
74042>>>>>>>>>        Function_Return retVal
74043>>>>>>>>>    End_Function
74044>>>>>>>>>
74044>>>>>>>>>    Procedure Set ComLicense String value
74046>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
74047>>>>>>>>>    End_Procedure
74048>>>>>>>>>
74048>>>>>>>>>    Function ComTitle Returns String
74050>>>>>>>>>        String retVal
74050>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
74051>>>>>>>>>        Function_Return retVal
74052>>>>>>>>>    End_Function
74053>>>>>>>>>
74053>>>>>>>>>    Procedure Set ComTitle String value
74055>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
74056>>>>>>>>>    End_Procedure
74057>>>>>>>>>
74057>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74057>>>>>>>>>    Function ComUseLegacyCore Returns Boolean
74059>>>>>>>>>        Boolean retVal
74059>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to retVal
74060>>>>>>>>>        Function_Return retVal
74061>>>>>>>>>    End_Function
74062>>>>>>>>>
74062>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74062>>>>>>>>>    Procedure Set ComUseLegacyCore Boolean value
74064>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to value
74065>>>>>>>>>    End_Procedure
74066>>>>>>>>>
74066>>>>>>>>>    Function ComVersion Returns String
74068>>>>>>>>>        Handle hDispatchDriver
74068>>>>>>>>>        String retVal
74068>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74069>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
74070>>>>>>>>>        Function_Return retVal
74071>>>>>>>>>    End_Function
74072>>>>>>>>>
74072>>>>>>>>>    Function ComUnicode Returns Boolean
74074>>>>>>>>>        Handle hDispatchDriver
74074>>>>>>>>>        Boolean retVal
74074>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74075>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
74076>>>>>>>>>        Function_Return retVal
74077>>>>>>>>>    End_Function
74078>>>>>>>>>
74078>>>>>>>>>    Function ComOcxPath Returns String
74080>>>>>>>>>        Handle hDispatchDriver
74080>>>>>>>>>        String retVal
74080>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74081>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
74082>>>>>>>>>        Function_Return retVal
74083>>>>>>>>>    End_Function
74084>>>>>>>>>End_Class
74085>>>>>>>>>
74085>>>>>>>>>// CoClass
74085>>>>>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.22.0.0
74085>>>>>>>>>// CLSID: {C0DE2200-F744-4373-B38D-29CE83EF0EE5}
74085>>>>>>>>>// SkinFramework Global Settings
74085>>>>>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
74086>>>>>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
74087>>>>>>>>>
74087>>>>>>>>>    Procedure Construct_Object
74089>>>>>>>>>        Forward Send Construct_Object
74091>>>>>>>>>        Set psProgID to "{C0DE2200-F744-4373-B38D-29CE83EF0EE5}"
74092>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
74093>>>>>>>>>    End_Procedure
74094>>>>>>>>>End_Class
74095>>>>>>>>>
74095>>>>>>>>>// CLSID: {C0DE2200-1038-498E-A936-361F08B4C4AA}
74095>>>>>>>>>Class cCJSkinIniFile is a cComAutomationObject
74096>>>>>>>>>
74096>>>>>>>>>    Function ComColorScheme Returns String
74098>>>>>>>>>        String retVal
74098>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74099>>>>>>>>>        Function_Return retVal
74100>>>>>>>>>    End_Function
74101>>>>>>>>>
74101>>>>>>>>>    Procedure Set ComColorScheme String value
74103>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74104>>>>>>>>>    End_Procedure
74105>>>>>>>>>
74105>>>>>>>>>    Function ComFontSize Returns String
74107>>>>>>>>>        String retVal
74107>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74108>>>>>>>>>        Function_Return retVal
74109>>>>>>>>>    End_Function
74110>>>>>>>>>
74110>>>>>>>>>    Procedure Set ComFontSize String value
74112>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74113>>>>>>>>>    End_Procedure
74114>>>>>>>>>
74114>>>>>>>>>    Function ComIniFileName Returns String
74116>>>>>>>>>        String retVal
74116>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
74117>>>>>>>>>        Function_Return retVal
74118>>>>>>>>>    End_Function
74119>>>>>>>>>
74119>>>>>>>>>    Procedure Set ComIniFileName String value
74121>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
74122>>>>>>>>>    End_Procedure
74123>>>>>>>>>End_Class
74124>>>>>>>>>
74124>>>>>>>>>// CLSID: {C0DE2200-4834-499E-95B4-30E0C3F43A10}
74124>>>>>>>>>Class cCJSkinDescription is a cComAutomationObject
74125>>>>>>>>>
74125>>>>>>>>>    Function ComName Returns String
74127>>>>>>>>>        String retVal
74127>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74128>>>>>>>>>        Function_Return retVal
74129>>>>>>>>>    End_Function
74130>>>>>>>>>
74130>>>>>>>>>    Procedure Set ComName String value
74132>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74133>>>>>>>>>    End_Procedure
74134>>>>>>>>>
74134>>>>>>>>>    Function ComPath Returns String
74136>>>>>>>>>        String retVal
74136>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74137>>>>>>>>>        Function_Return retVal
74138>>>>>>>>>    End_Function
74139>>>>>>>>>
74139>>>>>>>>>    Procedure Set ComPath String value
74141>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74142>>>>>>>>>    End_Procedure
74143>>>>>>>>>
74143>>>>>>>>>    Function ComCount Returns Integer
74145>>>>>>>>>        Handle hDispatchDriver
74145>>>>>>>>>        Integer retVal
74145>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74146>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74147>>>>>>>>>        Function_Return retVal
74148>>>>>>>>>    End_Function
74149>>>>>>>>>
74149>>>>>>>>>    Function ComIniFile Integer llIndex Returns Variant
74151>>>>>>>>>        Handle hDispatchDriver
74151>>>>>>>>>        Variant retVal
74151>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74152>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74153>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74154>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74155>>>>>>>>>        Function_Return retVal
74156>>>>>>>>>    End_Function
74157>>>>>>>>>
74157>>>>>>>>>    Function Com_NewEnum Returns Variant
74159>>>>>>>>>        Handle hDispatchDriver
74159>>>>>>>>>        Variant retVal
74159>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74160>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74161>>>>>>>>>        Function_Return retVal
74162>>>>>>>>>    End_Function
74163>>>>>>>>>End_Class
74164>>>>>>>>>
74164>>>>>>>>>// CLSID: {C0DE2200-FB37-4B08-A2B9-F6F8B253D697}
74164>>>>>>>>>Class cCJSkinDescriptions is a cComAutomationObject
74165>>>>>>>>>
74165>>>>>>>>>    Function ComCount Returns Integer
74167>>>>>>>>>        Handle hDispatchDriver
74167>>>>>>>>>        Integer retVal
74167>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74168>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74169>>>>>>>>>        Function_Return retVal
74170>>>>>>>>>    End_Function
74171>>>>>>>>>
74171>>>>>>>>>    Function ComSkin Integer llIndex Returns Variant
74173>>>>>>>>>        Handle hDispatchDriver
74173>>>>>>>>>        Variant retVal
74173>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74174>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74175>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74176>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74177>>>>>>>>>        Function_Return retVal
74178>>>>>>>>>    End_Function
74179>>>>>>>>>
74179>>>>>>>>>    Function Com_NewEnum Returns Variant
74181>>>>>>>>>        Handle hDispatchDriver
74181>>>>>>>>>        Variant retVal
74181>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74182>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74183>>>>>>>>>        Function_Return retVal
74184>>>>>>>>>    End_Function
74185>>>>>>>>>End_Class
74186>>>>>>>>>
74186>>>>>>>>>// CLSID: {C0DE2200-C56F-43C0-BCF1-8193B35FE4C4}
74186>>>>>>>>>Class cCJSkinSchema is a cComAutomationObject
74187>>>>>>>>>
74187>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
74189>>>>>>>>>        Handle hDispatchDriver
74189>>>>>>>>>        OLE_COLOR retVal
74189>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74190>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74191>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74192>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
74193>>>>>>>>>        Function_Return retVal
74194>>>>>>>>>    End_Function
74195>>>>>>>>>End_Class
74196>>>>>>>Use cApplication.pkg
74196>>>>>>>
74196>>>>>>>Struct tSkinInformation
74196>>>>>>>    String sName     // description of the skin
74196>>>>>>>    String sSkinfile // file path. Can be relative or full
74196>>>>>>>    String sSkinIni  // section name
74196>>>>>>>End_Struct
74196>>>>>>>
74196>>>>>>>
74196>>>>>>>Class cCJSkinFramework is a cCJComSkinFramework
74197>>>>>>>    
74197>>>>>>>    Procedure Construct_Object
74199>>>>>>>        Forward Send Construct_Object
74201>>>>>>>        
74201>>>>>>>        Property String psSkinFile ""
74202>>>>>>>        Property String psSkinIni ""
74203>>>>>>>        Property Boolean pbLoadPreference False
74204>>>>>>>        
74204>>>>>>>        Set peAutoCreate to acAutoCreate
74205>>>>>>>        
74205>>>>>>>        Move Self to ghoSkinFramework
74206>>>>>>>    End_Procedure
74207>>>>>>>    
74207>>>>>>>    // return the default skin path, which is the programs directory.
74207>>>>>>>    // This requires an application object.
74207>>>>>>>    // If you want to different skin path, override this.
74207>>>>>>>    Function SkinPath Returns String
74209>>>>>>>        String sPath sPaths
74209>>>>>>>        Handle hoWorkspace
74209>>>>>>>        If ghoApplication Begin
74211>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
74212>>>>>>>            Get psProgramPath of hoWorkspace to sPaths
74213>>>>>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
74214>>>>>>>        End
74214>>>>>>>>
74214>>>>>>>        Else Begin
74215>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74216>>>>>>>>
74216>>>>>>>        End
74216>>>>>>>>
74216>>>>>>>        Function_Return sPath
74217>>>>>>>    End_Function
74218>>>>>>>    
74218>>>>>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
74218>>>>>>>    // returns itself. If it is not, it uses SkinPath to get the path.
74218>>>>>>>    Function SkinQFile Returns String
74220>>>>>>>        String sFile sPath sSep
74220>>>>>>>        Boolean bQualified
74220>>>>>>>        Get psSkinFile to sFile
74221>>>>>>>        If not (IsFileNameQualified(sFile)) Begin
74223>>>>>>>            Get SkinPath to sPath
74224>>>>>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74225>>>>>>>            Move (sPath - sSep - sFile) to sFile
74226>>>>>>>        End
74226>>>>>>>>
74226>>>>>>>        Function_Return sFile
74227>>>>>>>    End_Function
74228>>>>>>>    
74228>>>>>>>    // defines the default VDF window class mapping.
74228>>>>>>>    Procedure OnAddVDFWindowClasses
74230>>>>>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
74231>>>>>>>        Send ComAddWindowClass "DFentry"                 "Edit"
74232>>>>>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
74233>>>>>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
74234>>>>>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
74235>>>>>>>        Send ComAddWindowClass "DFformlist"              "Edit"
74236>>>>>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
74237>>>>>>>        Send ComAddWindowClass "DFbutton"                "Button"
74238>>>>>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
74239>>>>>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
74240>>>>>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
74241>>>>>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
74242>>>>>>>        Send ComAddWindowClass "DFedit"                  "edit"
74243>>>>>>>        Send ComAddWindowClass "DFlistedit"              "edit"
74244>>>>>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
74245>>>>>>>        Send ComAddWindowClass "DFgroup"                 "Button"
74246>>>>>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
74247>>>>>>>        // External class
74247>>>>>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
74248>>>>>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
74249>>>>>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
74250>>>>>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
74251>>>>>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
74252>>>>>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
74253>>>>>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
74254>>>>>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
74255>>>>>>>    End_Procedure
74256>>>>>>>    
74256>>>>>>>    // Used to support developer designed class mappings (e.g. COM controls)
74256>>>>>>>    Procedure OnAddCustomWindowClasses
74258>>>>>>>    End_Procedure
74259>>>>>>>    
74259>>>>>>>    // called when object is created during end_construct_object.
74259>>>>>>>    Procedure OnCreate
74261>>>>>>>        Integer iOpts
74261>>>>>>>        Boolean bUseWindowsFont
74261>>>>>>>        Forward Send OnCreate
74263>>>>>>>        
74263>>>>>>>        // if we are using the windows fonts we will disable the apply metrics which
74263>>>>>>>        // never really looked good anyway. This test only exists or legacy purposes
74263>>>>>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
74264>>>>>>>        If bUseWindowsFont Begin
74266>>>>>>>            Get ComApplyOptions to iOpts
74267>>>>>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
74268>>>>>>>        End
74268>>>>>>>>
74268>>>>>>>        
74268>>>>>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
74268>>>>>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
74268>>>>>>>        // and this was the suggested workaround.
74268>>>>>>>        Set ComAutoApplyNewThreads to False
74269>>>>>>>        
74269>>>>>>>        Send OnAddVDFWindowClasses
74270>>>>>>>        Send OnAddCustomWindowClasses
74271>>>>>>>        
74271>>>>>>>        // if preferences are used, it will set psSkinFile and psSkinIni
74271>>>>>>>        If (pbLoadPreference(Self)) Begin
74273>>>>>>>            Send LoadSkinPreference
74274>>>>>>>        End
74274>>>>>>>>
74274>>>>>>>        // if a skin file name exists, we apply the skin.
74274>>>>>>>        If (psSkinFile(Self)<>"") Begin
74276>>>>>>>            Send ApplySkin
74277>>>>>>>        End
74277>>>>>>>>
74277>>>>>>>    End_Procedure
74278>>>>>>>    
74278>>>>>>>    // called by framework as part of application exit.
74278>>>>>>>    Procedure Broadcast_Notify_Exit_Application
74280>>>>>>>        Send Notify_Exit_Application
74281>>>>>>>    End_Procedure
74282>>>>>>>    
74282>>>>>>>    Procedure Notify_Exit_Application
74284>>>>>>>        If (pbLoadPreference(Self)) Begin
74286>>>>>>>            Send SaveSkinPreference
74287>>>>>>>        End
74287>>>>>>>>
74287>>>>>>>    End_Procedure
74288>>>>>>>    
74288>>>>>>>    Procedure NotifyPreApplySkin
74290>>>>>>>        Broadcast Send OnPreApplySkin of Desktop True
74292>>>>>>>    End_Procedure
74293>>>>>>>    
74293>>>>>>>    Procedure NotifyPostApplySkin
74295>>>>>>>        Broadcast Send OnPostApplySkin of Desktop True
74297>>>>>>>    End_Procedure
74298>>>>>>>    
74298>>>>>>>    // returns an array of all skins in the path. If path is "", use the default path.
74298>>>>>>>    // If the default path is used, returns the file names as relative names, else use full path.
74298>>>>>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
74300>>>>>>>        tSkinInformation[] Skins
74300>>>>>>>        tSkinInformation[] Skins
74301>>>>>>>        String sSkinName sSkinFile sDefaultPath sSep
74301>>>>>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
74301>>>>>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
74301>>>>>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
74301>>>>>>>        Integer iPos iDfltLen
74301>>>>>>>        Boolean bUseRelativePath
74301>>>>>>>        
74301>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74302>>>>>>>        
74302>>>>>>>        Get SkinPath to sDefaultPath
74303>>>>>>>        If (sPath="") Begin
74305>>>>>>>            Move sDefaultPath to sPath
74306>>>>>>>        End
74306>>>>>>>>
74306>>>>>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
74307>>>>>>>        Move (Length(sDefaultPath)) to iDfltLen
74308>>>>>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
74309>>>>>>>        
74309>>>>>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
74310>>>>>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
74312>>>>>>>            
74312>>>>>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
74313>>>>>>>            Get Create U_cCJSkinDescription to hSkinDescription
74314>>>>>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
74315>>>>>>>            
74315>>>>>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
74316>>>>>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
74317>>>>>>>            
74317>>>>>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
74323>>>>>>>>
74323>>>>>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
74324>>>>>>>                Set pvComObject of hSkinDescription to vSkinDescription
74325>>>>>>>                
74325>>>>>>>                Get ComCount of hSkinDescription to iNumSkins
74326>>>>>>>                
74326>>>>>>>                For iSkinsCount from 0 to (iNumSkins-1)
74332>>>>>>>>
74332>>>>>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
74333>>>>>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
74334>>>>>>>                    
74334>>>>>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
74335>>>>>>>                    Get ComPath of hSkinDescription to sSkinFile
74336>>>>>>>                    If bUseRelativePath Begin
74338>>>>>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
74339>>>>>>>                        If iPos Begin
74341>>>>>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
74342>>>>>>>                            While (Left(sSkinFile,1)=sSep)
74346>>>>>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
74347>>>>>>>                            Loop
74348>>>>>>>>
74348>>>>>>>                        End
74348>>>>>>>>
74348>>>>>>>                    End
74348>>>>>>>>
74348>>>>>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
74349>>>>>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
74350>>>>>>>                    
74350>>>>>>>                    Increment iArrayItem
74351>>>>>>>                Loop
74352>>>>>>>>
74352>>>>>>>            Loop
74353>>>>>>>>
74353>>>>>>>            
74353>>>>>>>            Send Destroy of hSkinDescriptions
74354>>>>>>>            Send Destroy of hSkinDescription
74355>>>>>>>            Send Destroy of hSkinIniFile
74356>>>>>>>            
74356>>>>>>>        End
74356>>>>>>>>
74356>>>>>>>        Function_Return Skins
74357>>>>>>>    End_Function
74358>>>>>>>    
74358>>>>>>>    // Save the skin preference. This requires an application object.
74358>>>>>>>    // Only do this if the application object allows it.
74358>>>>>>>    // This is called during startup if pbLoadPreference is True
74358>>>>>>>    // Suitable for override
74358>>>>>>>    Procedure SaveSkinPreference
74360>>>>>>>        String sSkin sIni
74360>>>>>>>        If ghoApplication Begin
74362>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74364>>>>>>>                Get psSkinFile to sSkin
74365>>>>>>>                Get psSkinIni to sIni
74366>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
74367>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
74368>>>>>>>            End
74368>>>>>>>>
74368>>>>>>>        End
74368>>>>>>>>
74368>>>>>>>        Else Begin
74369>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74370>>>>>>>>
74370>>>>>>>        End
74370>>>>>>>>
74370>>>>>>>    End_Procedure
74371>>>>>>>    
74371>>>>>>>    // Load the skin preference. This requires an application object.
74371>>>>>>>    // Only do this if the application object allows it.
74371>>>>>>>    // This is called during startup if pbLoadPreference is True
74371>>>>>>>    // Suitable for override
74371>>>>>>>    Procedure LoadSkinPreference
74373>>>>>>>        String sSkin sIni
74373>>>>>>>        Boolean bExists
74373>>>>>>>        If ghoApplication Begin
74375>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74377>>>>>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
74378>>>>>>>                If bExists Begin
74380>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
74381>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
74382>>>>>>>                    Set psSkinFile to sSkin
74383>>>>>>>                    Set psSkinIni to sIni
74384>>>>>>>                End
74384>>>>>>>>
74384>>>>>>>            End
74384>>>>>>>>
74384>>>>>>>        End
74384>>>>>>>>
74384>>>>>>>        Else Begin
74385>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74386>>>>>>>>
74386>>>>>>>        End
74386>>>>>>>>
74386>>>>>>>    End_Procedure
74387>>>>>>>    
74387>>>>>>>    // Can be called to apply the current skin.
74387>>>>>>>    Procedure ApplySkin
74389>>>>>>>        Boolean bOk
74389>>>>>>>        String sSkin sIni
74389>>>>>>>        If (IsComObjectCreated(Self)) Begin
74391>>>>>>>            Get SkinQFile to sSkin
74392>>>>>>>            Get psSkinIni to sIni
74393>>>>>>>            
74393>>>>>>>            Send NotifyPreApplySkin
74394>>>>>>>            // when skins are used we don't want to use built in Visual Styles
74394>>>>>>>            Send EnableVisualStyles of Desktop (sSkin="")
74395>>>>>>>            Get ComLoadSkin sSkin sIni to bOK
74396>>>>>>>            If (sSkin<>"" and not(bOk)) Begin
74398>>>>>>>                // if not ok, no skin was appied. Enable visual styles
74398>>>>>>>                Send EnableVisualStyles of Desktop True
74399>>>>>>>            End
74399>>>>>>>>
74399>>>>>>>            Send NotifyPostApplySkin
74400>>>>>>>        End
74400>>>>>>>>
74400>>>>>>>    End_Procedure
74401>>>>>>>    
74401>>>>>>>    
74401>>>>>>>End_Class
74402>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cProgressBar.pkg)
74402>>>>>>>Use Windows.pkg
74402>>>>>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cWinControl.pkg)
74402>>>>>>>>>Use Windows.pkg
74402>>>>>>>>>
74402>>>>>>>>>// Key State Masks for Mouse Messages
74402>>>>>>>>>
74402>>>>>>>>>Define MK_LBUTTON  for |CI$0001
74402>>>>>>>>>Define MK_RBUTTON  for |CI$0002
74402>>>>>>>>>Define MK_SHIFT    for |CI$0004
74402>>>>>>>>>Define MK_CONTROL  for |CI$0008
74402>>>>>>>>>Define MK_MBUTTON  for |CI$0010
74402>>>>>>>>>Define MK_XBUTTON1 for |CI$0020
74402>>>>>>>>>Define MK_XBUTTON2 for |CI$0040
74402>>>>>>>>>
74402>>>>>>>>>Enum_List // Mouse Key Flags
74402>>>>>>>>>    Define mkLeft    for MK_LBUTTON
74402>>>>>>>>>    Define mkMiddle  for MK_MBUTTON
74402>>>>>>>>>    Define mkRight   for MK_RBUTTON
74402>>>>>>>>>    Define mkX1      for MK_XBUTTON1
74402>>>>>>>>>    Define mkX2      for MK_XBUTTON2
74402>>>>>>>>>    Define mkShift   for MK_SHIFT
74402>>>>>>>>>    Define mkControl for MK_CONTROL
74402>>>>>>>>>End_Enum_List
74402>>>>>>>>>
74402>>>>>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
74402>>>>>>>>>    Define mbLeft
74402>>>>>>>>>    Define mbMiddle
74402>>>>>>>>>    Define mbRight
74402>>>>>>>>>    Define mbX1
74402>>>>>>>>>    Define mbX2
74402>>>>>>>>>End_Enum_List
74402>>>>>>>>>
74402>>>>>>>>>Class cWinControl is a DfBaseControl
74403>>>>>>>>>    Procedure Construct_Object
74405>>>>>>>>>        Forward Send Construct_Object
74407>>>>>>>>>        Property Integer private_pbEnabled True
74408>>>>>>>>>        Property Integer private_pbVisible True
74409>>>>>>>>>    End_Procedure
74410>>>>>>>>>    
74410>>>>>>>>>    Procedure End_Construct_Object
74412>>>>>>>>>        Forward Send End_Construct_Object
74414>>>>>>>>>        
74414>>>>>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
74415>>>>>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
74416>>>>>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
74417>>>>>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
74418>>>>>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
74419>>>>>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
74420>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
74421>>>>>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
74422>>>>>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
74423>>>>>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
74424>>>>>>>>>    End_Procedure
74425>>>>>>>>>    
74425>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
74427>>>>>>>>>        //Intentionally cancelled
74427>>>>>>>>>    End_Procedure
74428>>>>>>>>>    
74428>>>>>>>>>    Procedure Command Longptr wParam Longptr lParam
74430>>>>>>>>>        //Intentionally cancelled
74430>>>>>>>>>    End_Procedure
74431>>>>>>>>>    
74431>>>>>>>>>    Procedure DoRecreateWindow
74433>>>>>>>>>        // Recreates the window
74433>>>>>>>>>        If (Window_Handle(Self)) Begin
74435>>>>>>>>>            // attempt to do this without disturbing the focus tree.
74435>>>>>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
74436>>>>>>>>>            Send Page 1      //                       Send Page_Object 1
74437>>>>>>>>>        End
74437>>>>>>>>>>
74437>>>>>>>>>    End_Procedure
74438>>>>>>>>>    
74438>>>>>>>>>    Procedure DoUpdateWindow
74440>>>>>>>>>        // Forces windows to update the window by bypassing WM_PAINT
74440>>>>>>>>>        Handle hWnd
74440>>>>>>>>>        
74440>>>>>>>>>        Get Window_Handle to hWnd
74441>>>>>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
74444>>>>>>>>>    End_Procedure
74445>>>>>>>>>    
74445>>>>>>>>>    Procedure Page Integer iState
74447>>>>>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
74448>>>>>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
74449>>>>>>>>>        Forward Send Page iState
74451>>>>>>>>>    End_Procedure
74452>>>>>>>>>    
74452>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
74454>>>>>>>>>        Integer x y eButton
74454>>>>>>>>>        
74454>>>>>>>>>        Move (Hi(lParam))  to y
74455>>>>>>>>>        Move (Low(lParam)) to x
74456>>>>>>>>>        
74456>>>>>>>>>        Send OnMouseUp mbLeft x y wParam
74457>>>>>>>>>    End_Procedure
74458>>>>>>>>>    
74458>>>>>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
74460>>>>>>>>>        Integer x y eButton
74460>>>>>>>>>        
74460>>>>>>>>>        Move (Hi(lParam))  to y
74461>>>>>>>>>        Move (Low(lParam)) to x
74462>>>>>>>>>        
74462>>>>>>>>>        Send OnMouseUp mbMiddle x y wParam
74463>>>>>>>>>    End_Procedure
74464>>>>>>>>>    
74464>>>>>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
74466>>>>>>>>>        Integer x y eButton
74466>>>>>>>>>        
74466>>>>>>>>>        Move (Hi(lParam))  to y
74467>>>>>>>>>        Move (Low(lParam)) to x
74468>>>>>>>>>        
74468>>>>>>>>>        Send OnMouseUp mbRight x y wParam
74469>>>>>>>>>    End_Procedure
74470>>>>>>>>>    
74470>>>>>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
74472>>>>>>>>>        Integer x y eButton fKeys
74472>>>>>>>>>        
74472>>>>>>>>>        Move (Hi(lParam))  to y
74473>>>>>>>>>        Move (Low(lParam)) to x
74474>>>>>>>>>        
74474>>>>>>>>>        Send OnMouseDown mbLeft x y wParam
74475>>>>>>>>>    End_Procedure
74476>>>>>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
74478>>>>>>>>>        Integer x y eButton
74478>>>>>>>>>        
74478>>>>>>>>>        Move (Hi(lParam))  to y
74479>>>>>>>>>        Move (Low(lParam)) to x
74480>>>>>>>>>        
74480>>>>>>>>>        Send OnMouseDown mbMiddle x y wParam
74481>>>>>>>>>    End_Procedure
74482>>>>>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
74484>>>>>>>>>        Integer x y eButton
74484>>>>>>>>>        
74484>>>>>>>>>        Move (Hi(lParam))  to y
74485>>>>>>>>>        Move (Low(lParam)) to x
74486>>>>>>>>>        
74486>>>>>>>>>        Send OnMouseDown mbRight x y wParam
74487>>>>>>>>>    End_Procedure
74488>>>>>>>>>    
74488>>>>>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
74490>>>>>>>>>        Integer x y eButton
74490>>>>>>>>>        
74490>>>>>>>>>        Move (Hi(lParam))  to y
74491>>>>>>>>>        Move (Low(lParam)) to x
74492>>>>>>>>>        
74492>>>>>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
74493>>>>>>>>>    End_Procedure
74494>>>>>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
74496>>>>>>>>>        Integer x y eButton
74496>>>>>>>>>        
74496>>>>>>>>>        Move (Hi(lParam))  to y
74497>>>>>>>>>        Move (Low(lParam)) to x
74498>>>>>>>>>        
74498>>>>>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
74499>>>>>>>>>    End_Procedure
74500>>>>>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
74502>>>>>>>>>        Integer x y eButton
74502>>>>>>>>>        
74502>>>>>>>>>        Move (Hi(lParam))  to y
74503>>>>>>>>>        Move (Low(lParam)) to x
74504>>>>>>>>>        
74504>>>>>>>>>        Send OnMouseDoubleClick mbRight x y wParam
74505>>>>>>>>>    End_Procedure
74506>>>>>>>>>    
74506>>>>>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
74508>>>>>>>>>        Integer x y eButton
74508>>>>>>>>>        
74508>>>>>>>>>        Move (Hi(lParam))  to y
74509>>>>>>>>>        Move (Low(lParam)) to x
74510>>>>>>>>>        
74510>>>>>>>>>        Send OnMouseMove x y wParam
74511>>>>>>>>>    End_Procedure
74512>>>>>>>>>    
74512>>>>>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
74514>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74514>>>>>>>>>        //String sButton
74514>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74514>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74514>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74514>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74514>>>>>>>>>        
74514>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74514>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74514>>>>>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74514>>>>>>>>>    End_Procedure
74515>>>>>>>>>    
74515>>>>>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
74517>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74517>>>>>>>>>        //String sButton
74517>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74517>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74517>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74517>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74517>>>>>>>>>        
74517>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74517>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74517>>>>>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74517>>>>>>>>>    End_Procedure
74518>>>>>>>>>    
74518>>>>>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
74520>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74520>>>>>>>>>        //String sButton
74520>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74520>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74520>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74520>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74520>>>>>>>>>        
74520>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74520>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74520>>>>>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74520>>>>>>>>>    End_Procedure
74521>>>>>>>>>    
74521>>>>>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
74523>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74523>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74523>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74523>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74523>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74523>>>>>>>>>        
74523>>>>>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74523>>>>>>>>>    End_Procedure
74524>>>>>>>>>    
74524>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
74526>>>>>>>>>        Handle hWnd
74526>>>>>>>>>        
74526>>>>>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
74528>>>>>>>>>            Set private_pbEnabled to bEnabled
74529>>>>>>>>>            Get Window_Handle to hWnd
74530>>>>>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
74533>>>>>>>>>        End
74533>>>>>>>>>>
74533>>>>>>>>>    End_Procedure
74534>>>>>>>>>    Function pbEnabled Returns Boolean
74536>>>>>>>>>        Function_Return (private_pbEnabled(Self))
74537>>>>>>>>>    End_Function
74538>>>>>>>>>    
74538>>>>>>>>>    Procedure Set pbVisible Boolean bVisible
74540>>>>>>>>>        Handle  hWnd
74540>>>>>>>>>        Integer iVoid
74540>>>>>>>>>        
74540>>>>>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
74542>>>>>>>>>            Set private_pbVisible to bVisible
74543>>>>>>>>>            Get Window_Handle to hWnd
74544>>>>>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
74547>>>>>>>>>        End
74547>>>>>>>>>>
74547>>>>>>>>>    End_Procedure
74548>>>>>>>>>    Function pbVisible Returns Boolean
74550>>>>>>>>>        Function_Return (private_pbVisible(Self))
74551>>>>>>>>>    End_Function
74552>>>>>>>>>    
74552>>>>>>>>>End_Class
74553>>>>>>>Use CommCtrl.pkg
74553>>>>>>>
74553>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
74553>>>>>>>Class cProgressBar is a cWinControl
74554>>>>>>>    
74554>>>>>>>    Procedure Construct_Object
74556>>>>>>>        Forward Send Construct_Object
74558>>>>>>>        Property Integer private_piMinimum
74559>>>>>>>        Property Integer private_piMaximum   100
74560>>>>>>>        Property Integer private_piAdvanceBy 10
74561>>>>>>>        Property Integer private_piPosition
74562>>>>>>>        Property Integer private_pbVertical  False
74563>>>>>>>        Property Integer private_pbSmooth    False
74564>>>>>>>        Property Integer private_piBackColor clDefault
74565>>>>>>>        Property Integer private_piBarColor  clDefault
74566>>>>>>>        
74566>>>>>>>        Send Define_ToolTip_Support_Mixin
74567>>>>>>>        
74567>>>>>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
74568>>>>>>>        Set Focus_Mode to NonFocusable
74569>>>>>>>        Set Skip_State to True
74570>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
74571>>>>>>>    End_Procedure
74572>>>>>>>    
74572>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
74573>>>>>>>    
74573>>>>>>>    Procedure Set piMinimum Integer iMin
74575>>>>>>>        Integer iMax
74575>>>>>>>        
74575>>>>>>>        Set private_piMinimum to iMin
74576>>>>>>>        Get private_piMaximum to iMax
74577>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74578>>>>>>>    End_Procedure
74579>>>>>>>    Function piMinimum Returns Integer
74581>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
74584>>>>>>>        Else;            Function_Return (private_piMinimum(Self))
74586>>>>>>>    End_Function
74587>>>>>>>    
74587>>>>>>>    Procedure Set piMaximum Integer iMax
74589>>>>>>>        Integer iMin
74589>>>>>>>        
74589>>>>>>>        Set private_piMaximum to iMax
74590>>>>>>>        Get private_piMinimum to iMin
74591>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74592>>>>>>>    End_Procedure
74593>>>>>>>    Function piMaximum Returns Integer
74595>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
74598>>>>>>>        Else;            Function_Return (private_piMaximum(Self))
74600>>>>>>>    End_Function
74601>>>>>>>    
74601>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
74603>>>>>>>        Set private_piAdvanceBy to iAdvanceBy
74604>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
74605>>>>>>>    End_Procedure
74606>>>>>>>    Function piAdvanceBy Returns Integer
74608>>>>>>>        Function_Return (private_piAdvanceBy(Self))
74609>>>>>>>    End_Function
74610>>>>>>>    
74610>>>>>>>    Procedure Set piPosition Integer iPos
74612>>>>>>>        Set private_piPosition to iPos
74613>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
74614>>>>>>>    End_Procedure
74615>>>>>>>    
74615>>>>>>>    Function piPosition Returns Integer
74617>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
74620>>>>>>>        Else;            Function_Return (private_piPosition(Self))
74622>>>>>>>    End_Function
74623>>>>>>>    
74623>>>>>>>    Procedure Set pbVertical Boolean bVertical
74625>>>>>>>        If (private_pbVertical(Self) <> bVertical) Begin
74627>>>>>>>            Set private_pbVertical to bVertical
74628>>>>>>>            Send DoRecreateWindow
74629>>>>>>>        End
74629>>>>>>>>
74629>>>>>>>    End_Procedure
74630>>>>>>>    
74630>>>>>>>    Function pbVertical Returns Boolean
74632>>>>>>>        Function_Return (private_pbVertical(Self))
74633>>>>>>>    End_Function
74634>>>>>>>    
74634>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
74636>>>>>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
74638>>>>>>>            Set private_pbSmooth to bSmooth
74639>>>>>>>            Send DoRecreateWindow
74640>>>>>>>        End
74640>>>>>>>>
74640>>>>>>>    End_Procedure
74641>>>>>>>    Function pbSmooth Returns Boolean
74643>>>>>>>        Function_Return (private_pbSmooth(Self))
74644>>>>>>>    End_Function
74645>>>>>>>    
74645>>>>>>>    Procedure Set piBackColor Integer rgbColor
74647>>>>>>>        Set private_piBackColor to rgbColor
74648>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
74649>>>>>>>    End_Procedure
74650>>>>>>>    Function piBackColor Returns Integer
74652>>>>>>>        Function_Return (private_piBackColor(Self))
74653>>>>>>>    End_Function
74654>>>>>>>    
74654>>>>>>>    Procedure Set piBarColor Integer rgbColor
74656>>>>>>>        Set private_piBarColor to rgbColor
74657>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
74658>>>>>>>    End_Procedure
74659>>>>>>>    Function piBarColor Returns Integer
74661>>>>>>>        Function_Return (private_piBarColor(Self))
74662>>>>>>>    End_Function
74663>>>>>>>    
74663>>>>>>>    Procedure DoAdvance
74665>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
74666>>>>>>>    End_Procedure
74667>>>>>>>    
74667>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
74669>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
74670>>>>>>>    End_Procedure
74671>>>>>>>    
74671>>>>>>>    Procedure private_DoInitWindow
74673>>>>>>>        Set piBarColor  to (private_piBarColor(Self))
74674>>>>>>>        Set piBackColor to (private_piBackColor(Self))
74675>>>>>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
74676>>>>>>>        Set piMinimum   to (private_piMinimum(Self))
74677>>>>>>>        Set piMaximum   to (private_piMaximum(Self))
74678>>>>>>>        Set piPosition  to (private_piPosition(Self))
74679>>>>>>>    End_Procedure
74680>>>>>>>    
74680>>>>>>>    Procedure Page_Object Integer iState
74682>>>>>>>        Handle hWnd
74682>>>>>>>        
74682>>>>>>>        Get Window_Handle to hWnd
74683>>>>>>>        If (hWnd=0 and iState) Begin
74685>>>>>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
74686>>>>>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
74687>>>>>>>            Forward Send Page_Object True
74689>>>>>>>        End
74689>>>>>>>>
74689>>>>>>>        Else ;            Forward Send Page_Object iState
74692>>>>>>>        
74692>>>>>>>        // Handle tooltip support....
74692>>>>>>>        If (iState = 0) Begin
74694>>>>>>>            Send RequestDeleteToolTip
74695>>>>>>>        End
74695>>>>>>>>
74695>>>>>>>        Else Begin
74696>>>>>>>            Send RequestAddToolTip
74697>>>>>>>        End
74697>>>>>>>>
74697>>>>>>>    End_Procedure
74698>>>>>>>    
74698>>>>>>>    Procedure Page Integer iState
74700>>>>>>>        Forward Send Page iState
74702>>>>>>>        If (iState =1);            Send private_DoInitWindow
74705>>>>>>>    End_Procedure
74706>>>>>>>    
74706>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
74706>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
74706>>>>>>>    // is implemented in a mixin class.
74706>>>>>>>    Procedure RequestAddToolTip
74708>>>>>>>        Send AddToolTip
74709>>>>>>>    End_Procedure
74710>>>>>>>    
74710>>>>>>>    
74710>>>>>>>    // Called by Page_Object. Handles tooltip removal.
74710>>>>>>>    Procedure RequestDeleteToolTip
74712>>>>>>>        Send DeleteToolTip
74713>>>>>>>    End_Procedure
74714>>>>>>>End_Class
74715>>>>>Use Windows.pkg
74715>>>>>Use DUFLanguageConstants.inc
74715>>>>>Use Statpnl.pkg
74715>>>>>
74715>>>>>
74715>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
74715>>>>>
74715>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
74715>>>>>
74715>>>>>Object Status_Panel is a cProcessStatusPanel
74717>>>>>    Set Size to 152 222
74718>>>>>    Set Border_Style to Border_Dialog
74719>>>>>    Set Icon to "Default.ico"
74720>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
74721>>>>>
74721>>>>>    Property Boolean Cancel_Button_Visible_State True
74723>>>>>
74723>>>>>    Procedure Activate
74726>>>>>        Integer iSizeBefore
74726>>>>>        Get GuiSize to iSizeBefore
74727>>>>>        Forward Send Activate
74729>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
74730>>>>>    End_Procedure
74731>>>>>
74731>>>>>    Procedure End_Construct_Object
74734>>>>>        Forward Send End_Construct_Object
74736>>>>>        Set Label of oTitleTxt      to ""
74737>>>>>        Set Label of oTableNameTxt  to ""
74738>>>>>        Set Label of oMessageTxt    to ""
74739>>>>>        Set Label of oActionTxt     to ""
74740>>>>>    End_Procedure
74741>>>>>
74741>>>>>    Object oTitleTxt is a TextBox
74743>>>>>        Set Location to 5 21
74744>>>>>        Set Size to 8 179
74745>>>>>        Set Auto_Size_State to False
74746>>>>>        Set Justification_Mode  to jMode_Center
74747>>>>>        Set Label to "This is the Title Text"
74748>>>>>    End_Object
74749>>>>>
74749>>>>>    Object oTableNameTxt is a TextBox
74751>>>>>        Set Size to 19 204
74752>>>>>        Set Location to 18 9
74753>>>>>        Set Auto_Size_State to False
74754>>>>>        Set Justification_Mode to JMode_Left
74755>>>>>        Set Label to "This is the TableName Text"
74756>>>>>    End_Object
74757>>>>>
74757>>>>>    Object oMessageTxt is a TextBox
74759>>>>>        Set Location to 39 9
74760>>>>>        Set Size to 19 204
74761>>>>>        Set Auto_Size_State to False
74762>>>>>        Set Justification_Mode to JMode_Left
74763>>>>>        Set Label to "This is the Message text"
74764>>>>>    End_Object
74765>>>>>
74765>>>>>    Object oActionTxt is a TextBox
74767>>>>>        Set Size to 16 204
74768>>>>>        Set Location to 60 9
74769>>>>>        Set Auto_Size_State to False
74770>>>>>        Set Justification_Mode to JMode_Left
74771>>>>>        Set Label to "This is the Action Text"
74772>>>>>    End_Object
74773>>>>>
74773>>>>>    Object oStopButton is a Button
74775>>>>>        Set Location to 123 82
74776>>>>>        Set Label to C_$Cancel
74777>>>>>
74777>>>>>        Procedure OnClick 
74780>>>>>            Integer iRetval
74780>>>>>            Get YesNo_Box CS_DUF_DoYouWantToExit to iRetval
74781>>>>>            If (iRetval = MBR_Yes) Begin
74783>>>>>                Send Exit_Application
74784>>>>>            End
74784>>>>>>
74784>>>>>        End_Procedure
74785>>>>>
74785>>>>>    End_Object
74786>>>>>
74786>>>>>    Object oPercentage_tb is a TextBox
74788>>>>>        Set Location to 74 196
74789>>>>>        Set Size to 10 25
74790>>>>>//        Set Label to "% Done"
74790>>>>>    End_Object
74791>>>>>
74791>>>>>    Object oCopyRight is a TextBox
74793>>>>>        Set Location to 140 21
74794>>>>>        Set Size to 9 197
74795>>>>>        Set FontPointHeight to 8
74796>>>>>        Set Auto_Size_State to False
74797>>>>>        Set Justification_Mode  to jMode_Center
74798>>>>>        Set Label to "Copyright 2001-2024 RDC Tools International"
74799>>>>>    End_Object
74800>>>>>
74800>>>>>    Object oProgressBar is a cProgressBar
74802>>>>>        Set Size to 10 179
74803>>>>>        Set Location to 83 22
74804>>>>>        Set pbVisible to True // default
74805>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
74806>>>>>    End_Object
74807>>>>>
74807>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
74810>>>>>        Set pbVisible of ghoProgressBar to bVisible
74811>>>>>    End_Procedure
74812>>>>>
74812>>>>>    Function Progress_Bar_Visible_State Returns Boolean
74815>>>>>        Boolean bVisible
74815>>>>>        Get pbVisible of ghoProgressBar to bVisible
74816>>>>>        Function_Return (bVisible)
74817>>>>>    End_Function
74818>>>>>
74818>>>>>    Object oProgressBarOverall is a cProgressBar
74820>>>>>        Set Size to 10 179
74821>>>>>        Set Location to 107 22
74822>>>>>        Set pbVisible to True // default
74823>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
74824>>>>>    End_Object
74825>>>>>
74825>>>>>    Object oOverallProgress_tb is a TextBox
74827>>>>>        Set Size to 10 65
74828>>>>>        Set Location to 95 24
74829>>>>>        Set Label to "Overall Progress"
74830>>>>>    End_Object
74831>>>>>
74831>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
74834>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
74835>>>>>    End_Procedure
74836>>>>>
74836>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
74839>>>>>        Boolean bVisible
74839>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
74840>>>>>        Function_Return (bVisible)
74841>>>>>    End_Function
74842>>>>>
74842>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
74842>>>>>    // objects defined within this instance of the status panel.
74842>>>>>
74842>>>>>    // note: all of the messages that change text should be forwarded
74842>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
74842>>>>>
74842>>>>>    Procedure Set Message_Text String sText
74845>>>>>        Set Label of oMessageTxt to sText
74846>>>>>        Forward Set Message_Text to sText
74848>>>>>    End_Procedure
74849>>>>>
74849>>>>>    Function Message_Text Returns String
74852>>>>>        Function_Return (Label(oMessageTxt))
74853>>>>>    End_Function
74854>>>>>
74854>>>>>    Procedure Set Action_Text String sText
74857>>>>>        Set Label of oActionTxt to sText
74858>>>>>        Forward Set Action_Text to sText
74860>>>>>    End_Procedure
74861>>>>>
74861>>>>>    Function Action_Text Returns String
74864>>>>>        Function_Return (Label(oActionTxt))
74865>>>>>    End_Function
74866>>>>>
74866>>>>>    Procedure Set Button_Text String sText
74869>>>>>        Set Label of oStopButton to sText
74870>>>>>        Forward Set Button_Text to sText
74872>>>>>    End_Procedure
74873>>>>>
74873>>>>>    Function Button_Text Returns String
74876>>>>>        Function_Return (Label(oStopButton))
74877>>>>>    End_Function
74878>>>>>
74878>>>>>    Procedure Set Title_Text String sText
74881>>>>>        Set Label of oTitleTxt to sText
74882>>>>>        Forward Set Title_Text to sText
74884>>>>>    End_Procedure
74885>>>>>
74885>>>>>    Function Title_Text Returns String
74888>>>>>        Function_Return (Label(oTitleTxt))
74889>>>>>    End_Function
74890>>>>>
74890>>>>>    Procedure Set TableName_Text String sText
74893>>>>>        Set Label of oTableNameTxt to sText
74894>>>>>    End_Procedure
74895>>>>>
74895>>>>>    Function TableName_Text Returns String
74898>>>>>        Function_Return (Label(oTableNameTxt))
74899>>>>>    End_Function
74900>>>>>
74900>>>>>    Procedure Set License_Text String sText
74903>>>>>//        Set Label of oLicense_txt to sText
74903>>>>>    End_Procedure
74904>>>>>
74904>>>>>    // gets called when status panel is activated passing whether a button
74904>>>>>    // should appear
74904>>>>>    Procedure EnableCancelButton Boolean bEnable
74907>>>>>        Boolean bVisible
74907>>>>>        Get Cancel_Button_Visible_State to bVisible
74908>>>>>        If (bEnable = False) Begin
74910>>>>>            Set Visible_State of oStopButton to bVisible
74911>>>>>        End
74911>>>>>>
74911>>>>>        Set Enabled_State of oStopButton to bEnable
74912>>>>>    End_Procedure
74913>>>>>
74913>>>>>    Procedure Reset_StatusPanel
74916>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
74917>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
74918>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
74919>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
74920>>>>>    End_Procedure
74921>>>>>
74921>>>>>//    Object oProgressBar is a cProgressBar
74921>>>>>//        Move Self to ghoProgressBar
74921>>>>>//        Set Location to 1 25
74921>>>>>//        Set Size to 9 173
74921>>>>>//        Set piMinimum        to 0
74921>>>>>//        Set piMaximum        to 2000
74921>>>>>//        Set piAdvanceBy      to 100
74921>>>>>//        Set pbSmooth to True
74921>>>>>//
74921>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
74921>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
74921>>>>>//        // color will show correctly.
74921>>>>>//        Procedure Page Integer iPageObject
74921>>>>>//            Handle hWin
74921>>>>>//            Forward Send Page iPageObject
74921>>>>>//            If (ghoSkinFramework <> 0) Begin
74921>>>>>//                Get Window_Handle to hWin
74921>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
74921>>>>>//            End
74921>>>>>//        End_Procedure
74921>>>>>//    End_Object
74921>>>>>
74921>>>>>End_Object
74922>>>>>
74922>>>Use cDbUpdateHandler.inc // Contains cDbUpdateHandler class constants, structs etc.
Including file: cDbUpdateHandler.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.inc)
74922>>>>>// Constant declarations, structs etc. for the cDbUdpateHandler class.
74922>>>>>//
74922>>>>>Use VdfBase.pkg
74922>>>>>Use cApplication.pkg
74922>>>>>Use seq_chnl.pkg
74922>>>>>Use vWin32fh.pkg
Including file: vWin32fh.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vWin32fh.pkg)
74922>>>>>>>// This code is part of VDF GUIdance
74922>>>>>>>// Visit us @ http://www.vdf-guidance.com
74922>>>>>>>// e-Mail us @ info@vdf-guidance.com
74922>>>>>>>// VDF GUIdance is a mutual project of
74922>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
74922>>>>>>>// Wil van Antwerpen  - Antwise Solutions
74922>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
74922>>>>>>>//
74922>>>>>>>//
74922>>>>>>>// *** Windows 32bit file handling wrapper class ***
74922>>>>>>>//
74922>>>>>>>
74922>>>>>>>
74922>>>>>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
74922>>>>>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\cvFileDialogs.pkg)
74922>>>>>>>>>//***************************************************************************
74922>>>>>>>>>//*
74922>>>>>>>>>//* Class:        cvSaveAsDialog
74922>>>>>>>>>//* Package Name: cvFileDialogs.pkg
74922>>>>>>>>>//*
74922>>>>>>>>>//***************************************************************************
74922>>>>>>>>>
74922>>>>>>>>>Use File_dlg.pkg
74922>>>>>>>>>
74922>>>>>>>>>// *WvA: 13-01-1999 Created
74922>>>>>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
74922>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
74922>>>>>>>>>// file_name.
74922>>>>>>>>>Class cvSelectFile_Dialog is an OpenDialog
74923>>>>>>>>>
74923>>>>>>>>>    Procedure Construct_Object Integer iImage_Id
74925>>>>>>>>>        Forward Send Construct_Object iImage_Id
74927>>>>>>>>>        Set HideReadOnly_State to True
74928>>>>>>>>>    End_Procedure
74929>>>>>>>>>
74929>>>>>>>>>    Function SelectedFileName Returns String
74931>>>>>>>>>        String sFileName
74931>>>>>>>>>        Move "" to sFileName
74932>>>>>>>>>        If (Show_Dialog(Self)) Begin
74934>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
74935>>>>>>>>>        End
74935>>>>>>>>>>
74935>>>>>>>>>        Function_Return sFileName
74936>>>>>>>>>    End_Function
74937>>>>>>>>>End_Class
74938>>>>>>>>>
74938>>>>>>>>>// *WvA: 13-01-1999 Created
74938>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
74938>>>>>>>>>// file_name. Returns '' if the user didn't make a selection.
74938>>>>>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
74938>>>>>>>>>//                   file-open dialog
74938>>>>>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
74940>>>>>>>>>    String sSelectedFile
74940>>>>>>>>>    Integer hoOpenFileDialog
74940>>>>>>>>>
74940>>>>>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
74942>>>>>>>>>
74942>>>>>>>>>        Set Dialog_Caption    to sCaptionText
74943>>>>>>>>>        Set Filter_String     to sSupportedFileTypes
74944>>>>>>>>>        Set Initial_Folder    to sInitialFolder
74945>>>>>>>>>
74945>>>>>>>>>        Move Self       to hoOpenFileDialog
74946>>>>>>>>>    End_Object
74947>>>>>>>>>
74947>>>>>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
74948>>>>>>>>>    Send Destroy_Object to hoOpenFileDialog
74949>>>>>>>>>    Function_Return sSelectedFile
74950>>>>>>>>>End_Function
74951>>>>>>>>>
74951>>>>>>>>>Class cvSaveAsDialog is a SaveAsDialog
74952>>>>>>>>>
74952>>>>>>>>>    Procedure Construct_Object
74954>>>>>>>>>        Forward Send Construct_Object
74956>>>>>>>>>        Set HideReadOnly_State to True
74957>>>>>>>>>    End_Procedure
74958>>>>>>>>>
74958>>>>>>>>>    Function SelectedFileName Returns String
74960>>>>>>>>>        String sFileName
74960>>>>>>>>>        Move "" to sFileName
74961>>>>>>>>>        If (Show_Dialog(Self)) Begin
74963>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
74964>>>>>>>>>        End
74964>>>>>>>>>>
74964>>>>>>>>>        Function_Return sFileName
74965>>>>>>>>>    End_Function
74966>>>>>>>>>
74966>>>>>>>>>End_Class
74967>>>>>>>>>
74967>>>>>>>>>// Added optional default filename as suggested by Nils
74967>>>>>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
74969>>>>>>>>>    String sSelectedFile
74969>>>>>>>>>    Integer hoDialog
74969>>>>>>>>>
74969>>>>>>>>>    Move "" to sSelectedFile
74970>>>>>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
74971>>>>>>>>>    If (hoDialog) Begin
74973>>>>>>>>>    //Set NoChangeDir_State Of hoDialog To True
74973>>>>>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
74974>>>>>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
74975>>>>>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
74976>>>>>>>>>        If (Num_Arguments = 4) Begin
74978>>>>>>>>>            Set File_Title        of hoDialog to sDefaultFileName
74979>>>>>>>>>        End
74979>>>>>>>>>>
74979>>>>>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
74980>>>>>>>>>        Send Destroy of hoDialog
74981>>>>>>>>>    End
74981>>>>>>>>>>
74981>>>>>>>>>    Function_Return sSelectedFile
74982>>>>>>>>>End_Function
74983>>>>>>>Use Seq_chnl.pkg
74983>>>>>>>
74983>>>>>>>Use windows.pkg
74983>>>>>>>Use Dll.pkg
74983>>>>>>>
74983>>>>>>>Use vWin32fhW.pkg     // WinAPI Unicode version
Including file: vwin32fhW.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fhW.pkg)
74983>>>>>>>>>// This code is part of VDF GUIdance
74983>>>>>>>>>// Visit us @ http://www.vdf-guidance.com
74983>>>>>>>>>// e-Mail us @ info@vdf-guidance.com
74983>>>>>>>>>// VDF GUIdance is a mutual project of
74983>>>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
74983>>>>>>>>>// Wil van Antwerpen  - Antwise Solutions
74983>>>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
74983>>>>>>>>>//
74983>>>>>>>>>//
74983>>>>>>>>>// *** Windows 32bit file handling wrapper class ***
74983>>>>>>>>>// Unicode variant
74983>>>>>>>>>
74983>>>>>>>>>Use vWin32fhW.h       // Header file with WinAPI Unicode declarations
Including file: vwin32fhW.h    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fhW.h)
74983>>>>>>>>>>>//TH-Header
74983>>>>>>>>>>>//*****************************************************************************************
74983>>>>>>>>>>>// Copyright (c)  2004 KURANT Project
74983>>>>>>>>>>>// All rights reserved.
74983>>>>>>>>>>>//
74983>>>>>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
74983>>>>>>>>>>>// $ProjectName : Windows 32 bits file handling
74983>>>>>>>>>>>// $Authors     : Wil van Antwerpen
74983>>>>>>>>>>>// $Created     : 19.02.2004  19:25
74983>>>>>>>>>>>// $Type        : BSD (as in do with it whatever you like)
74983>>>>>>>>>>>//
74983>>>>>>>>>>>// Contents:
74983>>>>>>>>>>>//  This file contains the Windows API external function call definitions and
74983>>>>>>>>>>>//  constants as they are used in the vWin32fh package.
74983>>>>>>>>>>>//*****************************************************************************************
74983>>>>>>>>>>>//TH-RevisionStart
74983>>>>>>>>>>>//TH-RevisionEnd
74983>>>>>>>>>>>
74983>>>>>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
74983>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
74983>>>>>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
74983>>>>>>>>>>>
74983>>>>>>>>>>>
74983>>>>>>>>>>>Define vMax_Path     For |CI260
74983>>>>>>>>>>>Define vMinChar      For |CI$80
74983>>>>>>>>>>>Define vMaxChar      For |CI$7F
74983>>>>>>>>>>>Define vMinShort     For |CI$8000
74983>>>>>>>>>>>Define vMaxShort     For |CI$7FFF
74983>>>>>>>>>>>Define vMinLong      For |CI$80000000
74983>>>>>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
74983>>>>>>>>>>>Define vMaxByte      For |CI$FF
74983>>>>>>>>>>>Define vMaxWord      For |CI$FFFF
74983>>>>>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
74983>>>>>>>>>>>
74983>>>>>>>>>>>
74983>>>>>>>>>>>
74983>>>>>>>>>>>// For FindFirstFile
74983>>>>>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
74983>>>>>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
74983>>>>>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
74983>>>>>>>>>>>
74983>>>>>>>>>>>// The defines below can be used to find out what kind of error has occurred if
74983>>>>>>>>>>>// the API-call ShellExecute is used.
74983>>>>>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
74983>>>>>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
74983>>>>>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
74983>>>>>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
74983>>>>>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
74983>>>>>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
74983>>>>>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
74983>>>>>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
74983>>>>>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
74983>>>>>>>>>>>Define vSE_ERR_FNF             For |CI0002
74983>>>>>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
74983>>>>>>>>>>>Define vSE_ERR_OOM             For |CI0008
74983>>>>>>>>>>>Define vSE_ERR_PNF             For |CI0003
74983>>>>>>>>>>>Define vSE_ERR_SHARE           For |CI0026
74983>>>>>>>>>>>
74983>>>>>>>>>>>
74983>>>>>>>>>>>// C-Structure
74983>>>>>>>>>>>//typedef struct _browseinfo {
74983>>>>>>>>>>>//    HWND hwndOwner;
74983>>>>>>>>>>>//    LPCITEMIDLIST pidlRoot;
74983>>>>>>>>>>>//    LPSTR pszDisplayName;
74983>>>>>>>>>>>//    LPCSTR lpszTitle;
74983>>>>>>>>>>>//    UINT ulFlags;
74983>>>>>>>>>>>//    BFFCALLBACK lpfn;
74983>>>>>>>>>>>//    LPARAM lParam;
74983>>>>>>>>>>>//    int iImage;
74983>>>>>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
74983>>>>>>>>>>>
74983>>>>>>>>>>>//declare C structure struct_browseinfo
74983>>>>>>>>>>>//as documented in MSDN under Windows Shell API
74983>>>>>>>>>>>Struct tvBrowseInfo
74983>>>>>>>>>>>  Handle    hWndOwner
74983>>>>>>>>>>>  Pointer   pIDLRoot
74983>>>>>>>>>>>  Pointer   pszDisplayName
74983>>>>>>>>>>>  Pointer   lpszTitle
74983>>>>>>>>>>>  DWord     ulFlags
74983>>>>>>>>>>>    DWord   BrowseInfoMissingAlignment1
74983>>>>>>>>>>>  Pointer   lpfnCallback
74983>>>>>>>>>>>  LongPtr   lParam
74983>>>>>>>>>>>  DWord     iImage
74983>>>>>>>>>>>    DWord   BrowseInfoMissingAlignment2
74983>>>>>>>>>>>End_Struct // tvBrowseInfo
74983>>>>>>>>>>>
74983>>>>>>>>>>>// Browsing for directory.
74983>>>>>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
74983>>>>>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
74983>>>>>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
74983>>>>>>>>>>>                                            // The callback function can set the status text by
74983>>>>>>>>>>>                                            // sending messages to the dialog box.
74983>>>>>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
74983>>>>>>>>>>>
74983>>>>>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
74983>>>>>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
74983>>>>>>>>>>>
74983>>>>>>>>>>>// message from browser
74983>>>>>>>>>>>//Define BFFM_INITIALIZED        1
74983>>>>>>>>>>>//Define BFFM_SELCHANGED         2
74983>>>>>>>>>>>
74983>>>>>>>>>>>// messages to browser
74983>>>>>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
74983>>>>>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
74983>>>>>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
74983>>>>>>>>>>>
74983>>>>>>>>>>>
74983>>>>>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolderW" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
74984>>>>>>>>>>>
74984>>>>>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDListW" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
74985>>>>>>>>>>>
74985>>>>>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
74986>>>>>>>>>>>
74986>>>>>>>>>>>
74986>>>>>>>>>>>
74986>>>>>>>>>>>
74986>>>>>>>>>>>Struct tvSecurity_attributes
74986>>>>>>>>>>>  DWord   nLength
74986>>>>>>>>>>>    DWord   Security_attributesMissingAlignment1
74986>>>>>>>>>>>  Pointer lpDescriptor
74986>>>>>>>>>>>  Integer bInheritHandle
74986>>>>>>>>>>>    Integer Security_attributesMissingAlignment2
74986>>>>>>>>>>>End_Struct // tvSecurity_attributes
74986>>>>>>>>>>>
74986>>>>>>>>>>>//nLength:
74986>>>>>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
74986>>>>>>>>>>>// SECURITY_ATTRIBUTES structure.
74986>>>>>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
74986>>>>>>>>>>>// value of the nLength member. However, an application should still set it properly.
74986>>>>>>>>>>>// That ensures current, future, and cross-platform compatibility.
74986>>>>>>>>>>>//
74986>>>>>>>>>>>//lpSecurityDescriptor:
74986>>>>>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
74986>>>>>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
74986>>>>>>>>>>>// descriptor of the calling process.
74986>>>>>>>>>>>//
74986>>>>>>>>>>>//bInheritHandle:
74986>>>>>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
74986>>>>>>>>>>>// If this member is TRUE, the new process inherits the handle.
74986>>>>>>>>>>>
74986>>>>>>>>>>>
74986>>>>>>>>>>>// BOOL CreateDirectory(
74986>>>>>>>>>>>//    LPCTSTR lpPathName,
74986>>>>>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
74986>>>>>>>>>>>//   );
74986>>>>>>>>>>>//
74986>>>>>>>>>>>// lpPathName
74986>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
74986>>>>>>>>>>>//  to be created.
74986>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
74986>>>>>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
74986>>>>>>>>>>>// lpSecurityAttributes
74986>>>>>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
74986>>>>>>>>>>>//  determines whether the returned handle can be inherited by child processes.
74986>>>>>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
74986>>>>>>>>>>>// Returns:
74986>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
74986>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
74986>>>>>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryW" kernel32.dll ;  WString sPathName Pointer lpSecurity_Attributes Returns Integer
74987>>>>>>>>>>>
74987>>>>>>>>>>>
74987>>>>>>>>>>>// lpPathName
74987>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
74987>>>>>>>>>>>//  to be removed.
74987>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
74987>>>>>>>>>>>// Returns:
74987>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
74987>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
74987>>>>>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryW" kernel32.dll ;  WString sPathName Returns Integer
74988>>>>>>>>>>>
74988>>>>>>>>>>>
74988>>>>>>>>>>>
74988>>>>>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
74988>>>>>>>>>>>// executable file or a document file.
74988>>>>>>>>>>>//
74988>>>>>>>>>>>// Operation can be one of the following:
74988>>>>>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
74988>>>>>>>>>>>//            The file can be an executable file or a document file.
74988>>>>>>>>>>>//            The file can be a folder to open.
74988>>>>>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
74988>>>>>>>>>>>//            The file should be a document file. If the file is an executable file,
74988>>>>>>>>>>>//            the function opens the file, as if "open" had been specified.
74988>>>>>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
74988>>>>>>>>>>>//
74988>>>>>>>>>>>// Return Values:
74988>>>>>>>>>>>//
74988>>>>>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
74988>>>>>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
74988>>>>>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
74988>>>>>>>>>>>//
74988>>>>>>>>>>>// The following table lists these error values:
74988>>>>>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
74988>>>>>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
74988>>>>>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
74988>>>>>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
74988>>>>>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
74988>>>>>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
74988>>>>>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
74988>>>>>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
74988>>>>>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
74988>>>>>>>>>>>// Public Const SE_ERR_FNF = 2
74988>>>>>>>>>>>// Public Const SE_ERR_NOASSOC = 31
74988>>>>>>>>>>>// Public Const SE_ERR_OOM = 8
74988>>>>>>>>>>>// Public Const SE_ERR_PNF = 3
74988>>>>>>>>>>>// Public Const SE_ERR_SHARE = 26
74988>>>>>>>>>>>
74988>>>>>>>>>>>
74988>>>>>>>>>>>
74988>>>>>>>>>>>// Code to open the program that is associated with the selected file.
74988>>>>>>>>>>>//
74988>>>>>>>>>>>// External function call used in Procedure DoStartDocument
74988>>>>>>>>>>>External_function vWin32_ShellExecute "ShellExecuteW" shell32.dll ;  Handle  hWnd ;  WString wsOperation ;  WString wsFile ;  WString wsParameters ;  WString wsDirectory ;  Dword   iShowCmd Returns Handle
74989>>>>>>>>>>>
74989>>>>>>>>>>>
74989>>>>>>>>>>>
74989>>>>>>>>>>>
74989>>>>>>>>>>>Define vFO_MOVE                For |CI$0001
74989>>>>>>>>>>>Define vFO_COPY                For |CI$0002
74989>>>>>>>>>>>Define vFO_DELETE              For |CI$0003
74989>>>>>>>>>>>Define vFO_RENAME              For |CI$0004
74989>>>>>>>>>>>
74989>>>>>>>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
74989>>>>>>>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
74989>>>>>>>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
74989>>>>>>>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
74989>>>>>>>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
74989>>>>>>>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
74989>>>>>>>>>>>                                          // Must be freed using SHFreeNameMappings
74989>>>>>>>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
74989>>>>>>>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
74989>>>>>>>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
74989>>>>>>>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
74989>>>>>>>>>>>
74989>>>>>>>>>>>Struct tvShFileOpStruct
74989>>>>>>>>>>>  Handle   hWnd
74989>>>>>>>>>>>  UInteger wFunc
74989>>>>>>>>>>>    UInteger ShFileOpStructMissingAlignment1
74989>>>>>>>>>>>  Pointer  pFrom
74989>>>>>>>>>>>  Pointer  pTo
74989>>>>>>>>>>>  Short    fFlags
74989>>>>>>>>>>>  Integer  fAnyOperationsAborted
74989>>>>>>>>>>>    Short  ShFileOpStructMissingAlignment2
74989>>>>>>>>>>>  Pointer  hNameMappings
74989>>>>>>>>>>>  Pointer  lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
74989>>>>>>>>>>>End_Struct // tvShFileOpStruct
74989>>>>>>>>>>>
74989>>>>>>>>>>>// hwnd
74989>>>>>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
74989>>>>>>>>>>>
74989>>>>>>>>>>>// wFunc
74989>>>>>>>>>>>//   Operation to perform. This member can be one of the following values:
74989>>>>>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
74989>>>>>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
74989>>>>>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
74989>>>>>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
74989>>>>>>>>>>>
74989>>>>>>>>>>>// pFrom
74989>>>>>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
74989>>>>>>>>>>>//   be null-separated. The list of names must be double null-terminated.
74989>>>>>>>>>>>
74989>>>>>>>>>>>// pTo
74989>>>>>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
74989>>>>>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
74989>>>>>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
74989>>>>>>>>>>>//   double null-terminated.
74989>>>>>>>>>>>
74989>>>>>>>>>>>// fAnyOperationsAborted
74989>>>>>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
74989>>>>>>>>>>>//   were completed or FALSE otherwise.
74989>>>>>>>>>>>
74989>>>>>>>>>>>
74989>>>>>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
74989>>>>>>>>>>>// This can be a file or a folder.
74989>>>>>>>>>>>// With thanks to Andrew S Kaplan
74989>>>>>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationW" Shell32.dll ;        Pointer lpFileOp Returns Integer
74990>>>>>>>>>>>
74990>>>>>>>>>>>
74990>>>>>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
74990>>>>>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryW" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
74991>>>>>>>>>>>
74991>>>>>>>>>>>
74991>>>>>>>>>>>
74991>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74991>>>>>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
74991>>>>>>>>>>>//   Pointer lpPathName ;
74991>>>>>>>>>>>//   Pointer lpPrefixString ;
74991>>>>>>>>>>>//   Integer uUnique ;
74991>>>>>>>>>>>//   Pointer lpTempFileName ;
74991>>>>>>>>>>>//   Returns Integer
74991>>>>>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
74991>>>>>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameW" kernel32.dll WString sPath ;        WString sPrefix Integer iUnique Pointer lpTempFileName Returns Integer
74992>>>>>>>>>>>
74992>>>>>>>>>>>External_function vWin32_GetTempPath "GetTempPathW" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
74993>>>>>>>>>>>
74993>>>>>>>>>>>External_function vWin32_DeleteFile "DeleteFileW" Kernel32.Dll ;   WString sFileName ;   Returns Integer
74994>>>>>>>>>>>
74994>>>>>>>>>>>// from:
74994>>>>>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
74994>>>>>>>>>>>//
74994>>>>>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
74994>>>>>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
74994>>>>>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
74994>>>>>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
74994>>>>>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
74994>>>>>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
74994>>>>>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
74994>>>>>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
74994>>>>>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
74994>>>>>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
74994>>>>>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
74994>>>>>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
74994>>>>>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
74994>>>>>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
74994>>>>>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
74994>>>>>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
74994>>>>>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
74994>>>>>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
74994>>>>>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
74994>>>>>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
74994>>>>>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
74994>>>>>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
74994>>>>>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
74994>>>>>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
74994>>>>>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
74994>>>>>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
74994>>>>>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
74994>>>>>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
74994>>>>>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
74994>>>>>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
74994>>>>>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
74994>>>>>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
74994>>>>>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
74994>>>>>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
74994>>>>>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
74994>>>>>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
74994>>>>>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
74994>>>>>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
74994>>>>>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
74994>>>>>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
74994>>>>>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
74994>>>>>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
74994>>>>>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
74994>>>>>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
74994>>>>>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
74994>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
74994>>>>>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
74994>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
74994>>>>>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
74994>>>>>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
74994>>>>>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
74994>>>>>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
74994>>>>>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
74994>>>>>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
74994>>>>>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
74994>>>>>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
74994>>>>>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
74994>>>>>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
74994>>>>>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
74994>>>>>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
74994>>>>>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
74994>>>>>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
74994>>>>>>>>>>>
74994>>>>>>>>>>>
74994>>>>>>>>>>>//HRESULT SHGetFolderPath(
74994>>>>>>>>>>>//    HWND hwndOwner,
74994>>>>>>>>>>>//    int nFolder,
74994>>>>>>>>>>>//    HANDLE hToken,
74994>>>>>>>>>>>//    DWORD dwFlags,
74994>>>>>>>>>>>//    LPTSTR pszPath
74994>>>>>>>>>>>//);
74994>>>>>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
74994>>>>>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
74994>>>>>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
74994>>>>>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
74994>>>>>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
74994>>>>>>>>>>>//
74994>>>>>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathW" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
74995>>>>>>>>>>>
74995>>>>>>>>>>>
74995>>>>>>>>>>>
74995>>>>>>>>>>>Struct tvWin32FindData
74995>>>>>>>>>>> Dword            dwFileAttributes
74995>>>>>>>>>>> Dword            ftCreationLowDateTime
74995>>>>>>>>>>> Dword            ftCreationHighDateTime
74995>>>>>>>>>>> dword            ftLastAccessLowDateTime
74995>>>>>>>>>>> Dword            ftLastAccessHighDateTime
74995>>>>>>>>>>> Dword            ftLastWriteLowDateTime
74995>>>>>>>>>>> Dword            ftLastWriteHighDateTime
74995>>>>>>>>>>> Dword            nFileSizeHigh
74995>>>>>>>>>>> Dword            nFileSizeLow
74995>>>>>>>>>>> Dword            dwReserved0
74995>>>>>>>>>>> Dword            dwReserved1
74995>>>>>>>>>>> Short[vMax_Path] cFileName
74995>>>>>>>>>>> Short[14]        cAlternateFileName
74995>>>>>>>>>>>End_Struct
74995>>>>>>>>>>>
74995>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74995>>>>>>>>>>>// lpFileName      : address of name of file to search for
74995>>>>>>>>>>>// lpFindFileData  : address of returned information
74995>>>>>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileW"  Kernel32.dll WString sFileName ;          Pointer lpFindFileData Returns Handle
74996>>>>>>>>>>>
74996>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74996>>>>>>>>>>>// hFindFile       : handle of search
74996>>>>>>>>>>>// lpFindFileData  : address of structure for data on found file
74996>>>>>>>>>>>External_function vWin32_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
74997>>>>>>>>>>>
74997>>>>>>>>>>>
74997>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74997>>>>>>>>>>>//  hFindFile      : file search handle
74997>>>>>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
74998>>>>>>>>>>>
74998>>>>>>>>>>>
74998>>>>>>>>>>>
74998>>>>>>>>>>>Struct tvFileTime
74998>>>>>>>>>>>  DWord dwLowDateTime
74998>>>>>>>>>>>  DWord dwHighDateTime
74998>>>>>>>>>>>End_Struct
74998>>>>>>>>>>>
74998>>>>>>>>>>>
74998>>>>>>>>>>>Struct tvSystemTime
74998>>>>>>>>>>>  UShort wYear
74998>>>>>>>>>>>  UShort wMonth
74998>>>>>>>>>>>  UShort wDayOfWeek
74998>>>>>>>>>>>  UShort wDay
74998>>>>>>>>>>>  UShort wHour
74998>>>>>>>>>>>  UShort wMinute
74998>>>>>>>>>>>  UShort wSecond
74998>>>>>>>>>>>  UShort wMilliSeconds
74998>>>>>>>>>>>End_Struct
74998>>>>>>>>>>>
74998>>>>>>>>>>>
74998>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74998>>>>>>>>>>>//  lpFileTime     : pointer to file time to convert
74998>>>>>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
74998>>>>>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
74999>>>>>>>>>>>
74999>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
74999>>>>>>>>>>>// This function formats the time in a picture-string passed
74999>>>>>>>>>>>//
74999>>>>>>>>>>>// Picture      Meaning
74999>>>>>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
74999>>>>>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
74999>>>>>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
74999>>>>>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
74999>>>>>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
74999>>>>>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
74999>>>>>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
74999>>>>>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
74999>>>>>>>>>>>//    t         One character time marker string, such as A or P
74999>>>>>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
74999>>>>>>>>>>>//
74999>>>>>>>>>>>// For example, to get the time string  "11:29:40 PM"
74999>>>>>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
74999>>>>>>>>>>>
74999>>>>>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
75000>>>>>>>>>>>
75000>>>>>>>>>>>
75000>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75000>>>>>>>>>>>// This function formats the date in a picture-string passed
75000>>>>>>>>>>>//
75000>>>>>>>>>>>// Picture      Meaning
75000>>>>>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
75000>>>>>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
75000>>>>>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
75000>>>>>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
75000>>>>>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
75000>>>>>>>>>>>//              value associated with the specified locale.
75000>>>>>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
75000>>>>>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
75000>>>>>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
75000>>>>>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
75000>>>>>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
75000>>>>>>>>>>>//              associated with the specified locale.
75000>>>>>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
75000>>>>>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
75000>>>>>>>>>>>//    yyyy      Year represented hy full four digits.
75000>>>>>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
75000>>>>>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
75000>>>>>>>>>>>//              does not have an associated era or period string.
75000>>>>>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
75000>>>>>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
75000>>>>>>>>>>>
75000>>>>>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
75001>>>>>>>>>>>
75001>>>>>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
75001>>>>>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
75001>>>>>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
75001>>>>>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
75001>>>>>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
75001>>>>>>>>>>>
75001>>>>>>>>>>>//  Date Flags for GetDateFormatW.
75001>>>>>>>>>>>//
75001>>>>>>>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
75001>>>>>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
75001>>>>>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
75001>>>>>>>>>>>
75001>>>>>>>>>>>
75001>>>>>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
75002>>>>>>>>>>>
75002>>>>>>>>>>>
75002>>>>>>>>>>>// **WvA: 20-02-2004
75002>>>>>>>>>>>// While i was testing the format capabilities i stumbled over a very
75002>>>>>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
75002>>>>>>>>>>>// incorrectly into an unsigned integer.
75002>>>>>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
75002>>>>>>>>>>>// It does smell a bit fishy though
75002>>>>>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
75002>>>>>>>>>>>
75002>>>>>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
75002>>>>>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
75002>>>>>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
75002>>>>>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
75002>>>>>>>>>>>
75002>>>>>>>>>>>// Possible errors that can be returned by the shellformat function
75002>>>>>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
75002>>>>>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
75002>>>>>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
75002>>>>>>>>>>>
75002>>>>>>>>>>>
75002>>>>>>>>>>> // Courtesy Of Steve Walter,
75002>>>>>>>>>>> // USA Software, Inc
75002>>>>>>>>>>> // Format a disk
75002>>>>>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
75002>>>>>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
75003>>>>>>>>>>>
75003>>>>>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
75003>>>>>>>>>>>
75003>>>>>>>>>>>// SHCreateDirectoryEx
75003>>>>>>>>>>>
75003>>>>>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
75003>>>>>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
75003>>>>>>>>>>>//
75003>>>>>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
75003>>>>>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
75003>>>>>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
75003>>>>>>>>>>>//
75003>>>>>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
75003>>>>>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
75003>>>>>>>>>>>//        ERROR_CANCELLED.
75003>>>>>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
75003>>>>>>>>>>>
75003>>>>>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
75003>>>>>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
75003>>>>>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
75003>>>>>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
75003>>>>>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
75003>>>>>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
75003>>>>>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
75003>>>>>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
75003>>>>>>>>>>>
75003>>>>>>>>>>>//        int SHCreateDirectoryEx(
75003>>>>>>>>>>>//            HWND hwnd,
75003>>>>>>>>>>>//            LPCTSTR pszPath,
75003>>>>>>>>>>>//            const SECURITY_ATTRIBUTES *psa
75003>>>>>>>>>>>//        );
75003>>>>>>>>>>>
75003>>>>>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExW" shell32.dll Handle hWnd;                  WString wPath  Pointer lpSecurity_Attributes Returns Integer
75004>>>>>>>>>>>
75004>>>>>>>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryW" SHLWAPI.DLL WString wPath Returns Integer
75005>>>>>>>>>
75005>>>>>>>>>
75005>>>>>>>>>
75005>>>>>>>>>// Does the directory exist? - No = false, Yes = True
75005>>>>>>>>>// This also works with UNC path encoding and wildcards
75005>>>>>>>>>Function vFolderExists Global String sFolderName Returns Boolean
75007>>>>>>>>>    Boolean bFolderExists
75007>>>>>>>>>    Boolean bStop
75007>>>>>>>>>    String  sFolder sTmp
75007>>>>>>>>>    Integer iCh
75007>>>>>>>>>
75007>>>>>>>>>    If (sFolderName = "") Begin
75009>>>>>>>>>        Function_Return False
75010>>>>>>>>>    End
75010>>>>>>>>>>
75010>>>>>>>>>
75010>>>>>>>>>    Move True  to bFolderExists
75011>>>>>>>>>    Move False to bStop
75012>>>>>>>>>    Move "dir:" to sFolder
75013>>>>>>>>>    Append sFolder sFolderName
75014>>>>>>>>>    Get Seq_New_Channel to iCh  // get free channel for input
75015>>>>>>>>>    If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75017>>>>>>>>>        Error DFERR_PROGRAM "No I/O channel available for process (vFolderExists)"
75018>>>>>>>>>>
75018>>>>>>>>>        Function_Return False
75019>>>>>>>>>    End
75019>>>>>>>>>>
75019>>>>>>>>>    Direct_Input channel iCh sFolder
75021>>>>>>>>>    Repeat
75021>>>>>>>>>>
75021>>>>>>>>>        Readln channel iCh sTmp
75023>>>>>>>>>        Move (SeqEof) to bStop
75024>>>>>>>>>        If (Trim(sTmp)="") Begin
75026>>>>>>>>>            Move False to bFolderExists
75027>>>>>>>>>        End
75027>>>>>>>>>>
75027>>>>>>>>>        Else Begin
75028>>>>>>>>>            Move True to bFolderExists
75029>>>>>>>>>            Move True to bStop
75030>>>>>>>>>        End
75030>>>>>>>>>>
75030>>>>>>>>>    Until (bStop)
75032>>>>>>>>>    Close_Input channel iCh
75034>>>>>>>>>    Send Seq_Release_Channel iCh
75035>>>>>>>>>    Function_Return bFolderExists
75036>>>>>>>>>End_Function
75037>>>>>>>>>
75037>>>>>>>>>// returns folder name if a folder was selected, otherwise returns ""
75037>>>>>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
75039>>>>>>>>>    String  sPath
75039>>>>>>>>>    WString sFolder sTitle
75039>>>>>>>>>    Pointer lpItemIdList
75039>>>>>>>>>    Integer iFolderSelected iRetval
75039>>>>>>>>>    tvBrowseInfo BrowseInfo
75039>>>>>>>>>    tvBrowseInfo BrowseInfo
75039>>>>>>>>>
75039>>>>>>>>>    Move "" to sPath
75040>>>>>>>>>    If (sDialogTitle<>"") Begin
75042>>>>>>>>>        Move sDialogTitle to sTitle
75043>>>>>>>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
75043>>>>>>>>>        // disables showing some commonly used ascii characters like ascii 137 ()
75043>>>>>>>>>        // These chars are correctly shown if no toansi is used.
75043>>>>>>>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
75043>>>>>>>>>        // selected it will always be valid.
75043>>>>>>>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
75044>>>>>>>>>    End
75044>>>>>>>>>>
75044>>>>>>>>>
75044>>>>>>>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
75045>>>>>>>>>
75045>>>>>>>>>    // Torben Lund added line below. Move handle of focus object to structure before
75045>>>>>>>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
75045>>>>>>>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
75046>>>>>>>>>
75046>>>>>>>>>    // null 128 chars into var (make space)
75046>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
75047>>>>>>>>>
75047>>>>>>>>>    // select folder
75047>>>>>>>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
75048>>>>>>>>>    // get selected folder name
75048>>>>>>>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
75049>>>>>>>>>
75049>>>>>>>>>    // release memory resources that are used by the ItemIdList
75049>>>>>>>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
75050>>>>>>>>>
75050>>>>>>>>>    If (iFolderSelected<>0) Begin
75052>>>>>>>>>        Move (CString(sFolder)) to sPath
75053>>>>>>>>>    End
75053>>>>>>>>>>
75053>>>>>>>>>    Function_Return  sPath
75054>>>>>>>>>End_Function
75055>>>>>>>>>
75055>>>>>>>>>// returns 0 if the folder is created.
75055>>>>>>>>>//         1 if the API-call returned an error.
75055>>>>>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
75057>>>>>>>>>    Integer  iRetval bFolderCreated
75057>>>>>>>>>    WString  sFolder
75057>>>>>>>>>    tvSecurity_attributes SA
75057>>>>>>>>>    tvSecurity_attributes SA
75057>>>>>>>>>
75057>>>>>>>>>    Move False to bFolderCreated
75058>>>>>>>>>    If (sNewFolder <> "") Begin
75060>>>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
75061>>>>>>>>>        Move  0                                  to SA.lpDescriptor
75062>>>>>>>>>        Move  1                                  to SA.bInheritHandle
75063>>>>>>>>>        Move (sNewFolder+Character(0)) to sFolder
75064>>>>>>>>>        Move (vWin32_CreateDirectory(sFolder, AddressOf(SA))) to bFolderCreated
75065>>>>>>>>>    End
75065>>>>>>>>>>
75065>>>>>>>>>
75065>>>>>>>>>    If (bFolderCreated=false) Begin
75067>>>>>>>>>        Move 1 to iRetVal
75068>>>>>>>>>    End
75068>>>>>>>>>>
75068>>>>>>>>>    Function_Return iRetVal
75069>>>>>>>>>End_Function
75070>>>>>>>>>
75070>>>>>>>>>// **WvA: 03-02-2002 Function created.
75070>>>>>>>>>// With this function one can remove a directory.
75070>>>>>>>>>// returns 0 if the folder is removed.
75070>>>>>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
75070>>>>>>>>>//         2 if the folder did not exist
75070>>>>>>>>>//         3 if the sFolder parameter passed is equal to ""
75070>>>>>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
75072>>>>>>>>>    Boolean bRemoved
75072>>>>>>>>>    WString sPath
75072>>>>>>>>>    Integer iRetval
75072>>>>>>>>>
75072>>>>>>>>>    Move 0     to iRetVal
75073>>>>>>>>>    Move False to bRemoved
75074>>>>>>>>>    Move (Trim(sFolder)) to sFolder
75075>>>>>>>>>    If (sFolder="") Begin
75077>>>>>>>>>        Move 3 to iRetVal
75078>>>>>>>>>    End
75078>>>>>>>>>>
75078>>>>>>>>>    If (vFolderExists(sFolder)=False) Begin
75080>>>>>>>>>        Move 2 to iRetVal
75081>>>>>>>>>    End
75081>>>>>>>>>>
75081>>>>>>>>>    If (iRetVal=0) Begin
75083>>>>>>>>>        // null MAX_PATH chars into var (make space)
75083>>>>>>>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
75084>>>>>>>>>        //
75084>>>>>>>>>        Move (Insert(sFolder,sPath,1)) to sPath
75085>>>>>>>>>        Move (vWin32_RemoveDirectory(sPath)) to bRemoved
75086>>>>>>>>>    End
75086>>>>>>>>>>
75086>>>>>>>>>
75086>>>>>>>>>    If (iRetVal=0 And bRemoved=False) Begin
75088>>>>>>>>>        Move 1 to iRetVal
75089>>>>>>>>>    End
75089>>>>>>>>>>
75089>>>>>>>>>    Function_Return iRetVal
75090>>>>>>>>>End_Function
75091>>>>>>>>>
75091>>>>>>>>>// This will perform an operation on a file (e.g. open) with the application
75091>>>>>>>>>// registered in the Windows Registry to open that type of file (via its extension)
75091>>>>>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
75091>>>>>>>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
75093>>>>>>>>>    Handle  hInstance hWnd
75093>>>>>>>>>    // remove any leading/trailing spaces in the string
75093>>>>>>>>>    Move (Trim(sDocument)) to sDocument
75094>>>>>>>>>    Move (Trim(sPath))     to sPath
75095>>>>>>>>>    // Make the strings readable for windows API, by converting them to null-terminated
75095>>>>>>>>>    Append sOperation   (Character(0))
75096>>>>>>>>>    Append sDocument    (Character(0))
75097>>>>>>>>>    Append sParameters  (Character(0))
75098>>>>>>>>>    Append sPath        (Character(0))
75099>>>>>>>>>
75099>>>>>>>>>    Get Window_Handle to hWnd
75100>>>>>>>>>    Move (vWin32_ShellExecute (hWnd, sOperation, sDocument, sParameters, sPath, 1)) to hInstance
75101>>>>>>>>>    If (hInstance <= 32) Begin
75103>>>>>>>>>        Send vDDE_Error_Handler hInstance
75104>>>>>>>>>    End
75104>>>>>>>>>>
75104>>>>>>>>>End_Procedure
75105>>>>>>>>>
75105>>>>>>>>>Class cShellFileOperations is a Array
75106>>>>>>>>>
75106>>>>>>>>>    Procedure Construct_Object
75108>>>>>>>>>        Forward Send Construct_Object
75110>>>>>>>>>        Property Integer piDeleteFlags        0
75111>>>>>>>>>        Property Integer piCopyFlags          0
75112>>>>>>>>>        Property Integer piMoveFlags          0
75113>>>>>>>>>        Property Integer piRenameFlags        0
75114>>>>>>>>>
75114>>>>>>>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
75115>>>>>>>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
75116>>>>>>>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
75117>>>>>>>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
75118>>>>>>>>>    End_Procedure
75119>>>>>>>>>
75119>>>>>>>>>    // This function uses the shell API to perform a file operation on the
75119>>>>>>>>>    // files supplied.
75119>>>>>>>>>    //
75119>>>>>>>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
75121>>>>>>>>>        Integer  iRetVal
75121>>>>>>>>>        Integer  iUserAbort
75121>>>>>>>>>        WString  wsSource wsDestination
75121>>>>>>>>>        tvShFileOpStruct FOS
75121>>>>>>>>>        tvShFileOpStruct FOS
75121>>>>>>>>>
75121>>>>>>>>>        Move (sSource+Character(0)+Character(0))      to wsSource
75122>>>>>>>>>        Move (sDestination+Character(0)+Character(0)) to wsDestination
75123>>>>>>>>>
75123>>>>>>>>>        If (eOperation <> vFO_DELETE) Begin
75125>>>>>>>>>            Move (AddressOf(wsDestination)) to FOS.pTo
75126>>>>>>>>>        End
75126>>>>>>>>>>
75126>>>>>>>>>
75126>>>>>>>>>        Move eOperation            to FOS.wFunc
75127>>>>>>>>>        Move (AddressOf(wsSource)) to FOS.pFrom
75128>>>>>>>>>        Move iFlags                to FOS.fFlags
75129>>>>>>>>>
75129>>>>>>>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
75130>>>>>>>>>        Move FOS.fAnyOperationsAborted to iUserAbort
75131>>>>>>>>>        If (iUserAbort <> 0) Begin
75133>>>>>>>>>            Move 80 to iRetVal  // file Operation Aborted by USER
75134>>>>>>>>>        End
75134>>>>>>>>>>
75134>>>>>>>>>        Function_Return (iRetVal)
75135>>>>>>>>>    End_Function
75136>>>>>>>>>
75136>>>>>>>>>    Function sfoDeleteFile String sFileName Returns Integer
75138>>>>>>>>>        Integer  iRetVal
75138>>>>>>>>>        Integer  iFlags
75138>>>>>>>>>
75138>>>>>>>>>        Get piDeleteFlags to iFlags
75139>>>>>>>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
75140>>>>>>>>>        Function_Return iRetVal
75141>>>>>>>>>    End_Function
75142>>>>>>>>>
75142>>>>>>>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
75144>>>>>>>>>        Integer  iRetVal
75144>>>>>>>>>        Integer  iFlags
75144>>>>>>>>>
75144>>>>>>>>>        Get piCopyFlags to iFlags
75145>>>>>>>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
75146>>>>>>>>>        Function_Return iRetVal
75147>>>>>>>>>    End_Function
75148>>>>>>>>>
75148>>>>>>>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
75150>>>>>>>>>        Integer  iRetVal
75150>>>>>>>>>        Integer  iFlags
75150>>>>>>>>>
75150>>>>>>>>>        Get piMoveFlags to iFlags
75151>>>>>>>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
75152>>>>>>>>>        Function_Return iRetVal
75153>>>>>>>>>    End_Function
75154>>>>>>>>>
75154>>>>>>>>>    // Rename a file or folder
75154>>>>>>>>>    // Returns a nonzero value if the operation failed.
75154>>>>>>>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
75156>>>>>>>>>        Integer  iRetVal
75156>>>>>>>>>        Integer  iFlags
75156>>>>>>>>>
75156>>>>>>>>>        Get piRenameFlags to iFlags
75157>>>>>>>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
75158>>>>>>>>>        Function_Return iRetVal
75159>>>>>>>>>    End_Function
75160>>>>>>>>>
75160>>>>>>>>>
75160>>>>>>>>>    //Example:
75160>>>>>>>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
75160>>>>>>>>>    //                                          mode.
75160>>>>>>>>>
75160>>>>>>>>>End_Class
75161>>>>>>>>>
75161>>>>>>>>>Object oShellFileOperations is a cShellFileOperations
75163>>>>>>>>>End_Object
75164>>>>>>>>>
75164>>>>>>>>>// Restore to the old way of working with the shell file operations.
75164>>>>>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
75164>>>>>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
75164>>>>>>>>>Procedure vWin32fhCompatibilityMode
75166>>>>>>>>>    Integer hoSFO
75166>>>>>>>>>    Integer iFlags
75166>>>>>>>>>
75166>>>>>>>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
75167>>>>>>>>>    Move (oShellFileOperations(Self)) to hoSFO
75168>>>>>>>>>
75168>>>>>>>>>    Set piDeleteFlags of hoSFO to iFlags
75169>>>>>>>>>    Set piCopyFlags   of hoSFO to iFlags
75170>>>>>>>>>    Set piMoveFlags   of hoSFO to iFlags
75171>>>>>>>>>    Set piRenameFlags of hoSFO to iFlags
75172>>>>>>>>>End_Procedure
75173>>>>>>>>>
75173>>>>>>>>>// Delete a file or folder
75173>>>>>>>>>// Returns a nonzero value if the operation failed.
75173>>>>>>>>>Function vDeleteFile Global String sFileName Returns Integer
75175>>>>>>>>>    Integer  iRetVal
75175>>>>>>>>>
75175>>>>>>>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
75176>>>>>>>>>    Function_Return iRetVal
75177>>>>>>>>>End_Function
75178>>>>>>>>>
75178>>>>>>>>>// Copy a file or folder
75178>>>>>>>>>// Returns a nonzero value if the operation failed.
75178>>>>>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
75180>>>>>>>>>    Integer  iRetVal
75180>>>>>>>>>
75180>>>>>>>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75181>>>>>>>>>    Function_Return iRetVal
75182>>>>>>>>>End_Function
75183>>>>>>>>>
75183>>>>>>>>>// Move a file or folder
75183>>>>>>>>>// Returns a nonzero value if the operation failed.
75183>>>>>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
75185>>>>>>>>>    Integer  iRetVal
75185>>>>>>>>>
75185>>>>>>>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75186>>>>>>>>>    Function_Return iRetVal
75187>>>>>>>>>End_Function
75188>>>>>>>>>
75188>>>>>>>>>// Rename a file or folder
75188>>>>>>>>>// Returns a nonzero value if the operation failed.
75188>>>>>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
75190>>>>>>>>>    Integer  iRetVal
75190>>>>>>>>>
75190>>>>>>>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75191>>>>>>>>>    Function_Return iRetVal
75192>>>>>>>>>End_Function
75193>>>>>>>>>
75193>>>>>>>>>Function vGetWindowsDirectory Returns String
75195>>>>>>>>>    WString wDirectory
75195>>>>>>>>>    Integer iRetVal
75195>>>>>>>>>
75195>>>>>>>>>    Move (ZeroString(vMAX_PATH)) to wDirectory
75196>>>>>>>>>    Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), vMAX_PATH)) to iRetVal
75197>>>>>>>>>    If (iRetVal > vMAX_PATH) Begin
75199>>>>>>>>>        Move (ZeroString(iRetval)) to wDirectory
75200>>>>>>>>>        Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), iRetVal)) to iRetVal
75201>>>>>>>>>    End
75201>>>>>>>>>>
75201>>>>>>>>>    Function_Return (CString(wDirectory))
75202>>>>>>>>>End_Function
75203>>>>>>>>>
75203>>>>>>>>>Function vGetTempPath Returns String
75205>>>>>>>>>    Integer iRetVal
75205>>>>>>>>>    WString wTempPath
75205>>>>>>>>>
75205>>>>>>>>>    Move (ZeroString(vMAX_PATH)) to wTempPath
75206>>>>>>>>>    Move (vWin32_GetTempPath(vMAX_PATH, AddressOf(wTempPath))) to iRetVal
75207>>>>>>>>>    If (iRetVal > vMAX_PATH) Begin
75209>>>>>>>>>        Move (ZeroString(iRetval)) to wTempPath
75210>>>>>>>>>        Move (vWin32_GetTempPath(iRetVal, AddressOf(wTempPath))) to iRetVal
75211>>>>>>>>>    End
75211>>>>>>>>>>
75211>>>>>>>>>    Function_Return (CString(wTempPath))
75212>>>>>>>>>End_Function
75213>>>>>>>>>
75213>>>>>>>>>// Courtesy of Marco Kuipers
75213>>>>>>>>>Function vMakeTempFile Returns String
75215>>>>>>>>>    Integer iRetval
75215>>>>>>>>>    String  sTempPath
75215>>>>>>>>>    String  sTempFileName
75215>>>>>>>>>    String  sPrefixString
75215>>>>>>>>>    WString wsTempFileName
75215>>>>>>>>>
75215>>>>>>>>>    Get vGetTempPath to sTempPath
75216>>>>>>>>>    If (sTempPath = "") Begin
75218>>>>>>>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
75219>>>>>>>>>        If (sTempPath<>"") Begin
75221>>>>>>>>>            Move (sTempPath+"\Temp\") to sTempPath
75222>>>>>>>>>        End
75222>>>>>>>>>>
75222>>>>>>>>>    End
75222>>>>>>>>>>
75222>>>>>>>>>
75222>>>>>>>>>    If (sTempPath = "") Begin
75224>>>>>>>>>        // second fallback we really do not want to get here as to be fair using current folder as temp
75224>>>>>>>>>        // makes little sense. Leaving this in as it was old behavior.
75224>>>>>>>>>        Get_Current_Directory to sTempPath
75225>>>>>>>>>    End
75225>>>>>>>>>>
75225>>>>>>>>>
75225>>>>>>>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
75226>>>>>>>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
75228>>>>>>>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
75229>>>>>>>>>>
75229>>>>>>>>>    End
75229>>>>>>>>>>
75229>>>>>>>>>
75229>>>>>>>>>    Move (ZeroString(vMax_Path)) to wsTempFileName
75230>>>>>>>>>    Move ("tmp"+Character(0))    to sPrefixString
75231>>>>>>>>>    Move (vWin32_GetTempFileName (sTempPath, sPrefixString, 0, AddressOf(wsTempFileName))) to iRetval
75232>>>>>>>>>    If (iRetval = 0) Begin  // The api call returns 0 if an error occurs
75234>>>>>>>>>    //Get ShowLastError to iRetval
75234>>>>>>>>>        Move "" to sTempFileName
75235>>>>>>>>>    End
75235>>>>>>>>>>
75235>>>>>>>>>    Move (Cstring(wsTempFileName)) to sTempFileName
75236>>>>>>>>>    Function_Return sTempFileName
75237>>>>>>>>>End_Function
75238>>>>>>>>>
75238>>>>>>>>>// This function creates a uniquely named temporary file in folder sPath
75238>>>>>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
75238>>>>>>>>>// Note that you will have to cleanup the tempfile yourself as the function
75238>>>>>>>>>// does not take care of that.
75238>>>>>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
75240>>>>>>>>>    Integer iRetVal
75240>>>>>>>>>    String  sTempFileName
75240>>>>>>>>>    WString wTempFileName
75240>>>>>>>>>
75240>>>>>>>>>    Move (sPath+Character(0))   to sPath
75241>>>>>>>>>    Move (sPrefix+Character(0)) to sPrefix
75242>>>>>>>>>    Move (Pad("", vMAX_PATH))   to wTempFileName
75243>>>>>>>>>
75243>>>>>>>>>    Move (vWin32_GetTempFileName(sPath, sPrefix, 0, AddressOf(wTempFileName))) to iRetVal
75244>>>>>>>>>    Move (Trim(Cstring(wTempFileName))) to sTempFileName
75245>>>>>>>>>    Function_Return sTempFileName
75246>>>>>>>>>End_Function
75247>>>>>>>>>
75247>>>>>>>>>//
75247>>>>>>>>>// Get a specific shell folder for example to get the desktop folder
75247>>>>>>>>>// simply call this function and pass it vCSIDL_DESKTOP
75247>>>>>>>>>//
75247>>>>>>>>>Function vSHGetFolderPath Integer eFolder Returns String
75249>>>>>>>>>    Integer iVoid
75249>>>>>>>>>    Handle  hWnd
75249>>>>>>>>>    String  sFolder
75249>>>>>>>>>    WString wFolder
75249>>>>>>>>>
75249>>>>>>>>>    Move (Window_Handle(focus(desktop))) to hWnd
75250>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to wFolder
75251>>>>>>>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(wFolder))) To iVoid
75252>>>>>>>>>    Move (CString(wFolder)) to sFolder
75253>>>>>>>>>    Function_Return sFolder
75254>>>>>>>>>End_Function
75255>>>>>>>>>
75255>>>>>>>>>// Courtesy Of Vincent Oorsprong
75255>>>>>>>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
75257>>>>>>>>>    String  sFileDateTime
75257>>>>>>>>>    WString wFormattedTime wFormattedDate
75257>>>>>>>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
75257>>>>>>>>>    tvFileTime   FileTime
75257>>>>>>>>>    tvFileTime   FileTime
75257>>>>>>>>>    tvSystemTime SystemTime
75257>>>>>>>>>    tvSystemTime SystemTime
75257>>>>>>>>>
75257>>>>>>>>>    Move "" to sFileDateTime
75258>>>>>>>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
75259>>>>>>>>>    Move dwHighDateTime to FileTime.dwHighDateTime
75260>>>>>>>>>
75260>>>>>>>>>    Move 0 to SystemTime.wYear
75261>>>>>>>>>
75261>>>>>>>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
75262>>>>>>>>>    If (iSuccess = 1) Begin
75264>>>>>>>>>        Move (ZeroString(255))               to wFormattedTime
75265>>>>>>>>>        Move (SizeOfWString(wFormattedTime)) to iLenCcTime
75266>>>>>>>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedTime), iLenCcTime)) to iDataLength
75267>>>>>>>>>        Move (ZeroString(255))               to wFormattedDate
75268>>>>>>>>>        Move (SizeOfWString(wFormattedDate)) to iLenCcDate
75269>>>>>>>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedDate), iLenCcDate)) to iDataLength
75270>>>>>>>>>        Move (Cstring (wFormattedDate)  * Cstring (wFormattedTime)) to sFileDateTime
75271>>>>>>>>>    End
75271>>>>>>>>>>
75271>>>>>>>>>    Function_Return sFileDateTime
75272>>>>>>>>>End_Function
75273>>>>>>>>>
75273>>>>>>>>>// **WvA:
75273>>>>>>>>>// A windows replacement for the standard function FileExists.
75273>>>>>>>>>// This version will also return (true) for a file when it is open by an application.
75273>>>>>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
75273>>>>>>>>>// Example: Get vFilePathExists "C:\config.sy?"
75273>>>>>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
75273>>>>>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
75275>>>>>>>>>    String  sDirSep
75275>>>>>>>>>    Handle  hFindFile
75275>>>>>>>>>    Integer iVoid
75275>>>>>>>>>    tvWin32FindData FindData
75275>>>>>>>>>    tvWin32FindData FindData
75275>>>>>>>>>
75275>>>>>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
75276>>>>>>>>>    Move (Trim(sFilePathMask)) to sFilePathMask
75277>>>>>>>>>
75277>>>>>>>>>    If (Length(sFilePathMask)>0) Begin
75279>>>>>>>>>        // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
75279>>>>>>>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75280>>>>>>>>>        While (Right(sFilePathMask, 1) = sDirSep)
75284>>>>>>>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
75285>>>>>>>>>        Loop
75286>>>>>>>>>>
75286>>>>>>>>>
75286>>>>>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75287>>>>>>>>>        Move (vWin32_FindFirstFile (sFilePathMask, AddressOf(FindData))) to hFindFile
75288>>>>>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
75289>>>>>>>>>    End
75289>>>>>>>>>>
75289>>>>>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
75290>>>>>>>>>End_Function
75291>>>>>>>>>
75291>>>>>>>>>
75291>>>>>>>>>//
75291>>>>>>>>>// Returns the amount of files in the folder (if it exists)
75291>>>>>>>>>// Returns -1 if folder doesn't exist.
75291>>>>>>>>>// The files "." and ".." are not counted.
75291>>>>>>>>>//
75291>>>>>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
75293>>>>>>>>>    Boolean bFound
75293>>>>>>>>>    Handle  hFindFile
75293>>>>>>>>>    Integer iCount  iVoid
75293>>>>>>>>>    Integer iSuccess
75293>>>>>>>>>    String  sFileName
75293>>>>>>>>>    tvWin32FindData FindData
75293>>>>>>>>>    tvWin32FindData FindData
75293>>>>>>>>>
75293>>>>>>>>>    Move -1 to iCount
75294>>>>>>>>>    Get vFolderFormat sFolderName to sFolderName
75295>>>>>>>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
75296>>>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75297>>>>>>>>>    Move (vWin32_FindFirstFile (sFolderName, AddressOf(FindData))) to hFindFile
75298>>>>>>>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
75299>>>>>>>>>    If (bFound) Begin
75301>>>>>>>>>        Move 0 to iCount
75302>>>>>>>>>    End
75302>>>>>>>>>>
75302>>>>>>>>>    While (bFound)
75306>>>>>>>>>        Increment iCount
75307>>>>>>>>>        Move (PointerToWString(AddressOf(FindData.cFileName))) to sFileName
75308>>>>>>>>>        If (sFileName="." or sFileName="..") Begin
75310>>>>>>>>>            Decrement iCount
75311>>>>>>>>>        End
75311>>>>>>>>>>
75311>>>>>>>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
75312>>>>>>>>>        Move (iSuccess<>0) to bFound
75313>>>>>>>>>    Loop
75314>>>>>>>>>>
75314>>>>>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
75315>>>>>>>>>    Function_Return iCount
75316>>>>>>>>>End_Function
75317>>>>>>>>>
75317>>>>>>>>>// Create the folder, including intermediate directories.
75317>>>>>>>>>// Don't panic if the folder already exists.
75317>>>>>>>>>// Michael Mullan June 2009.
75317>>>>>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
75319>>>>>>>>>    String  sFolder
75319>>>>>>>>>    Integer iRetval iFolderCreated
75319>>>>>>>>>    tvSecurity_attributes SA
75319>>>>>>>>>    tvSecurity_attributes SA
75319>>>>>>>>>
75319>>>>>>>>>    Move 0 to iFolderCreated
75320>>>>>>>>>
75320>>>>>>>>>    // null MAX_PATH chars into var (make space)
75320>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
75321>>>>>>>>>    If (sNewFolder <> "") Begin
75323>>>>>>>>>
75323>>>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
75324>>>>>>>>>        Move  0  to SA.lpDescriptor
75325>>>>>>>>>        Move  1  to SA.bInheritHandle
75326>>>>>>>>>
75326>>>>>>>>>        //
75326>>>>>>>>>        Move (sNewFolder+"") to sFolder
75327>>>>>>>>>        Move (vWin32_SHCreateDirectoryEx(0,sFolder, AddressOf(SA))) to iFolderCreated
75328>>>>>>>>>    End
75328>>>>>>>>>>
75328>>>>>>>>>
75328>>>>>>>>>    If (iFolderCreated <> 0) Begin
75330>>>>>>>>>        Move 1 to iRetVal
75331>>>>>>>>>        Case Begin
75331>>>>>>>>>            Case (iFolderCreated = 161)
75333>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
75334>>>>>>>>>>
75334>>>>>>>>>                Case Break
75335>>>>>>>>>            Case (iFolderCreated = 206)
75338>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
75339>>>>>>>>>>
75339>>>>>>>>>                Case Break
75340>>>>>>>>>            Case (iFolderCreated = 3)
75343>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
75344>>>>>>>>>>
75344>>>>>>>>>                Case Break
75345>>>>>>>>>            Case (iFolderCreated = 80)
75348>>>>>>>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
75349>>>>>>>>>                Case Break
75350>>>>>>>>>            Case (iFolderCreated = 183)
75353>>>>>>>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
75354>>>>>>>>>                Case Break
75355>>>>>>>>>            Case (iFolderCreated = 1223)
75358>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
75359>>>>>>>>>>
75359>>>>>>>>>                Case Break
75360>>>>>>>>>            Case Else
75360>>>>>>>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
75361>>>>>>>>>>
75361>>>>>>>>>        Case End
75361>>>>>>>>>    End
75361>>>>>>>>>>
75361>>>>>>>>>    Function_Return iRetVal
75362>>>>>>>>>End_Function
75363>>>>>>>>>
75363>>>>>>>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
75365>>>>>>>>>    DWord   dwFileSizeHigh dwFileSizeLow
75365>>>>>>>>>    Integer iFileSize iVoid
75365>>>>>>>>>    Handle  hFindFile
75365>>>>>>>>>    tvWin32FindData FindData
75365>>>>>>>>>    tvWin32FindData FindData
75365>>>>>>>>>
75365>>>>>>>>>    Move (sFileName+"") to sFileName
75366>>>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75367>>>>>>>>>    Move (vWin32_FindFirstFile (sFileName, AddressOf(FindData))) to hFindFile
75368>>>>>>>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
75370>>>>>>>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
75371>>>>>>>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
75372>>>>>>>>>    End
75372>>>>>>>>>>
75372>>>>>>>>>    Move (vWin32_FindClose(hFindFile)) to iVoid
75373>>>>>>>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
75374>>>>>>>>>
75374>>>>>>>>>    Function_Return iFileSize
75375>>>>>>>>>End_Function
75376>>>>>>>>>
75376>>>>>>>>>//
75376>>>>>>>>>// Based on code in Peter Crook's Browse folder workspace
75376>>>>>>>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
75376>>>>>>>>>//
75376>>>>>>>>>//=============================================================================
75376>>>>>>>>>// Verifies that a path is a valid directory.
75376>>>>>>>>>//
75376>>>>>>>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
75376>>>>>>>>>//
75376>>>>>>>>>// Parameters:
75376>>>>>>>>>//      sPath - Address of the path to verify.
75376>>>>>>>>>//=============================================================================
75376>>>>>>>>>Function vPathIsDirectory Global String sPath Returns Boolean
75378>>>>>>>>>    Integer iResult
75378>>>>>>>>>    Boolean bRetVal
75378>>>>>>>>>
75378>>>>>>>>>    Move false to bRetVal
75379>>>>>>>>>    Move (sPath - Character (0)) to sPath
75380>>>>>>>>>    Move (vWin32_PathIsDirectory (sPath)) to iResult
75381>>>>>>>>>    If (iResult<>0) Begin
75383>>>>>>>>>        Move True to bRetVal
75384>>>>>>>>>    End
75384>>>>>>>>>>
75384>>>>>>>>>
75384>>>>>>>>>    Function_Return bRetVal
75385>>>>>>>>>End_Function
75386>>>>>>>>>
75386>>>>>>>
75386>>>>>>>//
75386>>>>>>>// Gets the string from the right of the last sStopChar in sFrom
75386>>>>>>>// If sStopChar has no occurences in the string an empty string is
75386>>>>>>>// returned.
75386>>>>>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
75388>>>>>>>    String  sRetVal
75388>>>>>>>    String  sChar
75388>>>>>>>    Integer iLength
75388>>>>>>>    Integer iPos
75388>>>>>>>    Boolean bStopChar
75388>>>>>>>    Move "" to sRetval
75389>>>>>>>    Move (Length(sFrom)) to iLength
75390>>>>>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
75392>>>>>>>        Move iLength   to iPos
75393>>>>>>>        Move (False)   to bStopChar
75394>>>>>>>        While Not bStopChar
75398>>>>>>>            Move (Mid(sFrom,1,iPos)) to sChar
75399>>>>>>>            Decrement iPos
75400>>>>>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
75402>>>>>>>                Move (True) to bStopChar
75403>>>>>>>            End
75403>>>>>>>>
75403>>>>>>>            Else Begin
75404>>>>>>>                Move (sChar+sRetVal) to sRetVal
75405>>>>>>>            End
75405>>>>>>>>
75405>>>>>>>        Loop
75406>>>>>>>>
75406>>>>>>>    End
75406>>>>>>>>
75406>>>>>>>    Function_Return sRetVal
75407>>>>>>>End_Function
75408>>>>>>>
75408>>>>>>>// Pre:  sFileName contains the complete path of the file.
75408>>>>>>>// Post: returns the complete path of the file.
75408>>>>>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
75408>>>>>>>Function ParseFolderName Global String sFileName Returns String
75410>>>>>>>    String sFile
75410>>>>>>>    String sFolderName
75410>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
75410>>>>>>>
75410>>>>>>>    Move "" to sFolderName
75411>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75412>>>>>>>    If sDirSep In sFileName Begin
75414>>>>>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
75415>>>>>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
75416>>>>>>>    End
75416>>>>>>>>
75416>>>>>>>    Else If ":" In sFileName Begin
75419>>>>>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
75420>>>>>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
75421>>>>>>>    End
75421>>>>>>>>
75421>>>>>>>    Function_Return sFolderName
75422>>>>>>>End_Function
75423>>>>>>>
75423>>>>>>>// Pre:  sFileName contains the complete path of the file.
75423>>>>>>>// post: The returned filename has it's path removed, but will have a extension
75423>>>>>>>Function ParseFileName Global String sFileName Returns String
75425>>>>>>>    String sFolderName
75425>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
75425>>>>>>>
75425>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75426>>>>>>>    Get ParseFolderName sFileName to sFolderName
75427>>>>>>>    If (sFolderName <> "") Begin
75429>>>>>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
75430>>>>>>>    End
75430>>>>>>>>
75430>>>>>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
75431>>>>>>>    Function_Return sFilename
75432>>>>>>>End_Function
75433>>>>>>>
75433>>>>>>>// Pre:  sFileName may contain the complete path of the file.
75433>>>>>>>//       or contain multiple dots in the filename, so temp.gif.bak will
75433>>>>>>>//       return "bak" as the extension and not "gif"
75433>>>>>>>// Post: returns the extension only, this extension can be a valid unixlike extension
75433>>>>>>>//       such as "html" or "java"
75433>>>>>>>Function ParseFileExtension Global String sFileName Returns String
75435>>>>>>>    String  sFileExtension
75435>>>>>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
75436>>>>>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
75437>>>>>>>    Function_Return sFileExtension
75438>>>>>>>End_Function
75439>>>>>>>
75439>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
75439>>>>>>>
75439>>>>>>>Function DDE_Error_To_String Integer iErrorID Returns String
75441>>>>>>>    String sMessage
75441>>>>>>>    Case Begin
75441>>>>>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
75443>>>>>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
75444>>>>>>>            Case Break
75445>>>>>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
75448>>>>>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
75449>>>>>>>            Case Break
75450>>>>>>>        Case (iErrorID = vERROR_BAD_FORMAT)
75453>>>>>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
75454>>>>>>>            Case Break
75455>>>>>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
75458>>>>>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
75459>>>>>>>            Case Break
75460>>>>>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
75463>>>>>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
75464>>>>>>>            Case Break
75465>>>>>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
75468>>>>>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
75469>>>>>>>            Case Break
75470>>>>>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
75473>>>>>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
75474>>>>>>>            Case Break
75475>>>>>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
75478>>>>>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
75479>>>>>>>            Case Break
75480>>>>>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
75483>>>>>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
75484>>>>>>>            Case Break
75485>>>>>>>        Case (iErrorID = vSE_ERR_NOASSOC)
75488>>>>>>>            Move CS_DDE_ERR_NOASSOC to sMessage
75489>>>>>>>            Case Break
75490>>>>>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
75493>>>>>>>            Move CS_DDE_ERR_OOM to sMessage
75494>>>>>>>            Case Break
75495>>>>>>>        Case (iErrorID = vSE_ERR_PNF)
75498>>>>>>>            Move CS_DDE_ERR_PNF to sMessage
75499>>>>>>>            Case Break
75500>>>>>>>        Case (iErrorID = vSE_ERR_SHARE)
75503>>>>>>>            Move CS_DDE_ERR_SHARE to sMessage
75504>>>>>>>            Case Break
75505>>>>>>>        Case Else
75505>>>>>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
75506>>>>>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
75507>>>>>>>            Case Break
75508>>>>>>>    Case End
75508>>>>>>>    Function_Return sMessage
75509>>>>>>>End_Function
75510>>>>>>>
75510>>>>>>>Procedure vDDE_Error_Handler Integer iErrorID
75512>>>>>>>    String sMessage
75512>>>>>>>    Get DDE_Error_To_String iErrorID to sMessage
75513>>>>>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
75514>>>>>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
75515>>>>>>>End_Procedure
75516>>>>>>>
75516>>>>>>>
75516>>>>>>>// This function informs the user that he entered a yet unknown folder and
75516>>>>>>>// asks if he/she wants to create the folder (Yes/No)
75516>>>>>>>// Choice: "Yes" - this creates the folder
75516>>>>>>>//                 if successful, the function returns false
75516>>>>>>>//                 else it will be true.
75516>>>>>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
75516>>>>>>>//                 For example: to stop a save
75516>>>>>>>// Precondition: A foldername must be entered. We do not check for empty paths
75516>>>>>>>// This function returns a non-zero value if the folder isn't created afterwards
75516>>>>>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
75518>>>>>>>    Integer bIsNotValid
75518>>>>>>>    Integer iUsers_Choice
75518>>>>>>>    String  sMessage
75518>>>>>>>
75518>>>>>>>    If (vFolderExists(sFolderName) Eq 0) Begin
75520>>>>>>>        Move "The folder '" to sMessage
75521>>>>>>>        Append sMessage sFolderName
75522>>>>>>>        Append sMessage "' does not yet exist,\n"
75523>>>>>>>        Append sMessage "Do you want to create it now?"
75524>>>>>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
75525>>>>>>>        Case Begin
75525>>>>>>>            Case (iUsers_Choice = MBR_Yes)
75527>>>>>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
75528>>>>>>>                If bIsNotValid Begin
75530>>>>>>>                    Move "An error occurred while trying to create folder '" to sMessage
75531>>>>>>>                    Append sMessage sFolderName "'.\n\n"
75533>>>>>>>                    Send Info_Box sMessage "Info"
75534>>>>>>>                End
75534>>>>>>>>
75534>>>>>>>                Case Break
75535>>>>>>>            Case (iUsers_Choice = MBR_No)
75538>>>>>>>                Move dfTrue to bIsNotValid // Cancel the save
75539>>>>>>>                Case Break
75540>>>>>>>        Case End
75540>>>>>>>    End
75540>>>>>>>>
75540>>>>>>>    Function_Return bIsNotValid
75541>>>>>>>End_Function
75542>>>>>>>
75542>>>>>>>// **WvA
75542>>>>>>>// Formats a foldername by first trimming it and after that by sticking a
75542>>>>>>>// directory separator (/\) to the end if it doesn't have one there already.
75542>>>>>>>// The folder may contain a drive letter or UNC encoding.
75542>>>>>>>Function vFolderFormat Global String sFolderName Returns String
75544>>>>>>>    String sDirSep
75544>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
75545>>>>>>>    Move (Trim(sFolderName)) to sFolderName
75546>>>>>>>    If (Right(sFolderName,1)<>sDirSep) Begin
75548>>>>>>>        Move (sFolderName+sDirSep) to sFolderName
75549>>>>>>>    End
75549>>>>>>>>
75549>>>>>>>    Function_Return sFolderName
75550>>>>>>>End_Function
75551>>>>>>>
75551>>>>>>>//
75551>>>>>>>// Gets the parent path of the currently supplied path
75551>>>>>>>// Returns "" when we are at the root folder.
75551>>>>>>>//
75551>>>>>>>Function vParentPath Global String sPath Returns String
75553>>>>>>>    String sStrip sDirSep
75553>>>>>>>
75553>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75554>>>>>>>    Move (Trim(sPath)) to sPath
75555>>>>>>>    If (Right(sPath,1) = sDirSep) Begin
75557>>>>>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
75558>>>>>>>    End
75558>>>>>>>>
75558>>>>>>>    If (Pos(sDirSep, sPath)) Begin
75560>>>>>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
75561>>>>>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
75562>>>>>>>    End
75562>>>>>>>>
75562>>>>>>>    Else Begin
75563>>>>>>>        Move "" to sPath
75564>>>>>>>    End
75564>>>>>>>>
75564>>>>>>>    Function_Return sPath
75565>>>>>>>End_Function
75566>>>>>Use DUFLanguageConstants.inc
75566>>>>>
75566>>>>>Define CS_IntFilesTableLogicalName for "IntFilesTable"
75566>>>>>// Do *not* change this name as it is used by the CheckIntFilesIntegrity
75566>>>>>// procedure and the explicit file name is used with the Include_Resource command.
75566>>>>>Define CS_FilelistBackupFile    for "FilelistBackupFile.cfg"
75566>>>>>
75566>>>>>Struct tDUFIntFile
75566>>>>>    Integer iID
75566>>>>>    String sIntFileName
75566>>>>>    String sIntLineText
75566>>>>>End_Struct
75566>>>>>
75566>>>>>Struct tDbVersionInfo
75566>>>>>    Number nVersionNumber
75566>>>>>    Handle hObject
75566>>>>>End_Struct
75566>>>>>
75566>>>>>Struct tDbUpdateError
75566>>>>>    Number nUpdateVersion
75566>>>>>    Integer iError
75566>>>>>    String  sOrgErrorText
75566>>>>>    String  sErrorText
75566>>>>>    Integer iErrorLine
75566>>>>>    Boolean bError  
75566>>>>>    Handle  hTable 
75566>>>>>    String  sTableRootName
75566>>>>>    Integer iField
75566>>>>>    Boolean bShortFormat
75566>>>>>End_Struct
75566>>>>>
75566>>>>>//  DF_FILE_ALIAS_DEFAULT if no master or alias
75566>>>>>//  DF_FILE_IS_MASTER if master
75566>>>>>//  DF_FILE_IS_ALIAS if alias
75566>>>>>Struct tDbUpdateHandlerMasterAlias
75566>>>>>    Handle hTable
75566>>>>>    Integer iMode
75566>>>>>End_Struct
75566>>>>>
75566>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
75566>>>>>Enumeration_List
75566>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
75566>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
75566>>>>>End_Enumeration_List
75566>>>>>
75566>>>>>    Define DATAFLEX_ID for "DATAFLEX"
75566>>>>>
75566>>>>>// Global handle to a cDatabaseUpdateHandler object that can be used to
75566>>>>>// communicate with the object from anywhere in a program.
75566>>>>>    Global_Variable Handle ghoDbUpdateHandler
75566>>>>>    Move 0 to ghoDbUpdateHandler
75567>>>>>
75567>>>>>// NOTE: If the DbVersion table should _not_ be used and you
75567>>>>>// instead set the "Set Data_File_Field to (RefTable(MyTable)) (RefTable(MyTable.DbUpdateVersion))"
75567>>>>>// in the cDbUpdateHandler object; Add a "Define DUF_Use_DbVersion" to your code,
75567>>>>>// _before_ the "Use cDbUpdateHandler.pkg" line.
75567>>>>>//#IFNDEF DUF_Use_Custom_DbVersion
75567>>>>>//    Declare_Datafile DbVersion
75567>>>>>//#ENDIF
75567>>>Use cDbUpdateLogFile.pkg
Including file: cDbUpdateLogFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateLogFile.pkg)
75567>>>>>//****************************************************************************
75567>>>>>// $Module type: Class
75567>>>>>// $Module name: cDbUpdateLogFile
75567>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75567>>>>>// Web-site    : http://www.rdctools.com
75567>>>>>// Created     : 2016-10-05 @ 18:58 (Military date format: YY-MM-DD)
75567>>>>>//
75567>>>>>// Description : This logic was moved from the cDbUpdateHandler class so that it would
75567>>>>>//               be easier to change to where errors/status messages are written/saved. As it is less likely
75567>>>>>//               that this class is to change; each developer can decide if the errors instead
75567>>>>>//               should be saved to a database table, or something entirely different.
75567>>>>>//               The default is to write the errors to a Ascii-file in the Data folder.
75567>>>>>//
75567>>>>>// $Rev History:
75567>>>>>//    2016-10-05  Module header created
75567>>>>>//****************************************************************************
75567>>>>>Use UI
75567>>>>>Use vWin32fh.pkg
75567>>>>>
75567>>>>>
75567>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
75567>>>>>
75567>>>>>Define CS_SuccessfulUpdate for "The database was updated successfully!"
75567>>>>>
75567>>>>>Class cDbUpdateLogFile is a cObject
75568>>>>>
75568>>>>>    Procedure Construct_Object
75570>>>>>        Forward Send Construct_Object
75572>>>>>
75572>>>>>        // Error handling:
75572>>>>>        Property tDbUpdateError[] paDbUpdateErrorArray
75573>>>>>        Property Integer piChannel -1
75574>>>>>
75574>>>>>        // This property is set by the cDbUpdateHandler object,
75574>>>>>        // when the update process starts.
75574>>>>>        Property DateTime pdtUpdateStart
75575>>>>>
75575>>>>>        // Gets set to False if the log contains data
75575>>>>>        Property Boolean pbEmptyLogFile True
75576>>>>>
75576>>>>>        // Gets set to True after the error log header text
75576>>>>>        // has been written.
75576>>>>>        Property Boolean pbHeaderWritten False
75577>>>>>
75577>>>>>        // If all activities should be logged- not just errors.
75577>>>>>        Property Boolean pbVerboseState False
75578>>>>>
75578>>>>>        // File name for the error log where all errors
75578>>>>>        // after a run is written to (appended).
75578>>>>>        // It is saved in the Data folder.
75578>>>>>        Property String psLogTextFile   "DUFUpdateLog.txt"
75579>>>>>        // If this property is set to "" in object code, the
75579>>>>>        // "shell" command parameter will be used to let Windows decide
75579>>>>>        // with which program to open the logfile.
75579>>>>>        Property String psEditorProgram ""
75580>>>>>
75580>>>>>        Property Boolean pbUseDataTableLog False
75581>>>>>
75581>>>>>        // If true an error will be written to file immediately when
75581>>>>>        // it occurs. This can be handy if a large update generates a lots
75581>>>>>        // of errors and the application crasches before finished, thus
75581>>>>>        // the errors will not be written.
75581>>>>>        Property Boolean pbQuickWrite True
75582>>>>>    End_Procedure
75583>>>>>
75583>>>>>    Procedure End_Construct_Object
75585>>>>>        Forward Send End_Construct_Object
75587>>>>>
75587>>>>>    End_Procedure
75588>>>>>
75588>>>>>    Procedure LogError Number nVersion Integer iError String sErrorText Integer iErrorLine Boolean bError Boolean bShortFormatIn
75590>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
75590>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
75592>>>>>        Boolean bShortFormat
75592>>>>>        Integer iSize
75592>>>>>        Handle hCurrentTable
75592>>>>>        Integer iCurrentField           
75592>>>>>        String sOrgErrorText sTableRootName
75592>>>>>        
75592>>>>>        Move False to bShortFormat
75593>>>>>        If (num_arguments > 5) Begin
75595>>>>>            Move bShortFormatIn to bShortFormat
75596>>>>>        End
75596>>>>>>
75596>>>>>        // Only do once.
75596>>>>>        If (pbHeaderWritten(Self) = False) Begin
75598>>>>>            Send WriteHeaderData
75599>>>>>            Set pbHeaderWritten to True
75600>>>>>        End
75600>>>>>>
75600>>>>>
75600>>>>>        Get Private.phCurrentTable to hCurrentTable  
75601>>>>>        Get Private.piCurrentField to iCurrentField  
75602>>>>>        If (iError > 0) Begin
75604>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hCurrentTable to sTableRootName
75607>>>>>            Get FetchErrorDescription iError to sOrgErrorText 
75608>>>>>        End
75608>>>>>>
75608>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
75609>>>>>        Move (SizeOfArray(DbUpdateErrorArray)) to iSize
75610>>>>>        Move nVersion       to DbUpdateErrorArray[iSize].nUpdateVersion
75611>>>>>        Move iError         to DbUpdateErrorArray[iSize].iError
75612>>>>>        Move iErrorLine     to DbUpdateErrorArray[iSize].iErrorLine
75613>>>>>        Move True           to DbUpdateErrorArray[iSize].bError  
75614>>>>>        Move sOrgErrorText  to DbUpdateErrorArray[iSize].sOrgErrorText
75615>>>>>        Move sErrorText     to DbUpdateErrorArray[iSize].sErrorText
75616>>>>>        Move hCurrentTable  to DbUpdateErrorArray[iSize].hTable            
75617>>>>>        Move sTableRootName to DbUpdateErrorArray[iSize].sTableRootName
75618>>>>>        Move iCurrentField  to DbUpdateErrorArray[iSize].iField  
75619>>>>>        Move bShortFormat   to DbUpdateErrorArray[iSize].bShortFormat
75620>>>>>
75620>>>>>        If (bError = False) Begin
75622>>>>>            Move False to DbUpdateErrorArray[iSize].bError
75623>>>>>        End
75623>>>>>>
75623>>>>>        Set paDbUpdateErrorArray to DbUpdateErrorArray
75624>>>>>
75624>>>>>        If (pbUseDataTableLog(Self) = True) Begin
75626>>>>>            If (pbQuickWrite(Self) = True) Begin
75628>>>>>                Send OnWriteRow_DataTable
75629>>>>>                // If we are writing error for error flush the
75629>>>>>                // error array when latest error has been written.
75629>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
75630>>>>>            End
75630>>>>>>
75630>>>>>            Procedure_Return
75631>>>>>        End
75631>>>>>>
75631>>>>>        Else Begin
75632>>>>>            If (pbQuickWrite(Self) = True) Begin
75634>>>>>                Send WriteErrorLog
75635>>>>>                // Flush the error log array
75635>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty 
75636>>>>>            End
75636>>>>>>
75636>>>>>        End
75636>>>>>>
75636>>>>>    End_Procedure   
75637>>>>>    
75637>>>>>    Function FetchErrorDescription Integer iError Returns String
75639>>>>>        String sErrorText         
75639>>>>>        Move "" to sErrorText
75640>>>>>        If (iError > 0) Begin
75642>>>>>            Move (Error_Text(Desktop, iError)) to sErrorText 
75643>>>>>        End
75643>>>>>>
75643>>>>>        Function_Return sErrorText
75644>>>>>    End_Function
75645>>>>>
75645>>>>>    // Hook procedure for writing header text prior starting the update work to
75645>>>>>    // a database table. This does nothing by default.
75645>>>>>    // Don't forget to Open your "error log table" first (!) as all
75645>>>>>    // tables have been closed at this stage. Put anything
75645>>>>>    // you want to indicate that the update process is just started.
75645>>>>>    Procedure OnWriteHeader_DataTable DateTime dtUpdateStart
75647>>>>>        Delegate Send OnErrorWriteHeader_DataTable dtUpdateStart
75649>>>>>    End_Procedure
75650>>>>>
75650>>>>>    Procedure OnWriteRow_DataTable
75652>>>>>        tDbUpdateError[] DbUpdateErrorArray
75652>>>>>        tDbUpdateError[] DbUpdateErrorArray
75653>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
75654>>>>>        If (SizeOfArray(DbUpdateErrorArray) > 0) Begin
75656>>>>>            Delegate Send OnErrorWriteRow_DataTable DbUpdateErrorArray
75658>>>>>        End
75658>>>>>>
75658>>>>>    End_Procedure
75659>>>>>
75659>>>>>    Function psLogTextFileWithPath Returns String
75661>>>>>        String sPath sFileName sFullFileName
75661>>>>>        
75661>>>>>        Get psDataPathFirstPart to sPath
75662>>>>>        Get psLogTextFile to sFileName
75663>>>>>        Move (sPath + sFileName) to sFullFileName
75664>>>>>        Function_Return sFullFileName
75665>>>>>    End_Function                     
75666>>>>>    
75666>>>>>    Procedure WriteHeaderData
75668>>>>>        String sFileName
75668>>>>>        Integer iCh iSize
75668>>>>>        Boolean bQuickWrite
75668>>>>>        DateTime dtUpdateStart
75668>>>>>
75668>>>>>        Move (CurrentDateTime()) to dtUpdateStart
75669>>>>>        If (pbUseDataTableLog(Self) = True) Begin
75671>>>>>            Send OnWriteHeader_DataTable dtUpdateStart
75672>>>>>            Procedure_Return
75673>>>>>        End
75673>>>>>>
75673>>>>>
75673>>>>>        Get piChannel to iCh
75674>>>>>        If (iCh < 0) Begin
75676>>>>>            Get Seq_New_Channel to iCh
75677>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75679>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
75680>>>>>>
75680>>>>>                Procedure_Return
75681>>>>>            End
75681>>>>>>
75681>>>>>            Set piChannel to iCh
75682>>>>>        End
75682>>>>>>
75682>>>>>
75682>>>>>        Get psLogTextFileWithPath to sFileName
75683>>>>>        Get vWin32_APIFileSize sFileName to iSize
75684>>>>>        Get pbQuickWrite to bQuickWrite
75685>>>>>        
75685>>>>>        If (bQuickWrite = True) Begin
75687>>>>>            Append_Output channel iCh sFileName
75689>>>>>                If (bQuickWrite = True) Begin
75691>>>>>                    If (iSize = 0) Begin
75693>>>>>                        Write channel iCh C_BOM_UTF8
75695>>>>>                        Writeln channel iCh CS_DatabaseUpdateFramework
75698>>>>>                        Set pbEmptyLogFile to False
75699>>>>>                    End
75699>>>>>>
75699>>>>>                    Writeln channel iCh
75701>>>>>                    Writeln channel iCh ("*** Database Update Started:      " + String(dtUpdateStart))
75704>>>>>                End
75704>>>>>>
75704>>>>>            Close_Output channel iCh
75706>>>>>        End
75706>>>>>>
75706>>>>>    End_Procedure
75707>>>>>
75707>>>>>    // Returns the first datapath found in the psDataPath property.
75707>>>>>    // The returned path always ends with a "\"
75707>>>>>    Function psDataPathFirstPart Returns String
75709>>>>>        String sDataPath
75709>>>>>        Integer iCount
75709>>>>>
75709>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
75710>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
75711>>>>>        If (iCount > 1) Begin
75713>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
75714>>>>>        End
75714>>>>>>
75714>>>>>        If (sDataPath <> "") Begin
75716>>>>>            Get vFolderFormat sDataPath to sDataPath
75717>>>>>        End
75717>>>>>>
75717>>>>>
75717>>>>>        Function_Return sDataPath
75718>>>>>    End_Function
75719>>>>>
75719>>>>>    // Called from the cDbUpdateHandler object after all updates have been done.
75719>>>>>    Procedure WriteErrorLog
75721>>>>>        tDbUpdateError[] aDbUpdateErrorArray
75721>>>>>        tDbUpdateError[] aDbUpdateErrorArray
75722>>>>>        String sFileName sErrorNo sVersion sErrorText sText sRootName sOrgErrorText
75722>>>>>        Integer iCount iSize iCh iError iErrorLine iField
75722>>>>>        Boolean bUseDataTable bQuickWrite
75722>>>>>        DateTime dtUpdateStart dtUpdateEnd
75722>>>>>        TimeSpan tsElapsed
75722>>>>>        Number nVersion                                  
75722>>>>>        Handle hTable
75722>>>>>
75722>>>>>        If (pbHeaderWritten(Self) = False) Begin
75724>>>>>            Send WriteHeaderData
75725>>>>>            Set pbHeaderWritten to True
75726>>>>>        End
75726>>>>>>
75726>>>>>
75726>>>>>        Get pbUseDataTableLog to bUseDataTable
75727>>>>>        If (bUseDataTable = True) Begin
75729>>>>>            Send OnWriteRow_DataTable
75730>>>>>            Procedure_Return
75731>>>>>        End
75731>>>>>>
75731>>>>>
75731>>>>>        Get piChannel to iCh
75732>>>>>        If (iCh < 0) Begin
75734>>>>>            Get Seq_New_Channel to iCh
75735>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75737>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
75738>>>>>>
75738>>>>>                Procedure_Return
75739>>>>>            End
75739>>>>>>
75739>>>>>            Set piChannel to iCh
75740>>>>>        End
75740>>>>>>
75740>>>>>
75740>>>>>        Get psLogTextFileWithPath to sFileName
75741>>>>>
75741>>>>>        Get paDbUpdateErrorArray to aDbUpdateErrorArray
75742>>>>>        Move (SizeOfArray(aDbUpdateErrorArray)) to iSize
75743>>>>>        Decrement iSize
75744>>>>>
75744>>>>>        Get pdtUpdateStart to dtUpdateStart
75745>>>>>        If (IsNullDateTime(dtUpdateStart) = False) Begin
75747>>>>>            Move (CurrentDateTime()) to dtUpdateEnd
75748>>>>>            Move (dtUpdateEnd - dtUpdateStart) to tsElapsed
75749>>>>>        End
75749>>>>>>
75749>>>>>        Get pbQuickWrite to bQuickWrite
75750>>>>>
75750>>>>>        Append_Output channel iCh sFileName
75752>>>>>        If (bQuickWrite = True and iSize < 0) Begin
75754>>>>>            Writeln channel iCh ("*** Database Update Finished:  " + String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
75757>>>>>        End
75757>>>>>>
75757>>>>>        Else If (bQuickWrite = False) Begin
75760>>>>>            Writeln channel iCh
75762>>>>>            Writeln channel iCh ("*** Database Update Started:" * String(dtUpdateStart) * "and finished at:" * String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
75765>>>>>        End   
75765>>>>>>
75765>>>>>        If (iSize >= 0) Begin
75767>>>>>            If (aDbUpdateErrorArray[0].bShortFormat = False) Begin
75769>>>>>//                Writeln channel iCh "[Err No:] [pnVersionNumber:] [Status Text:]"
75769>>>>>                Writeln channel iCh "[Err No:] [Version:] [Status Text:]"
75772>>>>>            End
75772>>>>>>
75772>>>>>        End
75772>>>>>>
75772>>>>>
75772>>>>>        For iCount from 0 to iSize  
75778>>>>>>
75778>>>>>            Move aDbUpdateErrorArray[iCount].iError         to iError
75779>>>>>            Move aDbUpdateErrorArray[iCount].nUpdateVersion to nVersion
75780>>>>>            Move aDbUpdateErrorArray[iCount].sErrorText     to sErrorText
75781>>>>>            Move aDbUpdateErrorArray[iCount].iErrorLine     to iErrorLine  
75782>>>>>            Move aDbUpdateErrorArray[iCount].hTable         to hTable
75783>>>>>            Move aDbUpdateErrorArray[iCount].sTableRootName to sRootName
75784>>>>>            Move aDbUpdateErrorArray[iCount].iField         to iField
75785>>>>>            
75785>>>>>            Get PadLeft (String(iError)) 8 to sErrorNo
75786>>>>>            If (iError = 0) Begin
75788>>>>>                Move " Info  " to sErrorNo
75789>>>>>            End
75789>>>>>>
75789>>>>>            If (aDbUpdateErrorArray[iCount].bError = True) Begin
75791>>>>>                Get PadLeft (String(nVersion)) (19 - Length(sErrorNo)) to sVersion
75792>>>>>//                Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
75792>>>>>                Move (sErrorNo + sVersion + "   " + sErrorText * "[ErrLine:" * String(iErrorLine) + "]" + "    (Table:" * sRootName * String(hTable) + "." + String(iField) + ")") to sText
75793>>>>>            End
75793>>>>>>
75793>>>>>            Else Begin
75794>>>>>                Get PadLeft (String(nVersion)) (19 - Length(sErrorNo)) to sVersion
75795>>>>>//                Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
75795>>>>>                Move (sErrorNo + sVersion + "   " + sErrorText) to sText
75796>>>>>            End
75796>>>>>>
75796>>>>>            Writeln channel iCh sText
75799>>>>>            If (aDbUpdateErrorArray[iCount].sOrgErrorText <> "") Begin
75801>>>>>                Move ("   (" + aDbUpdateErrorArray[iCount].sOrgErrorText + ")") to sOrgErrorText
75802>>>>>                Move (Utf8ToAnsi(sOrgErrorText)) to sOrgErrorText       
75803>>>>>                Writeln channel iCh sOrgErrorText
75806>>>>>            End
75806>>>>>>
75806>>>>>            If (sText contains CS_SuccessfulUpdate) Begin
75808>>>>>                Writeln channel iCh
75810>>>>>            End
75810>>>>>>
75810>>>>>        Loop
75811>>>>>>
75811>>>>>        Close_Output channel iCh
75813>>>>>
75813>>>>>        Send Seq_Release_Channel iCh
75814>>>>>        Set piChannel to -1
75815>>>>>
75815>>>>>    End_Procedure
75816>>>>>
75816>>>>>    // The character to pad is optional. If nothing, spaces are used.
75816>>>>>    // Example:
75816>>>>>    // Move (PadLeft(45672,10,"0")) to sString -> "0000045672"
75816>>>>>    //  or:
75816>>>>>    // Move (PadLeft("Test",10)) to sString -> " Test"
75816>>>>>    // Courtesy of Pieter van Dieren. Collected from DAWs' Newsgroups.
75816>>>>>    Function PadLeft String sString Integer iLength String sOptChar Returns String
75818>>>>>        String sChar
75818>>>>>
75818>>>>>        If (Num_Arguments >= 3) Begin
75820>>>>>            Move sOptChar to sChar
75821>>>>>        End
75821>>>>>>
75821>>>>>        Else Begin
75822>>>>>            Move " " to sChar
75823>>>>>        End
75823>>>>>>
75823>>>>>
75823>>>>>        While (Length(sString) < iLength)
75827>>>>>            Move (sChar + sString) to sString
75828>>>>>        Loop
75829>>>>>>
75829>>>>>
75829>>>>>        Function_Return sString
75830>>>>>    End_Function
75831>>>>>
75831>>>>>    Procedure ShowErrorLog
75833>>>>>        String sPath sFileName sEditorProgram
75833>>>>>        Boolean bExists
75833>>>>>
75833>>>>>        Get psLogTextFileWithPath to sFileName
75834>>>>>        Get vFilePathExists sFileName to bExists
75835>>>>>        If (bExists = True) Begin
75837>>>>>            Get psEditorProgram to sEditorProgram
75838>>>>>            If (sEditorProgram <> "") Begin
75840>>>>>                Runprogram Background (psEditorProgram(Self)) (sPath + sFileName)
75841>>>>>            End
75841>>>>>>
75841>>>>>            Else Begin
75842>>>>>                Runprogram Shell Background sFileName
75843>>>>>            End
75843>>>>>>
75843>>>>>        End
75843>>>>>>
75843>>>>>        Else Begin
75844>>>>>            Send Info_Box (CS_DUF_LogFileNotFound + String(sFileName))
75845>>>>>        End
75845>>>>>>
75845>>>>>    End_Procedure
75846>>>>>
75846>>>>>End_Class
75847>>>Use cDbUpdateVersion.pkg
Including file: cDbUpdateVersion.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateVersion.pkg)
75847>>>>>//****************************************************************************
75847>>>>>// $Module type: Class
75847>>>>>// $Module name: cDbUpdateVersion
75847>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75847>>>>>// Web-site    : http://www.rdctools.com
75847>>>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
75847>>>>>//
75847>>>>>// Description : Child class to cDbUpdateHandler.
75847>>>>>//               Put an object of this class inside the global ghoDbUpdateHandler object.
75847>>>>>//               Set the pnVersionNumber to a version number.
75847>>>>>//               Inside the cDbUpdateVersion object put a "Use MyNewDbUpdatePackage.pkg"
75847>>>>>//               Add one cVersion object for each update of the database to the ghoDbUpdateHandler object.
75847>>>>>//               Place your code in the "OnUpdate" event that alters the database.
75847>>>>>//
75847>>>>>// $Rev History:
75847>>>>>//    2016-09-27  Module header created
75847>>>>>//****************************************************************************
75847>>>>>Use UI
75847>>>>>Use DUFLanguageConstants.inc
75847>>>>>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
75847>>>>>>>//****************************************************************************
75847>>>>>>>// $Module type: Class
75847>>>>>>>// $Module name: cDbUpdateFunctionLibrary
75847>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75847>>>>>>>// Web-site    : http://www.rdctools.com
75847>>>>>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
75847>>>>>>>//
75847>>>>>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
75847>>>>>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
75847>>>>>>>//               functions to make db changes to Sql databases with DAW drivers,
75847>>>>>>>//               with the help of Sql-scripts.
75847>>>>>>>//
75847>>>>>>>// $Rev History:
75847>>>>>>>//    2014-09-05  Module header created
75847>>>>>>>//
75847>>>>>>>//****************************************************************************
75847>>>>>>>//
75847>>>>>>>// Martin Moleman on SQL Server and DateTime2 (Don't use DataTime any longer !)
75847>>>>>>>// One remark about your change: I would not change to datetime2(7) (7 decimals) but to
75847>>>>>>>// datetime2(3) (3 decimals = milliseconds) or If you don't need the milliseconds datetime2(0).
75847>>>>>>>// The reason is that the DataFlex DateTime type only allows 3 decimals. When using 7
75847>>>>>>>// decimals you may Get truncation that again may cause problems with finding.
75847>>>>>>>//
75847>>>>>>>// Important! The conversion from DateTime to Date or datetime2 will also convert all dummy zero Date values from 1753-01-01 to 0001-01-01.
75847>>>>>>>// This is important to realize. The conversion will actually change the data in the database (done by the driver)
75847>>>>>>>
75847>>>>>>>
75847>>>>>>>// DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA
75847>>>>>>>// Determines for all DataFlex data types, which SQL native types will be used when creating new columns.
75847>>>>>>>// Set_Attribute DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA of {driverNumber} {databaseHandle} ;
75847>>>>>>>// to {MAP_DF_TO_SQL_TYPE_SQL2000|MAP_DF_TO_SQL_TYPE_SQL2005|MAP_DF_TO_SQL_TYPE_SQL2008|MAP_DF_TO_SQL_TYPE_SQL2012}
75847>>>>>>>//
75847>>>>>>>Use cBaseDbUpdateFuncLib.pkg
Including file: cBaseDbUpdateFuncLib.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cBaseDbUpdateFuncLib.pkg)
75847>>>>>>>>>//****************************************************************************
75847>>>>>>>>>// $Module type: Class
75847>>>>>>>>>// $Module name: cBaseDbUpdateFuncLib
75847>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75847>>>>>>>>>// Web-site    : http://www.rdctools.com
75847>>>>>>>>>// Created     : 2023-11-06 @ 09:50 (Military date format: YY-MM-DD)
75847>>>>>>>>>//
75847>>>>>>>>>// Description : The class consists of the basis/parent for the cDbUpdateFunctionLibrary class
75847>>>>>>>>>//               It contains helper functions for the cDbUpdateFunctionLibrary class
75847>>>>>>>>>//
75847>>>>>>>>>// $Rev History:
75847>>>>>>>>>//    2023-11-06  Module header created
75847>>>>>>>>>//
75847>>>>>>>>>//****************************************************************************
75847>>>>>>>>>Use cApplication.pkg
75847>>>>>>>>>Use seq_chnl.pkg
75847>>>>>>>>>Use GlobalFunctionsProcedures.pkg
75847>>>>>>>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
75847>>>>>>>>>Use Dfcursor.pkg
75847>>>>>>>>>Use DUFStatusPanel.pkg
75847>>>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
75847>>>>>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
75847>>>>>>>>>>>//
75847>>>>>>>>>>>// We need to create a mixin class for the library.
75847>>>>>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
75847>>>>>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
75847>>>>>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
75847>>>>>>>>>>>// Note: This class should _not_ have a construct_object defined.
75847>>>>>>>>>>>//
75847>>>>>>>>>>>Use VdfBase.pkg
75847>>>>>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files\DataFlex 24.0\Pkg\WinUuid.pkg)
75847>>>>>>>>>>>>>Use Unicode.Pkg
75847>>>>>>>>>>>>>
75847>>>>>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll ;    Pointer Uuid ;    Returns Integer
75848>>>>>>>>>>>>>
75848>>>>>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringW" Rpcrt4.dll ;    Pointer pUuid ;    Pointer lpUUIDString ;    Returns Integer
75849>>>>>>>>>>>>>
75849>>>>>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll ;    Pointer pUuid ;    Returns Integer
75850>>>>>>>>>>>>>
75850>>>>>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeW" Rpcrt4.dll ;    Pointer pStr ;    Returns Integer
75851>>>>>>>>>>>>>
75851>>>>>>>>>>>>>
75851>>>>>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
75851>>>>>>>>>>>>>Function RandomHexUUID Global Returns String
75853>>>>>>>>>>>>>    Pointer pUUID pUUIDStr
75853>>>>>>>>>>>>>    Integer iRetval iOffset iChar
75853>>>>>>>>>>>>>    String sUUID
75853>>>>>>>>>>>>>    
75853>>>>>>>>>>>>>    Move (Alloc(16)) to pUUID
75854>>>>>>>>>>>>>    
75854>>>>>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
75855>>>>>>>>>>>>>    
75855>>>>>>>>>>>>>    If (iRetval = 0) Begin
75857>>>>>>>>>>>>>        Move 0 to pUUIDStr
75858>>>>>>>>>>>>>        
75858>>>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75859>>>>>>>>>>>>>        If (iRetval = 0) Begin
75861>>>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75862>>>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75863>>>>>>>>>>>>>            
75863>>>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75864>>>>>>>>>>>>>        End
75864>>>>>>>>>>>>>>
75864>>>>>>>>>>>>>    End
75864>>>>>>>>>>>>>>
75864>>>>>>>>>>>>>    
75864>>>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
75865>>>>>>>>>>>>>    
75865>>>>>>>>>>>>>    Function_Return sUUID
75866>>>>>>>>>>>>>End_Function
75867>>>>>>>>>>>>>
75867>>>>>>>>>>>>>
75867>>>>>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
75867>>>>>>>>>>>>>Function SeqHexUUID Global Returns String
75869>>>>>>>>>>>>>    Pointer pUUID pUUIDStr
75869>>>>>>>>>>>>>    Integer iRetval iOffset iChar
75869>>>>>>>>>>>>>    String sUUID
75869>>>>>>>>>>>>>    
75869>>>>>>>>>>>>>    Move (Alloc(16)) to pUUID
75870>>>>>>>>>>>>>    
75870>>>>>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
75871>>>>>>>>>>>>>    
75871>>>>>>>>>>>>>    If (iRetval = 0) Begin
75873>>>>>>>>>>>>>        Move 0 to pUUIDStr
75874>>>>>>>>>>>>>        
75874>>>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75875>>>>>>>>>>>>>        If (iRetval = 0) Begin
75877>>>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75878>>>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75879>>>>>>>>>>>>>            
75879>>>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75880>>>>>>>>>>>>>        End
75880>>>>>>>>>>>>>>
75880>>>>>>>>>>>>>    End
75880>>>>>>>>>>>>>>
75880>>>>>>>>>>>>>    
75880>>>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
75881>>>>>>>>>>>>>    
75881>>>>>>>>>>>>>    Function_Return sUUID
75882>>>>>>>>>>>>>End_Function
75883>>>>>>>>>>>Use cli.pkg
75883>>>>>>>>>>>Use sql.pkg
75883>>>>>>>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSqldrv.pkg)
75883>>>>>>>>>>>>>//     Package that declares MS SQL driver constants and functions.
75883>>>>>>>>>>>>>//     This package can be used by developers who want to add Data Access
75883>>>>>>>>>>>>>//     MS SQL Client specific code to a DataFlex application.
75883>>>>>>>>>>>>>
75883>>>>>>>>>>>>>Use Cli.pkg
75883>>>>>>>>>>>>>Use SQL.pkg
75883>>>>>>>>>>>>>
75883>>>>>>>>>>>>>//   Driver Indentification
75883>>>>>>>>>>>>>
75883>>>>>>>>>>>>>//   Error number constants
75883>>>>>>>>>>>>>
75883>>>>>>>>>>>>>
75883>>>>>>>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
75883>>>>>>>>>>>>>
75883>>>>>>>>>>>>>
75883>>>>>>>>>>>>>
75883>>>>>>>>>>>>>
75883>>>>>>>>>>>>>
75883>>>>>>>>>>>>>
75883>>>>>>>>>>>>>// SQL Server spcific types.
75883>>>>>>>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
75883>>>>>>>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
75883>>>>>>>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
75883>>>>>>>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
75883>>>>>>>>>>>>>
75883>>>>>>>>>>>>>// SQL Server spcific types.
75883>>>>>>>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
75883>>>>>>>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
75883>>>>>>>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
75883>>>>>>>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
75883>>>>>>>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
75883>>>>>>>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
75883>>>>>>>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
75883>>>>>>>>>>>>>
75883>>>>>>>>>>>>>
75883>>>>>>>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
75883>>>>>>>>>>>>>//
75883>>>>>>>>>>>>>//     Setup a constraint for a file.
75883>>>>>>>>>>>>>
75883>>>>>>>>>>>>>
75883>>>>>>>>>>>>>Class cMSSQLHandler is a cCLIHandler
75884>>>>>>>>>>>>>    
75884>>>>>>>>>>>>>    Procedure Construct_Object
75886>>>>>>>>>>>>>        Forward Send Construct_Object
75888>>>>>>>>>>>>>        
75888>>>>>>>>>>>>>        Set psDriverID to MSSQLDRV_ID
75889>>>>>>>>>>>>>    End_Procedure
75890>>>>>>>>>>>>>    
75890>>>>>>>>>>>>>    
75890>>>>>>>>>>>>>    
75890>>>>>>>>>>>>>    //   Extract the list from the out connect string.
75890>>>>>>>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
75892>>>>>>>>>>>>>        String  sItem
75892>>>>>>>>>>>>>        Integer iStart
75892>>>>>>>>>>>>>        Integer iEnd
75892>>>>>>>>>>>>>        
75892>>>>>>>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
75895>>>>>>>>>>>>>        
75895>>>>>>>>>>>>>        Send Delete_Data to hoStore
75896>>>>>>>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
75897>>>>>>>>>>>>>        While (iStart > 0)
75901>>>>>>>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
75902>>>>>>>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
75905>>>>>>>>>>>>>            Else Begin
75906>>>>>>>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
75907>>>>>>>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
75908>>>>>>>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
75911>>>>>>>>>>>>>                
75911>>>>>>>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
75914>>>>>>>>>>>>>                
75914>>>>>>>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
75917>>>>>>>>>>>>>            End
75917>>>>>>>>>>>>>>
75917>>>>>>>>>>>>>        Loop
75918>>>>>>>>>>>>>>
75918>>>>>>>>>>>>>        
75918>>>>>>>>>>>>>        Function_Return (Item_Count(hoStore))
75919>>>>>>>>>>>>>    End_Procedure
75920>>>>>>>>>>>>>    
75920>>>>>>>>>>>>>    
75920>>>>>>>>>>>>>    
75920>>>>>>>>>>>>>    //   Call the driver's browse connect function
75920>>>>>>>>>>>>>    Function BrowseConnect String sInConnStr Returns String
75922>>>>>>>>>>>>>        String  sDriver
75922>>>>>>>>>>>>>        String  sOutConnStr
75922>>>>>>>>>>>>>        Integer iArg
75922>>>>>>>>>>>>>        Integer iRetval
75922>>>>>>>>>>>>>        
75922>>>>>>>>>>>>>        Get psDriverID to sDriver
75923>>>>>>>>>>>>>        If (sDriver <> "") Begin
75925>>>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75926>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75931>>>>>>>>>>>>>        End
75931>>>>>>>>>>>>>>
75931>>>>>>>>>>>>>        
75931>>>>>>>>>>>>>        Function_Return sOutConnStr
75932>>>>>>>>>>>>>    End_Function// BrowseConnect
75933>>>>>>>>>>>>>    
75933>>>>>>>>>>>>>    
75933>>>>>>>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
75935>>>>>>>>>>>>>        String  sDriver
75935>>>>>>>>>>>>>        String  sOutConnStr
75935>>>>>>>>>>>>>        Integer iArg
75935>>>>>>>>>>>>>        Integer iRetval
75935>>>>>>>>>>>>>        
75935>>>>>>>>>>>>>        Move 1 to iArg // Browses only local
75936>>>>>>>>>>>>>        
75936>>>>>>>>>>>>>        Get psDriverID to sDriver
75937>>>>>>>>>>>>>        If (sDriver <> "") Begin
75939>>>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75940>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75945>>>>>>>>>>>>>        End
75945>>>>>>>>>>>>>>
75945>>>>>>>>>>>>>        
75945>>>>>>>>>>>>>        Function_Return sOutConnStr
75946>>>>>>>>>>>>>    End_Function// BrowseConnect
75947>>>>>>>>>>>>>    
75947>>>>>>>>>>>>>    
75947>>>>>>>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
75949>>>>>>>>>>>>>        String  sServerList
75949>>>>>>>>>>>>>        Integer iNumServers
75949>>>>>>>>>>>>>        Integer iDriver
75949>>>>>>>>>>>>>        Integer iClientVersion
75949>>>>>>>>>>>>>        String  sDriver
75949>>>>>>>>>>>>>        
75949>>>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
75950>>>>>>>>>>>>>        
75950>>>>>>>>>>>>>        If (iDriver) Begin
75952>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
75955>>>>>>>>>>>>>            
75955>>>>>>>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
75956>>>>>>>>>>>>>            
75956>>>>>>>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
75957>>>>>>>>>>>>>            If (iNetworkLocal = 0) Begin
75959>>>>>>>>>>>>>                Get BrowseConnect sDriver to sServerList
75960>>>>>>>>>>>>>            End
75960>>>>>>>>>>>>>>
75960>>>>>>>>>>>>>            Else Begin
75961>>>>>>>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
75962>>>>>>>>>>>>>            End
75962>>>>>>>>>>>>>>
75962>>>>>>>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
75963>>>>>>>>>>>>>        End
75963>>>>>>>>>>>>>>
75963>>>>>>>>>>>>>        
75963>>>>>>>>>>>>>        Function_Return iNumServers
75964>>>>>>>>>>>>>    End_Function
75965>>>>>>>>>>>>>    
75965>>>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
75965>>>>>>>>>>>>>    //   This function will return all SQL Server instances on the network.
75965>>>>>>>>>>>>>    //   This may take a long time.
75965>>>>>>>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
75965>>>>>>>>>>>>>    Function EnumerateServers Returns Integer
75967>>>>>>>>>>>>>        Integer iNumServers
75967>>>>>>>>>>>>>        Integer iNetworkLocal
75967>>>>>>>>>>>>>        
75967>>>>>>>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
75968>>>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75969>>>>>>>>>>>>>
75969>>>>>>>>>>>>>        Function_Return iNumServers
75970>>>>>>>>>>>>>    End_Function
75971>>>>>>>>>>>>>    
75971>>>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
75971>>>>>>>>>>>>>    //   This function will return only return SQL Server instance on the local machine
75971>>>>>>>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
75971>>>>>>>>>>>>>    Function EnumerateServersLocal Returns Integer
75973>>>>>>>>>>>>>        Integer iNumServers
75973>>>>>>>>>>>>>        Integer iNetworkLocal
75973>>>>>>>>>>>>>        
75973>>>>>>>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
75974>>>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75975>>>>>>>>>>>>>        
75975>>>>>>>>>>>>>        Function_Return iNumServers
75976>>>>>>>>>>>>>    End_Function
75977>>>>>>>>>>>>>    
75977>>>>>>>>>>>>>    //   Enumerate database in a given server.
75977>>>>>>>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
75979>>>>>>>>>>>>>        Integer hoSQL
75979>>>>>>>>>>>>>        String  sConnect
75979>>>>>>>>>>>>>        String  sDatabase
75979>>>>>>>>>>>>>        Integer hdbc
75979>>>>>>>>>>>>>        Integer hstmt
75979>>>>>>>>>>>>>        Integer iFetchResult iDriver iClientVersion
75979>>>>>>>>>>>>>        
75979>>>>>>>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
75982>>>>>>>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
75985>>>>>>>>>>>>>        
75985>>>>>>>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
75988>>>>>>>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
75990>>>>>>>>>>>>>
75990>>>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
75991>>>>>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
75994>>>>>>>>>>>>>        If (iClientVersion >= 18) Begin
75996>>>>>>>>>>>>>            Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
75997>>>>>>>>>>>>>            Move (Replaces(" ", sConnect, "")) to sConnect
75998>>>>>>>>>>>>>        End
75998>>>>>>>>>>>>>>
75998>>>>>>>>>>>>>        
75998>>>>>>>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
76000>>>>>>>>>>>>>            Move Current_Object to hoSQL
76001>>>>>>>>>>>>>        End_Object
76002>>>>>>>>>>>>>        
76002>>>>>>>>>>>>>        If (hoSQL <> 0) Begin
76004>>>>>>>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
76005>>>>>>>>>>>>>            If (hdbc <> 0) Begin
76007>>>>>>>>>>>>>                Get SQLOpen of hdbc to hstmt
76008>>>>>>>>>>>>>                If (hstmt <> 0) Begin
76010>>>>>>>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
76010>>>>>>>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
76010>>>>>>>>>>>>>                    //   approach in case meta data might change, the stored procedure will
76010>>>>>>>>>>>>>                    //   stay the same.
76010>>>>>>>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
76011>>>>>>>>>>>>>                    Send SQLCall to hstmt
76012>>>>>>>>>>>>>                    Repeat
76012>>>>>>>>>>>>>>
76012>>>>>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
76013>>>>>>>>>>>>>                        If (iFetchResult <> 0) Begin
76015>>>>>>>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
76016>>>>>>>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
76017>>>>>>>>>>>>>                        End
76017>>>>>>>>>>>>>>
76017>>>>>>>>>>>>>                    Until (iFetchResult = 0)
76019>>>>>>>>>>>>>                    
76019>>>>>>>>>>>>>                    Send SQLClose to hstmt
76020>>>>>>>>>>>>>                End
76020>>>>>>>>>>>>>>
76020>>>>>>>>>>>>>                Send SQLDisconnect to hdbc
76021>>>>>>>>>>>>>            End
76021>>>>>>>>>>>>>>
76021>>>>>>>>>>>>>        End
76021>>>>>>>>>>>>>>
76021>>>>>>>>>>>>>        Send Destroy_Object to hoSQL
76022>>>>>>>>>>>>>        
76022>>>>>>>>>>>>>        Function_Return (Item_Count(Current_Object))
76023>>>>>>>>>>>>>    End_Function
76024>>>>>>>>>>>>>    
76024>>>>>>>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
76026>>>>>>>>>>>>>        String  sSqlServerClientVersionName
76026>>>>>>>>>>>>>        
76026>>>>>>>>>>>>>        Case Begin
76026>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
76028>>>>>>>>>>>>>                Move SQLSERVER2019CLIENTNAME to sSqlServerClientVersionName
76029>>>>>>>>>>>>>                Case Break
76030>>>>>>>>>>>>>            
76030>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
76033>>>>>>>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
76034>>>>>>>>>>>>>                Case Break
76035>>>>>>>>>>>>>                
76035>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
76038>>>>>>>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
76039>>>>>>>>>>>>>                Case Break
76040>>>>>>>>>>>>>            
76040>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
76043>>>>>>>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
76044>>>>>>>>>>>>>                Case Break
76045>>>>>>>>>>>>>            
76045>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
76048>>>>>>>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
76049>>>>>>>>>>>>>                Case Break
76050>>>>>>>>>>>>>            
76050>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
76053>>>>>>>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
76054>>>>>>>>>>>>>                Case Break
76055>>>>>>>>>>>>>            
76055>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
76058>>>>>>>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
76059>>>>>>>>>>>>>                Case Break
76060>>>>>>>>>>>>>            
76060>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
76063>>>>>>>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
76064>>>>>>>>>>>>>                Case Break
76065>>>>>>>>>>>>>            
76065>>>>>>>>>>>>>            Case Else
76065>>>>>>>>>>>>>                Move (SFormat("%1 (version %2) ",SQLSERVERUNKNOWNCLIENTNAME,iClientVersion)) to sSqlServerClientVersionName
76066>>>>>>>>>>>>>        Case End
76066>>>>>>>>>>>>>        
76066>>>>>>>>>>>>>        Function_Return sSqlServerClientVersionName
76067>>>>>>>>>>>>>    End_Function
76068>>>>>>>>>>>>>
76068>>>>>>>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
76070>>>>>>>>>>>>>        String  sSqlServerClientDriverName
76070>>>>>>>>>>>>>        
76070>>>>>>>>>>>>>        Case Begin
76070>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
76072>>>>>>>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientDriverName
76073>>>>>>>>>>>>>                Case Break
76074>>>>>>>>>>>>>
76074>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
76077>>>>>>>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
76078>>>>>>>>>>>>>                Case Break
76079>>>>>>>>>>>>>                
76079>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
76082>>>>>>>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
76083>>>>>>>>>>>>>                Case Break
76084>>>>>>>>>>>>>            
76084>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
76087>>>>>>>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
76088>>>>>>>>>>>>>                Case Break
76089>>>>>>>>>>>>>            
76089>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
76092>>>>>>>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
76093>>>>>>>>>>>>>                Case Break
76094>>>>>>>>>>>>>            
76094>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
76097>>>>>>>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
76098>>>>>>>>>>>>>                Case Break
76099>>>>>>>>>>>>>            
76099>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
76102>>>>>>>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
76103>>>>>>>>>>>>>                Case Break
76104>>>>>>>>>>>>>            
76104>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
76107>>>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
76108>>>>>>>>>>>>>                Case Break
76109>>>>>>>>>>>>>            
76109>>>>>>>>>>>>>            Case Else
76109>>>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
76110>>>>>>>>>>>>>        Case End
76110>>>>>>>>>>>>>        
76110>>>>>>>>>>>>>        Function_Return sSqlServerClientDriverName
76111>>>>>>>>>>>>>    End_Function
76112>>>>>>>>>>>>>    
76112>>>>>>>>>>>>>End_Class
76113>>>>>>>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files\DataFlex 24.0\Pkg\db2_drv.pkg)
76113>>>>>>>>>>>>>// DB2_DRV.PKG                                                          
76113>>>>>>>>>>>>>//   Package that declares DB2 driver constants and functions.          
76113>>>>>>>>>>>>>//   This package can be used by developers who want to add DB2 driver  
76113>>>>>>>>>>>>>//   specific code to a DataFlex application.                           
76113>>>>>>>>>>>>>
76113>>>>>>>>>>>>>Use Cli.pkg
76113>>>>>>>>>>>>>
76113>>>>>>>>>>>>>// Driver attributes
76113>>>>>>>>>>>>>
76113>>>>>>>>>>>>>
76113>>>>>>>>>>>>>// Driver Indentification
76113>>>>>>>>>>>>>
76113>>>>>>>>>>>>>// Error number constants
76113>>>>>>>>>>>>>
76113>>>>>>>>>>>>>// Call driver function identifiers
76113>>>>>>>>>>>>>
76113>>>>>>>>>>>>>// DB2 specific data types
76113>>>>>>>>>>>>>Define SQL_CLOB           for   (-99)
76113>>>>>>>>>>>>>Define SQL_BLOB           for   (-98)
76113>>>>>>>>>>>>>Define SQL_XML            for   (-370)
76113>>>>>>>>>>>>>// DB2 Graphic types are Unicode types
76113>>>>>>>>>>>>>Define SQL_GRAPHIC        for   (-95)
76113>>>>>>>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
76113>>>>>>>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
76113>>>>>>>>>>>>>Define SQL_DBCLOB         for   (-350)
76113>>>>>>>>>>>>>
76113>>>>>>>>>>>>>
76113>>>>>>>>>>>>>// Extra DB2 commands
76113>>>>>>>>>>>>>
76113>>>>>>>>>>>>>
76113>>>>>>>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
76113>>>>>>>>>>>>>//   Setup a constraint for a file.                                     
76113>>>>>>>>>>>>>
76113>>>>>>>>>>>>>
76113>>>>>>>>>>>>>
76113>>>>>>>>>>>>>Class cDB2Handler is a cCLIHandler
76114>>>>>>>>>>>>>    
76114>>>>>>>>>>>>>    Procedure Construct_Object
76116>>>>>>>>>>>>>        Forward Send Construct_Object
76118>>>>>>>>>>>>>        
76118>>>>>>>>>>>>>        Set psDriverID to DB2_DRV_ID
76119>>>>>>>>>>>>>    End_Procedure
76120>>>>>>>>>>>>>    
76120>>>>>>>>>>>>>    
76120>>>>>>>>>>>>>    
76120>>>>>>>>>>>>>    // Reset the datasource list to the beginning
76120>>>>>>>>>>>>>    Procedure SeedDataSources
76122>>>>>>>>>>>>>        String  sDriver
76122>>>>>>>>>>>>>        String  sVoid
76122>>>>>>>>>>>>>        Integer iRetval
76122>>>>>>>>>>>>>        
76122>>>>>>>>>>>>>        Get psDriverID to sDriver
76123>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
76130>>>>>>>>>>>>>    End_Procedure
76131>>>>>>>>>>>>>    
76131>>>>>>>>>>>>>    
76131>>>>>>>>>>>>>    
76131>>>>>>>>>>>>>    // Call the driver's data sources function
76131>>>>>>>>>>>>>    Function DataSources Returns String
76133>>>>>>>>>>>>>        String  sDriver
76133>>>>>>>>>>>>>        String  sDataSource
76133>>>>>>>>>>>>>        String  sDescription
76133>>>>>>>>>>>>>        Integer iLength
76133>>>>>>>>>>>>>        Integer iRetval
76133>>>>>>>>>>>>>        
76133>>>>>>>>>>>>>        Get psDriverID to sDriver
76134>>>>>>>>>>>>>        If (sDriver <> "") Begin
76136>>>>>>>>>>>>>            Move 8192 to iLength
76137>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
76138>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
76139>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
76144>>>>>>>>>>>>>        End
76144>>>>>>>>>>>>>>
76144>>>>>>>>>>>>>        
76144>>>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," *  sDescription, "")))
76147>>>>>>>>>>>>>        Else ;            Function_Return ""
76149>>>>>>>>>>>>>    End_Function
76150>>>>>>>>>>>>>    
76150>>>>>>>>>>>>>End_Class
76151>>>>>>>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files\DataFlex 24.0\Pkg\odbc_drv.pkg)
76151>>>>>>>>>>>>>//   Package that declares ODBC driver constants and functions.         
76151>>>>>>>>>>>>>//   This package can be used by developers who want to add Data Access 
76151>>>>>>>>>>>>>//   ODBC Client specific code to a DataFlex application.               
76151>>>>>>>>>>>>>
76151>>>>>>>>>>>>>Use Cli.pkg
76151>>>>>>>>>>>>>
76151>>>>>>>>>>>>>// Driver Indentification
76151>>>>>>>>>>>>>
76151>>>>>>>>>>>>>// Error number constants
76151>>>>>>>>>>>>>
76151>>>>>>>>>>>>>// Call driver function identifiers
76151>>>>>>>>>>>>>
76151>>>>>>>>>>>>>Class cODBCHandler is a cCLIHandler
76152>>>>>>>>>>>>>    
76152>>>>>>>>>>>>>    Procedure Construct_Object
76154>>>>>>>>>>>>>        Forward Send Construct_Object
76156>>>>>>>>>>>>>        
76156>>>>>>>>>>>>>        Set psDriverID to ODBC_DRV_ID
76157>>>>>>>>>>>>>    End_Procedure
76158>>>>>>>>>>>>>    
76158>>>>>>>>>>>>>    
76158>>>>>>>>>>>>>    
76158>>>>>>>>>>>>>    // Setup the type of data sources returned by the datasources function
76158>>>>>>>>>>>>>    Procedure Set DataSourceType Integer iNewType
76160>>>>>>>>>>>>>        String  sDriver
76160>>>>>>>>>>>>>        String  sVoid
76160>>>>>>>>>>>>>        Integer iRetval
76160>>>>>>>>>>>>>        
76160>>>>>>>>>>>>>        Get psDriverID to sDriver
76161>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
76168>>>>>>>>>>>>>    End_Procedure
76169>>>>>>>>>>>>>    
76169>>>>>>>>>>>>>    
76169>>>>>>>>>>>>>    // Call the driver's data sources function
76169>>>>>>>>>>>>>    Function DataSources Returns String
76171>>>>>>>>>>>>>        String  sDriver
76171>>>>>>>>>>>>>        String  sDataSource
76171>>>>>>>>>>>>>        String  sDescription
76171>>>>>>>>>>>>>        Integer iLength
76171>>>>>>>>>>>>>        Integer iRetval
76171>>>>>>>>>>>>>        
76171>>>>>>>>>>>>>        Get psDriverID to sDriver
76172>>>>>>>>>>>>>        If (sDriver <> "") Begin
76174>>>>>>>>>>>>>            Move 8192 to iLength
76175>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
76176>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
76177>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
76182>>>>>>>>>>>>>        End
76182>>>>>>>>>>>>>>
76182>>>>>>>>>>>>>        
76182>>>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," * sDescription, "")))
76185>>>>>>>>>>>>>        Else ;            Function_Return ""
76187>>>>>>>>>>>>>    End_Function
76188>>>>>>>>>>>>>    
76188>>>>>>>>>>>>>End_Class
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files\DataFlex 24.0\Pkg\DFBTRDRV.PKG)
76189>>>>>>>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
76189>>>>>>>>>>>>>// Notice      : This package contains constants and commands, used to call
76189>>>>>>>>>>>>>//               specific functions in the DFBTRDRV.
76189>>>>>>>>>>>>>Use Ui
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>// Driver Indentification
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>// Driver attributes
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>// Call_Driver functions ID's
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>// DFBTRFN_CONVERT_FILE options
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>// DFBTRFN_SET_OWNER options
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>// Command to create all vars which may be needed
76189>>>>>>>>>>>>>// in other commands.
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>// Command to set the owner of a Btrieve file.
76189>>>>>>>>>>>>>// File must have been opened.
76189>>>>>>>>>>>>>// Filenumber needs to be passed.
76189>>>>>>>>>>>>>// To clear set the owner to "".
76189>>>>>>>>>>>>>// Examples:
76189>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
76189>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
76189>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
76189>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
76189>>>>>>>>>>>>>// To clear:
76189>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>// Command to parse DFBTR_SET_OWNVER
76189>>>>>>>>>>>>>// options.
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>// Command to parse for Callback
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>// Command to clear the owner of a Btrieve file.
76189>>>>>>>>>>>>>// File must have been opened.
76189>>>>>>>>>>>>>// Filenumber needs to be passed.
76189>>>>>>>>>>>>>// Examples:
76189>>>>>>>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>// Command to add a owner name to the internal list of ownernames
76189>>>>>>>>>>>>>// which will be tries when opening files.
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>// Command to remove all owners from the internal list of ownernames
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>// Command to set the owner name to be used when opening the DDF files.
76189>>>>>>>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
76189>>>>>>>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
76189>>>>>>>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>// Command to change the transaction type.
76189>>>>>>>>>>>>>// Valid types are:
76189>>>>>>>>>>>>>//     DFBTRTT_NONE
76189>>>>>>>>>>>>>//     DFBTRTT_EXCLUSIVE
76189>>>>>>>>>>>>>//     DFBTRTT_CONCURRENT
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>// Command to get the current transaction type.
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>// Command to set explicit_locking
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>// Command to get explicit locking
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
76189>>>>>>>>>>>>>//
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>// Purpose: An instance of this class can be used as a broker object to
76189>>>>>>>>>>>>>//          call several Dfbtrdrv releated methods.
76189>>>>>>>>>>>>>
76189>>>>>>>>>>>>>Class cDFBtrDrvHandler is an Array
76190>>>>>>>>>>>>>    
76190>>>>>>>>>>>>>    Procedure Construct_Object Integer iImage
76192>>>>>>>>>>>>>        Forward Send Construct_object iImage
76194>>>>>>>>>>>>>        
76194>>>>>>>>>>>>>        Property String  psDriverID "DFBTRDRV"
76195>>>>>>>>>>>>>    End_Procedure
76196>>>>>>>>>>>>>    
76196>>>>>>>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
76196>>>>>>>>>>>>>    //
76196>>>>>>>>>>>>>    
76196>>>>>>>>>>>>>    Function CKRevision Returns String
76198>>>>>>>>>>>>>        String  sDriverID
76198>>>>>>>>>>>>>        String  sRevision
76198>>>>>>>>>>>>>        String  sVoid
76198>>>>>>>>>>>>>        Integer iRetval
76198>>>>>>>>>>>>>        
76198>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76198>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76198>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76198>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76199>>>>>>>>>>>>>        Get psDriverID to sDriverID
76200>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sRevision
76201>>>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
76206>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76207>>>>>>>>>>>>>        If (Trim(sRevision) = "") Begin
76209>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76209>>>>>>>>>>>>>            Move "0.0.0.0" to sRevision
76210>>>>>>>>>>>>>        End
76210>>>>>>>>>>>>>>
76210>>>>>>>>>>>>>        Function_Return sRevision
76211>>>>>>>>>>>>>    End_Function
76212>>>>>>>>>>>>>    
76212>>>>>>>>>>>>>    Function CkUsesUri Returns Integer
76214>>>>>>>>>>>>>        String  sDriverID
76214>>>>>>>>>>>>>        String  sVoid1
76214>>>>>>>>>>>>>        String  sVoid2
76214>>>>>>>>>>>>>        Integer iRetval
76214>>>>>>>>>>>>>        
76214>>>>>>>>>>>>>        Get psDriverID to sDriverID
76215>>>>>>>>>>>>>        
76215>>>>>>>>>>>>>        Move 0 to iRetval
76216>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76216>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76216>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
76216>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76217>>>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
76222>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76223>>>>>>>>>>>>>        
76223>>>>>>>>>>>>>        Function_Return iRetval
76224>>>>>>>>>>>>>    End_Function
76225>>>>>>>>>>>>>    
76225>>>>>>>>>>>>>    
76225>>>>>>>>>>>>>    
76225>>>>>>>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
76225>>>>>>>>>>>>>    //
76225>>>>>>>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
76225>>>>>>>>>>>>>    //
76225>>>>>>>>>>>>>    
76225>>>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
76227>>>>>>>>>>>>>        Integer iPartRev
76227>>>>>>>>>>>>>        Integer iCurrentPart
76227>>>>>>>>>>>>>        Integer iSeparatorPos
76227>>>>>>>>>>>>>        
76227>>>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
76230>>>>>>>>>>>>>        
76230>>>>>>>>>>>>>        Move 0 to iCurrentPart
76231>>>>>>>>>>>>>        Repeat
76231>>>>>>>>>>>>>>
76231>>>>>>>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
76232>>>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
76234>>>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
76235>>>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
76236>>>>>>>>>>>>>                Increment iCurrentPart
76237>>>>>>>>>>>>>            End
76237>>>>>>>>>>>>>>
76237>>>>>>>>>>>>>            Else If (sRevision <> "") Begin
76240>>>>>>>>>>>>>                Move sRevision to iPartRev
76241>>>>>>>>>>>>>                Move "" to sRevision
76242>>>>>>>>>>>>>                Increment iCurrentPart
76243>>>>>>>>>>>>>            End
76243>>>>>>>>>>>>>>
76243>>>>>>>>>>>>>            Else ;                Move -1 to iPartRev
76245>>>>>>>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
76247>>>>>>>>>>>>>        
76247>>>>>>>>>>>>>        Function_Return iPartRev
76248>>>>>>>>>>>>>    End_Function
76249>>>>>>>>>>>>>    
76249>>>>>>>>>>>>>    
76249>>>>>>>>>>>>>    
76249>>>>>>>>>>>>>    //
76249>>>>>>>>>>>>>    //  Returns the major revision of the CK
76249>>>>>>>>>>>>>    //
76249>>>>>>>>>>>>>    
76249>>>>>>>>>>>>>    Function CKMajorRevision Returns Integer
76251>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
76252>>>>>>>>>>>>>    End_Function
76253>>>>>>>>>>>>>    
76253>>>>>>>>>>>>>    
76253>>>>>>>>>>>>>    
76253>>>>>>>>>>>>>    //  Returns the minor revision of the CK
76253>>>>>>>>>>>>>    //
76253>>>>>>>>>>>>>    
76253>>>>>>>>>>>>>    Function CKMinorRevision Returns Integer
76255>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
76256>>>>>>>>>>>>>    End_Function
76257>>>>>>>>>>>>>    
76257>>>>>>>>>>>>>    
76257>>>>>>>>>>>>>    //  Returns the release revision of the CK
76257>>>>>>>>>>>>>    //
76257>>>>>>>>>>>>>    
76257>>>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
76259>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
76260>>>>>>>>>>>>>    End_Function
76261>>>>>>>>>>>>>    
76261>>>>>>>>>>>>>    
76261>>>>>>>>>>>>>    //  Returns the major revision of the CK
76261>>>>>>>>>>>>>    //
76261>>>>>>>>>>>>>    
76261>>>>>>>>>>>>>    Function CKBuildRevision Returns Integer
76263>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
76264>>>>>>>>>>>>>    End_Function
76265>>>>>>>>>>>>>    
76265>>>>>>>>>>>>>    
76265>>>>>>>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
76265>>>>>>>>>>>>>    //
76265>>>>>>>>>>>>>    
76265>>>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
76267>>>>>>>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
76270>>>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
76273>>>>>>>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
76276>>>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
76279>>>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
76282>>>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
76286>>>>>>>>>>>>>            End
76286>>>>>>>>>>>>>>
76286>>>>>>>>>>>>>        End
76286>>>>>>>>>>>>>>
76286>>>>>>>>>>>>>        
76286>>>>>>>>>>>>>        Function_Return (False)
76287>>>>>>>>>>>>>    End_Function
76288>>>>>>>>>>>>>    
76288>>>>>>>>>>>>>    //   Functions to query the Pervasive.SQL version:
76288>>>>>>>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
76288>>>>>>>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
76288>>>>>>>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
76288>>>>>>>>>>>>>    //
76288>>>>>>>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
76288>>>>>>>>>>>>>    //   in the following format:
76288>>>>>>>>>>>>>    //       <version>.<revision>.<type>
76288>>>>>>>>>>>>>    //   possible values for <type>:
76288>>>>>>>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
76288>>>>>>>>>>>>>    //         server using Workgroup authentication mode
76288>>>>>>>>>>>>>    //       C for client cache engine
76288>>>>>>>>>>>>>    //       D for DOS workstation
76288>>>>>>>>>>>>>    //       N for client Requester
76288>>>>>>>>>>>>>    //       S for NetWare server
76288>>>>>>>>>>>>>    //       T for 32-bit Windows server engine
76288>>>>>>>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
76288>>>>>>>>>>>>>    //
76288>>>>>>>>>>>>>    //   example:
76288>>>>>>>>>>>>>    //       8.50.T
76288>>>>>>>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
76288>>>>>>>>>>>>>    //   32-bits Windows server.
76288>>>>>>>>>>>>>    //
76288>>>>>>>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
76288>>>>>>>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
76288>>>>>>>>>>>>>    //
76288>>>>>>>>>>>>>    //   If the version information is not available or can not be obtained
76288>>>>>>>>>>>>>    //   the functions will return "0.0.0"
76288>>>>>>>>>>>>>    
76288>>>>>>>>>>>>>    //  Returns the version information of the
76288>>>>>>>>>>>>>    //           Pervasive.SQL Client requester.
76288>>>>>>>>>>>>>    
76288>>>>>>>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
76290>>>>>>>>>>>>>        
76290>>>>>>>>>>>>>        String  sDriverID
76290>>>>>>>>>>>>>        String  sVersion
76290>>>>>>>>>>>>>        String  sVoid
76290>>>>>>>>>>>>>        Integer iRetval
76290>>>>>>>>>>>>>        
76290>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76290>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76290>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76290>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76291>>>>>>>>>>>>>        Get psDriverID to sDriverID
76292>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76293>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76298>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76299>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76301>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76301>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76302>>>>>>>>>>>>>        End
76302>>>>>>>>>>>>>>
76302>>>>>>>>>>>>>        Function_Return sVersion
76303>>>>>>>>>>>>>    End_Function
76304>>>>>>>>>>>>>    
76304>>>>>>>>>>>>>    //           Pervasive.SQL Engine
76304>>>>>>>>>>>>>    
76304>>>>>>>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
76306>>>>>>>>>>>>>        
76306>>>>>>>>>>>>>        String  sDriverID
76306>>>>>>>>>>>>>        String  sVersion
76306>>>>>>>>>>>>>        String  sVoid
76306>>>>>>>>>>>>>        Integer iRetval
76306>>>>>>>>>>>>>        
76306>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76306>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76306>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76306>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76307>>>>>>>>>>>>>        Get psDriverID to sDriverID
76308>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76309>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76314>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76315>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76317>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76317>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76318>>>>>>>>>>>>>        End
76318>>>>>>>>>>>>>>
76318>>>>>>>>>>>>>        Function_Return sVersion
76319>>>>>>>>>>>>>    End_Function
76320>>>>>>>>>>>>>    
76320>>>>>>>>>>>>>    //  Returns the version information of the
76320>>>>>>>>>>>>>    //           Pervasive.SQL Server Engine
76320>>>>>>>>>>>>>    
76320>>>>>>>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
76322>>>>>>>>>>>>>        
76322>>>>>>>>>>>>>        String  sDriverID
76322>>>>>>>>>>>>>        String  sVersion
76322>>>>>>>>>>>>>        String  sVoid
76322>>>>>>>>>>>>>        Integer iRetval
76322>>>>>>>>>>>>>        
76322>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76322>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76322>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76322>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76323>>>>>>>>>>>>>        Get psDriverID to sDriverID
76324>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76325>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76330>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76331>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76333>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76333>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76334>>>>>>>>>>>>>        End
76334>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>        Function_Return sVersion
76335>>>>>>>>>>>>>    End_Function
76336>>>>>>>>>>>>>    
76336>>>>>>>>>>>>>End_Class
76337>>>>>>>>>>>>>
76337>>>>>>>>>>>>>
76337>>>>>>>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
76337>>>>>>>>>>>>>//****************************************************************************
76337>>>>>>>>>>>>>// $Module type: Include file
76337>>>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.inc
76337>>>>>>>>>>>>>//
76337>>>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
76337>>>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
76337>>>>>>>>>>>>>// E-mail      : support@rdctools.com
76337>>>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76337>>>>>>>>>>>>>//
76337>>>>>>>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
76337>>>>>>>>>>>>>//
76337>>>>>>>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
76337>>>>>>>>>>>>>//
76337>>>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
76337>>>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
76337>>>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
76337>>>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
76337>>>>>>>>>>>>>// in the help folder for more details.
76337>>>>>>>>>>>>>//
76337>>>>>>>>>>>>>Use Winkern.pkg
76337>>>>>>>>>>>>>Use cIniFile.pkg
76337>>>>>>>>>>>>>    Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCryptographerEx.pkg)
76337>>>>>>>>>>>>>>>Use VdfBase.pkg
76337>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 24.0\Pkg\CryptographerConstants.pkg)
76337>>>>>>>>>>>>>>>>>//   Author  : Ulbe Stellema
76337>>>>>>>>>>>>>>>>>// Algorithm classes
76337>>>>>>>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
76337>>>>>>>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
76337>>>>>>>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
76337>>>>>>>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
76337>>>>>>>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
76337>>>>>>>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
76337>>>>>>>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>// Algorithm types
76337>>>>>>>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
76337>>>>>>>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
76337>>>>>>>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
76337>>>>>>>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
76337>>>>>>>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
76337>>>>>>>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
76337>>>>>>>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>// Generic sub-ids
76337>>>>>>>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>// RSA sub-ids
76337>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
76337>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
76337>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
76337>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
76337>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>// DSS sub-ids
76337>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
76337>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
76337>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>// DES sub_ids
76337>>>>>>>>>>>>>>>>>Define ALG_SID_DES                      for 1
76337>>>>>>>>>>>>>>>>>Define ALG_SID_3DES                     for 3
76337>>>>>>>>>>>>>>>>>Define ALG_SID_DESX                     for 4
76337>>>>>>>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
76337>>>>>>>>>>>>>>>>>Define ALG_SID_CAST                     for 6
76337>>>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
76337>>>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
76337>>>>>>>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
76337>>>>>>>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
76337>>>>>>>>>>>>>>>>>Define ALG_SID_RC5                      for 13
76337>>>>>>>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
76337>>>>>>>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
76337>>>>>>>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
76337>>>>>>>>>>>>>>>>>Define ALG_SID_AES                      for 17
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>// Fortezza sub-ids
76337>>>>>>>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
76337>>>>>>>>>>>>>>>>>Define ALG_SID_TEK                      for 11
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>// RC2 sub-ids
76337>>>>>>>>>>>>>>>>>Define ALG_SID_RC2                      for 2
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>// Stream cipher sub-ids
76337>>>>>>>>>>>>>>>>>Define ALG_SID_RC4                      for 1
76337>>>>>>>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>// Diffie-Hellman sub-ids
76337>>>>>>>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
76337>>>>>>>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
76337>>>>>>>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
76337>>>>>>>>>>>>>>>>>Define ALG_SID_KEA                      for 4
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>// Hash sub ids
76337>>>>>>>>>>>>>>>>>Define ALG_SID_MD2                      for 1
76337>>>>>>>>>>>>>>>>>Define ALG_SID_MD4                      for 2
76337>>>>>>>>>>>>>>>>>Define ALG_SID_MD5                      for 3
76337>>>>>>>>>>>>>>>>>Define ALG_SID_SHA                      for 4
76337>>>>>>>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
76337>>>>>>>>>>>>>>>>>Define ALG_SID_MAC                      for 5
76337>>>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
76337>>>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
76337>>>>>>>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
76337>>>>>>>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
76337>>>>>>>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
76337>>>>>>>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
76337>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
76337>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
76337>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>// secure channel sub ids
76337>>>>>>>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
76337>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
76337>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
76337>>>>>>>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
76337>>>>>>>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
76337>>>>>>>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
76337>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>// algorithm identifier definitions
76337>>>>>>>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
76337>>>>>>>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
76337>>>>>>>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
76337>>>>>>>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
76337>>>>>>>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
76337>>>>>>>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
76337>>>>>>>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
76337>>>>>>>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
76337>>>>>>>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
76337>>>>>>>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
76337>>>>>>>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
76337>>>>>>>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
76337>>>>>>>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
76337>>>>>>>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
76337>>>>>>>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
76337>>>>>>>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
76337>>>>>>>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
76337>>>>>>>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
76337>>>>>>>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
76337>>>>>>>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
76337>>>>>>>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
76337>>>>>>>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
76337>>>>>>>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
76337>>>>>>>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
76337>>>>>>>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
76337>>>>>>>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
76337>>>>>>>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
76337>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
76337>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
76337>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
76337>>>>>>>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
76337>>>>>>>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
76337>>>>>>>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
76337>>>>>>>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
76337>>>>>>>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
76337>>>>>>>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
76337>>>>>>>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
76337>>>>>>>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
76337>>>>>>>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
76337>>>>>>>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
76337>>>>>>>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
76337>>>>>>>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
76337>>>>>>>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
76337>>>>>>>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>// Providers
76337>>>>>>>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
76337>>>>>>>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
76337>>>>>>>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
76337>>>>>>>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
76337>>>>>>>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
76337>>>>>>>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
76337>>>>>>>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
76337>>>>>>>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
76337>>>>>>>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
76337>>>>>>>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
76337>>>>>>>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
76337>>>>>>>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
76337>>>>>>>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
76337>>>>>>>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
76337>>>>>>>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
76337>>>>>>>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>// dwFlag definitions for CryptGenKey
76337>>>>>>>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
76337>>>>>>>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
76337>>>>>>>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
76337>>>>>>>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
76337>>>>>>>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
76337>>>>>>>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
76337>>>>>>>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
76337>>>>>>>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
76337>>>>>>>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
76337>>>>>>>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
76337>>>>>>>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
76337>>>>>>>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
76337>>>>>>>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
76337>>>>>>>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
76337>>>>>>>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
76337>>>>>>>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>// Provider types
76337>>>>>>>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
76337>>>>>>>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
76337>>>>>>>>>>>>>>>>>Define PROV_DSS                         for 3
76337>>>>>>>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
76337>>>>>>>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
76337>>>>>>>>>>>>>>>>>Define PROV_SSL                         for 6
76337>>>>>>>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
76337>>>>>>>>>>>>>>>>>Define PROV_DSS_DH                      for 13
76337>>>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
76337>>>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
76337>>>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
76337>>>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
76337>>>>>>>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
76337>>>>>>>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
76337>>>>>>>>>>>>>>>>>Define PROV_RNG                         for 21
76337>>>>>>>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
76337>>>>>>>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
76337>>>>>>>>>>>>>>>>>Define PROV_RSA_AES                     for 24
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>// KP_MODE
76337>>>>>>>>>>>>>>>>>// KP_MODE
76337>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
76337>>>>>>>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
76337>>>>>>>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
76337>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
76337>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
76337>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
76337>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
76337>>>>>>>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
76337>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
76337>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
76337>>>>>>>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
76337>>>>>>>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
76337>>>>>>>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
76337>>>>>>>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
76337>>>>>>>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
76337>>>>>>>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
76337>>>>>>>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
76337>>>>>>>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
76337>>>>>>>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
76337>>>>>>>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
76337>>>>>>>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
76337>>>>>>>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
76337>>>>>>>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
76337>>>>>>>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
76337>>>>>>>>>>>>>>>>>Define KP_Y                             for 15      // Y value
76337>>>>>>>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
76337>>>>>>>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
76337>>>>>>>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
76337>>>>>>>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
76337>>>>>>>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
76337>>>>>>>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
76337>>>>>>>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
76337>>>>>>>>>>>>>>>>>Define KP_RP                            for 23
76337>>>>>>>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
76337>>>>>>>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
76337>>>>>>>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
76337>>>>>>>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
76337>>>>>>>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
76337>>>>>>>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
76337>>>>>>>>>>>>>>>>>Define KP_KEYVAL                        for 30
76337>>>>>>>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
76337>>>>>>>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
76337>>>>>>>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
76337>>>>>>>>>>>>>>>>>Define KP_PREHASH                       for 34
76337>>>>>>>>>>>>>>>>>Define KP_ROUNDS                        for 35
76337>>>>>>>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
76337>>>>>>>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
76337>>>>>>>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
76337>>>>>>>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
76337>>>>>>>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
76337>>>>>>>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
76337>>>>>>>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
76337>>>>>>>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
76337>>>>>>>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
76337>>>>>>>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
76337>>>>>>>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>// key BLOB types
76337>>>>>>>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
76337>>>>>>>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
76337>>>>>>>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
76337>>>>>>>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
76337>>>>>>>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
76337>>>>>>>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
76337>>>>>>>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
76337>>>>>>>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>// KP_PADDING
76337>>>>>>>>>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
76337>>>>>>>>>>>>>>>>>Define RANDOM_PADDING                   for 2
76337>>>>>>>>>>>>>>>>>Define ZERO_PADDING                     for 3
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>//  Structure cryptimportkey
76337>>>>>>>>>>>>>>>>>Struct PUBLICKEYSTRUC
76337>>>>>>>>>>>>>>>>>    UChar    bType
76337>>>>>>>>>>>>>>>>>    UChar    bVersion
76337>>>>>>>>>>>>>>>>>    UShort   reserved
76337>>>>>>>>>>>>>>>>>    UInteger aiKeyAlg
76337>>>>>>>>>>>>>>>>>End_Struct
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
76337>>>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
76337>>>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
76337>>>>>>>>>>>>>>>>>    UInteger       dwKeySize
76337>>>>>>>>>>>>>>>>>//    UChar[]        rgbKeyData
76337>>>>>>>>>>>>>>>>>End_Struct
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
76337>>>>>>>>>>>>>>>>>Struct HMAC_INFO
76337>>>>>>>>>>>>>>>>>    UInteger HashAlgid
76337>>>>>>>>>>>>>>>>>    Pointer pbInnerString
76337>>>>>>>>>>>>>>>>>    DWord cbInnerString
76337>>>>>>>>>>>>>>>>>    Pointer pbOuterString
76337>>>>>>>>>>>>>>>>>    DWord cbOuterString
76337>>>>>>>>>>>>>>>>>End_Struct
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>Struct BLOBHEADER
76337>>>>>>>>>>>>>>>>>    UChar   bType
76337>>>>>>>>>>>>>>>>>    UChar   bVersion
76337>>>>>>>>>>>>>>>>>    Short   reserved
76337>>>>>>>>>>>>>>>>>    Integer aiKeyAlg
76337>>>>>>>>>>>>>>>>>End_Struct
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>Struct CryptoBlob
76337>>>>>>>>>>>>>>>>>    BLOBHEADER  header
76337>>>>>>>>>>>>>>>>>    BLOBHEADER  header
76337>>>>>>>>>>>>>>>>>    Integer     cbKeySize
76337>>>>>>>>>>>>>>>>>    UChar[32]   rgbKeyData
76337>>>>>>>>>>>>>>>>>End_Struct
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>
76337>>>>>>>>>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
76337>>>>>>>>>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
76338>>>>>>>>>>>>>>>>>
76338>>>>>>>>>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
76338>>>>>>>>>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
76340>>>>>>>>>>>>>>>>>    
76340>>>>>>>>>>>>>>>>>    Boolean bResult
76340>>>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
76340>>>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
76340>>>>>>>>>>>>>>>>>
76340>>>>>>>>>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
76341>>>>>>>>>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
76342>>>>>>>>>>>>>>>>>    
76342>>>>>>>>>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
76343>>>>>>>>>>>>>>>>>
76343>>>>>>>>>>>>>>>>>    Function_Return bResult
76344>>>>>>>>>>>>>>>>>End_Function
76345>>>>>>>>>>>>>>>>>
76345>>>>>>>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
76346>>>>>>>>>>>>>>>>>
76346>>>>>>>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
76347>>>>>>>>>>>>>>>>>
76347>>>>>>>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
76348>>>>>>>>>>>>>>>>>
76348>>>>>>>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
76349>>>>>>>>>>>>>>>>>
76349>>>>>>>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76350>>>>>>>>>>>>>>>>>
76350>>>>>>>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
76351>>>>>>>>>>>>>>>>>
76351>>>>>>>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
76352>>>>>>>>>>>>>>>>>
76352>>>>>>>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
76354>>>>>>>>>>>>>>>>>    
76354>>>>>>>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
76355>>>>>>>>>>>>>>>>>
76355>>>>>>>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
76356>>>>>>>>>>>>>>>>>
76356>>>>>>>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
76358>>>>>>>>>>>>>>>>>    
76358>>>>>>>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
76359>>>>>>>>>>>>>>>>>    
76359>>>>>>>>>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76360>>>>>>>>>>>>>>>>>    
76360>>>>>>>>>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
76361>>>>>>>>>>>>>>>
76361>>>>>>>>>>>>>>>Class cCryptographerEx is a cObject
76362>>>>>>>>>>>>>>>    
76362>>>>>>>>>>>>>>>    Procedure Construct_Object
76364>>>>>>>>>>>>>>>        Forward Send Construct_Object
76366>>>>>>>>>>>>>>>        
76366>>>>>>>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
76367>>>>>>>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
76368>>>>>>>>>>>>>>>        Property Integer    piCipher    CALG_RC4
76369>>>>>>>>>>>>>>>        Property Integer    piHash      CALG_MD5
76370>>>>>>>>>>>>>>>        
76370>>>>>>>>>>>>>>>        // Private properties
76370>>>>>>>>>>>>>>>        Property Handle     Private_phProv
76371>>>>>>>>>>>>>>>        
76371>>>>>>>>>>>>>>>        // Block cipher properties
76371>>>>>>>>>>>>>>>        Property UChar[]    paKey
76372>>>>>>>>>>>>>>>        Property UChar[]    paIV
76373>>>>>>>>>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
76374>>>>>>>>>>>>>>>        Property Integer    piKeyType       CALG_AES_256
76375>>>>>>>>>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
76376>>>>>>>>>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
76377>>>>>>>>>>>>>>>        Property Integer    piBlockSize     16
76378>>>>>>>>>>>>>>>    End_Procedure
76379>>>>>>>>>>>>>>>    
76379>>>>>>>>>>>>>>>    
76379>>>>>>>>>>>>>>>    // Acquire key container handle
76379>>>>>>>>>>>>>>>    Function AcquireContext Returns Handle
76381>>>>>>>>>>>>>>>        Integer iProvider
76381>>>>>>>>>>>>>>>        WString wProvider
76381>>>>>>>>>>>>>>>        Handle hProv
76381>>>>>>>>>>>>>>>        Boolean bOk
76381>>>>>>>>>>>>>>>        Pointer pProv
76381>>>>>>>>>>>>>>>        
76381>>>>>>>>>>>>>>>        Move 0 to hProv
76382>>>>>>>>>>>>>>>        Get piProvider to iProvider
76383>>>>>>>>>>>>>>>        Get psProvider to wProvider
76384>>>>>>>>>>>>>>>        
76384>>>>>>>>>>>>>>>        //  Determine address to be passed as provider
76384>>>>>>>>>>>>>>>        If (Trim(wProvider) <> "") Begin
76386>>>>>>>>>>>>>>>            Move (AddressOf(wProvider)) to pProv
76387>>>>>>>>>>>>>>>        End
76387>>>>>>>>>>>>>>>>
76387>>>>>>>>>>>>>>>        Else Begin
76388>>>>>>>>>>>>>>>            Move 0 to pProv
76389>>>>>>>>>>>>>>>        End
76389>>>>>>>>>>>>>>>>
76389>>>>>>>>>>>>>>>        
76389>>>>>>>>>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
76389>>>>>>>>>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
76390>>>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
76392>>>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
76393>>>>>>>>>>>>>>>        End
76393>>>>>>>>>>>>>>>>
76393>>>>>>>>>>>>>>>        
76393>>>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
76395>>>>>>>>>>>>>>>            // Fallback to original
76395>>>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
76396>>>>>>>>>>>>>>>            
76396>>>>>>>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
76398>>>>>>>>>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
76399>>>>>>>>>>>>>>>            End
76399>>>>>>>>>>>>>>>>
76399>>>>>>>>>>>>>>>        End
76399>>>>>>>>>>>>>>>>
76399>>>>>>>>>>>>>>>        Set Private_phProv to hProv
76400>>>>>>>>>>>>>>>        
76400>>>>>>>>>>>>>>>        Function_Return hProv
76401>>>>>>>>>>>>>>>    End_Function
76402>>>>>>>>>>>>>>>    
76402>>>>>>>>>>>>>>>    // Releases key container handle
76402>>>>>>>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
76404>>>>>>>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
76405>>>>>>>>>>>>>>>    End_Function
76406>>>>>>>>>>>>>>>    
76406>>>>>>>>>>>>>>>    // Creates hash object
76406>>>>>>>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
76408>>>>>>>>>>>>>>>        Integer iAlgorithm
76408>>>>>>>>>>>>>>>        Handle hHash
76408>>>>>>>>>>>>>>>        Boolean bOk
76408>>>>>>>>>>>>>>>        
76408>>>>>>>>>>>>>>>        Move 0 to hHash
76409>>>>>>>>>>>>>>>        Get piHash to iAlgorithm
76410>>>>>>>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
76411>>>>>>>>>>>>>>>        
76411>>>>>>>>>>>>>>>        Function_Return hHash
76412>>>>>>>>>>>>>>>    End_Function
76413>>>>>>>>>>>>>>>    
76413>>>>>>>>>>>>>>>    // Destroys the hash object
76413>>>>>>>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
76415>>>>>>>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
76416>>>>>>>>>>>>>>>    End_Function
76417>>>>>>>>>>>>>>>    
76417>>>>>>>>>>>>>>>    // Adds data to hash object
76417>>>>>>>>>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
76419>>>>>>>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
76420>>>>>>>>>>>>>>>    End_Function
76421>>>>>>>>>>>>>>>    
76421>>>>>>>>>>>>>>>    // Generates session key
76421>>>>>>>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
76423>>>>>>>>>>>>>>>        Integer iAlgorithm
76423>>>>>>>>>>>>>>>        Handle hKey
76423>>>>>>>>>>>>>>>        Boolean bOk
76423>>>>>>>>>>>>>>>        
76423>>>>>>>>>>>>>>>        Move 0 to hKey
76424>>>>>>>>>>>>>>>        Get piCipher to iAlgorithm
76425>>>>>>>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
76426>>>>>>>>>>>>>>>        
76426>>>>>>>>>>>>>>>        Function_Return hKey
76427>>>>>>>>>>>>>>>    End_Function
76428>>>>>>>>>>>>>>>    
76428>>>>>>>>>>>>>>>    // Imports a plain text key
76428>>>>>>>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
76430>>>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
76430>>>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
76430>>>>>>>>>>>>>>>        Boolean   bSuccess
76430>>>>>>>>>>>>>>>        Handle    hKey
76430>>>>>>>>>>>>>>>        Integer   iHeadSize iKeySize
76430>>>>>>>>>>>>>>>        UChar[]   ucaKeyblob
76431>>>>>>>>>>>>>>>        Integer iVoid
76431>>>>>>>>>>>>>>>        
76431>>>>>>>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
76432>>>>>>>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
76433>>>>>>>>>>>>>>>        
76433>>>>>>>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
76434>>>>>>>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
76435>>>>>>>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
76436>>>>>>>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
76437>>>>>>>>>>>>>>>        
76437>>>>>>>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
76438>>>>>>>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
76439>>>>>>>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
76440>>>>>>>>>>>>>>>        
76440>>>>>>>>>>>>>>>        Move 0 to hKey
76441>>>>>>>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
76442>>>>>>>>>>>>>>>        If (not(bSuccess)) Begin
76444>>>>>>>>>>>>>>>            Move (ShowLastError()) to iVoid
76445>>>>>>>>>>>>>>>        End
76445>>>>>>>>>>>>>>>>
76445>>>>>>>>>>>>>>>        
76445>>>>>>>>>>>>>>>        Function_Return hKey
76446>>>>>>>>>>>>>>>    End_Function
76447>>>>>>>>>>>>>>>    
76447>>>>>>>>>>>>>>>    // Destroys the key
76447>>>>>>>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
76449>>>>>>>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
76450>>>>>>>>>>>>>>>    End_Function
76451>>>>>>>>>>>>>>>    
76451>>>>>>>>>>>>>>>    // Retrieves key data
76451>>>>>>>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
76453>>>>>>>>>>>>>>>        Integer iBuffer iLen
76453>>>>>>>>>>>>>>>        Boolean bOk
76453>>>>>>>>>>>>>>>        
76453>>>>>>>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
76454>>>>>>>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
76455>>>>>>>>>>>>>>>        Function_Return iBuffer
76456>>>>>>>>>>>>>>>    End_Function
76457>>>>>>>>>>>>>>>    
76457>>>>>>>>>>>>>>>    // Retrieves a hash value
76457>>>>>>>>>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
76459>>>>>>>>>>>>>>>        UChar[] ucHash
76460>>>>>>>>>>>>>>>        Integer liResult
76460>>>>>>>>>>>>>>>        DWord   dwDataLen
76460>>>>>>>>>>>>>>>        
76460>>>>>>>>>>>>>>>        Move 0 to dwDataLen
76461>>>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
76462>>>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
76465>>>>>>>>>>>>>>>        
76465>>>>>>>>>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
76466>>>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
76467>>>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
76470>>>>>>>>>>>>>>>        
76470>>>>>>>>>>>>>>>        Function_Return ucHash
76471>>>>>>>>>>>>>>>    End_Function
76472>>>>>>>>>>>>>>>
76472>>>>>>>>>>>>>>>    // Encrypts data
76472>>>>>>>>>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
76474>>>>>>>>>>>>>>>        Handle hProv hHash hKey
76474>>>>>>>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
76474>>>>>>>>>>>>>>>        Boolean bOk
76474>>>>>>>>>>>>>>>        
76474>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76475>>>>>>>>>>>>>>>        If (hProv) Begin
76477>>>>>>>>>>>>>>>            Get CreateHash hProv to hHash
76478>>>>>>>>>>>>>>>            If (hHash) Begin
76480>>>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
76481>>>>>>>>>>>>>>>                If (bOk) Begin
76483>>>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
76484>>>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
76485>>>>>>>>>>>>>>>                End
76485>>>>>>>>>>>>>>>>
76485>>>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
76486>>>>>>>>>>>>>>>            End
76486>>>>>>>>>>>>>>>>
76486>>>>>>>>>>>>>>>            
76486>>>>>>>>>>>>>>>            If (hKey) Begin
76488>>>>>>>>>>>>>>>                //  First call to determine resulting data size
76488>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
76489>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
76490>>>>>>>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
76491>>>>>>>>>>>>>>>                
76491>>>>>>>>>>>>>>>                //  Reserve space in string
76491>>>>>>>>>>>>>>>                If (iDataLen < iCipherLen) Begin
76493>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
76494>>>>>>>>>>>>>>>                End
76494>>>>>>>>>>>>>>>>
76494>>>>>>>>>>>>>>>                
76494>>>>>>>>>>>>>>>                //  Call to really decrypt
76494>>>>>>>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
76495>>>>>>>>>>>>>>>                //If (not(bOk)) Begin
76495>>>>>>>>>>>>>>>                //Move "" to sData
76495>>>>>>>>>>>>>>>                //Move (GetLastError()) to iErr
76495>>>>>>>>>>>>>>>                //End
76495>>>>>>>>>>>>>>>                
76495>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76496>>>>>>>>>>>>>>>            End 
76496>>>>>>>>>>>>>>>>
76496>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76497>>>>>>>>>>>>>>>        End 
76497>>>>>>>>>>>>>>>>
76497>>>>>>>>>>>>>>>        Function_Return ucData
76498>>>>>>>>>>>>>>>    End_Function
76499>>>>>>>>>>>>>>>    
76499>>>>>>>>>>>>>>>    // Decrypts data
76499>>>>>>>>>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
76501>>>>>>>>>>>>>>>        Handle hProv hHash hKey
76501>>>>>>>>>>>>>>>        Integer iAlgorithm iDataLen
76501>>>>>>>>>>>>>>>        Boolean bOk
76501>>>>>>>>>>>>>>>        
76501>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76502>>>>>>>>>>>>>>>        If (hProv) Begin
76504>>>>>>>>>>>>>>>            Get CreateHash hProv to hHash
76505>>>>>>>>>>>>>>>            If (hHash) Begin
76507>>>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
76508>>>>>>>>>>>>>>>                If (bOk) Begin
76510>>>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
76511>>>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
76512>>>>>>>>>>>>>>>                End
76512>>>>>>>>>>>>>>>>
76512>>>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
76513>>>>>>>>>>>>>>>            End
76513>>>>>>>>>>>>>>>>
76513>>>>>>>>>>>>>>>            
76513>>>>>>>>>>>>>>>            If (hKey) Begin
76515>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
76516>>>>>>>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
76517>>>>>>>>>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
76517>>>>>>>>>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
76519>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
76520>>>>>>>>>>>>>>>                End
76520>>>>>>>>>>>>>>>>
76520>>>>>>>>>>>>>>>                
76520>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76521>>>>>>>>>>>>>>>            End
76521>>>>>>>>>>>>>>>>
76521>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76522>>>>>>>>>>>>>>>        End
76522>>>>>>>>>>>>>>>>
76522>>>>>>>>>>>>>>>        Function_Return ucData
76523>>>>>>>>>>>>>>>    End_Function
76524>>>>>>>>>>>>>>>    
76524>>>>>>>>>>>>>>>    // Creates a key
76524>>>>>>>>>>>>>>>    Function CreateKey Handle hProv Returns Handle
76526>>>>>>>>>>>>>>>        Integer iAlg iType iByte iLength iSize
76526>>>>>>>>>>>>>>>        CryptoBlob keyBlob
76526>>>>>>>>>>>>>>>        CryptoBlob keyBlob
76526>>>>>>>>>>>>>>>        Boolean bOk
76526>>>>>>>>>>>>>>>        Handle hKey
76526>>>>>>>>>>>>>>>        UChar[] aKey
76527>>>>>>>>>>>>>>>
76527>>>>>>>>>>>>>>>        Get paKey to aKey
76528>>>>>>>>>>>>>>>        Get piKeyAlg to iAlg
76529>>>>>>>>>>>>>>>        Get piKeyType to iType
76530>>>>>>>>>>>>>>>        Move iAlg                   to keyBlob.header.bType
76531>>>>>>>>>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
76532>>>>>>>>>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
76533>>>>>>>>>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
76534>>>>>>>>>>>>>>>        
76534>>>>>>>>>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
76535>>>>>>>>>>>>>>>        For iByte from 0 to iLength
76541>>>>>>>>>>>>>>>>
76541>>>>>>>>>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
76542>>>>>>>>>>>>>>>        Loop
76543>>>>>>>>>>>>>>>>
76543>>>>>>>>>>>>>>>        
76543>>>>>>>>>>>>>>>        Move 0 to hKey
76544>>>>>>>>>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
76545>>>>>>>>>>>>>>>        Function_Return hKey
76546>>>>>>>>>>>>>>>    End_Function
76547>>>>>>>>>>>>>>>    
76547>>>>>>>>>>>>>>>    // Sets the key parameters
76547>>>>>>>>>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
76549>>>>>>>>>>>>>>>        Integer iPadding iMode
76549>>>>>>>>>>>>>>>        Boolean bOk
76549>>>>>>>>>>>>>>>        UChar[] aIV
76550>>>>>>>>>>>>>>>        
76550>>>>>>>>>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
76550>>>>>>>>>>>>>>>        //For iByte from 0 to iLength
76550>>>>>>>>>>>>>>>        //    Move iByte to aIV[iByte]
76550>>>>>>>>>>>>>>>        //Loop
76550>>>>>>>>>>>>>>>
76550>>>>>>>>>>>>>>>        // Set initialization vector
76550>>>>>>>>>>>>>>>        Get paIV to aIV
76551>>>>>>>>>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
76552>>>>>>>>>>>>>>>        If (bOk) Begin
76554>>>>>>>>>>>>>>>            // Set padding
76554>>>>>>>>>>>>>>>            Get piKeyPadding to iPadding
76555>>>>>>>>>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
76556>>>>>>>>>>>>>>>            If (bOk) Begin
76558>>>>>>>>>>>>>>>                // Set move
76558>>>>>>>>>>>>>>>                Get piKeyMode to iMode
76559>>>>>>>>>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
76560>>>>>>>>>>>>>>>            End
76560>>>>>>>>>>>>>>>>
76560>>>>>>>>>>>>>>>        End
76560>>>>>>>>>>>>>>>>
76560>>>>>>>>>>>>>>>        Function_Return bOk        
76561>>>>>>>>>>>>>>>    End_Function
76562>>>>>>>>>>>>>>>    
76562>>>>>>>>>>>>>>>    // Encrypts using block cipher
76562>>>>>>>>>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
76564>>>>>>>>>>>>>>>        Handle hProv hKey
76564>>>>>>>>>>>>>>>        Integer iLen iSize iBlocks
76564>>>>>>>>>>>>>>>        Boolean bOk
76564>>>>>>>>>>>>>>>        
76564>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76565>>>>>>>>>>>>>>>        If (hProv) Begin
76567>>>>>>>>>>>>>>>            // Create key
76567>>>>>>>>>>>>>>>            Get CreateKey hProv to hKey
76568>>>>>>>>>>>>>>>            If (hKey) Begin
76570>>>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
76571>>>>>>>>>>>>>>>                If (bOk) Begin
76573>>>>>>>>>>>>>>>                    // Buffer for block ciphers can be up to block length larger
76573>>>>>>>>>>>>>>>                    Get piBlockSize to iSize
76574>>>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76575>>>>>>>>>>>>>>>                    
76575>>>>>>>>>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
76576>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
76577>>>>>>>>>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
76578>>>>>>>>>>>>>>>                End
76578>>>>>>>>>>>>>>>>
76578>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76579>>>>>>>>>>>>>>>            End
76579>>>>>>>>>>>>>>>>
76579>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76580>>>>>>>>>>>>>>>        End
76580>>>>>>>>>>>>>>>>
76580>>>>>>>>>>>>>>>        Function_Return ucData
76581>>>>>>>>>>>>>>>    End_Function
76582>>>>>>>>>>>>>>>    
76582>>>>>>>>>>>>>>>    // Decrypts using block cipher
76582>>>>>>>>>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
76584>>>>>>>>>>>>>>>        Handle hProv hKey
76584>>>>>>>>>>>>>>>        Integer iLen
76584>>>>>>>>>>>>>>>        Boolean bOk
76584>>>>>>>>>>>>>>>        
76584>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76585>>>>>>>>>>>>>>>        If (hProv) Begin
76587>>>>>>>>>>>>>>>            // Create key
76587>>>>>>>>>>>>>>>            Get CreateKey hProv to hKey
76588>>>>>>>>>>>>>>>            If (hKey) Begin
76590>>>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
76591>>>>>>>>>>>>>>>                If (bOk) Begin
76593>>>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76594>>>>>>>>>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
76595>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
76596>>>>>>>>>>>>>>>                End
76596>>>>>>>>>>>>>>>>
76596>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76597>>>>>>>>>>>>>>>            End
76597>>>>>>>>>>>>>>>>
76597>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76598>>>>>>>>>>>>>>>        End
76598>>>>>>>>>>>>>>>>
76598>>>>>>>>>>>>>>>        Function_Return ucData
76599>>>>>>>>>>>>>>>    End_Function
76600>>>>>>>>>>>>>>>    
76600>>>>>>>>>>>>>>>    
76600>>>>>>>>>>>>>>>    //  Generates random data.
76600>>>>>>>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
76602>>>>>>>>>>>>>>>        Handle hProv
76602>>>>>>>>>>>>>>>        UChar[] uaResult
76603>>>>>>>>>>>>>>>        Boolean bRes
76603>>>>>>>>>>>>>>>        
76603>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76604>>>>>>>>>>>>>>>        
76604>>>>>>>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
76605>>>>>>>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
76606>>>>>>>>>>>>>>>        
76606>>>>>>>>>>>>>>>        Get ReleaseContext hProv to bRes
76607>>>>>>>>>>>>>>>        
76607>>>>>>>>>>>>>>>        Function_Return uaResult
76608>>>>>>>>>>>>>>>    End_Function
76609>>>>>>>>>>>>>>>    
76609>>>>>>>>>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
76609>>>>>>>>>>>>>>>    Function GenerateRandomString Integer iLength Returns String
76611>>>>>>>>>>>>>>>        String sResult
76611>>>>>>>>>>>>>>>        UChar[] ucData
76612>>>>>>>>>>>>>>>        Pointer pBase64
76612>>>>>>>>>>>>>>>        Integer iVoid
76612>>>>>>>>>>>>>>>        
76612>>>>>>>>>>>>>>>        Get GenerateRandom iLength to ucData
76613>>>>>>>>>>>>>>>        
76613>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
76614>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76615>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76616>>>>>>>>>>>>>>>        
76616>>>>>>>>>>>>>>>        Function_Return (Left(sResult, iLength))
76617>>>>>>>>>>>>>>>    End_Function
76618>>>>>>>>>>>>>>>    
76618>>>>>>>>>>>>>>>End_Class
76619>>>>>>>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Base64Functions.pkg)
76619>>>>>>>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
76619>>>>>>>>>>>>>>>//>
76619>>>>>>>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
76619>>>>>>>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
76619>>>>>>>>>>>>>>>//>
76619>>>>>>>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
76619>>>>>>>>>>>>>>>//> strings.
76619>>>>>>>>>>>>>>>//>
76619>>>>>>>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
76619>>>>>>>>>>>>>>>//> Base64Decode) that are built into the runtime.
76619>>>>>>>>>>>>>>>//>
76619>>>>>>>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
76619>>>>>>>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
76619>>>>>>>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
76619>>>>>>>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
76619>>>>>>>>>>>>>>>
76619>>>>>>>>>>>>>>>Use VdfBase.pkg
76619>>>>>>>>>>>>>>>
76619>>>>>>>>>>>>>>>// Functions in vdfBase64.dll
76619>>>>>>>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
76620>>>>>>>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
76621>>>>>>>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
76622>>>>>>>>>>>>>>>
76622>>>>>>>>>>>>>>>// Structure
76622>>>>>>>>>>>>>>>Struct txxfBase64Buffer
76622>>>>>>>>>>>>>>>    Pointer pData
76622>>>>>>>>>>>>>>>    Integer iLength
76622>>>>>>>>>>>>>>>End_Struct 
76622>>>>>>>>>>>>>>>
76622>>>>>>>>>>>>>>>Global_Variable Integer oBase64Functions
76622>>>>>>>>>>>>>>>
76622>>>>>>>>>>>>>>>Object _oBase64Functions is a cObject
76624>>>>>>>>>>>>>>>    Move Self to oBase64Functions
76625>>>>>>>>>>>>>>>
76625>>>>>>>>>>>>>>>
76625>>>>>>>>>>>>>>>    Function EncodeString String sValue Returns String
76628>>>>>>>>>>>>>>>        Address pBase64
76628>>>>>>>>>>>>>>>        String sResult
76628>>>>>>>>>>>>>>>        Integer iVoid
76628>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
76629>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76630>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76631>>>>>>>>>>>>>>>        Function_Return sResult
76632>>>>>>>>>>>>>>>    End_Function
76633>>>>>>>>>>>>>>>
76633>>>>>>>>>>>>>>>    Function DecodeString String sValue Returns String
76636>>>>>>>>>>>>>>>        Address pBinary
76636>>>>>>>>>>>>>>>        String sBinary
76636>>>>>>>>>>>>>>>        Integer iVoid iLen
76636>>>>>>>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
76637>>>>>>>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
76638>>>>>>>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
76639>>>>>>>>>>>>>>>        Move (Free(pBinary)) to iVoid
76640>>>>>>>>>>>>>>>        Function_Return sBinary
76641>>>>>>>>>>>>>>>    End_Function
76642>>>>>>>>>>>>>>>
76642>>>>>>>>>>>>>>>End_Object
76643>>>>>>>>>>>>>Use MSSqldrv.pkg
76643>>>>>>>>>>>>>Use db2_drv.pkg
76643>>>>>>>>>>>>>Use odbc_drv.pkg
76643>>>>>>>>>>>>>Use DFBtrDrv.pkg
76643>>>>>>>>>>>>>Use vWin32fh.pkg
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>Use DUFLanguageConstants.inc
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>// Create a new PSQL identifier for the Btrieve driver.
76643>>>>>>>>>>>>>    Define PSQLDRV_ID for "DFBTRDRV"
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
76643>>>>>>>>>>>>>// They can have slightly different SQL keywords.
76643>>>>>>>>>>>>>// Note: If a new type is added to the list,
76643>>>>>>>>>>>>>//       the struct array xxx must be adjusted
76643>>>>>>>>>>>>>//       so that it is filled with all SQL
76643>>>>>>>>>>>>>//       keywords for that new type.
76643>>>>>>>>>>>>>Enum_List  
76643>>>>>>>>>>>>>        Define EN_DbTypeDataFlex   for 0
76643>>>>>>>>>>>>>        Define EN_DbTypeMSSQL      for 1
76643>>>>>>>>>>>>>        Define EN_DbTypeMySQL      for 2
76643>>>>>>>>>>>>>        Define EN_DbTypeOracle     for 3
76643>>>>>>>>>>>>>        Define EN_DbTypeDB2        for 4
76643>>>>>>>>>>>>>        Define EN_DbTypePostgre    for 5
76643>>>>>>>>>>>>>        Define EN_DbTypePervasive  for 6
76643>>>>>>>>>>>>>End_Enum_List
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
76643>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
76643>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
76643>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
76643>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
76643>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
76643>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
76643>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
76643>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
76643>>>>>>>>>>>>>Define CS_DbTypePervasive   for "Pervasive.SQL (Btrieve)"
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>// SQLConnection.ini constants:
76643>>>>>>>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
76643>>>>>>>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
76643>>>>>>>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
76643>>>>>>>>>>>>>Define CS_SQLIniSectionName             for "Connection"
76643>>>>>>>>>>>>>Define CS_SQLODBCIniSectionName         for "ODBC"
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>// DF 19 ini-file settings:
76643>>>>>>>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
76643>>>>>>>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
76643>>>>>>>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
76643>>>>>>>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
76643>>>>>>>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
76643>>>>>>>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
76643>>>>>>>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
76643>>>>>>>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
76643>>>>>>>>>>>>>Define CS_SQLIniFileDSNKeyword          for "FILEDSN"
76643>>>>>>>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
76643>>>>>>>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection" 
76643>>>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>// Database Update Framework extended settings:
76643>>>>>>>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
76643>>>>>>>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
76643>>>>>>>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
76643>>>>>>>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
76643>>>>>>>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
76643>>>>>>>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
76643>>>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
76643>>>>>>>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
76643>>>>>>>>>>>>>Define CS_SQLIniConnectionNo            for "No"
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>Struct tSQLConnection
76643>>>>>>>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
76643>>>>>>>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
76643>>>>>>>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
76643>>>>>>>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. MSSQLDRV, DB2_DRV, ODBC_DRV or PSQLDRV_ID.
76643>>>>>>>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
76643>>>>>>>>>>>>>    String sDatabase                // 6. SQL Database
76643>>>>>>>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
76643>>>>>>>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
76643>>>>>>>>>>>>>    String sUserID                  // 9. User ID
76643>>>>>>>>>>>>>    String sPassword                // 10. Password
76643>>>>>>>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
76643>>>>>>>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
76643>>>>>>>>>>>>>    String sLongTableSpace          // 13. DB2 specific
76643>>>>>>>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
76643>>>>>>>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
76643>>>>>>>>>>>>>    Boolean bError                  // 16. Set to true on error.
76643>>>>>>>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
76643>>>>>>>>>>>>>End_Struct
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>Struct tFilelist
76643>>>>>>>>>>>>>    String sRootName
76643>>>>>>>>>>>>>    String sLogicalName
76643>>>>>>>>>>>>>    String sDisplayName    
76643>>>>>>>>>>>>>    String sNoDriverRootname
76643>>>>>>>>>>>>>    String sDriver
76643>>>>>>>>>>>>>    Handle hTable
76643>>>>>>>>>>>>>    Boolean bIsSystemFile 
76643>>>>>>>>>>>>>    Boolean bErrorOpening
76643>>>>>>>>>>>>>    Boolean bIsAlias
76643>>>>>>>>>>>>>End_Struct
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>Struct tFilelistLogicalName
76643>>>>>>>>>>>>>    String sLogicalName
76643>>>>>>>>>>>>>    String sNoDriverRootname
76643>>>>>>>>>>>>>    String sRootName
76643>>>>>>>>>>>>>    String sDisplayName    
76643>>>>>>>>>>>>>    String sDriver
76643>>>>>>>>>>>>>    Handle hTable
76643>>>>>>>>>>>>>    Boolean bIsSystemFile 
76643>>>>>>>>>>>>>    Boolean bErrorOpening
76643>>>>>>>>>>>>>    Boolean bIsAlias
76643>>>>>>>>>>>>>End_Struct
76643>>>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
76643>>>>>>>>>>>>>Use DUFLanguageConstants.inc
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
76643>>>>>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>    Define CS_OEM_Txt for "OEM"
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>    Define CS_SERVER for "SERVER"
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
76643>>>>>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>    Define CS_DUFBackupDataFolder for "BackupData"
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
76643>>>>>>>>>>>>>
76643>>>>>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary  
76643>>>>>>>>>>>>>    Move 0 to ghoDbUpdateFunctionLibrary
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>Struct tSQLScriptArray
76644>>>>>>>>>>>>>    Boolean bError
76644>>>>>>>>>>>>>    Boolean bArgumentSizeChanged
76644>>>>>>>>>>>>>    Integer iOrgArgumentSize
76644>>>>>>>>>>>>>    String[] sSQLScriptArray
76644>>>>>>>>>>>>>End_Struct
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>Struct tSqlErrorArray
76644>>>>>>>>>>>>>    String[]  sSqlErrorArray
76644>>>>>>>>>>>>>    String[]  sSqlStatementArray
76644>>>>>>>>>>>>>    Integer[] iSqlErrorArray
76644>>>>>>>>>>>>>End_Struct
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>Struct tSqlColumnNew
76644>>>>>>>>>>>>>    String  sBaseColumnName
76644>>>>>>>>>>>>>    String  sBaseTableName
76644>>>>>>>>>>>>>    String  sLabel
76644>>>>>>>>>>>>>    Integer iSqlType
76644>>>>>>>>>>>>>    Integer iSize
76644>>>>>>>>>>>>>    Integer iPrecision
76644>>>>>>>>>>>>>    Integer iDFType
76644>>>>>>>>>>>>>    Integer iDFNativeType
76644>>>>>>>>>>>>>End_Struct
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>Struct tColumnType
76644>>>>>>>>>>>>>    Integer iSQLType
76644>>>>>>>>>>>>>    String  sSQLType
76644>>>>>>>>>>>>>    Boolean bCanEditSize
76644>>>>>>>>>>>>>    Integer iDefaultSize
76644>>>>>>>>>>>>>    Integer iMinSize
76644>>>>>>>>>>>>>    Number  nMaxSize
76644>>>>>>>>>>>>>    String  sDataFlexType
76644>>>>>>>>>>>>>    Integer iDataFlexType
76644>>>>>>>>>>>>>    Boolean bNativeDataType
76644>>>>>>>>>>>>>    String  sPrecision
76644>>>>>>>>>>>>>End_Struct
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
76644>>>>>>>>>>>>>// Various SQL back-ends can have slightly different
76644>>>>>>>>>>>>>// keywords.
76644>>>>>>>>>>>>>Struct tSQLKeyWords
76644>>>>>>>>>>>>>    Integer iSQLWord
76644>>>>>>>>>>>>>    Integer iSQLDbType
76644>>>>>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
76644>>>>>>>>>>>>>End_Struct
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>Struct tSQLRelation
76644>>>>>>>>>>>>>    Integer iFileNumber
76644>>>>>>>>>>>>>    Integer iFieldNumber
76644>>>>>>>>>>>>>    String  sFileName
76644>>>>>>>>>>>>>    String  sFieldName
76644>>>>>>>>>>>>>End_Struct
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>Struct tSQLLoggedInUser
76644>>>>>>>>>>>>>    String sUser
76644>>>>>>>>>>>>>    String sProgram
76644>>>>>>>>>>>>>End_Struct
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
76644>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
76644>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
76644>>>>>>>>>>>>>// They can have slightly different SQL keywords.
76644>>>>>>>>>>>>>// Note: If a new type is added to the list,
76644>>>>>>>>>>>>>//       the struct array xxx must be adjusted
76644>>>>>>>>>>>>>//       so that it is filled with all SQL
76644>>>>>>>>>>>>>//       keywords for that new type.
76644>>>>>>>>>>>>>Enum_List
76644>>>>>>>>>>>>>//    Define EN_DbTypeMSSQL
76644>>>>>>>>>>>>>//    Define EN_DbTypeMySQL
76644>>>>>>>>>>>>>//    Define EN_DbTypeOracle
76644>>>>>>>>>>>>>//    Define EN_DbTypeDB2
76644>>>>>>>>>>>>>//    Define EN_DbTypePostgre
76644>>>>>>>>>>>>>//    Define EN_DbTypeDataFlex // Embedded database.
76644>>>>>>>>>>>>>End_Enum_List
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
76644>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
76644>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
76644>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
76644>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
76644>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
76644>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
76644>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
76644>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
76644>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
76644>>>>>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
76644>>>>>>>>>>>>>Enum_List
76644>>>>>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
76644>>>>>>>>>>>>>    Define DF_BCD_DUF       for -1499
76644>>>>>>>>>>>>>    Define DF_DATE_DUF      for -1498
76644>>>>>>>>>>>>>    Define DF_TEXT_DUF      for -1495
76644>>>>>>>>>>>>>    Define DF_BINARY_DUF    for -1494
76644>>>>>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
76644>>>>>>>>>>>>>End_Enum_List
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
76644>>>>>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
76644>>>>>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>// These are not defined pre DF 18:
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>Struct tSQLIntTableInfo
76644>>>>>>>>>>>>>    String sDriverName
76644>>>>>>>>>>>>>    String sServerName
76644>>>>>>>>>>>>>    String sDatabaseName
76644>>>>>>>>>>>>>    String sSchemaName
76644>>>>>>>>>>>>>    Boolean bRecnumTable
76644>>>>>>>>>>>>>    Integer iPrimaryIndex
76644>>>>>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
76644>>>>>>>>>>>>>    String sTableCharacterFormat
76644>>>>>>>>>>>>>    Boolean bUseDummyZeroDate
76644>>>>>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
76644>>>>>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
76644>>>>>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
76644>>>>>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
76644>>>>>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
76644>>>>>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
76644>>>>>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
76644>>>>>>>>>>>>>    String sFileIndexTablespace
76644>>>>>>>>>>>>>    String sFileLongTablespace
76644>>>>>>>>>>>>>    String sTableTablespace
76644>>>>>>>>>>>>>End_Struct
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>Struct tSQLIntColumnInfo
76644>>>>>>>>>>>>>    Integer iFieldNumber
76644>>>>>>>>>>>>>    Integer iFieldIndex
76644>>>>>>>>>>>>>    Integer iFieldRelatedFile
76644>>>>>>>>>>>>>    Integer iFieldRelatedField
76644>>>>>>>>>>>>>    Integer iIndexNumber
76644>>>>>>>>>>>>>    Integer iIndexNumberSegments
76644>>>>>>>>>>>>>    Integer iIndexSegmentField1
76644>>>>>>>>>>>>>    Integer iIndexSegmentField2
76644>>>>>>>>>>>>>    Integer iIndexSegmentFieldn
76644>>>>>>>>>>>>>    String  sIndexName
76644>>>>>>>>>>>>>End_Struct
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>Struct tAPIColumn
76644>>>>>>>>>>>>>    Integer iFieldNumber
76644>>>>>>>>>>>>>    String  sFieldName
76644>>>>>>>>>>>>>    Integer iType
76644>>>>>>>>>>>>>    String  sType
76644>>>>>>>>>>>>>    Integer iLength
76644>>>>>>>>>>>>>    Integer iPrecision
76644>>>>>>>>>>>>>    Integer iOptions
76644>>>>>>>>>>>>>    Boolean bIsSQLType
76644>>>>>>>>>>>>>    Boolean bAllowNULL
76644>>>>>>>>>>>>>    String  sDefaultValue
76644>>>>>>>>>>>>>    Boolean bShouldChange
76644>>>>>>>>>>>>>    Boolean bCancel
76644>>>>>>>>>>>>>    Boolean bError
76644>>>>>>>>>>>>>End_Struct
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>Struct tAPIColumnCompare
76644>>>>>>>>>>>>>    Integer iFieldNumber
76644>>>>>>>>>>>>>    // FROM database:
76644>>>>>>>>>>>>>    Boolean bExistsFrom
76644>>>>>>>>>>>>>    String  sFieldNameFrom
76644>>>>>>>>>>>>>    Integer iTypeFrom
76644>>>>>>>>>>>>>    String  sTypeFrom
76644>>>>>>>>>>>>>    Integer iLengthFrom
76644>>>>>>>>>>>>>    Integer iPrecisionFrom
76644>>>>>>>>>>>>>    Integer iOptionsFrom
76644>>>>>>>>>>>>>    Boolean bIsSQLTypeFrom
76644>>>>>>>>>>>>>    Boolean bAllowNULLFrom
76644>>>>>>>>>>>>>    String  sDefaultValueFrom
76644>>>>>>>>>>>>>    Boolean bShouldChangeFrom
76644>>>>>>>>>>>>>    Boolean bCancelFrom
76644>>>>>>>>>>>>>    Boolean bErrorFrom
76644>>>>>>>>>>>>>    // TO database:
76644>>>>>>>>>>>>>    Boolean bExistsTo
76644>>>>>>>>>>>>>    Integer iFieldNumberTo
76644>>>>>>>>>>>>>    String  sFieldNameTo
76644>>>>>>>>>>>>>    Integer iTypeTo
76644>>>>>>>>>>>>>    String  sTypeTo
76644>>>>>>>>>>>>>    Integer iLengthTo
76644>>>>>>>>>>>>>    Integer iPrecisionTo
76644>>>>>>>>>>>>>    Integer iOptionsTo
76644>>>>>>>>>>>>>    Boolean bIsSQLTypeTo
76644>>>>>>>>>>>>>    Boolean bAllowNULLTo
76644>>>>>>>>>>>>>    String  sDefaultValueTo
76644>>>>>>>>>>>>>    Boolean bShouldChangeTo
76644>>>>>>>>>>>>>    Boolean bCancelTo
76644>>>>>>>>>>>>>    Boolean bErrorTo
76644>>>>>>>>>>>>>End_Struct
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>Struct tAPIRelation
76644>>>>>>>>>>>>>    Handle  hTableFrom
76644>>>>>>>>>>>>>    Integer iColumnFrom
76644>>>>>>>>>>>>>    Handle  hTableTo
76644>>>>>>>>>>>>>    Integer iColumnTo
76644>>>>>>>>>>>>>    String  sLogicalNameFrom
76644>>>>>>>>>>>>>    String  sLogicalNameTo
76644>>>>>>>>>>>>>    String  sFieldNameFrom
76644>>>>>>>>>>>>>    String  sFieldNameTo
76644>>>>>>>>>>>>>    Boolean bShouldChange
76644>>>>>>>>>>>>>    Boolean bCancel
76644>>>>>>>>>>>>>    Boolean bError
76644>>>>>>>>>>>>>End_Struct
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>Struct tAPIRelationCompare
76644>>>>>>>>>>>>>    // Common:
76644>>>>>>>>>>>>>    Handle  hTableFrom
76644>>>>>>>>>>>>>    Integer iColumnFrom
76644>>>>>>>>>>>>>    Handle  hTableTo
76644>>>>>>>>>>>>>    Integer iColumnTo
76644>>>>>>>>>>>>>    // FROM database:
76644>>>>>>>>>>>>>    Boolean bExistsFrom
76644>>>>>>>>>>>>>    String  sLogicalNameFrom_From
76644>>>>>>>>>>>>>    String  sLogicalNameTo_From
76644>>>>>>>>>>>>>    String  sFieldNameFrom_From
76644>>>>>>>>>>>>>    String  sFieldNameTo_From
76644>>>>>>>>>>>>>    Boolean bShouldChange_From
76644>>>>>>>>>>>>>    Boolean bCancel_From
76644>>>>>>>>>>>>>    Boolean bError_From
76644>>>>>>>>>>>>>    // TO database:
76644>>>>>>>>>>>>>    Boolean bExistsTo
76644>>>>>>>>>>>>>    String  sLogicalNameFrom_To
76644>>>>>>>>>>>>>    String  sLogicalNameTo_To
76644>>>>>>>>>>>>>    String  sFieldNameFrom_To
76644>>>>>>>>>>>>>    String  sFieldNameTo_To
76644>>>>>>>>>>>>>    Boolean bShouldChange_To
76644>>>>>>>>>>>>>    Boolean bCancel_To
76644>>>>>>>>>>>>>    Boolean bError_To
76644>>>>>>>>>>>>>End_Struct
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>Struct tAPIIndexSegment
76644>>>>>>>>>>>>>    Integer iFieldNumber
76644>>>>>>>>>>>>>    String  sFieldName
76644>>>>>>>>>>>>>    Boolean bUppercase
76644>>>>>>>>>>>>>    Boolean bAscending
76644>>>>>>>>>>>>>    Boolean bShouldChange
76644>>>>>>>>>>>>>    Boolean bCancel
76644>>>>>>>>>>>>>    Boolean bError
76644>>>>>>>>>>>>>End_Struct
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>Struct tAPIIndex
76644>>>>>>>>>>>>>    Integer iIndexNumber
76644>>>>>>>>>>>>>    Integer iPrimaryIndex
76644>>>>>>>>>>>>>    String  sSQLIndexName
76644>>>>>>>>>>>>>    Integer iSQLIndexType
76644>>>>>>>>>>>>>    Boolean bIsSQLClustered
76644>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKey
76644>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
76644>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
76644>>>>>>>>>>>>>    Boolean bShouldChange
76644>>>>>>>>>>>>>    Boolean bCancel
76644>>>>>>>>>>>>>    Boolean bError
76644>>>>>>>>>>>>>End_Struct
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>Struct tAPIIndexCompare
76644>>>>>>>>>>>>>    // Common:
76644>>>>>>>>>>>>>    Integer iIndexNumber
76644>>>>>>>>>>>>>    // FROM database:
76644>>>>>>>>>>>>>    Boolean bExistsFrom
76644>>>>>>>>>>>>>    Integer iPrimaryIndexFrom
76644>>>>>>>>>>>>>    String  sSQLIndexNameFrom
76644>>>>>>>>>>>>>    Integer iSQLIndexTypeFrom
76644>>>>>>>>>>>>>    Boolean bIsSQLClusteredFrom
76644>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
76644>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
76644>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
76644>>>>>>>>>>>>>    Boolean bShouldChangeFrom
76644>>>>>>>>>>>>>    Boolean bCancelFrom
76644>>>>>>>>>>>>>    Boolean bErrorFrom
76644>>>>>>>>>>>>>    // TO database:
76644>>>>>>>>>>>>>    Boolean bExistsTo
76644>>>>>>>>>>>>>    Integer iPrimaryIndexTo
76644>>>>>>>>>>>>>    String  sSQLIndexNameTo
76644>>>>>>>>>>>>>    Integer iSQLIndexTypeTo
76644>>>>>>>>>>>>>    Boolean bIsSQLClusteredTo
76644>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
76644>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
76644>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
76644>>>>>>>>>>>>>    Boolean bShouldChangeTo
76644>>>>>>>>>>>>>    Boolean bCancelTo
76644>>>>>>>>>>>>>    Boolean bErrorTo
76644>>>>>>>>>>>>>End_Struct
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>Struct tAPITableNameInfo
76644>>>>>>>>>>>>>    Integer iTableNumber
76644>>>>>>>>>>>>>    String  sRootName
76644>>>>>>>>>>>>>    String  sLogicalName
76644>>>>>>>>>>>>>    String  sDisplayName
76644>>>>>>>>>>>>>    String  sDriverID
76644>>>>>>>>>>>>>    Boolean bIsAlias
76644>>>>>>>>>>>>>    Boolean bIsSQL
76644>>>>>>>>>>>>>    Boolean bIsSystemFile
76644>>>>>>>>>>>>>    Boolean bShouldChange
76644>>>>>>>>>>>>>    Boolean bCancel
76644>>>>>>>>>>>>>    Boolean bError
76644>>>>>>>>>>>>>End_Struct
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>Struct tAPITableNameInfoCompare
76644>>>>>>>>>>>>>    Integer iTableNumber
76644>>>>>>>>>>>>>    // FROM
76644>>>>>>>>>>>>>    Boolean bExistsFrom
76644>>>>>>>>>>>>>    String  sRootNameFrom
76644>>>>>>>>>>>>>    String  sLogicalNameFrom
76644>>>>>>>>>>>>>    String  sDisplayNameFrom
76644>>>>>>>>>>>>>    String  sDriverIDFrom
76644>>>>>>>>>>>>>    Boolean bIsAliasFrom
76644>>>>>>>>>>>>>    Boolean bIsSQLFrom
76644>>>>>>>>>>>>>    Boolean bIsSystemFileFrom
76644>>>>>>>>>>>>>    // TO database:
76644>>>>>>>>>>>>>    Boolean bExistsTo
76644>>>>>>>>>>>>>    String  sRootNameTo
76644>>>>>>>>>>>>>    String  sLogicalNameTo
76644>>>>>>>>>>>>>    String  sDisplayNameTo
76644>>>>>>>>>>>>>    String  sDriverIDTo
76644>>>>>>>>>>>>>    Boolean bIsAliasTo
76644>>>>>>>>>>>>>    Boolean bIsSQLTo
76644>>>>>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
76644>>>>>>>>>>>>>    Boolean bShouldChange
76644>>>>>>>>>>>>>    Boolean bCancel
76644>>>>>>>>>>>>>    Boolean bError
76644>>>>>>>>>>>>>End_Struct
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>Struct tAPITable
76644>>>>>>>>>>>>>    Handle hTable
76644>>>>>>>>>>>>>    Boolean bFromTable
76644>>>>>>>>>>>>>    Boolean bToTable
76644>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
76644>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
76644>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
76644>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
76644>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
76644>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
76644>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
76644>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
76644>>>>>>>>>>>>>    Boolean bShouldChange
76644>>>>>>>>>>>>>    Boolean bCancel
76644>>>>>>>>>>>>>    Boolean bError
76644>>>>>>>>>>>>>End_Struct
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>Struct tAPITableCompare
76644>>>>>>>>>>>>>    Handle hTable
76644>>>>>>>>>>>>>    // FROM database:
76644>>>>>>>>>>>>>    Boolean bExistsFrom
76644>>>>>>>>>>>>>    // TO database:
76644>>>>>>>>>>>>>    Boolean bExistsTo
76644>>>>>>>>>>>>>    // Both:
76644>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
76644>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
76644>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
76644>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
76644>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
76644>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
76644>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
76644>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
76644>>>>>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
76644>>>>>>>>>>>>>    Boolean bCancel         // User cancel
76644>>>>>>>>>>>>>    Boolean bError          // Error occured while collecting data
76644>>>>>>>>>>>>>End_Struct
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>Struct tAPITableBooleans
76644>>>>>>>>>>>>>    Boolean bApiTableUpdateAuto
76644>>>>>>>>>>>>>    Boolean bCompareDate_DateTime
76644>>>>>>>>>>>>>    Boolean bCompareIndexAscending
76644>>>>>>>>>>>>>    Boolean bCompareIndexUppercase
76644>>>>>>>>>>>>>    Boolean bCompareFilelistUppercase
76644>>>>>>>>>>>>>End_Struct
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>Define C_tAPIColumn_None for 0
76644>>>>>>>>>>>>>Define C_tAPIColumn_Identity for 1
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>// SQL Key-Word Constants:  CI_SQLSelect CI_SQLName CI_SQLFrom  CI_SQLSys
76644>>>>>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
76644>>>>>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
76644>>>>>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
76644>>>>>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
76644>>>>>>>>>>>>>Enum_List
76644>>>>>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"
76644>>>>>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
76644>>>>>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
76644>>>>>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
76644>>>>>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
76644>>>>>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
76644>>>>>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
76644>>>>>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
76644>>>>>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
76644>>>>>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
76644>>>>>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
76644>>>>>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
76644>>>>>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
76644>>>>>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
76644>>>>>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
76644>>>>>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
76644>>>>>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
76644>>>>>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
76644>>>>>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
76644>>>>>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
76644>>>>>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
76644>>>>>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
76644>>>>>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
76644>>>>>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
76644>>>>>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
76644>>>>>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
76644>>>>>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
76644>>>>>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
76644>>>>>>>>>>>>>    Define CI_SQLTo                    //for "TO"
76644>>>>>>>>>>>>>    Define CI_SQLGO                    //for "GO"
76644>>>>>>>>>>>>>    Define CI_SQLUse                   //for "USE"
76644>>>>>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>    Define CI_SQLName                  //for "NAME"
76644>>>>>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
76644>>>>>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
76644>>>>>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
76644>>>>>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
76644>>>>>>>>>>>>>    Define CI_SQLID                    //for "ID"
76644>>>>>>>>>>>>>    Define CI_SQLAND                   //for "AND"
76644>>>>>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
76644>>>>>>>>>>>>>    Define CI_SQLSet                   //for "SET"
76644>>>>>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
76644>>>>>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
76644>>>>>>>>>>>>>    Define CI_SQL_SAFE_UPDATES         //for "SQL_SAFE_UPDATES"  
76644>>>>>>>>>>>>>    Define CI_SQLDescription          //for "SELECT name, description from sys.fn_helpcollations()" (Enumerates all collates)
76644>>>>>>>>>>>>>End_Enum_List
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>>>
76644>>>>>>>>>>>
76644>>>>>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
76645>>>>>>>>>>>
76645>>>>>>>>>>>    Procedure CreateDbUpdateLibraryProperties
76647>>>>>>>>>>>        Handle hoSQLManagerMT
76647>>>>>>>>>>>
76647>>>>>>>>>>>        Property String private.psUseDatabase ""
76648>>>>>>>>>>>
76648>>>>>>>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
76648>>>>>>>>>>>        Property Handle  private.phCurrentTable 0
76649>>>>>>>>>>>        Property Integer private.piCurrentField 0
76650>>>>>>>>>>>
76650>>>>>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
76651>>>>>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
76652>>>>>>>>>>>
76652>>>>>>>>>>>        Property Handle phoSQLManagerMT
76653>>>>>>>>>>>
76653>>>>>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
76654>>>>>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
76655>>>>>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
76656>>>>>>>>>>>        Property Handle phoSQLConnectionHandler 0
76657>>>>>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
76658>>>>>>>>>>>
76658>>>>>>>>>>>        Property Boolean pbHandleQueryErrors True
76659>>>>>>>>>>>
76659>>>>>>>>>>>        Property tSqlColumnNew[] paQueryColumns
76660>>>>>>>>>>>        Property String[] paSQLFetchResults
76661>>>>>>>>>>>
76661>>>>>>>>>>>        // Error handling
76661>>>>>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
76662>>>>>>>>>>>        Property Boolean pbSqlError False
76663>>>>>>>>>>>        Property tSqlErrorArray paSqlErrorArray
76664>>>>>>>>>>>        Property Boolean pbProcessingError False
76665>>>>>>>>>>>
76665>>>>>>>>>>>        // Statistics on query
76665>>>>>>>>>>>        Property TimeSpan ptsTotalQueryTime
76666>>>>>>>>>>>        Property TimeSpan ptsQueryExec
76667>>>>>>>>>>>        Property TimeSpan ptsFetchResults
76668>>>>>>>>>>>        Property Integer piColumns 0
76669>>>>>>>>>>>        Property Integer piRows 0
76670>>>>>>>>>>>        Property Integer piRowType 0
76671>>>>>>>>>>>        Property String[] paQueryMessages
76672>>>>>>>>>>>        Property String psSQLStatementString
76673>>>>>>>>>>>
76673>>>>>>>>>>>        Property Integer[] paTableConvertExceptions
76674>>>>>>>>>>>
76674>>>>>>>>>>>        Property Integer[] paTableDateCorrectionExceptions
76675>>>>>>>>>>>
76675>>>>>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
76675>>>>>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
76675>>>>>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
76675>>>>>>>>>>>        Property Integer piChunkMax 500
76676>>>>>>>>>>>
76676>>>>>>>>>>>        // Fill the paSQLKeywordArray array with values;
76676>>>>>>>>>>>        Send SetupSQLKeywordArray
76677>>>>>>>>>>>    End_Procedure
76678>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
76678>>>>>>>>>>>>
76678>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
76680>>>>>>>>>>>>    Integer iStart iEnd
76680>>>>>>>>>>>>    String sRetval
76680>>>>>>>>>>>>
76680>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
76681>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
76682>>>>>>>>>>>>    If (iStart = 0) Begin
76684>>>>>>>>>>>>        Function_Return ""
76685>>>>>>>>>>>>    End
76685>>>>>>>>>>>>>
76685>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
76686>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
76687>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
76689>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
76690>>>>>>>>>>>>    End
76690>>>>>>>>>>>>>
76690>>>>>>>>>>>>    Else Begin
76691>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
76692>>>>>>>>>>>>    End
76692>>>>>>>>>>>>>
76692>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
76694>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
76695>>>>>>>>>>>>        Decrement iEnd
76696>>>>>>>>>>>>    End
76696>>>>>>>>>>>>>
76696>>>>>>>>>>>>    If (iEnd <> 0) Begin
76698>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
76699>>>>>>>>>>>>    End
76699>>>>>>>>>>>>>
76699>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
76700>>>>>>>>>>>>
76700>>>>>>>>>>>>    Function_Return (Trim(sRetval))
76701>>>>>>>>>>>>End_Function
76702>>>>>>>>>>>>
76702>>>>>>>>>>>>
76702>>>>>>>>>>>
76702>>>>>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
76702>>>>>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
76704>>>>>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
76706>>>>>>>>>>>            Function_Return (EQ)
76707>>>>>>>>>>>        End
76707>>>>>>>>>>>>
76707>>>>>>>>>>>        Function_Return (GT)
76708>>>>>>>>>>>    End_Function
76709>>>>>>>>>>>
76709>>>>>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
76709>>>>>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
76711>>>>>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
76714>>>>>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
76717>>>>>>>>>>>
76717>>>>>>>>>>>        Function_Return (EQ)
76718>>>>>>>>>>>    End_Function
76719>>>>>>>>>>>
76719>>>>>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
76721>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
76721>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
76722>>>>>>>>>>>        Integer iSize
76722>>>>>>>>>>>
76722>>>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
76723>>>>>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
76724>>>>>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
76725>>>>>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
76726>>>>>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
76727>>>>>>>>>>>
76727>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
76728>>>>>>>>>>>    End_Procedure
76729>>>>>>>>>>>
76729>>>>>>>>>>>    // Creates a struct array with all SQL keywords
76729>>>>>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
76729>>>>>>>>>>>    // have slightly different wording.
76729>>>>>>>>>>>    // If a new EN_dbTypexxx type is added; additions
76729>>>>>>>>>>>    // needs to be done for every keyword group below.
76729>>>>>>>>>>>    Procedure SetupSQLKeywordArray
76731>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
76731>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
76733>>>>>>>>>>>
76733>>>>>>>>>>>        // This should only be called once; but in case it is
76733>>>>>>>>>>>        // we delete the array first.
76733>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
76734>>>>>>>>>>>
76734>>>>>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
76734>>>>>>>>>>>        //
76734>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
76735>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
76736>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
76737>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
76738>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"
76739>>>>>>>>>>>
76739>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
76740>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
76741>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
76742>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
76743>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"
76744>>>>>>>>>>>
76744>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
76745>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
76746>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
76747>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
76748>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"
76749>>>>>>>>>>>
76749>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
76750>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
76751>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
76752>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
76753>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"
76754>>>>>>>>>>>
76754>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
76755>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
76756>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
76757>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
76758>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"
76759>>>>>>>>>>>
76759>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
76760>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
76761>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
76762>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
76763>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
76764>>>>>>>>>>>
76764>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
76765>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
76766>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
76767>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
76768>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
76769>>>>>>>>>>>
76769>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
76770>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
76771>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
76772>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
76773>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
76774>>>>>>>>>>>
76774>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
76775>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
76776>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
76777>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
76778>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
76779>>>>>>>>>>>
76779>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_DbTypeMSSQL   ""
76780>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeMySQL   "SQL_SAFE_UPDATES"
76781>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeOracle  ""
76782>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeDB2     ""
76783>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypePostgre ""
76784>>>>>>>>>>>
76784>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
76785>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
76786>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
76787>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
76788>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
76789>>>>>>>>>>>
76789>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
76790>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
76791>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
76792>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
76793>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
76794>>>>>>>>>>>
76794>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
76795>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
76796>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
76797>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
76798>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
76799>>>>>>>>>>>
76799>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
76800>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
76801>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
76802>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
76803>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
76804>>>>>>>>>>>
76804>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
76805>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
76806>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
76807>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
76808>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
76809>>>>>>>>>>>
76809>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
76810>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
76811>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
76812>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
76813>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
76814>>>>>>>>>>>
76814>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
76815>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
76816>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
76817>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
76818>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
76819>>>>>>>>>>>
76819>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
76820>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
76821>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
76822>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
76823>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
76824>>>>>>>>>>>
76824>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
76825>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
76826>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
76827>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
76828>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
76829>>>>>>>>>>>
76829>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
76830>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
76831>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
76832>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
76833>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
76834>>>>>>>>>>>
76834>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
76835>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
76836>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
76837>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
76838>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
76839>>>>>>>>>>>
76839>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
76840>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
76841>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
76842>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
76843>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
76844>>>>>>>>>>>
76844>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
76845>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
76846>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
76847>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
76848>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
76849>>>>>>>>>>>
76849>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
76850>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
76851>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
76852>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
76853>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
76854>>>>>>>>>>>
76854>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
76855>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
76856>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
76857>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
76858>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
76859>>>>>>>>>>>
76859>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
76860>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
76861>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
76862>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
76863>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
76864>>>>>>>>>>>
76864>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
76865>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
76866>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
76867>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
76868>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
76869>>>>>>>>>>>
76869>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
76870>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
76871>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
76872>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
76873>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
76874>>>>>>>>>>>
76874>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
76875>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
76876>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
76877>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
76878>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
76879>>>>>>>>>>>
76879>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
76880>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
76881>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
76882>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
76883>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
76884>>>>>>>>>>>
76884>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
76885>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
76886>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
76887>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
76888>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
76889>>>>>>>>>>>
76889>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
76890>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
76891>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
76892>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
76893>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
76894>>>>>>>>>>>
76894>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
76895>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
76896>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
76897>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
76898>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
76899>>>>>>>>>>>
76899>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
76900>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
76901>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
76902>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
76903>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
76904>>>>>>>>>>>
76904>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
76905>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
76906>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
76907>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
76908>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
76909>>>>>>>>>>>
76909>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
76910>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
76911>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
76912>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
76913>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
76914>>>>>>>>>>>
76914>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
76915>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
76916>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
76917>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
76918>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
76919>>>>>>>>>>>
76919>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
76920>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
76921>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
76922>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
76923>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
76924>>>>>>>>>>>
76924>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
76925>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
76926>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
76927>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
76928>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
76929>>>>>>>>>>>
76929>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
76930>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
76931>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
76932>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
76933>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
76934>>>>>>>>>>>
76934>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
76935>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
76936>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
76937>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
76938>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
76939>>>>>>>>>>>
76939>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
76940>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
76941>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
76942>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
76943>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
76944>>>>>>>>>>>
76944>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
76945>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
76946>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
76947>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
76948>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
76949>>>>>>>>>>>
76949>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMSSQL   "DESCRIPTION"
76950>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMySQL   "DESCRIPTION"
76951>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeOracle  "DESCRIPTION"
76952>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeDB2     "DESCRIPTION"
76953>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypePostgre "DESCRIPTION"
76954>>>>>>>>>>>
76954>>>>>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
76954>>>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
76955>>>>>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
76956>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
76957>>>>>>>>>>>
76957>>>>>>>>>>>    End_Procedure
76958>>>>>>>>>>>
76958>>>>>>>>>>>End_Class
76959>>>>>>>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
76959>>>>>>>>>>>//****************************************************************************
76959>>>>>>>>>>>// $Module type: Class
76959>>>>>>>>>>>// $Module name: cSQLConnectionHandler.pkg
76959>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
76959>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76959>>>>>>>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
76959>>>>>>>>>>>//
76959>>>>>>>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
76959>>>>>>>>>>>//
76959>>>>>>>>>>>// $Rev History:
76959>>>>>>>>>>>//    2015-08-11  Module header created
76959>>>>>>>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
76959>>>>>>>>>>>//                Added a new structure for passing connection data back & forth.
76959>>>>>>>>>>>//                Added better error handling.
76959>>>>>>>>>>>//                Added a decompose message for the connection string.
76959>>>>>>>>>>>//    2017-01-09  Added support for Mertech drivers
76959>>>>>>>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
76959>>>>>>>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
76959>>>>>>>>>>>//    2017-02-12  Reworked the whole connection property interface.
76959>>>>>>>>>>>//                Now there is one struct property that is the at cencter of a connection.
76959>>>>>>>>>>>//    2023-11-06 *** REMOVED ALL SUPPORT FOR MERTECH DRIVERS ***
76959>>>>>>>>>>>//****************************************************************************
76959>>>>>>>>>>>Use cli.pkg
76959>>>>>>>>>>>Use MSSqldrv.pkg
76959>>>>>>>>>>>Use db2_drv.pkg
76959>>>>>>>>>>>Use odbc_drv.pkg
76959>>>>>>>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
76959>>>>>>>>>>>>>//****************************************************************************
76959>>>>>>>>>>>>>// $Module type: Class
76959>>>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
76959>>>>>>>>>>>>>//
76959>>>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
76959>>>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
76959>>>>>>>>>>>>>// E-mail      : support@rdctools.com
76959>>>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76959>>>>>>>>>>>>>//
76959>>>>>>>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
76959>>>>>>>>>>>>>//
76959>>>>>>>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
76959>>>>>>>>>>>>>//               properties of that object.
76959>>>>>>>>>>>>>//
76959>>>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
76959>>>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
76959>>>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
76959>>>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
76959>>>>>>>>>>>>>// in the help folder for more details.
76959>>>>>>>>>>>>>//
76959>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
76959>>>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
76959>>>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
76959>>>>>>>>>>>>>>>
76959>>>>>>>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
76960>>>>>>>>>>>>>>>    Procedure Construct_Object
76962>>>>>>>>>>>>>>>        Forward Send Construct_Object
76964>>>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
76965>>>>>>>>>>>>>>>    End_Procedure
76966>>>>>>>>>>>>>>>
76966>>>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
76968>>>>>>>>>>>>>>>        String sRetval
76968>>>>>>>>>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
76970>>>>>>>>>>>>>>>            Move CS_SQLIniFileDSNKeyword to sRetval    
76971>>>>>>>>>>>>>>>        End                                        
76971>>>>>>>>>>>>>>>>
76971>>>>>>>>>>>>>>>        Else Begin
76972>>>>>>>>>>>>>>>            Move CS_SQLIniDSNKeyword to sRetval
76973>>>>>>>>>>>>>>>        End
76973>>>>>>>>>>>>>>>>
76973>>>>>>>>>>>>>>>            
76973>>>>>>>>>>>>>>>        Function_Return sRetval
76974>>>>>>>>>>>>>>>    End_Function
76975>>>>>>>>>>>>>>>
76975>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
76977>>>>>>>>>>>>>>>        String sConnect sServerKeyWord sDriverID
76977>>>>>>>>>>>>>>>        Integer iClientVersion
76977>>>>>>>>>>>>>>>        
76977>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
76978>>>>>>>>>>>>>>>        Get ServerKeyword sServer to sServerKeyWord
76979>>>>>>>>>>>>>>>        Move (sConnect + sServerKeyWord + "=" + sServer) to sConnect
76980>>>>>>>>>>>>>>>        If (sServerKeyWord = CS_SQLIniDSNKeyword or sServerKeyWord = CS_SQLIniFileDSNKeyword) Begin
76982>>>>>>>>>>>>>>>            Move "" to sDatabase
76983>>>>>>>>>>>>>>>        End
76983>>>>>>>>>>>>>>>>
76983>>>>>>>>>>>>>>>        
76983>>>>>>>>>>>>>>>        If (sDatabase <> "") Begin
76985>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
76986>>>>>>>>>>>>>>>        End
76986>>>>>>>>>>>>>>>>
76986>>>>>>>>>>>>>>>        If (bTrusted = True) Begin
76988>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
76989>>>>>>>>>>>>>>>        End
76989>>>>>>>>>>>>>>>>
76989>>>>>>>>>>>>>>>        Else Begin
76990>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniUIDKeyword + "=" + sUserID + ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
76991>>>>>>>>>>>>>>>        End
76991>>>>>>>>>>>>>>>>
76991>>>>>>>>>>>>>>>        
76991>>>>>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
76993>>>>>>>>>>>>>>>            Get SQLClientVersionInteger MSSQLDRV_ID to iClientVersion
76994>>>>>>>>>>>>>>>            If (iClientVersion >= 18) Begin
76996>>>>>>>>>>>>>>>                Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
76997>>>>>>>>>>>>>>>                Move (Replaces(" ", sConnect, "")) to sConnect
76998>>>>>>>>>>>>>>>            End
76998>>>>>>>>>>>>>>>>
76998>>>>>>>>>>>>>>>        End
76998>>>>>>>>>>>>>>>>
76998>>>>>>>>>>>>>>>        
76998>>>>>>>>>>>>>>>        Function_Return sConnect
76999>>>>>>>>>>>>>>>    End_Function
77000>>>>>>>>>>>>>>>
77000>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77002>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77002>>>>>>>>>>>>>>>        String sDriverID
77002>>>>>>>>>>>>>>>
77002>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77003>>>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
77005>>>>>>>>>>>>>>>            Function_Return True
77006>>>>>>>>>>>>>>>        End
77006>>>>>>>>>>>>>>>>
77006>>>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
77007>>>>>>>>>>>>>>>        If (bTrusted = False and sDatabase <> "") Begin
77009>>>>>>>>>>>>>>>            Move (SFormat("SERVER=%1;DATABASE=%2", sServer, sDatabase)) to sServer
77010>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
77012>>>>>>>>>>>>>>>        End
77012>>>>>>>>>>>>>>>>
77012>>>>>>>>>>>>>>>        Else Begin
77013>>>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
77015>>>>>>>>>>>>>>>        End
77015>>>>>>>>>>>>>>>>
77015>>>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
77016>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77017>>>>>>>>>>>>>>>    End_Function
77018>>>>>>>>>>>>>>>
77018>>>>>>>>>>>>>>>    Function SQLClientVersionInteger String sDriverID Returns Integer
77020>>>>>>>>>>>>>>>        Integer iNumberOfDrivers iCount iDriver iClientVersion
77020>>>>>>>>>>>>>>>        String sDriver
77020>>>>>>>>>>>>>>>        
77020>>>>>>>>>>>>>>>        Move 0 to iDriver
77021>>>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77024>>>>>>>>>>>>>>>        If (iNumberOfDrivers = 1) Begin
77026>>>>>>>>>>>>>>>            Load_Driver sDriverID
77027>>>>>>>>>>>>>>>            Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77030>>>>>>>>>>>>>>>        End
77030>>>>>>>>>>>>>>>>
77030>>>>>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
77036>>>>>>>>>>>>>>>>
77036>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sDriver
77039>>>>>>>>>>>>>>>            If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
77041>>>>>>>>>>>>>>>                Move iCount to iDriver
77042>>>>>>>>>>>>>>>                Move iNumberOfDrivers to iCount // We're done.
77043>>>>>>>>>>>>>>>            End
77043>>>>>>>>>>>>>>>>
77043>>>>>>>>>>>>>>>        Loop
77044>>>>>>>>>>>>>>>>
77044>>>>>>>>>>>>>>>    
77044>>>>>>>>>>>>>>>        // This info is (at current) only available for the MS SQL driver:
77044>>>>>>>>>>>>>>>        If (iDriver <> 0 and sDriverID = MSSQLDRV_ID) Begin
77046>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
77049>>>>>>>>>>>>>>>        End
77049>>>>>>>>>>>>>>>>
77049>>>>>>>>>>>>>>>        Function_Return iClientVersion
77050>>>>>>>>>>>>>>>    End_Function
77051>>>>>>>>>>>>>>>    
77051>>>>>>>>>>>>>>>End_Class
77052>>>>>>>>>>>>>>>
77052>>>>>>>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
77053>>>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
77055>>>>>>>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
77056>>>>>>>>>>>>>>>    End_Function
77057>>>>>>>>>>>>>>>
77057>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77059>>>>>>>>>>>>>>>        Integer iClientVersion
77059>>>>>>>>>>>>>>>        String sConnect
77059>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77059>>>>>>>>>>>>>>>        
77059>>>>>>>>>>>>>>>        Move (sConnect * "SERVER=" + sServer) to sConnect
77060>>>>>>>>>>>>>>>        If (sDatabase <> "") Begin
77062>>>>>>>>>>>>>>>            Move (sConnect * ";DATABASE=" + sDatabase) to sConnect
77063>>>>>>>>>>>>>>>        End
77063>>>>>>>>>>>>>>>>
77063>>>>>>>>>>>>>>>        If (bTrusted = True) Begin
77065>>>>>>>>>>>>>>>            Move (sConnect * ";TRUSTED_CONNECTION=Yes") to sConnect
77066>>>>>>>>>>>>>>>        End
77066>>>>>>>>>>>>>>>>
77066>>>>>>>>>>>>>>>        Else Begin
77067>>>>>>>>>>>>>>>            Move (sConnect * ";UID=" + sUserID * ";PWD=" + sPassword) to sConnect
77068>>>>>>>>>>>>>>>        End
77068>>>>>>>>>>>>>>>>
77068>>>>>>>>>>>>>>>
77068>>>>>>>>>>>>>>>        Get SQLClientVersionInteger MSSQLDRV_ID to iClientVersion
77069>>>>>>>>>>>>>>>        If (iClientVersion >= 18) Begin
77071>>>>>>>>>>>>>>>            Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
77072>>>>>>>>>>>>>>>            Move (Replaces(" ", sConnect, "")) to sConnect
77073>>>>>>>>>>>>>>>        End
77073>>>>>>>>>>>>>>>>
77073>>>>>>>>>>>>>>>        
77073>>>>>>>>>>>>>>>        Login sConnect "" "" MSSQLDRV_ID
77075>>>>>>>>>>>>>>>
77075>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77076>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77077>>>>>>>>>>>>>>>    End_Function
77078>>>>>>>>>>>>>>>
77078>>>>>>>>>>>>>>>    Function SQLClientVersionInteger String sDriverID Returns Integer
77080>>>>>>>>>>>>>>>        Integer iNumberOfDrivers iCount iDriver iClientVersion
77080>>>>>>>>>>>>>>>        String sDriver
77080>>>>>>>>>>>>>>>        
77080>>>>>>>>>>>>>>>        Move 0 to iDriver
77081>>>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77084>>>>>>>>>>>>>>>        If (iNumberOfDrivers = 1) Begin
77086>>>>>>>>>>>>>>>            Load_Driver sDriverID
77087>>>>>>>>>>>>>>>            Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77090>>>>>>>>>>>>>>>        End
77090>>>>>>>>>>>>>>>>
77090>>>>>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
77096>>>>>>>>>>>>>>>>
77096>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sDriver
77099>>>>>>>>>>>>>>>            If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
77101>>>>>>>>>>>>>>>                Move iCount to iDriver
77102>>>>>>>>>>>>>>>                Move iNumberOfDrivers to iCount // We're done.
77103>>>>>>>>>>>>>>>            End
77103>>>>>>>>>>>>>>>>
77103>>>>>>>>>>>>>>>        Loop
77104>>>>>>>>>>>>>>>>
77104>>>>>>>>>>>>>>>    
77104>>>>>>>>>>>>>>>        // This info is (at current) only available for the MS SQL driver:
77104>>>>>>>>>>>>>>>        If (iDriver <> 0 and sDriverID = MSSQLDRV_ID) Begin
77106>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
77109>>>>>>>>>>>>>>>        End
77109>>>>>>>>>>>>>>>>
77109>>>>>>>>>>>>>>>        Function_Return iClientVersion
77110>>>>>>>>>>>>>>>    End_Function
77111>>>>>>>>>>>>>>>    
77111>>>>>>>>>>>>>>>End_Class
77112>>>>>>>>>>>>>>>
77112>>>>>>>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
77113>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77115>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77115>>>>>>>>>>>>>>>        String sDriverID
77115>>>>>>>>>>>>>>>
77115>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77116>>>>>>>>>>>>>>>        Move (Trim(sDriverID)) to sDriverID
77117>>>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
77119>>>>>>>>>>>>>>>            Function_Return True
77120>>>>>>>>>>>>>>>        End
77120>>>>>>>>>>>>>>>>
77120>>>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
77121>>>>>>>>>>>>>>>        If (bTrusted = False) Begin
77123>>>>>>>>>>>>>>>            If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
77125>>>>>>>>>>>>>>>                Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sServer
77126>>>>>>>>>>>>>>>            End
77126>>>>>>>>>>>>>>>>
77126>>>>>>>>>>>>>>>            Else If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77129>>>>>>>>>>>>>>>                Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77130>>>>>>>>>>>>>>>            End
77130>>>>>>>>>>>>>>>>
77130>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
77132>>>>>>>>>>>>>>>        End
77132>>>>>>>>>>>>>>>>
77132>>>>>>>>>>>>>>>        Else Begin
77133>>>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
77135>>>>>>>>>>>>>>>        End
77135>>>>>>>>>>>>>>>>
77135>>>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
77136>>>>>>>>>>>>>>>
77136>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77137>>>>>>>>>>>>>>>    End_Function
77138>>>>>>>>>>>>>>>End_Class
77139>>>>>>>>>>>>>>>
77139>>>>>>>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
77140>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77142>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77142>>>>>>>>>>>>>>>        String sDriverID
77142>>>>>>>>>>>>>>>
77142>>>>>>>>>>>>>>>        Move False to Err
77143>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77144>>>>>>>>>>>>>>>        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77146>>>>>>>>>>>>>>>            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77147>>>>>>>>>>>>>>>        End
77147>>>>>>>>>>>>>>>>
77147>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
77149>>>>>>>>>>>>>>>
77149>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77150>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77151>>>>>>>>>>>>>>>    End_Function
77152>>>>>>>>>>>>>>>End_Class
77153>>>>>>>>>>>>>>>
77153>>>>>>>>>>>>>>>Class cDbUpdatePSQLDriver is a cDbUpdateGenericDatabaseDriver
77154>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77156>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77156>>>>>>>>>>>>>>>        String sDriverID
77156>>>>>>>>>>>>>>>
77156>>>>>>>>>>>>>>>        Move False to Err
77157>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77158>>>>>>>>>>>>>>>//        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77158>>>>>>>>>>>>>>>//            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77158>>>>>>>>>>>>>>>//        End
77158>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
77160>>>>>>>>>>>>>>>
77160>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77161>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77162>>>>>>>>>>>>>>>    End_Function
77163>>>>>>>>>>>>>>>End_Class
77164>>>>>>>>>>>>>>>
77164>>>>>>>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
77165>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77167>>>>>>>>>>>>>>>        Function_Return ""
77168>>>>>>>>>>>>>>>    End_Function
77169>>>>>>>>>>>>>>>End_Class
77170>>>>>>>>>>>>>>>
77170>>>>>>>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
77171>>>>>>>>>>>>>>>    Procedure Construct_Object
77173>>>>>>>>>>>>>>>        Forward Send Construct_Object
77175>>>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
77176>>>>>>>>>>>>>>>        Property Handle phoDriverSpecificObject
77177>>>>>>>>>>>>>>>    End_Procedure
77178>>>>>>>>>>>>>>>
77178>>>>>>>>>>>>>>>    Function CreateDriver Returns Handle
77180>>>>>>>>>>>>>>>        String sDriverID sObjectName
77180>>>>>>>>>>>>>>>        Handle hoDriver hcDriverClass
77180>>>>>>>>>>>>>>>
77180>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77181>>>>>>>>>>>>>>>        Case Begin
77181>>>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
77183>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
77184>>>>>>>>>>>>>>>                Move "oDbUpdateMSSQLDriver" to sObjectName
77185>>>>>>>>>>>>>>>                Case Break
77186>>>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
77189>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
77190>>>>>>>>>>>>>>>                Move "oDbUpdateODBCDriver" to sObjectName
77191>>>>>>>>>>>>>>>                Case Break
77192>>>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
77195>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
77196>>>>>>>>>>>>>>>                Move "oDbUpdateDB2Driver" to sObjectName
77197>>>>>>>>>>>>>>>                Case Break               
77198>>>>>>>>>>>>>>>            Case Else
77198>>>>>>>>>>>>>>>                // DATAFLEX_ID = Default driver
77198>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
77199>>>>>>>>>>>>>>>                Move "oDbUpdateDataFlexDriver" to sObjectName
77200>>>>>>>>>>>>>>>                Move DATAFLEX_ID to sDriverID
77201>>>>>>>>>>>>>>>        Case End
77201>>>>>>>>>>>>>>>
77201>>>>>>>>>>>>>>>        Get Create hcDriverClass to hoDriver
77202>>>>>>>>>>>>>>>        Set Name of hoDriver to sObjectName
77203>>>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
77204>>>>>>>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
77205>>>>>>>>>>>>>>>
77205>>>>>>>>>>>>>>>        Function_Return hoDriver
77206>>>>>>>>>>>>>>>    End_Function
77207>>>>>>>>>>>>>>>
77207>>>>>>>>>>>>>>>    Procedure DestroyDriver
77209>>>>>>>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
77211>>>>>>>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
77212>>>>>>>>>>>>>>>        End
77212>>>>>>>>>>>>>>>>
77212>>>>>>>>>>>>>>>    End_Procedure
77213>>>>>>>>>>>>>>>
77213>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77215>>>>>>>>>>>>>>>        String sConnect
77215>>>>>>>>>>>>>>>        Handle hoDriver
77215>>>>>>>>>>>>>>>
77215>>>>>>>>>>>>>>>        Get phoDriverSpecificObject to hoDriver
77216>>>>>>>>>>>>>>>        If (hoDriver = 0) Begin
77218>>>>>>>>>>>>>>>            Get CreateDriver to hoDriver
77219>>>>>>>>>>>>>>>        End
77219>>>>>>>>>>>>>>>>
77219>>>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
77220>>>>>>>>>>>>>>>        Send DestroyDriver
77221>>>>>>>>>>>>>>>        Function_Return sConnect
77222>>>>>>>>>>>>>>>    End_Function
77223>>>>>>>>>>>>>>>
77223>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77225>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77225>>>>>>>>>>>>>>>        Handle hoDriver
77225>>>>>>>>>>>>>>>
77225>>>>>>>>>>>>>>>        Get phoDriverSpecificObject to hoDriver
77226>>>>>>>>>>>>>>>        If (hoDriver = 0) Begin
77228>>>>>>>>>>>>>>>            Get CreateDriver to hoDriver
77229>>>>>>>>>>>>>>>        End
77229>>>>>>>>>>>>>>>>
77229>>>>>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
77230>>>>>>>>>>>>>>>        Send DestroyDriver
77231>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77232>>>>>>>>>>>>>>>    End_Function
77233>>>>>>>>>>>>>>>
77233>>>>>>>>>>>>>>>End_Class
77234>>>>>>>>>>>>>
77234>>>>>>>>>>>>>    Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cLoginEncryption.pkg)
77234>>>>>>>>>>>>>>>Use cCryptographerEx.pkg
77234>>>>>>>>>>>>>>>
77234>>>>>>>>>>>>>>>Class cLoginEncryption is a cObject
77235>>>>>>>>>>>>>>>    
77235>>>>>>>>>>>>>>>    Procedure Construct_Object
77237>>>>>>>>>>>>>>>        Forward Send Construct_Object
77239>>>>>>>>>>>>>>>        // this must be set to a multi (40ish) character random key
77239>>>>>>>>>>>>>>>        Property String psEncryptPassword ""
77240>>>>>>>>>>>>>>>        
77240>>>>>>>>>>>>>>>        Object oDataCrypter is a cCryptographerEx
77242>>>>>>>>>>>>>>>            Set piHash to CALG_SHA_256
77243>>>>>>>>>>>>>>>            Set piCipher to CALG_AES_256
77244>>>>>>>>>>>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
77245>>>>>>>>>>>>>>>            Set piProvider to PROV_RSA_AES
77246>>>>>>>>>>>>>>>        End_Object
77247>>>>>>>>>>>>>>>    End_Procedure
77248>>>>>>>>>>>>>>>    
77248>>>>>>>>>>>>>>>    // This can be augmented to return a password encryption key using any
77248>>>>>>>>>>>>>>>    // hidden mechanism desired.
77248>>>>>>>>>>>>>>>    Function GetEncryptionPassword Returns String
77250>>>>>>>>>>>>>>>        String sPassword
77250>>>>>>>>>>>>>>>        Get psEncryptPassword to sPassword
77251>>>>>>>>>>>>>>>        Function_Return sPassword
77252>>>>>>>>>>>>>>>    End_Function
77253>>>>>>>>>>>>>>>    
77253>>>>>>>>>>>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
77253>>>>>>>>>>>>>>>    //
77253>>>>>>>>>>>>>>>    // Params:
77253>>>>>>>>>>>>>>>    //   sPlainText     String to encrypt.
77253>>>>>>>>>>>>>>>    // Returns:
77253>>>>>>>>>>>>>>>    //   Base64 encoded hash.
77253>>>>>>>>>>>>>>>    Function EncryptPassword String sPlainText Returns String
77255>>>>>>>>>>>>>>>        String sEncryptPassword sBase64
77255>>>>>>>>>>>>>>>        UChar[] ucBinary
77256>>>>>>>>>>>>>>>        Pointer pBase64
77256>>>>>>>>>>>>>>>        Integer iVoid
77256>>>>>>>>>>>>>>>        
77256>>>>>>>>>>>>>>>        //  Encrypt Key
77256>>>>>>>>>>>>>>>        Get GetEncryptionPassword to sEncryptPassword
77257>>>>>>>>>>>>>>>        If (sEncryptPassword = "") Begin
77259>>>>>>>>>>>>>>>            Error DFERR_PROGRAM "No encryption password set"
77260>>>>>>>>>>>>>>>>
77260>>>>>>>>>>>>>>>        End
77260>>>>>>>>>>>>>>>>
77260>>>>>>>>>>>>>>>        
77260>>>>>>>>>>>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
77261>>>>>>>>>>>>>>>        
77261>>>>>>>>>>>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
77263>>>>>>>>>>>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
77264>>>>>>>>>>>>>>>>
77264>>>>>>>>>>>>>>>            Function_Return ""
77265>>>>>>>>>>>>>>>        End
77265>>>>>>>>>>>>>>>>
77265>>>>>>>>>>>>>>>        
77265>>>>>>>>>>>>>>>        //  Encode binary hash to Base64
77265>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
77266>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sBase64
77267>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
77268>>>>>>>>>>>>>>>        
77268>>>>>>>>>>>>>>>        Function_Return sBase64
77269>>>>>>>>>>>>>>>    End_Function
77270>>>>>>>>>>>>>>>    
77270>>>>>>>>>>>>>>>    
77270>>>>>>>>>>>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
77270>>>>>>>>>>>>>>>    //
77270>>>>>>>>>>>>>>>    // Params:
77270>>>>>>>>>>>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
77270>>>>>>>>>>>>>>>    // Returns:
77270>>>>>>>>>>>>>>>    //   Readable plain text password
77270>>>>>>>>>>>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
77272>>>>>>>>>>>>>>>        String sEncryptPassword
77272>>>>>>>>>>>>>>>        UChar[] ucBinary ucPlain
77274>>>>>>>>>>>>>>>        Boolean bIsHex
77274>>>>>>>>>>>>>>>        Integer iLen iVoid
77274>>>>>>>>>>>>>>>        Pointer pBinary
77274>>>>>>>>>>>>>>>        
77274>>>>>>>>>>>>>>>        If (sBase64EncryptedPassword <> "") Begin
77276>>>>>>>>>>>>>>>            //  Decode from Base64
77276>>>>>>>>>>>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
77277>>>>>>>>>>>>>>>            
77277>>>>>>>>>>>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
77278>>>>>>>>>>>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
77279>>>>>>>>>>>>>>>                        
77279>>>>>>>>>>>>>>>            Move (Free(pBinary)) to iVoid
77280>>>>>>>>>>>>>>>            
77280>>>>>>>>>>>>>>>            //  Encrypted binary hash to string
77280>>>>>>>>>>>>>>>            Get GetEncryptionPassword to sEncryptPassword
77281>>>>>>>>>>>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
77282>>>>>>>>>>>>>>>        End
77282>>>>>>>>>>>>>>>>
77282>>>>>>>>>>>>>>>        
77282>>>>>>>>>>>>>>>        Function_Return (UCharArrayToString(ucPlain))
77283>>>>>>>>>>>>>>>    End_Function
77284>>>>>>>>>>>>>>>End_Class
77285>>>>>>>>>>>>>
77285>>>>>>>>>>>>>Class cSQLConnectionIniFile is a cIniFile
77286>>>>>>>>>>>>>    Procedure Construct_Object
77288>>>>>>>>>>>>>        Forward Send Construct_Object
77290>>>>>>>>>>>>>
77290>>>>>>>>>>>>>        Property String Private_psIniFilePath
77291>>>>>>>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
77292>>>>>>>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
77293>>>>>>>>>>>>>
77293>>>>>>>>>>>>>        Property Boolean pbDFConnId False
77294>>>>>>>>>>>>>
77294>>>>>>>>>>>>>        // *** You really want to change this value! ***
77294>>>>>>>>>>>>>        // It is used when encrypting/decrypting passwords.
77294>>>>>>>>>>>>>        Property String psHashString "zx!2139(LI0+?ips7433"
77295>>>>>>>>>>>>>
77295>>>>>>>>>>>>>    End_Procedure
77296>>>>>>>>>>>>>
77296>>>>>>>>>>>>>    Procedure End_Construct_Object
77298>>>>>>>>>>>>>        Forward Send End_Construct_Object
77300>>>>>>>>>>>>>    End_Procedure
77301>>>>>>>>>>>>>
77301>>>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
77303>>>>>>>>>>>>>        String sIniFile
77303>>>>>>>>>>>>>        Get vFolderFormat sPath to sPath
77304>>>>>>>>>>>>>        Set private_psIniFilePath to sPath
77305>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77306>>>>>>>>>>>>>        Set psFileName to (sPath + sIniFile)
77307>>>>>>>>>>>>>    End_Procedure
77308>>>>>>>>>>>>>
77308>>>>>>>>>>>>>    Function psIniFilePath Returns String
77310>>>>>>>>>>>>>        Function_Return (private_psIniFilePath(Self))
77311>>>>>>>>>>>>>    End_Function
77312>>>>>>>>>>>>>
77312>>>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
77314>>>>>>>>>>>>>        String sPath
77314>>>>>>>>>>>>>        Get psIniFilePath to sPath
77315>>>>>>>>>>>>>        Set psFileName to (sPath + sFileName)
77316>>>>>>>>>>>>>        Set private_psIniFileName to sFileName
77317>>>>>>>>>>>>>    End_Procedure
77318>>>>>>>>>>>>>
77318>>>>>>>>>>>>>    Function psIniFileName Returns String
77320>>>>>>>>>>>>>        Function_Return (private_psIniFileName(Self))
77321>>>>>>>>>>>>>    End_Function
77322>>>>>>>>>>>>>
77322>>>>>>>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
77322>>>>>>>>>>>>>    // Sets a value in the program's ini file (write)
77322>>>>>>>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
77322>>>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
77324>>>>>>>>>>>>>        String sIniFile sPath
77324>>>>>>>>>>>>>
77324>>>>>>>>>>>>>        Get psIniFilePath to sPath
77325>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77326>>>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
77327>>>>>>>>>>>>>        Set psFileName to sIniFile
77328>>>>>>>>>>>>>        Send WriteString sSection sValueName sValue
77329>>>>>>>>>>>>>    End_Procedure
77330>>>>>>>>>>>>>
77330>>>>>>>>>>>>>    // Get a value from program's ini-file (read)
77330>>>>>>>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
77330>>>>>>>>>>>>>    // Returns the value
77330>>>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
77332>>>>>>>>>>>>>        String sValue sIniFile sPath
77332>>>>>>>>>>>>>
77332>>>>>>>>>>>>>        Get psIniFilePath to sPath
77333>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77334>>>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
77335>>>>>>>>>>>>>        Set psFileName to sIniFile
77336>>>>>>>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
77337>>>>>>>>>>>>>
77337>>>>>>>>>>>>>        Function_Return sValue
77338>>>>>>>>>>>>>    End_Function
77339>>>>>>>>>>>>>
77339>>>>>>>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
77339>>>>>>>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
77341>>>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
77344>>>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
77347>>>>>>>>>>>>>
77347>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
77350>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
77353>>>>>>>>>>>>>
77353>>>>>>>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
77356>>>>>>>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
77359>>>>>>>>>>>>>
77359>>>>>>>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
77362>>>>>>>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
77365>>>>>>>>>>>>>
77365>>>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
77368>>>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
77371>>>>>>>>>>>>>
77371>>>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
77374>>>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
77377>>>>>>>>>>>>>
77377>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
77380>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
77383>>>>>>>>>>>>>
77383>>>>>>>>>>>>>        Function_Return (EQ)
77384>>>>>>>>>>>>>    End_Function
77385>>>>>>>>>>>>>
77385>>>>>>>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
77387>>>>>>>>>>>>>        Handle hoSections
77387>>>>>>>>>>>>>        Integer iItems
77387>>>>>>>>>>>>>
77387>>>>>>>>>>>>>        Send ReadSections hoSections
77388>>>>>>>>>>>>>        Move (Item_Count(hoSections)) to iItems
77389>>>>>>>>>>>>>        Function_Return iItems
77390>>>>>>>>>>>>>    End_Function
77391>>>>>>>>>>>>>
77391>>>>>>>>>>>>>    // The normal connection string looks something like this;
77391>>>>>>>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
77391>>>>>>>>>>>>>    // ...but the full connection string looks like this;
77391>>>>>>>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
77391>>>>>>>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
77391>>>>>>>>>>>>>//        String sSection
77391>>>>>>>>>>>>>//        Integer iCount
77391>>>>>>>>>>>>>//
77391>>>>>>>>>>>>>//        Move False to Err
77391>>>>>>>>>>>>>//        Get psIniSectionName to sSection
77391>>>>>>>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
77391>>>>>>>>>>>>>//        Increment iCount
77391>>>>>>>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
77391>>>>>>>>>>>>>//
77391>>>>>>>>>>>>>//        Function_Return (Err = False)
77391>>>>>>>>>>>>>//    End_Function
77391>>>>>>>>>>>>>
77391>>>>>>>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
77393>>>>>>>>>>>>>        Integer iCount
77393>>>>>>>>>>>>>        Boolean bExists
77393>>>>>>>>>>>>>        String sSection
77393>>>>>>>>>>>>>
77393>>>>>>>>>>>>>        Move False to Err
77394>>>>>>>>>>>>>        Move 1 to iCount
77395>>>>>>>>>>>>>        Get psIniSectionName to sSection
77396>>>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77397>>>>>>>>>>>>>        While (bExists = True)
77401>>>>>>>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
77402>>>>>>>>>>>>>            Increment iCount
77403>>>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77404>>>>>>>>>>>>>        Loop
77405>>>>>>>>>>>>>>
77405>>>>>>>>>>>>>        Function_Return (Err = False)
77406>>>>>>>>>>>>>    End_Function
77407>>>>>>>>>>>>>
77407>>>>>>>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
77409>>>>>>>>>>>>>        Integer iCount
77409>>>>>>>>>>>>>        String sSection
77409>>>>>>>>>>>>>        Boolean bExists
77409>>>>>>>>>>>>>
77409>>>>>>>>>>>>>        Move False to Err
77410>>>>>>>>>>>>>        Move 1 to iCount
77411>>>>>>>>>>>>>        Get psIniSectionName to sSection
77412>>>>>>>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
77413>>>>>>>>>>>>>        While (bExists = True)
77417>>>>>>>>>>>>>            If (iCount = iItem) Begin
77419>>>>>>>>>>>>>                Send DeleteSection sSection
77420>>>>>>>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
77420>>>>>>>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
77421>>>>>>>>>>>>>            End
77421>>>>>>>>>>>>>>
77421>>>>>>>>>>>>>            Increment iCount
77422>>>>>>>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
77423>>>>>>>>>>>>>        Loop
77424>>>>>>>>>>>>>>
77424>>>>>>>>>>>>>
77424>>>>>>>>>>>>>        Function_Return (Err = False)
77425>>>>>>>>>>>>>    End_Function
77426>>>>>>>>>>>>>
77426>>>>>>>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
77426>>>>>>>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
77426>>>>>>>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
77428>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77428>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77429>>>>>>>>>>>>>        tSQLConnection   SQLConnection
77429>>>>>>>>>>>>>        tSQLConnection   SQLConnection
77429>>>>>>>>>>>>>        Integer iIndex
77429>>>>>>>>>>>>>
77429>>>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
77430>>>>>>>>>>>>>        If (iIndex = -1) Begin
77432>>>>>>>>>>>>>            Move True to SQLConnection.bError
77433>>>>>>>>>>>>>            Function_Return SQLConnection
77434>>>>>>>>>>>>>        End
77434>>>>>>>>>>>>>>
77434>>>>>>>>>>>>>
77434>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77435>>>>>>>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
77436>>>>>>>>>>>>>
77436>>>>>>>>>>>>>        Function_Return SQLConnection
77437>>>>>>>>>>>>>    End_Function
77438>>>>>>>>>>>>>
77438>>>>>>>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
77438>>>>>>>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
77440>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77440>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77441>>>>>>>>>>>>>        Integer iRetval iCount iSize
77441>>>>>>>>>>>>>        String sValue
77441>>>>>>>>>>>>>        Boolean bExists
77441>>>>>>>>>>>>>
77441>>>>>>>>>>>>>        Move -1 to iRetval
77442>>>>>>>>>>>>>
77442>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77443>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77444>>>>>>>>>>>>>        Decrement iSize
77445>>>>>>>>>>>>>        For iCount from 0 to iSize
77451>>>>>>>>>>>>>>
77451>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
77452>>>>>>>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
77453>>>>>>>>>>>>>            If (bExists) Begin
77455>>>>>>>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
77456>>>>>>>>>>>>>                Move iSize to iCount         // We're done!
77457>>>>>>>>>>>>>            End
77457>>>>>>>>>>>>>>
77457>>>>>>>>>>>>>        Loop
77458>>>>>>>>>>>>>>
77458>>>>>>>>>>>>>
77458>>>>>>>>>>>>>        Function_Return iRetval
77459>>>>>>>>>>>>>    End_Function
77460>>>>>>>>>>>>>
77460>>>>>>>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
77460>>>>>>>>>>>>>    // Used to check that ConnectionID's are unique.
77460>>>>>>>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
77462>>>>>>>>>>>>>        Integer iCount iSize iItems
77462>>>>>>>>>>>>>        String sValue
77462>>>>>>>>>>>>>        Boolean bExists
77462>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77462>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77463>>>>>>>>>>>>>
77463>>>>>>>>>>>>>        Move 0 to iItems
77464>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77465>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77466>>>>>>>>>>>>>        Decrement iSize
77467>>>>>>>>>>>>>        For iCount from 0 to iSize
77473>>>>>>>>>>>>>>
77473>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
77474>>>>>>>>>>>>>            Move (sValue = sConnectionID) to bExists
77475>>>>>>>>>>>>>            If (bExists) Begin
77477>>>>>>>>>>>>>                Increment iItems
77478>>>>>>>>>>>>>            End
77478>>>>>>>>>>>>>>
77478>>>>>>>>>>>>>        Loop
77479>>>>>>>>>>>>>>
77479>>>>>>>>>>>>>
77479>>>>>>>>>>>>>        Function_Return (iItems > 1)
77480>>>>>>>>>>>>>    End_Function
77481>>>>>>>>>>>>>
77481>>>>>>>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
77481>>>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
77483>>>>>>>>>>>>>        Boolean bOK
77483>>>>>>>>>>>>>        Integer iSize iCount
77483>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77483>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77484>>>>>>>>>>>>>        tSQLConnection SQLConnection
77484>>>>>>>>>>>>>        tSQLConnection SQLConnection
77484>>>>>>>>>>>>>        String sConnectionString
77484>>>>>>>>>>>>>
77484>>>>>>>>>>>>>        Move False to Err
77485>>>>>>>>>>>>>        Get psConnectionString to sConnectionString
77486>>>>>>>>>>>>>
77486>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77487>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77488>>>>>>>>>>>>>        Decrement iSize
77489>>>>>>>>>>>>>        // Set all current connection to inactive.
77489>>>>>>>>>>>>>        For iCount from 0 to iSize
77495>>>>>>>>>>>>>>
77495>>>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
77496>>>>>>>>>>>>>        Loop
77497>>>>>>>>>>>>>>
77497>>>>>>>>>>>>>
77497>>>>>>>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
77498>>>>>>>>>>>>>        Move True              to SQLConnection.bEnabled
77499>>>>>>>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
77500>>>>>>>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
77501>>>>>>>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
77502>>>>>>>>>>>>>
77502>>>>>>>>>>>>>        Function_Return (bOK = True)
77503>>>>>>>>>>>>>    End_Function
77504>>>>>>>>>>>>>
77504>>>>>>>>>>>>>    // Used for updating an existing connection with new data.
77504>>>>>>>>>>>>>    // Returns True if successful.
77504>>>>>>>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
77506>>>>>>>>>>>>>        Boolean bOK
77506>>>>>>>>>>>>>        Integer iItem iSize iCount
77506>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77506>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77507>>>>>>>>>>>>>
77507>>>>>>>>>>>>>        Move False to Err
77508>>>>>>>>>>>>>        Move -1 to iItem
77509>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77510>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77511>>>>>>>>>>>>>        Decrement iSize
77512>>>>>>>>>>>>>        // Set all current connection to inactive.
77512>>>>>>>>>>>>>        For iCount from 0 to iSize
77518>>>>>>>>>>>>>>
77518>>>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
77519>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
77521>>>>>>>>>>>>>                Move iCount to iItem
77522>>>>>>>>>>>>>            End
77522>>>>>>>>>>>>>>
77522>>>>>>>>>>>>>        Loop
77523>>>>>>>>>>>>>>
77523>>>>>>>>>>>>>
77523>>>>>>>>>>>>>        If (iItem <> -1) Begin
77525>>>>>>>>>>>>>            Move True to SQLConnection.bEnabled
77526>>>>>>>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
77527>>>>>>>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
77528>>>>>>>>>>>>>        End
77528>>>>>>>>>>>>>>
77528>>>>>>>>>>>>>
77528>>>>>>>>>>>>>        Function_Return (bOK = True)
77529>>>>>>>>>>>>>    End_Function
77530>>>>>>>>>>>>>
77530>>>>>>>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
77532>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77532>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77533>>>>>>>>>>>>>        String sSection sValue
77533>>>>>>>>>>>>>        Integer iCount
77533>>>>>>>>>>>>>        Boolean bExists
77533>>>>>>>>>>>>>
77533>>>>>>>>>>>>>        Get psIniSectionName to sSection
77534>>>>>>>>>>>>>        Get SectionExists sSection to bExists
77535>>>>>>>>>>>>>        If (bExists = False) Begin
77537>>>>>>>>>>>>>            Function_Return SQLConnectionsArray
77538>>>>>>>>>>>>>        End
77538>>>>>>>>>>>>>>
77538>>>>>>>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
77539>>>>>>>>>>>>>        If (bExists = True) Begin
77541>>>>>>>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
77542>>>>>>>>>>>>>>
77542>>>>>>>>>>>>>        End
77542>>>>>>>>>>>>>>
77542>>>>>>>>>>>>>
77542>>>>>>>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
77543>>>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77544>>>>>>>>>>>>>
77544>>>>>>>>>>>>>        While (bExists = True)                 
77548>>>>>>>>>>>>>            // 2018-07-14 Change to allow disabling all connections in test environment.
77548>>>>>>>>>>>>>            // We always put the enabled/active connection at the top
77548>>>>>>>>>>>>>//            Move (iCount = 1) to bEnabled
77548>>>>>>>>>>>>>//            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
77548>>>>>>>>>>>>>
77548>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
77549>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
77550>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword     ""        to sValue
77551>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", False, True))                                               to SQLConnectionsArray[iCount].bEnabled
77552>>>>>>>>>>>>>
77552>>>>>>>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
77552>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
77553>>>>>>>>>>>>>            If (sValue = "99") Begin
77555>>>>>>>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
77556>>>>>>>>>>>>>            End
77556>>>>>>>>>>>>>>
77556>>>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
77557>>>>>>>>>>>>>
77557>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
77558>>>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
77559>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
77561>>>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniFileDSNKeyword +"=") to SQLConnectionsArray[iCount].sServer
77562>>>>>>>>>>>>>            End
77562>>>>>>>>>>>>>>
77562>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
77564>>>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
77565>>>>>>>>>>>>>            End
77565>>>>>>>>>>>>>>
77565>>>>>>>>>>>>>
77565>>>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
77566>>>>>>>>>>>>>
77566>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
77567>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
77568>>>>>>>>>>>>>
77568>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
77569>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
77570>>>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
77572>>>>>>>>>>>>>                Get DecryptPassword sValue to sValue
77573>>>>>>>>>>>>>            End
77573>>>>>>>>>>>>>>
77573>>>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
77574>>>>>>>>>>>>>
77574>>>>>>>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
77574>>>>>>>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
77575>>>>>>>>>>>>>
77575>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
77576>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
77577>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
77578>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
77579>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to sValue
77580>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bSilentLogin
77581>>>>>>>>>>>>>
77581>>>>>>>>>>>>>            Increment iCount
77582>>>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77583>>>>>>>>>>>>>        Loop
77584>>>>>>>>>>>>>>
77584>>>>>>>>>>>>>
77584>>>>>>>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
77584>>>>>>>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
77586>>>>>>>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
77587>>>>>>>>>>>>>        End
77587>>>>>>>>>>>>>>
77587>>>>>>>>>>>>>
77587>>>>>>>>>>>>>        Function_Return SQLConnectionsArray
77588>>>>>>>>>>>>>    End_Function
77589>>>>>>>>>>>>>
77589>>>>>>>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
77591>>>>>>>>>>>>>        Integer iCount iSize
77591>>>>>>>>>>>>>        Boolean bOK
77591>>>>>>>>>>>>>        String sSection sValue
77591>>>>>>>>>>>>>
77591>>>>>>>>>>>>>        // First we need to _remove_ all current connections from the ini-file.
77591>>>>>>>>>>>>>        Move 0 to iCount
77592>>>>>>>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
77593>>>>>>>>>>>>>        If (bOK = False) Begin
77595>>>>>>>>>>>>>            Function_Return False
77596>>>>>>>>>>>>>        End
77596>>>>>>>>>>>>>>
77596>>>>>>>>>>>>>
77596>>>>>>>>>>>>>        Move False to Err
77597>>>>>>>>>>>>>        Get psIniSectionName to sSection
77598>>>>>>>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
77598>>>>>>>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
77599>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77600>>>>>>>>>>>>>        Decrement iSize
77601>>>>>>>>>>>>>
77601>>>>>>>>>>>>>        For iCount from 0 to iSize
77607>>>>>>>>>>>>>>
77607>>>>>>>>>>>>>            // DF 19 compatible settings:
77607>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
77608>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
77609>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDisabledKeyword       to (If(SQLConnectionsArray[iCount].bEnabled = 0, "Yes", "No"))
77610>>>>>>>>>>>>>            
77610>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
77611>>>>>>>>>>>>>
77611>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
77612>>>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
77614>>>>>>>>>>>>>                Get EncryptPassword sValue to sValue
77615>>>>>>>>>>>>>            End
77615>>>>>>>>>>>>>>
77615>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
77616>>>>>>>>>>>>>
77616>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
77618>>>>>>>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
77619>>>>>>>>>>>>>            End
77619>>>>>>>>>>>>>>
77619>>>>>>>>>>>>>
77619>>>>>>>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
77620>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
77621>>>>>>>>>>>>>
77621>>>>>>>>>>>>>            // The Database Update Framework extended settings:
77621>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
77622>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
77623>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
77624>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
77625>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
77626>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to (If(SQLConnectionsArray[iCount].bSilentLogin = 1, "Yes", "No"))
77627>>>>>>>>>>>>>        Loop
77628>>>>>>>>>>>>>>
77628>>>>>>>>>>>>>
77628>>>>>>>>>>>>>        Function_Return (bOK and Err = False)
77629>>>>>>>>>>>>>    End_Function
77630>>>>>>>>>>>>>
77630>>>>>>>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
77630>>>>>>>>>>>>>    //
77630>>>>>>>>>>>>>    // SQL utility function that returns a database type (string) constant
77630>>>>>>>>>>>>>    // corresponding to the passed iDbType.
77630>>>>>>>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
77632>>>>>>>>>>>>>        String sRetval
77632>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
77634>>>>>>>>>>>>>            Move CS_dbTypeMSSQL to sRetval
77635>>>>>>>>>>>>>        End
77635>>>>>>>>>>>>>>
77635>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
77637>>>>>>>>>>>>>            Move CS_dbTypeMySQL to sRetval
77638>>>>>>>>>>>>>        End
77638>>>>>>>>>>>>>>
77638>>>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
77640>>>>>>>>>>>>>            Move CS_dbTypeOracle to sRetval
77641>>>>>>>>>>>>>        End
77641>>>>>>>>>>>>>>
77641>>>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
77643>>>>>>>>>>>>>            Move CS_dbTypeDB2 to sRetval
77644>>>>>>>>>>>>>        End
77644>>>>>>>>>>>>>>
77644>>>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
77646>>>>>>>>>>>>>            Move CS_dbTypePostgre to sRetval
77647>>>>>>>>>>>>>        End
77647>>>>>>>>>>>>>>
77647>>>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
77649>>>>>>>>>>>>>            Move CS_DbTypePervasive to sRetval
77650>>>>>>>>>>>>>        End
77650>>>>>>>>>>>>>>
77650>>>>>>>>>>>>>        Function_Return sRetval
77651>>>>>>>>>>>>>    End_Function
77652>>>>>>>>>>>>>
77652>>>>>>>>>>>>>    // SQL utility function that returns a database type constant (integer)
77652>>>>>>>>>>>>>    // corresponding to the passed sDbType string constant.
77652>>>>>>>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
77654>>>>>>>>>>>>>        Integer iRetval
77654>>>>>>>>>>>>>        If (sDbType = CS_DbTypeDataFlex) Begin
77656>>>>>>>>>>>>>            Move EN_DbTypeDataFlex to iRetval
77657>>>>>>>>>>>>>        End
77657>>>>>>>>>>>>>>
77657>>>>>>>>>>>>>        If (sDbType = CS_dbTypeMSSQL) Begin
77659>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77660>>>>>>>>>>>>>        End
77660>>>>>>>>>>>>>>
77660>>>>>>>>>>>>>        If (sDbType = CS_dbTypeMySQL) Begin
77662>>>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
77663>>>>>>>>>>>>>        End
77663>>>>>>>>>>>>>>
77663>>>>>>>>>>>>>        If (sDbType = CS_dbTypeOracle) Begin
77665>>>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
77666>>>>>>>>>>>>>        End
77666>>>>>>>>>>>>>>
77666>>>>>>>>>>>>>        If (sDbType = CS_dbTypeDB2) Begin
77668>>>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
77669>>>>>>>>>>>>>        End
77669>>>>>>>>>>>>>>
77669>>>>>>>>>>>>>        If (sDbType = CS_dbTypePostgre) Begin
77671>>>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
77672>>>>>>>>>>>>>        End
77672>>>>>>>>>>>>>>
77672>>>>>>>>>>>>>        If (sDbType = CS_DbTypePervasive) Begin
77674>>>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
77675>>>>>>>>>>>>>        End
77675>>>>>>>>>>>>>>
77675>>>>>>>>>>>>>        Function_Return iRetval
77676>>>>>>>>>>>>>    End_Function
77677>>>>>>>>>>>>>
77677>>>>>>>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
77677>>>>>>>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
77677>>>>>>>>>>>>>    // the SQL Connection program's grid.
77677>>>>>>>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
77679>>>>>>>>>>>>>        String sRetval
77679>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
77681>>>>>>>>>>>>>            Move "EN_dbTypeMSSQL" to sRetval
77682>>>>>>>>>>>>>        End
77682>>>>>>>>>>>>>>
77682>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
77684>>>>>>>>>>>>>            Move "EN_dbTypeMySQL" to sRetval
77685>>>>>>>>>>>>>        End
77685>>>>>>>>>>>>>>
77685>>>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
77687>>>>>>>>>>>>>            Move "EN_dbTypeOracle" to sRetval
77688>>>>>>>>>>>>>        End
77688>>>>>>>>>>>>>>
77688>>>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
77690>>>>>>>>>>>>>            Move "EN_dbTypeDB2" to sRetval
77691>>>>>>>>>>>>>        End
77691>>>>>>>>>>>>>>
77691>>>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
77693>>>>>>>>>>>>>            Move "EN_dbTypePostgre" to sRetval
77694>>>>>>>>>>>>>        End
77694>>>>>>>>>>>>>>
77694>>>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
77696>>>>>>>>>>>>>            Move "EN_dbTypePervasive" to sRetval
77697>>>>>>>>>>>>>        End
77697>>>>>>>>>>>>>>
77697>>>>>>>>>>>>>        Function_Return sRetval
77698>>>>>>>>>>>>>    End_Function
77699>>>>>>>>>>>>>
77699>>>>>>>>>>>>>    // Pass a driver id and the function will return
77699>>>>>>>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
77699>>>>>>>>>>>>>    // quite work and always returns "MS SQL Server"
77699>>>>>>>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
77701>>>>>>>>>>>>>        Integer iRetval
77701>>>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
77703>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77704>>>>>>>>>>>>>        End
77704>>>>>>>>>>>>>>
77704>>>>>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
77706>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77707>>>>>>>>>>>>>        End
77707>>>>>>>>>>>>>>
77707>>>>>>>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
77709>>>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
77710>>>>>>>>>>>>>        End
77710>>>>>>>>>>>>>>
77710>>>>>>>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
77712>>>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
77713>>>>>>>>>>>>>        End
77713>>>>>>>>>>>>>>
77713>>>>>>>>>>>>>        Function_Return iRetval
77714>>>>>>>>>>>>>    End_Function
77715>>>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
77715>>>>>>>>>>>>>>
77715>>>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
77717>>>>>>>>>>>>>>    Integer iStart iEnd
77717>>>>>>>>>>>>>>    String sRetval
77717>>>>>>>>>>>>>>
77717>>>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
77718>>>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
77719>>>>>>>>>>>>>>    If (iStart = 0) Begin
77721>>>>>>>>>>>>>>        Function_Return ""
77722>>>>>>>>>>>>>>    End
77722>>>>>>>>>>>>>>>
77722>>>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
77723>>>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
77724>>>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
77726>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77727>>>>>>>>>>>>>>    End
77727>>>>>>>>>>>>>>>
77727>>>>>>>>>>>>>>    Else Begin
77728>>>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
77729>>>>>>>>>>>>>>    End
77729>>>>>>>>>>>>>>>
77729>>>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
77731>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77732>>>>>>>>>>>>>>        Decrement iEnd
77733>>>>>>>>>>>>>>    End
77733>>>>>>>>>>>>>>>
77733>>>>>>>>>>>>>>    If (iEnd <> 0) Begin
77735>>>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
77736>>>>>>>>>>>>>>    End
77736>>>>>>>>>>>>>>>
77736>>>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
77737>>>>>>>>>>>>>>
77737>>>>>>>>>>>>>>    Function_Return (Trim(sRetval))
77738>>>>>>>>>>>>>>End_Function
77739>>>>>>>>>>>>>>
77739>>>>>>>>>>>>>>
77739>>>>>>>>>>>>>
77739>>>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77741>>>>>>>>>>>>>        String sConnect
77741>>>>>>>>>>>>>        Handle hoDriver
77741>>>>>>>>>>>>>
77741>>>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver 
77742>>>>>>>>>>>>>        Set Name of hoDriver to "oDbUpdateDatabaseDriver"
77743>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
77744>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
77745>>>>>>>>>>>>>        Send Destroy of hoDriver
77746>>>>>>>>>>>>>
77746>>>>>>>>>>>>>        Function_Return sConnect
77747>>>>>>>>>>>>>    End_Function
77748>>>>>>>>>>>>>
77748>>>>>>>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
77748>>>>>>>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
77750>>>>>>>>>>>>>        String sConnect
77750>>>>>>>>>>>>>
77750>>>>>>>>>>>>>        Case Begin
77750>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
77752>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
77753>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77755>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77756>>>>>>>>>>>>>                End
77756>>>>>>>>>>>>>>
77756>>>>>>>>>>>>>                Case Break
77757>>>>>>>>>>>>>
77757>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
77760>>>>>>>>>>>>>                If (Uppercase(sServer) contains ".DSN") Begin
77762>>>>>>>>>>>>>                    Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sConnect
77763>>>>>>>>>>>>>                End
77763>>>>>>>>>>>>>>
77763>>>>>>>>>>>>>                Else If (not(Uppercase(sServer) contains "DSN")) Begin
77766>>>>>>>>>>>>>                    Move (CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77767>>>>>>>>>>>>>                End
77767>>>>>>>>>>>>>>
77767>>>>>>>>>>>>>
77767>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77769>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77770>>>>>>>>>>>>>                End
77770>>>>>>>>>>>>>>
77770>>>>>>>>>>>>>                Case Break
77771>>>>>>>>>>>>>
77771>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
77774>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77775>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77777>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77778>>>>>>>>>>>>>                End
77778>>>>>>>>>>>>>>
77778>>>>>>>>>>>>>                Case Break
77779>>>>>>>>>>>>>
77779>>>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
77782>>>>>>>>>>>>>                Break
77783>>>>>>>>>>>>>
77783>>>>>>>>>>>>>            Case Else
77783>>>>>>>>>>>>>                Move "" to sConnect
77784>>>>>>>>>>>>>        Case End
77784>>>>>>>>>>>>>
77784>>>>>>>>>>>>>        Function_Return sConnect
77785>>>>>>>>>>>>>    End_Function
77786>>>>>>>>>>>>>
77786>>>>>>>>>>>>>    // Use Base64
77786>>>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
77788>>>>>>>>>>>>>        String sRetval
77788>>>>>>>>>>>>>        Handle hoLoginEncryption
77788>>>>>>>>>>>>>
77788>>>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
77789>>>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
77790>>>>>>>>>>>>>        Get EncryptPassword of hoLoginEncryption sPassword to sRetval
77791>>>>>>>>>>>>>        Send Destroy of hoLoginEncryption
77792>>>>>>>>>>>>>          
77792>>>>>>>>>>>>>        Function_Return sRetval
77793>>>>>>>>>>>>>    End_Function
77794>>>>>>>>>>>>>
77794>>>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
77796>>>>>>>>>>>>>        String sRetval
77796>>>>>>>>>>>>>        Handle hoLoginEncryption
77796>>>>>>>>>>>>>
77796>>>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
77797>>>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
77798>>>>>>>>>>>>>        Get DecryptPassword of hoLoginEncryption sPassword to sRetval
77799>>>>>>>>>>>>>        Send Destroy of hoLoginEncryption
77800>>>>>>>>>>>>>
77800>>>>>>>>>>>>>        Function_Return sRetval
77801>>>>>>>>>>>>>    End_Function
77802>>>>>>>>>>>>>
77802>>>>>>>>>>>>>    // Returns the full path of the Application (no trailing "\")
77802>>>>>>>>>>>>>    Function ApplicationPath Returns String
77804>>>>>>>>>>>>>        String sApplicationFileName sPath
77804>>>>>>>>>>>>>        Integer iNumChars iRetval
77804>>>>>>>>>>>>>
77804>>>>>>>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
77805>>>>>>>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
77806>>>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
77807>>>>>>>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
77808>>>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sPath
77809>>>>>>>>>>>>>
77809>>>>>>>>>>>>>        Function_Return sPath
77810>>>>>>>>>>>>>    End_Function
77811>>>>>>>>>>>>>
77811>>>>>>>>>>>>>    // Pass a filename including the extension. The return value
77811>>>>>>>>>>>>>    // will be the path of of the first found "sSearchFileName in the workspace.
77811>>>>>>>>>>>>>    // If not found in the workspace it will be search "globally" by the Get_File_Path command.
77811>>>>>>>>>>>>>    Function SearchLocallyThenGloballyForFile String sSearchFileName Returns String
77813>>>>>>>>>>>>>        Boolean bExists
77813>>>>>>>>>>>>>        Handle hoPaths hoIniFile
77813>>>>>>>>>>>>>        String[] asWorkSpaceFiles
77814>>>>>>>>>>>>>        String sProgramsPath sSection sFileName sRelativePath sRelativePaths sPath sDirSep sProgramsDir
77814>>>>>>>>>>>>>        Integer iSize iCount iPath iNoOfPaths iCountPath
77814>>>>>>>>>>>>>        
77814>>>>>>>>>>>>>        Get psIniFilePath to sProgramsPath
77815>>>>>>>>>>>>>        Get vFolderFormat sProgramsPath to sProgramsPath 
77816>>>>>>>>>>>>>        Move (Lowercase(sSearchFileName)) to sSearchFileName
77817>>>>>>>>>>>>>        Get vFilePathExists (sProgramsPath + sSearchFileName) to bExists   
77818>>>>>>>>>>>>>        If (bExists = True) Begin
77820>>>>>>>>>>>>>            Function_Return sProgramsPath
77821>>>>>>>>>>>>>        End                      
77821>>>>>>>>>>>>>>
77821>>>>>>>>>>>>>    
77821>>>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
77822>>>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
77824>>>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
77825>>>>>>>>>>>>>        End                                              
77825>>>>>>>>>>>>>>
77825>>>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sProgramsDir
77826>>>>>>>>>>>>>        
77826>>>>>>>>>>>>>        Move False to bExists
77827>>>>>>>>>>>>>        Get Create (RefClass(Array)) to hoPaths
77828>>>>>>>>>>>>>        Get WorkspaceIniFiles sProgramsPath to asWorkspaceFiles
77829>>>>>>>>>>>>>        Move (SizeOfArray(asWorkspaceFiles)) to iSize
77830>>>>>>>>>>>>>        Decrement iSize       
77831>>>>>>>>>>>>>        
77831>>>>>>>>>>>>>        For iCount from 0 to iSize
77837>>>>>>>>>>>>>>
77837>>>>>>>>>>>>>            Move asWorkspaceFiles[iCount] to sFileName
77838>>>>>>>>>>>>>            Get Create (Refclass(cIniFile)) to hoIniFile
77839>>>>>>>>>>>>>            Set psFileName of hoIniFile to sFileName
77840>>>>>>>>>>>>>            Send ReadSection of hoIniFile "Workspace" hoPaths
77841>>>>>>>>>>>>>            For iPath from 0 to (Item_Count(hoPaths) -1)
77847>>>>>>>>>>>>>>
77847>>>>>>>>>>>>>                Get Value of hoPaths iPath to sSection    
77848>>>>>>>>>>>>>                Get ReadString of hoIniFile "Workspace" sSection "" to sRelativePath 
77849>>>>>>>>>>>>>                // Check if there are more than one path specified;
77849>>>>>>>>>>>>>                Get CountOfPaths of (phoWorkspace(ghoApplication)) sRelativePath to iNoOfPaths
77850>>>>>>>>>>>>>                If (iNoOfPaths > 1) Begin         
77852>>>>>>>>>>>>>                    Move sRelativePath to sRelativePaths
77853>>>>>>>>>>>>>                    For iCountPath from 1 to iNoOfPaths
77859>>>>>>>>>>>>>>
77859>>>>>>>>>>>>>                        Get PathAtIndex of (phoWorkspace(ghoApplication)) sRelativePaths iCountPath to sRelativePath
77860>>>>>>>>>>>>>                        Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
77861>>>>>>>>>>>>>                        Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
77862>>>>>>>>>>>>>                        Get vFolderFormat sPath to sPath
77863>>>>>>>>>>>>>                        Get vFilePathExists (sPath + sSearchFileName) to bExists
77864>>>>>>>>>>>>>                        If (bExists = True) Begin
77866>>>>>>>>>>>>>                            Move iNoOfPaths to iCountPath
77867>>>>>>>>>>>>>                            Move (Item_Count(hoPaths)) to iPath // We're done.
77868>>>>>>>>>>>>>                            Move iSize to iCount
77869>>>>>>>>>>>>>                        End                                                    
77869>>>>>>>>>>>>>>
77869>>>>>>>>>>>>>                    Loop
77870>>>>>>>>>>>>>>
77870>>>>>>>>>>>>>                End
77870>>>>>>>>>>>>>>
77870>>>>>>>>>>>>>                Else Begin
77871>>>>>>>>>>>>>                    Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
77872>>>>>>>>>>>>>                    Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
77873>>>>>>>>>>>>>                    Get vFolderFormat sPath to sPath
77874>>>>>>>>>>>>>                    Get vFilePathExists (sPath + sSearchFileName) to bExists
77875>>>>>>>>>>>>>                    If (bExists = True) Begin
77877>>>>>>>>>>>>>                        Move (Item_Count(hoPaths)) to iPath // We're done.
77878>>>>>>>>>>>>>                        Move iSize to iCount
77879>>>>>>>>>>>>>                    End                                                    
77879>>>>>>>>>>>>>>
77879>>>>>>>>>>>>>                End
77879>>>>>>>>>>>>>>
77879>>>>>>>>>>>>>            Loop
77880>>>>>>>>>>>>>>
77880>>>>>>>>>>>>>            If (bExists = False) Begin
77882>>>>>>>>>>>>>                Move "" to sPath    
77883>>>>>>>>>>>>>            End
77883>>>>>>>>>>>>>>
77883>>>>>>>>>>>>>            Send Destroy of hoIniFile          
77884>>>>>>>>>>>>>        Loop        
77885>>>>>>>>>>>>>>
77885>>>>>>>>>>>>>        Send Destroy of hoPaths
77886>>>>>>>>>>>>>        
77886>>>>>>>>>>>>>        // Then not found in workspace, look for the file in DFSysPath;
77886>>>>>>>>>>>>>        If (sPath = "") Begin
77888>>>>>>>>>>>>>            Get_File_Path sSearchFileName to sFileName   
77889>>>>>>>>>>>>>            Get ParseFolderName sFileName to sPath
77890>>>>>>>>>>>>>        End                  
77890>>>>>>>>>>>>>>
77890>>>>>>>>>>>>>        
77890>>>>>>>>>>>>>        Function_Return sPath    
77891>>>>>>>>>>>>>    End_Function
77892>>>>>>>>>>>>>    
77892>>>>>>>>>>>>>    // Pass the path to the workspace Programs folder - returns a string array
77892>>>>>>>>>>>>>    // with one or more .ws file names.
77892>>>>>>>>>>>>>    // First checks if there is a .sws file - and if so reads the name of the
77892>>>>>>>>>>>>>    // workspace file (.ws) and returns it as a string array.
77892>>>>>>>>>>>>>    // If _no_ .sws file is found, enumerates the passed sProgramsPath variable
77892>>>>>>>>>>>>>    Function WorkspaceIniFiles String sProgramsPath Returns String[]
77894>>>>>>>>>>>>>        String[] asSWSFiles asWorkspaceFiles   
77896>>>>>>>>>>>>>        String sFile sHomePath sDirSep
77896>>>>>>>>>>>>>        Integer iCh iSize
77896>>>>>>>>>>>>>        Boolean bExists      
77896>>>>>>>>>>>>>        Handle hoIniFile 
77896>>>>>>>>>>>>>        
77896>>>>>>>>>>>>>        Move (ResizeArray(asSWSFiles, 0)) to asSWSFiles
77897>>>>>>>>>>>>>        Move (ResizeArray(asWorkspaceFiles, 0)) to asWorkspaceFiles
77898>>>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
77900>>>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
77901>>>>>>>>>>>>>        End                                              
77901>>>>>>>>>>>>>>
77901>>>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
77902>>>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sHomePath
77903>>>>>>>>>>>>>        Move (Replace(sHomePath, sProgramsPath, "")) to sHomePath
77904>>>>>>>>>>>>>        Get vFolderFormat sHomePath to sHomePath 
77905>>>>>>>>>>>>>        
77905>>>>>>>>>>>>>        // First check if theres an .sws file. If there is we will open it and
77905>>>>>>>>>>>>>        // read the name of the .ws file name.
77905>>>>>>>>>>>>>        File_Exist (sHomePath + "*.sws") bExists
77906>>>>>>>>>>>>>        If (bExists = True) Begin
77908>>>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sHomePath + "*.sws") to iCh
77909>>>>>>>>>>>>>            If (iCh < 0) Begin
77911>>>>>>>>>>>>>                Function_Return asSWSFiles
77912>>>>>>>>>>>>>            End                                 
77912>>>>>>>>>>>>>>
77912>>>>>>>>>>>>>            
77912>>>>>>>>>>>>>            Repeat
77912>>>>>>>>>>>>>>
77912>>>>>>>>>>>>>                Readln channel iCh sFile
77914>>>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
77916>>>>>>>>>>>>>                    Move sFile to asSWSFiles[SizeOfArray(asSWSFiles)]
77917>>>>>>>>>>>>>                End
77917>>>>>>>>>>>>>>
77917>>>>>>>>>>>>>            Until (SeqEof = True)
77919>>>>>>>>>>>>>            Send Seq_Close_Channel iCh    
77920>>>>>>>>>>>>>            
77920>>>>>>>>>>>>>            Move (SizeOfArray(asSWSFiles)) to iSize
77921>>>>>>>>>>>>>            If (iSize <> 0) Begin
77923>>>>>>>>>>>>>                Get Create (RefClass(cIniFile)) to hoIniFile  
77924>>>>>>>>>>>>>                // Use the file with that is last as it might have the DataFlex version in it,
77924>>>>>>>>>>>>>                // and thus is the latest one and it is more likely it is accurate (?)...
77924>>>>>>>>>>>>>                Move asSWSFiles[SizeOfArray(asSWSFiles) -1] to sFile
77925>>>>>>>>>>>>>                Set psFileName of hoIniFile to (sHomePath + sFile)
77926>>>>>>>>>>>>>                Get ReadString of hoIniFile "WorkspacePaths" "ConfigFile" "" to sFile
77927>>>>>>>>>>>>>                If (sFile <> "") Begin
77929>>>>>>>>>>>>>                    Move (Replace(".", sFile, sHomePath)) to sFile
77930>>>>>>>>>>>>>                    Move (Replace((sDirSep + String(sDirSep)), sFile, sDirSep)) to sFile
77931>>>>>>>>>>>>>                    File_Exist sFile bExists
77932>>>>>>>>>>>>>                    If (bExists = True) Begin
77934>>>>>>>>>>>>>                        Move sFile to asWorkspaceFiles[0] 
77935>>>>>>>>>>>>>                    End
77935>>>>>>>>>>>>>>
77935>>>>>>>>>>>>>                End
77935>>>>>>>>>>>>>>
77935>>>>>>>>>>>>>                Send Destroy of hoIniFile
77936>>>>>>>>>>>>>            End
77936>>>>>>>>>>>>>>
77936>>>>>>>>>>>>>        End
77936>>>>>>>>>>>>>>
77936>>>>>>>>>>>>>        
77936>>>>>>>>>>>>>        // If no .sws file exists, enumerate the .ws files from the Programs folder:    
77936>>>>>>>>>>>>>        If (SizeOfArray(asWorkspaceFiles) = 0) Begin
77938>>>>>>>>>>>>>            Get vFolderFormat sProgramsPath to sProgramsPath 
77939>>>>>>>>>>>>>            File_Exist (sProgramsPath + "*.ws") bExists
77940>>>>>>>>>>>>>            If (bExists = False) Begin
77942>>>>>>>>>>>>>                Function_Return asWorkspaceFiles
77943>>>>>>>>>>>>>            End
77943>>>>>>>>>>>>>>
77943>>>>>>>>>>>>>        
77943>>>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sProgramsPath + "*.ws") to iCh
77944>>>>>>>>>>>>>            If (iCh < 0) Begin
77946>>>>>>>>>>>>>                Function_Return asWorkspaceFiles
77947>>>>>>>>>>>>>            End                                 
77947>>>>>>>>>>>>>>
77947>>>>>>>>>>>>>            
77947>>>>>>>>>>>>>            Repeat
77947>>>>>>>>>>>>>>
77947>>>>>>>>>>>>>                Readln channel iCh sFile
77949>>>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
77951>>>>>>>>>>>>>                    Move sFile to asWorkspaceFiles[SizeOfArray(asWorkspaceFiles)]
77952>>>>>>>>>>>>>                End
77952>>>>>>>>>>>>>>
77952>>>>>>>>>>>>>            Until (SeqEof = True)
77954>>>>>>>>>>>>>            Send Seq_Close_Channel iCh
77955>>>>>>>>>>>>>        End
77955>>>>>>>>>>>>>>
77955>>>>>>>>>>>>>        
77955>>>>>>>>>>>>>        Function_Return asWorkspaceFiles
77956>>>>>>>>>>>>>    End_Function
77957>>>>>>>>>>>>>
77957>>>>>>>>>>>>>End_Class
77958>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
77958>>>>>>>>>>>Use vWin32fh.pkg
77958>>>>>>>>>>>
77958>>>>>>>>>>>// The cConnection class is the new SQL connections class for DF 19.
77958>>>>>>>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
77958>>>>>>>>>>>
77958>>>>>>>>>>>// We're making references to this object handle so we need it defined
77958>>>>>>>>>>>// here as well as for the cDbUpdateHandler class
77958>>>>>>>>>>>
77958>>>>>>>>>>>    Global_Variable Handle ghoSQLConnectionHandler
77958>>>>>>>>>>>    Move 0 to ghoSQLConnectionHandler
77959>>>>>>>>>>>
77959>>>>>>>>>>>Class cSQLConnectionHandler is a cObject
77960>>>>>>>>>>>
77960>>>>>>>>>>>    Procedure Construct_Object
77962>>>>>>>>>>>        Handle ho
77962>>>>>>>>>>>        Forward Send Construct_Object
77964>>>>>>>>>>>        Move Self to ghoSQLConnectionHandler
77965>>>>>>>>>>>
77965>>>>>>>>>>>        Property Handle phoSQLConnectionIniFile 
77966>>>>>>>>>>>        Get  Create (RefClass(cSQLConnectionIniFile)) to ho
77967>>>>>>>>>>>        Set Name of ho to "oSQLConnectionIniFile"
77968>>>>>>>>>>>        Set phoSQLConnectionIniFile to ho
77969>>>>>>>>>>>        
77969>>>>>>>>>>>
77969>>>>>>>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
77969>>>>>>>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
77969>>>>>>>>>>>        // methods to this class.
77969>>>>>>>>>>>        Property Boolean pbUseConnectionID True
77970>>>>>>>>>>>        Property Boolean pbToANSI          True
77971>>>>>>>>>>>        Property Boolean pbRecnum          True
77972>>>>>>>>>>>        Property Boolean pbCopyData        True
77973>>>>>>>>>>>        Property Boolean pbApiTableUpdateAuto    False
77974>>>>>>>>>>>        Property Boolean pbCompareDate_DateTime  False
77975>>>>>>>>>>>        Property Boolean pbCompareIndexAscending False
77976>>>>>>>>>>>        Property Boolean pbCompareIndexUppercase False
77977>>>>>>>>>>>
77977>>>>>>>>>>>        // Driver default value settings:
77977>>>>>>>>>>>        // Note: When the object is created the corresponding values
77977>>>>>>>>>>>        // from the driver .int files are read.
77977>>>>>>>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
77977>>>>>>>>>>>        Property String psDriverDefaultValueASCII    ""
77978>>>>>>>>>>>        Property String psDriverDefaultValueBinary   ""
77979>>>>>>>>>>>        Property String psDriverDefaultValueDate     ""
77980>>>>>>>>>>>        Property String psDriverDefaultValueDateTime ""
77981>>>>>>>>>>>        Property String psDriverDefaultValueNumeric  ""
77982>>>>>>>>>>>        Property String psDriverDefaultValueText     ""
77983>>>>>>>>>>>
77983>>>>>>>>>>>        // Driver "nullability" settings:
77983>>>>>>>>>>>        // Note: When the object is created the corresponding values
77983>>>>>>>>>>>        // from the driver .int files are read.
77983>>>>>>>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
77983>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
77984>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
77985>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableDate     False
77986>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
77987>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
77988>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableText     False
77989>>>>>>>>>>>
77989>>>>>>>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
77989>>>>>>>>>>>        //     It is private because the get/set version also updates the DAW
77989>>>>>>>>>>>        //     driver interfaces.
77989>>>>>>>>>>>        //     There are also procedure/function pairs to set/get individual data members
77989>>>>>>>>>>>        //     of the struct they are all routed throu this struct property.
77989>>>>>>>>>>>        Property tSQLConnection Private.pSQLConnection
77990>>>>>>>>>>>
77990>>>>>>>>>>>    End_Procedure
77991>>>>>>>>>>>
77991>>>>>>>>>>>    Procedure End_Construct_Object
77993>>>>>>>>>>>        tSQLConnection SQLConnection
77993>>>>>>>>>>>        tSQLConnection SQLConnection
77993>>>>>>>>>>>
77993>>>>>>>>>>>        Forward Send End_Construct_Object
77995>>>>>>>>>>>
77995>>>>>>>>>>>        // Now is the time to read and apply SQL connection settings.
77995>>>>>>>>>>>        Get SetupSQLConnection True True to SQLConnection
77996>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
77997>>>>>>>>>>>    End_Procedure
77998>>>>>>>>>>>
77998>>>>>>>>>>>    // *** Properties ***
77998>>>>>>>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
77998>>>>>>>>>>>    // private.pSQLConnection struct connection property. These "properties" are
77998>>>>>>>>>>>    // merely here for conveniance.
77998>>>>>>>>>>>    //
77998>>>>>>>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
77998>>>>>>>>>>>    // where we update data to/from the DAW driver interfaces and this framework.
77998>>>>>>>>>>>    // This struct property contains all the connection data.
77998>>>>>>>>>>>    //
77998>>>>>>>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
78000>>>>>>>>>>>        Boolean bOK
78000>>>>>>>>>>>
78000>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78001>>>>>>>>>>>
78001>>>>>>>>>>>        // When starting a program we might not have a connection id yet:
78001>>>>>>>>>>>        If (SQLConnection.sDriverID = DATAFLEX_ID) Begin
78003>>>>>>>>>>>//        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
78003>>>>>>>>>>>            Procedure_Return
78004>>>>>>>>>>>        End
78004>>>>>>>>>>>>
78004>>>>>>>>>>>
78004>>>>>>>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
78004>>>>>>>>>>>        // be logged in already and don't want to do it again.
78004>>>>>>>>>>>        If (SQLConnection.bDAWConnection = False) Begin
78006>>>>>>>>>>>            // After we have set the class property we need to tell the DAW
78006>>>>>>>>>>>            // driver interfaces about the change & make a new login.
78006>>>>>>>>>>>            Get SQLLogin SQLConnection to bOK
78007>>>>>>>>>>>            If (bOK = False) Begin
78009>>>>>>>>>>>                Error DFERR_PROGRAM "Login error."
78010>>>>>>>>>>>>
78010>>>>>>>>>>>            End
78010>>>>>>>>>>>>
78010>>>>>>>>>>>        End
78010>>>>>>>>>>>>
78010>>>>>>>>>>>
78010>>>>>>>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
78010>>>>>>>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
78011>>>>>>>>>>>
78011>>>>>>>>>>>    End_Procedure
78012>>>>>>>>>>>
78012>>>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
78012>>>>>>>>>>>    // attempt to load the driver.
78012>>>>>>>>>>>    // Returns true if the passed driver is SQL based.
78012>>>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
78014>>>>>>>>>>>        Boolean bOK
78014>>>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
78015>>>>>>>>>>>        Function_Return bOK
78016>>>>>>>>>>>    End_Function
78017>>>>>>>>>>>
78017>>>>>>>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
78017>>>>>>>>>>>    Procedure SetupDriverDefaults String sDriverID
78019>>>>>>>>>>>        String sAttributeValue sServer
78019>>>>>>>>>>>        Integer iDriverID
78019>>>>>>>>>>>        Boolean bNULL bSQLDriver
78019>>>>>>>>>>>        Handle hDatabase
78019>>>>>>>>>>>        
78019>>>>>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
78020>>>>>>>>>>>        If (bSQLDriver = False) Begin
78022>>>>>>>>>>>            Procedure_Return
78023>>>>>>>>>>>        End                                      
78023>>>>>>>>>>>>
78023>>>>>>>>>>>        
78023>>>>>>>>>>>        Get DriverIndex sDriverID to iDriverID  
78024>>>>>>>>>>>        
78024>>>>>>>>>>>        // ToDo: Testing!
78024>>>>>>>>>>>//        Get psServer of ghoDbUpdateFunctionLibrary to sServer
78024>>>>>>>>>>>//        Get SqlUtilDatabaseHandle of ghoDbUpdateFunctionLibrary sDriverID sServer to hDatabase
78024>>>>>>>>>>>//        Set_Attribute DF_DATABASE_IGNORE_WARNINGS of iDriverID hDatabase to True 
78024>>>>>>>>>>>
78024>>>>>>>>>>>        // Driver default values for various data types:
78024>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
78027>>>>>>>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
78028>>>>>>>>>>>
78028>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
78031>>>>>>>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
78032>>>>>>>>>>>
78032>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
78035>>>>>>>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
78036>>>>>>>>>>>
78036>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
78039>>>>>>>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
78040>>>>>>>>>>>
78040>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
78043>>>>>>>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
78044>>>>>>>>>>>
78044>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
78047>>>>>>>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
78048>>>>>>>>>>>
78048>>>>>>>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
78048>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
78051>>>>>>>>>>>        Set pbDriverDefaultNullableASCII to bNULL
78052>>>>>>>>>>>
78052>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
78055>>>>>>>>>>>        Set pbDriverDefaultNullableBinary to bNULL
78056>>>>>>>>>>>
78056>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
78059>>>>>>>>>>>        Set pbDriverDefaultNullableDate to bNULL
78060>>>>>>>>>>>
78060>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
78063>>>>>>>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
78064>>>>>>>>>>>
78064>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
78067>>>>>>>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
78068>>>>>>>>>>>
78068>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
78071>>>>>>>>>>>        Set pbDriverDefaultNullableText to bNULL
78072>>>>>>>>>>>
78072>>>>>>>>>>>    End_Procedure
78073>>>>>>>>>>>
78073>>>>>>>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
78075>>>>>>>>>>>        Boolean bOK bIsDaw
78075>>>>>>>>>>>        String sConnectionString
78075>>>>>>>>>>>        Handle hoErrorObj hoDriver hoIniFile
78075>>>>>>>>>>>        Integer iDriverID
78075>>>>>>>>>>>
78075>>>>>>>>>>>        Move False to bOK
78076>>>>>>>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
78077>>>>>>>>>>>
78077>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78078>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
78079>>>>>>>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
78080>>>>>>>>>>>        If (iDriverID = 0) Begin
78082>>>>>>>>>>>            Move hoErrorObj to Error_Object_Id
78083>>>>>>>>>>>            Function_Return False
78084>>>>>>>>>>>        End
78084>>>>>>>>>>>>
78084>>>>>>>>>>>
78084>>>>>>>>>>>        Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
78087>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
78088>>>>>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
78089>>>>>>>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
78090>>>>>>>>>>>        Send Destroy   of hoDriver
78091>>>>>>>>>>>
78091>>>>>>>>>>>        Function_Return bOK
78092>>>>>>>>>>>    End_Function
78093>>>>>>>>>>>
78093>>>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
78095>>>>>>>>>>>        tSQLConnection SQLConnection
78095>>>>>>>>>>>        tSQLConnection SQLConnection
78095>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78096>>>>>>>>>>>        Function_Return SQLConnection
78097>>>>>>>>>>>    End_Function
78098>>>>>>>>>>>
78098>>>>>>>>>>>    Procedure Set psConnectionID String sValue
78100>>>>>>>>>>>        tSQLConnection SQLConnection
78100>>>>>>>>>>>        tSQLConnection SQLConnection
78100>>>>>>>>>>>
78100>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78101>>>>>>>>>>>        If (SQLConnection.sConnectionID = "") Begin
78103>>>>>>>>>>>            Move sValue to SQLConnection.sConnectionID
78104>>>>>>>>>>>        End
78104>>>>>>>>>>>>
78104>>>>>>>>>>>
78104>>>>>>>>>>>        // Else we might want to change the current connection ID
78104>>>>>>>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
78107>>>>>>>>>>>            Move False to Err
78108>>>>>>>>>>>            Logout SQLConnection.sDriverID
78109>>>>>>>>>>>            // This will also make a login to the new server.
78109>>>>>>>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
78110>>>>>>>>>>>        End
78110>>>>>>>>>>>>
78110>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78111>>>>>>>>>>>    End_Procedure
78112>>>>>>>>>>>
78112>>>>>>>>>>>    Function psConnectionID Returns String
78114>>>>>>>>>>>        tSQLConnection SQLConnection
78114>>>>>>>>>>>        tSQLConnection SQLConnection
78114>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78115>>>>>>>>>>>        Function_Return SQLConnection.sConnectionID
78116>>>>>>>>>>>    End_Function
78117>>>>>>>>>>>
78117>>>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
78117>>>>>>>>>>>    //       the psDriverID *must* be the first property that is changed!
78117>>>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
78117>>>>>>>>>>>    //       for a connection string has the wrong format for that driver.
78117>>>>>>>>>>>    Procedure Set psDriverID String sValue
78119>>>>>>>>>>>        tSQLConnection SQLConnection
78119>>>>>>>>>>>        tSQLConnection SQLConnection
78119>>>>>>>>>>>        Get pSQLConnection to SQLConnection
78120>>>>>>>>>>>        Move sValue        to SQLConnection.sDriverID
78121>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78122>>>>>>>>>>>        If (sValue <> DATAFLEX_ID) Begin
78124>>>>>>>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78125>>>>>>>>>>>        End
78125>>>>>>>>>>>>
78125>>>>>>>>>>>    End_Procedure
78126>>>>>>>>>>>
78126>>>>>>>>>>>    Function psDriverID Returns String
78128>>>>>>>>>>>        tSQLConnection SQLConnection
78128>>>>>>>>>>>        tSQLConnection SQLConnection
78128>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78129>>>>>>>>>>>        If (SQLConnection.sDriverID = "") Begin
78131>>>>>>>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
78132>>>>>>>>>>>        End
78132>>>>>>>>>>>>
78132>>>>>>>>>>>        Function_Return SQLConnection.sDriverID
78133>>>>>>>>>>>    End_Function
78134>>>>>>>>>>>
78134>>>>>>>>>>>    Procedure Set psConnectionString String sValue
78136>>>>>>>>>>>        tSQLConnection SQLConnection
78136>>>>>>>>>>>        tSQLConnection SQLConnection
78136>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78137>>>>>>>>>>>        Move sValue        to SQLConnection.sConnectionString
78138>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78139>>>>>>>>>>>    End_Procedure
78140>>>>>>>>>>>
78140>>>>>>>>>>>    Function psConnectionString Returns String
78142>>>>>>>>>>>        tSQLConnection SQLConnection
78142>>>>>>>>>>>        tSQLConnection SQLConnection
78142>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78143>>>>>>>>>>>        Function_Return SQLConnection.sConnectionString
78144>>>>>>>>>>>    End_Function
78145>>>>>>>>>>>
78145>>>>>>>>>>>    Procedure Set psServer String sValue
78147>>>>>>>>>>>        tSQLConnection SQLConnection
78147>>>>>>>>>>>        tSQLConnection SQLConnection
78147>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78148>>>>>>>>>>>        Move sValue        to SQLConnection.sServer
78149>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78150>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78151>>>>>>>>>>>    End_Procedure
78152>>>>>>>>>>>
78152>>>>>>>>>>>    Function psServer Returns String
78154>>>>>>>>>>>        tSQLConnection SQLConnection
78154>>>>>>>>>>>        tSQLConnection SQLConnection
78154>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78155>>>>>>>>>>>        Function_Return SQLConnection.sServer
78156>>>>>>>>>>>    End_Function
78157>>>>>>>>>>>
78157>>>>>>>>>>>    Procedure Set psDatabase String sValue
78159>>>>>>>>>>>        tSQLConnection SQLConnection
78159>>>>>>>>>>>        tSQLConnection SQLConnection
78159>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78160>>>>>>>>>>>        Move sValue        to SQLConnection.sDatabase
78161>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78162>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78163>>>>>>>>>>>    End_Procedure
78164>>>>>>>>>>>
78164>>>>>>>>>>>    Function psDatabase Returns String
78166>>>>>>>>>>>        tSQLConnection SQLConnection
78166>>>>>>>>>>>        tSQLConnection SQLConnection
78166>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78167>>>>>>>>>>>        Function_Return SQLConnection.sDatabase
78168>>>>>>>>>>>    End_Function
78169>>>>>>>>>>>
78169>>>>>>>>>>>    Procedure Set psUserID String sValue
78171>>>>>>>>>>>        tSQLConnection SQLConnection
78171>>>>>>>>>>>        tSQLConnection SQLConnection
78171>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78172>>>>>>>>>>>        Move sValue        to SQLConnection.sUserID
78173>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78174>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78175>>>>>>>>>>>    End_Procedure
78176>>>>>>>>>>>
78176>>>>>>>>>>>    Function psUserID Returns String
78178>>>>>>>>>>>        tSQLConnection SQLConnection
78178>>>>>>>>>>>        tSQLConnection SQLConnection
78178>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78179>>>>>>>>>>>        Function_Return SQLConnection.sUserID
78180>>>>>>>>>>>    End_Function
78181>>>>>>>>>>>
78181>>>>>>>>>>>    // This is the uncrypted password
78181>>>>>>>>>>>    Procedure Set psPassword String sValue
78183>>>>>>>>>>>        tSQLConnection SQLConnection
78183>>>>>>>>>>>        tSQLConnection SQLConnection
78183>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78184>>>>>>>>>>>        Move sValue        to SQLConnection.sPassword
78185>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78186>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78187>>>>>>>>>>>    End_Procedure
78188>>>>>>>>>>>
78188>>>>>>>>>>>    Function psPassword Returns String
78190>>>>>>>>>>>        tSQLConnection SQLConnection
78190>>>>>>>>>>>        tSQLConnection SQLConnection
78190>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78191>>>>>>>>>>>        Function_Return SQLConnection.sPassword
78192>>>>>>>>>>>    End_Function
78193>>>>>>>>>>>
78193>>>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
78195>>>>>>>>>>>        tSQLConnection SQLConnection
78195>>>>>>>>>>>        tSQLConnection SQLConnection
78195>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78196>>>>>>>>>>>        Move bValue        to SQLConnection.bTrusted
78197>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78198>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78199>>>>>>>>>>>    End_Procedure
78200>>>>>>>>>>>
78200>>>>>>>>>>>    Function pbTrusted Returns Boolean
78202>>>>>>>>>>>        tSQLConnection SQLConnection
78202>>>>>>>>>>>        tSQLConnection SQLConnection
78202>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78203>>>>>>>>>>>        Function_Return SQLConnection.bTrusted
78204>>>>>>>>>>>    End_Function
78205>>>>>>>>>>>
78205>>>>>>>>>>>    // *** All of these properties are special to the Database Update Framework ***
78205>>>>>>>>>>>    //     Thus they are not propagated to the DAW classes and that is why
78205>>>>>>>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
78205>>>>>>>>>>>    //     the central pSQLConnection "hub".
78205>>>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
78207>>>>>>>>>>>        tSQLConnection SQLConnection
78207>>>>>>>>>>>        tSQLConnection SQLConnection
78207>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78208>>>>>>>>>>>        Move bValue to SQLConnection.bTrusted
78209>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78210>>>>>>>>>>>    End_Procedure
78211>>>>>>>>>>>
78211>>>>>>>>>>>    Function pbSilentLogin Returns Boolean
78213>>>>>>>>>>>        tSQLConnection SQLConnection
78213>>>>>>>>>>>        tSQLConnection SQLConnection
78213>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78214>>>>>>>>>>>        Function_Return SQLConnection.bSilentLogin
78215>>>>>>>>>>>    End_Function
78216>>>>>>>>>>>
78216>>>>>>>>>>>    Procedure Set piDbType Integer iValue
78218>>>>>>>>>>>        tSQLConnection SQLConnection
78218>>>>>>>>>>>        tSQLConnection SQLConnection
78218>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78219>>>>>>>>>>>        Move iValue to SQLConnection.iDbType
78220>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78221>>>>>>>>>>>    End_Procedure
78222>>>>>>>>>>>
78222>>>>>>>>>>>    Function piDbType Returns Integer
78224>>>>>>>>>>>        tSQLConnection SQLConnection
78224>>>>>>>>>>>        tSQLConnection SQLConnection
78224>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78225>>>>>>>>>>>        Function_Return SQLConnection.iDbType
78226>>>>>>>>>>>    End_Function
78227>>>>>>>>>>>
78227>>>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
78229>>>>>>>>>>>        tSQLConnection SQLConnection
78229>>>>>>>>>>>        tSQLConnection SQLConnection
78229>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78230>>>>>>>>>>>        Move sValue to SQLConnection.sBaseTableSpace
78231>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78232>>>>>>>>>>>    End_Procedure
78233>>>>>>>>>>>
78233>>>>>>>>>>>    Function psBaseTableSpace Returns String
78235>>>>>>>>>>>        tSQLConnection SQLConnection
78235>>>>>>>>>>>        tSQLConnection SQLConnection
78235>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78236>>>>>>>>>>>        Function_Return SQLConnection.sBaseTableSpace
78237>>>>>>>>>>>    End_Function
78238>>>>>>>>>>>
78238>>>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
78240>>>>>>>>>>>        tSQLConnection SQLConnection
78240>>>>>>>>>>>        tSQLConnection SQLConnection
78240>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78241>>>>>>>>>>>        Move sValue to SQLConnection.sIndexTableSpace
78242>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78243>>>>>>>>>>>    End_Procedure
78244>>>>>>>>>>>
78244>>>>>>>>>>>    Function psIndexTableSpace Returns String
78246>>>>>>>>>>>        tSQLConnection SQLConnection
78246>>>>>>>>>>>        tSQLConnection SQLConnection
78246>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78247>>>>>>>>>>>        Function_Return SQLConnection.sIndexTableSpace
78248>>>>>>>>>>>    End_Function
78249>>>>>>>>>>>
78249>>>>>>>>>>>    Procedure Set psLongTableSpace String sValue
78251>>>>>>>>>>>        tSQLConnection SQLConnection
78251>>>>>>>>>>>        tSQLConnection SQLConnection
78251>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78252>>>>>>>>>>>        Move sValue to SQLConnection.sLongTableSpace
78253>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78254>>>>>>>>>>>    End_Procedure
78255>>>>>>>>>>>
78255>>>>>>>>>>>    Function psLongTableSpace Returns String
78257>>>>>>>>>>>        tSQLConnection SQLConnection
78257>>>>>>>>>>>        tSQLConnection SQLConnection
78257>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78258>>>>>>>>>>>        Function_Return SQLConnection.sLongTableSpace
78259>>>>>>>>>>>    End_Function
78260>>>>>>>>>>>
78260>>>>>>>>>>>    Procedure Set psSchema String sValue
78262>>>>>>>>>>>        tSQLConnection SQLConnection
78262>>>>>>>>>>>        tSQLConnection SQLConnection
78262>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78263>>>>>>>>>>>        Move sValue to SQLConnection.sSchema
78264>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78265>>>>>>>>>>>    End_Procedure
78266>>>>>>>>>>>
78266>>>>>>>>>>>    Function psSchema Returns String
78268>>>>>>>>>>>        tSQLConnection SQLConnection
78268>>>>>>>>>>>        tSQLConnection SQLConnection
78268>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78269>>>>>>>>>>>        Function_Return SQLConnection.sSchema
78270>>>>>>>>>>>    End_Function
78271>>>>>>>>>>>
78271>>>>>>>>>>>    Procedure Set pbEnabled Boolean bValue
78273>>>>>>>>>>>        tSQLConnection SQLConnection
78273>>>>>>>>>>>        tSQLConnection SQLConnection
78273>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78274>>>>>>>>>>>        Move bValue to SQLConnection.bEnabled
78275>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78276>>>>>>>>>>>    End_Procedure
78277>>>>>>>>>>>
78277>>>>>>>>>>>    Function pbEnabled Returns Boolean
78279>>>>>>>>>>>        tSQLConnection SQLConnection
78279>>>>>>>>>>>        tSQLConnection SQLConnection
78279>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78280>>>>>>>>>>>        Function_Return SQLConnection.bEnabled
78281>>>>>>>>>>>    End_Function
78282>>>>>>>>>>>
78282>>>>>>>>>>>
78282>>>>>>>>>>>    // ************************************
78282>>>>>>>>>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
78284>>>>>>>>>>>        tSQLConnection SQLConnection
78284>>>>>>>>>>>        tSQLConnection SQLConnection
78284>>>>>>>>>>>
78284>>>>>>>>>>>        // If this object was created by the cDbUpdateHandler class we will
78284>>>>>>>>>>>        // deferr reading SQL connection values until later.
78284>>>>>>>>>>>        If (bReadDFConnSettings = True) Begin
78286>>>>>>>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
78286>>>>>>>>>>>            If (ghoConnection > 0) Begin
78288>>>>>>>>>>>                Get ReadcConnections to SQLConnection
78289>>>>>>>>>>>            End
78289>>>>>>>>>>>>
78289>>>>>>>>>>>
78289>>>>>>>>>>>            // In addition to the above; there might be other values set even if a cConnection
78289>>>>>>>>>>>            // object is used.
78289>>>>>>>>>>>            If (bReadSQLConnections = True) Begin
78291>>>>>>>>>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
78292>>>>>>>>>>>            End
78292>>>>>>>>>>>>
78292>>>>>>>>>>>        End
78292>>>>>>>>>>>>
78292>>>>>>>>>>>
78292>>>>>>>>>>>        Function_Return SQLConnection
78293>>>>>>>>>>>    End_Function
78294>>>>>>>>>>>
78294>>>>>>>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
78294>>>>>>>>>>>    Function ReadcConnections Returns tSQLConnection
78296>>>>>>>>>>>        tConnection Connection
78296>>>>>>>>>>>        tConnection Connection
78296>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78296>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78296>>>>>>>>>>>        Integer iRetval iDbType
78296>>>>>>>>>>>        Boolean bOK bConnected
78296>>>>>>>>>>>        String sConnectionID
78296>>>>>>>>>>>
78296>>>>>>>>>>>            tConnection[] Connections
78296>>>>>>>>>>>            tConnection[] Connections
78297>>>>>>>>>>>            // - If the DF 19 cConnection class has been used in the cApplication object
78297>>>>>>>>>>>            // - and there are multiple connection id's defined for the same driver. This is
78297>>>>>>>>>>>            //   because otherwise we can't possibly know which connection id to use... So
78297>>>>>>>>>>>            //   we then generate an error and abort the program...
78297>>>>>>>>>>>            Get IsSinglecConnection (&sConnectionID) to bOK
78298>>>>>>>>>>>            If (bOK = False) Begin
78300>>>>>>>>>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
78301>>>>>>>>>>>>
78301>>>>>>>>>>>                Abort
78302>>>>>>>>>>>>
78302>>>>>>>>>>>            End
78302>>>>>>>>>>>>
78302>>>>>>>>>>>            If (sConnectionID = "") Begin
78304>>>>>>>>>>>                Get ConnectionIDs of ghoConnection to Connections
78305>>>>>>>>>>>                If (SizeOfArray(Connections) > 0) Begin
78307>>>>>>>>>>>                    Move Connections[0].sId to sConnectionID
78308>>>>>>>>>>>                End
78308>>>>>>>>>>>>
78308>>>>>>>>>>>            End
78308>>>>>>>>>>>>
78308>>>>>>>>>>>
78308>>>>>>>>>>>            Move 0 to iRetval
78309>>>>>>>>>>>            // DAW DF19 connection info:
78309>>>>>>>>>>>            // We first check that the connection is OK:
78309>>>>>>>>>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
78310>>>>>>>>>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
78310>>>>>>>>>>>            If (iRetval = -1) Begin
78312>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78313>>>>>>>>>>>            End
78313>>>>>>>>>>>>
78313>>>>>>>>>>>
78313>>>>>>>>>>>            If (sConnectionID <> "") Begin
78315>>>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
78316>>>>>>>>>>>            End
78316>>>>>>>>>>>>
78316>>>>>>>>>>>            If (Connection.sId = "") Begin
78318>>>>>>>>>>>                Move True to SQLConnectionEmpty.bError
78319>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78320>>>>>>>>>>>            End
78320>>>>>>>>>>>>
78320>>>>>>>>>>>
78320>>>>>>>>>>>            // DUF connection info struct property:
78320>>>>>>>>>>>            Get Private.pSQLConnection                       to SQLConnection
78321>>>>>>>>>>>
78321>>>>>>>>>>>            Move Connection.sId to sConnectionID
78322>>>>>>>>>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
78323>>>>>>>>>>>
78323>>>>>>>>>>>            If (bConnected = False) Begin
78325>>>>>>>>>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
78326>>>>>>>>>>>                If (iRetval <> 0) Begin
78328>>>>>>>>>>>                    Send UserError CS_DUF_CannotLoginToServer
78329>>>>>>>>>>>                    Send Exit_Application
78330>>>>>>>>>>>                End
78330>>>>>>>>>>>>
78330>>>>>>>>>>>                Move True                                   to SQLConnection.bDAWConnection
78331>>>>>>>>>>>                // We need to get the DAW connection info again as it might have
78331>>>>>>>>>>>                // been changed in the DAW db login dialog.
78331>>>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
78332>>>>>>>>>>>            End
78332>>>>>>>>>>>>
78332>>>>>>>>>>>
78332>>>>>>>>>>>            Move True                                        to SQLConnection.bEnabled
78333>>>>>>>>>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
78334>>>>>>>>>>>
78334>>>>>>>>>>>            // Not used in DUF:
78334>>>>>>>>>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
78334>>>>>>>>>>>
78334>>>>>>>>>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
78335>>>>>>>>>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
78336>>>>>>>>>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
78337>>>>>>>>>>>            Move Connection.sId                              to SQLConnection.sConnectionID
78338>>>>>>>>>>>            Move Connection.sUID                             to SQLConnection.sUserID
78339>>>>>>>>>>>            Move Connection.sPWD                             to SQLConnection.sPassword
78340>>>>>>>>>>>
78340>>>>>>>>>>>            // Not used in DUF:
78340>>>>>>>>>>>            // Move Connection.sSection to SQLConnection.xxx
78340>>>>>>>>>>>
78340>>>>>>>>>>>            // The rest of the properties of the SQLConnection struct should have been
78340>>>>>>>>>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
78340>>>>>>>>>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
78342>>>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniServerKeyword + "=")       to SQLConnection.sServer
78343>>>>>>>>>>>            End
78343>>>>>>>>>>>>
78343>>>>>>>>>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
78345>>>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniDSNKeyword + "=")          to SQLConnection.sServer
78346>>>>>>>>>>>                If (SQLConnection.sServer = "") Begin
78348>>>>>>>>>>>                    Get ParseKeyWord Connection.sString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78349>>>>>>>>>>>                End
78349>>>>>>>>>>>>
78349>>>>>>>>>>>            End
78349>>>>>>>>>>>>
78349>>>>>>>>>>>
78349>>>>>>>>>>>            Get ParseKeyWord Connection.sString (CS_SQLIniDatabaseKeyword  + "=")        to SQLConnection.sDatabase
78350>>>>>>>>>>>
78350>>>>>>>>>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
78350>>>>>>>>>>>            // the value from the driver id:
78350>>>>>>>>>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
78351>>>>>>>>>>>            If (SQLConnection.iDbType = 0) Begin
78353>>>>>>>>>>>            // ...but in case it has been explicitly set in the object we use that value.
78353>>>>>>>>>>>            Get piDbType                                     to iDbType
78354>>>>>>>>>>>            End
78354>>>>>>>>>>>>
78354>>>>>>>>>>>            If (iDbType > 0 and SQLConnection.iDbType = 0) Begin
78356>>>>>>>>>>>                Move iDbType to SQLConnection.iDbType
78357>>>>>>>>>>>            End
78357>>>>>>>>>>>>
78357>>>>>>>>>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
78358>>>>>>>>>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
78359>>>>>>>>>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
78360>>>>>>>>>>>            Get psSchema                                     to SQLConnection.sSchema
78361>>>>>>>>>>>
78361>>>>>>>>>>>            // We finally set the struct property to the newly fetched values.
78361>>>>>>>>>>>            Set pSQLConnection to SQLConnection
78362>>>>>>>>>>>
78362>>>>>>>>>>>        Function_Return SQLConnection
78363>>>>>>>>>>>    End_Function
78364>>>>>>>>>>>
78364>>>>>>>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
78364>>>>>>>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
78364>>>>>>>>>>>    // connection id for a particular driver.
78364>>>>>>>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
78364>>>>>>>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
78364>>>>>>>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
78364>>>>>>>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
78364>>>>>>>>>>>    // connections of the DAW cConnect class.
78364>>>>>>>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
78366>>>>>>>>>>>        tConnection[] ConnIdArray
78366>>>>>>>>>>>        tConnection[] ConnIdArray
78367>>>>>>>>>>>        Integer iCount iSize iConnectionIDCounter
78367>>>>>>>>>>>        Boolean bEnabled bFound
78367>>>>>>>>>>>        String sConnectionID2 sDriverID sDriverConn
78367>>>>>>>>>>>
78367>>>>>>>>>>>        Move False to bFound
78368>>>>>>>>>>>        If (ghoConnection > 0) Begin
78370>>>>>>>>>>>
78370>>>>>>>>>>>            // The property of the cDbUpdateHandler container object
78370>>>>>>>>>>>            Get psDriverID to sDriverID
78371>>>>>>>>>>>
78371>>>>>>>>>>>            Move 0 to iConnectionIDCounter
78372>>>>>>>>>>>            // This is the the DAW cConnect array with all registered connection id's.
78372>>>>>>>>>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
78373>>>>>>>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
78374>>>>>>>>>>>            Decrement iSize
78375>>>>>>>>>>>            For iCount from 0 to iSize
78381>>>>>>>>>>>>
78381>>>>>>>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
78382>>>>>>>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
78383>>>>>>>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
78384>>>>>>>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
78384>>>>>>>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
78384>>>>>>>>>>>                If (sConnectionID = "") Begin
78386>>>>>>>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
78387>>>>>>>>>>>                End
78387>>>>>>>>>>>>
78387>>>>>>>>>>>                Else Begin
78388>>>>>>>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
78390>>>>>>>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
78391>>>>>>>>>>>                    End
78391>>>>>>>>>>>>
78391>>>>>>>>>>>                End
78391>>>>>>>>>>>>
78391>>>>>>>>>>>
78391>>>>>>>>>>>                If (bFound = True) Begin
78393>>>>>>>>>>>                    Increment iConnectionIDCounter
78394>>>>>>>>>>>                End
78394>>>>>>>>>>>>
78394>>>>>>>>>>>            Loop
78395>>>>>>>>>>>>
78395>>>>>>>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
78396>>>>>>>>>>>            If (bFound = True) Begin
78398>>>>>>>>>>>                Move sConnectionID2 to sConnectionID
78399>>>>>>>>>>>            End
78399>>>>>>>>>>>>
78399>>>>>>>>>>>        End
78399>>>>>>>>>>>>
78399>>>>>>>>>>>
78399>>>>>>>>>>>        // Special case; a cConnection object has been setup in the cApplication,
78399>>>>>>>>>>>        // but no DFConn.ini record has been created.
78399>>>>>>>>>>>        If (iSize = -1) Begin
78401>>>>>>>>>>>            Move True to bFound
78402>>>>>>>>>>>        End
78402>>>>>>>>>>>>
78402>>>>>>>>>>>
78402>>>>>>>>>>>        Function_Return bFound
78403>>>>>>>>>>>    End_Function
78404>>>>>>>>>>>
78404>>>>>>>>>>>    // Send on object creation to read the default connection string settings, and
78404>>>>>>>>>>>    // create a connection to the server.
78404>>>>>>>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
78406>>>>>>>>>>>        String sPath sFileName
78406>>>>>>>>>>>        Boolean bExists bActive
78406>>>>>>>>>>>        tSQLConnection[] SQLConnectionArray
78406>>>>>>>>>>>        tSQLConnection[] SQLConnectionArray
78407>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78407>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78407>>>>>>>>>>>        Handle hoIniFile
78407>>>>>>>>>>>        Integer iSize iCount iRetval
78407>>>>>>>>>>>
78407>>>>>>>>>>>        Get psIniFilePath to sPath
78408>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78409>>>>>>>>>>>        If (sPath = "") Begin
78411>>>>>>>>>>>            Get ApplicationPath of hoIniFile to sPath
78412>>>>>>>>>>>            Set psIniFilePath   of hoIniFile to sPath
78413>>>>>>>>>>>        End
78413>>>>>>>>>>>>
78413>>>>>>>>>>>        Get vFolderFormat sPath to sPath
78414>>>>>>>>>>>        Get psIniFileName to sFileName
78415>>>>>>>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
78416>>>>>>>>>>>
78416>>>>>>>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
78417>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
78418>>>>>>>>>>>        If (iSize = 0) Begin
78420>>>>>>>>>>>            // This may have been set by the "ReadcConnections" function,
78420>>>>>>>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
78420>>>>>>>>>>>            // in the cApplication object.
78420>>>>>>>>>>>            Get pSQLConnection to SQLConnection
78421>>>>>>>>>>>            If (SQLConnection.sConnectionID = "") Begin
78423>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78424>>>>>>>>>>>            End
78424>>>>>>>>>>>>
78424>>>>>>>>>>>            Move SQLConnection to SQLConnectionArray[0] 
78425>>>>>>>>>>>            Move 1 to iSize
78426>>>>>>>>>>>        End
78426>>>>>>>>>>>>
78426>>>>>>>>>>>
78426>>>>>>>>>>>        Move False to bActive
78427>>>>>>>>>>>        // The first connection should be the one that is active, but all connections might have been disabled.
78427>>>>>>>>>>>        Decrement iSize
78428>>>>>>>>>>>        For iCount from 0 to iSize
78434>>>>>>>>>>>>
78434>>>>>>>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
78435>>>>>>>>>>>            If (SQLConnection.bEnabled = True) Begin
78437>>>>>>>>>>>                Move True to bActive
78438>>>>>>>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
78439>>>>>>>>>>>            End
78439>>>>>>>>>>>>
78439>>>>>>>>>>>        Loop
78440>>>>>>>>>>>>
78440>>>>>>>>>>>
78440>>>>>>>>>>>        // In case all connections have been disabled, we're out of here.
78440>>>>>>>>>>>        If (bActive = False) Begin
78442>>>>>>>>>>>            Function_Return SQLConnectionEmpty
78443>>>>>>>>>>>        End
78443>>>>>>>>>>>>
78443>>>>>>>>>>>
78443>>>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin False
78444>>>>>>>>>>>
78444>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78445>>>>>>>>>>>        Get AutoSetConnectionID to iRetval
78446>>>>>>>>>>>
78446>>>>>>>>>>>        Function_Return SQLConnection
78447>>>>>>>>>>>    End_Function
78448>>>>>>>>>>>
78448>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
78450>>>>>>>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
78451>>>>>>>>>>>    End_Procedure
78452>>>>>>>>>>>
78452>>>>>>>>>>>    Function psIniFilePath Returns String
78454>>>>>>>>>>>        String sRetval
78454>>>>>>>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
78455>>>>>>>>>>>        Function_Return sRetval
78456>>>>>>>>>>>    End_Function
78457>>>>>>>>>>>
78457>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
78459>>>>>>>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
78460>>>>>>>>>>>    End_Procedure
78461>>>>>>>>>>>
78461>>>>>>>>>>>    Function psIniFileName Returns String
78463>>>>>>>>>>>        String sRetval
78463>>>>>>>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
78464>>>>>>>>>>>        Function_Return sRetval
78465>>>>>>>>>>>    End_Function
78466>>>>>>>>>>>
78466>>>>>>>>>>>    Procedure Set psIniSectionName String sSection
78468>>>>>>>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
78469>>>>>>>>>>>    End_Procedure
78470>>>>>>>>>>>
78470>>>>>>>>>>>    Function psIniSectionName Returns String
78472>>>>>>>>>>>        String sRetval
78472>>>>>>>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
78473>>>>>>>>>>>        Function_Return sRetval
78474>>>>>>>>>>>    End_Function
78475>>>>>>>>>>>
78475>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
78477>>>>>>>>>>>        Handle ho
78477>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78478>>>>>>>>>>>        Set IniFileValue of ho to sSection sValueName sValue
78479>>>>>>>>>>>    End_Procedure
78480>>>>>>>>>>>
78480>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
78482>>>>>>>>>>>        Handle ho
78482>>>>>>>>>>>        String sRetval
78482>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78483>>>>>>>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
78484>>>>>>>>>>>        Function_Return sRetval
78485>>>>>>>>>>>    End_Function
78486>>>>>>>>>>>
78486>>>>>>>>>>>    Function SectionExists String sSection Returns Boolean
78488>>>>>>>>>>>        Handle ho
78488>>>>>>>>>>>        Boolean bRetval
78488>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78489>>>>>>>>>>>        Get SectionExists of ho sSection to bRetval
78490>>>>>>>>>>>        Function_Return bRetval
78491>>>>>>>>>>>    End_Function
78492>>>>>>>>>>>
78492>>>>>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
78494>>>>>>>>>>>        Handle ho
78494>>>>>>>>>>>        Boolean bRetval
78494>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78495>>>>>>>>>>>        Get KeyExists of ho sSection sKey to bRetval
78496>>>>>>>>>>>        Function_Return bRetval
78497>>>>>>>>>>>    End_Function
78498>>>>>>>>>>>
78498>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
78500>>>>>>>>>>>        Handle ho
78500>>>>>>>>>>>        String sRetval
78500>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78501>>>>>>>>>>>        Get EncryptPassword of ho sPassword to sRetval
78502>>>>>>>>>>>        Function_Return sRetval
78503>>>>>>>>>>>    End_Function
78504>>>>>>>>>>>
78504>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
78506>>>>>>>>>>>        Handle ho
78506>>>>>>>>>>>        String sRetval
78506>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78507>>>>>>>>>>>        Get DecryptPassword of ho sPassword to sRetval
78508>>>>>>>>>>>        Function_Return sRetval
78509>>>>>>>>>>>    End_Function
78510>>>>>>>>>>>
78510>>>>>>>>>>>    // *** Main Connection Message ***
78510>>>>>>>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent Boolean bExitProgram
78512>>>>>>>>>>>        Handle hoDriver
78512>>>>>>>>>>>        String sConnectionString sError
78512>>>>>>>>>>>        Boolean bLoginSuccessful
78512>>>>>>>>>>>
78512>>>>>>>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
78513>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
78514>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
78515>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
78516>>>>>>>>>>>        If (bLoginSuccessful = False) Begin
78518>>>>>>>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)   
78519>>>>>>>>>>>>
78519>>>>>>>>>>>            If (bExitProgram = True) Begin
78521>>>>>>>>>>>                Send Exit_Application
78522>>>>>>>>>>>            End
78522>>>>>>>>>>>>
78522>>>>>>>>>>>        End
78522>>>>>>>>>>>>
78522>>>>>>>>>>>        Send Destroy of hoDriver
78523>>>>>>>>>>>    End_Procedure
78524>>>>>>>>>>>
78524>>>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
78526>>>>>>>>>>>        Integer iRetval
78526>>>>>>>>>>>        Handle hoCLI
78526>>>>>>>>>>>        String sDriverID
78526>>>>>>>>>>>
78526>>>>>>>>>>>        Get psDriverID to sDriverID
78527>>>>>>>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
78528>>>>>>>>>>>        If (hoCLI <> 0) Begin
78530>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78531>>>>>>>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
78532>>>>>>>>>>>            Send Destroy of hoCLI
78533>>>>>>>>>>>        End
78533>>>>>>>>>>>>
78533>>>>>>>>>>>
78533>>>>>>>>>>>        Function_Return iRetval
78534>>>>>>>>>>>    End_Function
78535>>>>>>>>>>>
78535>>>>>>>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
78537>>>>>>>>>>>        tSQLConnection SQLConnection
78537>>>>>>>>>>>        tSQLConnection SQLConnection
78537>>>>>>>>>>>
78537>>>>>>>>>>>        Set psDriverID to sDriverID
78538>>>>>>>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
78539>>>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted False
78540>>>>>>>>>>>    End_Procedure
78541>>>>>>>>>>>
78541>>>>>>>>>>>    // This is needed when e.g. the connection id we have specified in the program code
78541>>>>>>>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
78541>>>>>>>>>>>    // or the one in the DataFlex Bin folder.)
78541>>>>>>>>>>>    // We then need to delete the current one before creating a new one.
78541>>>>>>>>>>>    // This is because the parameters may differ between the program code and the
78541>>>>>>>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
78541>>>>>>>>>>>    // when one tries to create a Connection ID that already exists.
78541>>>>>>>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
78543>>>>>>>>>>>        Integer iResult iDriver iNumConn iConn
78543>>>>>>>>>>>        Handle hoCLI
78543>>>>>>>>>>>        String sID
78543>>>>>>>>>>>
78543>>>>>>>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
78545>>>>>>>>>>>            Procedure_Return
78546>>>>>>>>>>>        End
78546>>>>>>>>>>>>
78546>>>>>>>>>>>
78546>>>>>>>>>>>        Move 0 to iResult
78547>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78548>>>>>>>>>>>        If (hoCLI <> 0) Begin
78550>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78551>>>>>>>>>>>            Get DriverIndex sDriverID to iDriver
78552>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78555>>>>>>>>>>>            Decrement iNumConn
78556>>>>>>>>>>>            For iConn from 0 to iNumConn
78562>>>>>>>>>>>>
78562>>>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78565>>>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78567>>>>>>>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
78568>>>>>>>>>>>                End
78568>>>>>>>>>>>>
78568>>>>>>>>>>>            Loop
78569>>>>>>>>>>>>
78569>>>>>>>>>>>            Send Destroy of hoCLI
78570>>>>>>>>>>>        End
78570>>>>>>>>>>>>
78570>>>>>>>>>>>
78570>>>>>>>>>>>    End_Procedure
78571>>>>>>>>>>>
78571>>>>>>>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
78573>>>>>>>>>>>        Integer iResult iDriver iNumConn iConn
78573>>>>>>>>>>>        Handle hoCLI
78573>>>>>>>>>>>        String sID sConnectionString sVal sDatabase
78573>>>>>>>>>>>        tSQLConnection SQLConnection
78573>>>>>>>>>>>        tSQLConnection SQLConnection
78573>>>>>>>>>>>        Boolean bTrusted
78573>>>>>>>>>>>
78573>>>>>>>>>>>        Move 0 to iResult
78574>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78575>>>>>>>>>>>        If (hoCLI <> 0) Begin
78577>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78578>>>>>>>>>>>            Get DriverIndex sDriverID to iDriver
78579>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78582>>>>>>>>>>>            Decrement iNumConn
78583>>>>>>>>>>>            For iConn from 0 to iNumConn
78589>>>>>>>>>>>>
78589>>>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78592>>>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78594>>>>>>>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
78595>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
78598>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
78601>>>>>>>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
78602>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
78605>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
78606>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
78607>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
78608>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
78609>>>>>>>>>>>
78609>>>>>>>>>>>                    Case Begin
78609>>>>>>>>>>>                        Case (sDriverID = MSSQLDRV_ID)
78611>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
78612>>>>>>>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
78613>>>>>>>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
78614>>>>>>>>>>>                            Case Break
78615>>>>>>>>>>>                        Case (sDriverID = DB2_DRV_ID)
78618>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78619>>>>>>>>>>>                            Case Break
78620>>>>>>>>>>>                        Case (sDriverID = ODBC_DRV_ID)
78623>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78624>>>>>>>>>>>                            If (SQLConnection.sServer = "") Begin
78626>>>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78627>>>>>>>>>>>                            End
78627>>>>>>>>>>>>
78627>>>>>>>>>>>                            Case Break
78628>>>>>>>>>>>                        Case Else
78628>>>>>>>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
78629>>>>>>>>>>>>
78629>>>>>>>>>>>                            Case Break
78630>>>>>>>>>>>                    Case End
78630>>>>>>>>>>>                End
78630>>>>>>>>>>>>
78630>>>>>>>>>>>            Loop
78631>>>>>>>>>>>>
78631>>>>>>>>>>>            Send Destroy of hoCLI
78632>>>>>>>>>>>        End
78632>>>>>>>>>>>>
78632>>>>>>>>>>>
78632>>>>>>>>>>>        Function_Return SQLConnection
78633>>>>>>>>>>>    End_Function
78634>>>>>>>>>>>
78634>>>>>>>>>>>    Function DriverIndex String sDriverID Returns Integer
78636>>>>>>>>>>>        String  sCurrentDriver
78636>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
78636>>>>>>>>>>>
78636>>>>>>>>>>>        Move 0 to iDriver
78637>>>>>>>>>>>        Move 0 to iCount
78638>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
78641>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
78647>>>>>>>>>>>>
78647>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
78650>>>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
78652>>>>>>>>>>>                Function_Return iCount
78653>>>>>>>>>>>            End
78653>>>>>>>>>>>>
78653>>>>>>>>>>>        Loop
78654>>>>>>>>>>>>
78654>>>>>>>>>>>
78654>>>>>>>>>>>        // If driver not previously loaded; attempt to do so now.
78654>>>>>>>>>>>        If (iDriver = 0) Begin
78656>>>>>>>>>>>            Move 0 to LastErr
78657>>>>>>>>>>>            Load_Driver sDriverID
78658>>>>>>>>>>>            // If driver could not be loaded.
78658>>>>>>>>>>>            If (LastErr = DFERR_CANT_LOAD_DLL) Begin
78660>>>>>>>>>>>                Move -1 to iCount
78661>>>>>>>>>>>            End
78661>>>>>>>>>>>>
78661>>>>>>>>>>>        End
78661>>>>>>>>>>>>
78661>>>>>>>>>>>        Function_Return iCount
78662>>>>>>>>>>>    End_Function
78663>>>>>>>>>>>
78663>>>>>>>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
78663>>>>>>>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
78665>>>>>>>>>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
78665>>>>>>>>>>>        Boolean bTrusted bSilent
78665>>>>>>>>>>>        Integer iRetval
78665>>>>>>>>>>>
78665>>>>>>>>>>>        Move SQLConnection.sDriverID     to sDriverID
78666>>>>>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
78667>>>>>>>>>>>        Move SQLConnection.sServer       to sServer
78668>>>>>>>>>>>        Move SQLConnection.sDatabase     to sDatabase
78669>>>>>>>>>>>        Move SQLConnection.bTrusted      to bTrusted
78670>>>>>>>>>>>        Move SQLConnection.sUserID       to sUserID
78671>>>>>>>>>>>        Move SQLConnection.sPassword     to sPassword
78672>>>>>>>>>>>        Move SQLConnection.bSilentLogin  to bSilent
78673>>>>>>>>>>>
78673>>>>>>>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent False
78674>>>>>>>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
78674>>>>>>>>>>>        Get AutoSetConnectionID to iRetval
78675>>>>>>>>>>>    End_Procedure
78676>>>>>>>>>>>
78676>>>>>>>>>>>    // Called when the object is constructed.
78676>>>>>>>>>>>    // It will check the psDriverID for a ConnectionID and save it
78676>>>>>>>>>>>    // as psConnectionID property. It is later used whenever a login to
78676>>>>>>>>>>>    // the database is needed.
78676>>>>>>>>>>>    Function AutoSetConnectionID Returns Boolean
78678>>>>>>>>>>>        String sConnectionID sDriverID sConnectionString
78678>>>>>>>>>>>        Integer iDriver iRetval
78678>>>>>>>>>>>        Handle hoCLI
78678>>>>>>>>>>>        Boolean bOK bSilent
78678>>>>>>>>>>>
78678>>>>>>>>>>>        Get pbSilentLogin      to bSilent
78679>>>>>>>>>>>        Get psConnectionID     to sConnectionID
78680>>>>>>>>>>>        Get psConnectionString to sConnectionString
78681>>>>>>>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
78681>>>>>>>>>>>        Get psDriverID to sDriverID
78682>>>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78683>>>>>>>>>>>        If (bOK = False) Begin
78685>>>>>>>>>>>            Function_Return False
78686>>>>>>>>>>>        End
78686>>>>>>>>>>>>
78686>>>>>>>>>>>
78686>>>>>>>>>>>        Get DriverIndex sDriverID          to iDriver
78687>>>>>>>>>>>        // If driver not loaded; load it.
78687>>>>>>>>>>>        If (iDriver = 0) Begin
78689>>>>>>>>>>>            Load_Driver sDriverID
78690>>>>>>>>>>>            Get DriverIndex sDriverID      to iDriver
78691>>>>>>>>>>>        End
78691>>>>>>>>>>>>
78691>>>>>>>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
78691>>>>>>>>>>>        If (iDriver = 0) Begin
78693>>>>>>>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
78694>>>>>>>>>>>>
78694>>>>>>>>>>>            Function_Return False
78695>>>>>>>>>>>        End           
78695>>>>>>>>>>>>
78695>>>>>>>>>>>            Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to True
78698>>>>>>>>>>>        
78698>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78699>>>>>>>>>>>        Set psDriverID of hoCLI            to sDriverID
78700>>>>>>>>>>>        // Delete the connection first; in case it exists
78700>>>>>>>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
78701>>>>>>>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval 
78702>>>>>>>>>>>        Send Destroy of hoCLI
78703>>>>>>>>>>>
78703>>>>>>>>>>>        Function_Return (iRetval = 0)
78704>>>>>>>>>>>    End_Function
78705>>>>>>>>>>>
78705>>>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
78707>>>>>>>>>>>        Boolean bOK
78707>>>>>>>>>>>
78707>>>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
78708>>>>>>>>>>>
78708>>>>>>>>>>>        If (bOK = False) Begin
78710>>>>>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
78711>>>>>>>>>>>>
78711>>>>>>>>>>>            Function_Return False
78712>>>>>>>>>>>        End
78712>>>>>>>>>>>>
78712>>>>>>>>>>>
78712>>>>>>>>>>>        Function_Return True
78713>>>>>>>>>>>    End_Function
78714>>>>>>>>>>>
78714>>>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
78716>>>>>>>>>>>        Boolean bOK
78716>>>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
78717>>>>>>>>>>>        Function_Return bOK
78718>>>>>>>>>>>    End_Function
78719>>>>>>>>>>>
78719>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
78721>>>>>>>>>>>        Handle hoIniFile
78721>>>>>>>>>>>        String sConnect
78721>>>>>>>>>>>
78721>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78722>>>>>>>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
78723>>>>>>>>>>>
78723>>>>>>>>>>>        Function_Return sConnect
78724>>>>>>>>>>>    End_Function
78725>>>>>>>>>>>
78725>>>>>>>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
78725>>>>>>>>>>>    // Pass a complete driver connection string
78725>>>>>>>>>>>    // Returns the following as a struct:
78725>>>>>>>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
78725>>>>>>>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
78725>>>>>>>>>>>    //
78725>>>>>>>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
78727>>>>>>>>>>>        tSQLConnection SQLConnection
78727>>>>>>>>>>>        tSQLConnection SQLConnection
78727>>>>>>>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
78727>>>>>>>>>>>        Boolean bTrusted bSilent bOK
78727>>>>>>>>>>>        Integer iPos
78727>>>>>>>>>>>
78727>>>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78728>>>>>>>>>>>        If (bOK = False) Begin
78730>>>>>>>>>>>            Function_Return SQLConnection
78731>>>>>>>>>>>        End
78731>>>>>>>>>>>>
78731>>>>>>>>>>>
78731>>>>>>>>>>>        Move False to bTrusted
78732>>>>>>>>>>>        Move False to bSilent
78733>>>>>>>>>>>
78733>>>>>>>>>>>        Case Begin
78733>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
78735>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
78736>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
78737>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78738>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78739>>>>>>>>>>>                If (bTrusted = False) Begin
78741>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78742>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78743>>>>>>>>>>>                End
78743>>>>>>>>>>>>
78743>>>>>>>>>>>                Case Break
78744>>>>>>>>>>>
78744>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
78747>>>>>>>>>>>                If (uppercase(sConnectionString) contains ("." + CS_SQLIniDSNKeyword)) Begin
78749>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword + "=")  to sServer
78750>>>>>>>>>>>                End
78750>>>>>>>>>>>>
78750>>>>>>>>>>>                Else Begin
78751>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78752>>>>>>>>>>>                End
78752>>>>>>>>>>>>
78752>>>>>>>>>>>
78752>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78753>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78754>>>>>>>>>>>                If (bTrusted = False) Begin
78756>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78757>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78758>>>>>>>>>>>                End
78758>>>>>>>>>>>>
78758>>>>>>>>>>>                Case Break
78759>>>>>>>>>>>
78759>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
78762>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78763>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
78764>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
78765>>>>>>>>>>>                Case Break
78766>>>>>>>>>>>
78766>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
78769>>>>>>>>>>>                Break
78770>>>>>>>>>>>        Case End
78770>>>>>>>>>>>
78770>>>>>>>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
78771>>>>>>>>>>>
78771>>>>>>>>>>>        // bSilent?
78771>>>>>>>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
78772>>>>>>>>>>>        If (iPos = 0) Begin
78774>>>>>>>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
78775>>>>>>>>>>>        End
78775>>>>>>>>>>>>
78775>>>>>>>>>>>        If (iPos = 0) Begin
78777>>>>>>>>>>>            Move "0"                                                            to sValue
78778>>>>>>>>>>>        End
78778>>>>>>>>>>>>
78778>>>>>>>>>>>        Else Begin
78779>>>>>>>>>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
78780>>>>>>>>>>>        End
78780>>>>>>>>>>>>
78780>>>>>>>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
78781>>>>>>>>>>>
78781>>>>>>>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
78782>>>>>>>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
78783>>>>>>>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
78784>>>>>>>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
78785>>>>>>>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
78786>>>>>>>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
78787>>>>>>>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
78788>>>>>>>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
78789>>>>>>>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
78790>>>>>>>>>>>
78790>>>>>>>>>>>        Function_Return SQLConnection
78791>>>>>>>>>>>    End_Function
78792>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
78792>>>>>>>>>>>>
78792>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
78794>>>>>>>>>>>>    Integer iStart iEnd
78794>>>>>>>>>>>>    String sRetval
78794>>>>>>>>>>>>
78794>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
78795>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
78796>>>>>>>>>>>>    If (iStart = 0) Begin
78798>>>>>>>>>>>>        Function_Return ""
78799>>>>>>>>>>>>    End
78799>>>>>>>>>>>>>
78799>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
78800>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
78801>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
78803>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78804>>>>>>>>>>>>    End
78804>>>>>>>>>>>>>
78804>>>>>>>>>>>>    Else Begin
78805>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
78806>>>>>>>>>>>>    End
78806>>>>>>>>>>>>>
78806>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
78808>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78809>>>>>>>>>>>>        Decrement iEnd
78810>>>>>>>>>>>>    End
78810>>>>>>>>>>>>>
78810>>>>>>>>>>>>    If (iEnd <> 0) Begin
78812>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
78813>>>>>>>>>>>>    End
78813>>>>>>>>>>>>>
78813>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
78814>>>>>>>>>>>>
78814>>>>>>>>>>>>    Function_Return (Trim(sRetval))
78815>>>>>>>>>>>>End_Function
78816>>>>>>>>>>>>
78816>>>>>>>>>>>>
78816>>>>>>>>>>>
78816>>>>>>>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
78816>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
78818>>>>>>>>>>>        Handle ho
78818>>>>>>>>>>>        Integer iIndex
78818>>>>>>>>>>>        Boolean bRetval bOK
78818>>>>>>>>>>>        tSQLConnection SQLConnection
78818>>>>>>>>>>>        tSQLConnection SQLConnection
78818>>>>>>>>>>>
78818>>>>>>>>>>>        Get pSQLConnection to SQLConnection
78819>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78820>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
78821>>>>>>>>>>>        If (iIndex = -1) Begin
78823>>>>>>>>>>>            Function_Return False
78824>>>>>>>>>>>        End
78824>>>>>>>>>>>>
78824>>>>>>>>>>>
78824>>>>>>>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
78825>>>>>>>>>>>        Send UpdateConnectionString SQLConnection
78826>>>>>>>>>>>        If (ghoConnection > 0) Begin
78828>>>>>>>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
78829>>>>>>>>>>>            If (iIndex <> -1) Begin
78831>>>>>>>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
78832>>>>>>>>>>>            End
78832>>>>>>>>>>>>
78832>>>>>>>>>>>        End
78832>>>>>>>>>>>>
78832>>>>>>>>>>>
78832>>>>>>>>>>>        Function_Return bRetval
78833>>>>>>>>>>>    End_Function
78834>>>>>>>>>>>
78834>>>>>>>>>>>    Procedure Set pbDFConnid Boolean bState
78836>>>>>>>>>>>        Set pbDFConnid of (phoSQLConnectionIniFile(Self)) to bState
78837>>>>>>>>>>>    End_Procedure
78838>>>>>>>>>>>    
78838>>>>>>>>>>>    Function pbDFConnid Returns Boolean
78840>>>>>>>>>>>        Boolean bState
78840>>>>>>>>>>>        Get pbDFConnid of (phoSQLConnectionIniFile(Self)) to bState
78841>>>>>>>>>>>        Function_Return bState
78842>>>>>>>>>>>    End_Function
78843>>>>>>>>>>>
78843>>>>>>>>>>>End_Class
78844>>>>>>>>>Use vWin32fh.pkg
78844>>>>>>>>>Use Dfabout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\DfAbout.pkg)
78844>>>>>>>>>>>Use LanguageText.pkg
78844>>>>>>>>>>>Use Windows.pkg
78844>>>>>>>>>>>Use Dfclient.pkg
78844>>>>>>>>>>>Use DFbitmap.pkg
78844>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
78844>>>>>>>>>>>Use cRichEdit.pkg
78844>>>>>>>>>>>Use cTextEdit.pkg
78844>>>>>>>>>>>Use cRichEdit.pkg
78844>>>>>>>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files\DataFlex 24.0\Pkg\gFormatNumbers.pkg)
78844>>>>>>>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cFormatter.pkg)
78844>>>>>>>>>>>>>>>Use VDFBase.pkg
78844>>>>>>>>>>>>>>>
78844>>>>>>>>>>>>>>>Class cFormatter is an cObject
78845>>>>>>>>>>>>>>>    
78845>>>>>>>>>>>>>>>    Procedure Construct_object
78847>>>>>>>>>>>>>>>        Integer iCh
78847>>>>>>>>>>>>>>>        Forward Send construct_object
78849>>>>>>>>>>>>>>>        Property String  psCurrencySymbol
78850>>>>>>>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
78851>>>>>>>>>>>>>>>        
78851>>>>>>>>>>>>>>>        Property String  psLeft
78852>>>>>>>>>>>>>>>        Property String  psright
78853>>>>>>>>>>>>>>>        Property Integer pbThousandsSep
78854>>>>>>>>>>>>>>>        Property Integer piPoints
78855>>>>>>>>>>>>>>>        
78855>>>>>>>>>>>>>>>        Property String  psCurPosLeft
78856>>>>>>>>>>>>>>>        Property String  psCurPosright
78857>>>>>>>>>>>>>>>        Property Integer pbCurPosThousandsSep
78858>>>>>>>>>>>>>>>        Property Integer piCurPosPoints
78859>>>>>>>>>>>>>>>        
78859>>>>>>>>>>>>>>>        Property String  psCurNegLeft
78860>>>>>>>>>>>>>>>        Property String  psCurNegright
78861>>>>>>>>>>>>>>>        Property Integer pbCurNegThousandsSep
78862>>>>>>>>>>>>>>>        Property Integer piCurNegPoints
78863>>>>>>>>>>>>>>>        
78863>>>>>>>>>>>>>>>        Property String  psNumPosLeft
78864>>>>>>>>>>>>>>>        Property String  psNumPosright
78865>>>>>>>>>>>>>>>        Property Integer pbNumPosThousandsSep
78866>>>>>>>>>>>>>>>        Property Integer piNumPosPoints
78867>>>>>>>>>>>>>>>        
78867>>>>>>>>>>>>>>>        Property String  psNumNegLeft
78868>>>>>>>>>>>>>>>        Property String  psNumNegright
78869>>>>>>>>>>>>>>>        Property Integer pbNumNegThousandsSep
78870>>>>>>>>>>>>>>>        Property Integer piNumNegPoints
78871>>>>>>>>>>>>>>>        
78871>>>>>>>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
78872>>>>>>>>>>>>>>>        Send SetFormat  ",#.*"           False // numeric
78873>>>>>>>>>>>>>>>        
78873>>>>>>>>>>>>>>>    End_Procedure
78874>>>>>>>>>>>>>>>    
78874>>>>>>>>>>>>>>>    // internal
78874>>>>>>>>>>>>>>>    // parse passed format string and set temporary properties with result
78874>>>>>>>>>>>>>>>    Procedure ParseFormat String sFmt
78876>>>>>>>>>>>>>>>        
78876>>>>>>>>>>>>>>>        String sLeft sRight sDigit
78876>>>>>>>>>>>>>>>        Integer bSep iPos i iDigits
78876>>>>>>>>>>>>>>>        
78876>>>>>>>>>>>>>>>        // replace any literals. A "/" followed by anything.
78876>>>>>>>>>>>>>>>        // some literals are special. $ . , / #
78876>>>>>>>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
78877>>>>>>>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
78878>>>>>>>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
78879>>>>>>>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
78880>>>>>>>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
78881>>>>>>>>>>>>>>>        Move (Character(9)) to sDigit
78882>>>>>>>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
78883>>>>>>>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
78884>>>>>>>>>>>>>>>        
78884>>>>>>>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
78885>>>>>>>>>>>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
78888>>>>>>>>>>>>>>>        
78888>>>>>>>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
78889>>>>>>>>>>>>>>>        
78889>>>>>>>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
78890>>>>>>>>>>>>>>>        
78890>>>>>>>>>>>>>>>        // Move all the special literals back into place before parsing
78890>>>>>>>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
78891>>>>>>>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
78892>>>>>>>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
78893>>>>>>>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
78894>>>>>>>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
78895>>>>>>>>>>>>>>>        
78895>>>>>>>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
78897>>>>>>>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
78898>>>>>>>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
78900>>>>>>>>>>>>>>>                Move -2 to iDigits
78901>>>>>>>>>>>>>>>                Increment i
78902>>>>>>>>>>>>>>>            End
78902>>>>>>>>>>>>>>>>
78902>>>>>>>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
78906>>>>>>>>>>>>>>>                Increment i
78907>>>>>>>>>>>>>>>            Loop
78908>>>>>>>>>>>>>>>>
78908>>>>>>>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
78909>>>>>>>>>>>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
78912>>>>>>>>>>>>>>>            //
78912>>>>>>>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
78913>>>>>>>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
78917>>>>>>>>>>>>>>>                Increment i
78918>>>>>>>>>>>>>>>            Loop
78919>>>>>>>>>>>>>>>>
78919>>>>>>>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
78920>>>>>>>>>>>>>>>        End
78920>>>>>>>>>>>>>>>>
78920>>>>>>>>>>>>>>>        Else Begin                             // we have no decinal
78921>>>>>>>>>>>>>>>            Move 0 to iDigits                  // so points is none
78922>>>>>>>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
78923>>>>>>>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
78925>>>>>>>>>>>>>>>                Move sFmt to sLeft
78926>>>>>>>>>>>>>>>                Move ""   to sRight
78927>>>>>>>>>>>>>>>            End
78927>>>>>>>>>>>>>>>>
78927>>>>>>>>>>>>>>>            Else Begin
78928>>>>>>>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
78929>>>>>>>>>>>>>>>                Move 1 to i
78930>>>>>>>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
78934>>>>>>>>>>>>>>>                    Increment i
78935>>>>>>>>>>>>>>>                Loop
78936>>>>>>>>>>>>>>>>
78936>>>>>>>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
78937>>>>>>>>>>>>>>>            End
78937>>>>>>>>>>>>>>>>
78937>>>>>>>>>>>>>>>        End
78937>>>>>>>>>>>>>>>>
78937>>>>>>>>>>>>>>>        // set temporary format properties and exit
78937>>>>>>>>>>>>>>>        Set pbThousandsSep to bSep
78938>>>>>>>>>>>>>>>        Set psLeft         to sLeft
78939>>>>>>>>>>>>>>>        Set psRight        to sRight
78940>>>>>>>>>>>>>>>        Set piPoints       to iDigits
78941>>>>>>>>>>>>>>>    End_Procedure
78942>>>>>>>>>>>>>>>    
78942>>>>>>>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
78942>>>>>>>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
78942>>>>>>>>>>>>>>>    //
78942>>>>>>>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
78942>>>>>>>>>>>>>>>    Procedure SetFormat String sFmt Integer bCurrency
78944>>>>>>>>>>>>>>>        String sPos sNeg
78944>>>>>>>>>>>>>>>        Integer iPos
78944>>>>>>>>>>>>>>>        
78944>>>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
78945>>>>>>>>>>>>>>>        If iPos Begin
78947>>>>>>>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
78948>>>>>>>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
78949>>>>>>>>>>>>>>>        End
78949>>>>>>>>>>>>>>>>
78949>>>>>>>>>>>>>>>        Else Begin
78950>>>>>>>>>>>>>>>            Move sFmt         to sPos
78951>>>>>>>>>>>>>>>            Move ("-" + sFmt) to sNeg
78952>>>>>>>>>>>>>>>        End
78952>>>>>>>>>>>>>>>>
78952>>>>>>>>>>>>>>>        Send ParseFormat sPos
78953>>>>>>>>>>>>>>>        If bCurrency Begin
78955>>>>>>>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
78956>>>>>>>>>>>>>>>            Set psCurPosLeft         to (psLeft(Self))
78957>>>>>>>>>>>>>>>            Set psCurPosRight        to (psRight(Self))
78958>>>>>>>>>>>>>>>            Set piCurPosPoints       to (piPoints(Self))
78959>>>>>>>>>>>>>>>        End
78959>>>>>>>>>>>>>>>>
78959>>>>>>>>>>>>>>>        Else Begin
78960>>>>>>>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
78961>>>>>>>>>>>>>>>            Set psNumPosLeft         to (psLeft(Self))
78962>>>>>>>>>>>>>>>            Set psNumPosRight        to (psRight(Self))
78963>>>>>>>>>>>>>>>            Set piNumPosPoints       to (piPoints(Self))
78964>>>>>>>>>>>>>>>        End
78964>>>>>>>>>>>>>>>>
78964>>>>>>>>>>>>>>>        
78964>>>>>>>>>>>>>>>        Send ParseFormat sNeg
78965>>>>>>>>>>>>>>>        If bCurrency Begin
78967>>>>>>>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
78968>>>>>>>>>>>>>>>            Set psCurNegLeft         to (psLeft(Self))
78969>>>>>>>>>>>>>>>            Set psCurNegRight        to (psRight(Self))
78970>>>>>>>>>>>>>>>            Set piCurNegPoints       to (piPoints(Self))
78971>>>>>>>>>>>>>>>        End
78971>>>>>>>>>>>>>>>>
78971>>>>>>>>>>>>>>>        Else Begin
78972>>>>>>>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
78973>>>>>>>>>>>>>>>            Set psNumNegLeft         to (psLeft(Self))
78974>>>>>>>>>>>>>>>            Set psNumNegRight        to (psRight(Self))
78975>>>>>>>>>>>>>>>            Set piNumNegPoints       to (piPoints(Self))
78976>>>>>>>>>>>>>>>        End
78976>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>    End_Procedure
78977>>>>>>>>>>>>>>>    
78977>>>>>>>>>>>>>>>    // low level formatting. Pass parameters
78977>>>>>>>>>>>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
78979>>>>>>>>>>>>>>>        String  sLeft sRight sNumber sSep sDec
78979>>>>>>>>>>>>>>>        Integer iDec iLen iCh
78979>>>>>>>>>>>>>>>        
78979>>>>>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
78982>>>>>>>>>>>>>>>        Move (Character(iCh)) to sDec
78983>>>>>>>>>>>>>>>        
78983>>>>>>>>>>>>>>>        Move (abs(nNumber)) to sNumber
78984>>>>>>>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
78985>>>>>>>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
78986>>>>>>>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
78987>>>>>>>>>>>>>>>        // format for decimal separator
78987>>>>>>>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
78990>>>>>>>>>>>>>>>        
78990>>>>>>>>>>>>>>>        // format for thousand sep.
78990>>>>>>>>>>>>>>>        If bSep Begin
78992>>>>>>>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
78995>>>>>>>>>>>>>>>            Move (Character(iCh)) to sSep
78996>>>>>>>>>>>>>>>            Move (Length(sLeft)) to iLen
78997>>>>>>>>>>>>>>>            While (iLen>3)
79001>>>>>>>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
79002>>>>>>>>>>>>>>>                Move (iLen-3) to iLen
79003>>>>>>>>>>>>>>>            Loop
79004>>>>>>>>>>>>>>>>
79004>>>>>>>>>>>>>>>        End
79004>>>>>>>>>>>>>>>>
79004>>>>>>>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
79004>>>>>>>>>>>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
79007>>>>>>>>>>>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
79008>>>>>>>>>>>>>>>    End_Function
79009>>>>>>>>>>>>>>>    
79009>>>>>>>>>>>>>>>    // Public: Format for currency
79009>>>>>>>>>>>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
79011>>>>>>>>>>>>>>>        String  sLeft sRight
79011>>>>>>>>>>>>>>>        Integer bSep
79011>>>>>>>>>>>>>>>        If (nNumber<0) Begin
79013>>>>>>>>>>>>>>>            Get pbCurNegThousandsSep to bSep
79014>>>>>>>>>>>>>>>            Get psCurNegLeft         to sLeft
79015>>>>>>>>>>>>>>>            Get psCurNegRight        to sRight
79016>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
79019>>>>>>>>>>>>>>>        End
79019>>>>>>>>>>>>>>>>
79019>>>>>>>>>>>>>>>        Else Begin
79020>>>>>>>>>>>>>>>            Get pbCurPosThousandsSep to bSep
79021>>>>>>>>>>>>>>>            Get psCurPosLeft         to sLeft
79022>>>>>>>>>>>>>>>            Get psCurPosRight        to sRight
79023>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
79026>>>>>>>>>>>>>>>        End
79026>>>>>>>>>>>>>>>>
79026>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79027>>>>>>>>>>>>>>>    End_Function
79028>>>>>>>>>>>>>>>    
79028>>>>>>>>>>>>>>>    // Public: Format for numeric
79028>>>>>>>>>>>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
79030>>>>>>>>>>>>>>>        String  sLeft sRight
79030>>>>>>>>>>>>>>>        Integer bSep
79030>>>>>>>>>>>>>>>        If (nNumber<0) Begin
79032>>>>>>>>>>>>>>>            Get pbNumNegThousandsSep to bSep
79033>>>>>>>>>>>>>>>            Get psNumNegLeft         to sLeft
79034>>>>>>>>>>>>>>>            Get psNumNegRight        to sRight
79035>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
79038>>>>>>>>>>>>>>>        End
79038>>>>>>>>>>>>>>>>
79038>>>>>>>>>>>>>>>        Else Begin
79039>>>>>>>>>>>>>>>            Get pbNumPosThousandsSep to bSep
79040>>>>>>>>>>>>>>>            Get psNumPosLeft         to sLeft
79041>>>>>>>>>>>>>>>            Get psNumPosRight        to sRight
79042>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
79045>>>>>>>>>>>>>>>        End
79045>>>>>>>>>>>>>>>>
79045>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79046>>>>>>>>>>>>>>>    End_Function
79047>>>>>>>>>>>>>>>    
79047>>>>>>>>>>>>>>>    
79047>>>>>>>>>>>>>>>    // Public: Format passing format string
79047>>>>>>>>>>>>>>>    Function FormatVal Number nNumber String sFmt Returns String
79049>>>>>>>>>>>>>>>        Integer iPos bIsNeg
79049>>>>>>>>>>>>>>>        String  sLeft sRight
79049>>>>>>>>>>>>>>>        Integer iPoints bSep
79049>>>>>>>>>>>>>>>        Move (nNumber<0) to bIsNeg
79050>>>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
79051>>>>>>>>>>>>>>>        Case Begin
79051>>>>>>>>>>>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
79054>>>>>>>>>>>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
79058>>>>>>>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
79062>>>>>>>>>>>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
79064>>>>>>>>>>>>>>>        Case End
79064>>>>>>>>>>>>>>>        Send ParseFormat sFmt
79065>>>>>>>>>>>>>>>        Get pbThousandsSep to bSep
79066>>>>>>>>>>>>>>>        Get psLeft         to sLeft
79067>>>>>>>>>>>>>>>        Get psRight        to sRight
79068>>>>>>>>>>>>>>>        Get piPoints       to iPoints
79069>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79070>>>>>>>>>>>>>>>    End_Function
79071>>>>>>>>>>>>>>>    
79071>>>>>>>>>>>>>>>End_Class
79072>>>>>>>>>>>>>
79072>>>>>>>>>>>>>Global_Variable Handle ghoFormatter
79072>>>>>>>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
79073>>>>>>>>>>>>>
79073>>>>>>>>>>>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
79075>>>>>>>>>>>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
79076>>>>>>>>>>>>>End_Function
79077>>>>>>>>>>>>>
79077>>>>>>>>>>>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
79079>>>>>>>>>>>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
79080>>>>>>>>>>>>>End_Function
79081>>>>>>>>>>>>>
79081>>>>>>>>>>>>>Function FormatValue Global Number nNum String sFmt Returns String
79083>>>>>>>>>>>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
79084>>>>>>>>>>>>>End_Function
79085>>>>>>>>>>>>>
79085>>>>>>>>>>>>>Procedure SetCurrencyFormat Global String sFmt
79087>>>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt True
79088>>>>>>>>>>>>>End_Procedure
79089>>>>>>>>>>>>>
79089>>>>>>>>>>>>>Procedure SetNumberFormat Global String sFmt
79091>>>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt False
79092>>>>>>>>>>>>>End_Procedure
79093>>>>>>>>>>>>>
79093>>>>>>>>>>>>>
79093>>>>>>>>>>>Use tWinStructs.pkg
79093>>>>>>>>>>>
79093>>>>>>>>>>>Use cli.pkg
79093>>>>>>>>>>>Use DFBTRDRV.PKG
79093>>>>>>>>>>>Use MSSqldrv.pkg
79093>>>>>>>>>>>Use db2_drv.pkg
79093>>>>>>>>>>>Use odbc_drv.pkg
79093>>>>>>>>>>>Use seq_chnl.pkg
79093>>>>>>>>>>>
79093>>>>>>>>>>>Register_Function phoWorkspace Returns Handle
79093>>>>>>>>>>>Register_Function Help_filename Returns String
79093>>>>>>>>>>>Register_Function GetHelpFile Returns String
79093>>>>>>>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
79093>>>>>>>>>>>
79093>>>>>>>>>>>// *** Constant Declarations: ***
79093>>>>>>>>>>>//
79093>>>>>>>>>>>
79093>>>>>>>>>>>
79093>>>>>>>>>>>
79093>>>>>>>>>>>
79093>>>>>>>>>>>
79093>>>>>>>>>>>
79093>>>>>>>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
79093>>>>>>>>>>>
79093>>>>>>>>>>>
79093>>>>>>>>>>>
79093>>>>>>>>>>>
79093>>>>>>>>>>>
79093>>>>>>>>>>>
79093>>>>>>>>>>>
79093>>>>>>>>>>>
79093>>>>>>>>>>>
79093>>>>>>>>>>>// System icon menu constants. If the upper left hand
79093>>>>>>>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
79093>>>>>>>>>>>    Define SC_RESTORE  for |CI$F120
79093>>>>>>>>>>>    Define SC_MOVE     for |CI$F010
79093>>>>>>>>>>>    Define SC_SIZE     for |CI$F000
79093>>>>>>>>>>>    Define SC_MINIMIZE for |CI$F020
79093>>>>>>>>>>>    Define SC_MAXIMIZE for |CI$F030
79093>>>>>>>>>>>    Define SC_CLOSE    for |CI$F060
79093>>>>>>>>>>>    Define SC_KEYMENU  for |CI$F100
79093>>>>>>>>>>>    Define SC_NEXTWINDOW for |CI$F040
79093>>>>>>>>>>>    Define SC_PREVWINDOW for |CI$F050
79093>>>>>>>>>>>
79093>>>>>>>>>>>Define CS_SignProgram        for "signtool.exe"
79093>>>>>>>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
79093>>>>>>>>>>>Define CS_VerifyCredentials  for "verify"
79093>>>>>>>>>>>Define CS_VerifyFileParam    for "/a"
79093>>>>>>>>>>>Define CS_DefAuthVerPolicy   for "/pa"
79093>>>>>>>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
79093>>>>>>>>>>>
79093>>>>>>>>>>>// *** Struct Declarations: ***
79093>>>>>>>>>>>Struct AboutSHELLEXECUTEINFO
79093>>>>>>>>>>>    DWord   cbSize
79093>>>>>>>>>>>    Integer fMask
79093>>>>>>>>>>>    Handle  hwnd
79093>>>>>>>>>>>    Pointer lpVerb
79093>>>>>>>>>>>    Pointer lpFile
79093>>>>>>>>>>>    Pointer lpParameters
79093>>>>>>>>>>>    Pointer lpDirectory
79093>>>>>>>>>>>    Integer nShow
79093>>>>>>>>>>>    Integer iMissingAlignment1
79093>>>>>>>>>>>    Pointer hInstApp
79093>>>>>>>>>>>    Pointer lpIDList
79093>>>>>>>>>>>    Pointer lpClass
79093>>>>>>>>>>>    Handle  hkeyClass
79093>>>>>>>>>>>    DWord   dwHotKey
79093>>>>>>>>>>>    Integer iMissingAlignment2
79093>>>>>>>>>>>    Handle  hIconMonitor // Union
79093>>>>>>>>>>>    //Handle  hMonitor     // Union
79093>>>>>>>>>>>    Handle  hProcess
79093>>>>>>>>>>>End_Struct
79093>>>>>>>>>>>
79093>>>>>>>>>>>
79093>>>>>>>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
79093>>>>>>>>>>>//Type MEMORYSTATUS
79093>>>>>>>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
79093>>>>>>>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
79093>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
79093>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
79093>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
79093>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
79093>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
79093>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
79093>>>>>>>>>>>//End_Type
79093>>>>>>>>>>>
79093>>>>>>>>>>>// *** External Function calls: ***
79093>>>>>>>>>>>//
79093>>>>>>>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
79094>>>>>>>>>>>
79094>>>>>>>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
79095>>>>>>>>>>>
79095>>>>>>>>>>>// Do not call directly, use the wrapper function instead
79095>>>>>>>>>>>External_Function WNetGetUserW "WNetGetUserW" MPR.DLL ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
79096>>>>>>>>>>>
79096>>>>>>>>>>>    // Wrapper Function WNetGetUser
79096>>>>>>>>>>>    Function WNetGetUser Global ;        Pointer lpName ;        Pointer lpUser_Name ;        Pointer lpLength ;        Returns DWord
79098>>>>>>>>>>>
79098>>>>>>>>>>>        DWord   dwResult
79098>>>>>>>>>>>        UWide   uwName uwUserName
79098>>>>>>>>>>>        UWide   uwName uwUserName
79098>>>>>>>>>>>
79098>>>>>>>>>>>        Send StringToWide lpName (&uwName)
79099>>>>>>>>>>>
79099>>>>>>>>>>>        Send WideSetBuffer lpUser_Name lpLength (&uwUserName)
79100>>>>>>>>>>>
79100>>>>>>>>>>>        Move (WNetGetUserW (uwName.lpUText, uwUserName.lpUText, lpLength)) to dwResult
79101>>>>>>>>>>>
79101>>>>>>>>>>>        Send WideToString (&uwUserName) lpUser_Name
79102>>>>>>>>>>>
79102>>>>>>>>>>>        Function_Return dwResult
79103>>>>>>>>>>>    End_Function
79104>>>>>>>>>>>
79104>>>>>>>>>>>
79104>>>>>>>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
79105>>>>>>>>>>>
79105>>>>>>>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
79106>>>>>>>>>>>
79106>>>>>>>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
79107>>>>>>>>>>>
79107>>>>>>>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
79108>>>>>>>>>>>
79108>>>>>>>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
79109>>>>>>>>>>>
79109>>>>>>>>>>>// *** Global/Desktop Function Declarations: ***
79109>>>>>>>>>>>
79109>>>>>>>>>>>Function ComputerName Desktop Returns String
79111>>>>>>>>>>>    String sName
79111>>>>>>>>>>>    Get_Environment "COMPUTERNAME" to sName
79112>>>>>>>>>>>>
79112>>>>>>>>>>>    Function_Return sName
79113>>>>>>>>>>>End_Function
79114>>>>>>>>>>>
79114>>>>>>>>>>>Function Network_User_Name Desktop Returns String
79116>>>>>>>>>>>    WString wName
79116>>>>>>>>>>>    Integer iRetval iLength
79116>>>>>>>>>>>
79116>>>>>>>>>>>    Move 0 to iLength
79117>>>>>>>>>>>    Move (WNetGetUserW (0, 0, AddressOf (iLength))) to iRetval
79118>>>>>>>>>>>    Move (ZeroString(iLength)) to wName
79119>>>>>>>>>>>    Move (WNetGetUserW (0, AddressOf (wName), AddressOf (iLength))) to iRetval
79120>>>>>>>>>>>
79120>>>>>>>>>>>    If (iRetval = NO_ERROR) Begin
79122>>>>>>>>>>>        Function_Return (CString (wName))
79123>>>>>>>>>>>    End
79123>>>>>>>>>>>>
79123>>>>>>>>>>>
79123>>>>>>>>>>>    Function_Return "User Unknown"
79124>>>>>>>>>>>End_Function
79125>>>>>>>>>>>
79125>>>>>>>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
79127>>>>>>>>>>>    String sClient sDriver sClientDriver
79127>>>>>>>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
79127>>>>>>>>>>>    Handle hoMsqlDrv
79127>>>>>>>>>>>
79127>>>>>>>>>>>    Move 0 to iDriver
79128>>>>>>>>>>>    Move "" to sClient
79129>>>>>>>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
79132>>>>>>>>>>>    For iCount from 1 to iNumberOfDrivers
79138>>>>>>>>>>>>
79138>>>>>>>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
79141>>>>>>>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
79143>>>>>>>>>>>            Move iCount to iDriver
79144>>>>>>>>>>>            Move iNumberOfDrivers to iCount // We're done.
79145>>>>>>>>>>>        End
79145>>>>>>>>>>>>
79145>>>>>>>>>>>    Loop
79146>>>>>>>>>>>>
79146>>>>>>>>>>>
79146>>>>>>>>>>>    // This info is (at current) only available for the MS SQL driver:
79146>>>>>>>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
79148>>>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
79151>>>>>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
79152>>>>>>>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
79153>>>>>>>>>>>        Send Destroy of hoMsqlDrv
79154>>>>>>>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
79155>>>>>>>>>>>    End
79155>>>>>>>>>>>>
79155>>>>>>>>>>>
79155>>>>>>>>>>>    Function_Return sClient
79156>>>>>>>>>>>End_Function
79157>>>>>>>>>>>
79157>>>>>>>>>>>// *** Class Declarations: ***
79157>>>>>>>>>>>//
79157>>>>>>>>>>>Class cBitmapContainerDFLink is a BitmapContainer
79158>>>>>>>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
79160>>>>>>>>>>>        Send Mouse_Up iWindowNumber iPosition
79161>>>>>>>>>>>    End_Procedure
79162>>>>>>>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
79164>>>>>>>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
79166>>>>>>>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
79167>>>>>>>>>>>    End_Procedure
79168>>>>>>>>>>>End_Class
79169>>>>>>>>>>>
79169>>>>>>>>>>>Class cCopyEditorContentButton is a Button
79170>>>>>>>>>>>    Procedure Construct_Object
79172>>>>>>>>>>>        Forward Send Construct_Object
79174>>>>>>>>>>>        Property Handle phoEditorHandle
79175>>>>>>>>>>>        Set psToolTip to C_$DescCopy
79176>>>>>>>>>>>    End_Procedure
79177>>>>>>>>>>>
79177>>>>>>>>>>>    Procedure CopyToWindowsClipboard
79179>>>>>>>>>>>        Handle hoEditor
79179>>>>>>>>>>>        Boolean bCanCopy
79179>>>>>>>>>>>        Address aEditorAddress
79179>>>>>>>>>>>
79179>>>>>>>>>>>        Get phoEditorHandle to hoEditor
79180>>>>>>>>>>>        Send Select_All of hoEditor
79181>>>>>>>>>>>        Get CanCopy of hoEditor to bCanCopy
79182>>>>>>>>>>>        If (bCanCopy = True) Begin
79184>>>>>>>>>>>            Get paValue of hoEditor to aEditorAddress
79185>>>>>>>>>>>            Send Copy   of hoEditor
79186>>>>>>>>>>>            // Remove the selection after text is copied to the clipboard.
79186>>>>>>>>>>>            Send Beginning_of_Data of hoEditor
79187>>>>>>>>>>>            Send Info_Box C_$CopyToClipboard_Text
79188>>>>>>>>>>>        End
79188>>>>>>>>>>>>
79188>>>>>>>>>>>    End_Procedure
79189>>>>>>>>>>>End_Class
79190>>>>>>>>>>>
79190>>>>>>>>>>>Class SysinfoDisplay is a cTextEdit
79191>>>>>>>>>>>    Procedure Construct_Object
79193>>>>>>>>>>>        Forward Send Construct_Object
79195>>>>>>>>>>>
79195>>>>>>>>>>>        Set Size to 100 245
79196>>>>>>>>>>>        Set Location to 6 6
79197>>>>>>>>>>>        Set Border_Style to Border_None
79198>>>>>>>>>>>        Set Read_Only_State to True
79199>>>>>>>>>>>        Set pbWrap to True
79200>>>>>>>>>>>        Set peAnchors to anAll
79201>>>>>>>>>>>    End_Procedure
79202>>>>>>>>>>>
79202>>>>>>>>>>>    // Augmented class message to adjust certain text strings that are wrong...
79202>>>>>>>>>>>
79202>>>>>>>>>>>    Procedure AppendTextLn String sText
79204>>>>>>>>>>>        String sWorkspaceWSFile
79204>>>>>>>>>>>
79204>>>>>>>>>>>        // Only works for English:
79204>>>>>>>>>>>        If (ghoApplication > 0) Begin
79206>>>>>>>>>>>            If (sText contains "Workspace Name") Begin
79208>>>>>>>>>>>                Move "Workspace Config Filename:" to sText
79209>>>>>>>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
79210>>>>>>>>>>>                Move (sText * sWorkspaceWSFile) to sText
79211>>>>>>>>>>>            End
79211>>>>>>>>>>>>
79211>>>>>>>>>>>        End
79211>>>>>>>>>>>>
79211>>>>>>>>>>>        Send AppendText sText
79212>>>>>>>>>>>        Send AppendText (character(10))
79213>>>>>>>>>>>    End_Procedure
79214>>>>>>>>>>>
79214>>>>>>>>>>>    //    This method will show the name Of the current directory in the system
79214>>>>>>>>>>>    //    information box
79214>>>>>>>>>>>    Procedure Show_Current_Directory
79216>>>>>>>>>>>        String sDir
79216>>>>>>>>>>>
79216>>>>>>>>>>>        Get_Current_Directory To sDir
79217>>>>>>>>>>>
79217>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
79218>>>>>>>>>>>    End_Procedure
79219>>>>>>>>>>>
79219>>>>>>>>>>>    Procedure Show_Windows_Directory
79221>>>>>>>>>>>        String sWindir
79221>>>>>>>>>>>
79221>>>>>>>>>>>        Get_Windows_Directory To sWindir
79222>>>>>>>>>>>
79222>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
79223>>>>>>>>>>>    End_Procedure
79224>>>>>>>>>>>
79224>>>>>>>>>>>    Procedure Show_Current_User
79226>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
79227>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
79228>>>>>>>>>>>    End_Procedure
79229>>>>>>>>>>>
79229>>>>>>>>>>>    Procedure Show_Number_Format
79231>>>>>>>>>>>        Integer iFormat
79231>>>>>>>>>>>        String sFormatText
79231>>>>>>>>>>>
79231>>>>>>>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
79234>>>>>>>>>>>        Move (Character (iFormat)) To sFormatText
79235>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
79236>>>>>>>>>>>
79236>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
79239>>>>>>>>>>>        Move (Character (iFormat)) to sFormatText
79240>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
79241>>>>>>>>>>>    End_Procedure
79242>>>>>>>>>>>
79242>>>>>>>>>>>    Procedure Show_Filelist_Name
79244>>>>>>>>>>>        String sFilename
79244>>>>>>>>>>>
79244>>>>>>>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
79247>>>>>>>>>>>
79247>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
79248>>>>>>>>>>>    End_Procedure
79249>>>>>>>>>>>
79249>>>>>>>>>>>    Procedure Show_Lock_Delay
79251>>>>>>>>>>>        Integer iLockdelay
79251>>>>>>>>>>>
79251>>>>>>>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
79254>>>>>>>>>>>
79254>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
79255>>>>>>>>>>>    End_Procedure
79256>>>>>>>>>>>
79256>>>>>>>>>>>    Procedure Show_Lock_Timeout
79258>>>>>>>>>>>        Integer iLockTimeout
79258>>>>>>>>>>>
79258>>>>>>>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
79261>>>>>>>>>>>
79261>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
79262>>>>>>>>>>>    End_Procedure
79263>>>>>>>>>>>
79263>>>>>>>>>>>    Procedure Show_Screen_Size
79265>>>>>>>>>>>        Integer iYscreensize iXscreensize
79265>>>>>>>>>>>
79265>>>>>>>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
79266>>>>>>>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
79267>>>>>>>>>>>
79267>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
79268>>>>>>>>>>>    End_Procedure
79269>>>>>>>>>>>
79269>>>>>>>>>>>    Procedure Show_Page_Size
79271>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
79272>>>>>>>>>>>    End_procedure
79273>>>>>>>>>>>
79273>>>>>>>>>>>    Procedure Show_Date
79275>>>>>>>>>>>        Date dToday
79275>>>>>>>>>>>
79275>>>>>>>>>>>        Move (CurrentDateTime()) to dToday
79276>>>>>>>>>>>
79276>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
79277>>>>>>>>>>>    End_procedure
79278>>>>>>>>>>>
79278>>>>>>>>>>>    Procedure Show_Date_Format
79280>>>>>>>>>>>        Integer iDateFormat
79280>>>>>>>>>>>        String sDateFormat
79280>>>>>>>>>>>
79280>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
79283>>>>>>>>>>>        Case Begin
79283>>>>>>>>>>>            Case (iDateFormat = DF_DATE_USA)
79285>>>>>>>>>>>                Move C_$USA To sDateFormat
79286>>>>>>>>>>>                Case Break
79287>>>>>>>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
79290>>>>>>>>>>>                Move C_$European To sDateFormat
79291>>>>>>>>>>>                Case Break
79292>>>>>>>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
79295>>>>>>>>>>>                Move C_$Military To sDateFormat
79296>>>>>>>>>>>                Case Break
79297>>>>>>>>>>>            Case Else
79297>>>>>>>>>>>                Move C_$UnknownDateType To sDateFormat
79298>>>>>>>>>>>                Case Break
79299>>>>>>>>>>>        Case End
79299>>>>>>>>>>>
79299>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
79300>>>>>>>>>>>    End_Procedure
79301>>>>>>>>>>>
79301>>>>>>>>>>>    // 2013-08-14 NGS
79301>>>>>>>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
79301>>>>>>>>>>>    Procedure Show_Systemresources
79303>>>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
79303>>>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
79303>>>>>>>>>>>        Integer iRetval
79303>>>>>>>>>>>        Number nValue
79303>>>>>>>>>>>        String sValue
79303>>>>>>>>>>>
79303>>>>>>>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
79304>>>>>>>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
79305>>>>>>>>>>>        If (iRetval = 0) Begin
79307>>>>>>>>>>>            Move (ShowLastError ()) to iRetval
79308>>>>>>>>>>>            Procedure_Return
79309>>>>>>>>>>>        End
79309>>>>>>>>>>>>
79309>>>>>>>>>>>
79309>>>>>>>>>>>        Send AppendTextLn ""
79310>>>>>>>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
79311>>>>>>>>>>>
79311>>>>>>>>>>>        // Show memory in Gigabytes:
79311>>>>>>>>>>>        Move (nValue/1024/1024/1024) to nValue
79312>>>>>>>>>>>        Move (Round(nValue)) to nValue
79313>>>>>>>>>>>        Get FormatNumber nValue 2 to sValue
79314>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
79315>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
79316>>>>>>>>>>>
79316>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
79316>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
79317>>>>>>>>>>>        Move (Round(nValue)) to nValue
79318>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79319>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
79320>>>>>>>>>>>
79320>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
79320>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
79321>>>>>>>>>>>        Move (Round(nValue)) to nValue
79322>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79323>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
79324>>>>>>>>>>>
79324>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
79324>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
79325>>>>>>>>>>>        Move (Round(nValue)) to nValue
79326>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79327>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
79328>>>>>>>>>>>
79328>>>>>>>>>>>        // Add an empty row after the memory information:
79328>>>>>>>>>>>        Send AppendTextLn ""
79329>>>>>>>>>>>    End_Procedure
79330>>>>>>>>>>>
79330>>>>>>>>>>>    Procedure Show_Registration
79332>>>>>>>>>>>        String sRegName
79332>>>>>>>>>>>        Integer iSN iUsersMax iUserCount
79332>>>>>>>>>>>
79332>>>>>>>>>>>        Registration sRegName iSN
79333>>>>>>>>>>>>
79333>>>>>>>>>>>        Get_Licensed_Max_Users to iUsersMax
79334>>>>>>>>>>>        Get_Current_User_Count to iUserCount
79335>>>>>>>>>>>
79335>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
79336>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
79337>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
79338>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
79339>>>>>>>>>>>    End_Procedure
79340>>>>>>>>>>>
79340>>>>>>>>>>>    //****************************************************************************
79340>>>>>>>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
79340>>>>>>>>>>>    // To the workspace object passing the an object and message To send back
79340>>>>>>>>>>>    // To this object. It is expected that the workspace object will send this
79340>>>>>>>>>>>    // message for every line Of information it wants displayed (passing the
79340>>>>>>>>>>>    // information To be displayed
79340>>>>>>>>>>>    //****************************************************************************
79340>>>>>>>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
79340>>>>>>>>>>>
79340>>>>>>>>>>>    Procedure Show_ServicePack
79342>>>>>>>>>>>        String sKey sVersion sDataFlex
79342>>>>>>>>>>>        Handle hoRegistry
79342>>>>>>>>>>>        Boolean bExists bOpened
79342>>>>>>>>>>>
79342>>>>>>>>>>>        Move "DataFlex"        to sDataFlex
79343>>>>>>>>>>>
79343>>>>>>>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
79344>>>>>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
79345>>>>>>>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
79346>>>>>>>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
79347>>>>>>>>>>>
79347>>>>>>>>>>>        If (bExists) Begin
79349>>>>>>>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79350>>>>>>>>>>>        End
79350>>>>>>>>>>>>
79350>>>>>>>>>>>        Else Begin
79351>>>>>>>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79352>>>>>>>>>>>        End
79352>>>>>>>>>>>>
79352>>>>>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
79353>>>>>>>>>>>        If (bExists) Begin
79355>>>>>>>>>>>            Get OpenKey of hoRegistry sKey to bOpened
79356>>>>>>>>>>>            If (bOpened) Begin
79358>>>>>>>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
79359>>>>>>>>>>>                If (bExists) Begin
79361>>>>>>>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
79362>>>>>>>>>>>                End
79362>>>>>>>>>>>>
79362>>>>>>>>>>>                Send CloseKey of hoRegistry
79363>>>>>>>>>>>            End
79363>>>>>>>>>>>>
79363>>>>>>>>>>>        End
79363>>>>>>>>>>>>
79363>>>>>>>>>>>        Send Destroy of hoRegistry
79364>>>>>>>>>>>
79364>>>>>>>>>>>        If (sVersion <> "") Begin
79366>>>>>>>>>>>           Send AppendTextLn sVersion
79367>>>>>>>>>>>           Send AppendTextLn ""
79368>>>>>>>>>>>        End
79368>>>>>>>>>>>>
79368>>>>>>>>>>>    End_Procedure
79369>>>>>>>>>>>
79369>>>>>>>>>>>    Procedure Show_WorkspaceInformation
79371>>>>>>>>>>>        Integer hoWorkspace
79371>>>>>>>>>>>
79371>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79373>>>>>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
79374>>>>>>>>>>>            If (hoWorkspace <> 0) Begin
79376>>>>>>>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
79377>>>>>>>>>>>            End
79377>>>>>>>>>>>>
79377>>>>>>>>>>>        End
79377>>>>>>>>>>>>
79377>>>>>>>>>>>    End_Procedure
79378>>>>>>>>>>>
79378>>>>>>>>>>>    //****************************************************************************
79378>>>>>>>>>>>    // If connection ids are used, we will send the message EnumerateConnections
79378>>>>>>>>>>>    // to the connection manager object passing the an object and message to send
79378>>>>>>>>>>>    // back to this object. It is expected that the connection manager object will
79378>>>>>>>>>>>    // send this message for every line Of information it wants displayed (passing
79378>>>>>>>>>>>    // the information To be displayed
79378>>>>>>>>>>>    //****************************************************************************
79378>>>>>>>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
79378>>>>>>>>>>>
79378>>>>>>>>>>>    Procedure Show_ConnectionIdInformation
79380>>>>>>>>>>>        If (ghoConnection > 0) Begin
79382>>>>>>>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
79383>>>>>>>>>>>            Send AppendTextLn ""
79384>>>>>>>>>>>        End
79384>>>>>>>>>>>>
79384>>>>>>>>>>>    End_Procedure
79385>>>>>>>>>>>
79385>>>>>>>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
79387>>>>>>>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
79388>>>>>>>>>>>    End_Function
79389>>>>>>>>>>>
79389>>>>>>>>>>>    Procedure Show_Versions
79391>>>>>>>>>>>        Integer iVersion iRevision iBuild
79391>>>>>>>>>>>
79391>>>>>>>>>>>        Version_information iVersion iRevision iBuild
79393>>>>>>>>>>>
79393>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
79394>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
79395>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
79396>>>>>>>>>>>        Send AppendTextLn "This is a 64-bit exe file"
79397>>>>>>>>>>>    End_Procedure
79398>>>>>>>>>>>
79398>>>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
79400>>>>>>>>>>>        Boolean bOK
79400>>>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
79401>>>>>>>>>>>        Function_Return bOK
79402>>>>>>>>>>>    End_Function
79403>>>>>>>>>>>
79403>>>>>>>>>>>    //***
79403>>>>>>>>>>>    //*** BW
79403>>>>>>>>>>>    //*** Procedure: Show_Drivers
79403>>>>>>>>>>>    //*** Purpose  : Show loaded database drivers
79403>>>>>>>>>>>    //***
79403>>>>>>>>>>>
79403>>>>>>>>>>>//#IF (Required_FMAC_Build > 106)
79403>>>>>>>>>>>//    #Warning -3
79403>>>>>>>>>>>//#ENDIF
79403>>>>>>>>>>>    Procedure Show_Drivers
79405>>>>>>>>>>>        String sDriverID sVersion sClient sValue
79405>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
79405>>>>>>>>>>>        Handle hoCLIHandler hoBtrvHandler
79405>>>>>>>>>>>        Boolean bStudioLicense bIsDAWDriver
79405>>>>>>>>>>>
79405>>>>>>>>>>>        Move False to bStudioLicense
79406>>>>>>>>>>>
79406>>>>>>>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
79407>>>>>>>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
79408>>>>>>>>>>>
79408>>>>>>>>>>>        // For testing purposes:
79408>>>>>>>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79408>>>>>>>>>>>//        Load_Driver MSSQLDRV_ID
79408>>>>>>>>>>>//        Load_Driver ODBC_DRV_ID
79408>>>>>>>>>>>//        Load_Driver DB2_DRV_ID
79408>>>>>>>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79408>>>>>>>>>>>//
79408>>>>>>>>>>>        Move False to Err
79409>>>>>>>>>>>
79409>>>>>>>>>>>        // Loop through all loaded drivers.
79409>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
79412>>>>>>>>>>>        If (iNumberOfDrivers > 1) Begin
79414>>>>>>>>>>>            Send AppendTextLn ""
79415>>>>>>>>>>>        End
79415>>>>>>>>>>>>
79415>>>>>>>>>>>        For iDriver from 1 to iNumberOfDrivers
79421>>>>>>>>>>>>
79421>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
79422>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
79425>>>>>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
79426>>>>>>>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
79427>>>>>>>>>>>
79427>>>>>>>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True) Begin
79429>>>>>>>>>>>
79429>>>>>>>>>>>                // Pervasive/Btrieve database
79429>>>>>>>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
79431>>>>>>>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
79432>>>>>>>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
79433>>>>>>>>>>>                    If (sClient <> "0.0.0") Begin
79435>>>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
79436>>>>>>>>>>>                    End
79436>>>>>>>>>>>>
79436>>>>>>>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
79437>>>>>>>>>>>                    If (sClient <> "0.0.0") Begin
79439>>>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
79440>>>>>>>>>>>                    End
79440>>>>>>>>>>>>
79440>>>>>>>>>>>                End
79440>>>>>>>>>>>>
79440>>>>>>>>>>>
79440>>>>>>>>>>>                Else Begin
79441>>>>>>>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
79442>>>>>>>>>>>                    Move 0 to iNumServers
79443>>>>>>>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
79445>>>>>>>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
79448>>>>>>>>>>>                    End
79448>>>>>>>>>>>>
79448>>>>>>>>>>>
79448>>>>>>>>>>>                    If (bIsDAWDriver = True) Begin
79450>>>>>>>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
79452>>>>>>>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
79453>>>>>>>>>>>                        End
79453>>>>>>>>>>>>
79453>>>>>>>>>>>                        Get CKRevision of hoCLIHandler to sVersion
79454>>>>>>>>>>>                    End
79454>>>>>>>>>>>>
79454>>>>>>>>>>>
79454>>>>>>>>>>>                    // If the serialnumber is = 0, it means that the
79454>>>>>>>>>>>                    // Studio licens is in use and there is no
79454>>>>>>>>>>>                    // number of max users defined because the driver is
79454>>>>>>>>>>>                    // relying on the info from the VDF license.
79454>>>>>>>>>>>                    If (bStudioLicense = False) Begin
79456>>>>>>>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
79457>>>>>>>>>>>                        Move (iSerialNo = 0) to bStudioLicense
79458>>>>>>>>>>>                    End
79458>>>>>>>>>>>>
79458>>>>>>>>>>>                End
79458>>>>>>>>>>>>
79458>>>>>>>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
79459>>>>>>>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
79461>>>>>>>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
79462>>>>>>>>>>>                End
79462>>>>>>>>>>>>
79462>>>>>>>>>>>                If (iNumServers <> 0) Begin
79464>>>>>>>>>>>                    For iCount from 1 to iNumServers
79470>>>>>>>>>>>>
79470>>>>>>>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
79473>>>>>>>>>>>                        If (not(sValue contains ";PWD=")) Begin
79475>>>>>>>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
79476>>>>>>>>>>>                        End
79476>>>>>>>>>>>>
79476>>>>>>>>>>>                    Loop
79477>>>>>>>>>>>>
79477>>>>>>>>>>>                End
79477>>>>>>>>>>>>
79477>>>>>>>>>>>            End
79477>>>>>>>>>>>>
79477>>>>>>>>>>>        Loop
79478>>>>>>>>>>>>
79478>>>>>>>>>>>
79478>>>>>>>>>>>        Send AppendTextLn ""
79479>>>>>>>>>>>        If (bStudioLicense = False) Begin
79481>>>>>>>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
79482>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
79483>>>>>>>>>>>        End
79483>>>>>>>>>>>>
79483>>>>>>>>>>>        Else Begin
79484>>>>>>>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
79485>>>>>>>>>>>        End
79485>>>>>>>>>>>>
79485>>>>>>>>>>>        Send Destroy of hoCLIHandler
79486>>>>>>>>>>>        Send Destroy of hoBtrvHandler
79487>>>>>>>>>>>    End_Procedure
79488>>>>>>>>>>>
79488>>>>>>>>>>>    Procedure Show_HelpFile
79490>>>>>>>>>>>        String sHelpFile
79490>>>>>>>>>>>        Integer eHelpType
79490>>>>>>>>>>>
79490>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79492>>>>>>>>>>>            Get peHelpType Of ghoApplication To eHelpType
79493>>>>>>>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
79495>>>>>>>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
79496>>>>>>>>>>>            End
79496>>>>>>>>>>>>
79496>>>>>>>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
79499>>>>>>>>>>>                Get Help_filename Of Help_object_id To sHelpFile
79500>>>>>>>>>>>            End
79500>>>>>>>>>>>>
79500>>>>>>>>>>>            Else Begin
79501>>>>>>>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
79502>>>>>>>>>>>            End
79502>>>>>>>>>>>>
79502>>>>>>>>>>>
79502>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
79503>>>>>>>>>>>        End
79503>>>>>>>>>>>>
79503>>>>>>>>>>>    End_Procedure
79504>>>>>>>>>>>
79504>>>>>>>>>>>    Procedure Show_EnterAsTab
79506>>>>>>>>>>>        Boolean bEnterKeyAsTabKey
79506>>>>>>>>>>>        String sText
79506>>>>>>>>>>>
79506>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79508>>>>>>>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
79509>>>>>>>>>>>            If (bEnterKeyAsTabKey) Begin
79511>>>>>>>>>>>                Move "True" To sText
79512>>>>>>>>>>>            End
79512>>>>>>>>>>>>
79512>>>>>>>>>>>            Else Begin
79513>>>>>>>>>>>                Move "False" To sText
79514>>>>>>>>>>>            End
79514>>>>>>>>>>>>
79514>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
79515>>>>>>>>>>>        End
79515>>>>>>>>>>>>
79515>>>>>>>>>>>    End_Procedure
79516>>>>>>>>>>>
79516>>>>>>>>>>>    //    During activation we will remove the old information and add the newly
79516>>>>>>>>>>>    //    found systeminformation
79516>>>>>>>>>>>    Procedure Add_Focus Integer hoRoot
79518>>>>>>>>>>>        Forward Send Add_Focus hoRoot
79520>>>>>>>>>>>
79520>>>>>>>>>>>        Send Delete_Data
79521>>>>>>>>>>>
79521>>>>>>>>>>>        Set Changed_State To False
79522>>>>>>>>>>>        Set Read_Only_State To True
79523>>>>>>>>>>>
79523>>>>>>>>>>>        Send Show_Registration
79524>>>>>>>>>>>        Send Show_Drivers
79525>>>>>>>>>>>        Send Show_ServicePack
79526>>>>>>>>>>>        Send Show_Versions
79527>>>>>>>>>>>        Send AppendTextLn ""
79528>>>>>>>>>>>
79528>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79530>>>>>>>>>>>            Send Show_WorkSpaceInformation
79531>>>>>>>>>>>            Send Show_HelpFile
79532>>>>>>>>>>>            Send AppendTextLn ""
79533>>>>>>>>>>>        End
79533>>>>>>>>>>>>
79533>>>>>>>>>>>        Else Begin
79534>>>>>>>>>>>            Send AppendTextLn ""
79535>>>>>>>>>>>        End
79535>>>>>>>>>>>>
79535>>>>>>>>>>>
79535>>>>>>>>>>>        If (ghoConnection <> 0) Begin
79537>>>>>>>>>>>            Send Show_ConnectionIdInformation
79538>>>>>>>>>>>        End
79538>>>>>>>>>>>>
79538>>>>>>>>>>>
79538>>>>>>>>>>>        Send Show_Current_User
79539>>>>>>>>>>>        Send Show_Windows_Directory
79540>>>>>>>>>>>        Send Show_Current_Directory
79541>>>>>>>>>>>
79541>>>>>>>>>>>        // This is already shown in the workspace details,
79541>>>>>>>>>>>        // unless no workspace object is present:
79541>>>>>>>>>>>        If (ghoApplication = 0) Begin
79543>>>>>>>>>>>            Send Show_Filelist_Name
79544>>>>>>>>>>>        End
79544>>>>>>>>>>>>
79544>>>>>>>>>>>
79544>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79546>>>>>>>>>>>            Send AppendTextLn ""
79547>>>>>>>>>>>            Send Show_EnterAsTab
79548>>>>>>>>>>>        End
79548>>>>>>>>>>>>
79548>>>>>>>>>>>
79548>>>>>>>>>>>        Send Show_Screen_Size
79549>>>>>>>>>>>        Send Show_Page_Size
79550>>>>>>>>>>>        Send Show_Number_Format
79551>>>>>>>>>>>        Send Show_Date_Format
79552>>>>>>>>>>>        Send Show_Lock_Delay
79553>>>>>>>>>>>        Send Show_Lock_Timeout
79554>>>>>>>>>>>        Send Show_Date
79555>>>>>>>>>>>        Send Show_Systemresources
79556>>>>>>>>>>>        Send Beginning_of_Data
79557>>>>>>>>>>>
79557>>>>>>>>>>>        Set Icon to 'default.ico'
79558>>>>>>>>>>>    End_Procedure
79559>>>>>>>>>>>End_Class
79560>>>>>>>>>>>
79560>>>>>>>>>>>Class SysInfoDialog is a ModalPanel
79561>>>>>>>>>>>    Procedure Construct_Object
79563>>>>>>>>>>>        Forward Send Construct_Object
79565>>>>>>>>>>>
79565>>>>>>>>>>>        Set Label to C_$SystemInformation
79566>>>>>>>>>>>        Set Size to 140 267
79567>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79568>>>>>>>>>>>        Set Border_Style to Border_Thick
79569>>>>>>>>>>>        Set Sysmenu_Icon to False
79570>>>>>>>>>>>
79570>>>>>>>>>>>        // "+1" will make the panel to paint correctly.
79570>>>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
79571>>>>>>>>>>>
79571>>>>>>>>>>>        // 2014-09-14 NGS
79571>>>>>>>>>>>        // Added a container object around the cTexteditor
79571>>>>>>>>>>>        // object to get a border around the text.
79571>>>>>>>>>>>        Object oSysinfoDisplayContainer is a Container3d
79573>>>>>>>>>>>            Set Location to 2 4
79574>>>>>>>>>>>            Set Size to 110 255
79575>>>>>>>>>>>            Set Border_Style to Border_ClientEdge
79576>>>>>>>>>>>            Set Color to clWhite
79577>>>>>>>>>>>            Set peAnchors to anAll
79578>>>>>>>>>>>
79578>>>>>>>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
79580>>>>>>>>>>>            End_Object
79581>>>>>>>>>>>
79581>>>>>>>>>>>        End_Object
79582>>>>>>>>>>>
79582>>>>>>>>>>>        Object oCloseButton is a Button
79584>>>>>>>>>>>            Set Label to C_$Close
79585>>>>>>>>>>>            Set Location to 120 210
79586>>>>>>>>>>>            CompilerWarnings Off
79586>>>>>>>>>>>            Set Message Item 0 to msg_Close_Panel
79587>>>>>>>>>>>            CompilerWarnings On
79587>>>>>>>>>>>            Set Default_State To True
79588>>>>>>>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
79588>>>>>>>>>>>            // and changes its peAnchors, we might as well prepare this object
79588>>>>>>>>>>>            // for that situation.
79588>>>>>>>>>>>            Set peAnchors to anBottomRight
79589>>>>>>>>>>>        End_Object
79590>>>>>>>>>>>
79590>>>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79592>>>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79593>>>>>>>>>>>            Set Size to 14 50
79594>>>>>>>>>>>            Set Location to 120 158
79595>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79595>>>>>>>>>>>            // we might as well prepare the object for it.
79595>>>>>>>>>>>            Set peAnchors to anBottomRight
79596>>>>>>>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
79597>>>>>>>>>>>        End_Object
79598>>>>>>>>>>>
79598>>>>>>>>>>>        On_Key kCancel Send Close_Panel
79599>>>>>>>>>>>    End_Procedure
79600>>>>>>>>>>>
79600>>>>>>>>>>>    Procedure Page Integer iPageObject
79602>>>>>>>>>>>        Handle hMenu
79602>>>>>>>>>>>        Integer iPrevState
79602>>>>>>>>>>>
79602>>>>>>>>>>>        Forward Send Page iPageObject
79604>>>>>>>>>>>
79604>>>>>>>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
79604>>>>>>>>>>>        //
79604>>>>>>>>>>>    End_Procedure
79605>>>>>>>>>>>
79605>>>>>>>>>>>End_Class
79606>>>>>>>>>>>
79606>>>>>>>>>>>Class cAboutEdit is an cRichEdit
79607>>>>>>>>>>>    Procedure Construct_Object
79609>>>>>>>>>>>        Forward Send Construct_Object
79611>>>>>>>>>>>
79611>>>>>>>>>>>        Property String psContentText
79612>>>>>>>>>>>
79612>>>>>>>>>>>        Set Size to 77 153
79613>>>>>>>>>>>        Set Location to 8 60
79614>>>>>>>>>>>        Set Read_Only_State to True
79615>>>>>>>>>>>        Set Skip_State to True
79616>>>>>>>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
79616>>>>>>>>>>>        // or 1/20 of a printer's point.
79616>>>>>>>>>>>        Set piRightMargin to (0.1 * 1440)
79617>>>>>>>>>>>        Set Border_Style  to Border_None
79618>>>>>>>>>>>    End_Procedure
79619>>>>>>>>>>>
79619>>>>>>>>>>>    // Adds a line of text to the edit object
79619>>>>>>>>>>>    Procedure Add_Line String sText
79621>>>>>>>>>>>        String sContentText
79621>>>>>>>>>>>        Get psContentText to sContentText
79622>>>>>>>>>>>        Move (sContentText + String(sText)) to sContentText
79623>>>>>>>>>>>        Set psContentText to sContentText
79624>>>>>>>>>>>    End_Procedure
79625>>>>>>>>>>>
79625>>>>>>>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
79625>>>>>>>>>>>    // Note that we use a property psContentText and add to it,
79625>>>>>>>>>>>    // because the object isn't paged yet when we add these
79625>>>>>>>>>>>    // values and the COM edit object needs to be paged
79625>>>>>>>>>>>    // for the text to become visible. See Also: Procedure Page below.
79625>>>>>>>>>>>    Procedure Add_LineLn String sText
79627>>>>>>>>>>>        String sContentText sCR
79627>>>>>>>>>>>
79627>>>>>>>>>>>        Move (Character(10) + String(Character(13))) to sCR
79628>>>>>>>>>>>        Get psContentText to sContentText
79629>>>>>>>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
79630>>>>>>>>>>>        Set psContentText to sContentText
79631>>>>>>>>>>>    End_Procedure
79632>>>>>>>>>>>
79632>>>>>>>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
79634>>>>>>>>>>>        String sLinkText
79634>>>>>>>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
79635>>>>>>>>>>>        Send Show_HomePage sLinkText
79636>>>>>>>>>>>    End_Procedure
79637>>>>>>>>>>>
79637>>>>>>>>>>>    Procedure Page Integer iPageObject
79639>>>>>>>>>>>        String sContentText
79639>>>>>>>>>>>
79639>>>>>>>>>>>        Forward Send Page iPageObject
79641>>>>>>>>>>>        Get psContentText to sContentText
79642>>>>>>>>>>>        Send AppendText sContentText
79643>>>>>>>>>>>        send Beginning_of_Data
79644>>>>>>>>>>>    End_Procedure
79645>>>>>>>>>>>
79645>>>>>>>>>>>End_Class
79646>>>>>>>>>>>
79646>>>>>>>>>>>Class AboutDialog is a ModalPanel
79647>>>>>>>>>>>    Procedure Construct_Object
79649>>>>>>>>>>>
79649>>>>>>>>>>>        Forward Send Construct_Object
79651>>>>>>>>>>>
79651>>>>>>>>>>>        Set Label to C_$About
79652>>>>>>>>>>>        Set Size to 118 230
79653>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79654>>>>>>>>>>>        Set Border_Style to Border_Thick
79655>>>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
79656>>>>>>>>>>>
79656>>>>>>>>>>>        Object oSysInfoDialog is a SysInfoDialog
79658>>>>>>>>>>>        End_Object
79659>>>>>>>>>>>
79659>>>>>>>>>>>        Object oBox is a Container3d
79661>>>>>>>>>>>            Set Border_Style to Border_Normal
79662>>>>>>>>>>>            Set Size to 90 220
79663>>>>>>>>>>>            Set Location to 4 5
79664>>>>>>>>>>>            Set Color to clWhite
79665>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79665>>>>>>>>>>>            // we might as well prepare the object for it.
79665>>>>>>>>>>>            Set peAnchors to anAll
79666>>>>>>>>>>>
79666>>>>>>>>>>>            Object oAboutGraphic is a BitmapContainer
79668>>>>>>>>>>>                Set Border_Style To Border_None
79669>>>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
79670>>>>>>>>>>>                Set Color to clWhite
79671>>>>>>>>>>>                Set Size to 45 50
79672>>>>>>>>>>>                Set Location to 0 3
79673>>>>>>>>>>>            End_Object
79674>>>>>>>>>>>
79674>>>>>>>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
79676>>>>>>>>>>>                Set Border_Style to Border_None
79677>>>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
79678>>>>>>>>>>>                Set Color to clWhite
79679>>>>>>>>>>>                Set Size to 30 55
79680>>>>>>>>>>>                Set Location to 50 3
79681>>>>>>>>>>>            End_Object
79682>>>>>>>>>>>
79682>>>>>>>>>>>            Object oInfoList_Editor is an cAboutEdit
79684>>>>>>>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
79684>>>>>>>>>>>                // we might as well prepare the object for it.
79684>>>>>>>>>>>                Set peAnchors to anAll
79685>>>>>>>>>>>            End_Object
79686>>>>>>>>>>>
79686>>>>>>>>>>>            // These objects are here for backwards compatability only.
79686>>>>>>>>>>>            // They are not used.
79686>>>>>>>>>>>            Object oProductName is a TextBox
79688>>>>>>>>>>>                Set Label To C_$ProductName
79689>>>>>>>>>>>                Set Size To 10 45
79690>>>>>>>>>>>                Set Location To 8 53
79691>>>>>>>>>>>                Set Visible_State to False
79692>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79693>>>>>>>>>>>            End_Object
79694>>>>>>>>>>>
79694>>>>>>>>>>>            Object oVersion is a TextBox
79696>>>>>>>>>>>                Set Label To C_$Version
79697>>>>>>>>>>>                Set Size To 10 25
79698>>>>>>>>>>>                Set Location To 21 53
79699>>>>>>>>>>>                Set Visible_State to False
79700>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79701>>>>>>>>>>>            End_Object
79702>>>>>>>>>>>
79702>>>>>>>>>>>            Object oCopyright is a TextBox
79704>>>>>>>>>>>                Set Label To C_$Copyright
79705>>>>>>>>>>>                Set Size To 10 31
79706>>>>>>>>>>>                Set Location To 34 53
79707>>>>>>>>>>>                Set Visible_State to False
79708>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79709>>>>>>>>>>>            End_Object
79710>>>>>>>>>>>
79710>>>>>>>>>>>            Object oAuthor is a TextBox
79712>>>>>>>>>>>                Set Label To C_$Author
79713>>>>>>>>>>>                Set Size To 10 22
79714>>>>>>>>>>>                Set Location To 46 53
79715>>>>>>>>>>>                Set Visible_State to False
79716>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79717>>>>>>>>>>>            End_Object
79718>>>>>>>>>>>
79718>>>>>>>>>>>        End_Object
79719>>>>>>>>>>>
79719>>>>>>>>>>>        Object oOKButton is a Button
79721>>>>>>>>>>>            On_Item C_$Close Send Close_Panel
79722>>>>>>>>>>>            Set Location to 98 176
79723>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79723>>>>>>>>>>>            // we might as well prepare the object for it.
79723>>>>>>>>>>>            Set peAnchors to anBottomRight
79724>>>>>>>>>>>        End_Object
79725>>>>>>>>>>>
79725>>>>>>>>>>>        Object oSysInfoButton is a Button
79727>>>>>>>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
79728>>>>>>>>>>>            Set Location to 98 123
79729>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79729>>>>>>>>>>>            // we might as well prepare the object for it.
79729>>>>>>>>>>>            Set peAnchors to anBottomRight
79730>>>>>>>>>>>        End_Object
79731>>>>>>>>>>>
79731>>>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79733>>>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79734>>>>>>>>>>>            Set Size to 14 50
79735>>>>>>>>>>>            Set Location to 98 70
79736>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79736>>>>>>>>>>>            // we might as well prepare the object for it.
79736>>>>>>>>>>>            Set peAnchors to anBottomRight
79737>>>>>>>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
79738>>>>>>>>>>>        End_Object
79739>>>>>>>>>>>
79739>>>>>>>>>>>        On_Key Kcancel Send KeyAction of oOKButton
79740>>>>>>>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
79741>>>>>>>>>>>        Set LogoDF to "DF32.bmp"
79742>>>>>>>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
79742>>>>>>>>>>>    End_Procedure
79743>>>>>>>>>>>
79743>>>>>>>>>>>    Procedure Page Integer iPageObject
79745>>>>>>>>>>>        Handle hMenu
79745>>>>>>>>>>>        Integer iPrevState
79745>>>>>>>>>>>
79745>>>>>>>>>>>        Forward Send Page iPageObject
79747>>>>>>>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
79747>>>>>>>>>>>        Set Icon to "Default.ico"
79748>>>>>>>>>>>
79748>>>>>>>>>>>        // Shadow upper left corner menu items: (icon menu items)
79748>>>>>>>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
79749>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79750>>>>>>>>>>>        // The "Move" menu command may come in handy to have.
79750>>>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79750>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79751>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79752>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79753>>>>>>>>>>>        // The "Close" menu command may be good to have.
79753>>>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79753>>>>>>>>>>>    End_Procedure
79754>>>>>>>>>>>
79754>>>>>>>>>>>    Procedure Set ProductName String sText
79756>>>>>>>>>>>        Set Value of oProductName to sText
79757>>>>>>>>>>>    End_Procedure
79758>>>>>>>>>>>
79758>>>>>>>>>>>    Procedure Set Copyright String sText
79760>>>>>>>>>>>        Set Value of oCopyright to sText
79761>>>>>>>>>>>    End_Procedure
79762>>>>>>>>>>>
79762>>>>>>>>>>>    Procedure Set Author String sText
79764>>>>>>>>>>>        Set Value of oAuthor to sText
79765>>>>>>>>>>>    End_Procedure
79766>>>>>>>>>>>
79766>>>>>>>>>>>    // This is used by the About object to display the compile date & time:
79766>>>>>>>>>>>    // Note: It relies on that each project (program) has been setup to use the "WriteDateTimeHeaderFile64.exe"
79766>>>>>>>>>>>    //       program as a pre-compile!
79766>>>>>>>>>>>    //       Add it here: "Before Compilation Process:" (See Studio's: Project - Project Properties - Compiler tab-page)
79766>>>>>>>>>>>    Include_Resource CompileHeader.h as res_CompileHeader type DF_RESOURCE_TYPE_LINE
79766>>>>>>>>>>>
79766>>>>>>>>>>>    Procedure Set Version String sVersion
79768>>>>>>>>>>>        Handle hoVersionInfo
79768>>>>>>>>>>>        Boolean bIncluded
79768>>>>>>>>>>>        Integer iMajor iMinor iRelease iBuild iPos
79768>>>>>>>>>>>        String sCertInfo sCompileDateAndTime
79768>>>>>>>>>>>
79768>>>>>>>>>>>        If (sVersion = "") Begin
79770>>>>>>>>>>>            // This automatically shows the program version of the program, if available.
79770>>>>>>>>>>>            // It will be displayed as the second item in the edit object.
79770>>>>>>>>>>>            If (ghoApplication <> 0) Begin
79772>>>>>>>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
79773>>>>>>>>>>>                If (hoVersionInfo <> 0) Begin
79775>>>>>>>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
79776>>>>>>>>>>>                    If (bIncluded) Begin
79778>>>>>>>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
79779>>>>>>>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
79780>>>>>>>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
79781>>>>>>>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
79782>>>>>>>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
79783>>>>>>>>>>>                    End
79783>>>>>>>>>>>>
79783>>>>>>>>>>>                End
79783>>>>>>>>>>>>
79783>>>>>>>>>>>            End
79783>>>>>>>>>>>>
79783>>>>>>>>>>>        End
79783>>>>>>>>>>>>
79783>>>>>>>>>>>
79783>>>>>>>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
79783>>>>>>>>>>>        Direct_Input "resource: res_CompileHeader"
79784>>>>>>>>>>>        Readln sCompileDateAndTime
79785>>>>>>>>>>>        Move (Pos('"', sCompileDateAndTime)) to iPos
79786>>>>>>>>>>>        If (iPos <> 0) Begin
79788>>>>>>>>>>>            Move (Mid(sCompileDateAndTime, Length(sCompileDateAndTime), (iPos + 1))) to sCompileDateAndTime
79789>>>>>>>>>>>            Move (Replaces('"', sCompileDateAndTime, '')) to sCompileDateAndTime
79790>>>>>>>>>>>        End
79790>>>>>>>>>>>>
79790>>>>>>>>>>>        Close_Input
79791>>>>>>>>>>>
79791>>>>>>>>>>>        If (sCompileDateAndTime <> "") Begin
79793>>>>>>>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(sCompileDateAndTime))
79794>>>>>>>>>>>        End
79794>>>>>>>>>>>>
79794>>>>>>>>>>>
79794>>>>>>>>>>>        Get IsProgramDigitallySigned to sCertInfo
79795>>>>>>>>>>>        If (sCertInfo <> "-1") Begin
79797>>>>>>>>>>>            If (sCertInfo <> "") Begin
79799>>>>>>>>>>>                Send Add_LineLn sCertInfo
79800>>>>>>>>>>>            End
79800>>>>>>>>>>>>
79800>>>>>>>>>>>            Else Begin
79801>>>>>>>>>>>                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
79802>>>>>>>>>>>            End
79802>>>>>>>>>>>>
79802>>>>>>>>>>>        End
79802>>>>>>>>>>>>
79802>>>>>>>>>>>    End_Procedure
79803>>>>>>>>>>>
79803>>>>>>>>>>>    Function IsDate String sDate Returns Boolean
79805>>>>>>>>>>>        Boolean bIsDate
79805>>>>>>>>>>>        String sGoodCharacters sChar
79805>>>>>>>>>>>        Integer iCount iLength
79805>>>>>>>>>>>
79805>>>>>>>>>>>        Move True to bIsDate
79806>>>>>>>>>>>        Move "0123456789-/" to sGoodCharacters
79807>>>>>>>>>>>        Move (Length(sDate)) to iLength
79808>>>>>>>>>>>        For iCount from 1 to iLength
79814>>>>>>>>>>>>
79814>>>>>>>>>>>            Move (Left(sDate, 1)) to sChar
79815>>>>>>>>>>>            Move (Mid(sDate, 12, 2)) to sDate
79816>>>>>>>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
79817>>>>>>>>>>>            If (bIsDate = False) Begin
79819>>>>>>>>>>>                Move iLength to iCount
79820>>>>>>>>>>>            End
79820>>>>>>>>>>>>
79820>>>>>>>>>>>        Loop
79821>>>>>>>>>>>>
79821>>>>>>>>>>>        Function_Return bIsDate
79822>>>>>>>>>>>    End_Function
79823>>>>>>>>>>>
79823>>>>>>>>>>>    Function GetCompileDate Returns Date
79825>>>>>>>>>>>        Date dCompileDate
79825>>>>>>>>>>>        String sAppFilename sProgram sData sCompileDate
79825>>>>>>>>>>>        Integer iChannel iPos iDateFormat iCount iSize
79825>>>>>>>>>>>        Boolean bIsValid   
79825>>>>>>>>>>>        
79825>>>>>>>>>>>        Move 0 to dCompileDate
79826>>>>>>>>>>>        // Get full path to the current running executable
79826>>>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
79827>>>>>>>>>>>        Get GetApplicationName     of ghoApplication to sProgram
79828>>>>>>>>>>>
79828>>>>>>>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
79828>>>>>>>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
79829>>>>>>>>>>>
79829>>>>>>>>>>>        Read_Block channel iChannel sData 9000000   // This must be big enough to reach the compile date location
79831>>>>>>>>>>>        Move (Pos(sProgram, sData)) to iPos
79832>>>>>>>>>>>        If (iPos > 0) Begin
79834>>>>>>>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
79834>>>>>>>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
79835>>>>>>>>>>>
79835>>>>>>>>>>>            // If the current date format is non US, we need to temporary
79835>>>>>>>>>>>            // change the format and then move the string to the date variable.
79835>>>>>>>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
79838>>>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA  
79841>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id 16 
79842>>>>>>>>>>>            If (Left(sCompileDate, 1) = "0") Begin
79844>>>>>>>>>>>                Move ("1" + String(sCompileDate)) to sCompileDate
79845>>>>>>>>>>>            End
79845>>>>>>>>>>>>
79845>>>>>>>>>>>            Move (Date(sCompileDate))    to dCompileDate
79846>>>>>>>>>>>            Send Trap_Error of Error_Object_Id 16
79847>>>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
79850>>>>>>>>>>>        End
79850>>>>>>>>>>>>
79850>>>>>>>>>>>        Else Begin
79851>>>>>>>>>>>            Error DFERR_PROGRAM "Compile Date location in .exe not found"
79852>>>>>>>>>>>>
79852>>>>>>>>>>>        End
79852>>>>>>>>>>>>
79852>>>>>>>>>>>
79852>>>>>>>>>>>        Send Seq_Close_Channel iChannel
79853>>>>>>>>>>>
79853>>>>>>>>>>>        Function_Return dCompileDate
79854>>>>>>>>>>>    End_Function
79855>>>>>>>>>>>
79855>>>>>>>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
79855>>>>>>>>>>>    // (the passed program), has been finished
79855>>>>>>>>>>>    // The DOS box does also _not_ flash briefly.
79855>>>>>>>>>>>    Procedure RunProgramWait String sProgram String sParameter
79857>>>>>>>>>>>        Handle hProcess
79857>>>>>>>>>>>        Integer iVoid
79857>>>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79857>>>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79857>>>>>>>>>>>
79857>>>>>>>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
79858>>>>>>>>>>>
79858>>>>>>>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
79859>>>>>>>>>>>        Move SW_SHOW                 to sInfo.nShow
79860>>>>>>>>>>>
79860>>>>>>>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
79861>>>>>>>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
79862>>>>>>>>>>>        // This will "hide" the DOS box from showing (no flasing box):
79862>>>>>>>>>>>        Move 0                       to sInfo.nShow
79863>>>>>>>>>>>
79863>>>>>>>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
79864>>>>>>>>>>>        Move sInfo.hProcess to hProcess
79865>>>>>>>>>>>        If (hProcess) Begin
79867>>>>>>>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
79868>>>>>>>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
79869>>>>>>>>>>>        End
79869>>>>>>>>>>>>
79869>>>>>>>>>>>    End_Procedure
79870>>>>>>>>>>>
79870>>>>>>>>>>>    Function AddFolderDelimiter String sPath Returns String
79872>>>>>>>>>>>        String sDirSep
79872>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
79873>>>>>>>>>>>        Move (Trim(sPath)) to sPath
79874>>>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
79876>>>>>>>>>>>            Move (sPath + sDirSep) to sPath
79877>>>>>>>>>>>        End
79877>>>>>>>>>>>>
79877>>>>>>>>>>>        Function_Return sPath
79878>>>>>>>>>>>    End_Function
79879>>>>>>>>>>>
79879>>>>>>>>>>>    // Returns an empty string if the current program is not digitally signed,
79879>>>>>>>>>>>    // or there is a problem with the certificate.
79879>>>>>>>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
79879>>>>>>>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
79879>>>>>>>>>>>    Function IsProgramDigitallySigned Returns String
79881>>>>>>>>>>>        Boolean bExists
79881>>>>>>>>>>>        String sPath sProgram sParams sRetval
79881>>>>>>>>>>>        Integer iCh
79881>>>>>>>>>>>
79881>>>>>>>>>>>        Move "" to sRetval
79882>>>>>>>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
79883>>>>>>>>>>>        Get AddFolderDelimiter sPath to sPath
79884>>>>>>>>>>>        File_Exist (sPath + CS_SignProgram) bExists
79885>>>>>>>>>>>        If (bExists = False) Begin
79887>>>>>>>>>>>            Function_Return "-1"
79888>>>>>>>>>>>        End
79888>>>>>>>>>>>>
79888>>>>>>>>>>>
79888>>>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
79889>>>>>>>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
79890>>>>>>>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
79891>>>>>>>>>>>        Move (sParams * String("| clip"))    to sParams
79892>>>>>>>>>>>        Get Seq_New_Channel to iCh
79893>>>>>>>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
79895>>>>>>>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
79898>>>>>>>>>>>        Close_Output channel iCh
79900>>>>>>>>>>>        // New ShellExecute based message that waits for the passed process to end.
79900>>>>>>>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
79901>>>>>>>>>>>        Direct_Input channel iCh "CLIPBOARD:"
79903>>>>>>>>>>>            Readln channel iCh sRetval
79905>>>>>>>>>>>            Readln channel iCh sRetval
79907>>>>>>>>>>>            Readln channel iCh sRetval
79909>>>>>>>>>>>            Readln channel iCh sRetval
79911>>>>>>>>>>>        Close_Input channel iCh
79913>>>>>>>>>>>        Send Seq_Release_Channel iCh
79914>>>>>>>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
79916>>>>>>>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
79917>>>>>>>>>>>        End
79917>>>>>>>>>>>>
79917>>>>>>>>>>>        Else Begin
79918>>>>>>>>>>>            Move "" to sRetval
79919>>>>>>>>>>>        End
79919>>>>>>>>>>>>
79919>>>>>>>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
79919>>>>>>>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
79920>>>>>>>>>>>>
79920>>>>>>>>>>>        Function_Return sRetval
79921>>>>>>>>>>>    End_Function
79922>>>>>>>>>>>
79922>>>>>>>>>>>    Procedure Add_LineLn String sValue
79924>>>>>>>>>>>        Send Add_LineLn of oInfoList_Editor sValue
79925>>>>>>>>>>>    End_Procedure
79926>>>>>>>>>>>
79926>>>>>>>>>>>    Procedure Add_Line String sValue
79928>>>>>>>>>>>        Send Add_Line of oInfoList_Editor sValue
79929>>>>>>>>>>>    End_Procedure
79930>>>>>>>>>>>
79930>>>>>>>>>>>    Procedure Set Logo string sLogo
79932>>>>>>>>>>>        // Square bitmaps of 80x80 work best
79932>>>>>>>>>>>        Set Bitmap of oAboutGraphic to sLogo
79933>>>>>>>>>>>    End_Procedure
79934>>>>>>>>>>>
79934>>>>>>>>>>>    Procedure Set LogoDF String sLogo
79936>>>>>>>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
79937>>>>>>>>>>>    End_Procedure
79938>>>>>>>>>>>
79938>>>>>>>>>>>    Procedure Show_Sysinfo
79940>>>>>>>>>>>        Send Popup_Modal of oSysinfoDialog
79941>>>>>>>>>>>    End_Procedure
79942>>>>>>>>>>>
79942>>>>>>>>>>>    Procedure Show_HomePage String sWebpage
79944>>>>>>>>>>>        Handle hWnd
79944>>>>>>>>>>>        Get Window_Handle to hWnd
79945>>>>>>>>>>>        Runprogram Shell Background (Trim(sWebpage))
79946>>>>>>>>>>>    End_Procedure
79947>>>>>>>>>>>
79947>>>>>>>>>>>End_Class
79948>>>>>>>>>
79948>>>>>>>>>    Function piOrgErrorHandlerID Returns Integer
79950>>>>>>>>>    End_Function
79951>>>>>>>>>
79951>>>>>>>>>Register_Procedure Set Private.pbProcessingError Boolean bProcessingError
79951>>>>>>>>>
79951>>>>>>>>>Class cBaseDbUpdateFuncLib is a cObject
79952>>>>>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
79953>>>>>>>>>>
79953>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
79955>>>>>>>>>>    Integer iStart iEnd
79955>>>>>>>>>>    String sRetval
79955>>>>>>>>>>
79955>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
79956>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
79957>>>>>>>>>>    If (iStart = 0) Begin
79959>>>>>>>>>>        Function_Return ""
79960>>>>>>>>>>    End
79960>>>>>>>>>>>
79960>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
79961>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
79962>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
79964>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
79965>>>>>>>>>>    End
79965>>>>>>>>>>>
79965>>>>>>>>>>    Else Begin
79966>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
79967>>>>>>>>>>    End
79967>>>>>>>>>>>
79967>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
79969>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
79970>>>>>>>>>>        Decrement iEnd
79971>>>>>>>>>>    End
79971>>>>>>>>>>>
79971>>>>>>>>>>    If (iEnd <> 0) Begin
79973>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
79974>>>>>>>>>>    End
79974>>>>>>>>>>>
79974>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
79975>>>>>>>>>>
79975>>>>>>>>>>    Function_Return (Trim(sRetval))
79976>>>>>>>>>>End_Function
79977>>>>>>>>>>
79977>>>>>>>>>>
79977>>>>>>>>>    
79977>>>>>>>>>    Procedure Construct_Object
79979>>>>>>>>>        Handle ho
79979>>>>>>>>>        Forward Send Construct_Object
79981>>>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
79982>>>>>>>>>        
79982>>>>>>>>>        Send CreateDbUpdateLibraryProperties
79983>>>>>>>>>        Property String private.psCollation "Latin1_General_CS_AS"
79984>>>>>>>>>        Property String[] pasSQLDataTables
79985>>>>>>>>>        Property tFilelist[] pFileListArray  
79986>>>>>>>>>        Property tFilelist[] pErrorTables
79987>>>>>>>>>
79987>>>>>>>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
79987>>>>>>>>>        // we will create one as it is used for all ConnectionID, ConnectionString
79987>>>>>>>>>        // etc settings.
79987>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79989>>>>>>>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
79990>>>>>>>>>            Set Name of ho to "oSQLConnectionHandler"
79991>>>>>>>>>            Set phoSQLConnectionHandler to ho
79992>>>>>>>>>        End
79992>>>>>>>>>>
79992>>>>>>>>>
79992>>>>>>>>>    End_Procedure
79993>>>>>>>>>
79993>>>>>>>>>    Procedure End_Construct_Object
79995>>>>>>>>>        Forward Send End_Construct_Object
79997>>>>>>>>>
79997>>>>>>>>>    End_Procedure
79998>>>>>>>>>
79998>>>>>>>>>    // Latin1_General_CI_AS = General Insensitive collation
79998>>>>>>>>>    // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.
79998>>>>>>>>>    // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
79998>>>>>>>>>    // Good read about which collation to select:
79998>>>>>>>>>    // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
79998>>>>>>>>>    Procedure Set psCollation String sCollation
80000>>>>>>>>>        Set private.psCollation to sCollation
80001>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
80003>>>>>>>>>            Set psCollation of ghoDbUpdateHandler to sCollation
80004>>>>>>>>>        End
80004>>>>>>>>>>
80004>>>>>>>>>    End_Procedure
80005>>>>>>>>>
80005>>>>>>>>>    Function psCollation Returns String
80007>>>>>>>>>        String sCollation
80007>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
80009>>>>>>>>>            Get psCollation of ghoDbUpdateHandler to sCollation
80010>>>>>>>>>        End   
80010>>>>>>>>>>
80010>>>>>>>>>        Else Begin
80011>>>>>>>>>            Get private.psCollation to sCollation
80012>>>>>>>>>        End
80012>>>>>>>>>>
80012>>>>>>>>>        Function_Return sCollation
80013>>>>>>>>>    End_Function
80014>>>>>>>>>
80014>>>>>>>>>    // Array sorting helper functions:
80014>>>>>>>>>    Function __UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
80016>>>>>>>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
80018>>>>>>>>>            Function_Return (EQ)
80019>>>>>>>>>        End
80019>>>>>>>>>>
80019>>>>>>>>>
80019>>>>>>>>>        Function_Return (GT)
80020>>>>>>>>>    End_Function
80021>>>>>>>>>
80021>>>>>>>>>    Function __SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
80023>>>>>>>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
80026>>>>>>>>>
80026>>>>>>>>>        Function_Return (GT)
80027>>>>>>>>>    End_Function
80028>>>>>>>>>
80028>>>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
80028>>>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
80028>>>>>>>>>    Function _ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
80030>>>>>>>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
80030>>>>>>>>>        Handle hTable
80030>>>>>>>>>        Boolean bIsSame
80030>>>>>>>>>
80030>>>>>>>>>        Move APITableInfo.iTableNumber      to hTable
80031>>>>>>>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
80032>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
80035>>>>>>>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
80036>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
80039>>>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
80042>>>>>>>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
80043>>>>>>>>>
80043>>>>>>>>>        If (bCompareFilelistUppercase = True) Begin
80045>>>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
80046>>>>>>>>>        End
80046>>>>>>>>>>
80046>>>>>>>>>        Else Begin
80047>>>>>>>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
80048>>>>>>>>>        End
80048>>>>>>>>>>
80048>>>>>>>>>
80048>>>>>>>>>        Function_Return bIsSame
80049>>>>>>>>>    End_Function
80050>>>>>>>>>
80050>>>>>>>>>    Function AutoSetConnectionID String sConnectionID Returns Boolean
80052>>>>>>>>>        Integer iRetval
80052>>>>>>>>>        Move 1 to iRetval
80053>>>>>>>>>        If (ghoSQLConnectionHandler <> 0) Begin
80055>>>>>>>>>            Set psConnectionID of ghoSQLConnectionHandler to sConnectionID
80056>>>>>>>>>            Get AutoSetConnectionID of ghoSQLConnectionHandler to iRetval
80057>>>>>>>>>        End
80057>>>>>>>>>>
80057>>>>>>>>>        Function_Return (iRetval = 0)
80058>>>>>>>>>    End_Function
80059>>>>>>>>>
80059>>>>>>>>>    Function _AddFolderDelimiter String sPath Returns String
80061>>>>>>>>>        String sDirSep
80061>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
80062>>>>>>>>>        Move (Trim(sPath)) to sPath
80063>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
80065>>>>>>>>>            Move (sPath + sDirSep) to sPath
80066>>>>>>>>>        End
80066>>>>>>>>>>
80066>>>>>>>>>        Function_Return sPath
80067>>>>>>>>>    End_Function
80068>>>>>>>>>
80068>>>>>>>>>    Procedure _SqlColumnInfo Handle hoStmt
80070>>>>>>>>>        Integer i iCols iItem
80070>>>>>>>>>        tSqlColumnNew[] aQueryColumns
80070>>>>>>>>>        tSqlColumnNew[] aQueryColumns
80071>>>>>>>>>
80071>>>>>>>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
80072>>>>>>>>>        For i from 1 to iCols
80078>>>>>>>>>>
80078>>>>>>>>>            Move (SizeOfArray(aQueryColumns)) to iItem
80079>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
80080>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
80081>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
80082>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
80083>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
80084>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
80085>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
80086>>>>>>>>>        Loop
80087>>>>>>>>>>
80087>>>>>>>>>        Set piColumns to iCols
80088>>>>>>>>>        Set paQueryColumns to aQueryColumns
80089>>>>>>>>>    End_Procedure
80090>>>>>>>>>
80090>>>>>>>>>    // *** Property Messages ***
80090>>>>>>>>>    //
80090>>>>>>>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
80090>>>>>>>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
80090>>>>>>>>>    //
80090>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
80092>>>>>>>>>        tSQLConnection SQLConnection
80092>>>>>>>>>        tSQLConnection SQLConnection
80092>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80094>>>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
80094>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80095>>>>>>>>>>
80095>>>>>>>>>            Function_Return
80096>>>>>>>>>        End
80096>>>>>>>>>>
80096>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
80097>>>>>>>>>        Function_Return SQLConnection
80098>>>>>>>>>    End_Function
80099>>>>>>>>>
80099>>>>>>>>>    // * Dummy function for the Studio's Code Explorer *
80099>>>>>>>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
80101>>>>>>>>>        Function_Return False
80102>>>>>>>>>    End_Function
80103>>>>>>>>>
80103>>>>>>>>>    Procedure Set psServer String sValue
80105>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80107>>>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
80107>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80108>>>>>>>>>>
80108>>>>>>>>>            Procedure_Return
80109>>>>>>>>>        End
80109>>>>>>>>>>
80109>>>>>>>>>        Set psServer of ghoSQLConnectionHandler to sValue
80110>>>>>>>>>    End_Procedure
80111>>>>>>>>>
80111>>>>>>>>>    Function psServer Returns String
80113>>>>>>>>>        String sValue
80113>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80115>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80116>>>>>>>>>>
80116>>>>>>>>>            Function_Return
80117>>>>>>>>>        End
80117>>>>>>>>>>
80117>>>>>>>>>        Get psServer of ghoSQLConnectionHandler to sValue
80118>>>>>>>>>        Function_Return sValue
80119>>>>>>>>>    End_Function
80120>>>>>>>>>
80120>>>>>>>>>    Procedure Set psDatabase String sValue
80122>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80124>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80125>>>>>>>>>>
80125>>>>>>>>>            Procedure_Return
80126>>>>>>>>>        End
80126>>>>>>>>>>
80126>>>>>>>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
80127>>>>>>>>>    End_Procedure
80128>>>>>>>>>
80128>>>>>>>>>    Function psDatabase Returns String
80130>>>>>>>>>        String sValue
80130>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80132>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80133>>>>>>>>>>
80133>>>>>>>>>            Function_Return
80134>>>>>>>>>        End
80134>>>>>>>>>>
80134>>>>>>>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
80135>>>>>>>>>        Function_Return sValue
80136>>>>>>>>>    End_Function
80137>>>>>>>>>
80137>>>>>>>>>    Procedure Set psUserID String sValue
80139>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80141>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80142>>>>>>>>>>
80142>>>>>>>>>            Procedure_Return
80143>>>>>>>>>        End
80143>>>>>>>>>>
80143>>>>>>>>>        Set psUserID of ghoSQLConnectionHandler to sValue
80144>>>>>>>>>    End_Procedure
80145>>>>>>>>>
80145>>>>>>>>>    Function psUserID Returns String
80147>>>>>>>>>        String sValue
80147>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80149>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80150>>>>>>>>>>
80150>>>>>>>>>            Function_Return
80151>>>>>>>>>        End
80151>>>>>>>>>>
80151>>>>>>>>>        Get psUserID of ghoSQLConnectionHandler to sValue
80152>>>>>>>>>        Function_Return sValue
80153>>>>>>>>>    End_Function
80154>>>>>>>>>
80154>>>>>>>>>    Procedure Set psPassword String sValue
80156>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80158>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80159>>>>>>>>>>
80159>>>>>>>>>            Procedure_Return
80160>>>>>>>>>        End
80160>>>>>>>>>>
80160>>>>>>>>>        Set psPassword of ghoSQLConnectionHandler to sValue
80161>>>>>>>>>    End_Procedure
80162>>>>>>>>>
80162>>>>>>>>>    Function psPassword Returns String
80164>>>>>>>>>        String sValue
80164>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80166>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80167>>>>>>>>>>
80167>>>>>>>>>            Function_Return
80168>>>>>>>>>        End
80168>>>>>>>>>>
80168>>>>>>>>>        Get psPassword of ghoSQLConnectionHandler to sValue
80169>>>>>>>>>        Function_Return sValue
80170>>>>>>>>>    End_Function
80171>>>>>>>>>
80171>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
80173>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80175>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80176>>>>>>>>>>
80176>>>>>>>>>            Procedure_Return
80177>>>>>>>>>        End
80177>>>>>>>>>>
80177>>>>>>>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
80178>>>>>>>>>    End_Procedure
80179>>>>>>>>>
80179>>>>>>>>>    Function pbTrusted Returns Boolean
80181>>>>>>>>>        Boolean bValue
80181>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80183>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80184>>>>>>>>>>
80184>>>>>>>>>            Function_Return
80185>>>>>>>>>        End
80185>>>>>>>>>>
80185>>>>>>>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
80186>>>>>>>>>        Function_Return bValue
80187>>>>>>>>>    End_Function
80188>>>>>>>>>
80188>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
80190>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80192>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80193>>>>>>>>>>
80193>>>>>>>>>            Procedure_Return
80194>>>>>>>>>        End
80194>>>>>>>>>>
80194>>>>>>>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
80195>>>>>>>>>    End_Procedure
80196>>>>>>>>>
80196>>>>>>>>>    Function pbSilentLogin Returns Boolean
80198>>>>>>>>>        Boolean bValue
80198>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80200>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80201>>>>>>>>>>
80201>>>>>>>>>            Function_Return
80202>>>>>>>>>        End
80202>>>>>>>>>>
80202>>>>>>>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
80203>>>>>>>>>        Function_Return bValue
80204>>>>>>>>>    End_Function
80205>>>>>>>>>
80205>>>>>>>>>    Procedure Set psConnectionID String sValue
80207>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80209>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80210>>>>>>>>>>
80210>>>>>>>>>            Procedure_Return
80211>>>>>>>>>        End
80211>>>>>>>>>>
80211>>>>>>>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
80212>>>>>>>>>    End_Procedure
80213>>>>>>>>>
80213>>>>>>>>>    Function psConnectionID Returns String
80215>>>>>>>>>        String sValue
80215>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80217>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80218>>>>>>>>>>
80218>>>>>>>>>            Function_Return
80219>>>>>>>>>        End
80219>>>>>>>>>>
80219>>>>>>>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
80220>>>>>>>>>        Function_Return sValue
80221>>>>>>>>>    End_Function
80222>>>>>>>>>
80222>>>>>>>>>    Procedure Set psConnectionString String sValue
80224>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80226>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80227>>>>>>>>>>
80227>>>>>>>>>            Procedure_Return
80228>>>>>>>>>        End
80228>>>>>>>>>>
80228>>>>>>>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
80229>>>>>>>>>    End_Procedure
80230>>>>>>>>>
80230>>>>>>>>>    Function psConnectionString Returns String
80232>>>>>>>>>        String sValue
80232>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80234>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80235>>>>>>>>>>
80235>>>>>>>>>            Function_Return
80236>>>>>>>>>        End
80236>>>>>>>>>>
80236>>>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
80237>>>>>>>>>        Function_Return sValue
80238>>>>>>>>>    End_Function
80239>>>>>>>>>
80239>>>>>>>>>    // The normal connection string looks something like this;
80239>>>>>>>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
80239>>>>>>>>>    // ...and the full connection string looks like this;
80239>>>>>>>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
80239>>>>>>>>>    Function psFullConnectionString Returns String
80241>>>>>>>>>        String sConnectionID sConnectionString
80241>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80243>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80244>>>>>>>>>>
80244>>>>>>>>>            Function_Return
80245>>>>>>>>>        End
80245>>>>>>>>>>
80245>>>>>>>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
80246>>>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
80247>>>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
80248>>>>>>>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
80249>>>>>>>>>    End_Function
80250>>>>>>>>>
80250>>>>>>>>>    Function piConnectionOptions Returns Integer
80252>>>>>>>>>        Integer iValue
80252>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80254>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80255>>>>>>>>>>
80255>>>>>>>>>            Function_Return
80256>>>>>>>>>        End
80256>>>>>>>>>>
80256>>>>>>>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
80257>>>>>>>>>        Function_Return iValue
80258>>>>>>>>>    End_Function
80259>>>>>>>>>
80259>>>>>>>>>    Procedure Set psSchema String sValue
80261>>>>>>>>>        tSQLConnection SQLConnection
80261>>>>>>>>>        tSQLConnection SQLConnection
80261>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80263>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80264>>>>>>>>>>
80264>>>>>>>>>            Procedure_Return
80265>>>>>>>>>        End
80265>>>>>>>>>>
80265>>>>>>>>>        Set psSchema of ghoSQLConnectionHandler to sValue
80266>>>>>>>>>    End_Procedure
80267>>>>>>>>>
80267>>>>>>>>>    Function psSchema Returns String
80269>>>>>>>>>        String sRetval
80269>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80271>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80272>>>>>>>>>>
80272>>>>>>>>>            Function_Return
80273>>>>>>>>>        End
80273>>>>>>>>>>
80273>>>>>>>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
80274>>>>>>>>>        Function_Return sRetval
80275>>>>>>>>>    End_Function
80276>>>>>>>>>
80276>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
80278>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80280>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80281>>>>>>>>>>
80281>>>>>>>>>            Procedure_Return
80282>>>>>>>>>        End
80282>>>>>>>>>>
80282>>>>>>>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
80283>>>>>>>>>    End_Procedure
80284>>>>>>>>>
80284>>>>>>>>>    Function psBaseTableSpace Returns String
80286>>>>>>>>>        String sRetval
80286>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80288>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80289>>>>>>>>>>
80289>>>>>>>>>            Function_Return
80290>>>>>>>>>        End
80290>>>>>>>>>>
80290>>>>>>>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
80291>>>>>>>>>        Function_Return sRetval
80292>>>>>>>>>    End_Function
80293>>>>>>>>>
80293>>>>>>>>>    Procedure Set psLongTableSpace String sValue
80295>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80297>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80298>>>>>>>>>>
80298>>>>>>>>>            Procedure_Return
80299>>>>>>>>>        End
80299>>>>>>>>>>
80299>>>>>>>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
80300>>>>>>>>>    End_Procedure
80301>>>>>>>>>
80301>>>>>>>>>    Function psLongTableSpace Returns String
80303>>>>>>>>>        String sRetval
80303>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80305>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80306>>>>>>>>>>
80306>>>>>>>>>            Function_Return
80307>>>>>>>>>        End
80307>>>>>>>>>>
80307>>>>>>>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
80308>>>>>>>>>        Function_Return sRetval
80309>>>>>>>>>    End_Function
80310>>>>>>>>>
80310>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
80312>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80314>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80315>>>>>>>>>>
80315>>>>>>>>>            Procedure_Return
80316>>>>>>>>>        End
80316>>>>>>>>>>
80316>>>>>>>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
80317>>>>>>>>>    End_Procedure
80318>>>>>>>>>
80318>>>>>>>>>    Function psIndexTableSpace Returns String
80320>>>>>>>>>        String sRetval
80320>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80322>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80323>>>>>>>>>>
80323>>>>>>>>>            Function_Return
80324>>>>>>>>>        End
80324>>>>>>>>>>
80324>>>>>>>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
80325>>>>>>>>>        Function_Return sRetval
80326>>>>>>>>>    End_Function
80327>>>>>>>>>
80327>>>>>>>>>    Procedure Set pbUseConnectionID Boolean bState
80329>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80331>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80332>>>>>>>>>>
80332>>>>>>>>>            Procedure_Return
80333>>>>>>>>>        End
80333>>>>>>>>>>
80333>>>>>>>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
80334>>>>>>>>>    End_Procedure
80335>>>>>>>>>
80335>>>>>>>>>    Function pbUseConnectionID Returns Boolean
80337>>>>>>>>>        Boolean bState
80337>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80339>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80340>>>>>>>>>>
80340>>>>>>>>>            Function_Return
80341>>>>>>>>>        End
80341>>>>>>>>>>
80341>>>>>>>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
80342>>>>>>>>>        Function_Return bState
80343>>>>>>>>>    End_Function
80344>>>>>>>>>
80344>>>>>>>>>    Procedure Set pbToANSI Boolean bState
80346>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80348>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80349>>>>>>>>>>
80349>>>>>>>>>            Procedure_Return
80350>>>>>>>>>        End
80350>>>>>>>>>>
80350>>>>>>>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
80351>>>>>>>>>    End_Procedure
80352>>>>>>>>>
80352>>>>>>>>>    Function pbToANSI Returns Boolean
80354>>>>>>>>>        Boolean bState
80354>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80356>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80357>>>>>>>>>>
80357>>>>>>>>>            Function_Return
80358>>>>>>>>>        End
80358>>>>>>>>>>
80358>>>>>>>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
80359>>>>>>>>>        Function_Return bState
80360>>>>>>>>>    End_Function
80361>>>>>>>>>
80361>>>>>>>>>    Procedure Set pbRecnum Boolean bState
80363>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80365>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80366>>>>>>>>>>
80366>>>>>>>>>            Procedure_Return
80367>>>>>>>>>        End
80367>>>>>>>>>>
80367>>>>>>>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
80368>>>>>>>>>    End_Procedure
80369>>>>>>>>>
80369>>>>>>>>>    Function pbRecnum Returns Boolean
80371>>>>>>>>>        Boolean bState
80371>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80373>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80374>>>>>>>>>>
80374>>>>>>>>>            Function_Return
80375>>>>>>>>>        End
80375>>>>>>>>>>
80375>>>>>>>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
80376>>>>>>>>>        Function_Return bState
80377>>>>>>>>>    End_Function
80378>>>>>>>>>
80378>>>>>>>>>    Procedure Set pbCopyData Boolean bState
80380>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80382>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80383>>>>>>>>>>
80383>>>>>>>>>            Procedure_Return
80384>>>>>>>>>        End
80384>>>>>>>>>>
80384>>>>>>>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
80385>>>>>>>>>    End_Procedure
80386>>>>>>>>>
80386>>>>>>>>>    Function pbCopyData Returns Boolean
80388>>>>>>>>>        Boolean bState
80388>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80390>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80391>>>>>>>>>>
80391>>>>>>>>>            Function_Return
80392>>>>>>>>>        End
80392>>>>>>>>>>
80392>>>>>>>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
80393>>>>>>>>>        Function_Return bState
80394>>>>>>>>>    End_Function
80395>>>>>>>>>
80395>>>>>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
80397>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80399>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80400>>>>>>>>>>
80400>>>>>>>>>            Procedure_Return
80401>>>>>>>>>        End
80401>>>>>>>>>>
80401>>>>>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
80402>>>>>>>>>    End_Procedure
80403>>>>>>>>>
80403>>>>>>>>>    Function pbApiTableUpdateAuto Returns Boolean
80405>>>>>>>>>        Boolean bState
80405>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80407>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80408>>>>>>>>>>
80408>>>>>>>>>            Function_Return
80409>>>>>>>>>        End
80409>>>>>>>>>>
80409>>>>>>>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
80410>>>>>>>>>        Function_Return bState
80411>>>>>>>>>    End_Function
80412>>>>>>>>>
80412>>>>>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
80414>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80416>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80417>>>>>>>>>>
80417>>>>>>>>>            Procedure_Return
80418>>>>>>>>>        End
80418>>>>>>>>>>
80418>>>>>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
80419>>>>>>>>>    End_Procedure
80420>>>>>>>>>
80420>>>>>>>>>    Function pbCompareDate_DateTime Returns Boolean
80422>>>>>>>>>        Boolean bState
80422>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80424>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80425>>>>>>>>>>
80425>>>>>>>>>            Function_Return
80426>>>>>>>>>        End
80426>>>>>>>>>>
80426>>>>>>>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
80427>>>>>>>>>        Function_Return bState
80428>>>>>>>>>    End_Function
80429>>>>>>>>>
80429>>>>>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
80431>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80433>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80434>>>>>>>>>>
80434>>>>>>>>>            Procedure_Return
80435>>>>>>>>>        End
80435>>>>>>>>>>
80435>>>>>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
80436>>>>>>>>>    End_Procedure
80437>>>>>>>>>
80437>>>>>>>>>    Function pbCompareIndexAscending Returns Boolean
80439>>>>>>>>>        Boolean bState
80439>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80441>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80442>>>>>>>>>>
80442>>>>>>>>>            Function_Return
80443>>>>>>>>>        End
80443>>>>>>>>>>
80443>>>>>>>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
80444>>>>>>>>>        Function_Return bState
80445>>>>>>>>>    End_Function
80446>>>>>>>>>
80446>>>>>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
80448>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80450>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80451>>>>>>>>>>
80451>>>>>>>>>            Procedure_Return
80452>>>>>>>>>        End
80452>>>>>>>>>>
80452>>>>>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
80453>>>>>>>>>    End_Procedure
80454>>>>>>>>>
80454>>>>>>>>>    Function pbCompareIndexUppercase Returns Boolean
80456>>>>>>>>>        Boolean bState
80456>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80458>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80459>>>>>>>>>>
80459>>>>>>>>>            Function_Return
80460>>>>>>>>>        End
80460>>>>>>>>>>
80460>>>>>>>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
80461>>>>>>>>>        Function_Return bState
80462>>>>>>>>>    End_Function
80463>>>>>>>>>
80463>>>>>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
80465>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80467>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80468>>>>>>>>>>
80468>>>>>>>>>            Procedure_Return
80469>>>>>>>>>        End
80469>>>>>>>>>>
80469>>>>>>>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
80470>>>>>>>>>    End_Procedure
80471>>>>>>>>>
80471>>>>>>>>>    Function psDriverDefaultValueASCII Returns String
80473>>>>>>>>>        String sRetval
80473>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80475>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80476>>>>>>>>>>
80476>>>>>>>>>            Function_Return
80477>>>>>>>>>        End
80477>>>>>>>>>>
80477>>>>>>>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
80478>>>>>>>>>        Function_Return sRetval
80479>>>>>>>>>    End_Function
80480>>>>>>>>>
80480>>>>>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
80482>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80484>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80485>>>>>>>>>>
80485>>>>>>>>>            Procedure_Return
80486>>>>>>>>>        End
80486>>>>>>>>>>
80486>>>>>>>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
80487>>>>>>>>>    End_Procedure
80488>>>>>>>>>
80488>>>>>>>>>    Function psDriverDefaultValueBinary Returns String
80490>>>>>>>>>        String sRetval
80490>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80492>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80493>>>>>>>>>>
80493>>>>>>>>>            Function_Return
80494>>>>>>>>>        End
80494>>>>>>>>>>
80494>>>>>>>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
80495>>>>>>>>>        Function_Return sRetval
80496>>>>>>>>>    End_Function
80497>>>>>>>>>
80497>>>>>>>>>    Procedure Set psDriverDefaultValueDate String sValue
80499>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80501>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80502>>>>>>>>>>
80502>>>>>>>>>            Procedure_Return
80503>>>>>>>>>        End
80503>>>>>>>>>>
80503>>>>>>>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
80504>>>>>>>>>    End_Procedure
80505>>>>>>>>>
80505>>>>>>>>>    Function psDriverDefaultValueDate Returns String
80507>>>>>>>>>        String sRetval
80507>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80509>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80510>>>>>>>>>>
80510>>>>>>>>>            Function_Return
80511>>>>>>>>>        End
80511>>>>>>>>>>
80511>>>>>>>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
80512>>>>>>>>>        Function_Return sRetval
80513>>>>>>>>>    End_Function
80514>>>>>>>>>
80514>>>>>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
80516>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80518>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80519>>>>>>>>>>
80519>>>>>>>>>            Procedure_Return
80520>>>>>>>>>        End
80520>>>>>>>>>>
80520>>>>>>>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
80521>>>>>>>>>    End_Procedure
80522>>>>>>>>>
80522>>>>>>>>>    Function psDriverDefaultValueDateTime Returns String
80524>>>>>>>>>        String sRetval
80524>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80526>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80527>>>>>>>>>>
80527>>>>>>>>>            Function_Return
80528>>>>>>>>>        End
80528>>>>>>>>>>
80528>>>>>>>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
80529>>>>>>>>>        Function_Return sRetval
80530>>>>>>>>>    End_Function
80531>>>>>>>>>
80531>>>>>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
80533>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80535>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80536>>>>>>>>>>
80536>>>>>>>>>            Procedure_Return
80537>>>>>>>>>        End
80537>>>>>>>>>>
80537>>>>>>>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
80538>>>>>>>>>    End_Procedure
80539>>>>>>>>>
80539>>>>>>>>>    Function psDriverDefaultValueNumeric Returns String
80541>>>>>>>>>        String sRetval
80541>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80543>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80544>>>>>>>>>>
80544>>>>>>>>>            Function_Return
80545>>>>>>>>>        End
80545>>>>>>>>>>
80545>>>>>>>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
80546>>>>>>>>>        Function_Return sRetval
80547>>>>>>>>>    End_Function
80548>>>>>>>>>
80548>>>>>>>>>    Procedure Set psDriverDefaultValueText String sValue
80550>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80552>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80553>>>>>>>>>>
80553>>>>>>>>>            Procedure_Return
80554>>>>>>>>>        End
80554>>>>>>>>>>
80554>>>>>>>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
80555>>>>>>>>>    End_Procedure
80556>>>>>>>>>
80556>>>>>>>>>    Function psDriverDefaultValueText Returns String
80558>>>>>>>>>        String sRetval
80558>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80560>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80561>>>>>>>>>>
80561>>>>>>>>>            Function_Return
80562>>>>>>>>>        End
80562>>>>>>>>>>
80562>>>>>>>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
80563>>>>>>>>>        Function_Return sRetval
80564>>>>>>>>>    End_Function
80565>>>>>>>>>
80565>>>>>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
80567>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80569>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80570>>>>>>>>>>
80570>>>>>>>>>            Procedure_Return
80571>>>>>>>>>        End
80571>>>>>>>>>>
80571>>>>>>>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
80572>>>>>>>>>    End_Procedure
80573>>>>>>>>>
80573>>>>>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
80575>>>>>>>>>        Boolean bState
80575>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80577>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80578>>>>>>>>>>
80578>>>>>>>>>            Function_Return
80579>>>>>>>>>        End
80579>>>>>>>>>>
80579>>>>>>>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
80580>>>>>>>>>        Function_Return bState
80581>>>>>>>>>    End_Function
80582>>>>>>>>>
80582>>>>>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
80584>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80586>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80587>>>>>>>>>>
80587>>>>>>>>>            Procedure_Return
80588>>>>>>>>>        End
80588>>>>>>>>>>
80588>>>>>>>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
80589>>>>>>>>>    End_Procedure
80590>>>>>>>>>
80590>>>>>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
80592>>>>>>>>>        Boolean bState
80592>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80594>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80595>>>>>>>>>>
80595>>>>>>>>>            Function_Return
80596>>>>>>>>>        End
80596>>>>>>>>>>
80596>>>>>>>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
80597>>>>>>>>>        Function_Return bState
80598>>>>>>>>>    End_Function
80599>>>>>>>>>
80599>>>>>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
80601>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80603>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80604>>>>>>>>>>
80604>>>>>>>>>            Procedure_Return
80605>>>>>>>>>        End
80605>>>>>>>>>>
80605>>>>>>>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
80606>>>>>>>>>    End_Procedure
80607>>>>>>>>>
80607>>>>>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
80609>>>>>>>>>        Boolean bState
80609>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80611>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80612>>>>>>>>>>
80612>>>>>>>>>            Function_Return
80613>>>>>>>>>        End
80613>>>>>>>>>>
80613>>>>>>>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
80614>>>>>>>>>        Function_Return bState
80615>>>>>>>>>    End_Function
80616>>>>>>>>>
80616>>>>>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
80618>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80620>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80621>>>>>>>>>>
80621>>>>>>>>>            Procedure_Return
80622>>>>>>>>>        End
80622>>>>>>>>>>
80622>>>>>>>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
80623>>>>>>>>>    End_Procedure
80624>>>>>>>>>
80624>>>>>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
80626>>>>>>>>>        Boolean bState
80626>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80628>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80629>>>>>>>>>>
80629>>>>>>>>>            Function_Return
80630>>>>>>>>>        End
80630>>>>>>>>>>
80630>>>>>>>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
80631>>>>>>>>>        Function_Return bState
80632>>>>>>>>>    End_Function
80633>>>>>>>>>
80633>>>>>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
80635>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80637>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80638>>>>>>>>>>
80638>>>>>>>>>            Procedure_Return
80639>>>>>>>>>        End
80639>>>>>>>>>>
80639>>>>>>>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
80640>>>>>>>>>    End_Procedure
80641>>>>>>>>>
80641>>>>>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
80643>>>>>>>>>        Boolean bState
80643>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80645>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80646>>>>>>>>>>
80646>>>>>>>>>            Function_Return
80647>>>>>>>>>        End
80647>>>>>>>>>>
80647>>>>>>>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
80648>>>>>>>>>        Function_Return bState
80649>>>>>>>>>    End_Function
80650>>>>>>>>>
80650>>>>>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
80652>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80654>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80655>>>>>>>>>>
80655>>>>>>>>>            Procedure_Return
80656>>>>>>>>>        End
80656>>>>>>>>>>
80656>>>>>>>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
80657>>>>>>>>>    End_Procedure
80658>>>>>>>>>
80658>>>>>>>>>    Function pbDriverDefaultNullableText Returns Boolean
80660>>>>>>>>>        Boolean bState
80660>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80662>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80663>>>>>>>>>>
80663>>>>>>>>>            Function_Return
80664>>>>>>>>>        End
80664>>>>>>>>>>
80664>>>>>>>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
80665>>>>>>>>>        Function_Return bState
80666>>>>>>>>>    End_Function
80667>>>>>>>>>
80667>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
80667>>>>>>>>>    //       the psDriverID *must* be the first property that gets changed!
80667>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
80667>>>>>>>>>    //       for a connection string has the wrong format for that driver.
80667>>>>>>>>>    Procedure Set psDriverID String sValue
80669>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80670>>>>>>>>>        Delegate Set psDriverID to sValue
80672>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80673>>>>>>>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
80674>>>>>>>>>    End_Procedure
80675>>>>>>>>>
80675>>>>>>>>>    Function psDriverID Returns String
80677>>>>>>>>>        String sDriverID
80677>>>>>>>>>
80677>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80678>>>>>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
80678>>>>>>>>>        Delegate Get psDriverID to sDriverID
80680>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80681>>>>>>>>>        Move False to Err
80682>>>>>>>>>
80682>>>>>>>>>        // ...and in case it didn't use property of this class. Then the library is
80682>>>>>>>>>        // probably used as "utilites" from a special made program and
80682>>>>>>>>>        // the ghoSQLConnectionHandler must have been setup
80682>>>>>>>>>        If (sDriverID = "") Begin
80684>>>>>>>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
80685>>>>>>>>>        End
80685>>>>>>>>>>
80685>>>>>>>>>        Function_Return sDriverID
80686>>>>>>>>>    End_Function
80687>>>>>>>>>
80687>>>>>>>>>    Procedure Set piDbType Integer iValue
80689>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80690>>>>>>>>>        Delegate Set piDbType to iValue
80692>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80693>>>>>>>>>        Set piDbType of ghoSQLConnectionHandler to iValue
80694>>>>>>>>>    End_Procedure
80695>>>>>>>>>
80695>>>>>>>>>    Function piDbType Returns Integer
80697>>>>>>>>>        Integer iRetval
80697>>>>>>>>>        Get piDbType of ghoSQLConnectionHandler to iRetval
80698>>>>>>>>>        Function_Return iRetval
80699>>>>>>>>>    End_Function
80700>>>>>>>>>
80700>>>>>>>>>    // Returns the index for the passed sTableName
80700>>>>>>>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
80700>>>>>>>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
80702>>>>>>>>>        Integer iIndex iSize iCount iItem
80702>>>>>>>>>        String[] asTablesArray
80703>>>>>>>>>        String sDatabase sSchema sVal sConnectionString
80703>>>>>>>>>
80703>>>>>>>>>        Move -1 to iIndex
80704>>>>>>>>>        Get psConnectionString to sConnectionString
80705>>>>>>>>>        Get psDatabase to sDatabase
80706>>>>>>>>>        Get psSchema   to sSchema
80707>>>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to asTablesArray
80708>>>>>>>>>        Move (SearchArray(sTableName, asTablesArray, Desktop, (RefFunc(DFSTRICMP)))) to iItem
80709>>>>>>>>>        If (iItem <> -1) Begin
80711>>>>>>>>>            Move iItem to iIndex
80712>>>>>>>>>        End
80712>>>>>>>>>>
80712>>>>>>>>>        Function_Return iIndex
80713>>>>>>>>>    End_Function
80714>>>>>>>>>
80714>>>>>>>>>    // Returns all schemas as a string array for the passed driver id.
80714>>>>>>>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
80716>>>>>>>>>        String[] sReturnArray
80717>>>>>>>>>        Boolean bOK
80717>>>>>>>>>
80717>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80718>>>>>>>>>        If (bOK = False) Begin
80720>>>>>>>>>            Function_Return sReturnArray
80721>>>>>>>>>        End
80721>>>>>>>>>>
80721>>>>>>>>>
80721>>>>>>>>>        Case Begin
80721>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80723>>>>>>>>>                Get _SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
80724>>>>>>>>>                Case Break
80725>>>>>>>>>
80725>>>>>>>>>            Case Else
80725>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
80726>>>>>>>>>>
80726>>>>>>>>>                Case Break
80727>>>>>>>>>        Case End
80727>>>>>>>>>
80727>>>>>>>>>        Function_Return sReturnArray
80728>>>>>>>>>    End_Function
80729>>>>>>>>>
80729>>>>>>>>>    // Returns a string array with all tables for the current database.
80729>>>>>>>>>    Function _SqlUtilEnumerateTables String sDriverID String sDatabase String sSchema Returns String[]
80731>>>>>>>>>        String[] asReturnArray
80732>>>>>>>>>        String sConnectionString sSelect
80732>>>>>>>>>        Integer iSize iCount iDbType
80732>>>>>>>>>        Boolean bOK
80732>>>>>>>>>
80732>>>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
80734>>>>>>>>>            Function_Return asReturnArray
80735>>>>>>>>>        End
80735>>>>>>>>>>
80735>>>>>>>>>
80735>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80736>>>>>>>>>        If (bOK = False) Begin
80738>>>>>>>>>            Function_Return asReturnArray
80739>>>>>>>>>        End
80739>>>>>>>>>>
80739>>>>>>>>>        If (sSchema = "") Begin
80741>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
80742>>>>>>>>>        End
80742>>>>>>>>>>
80742>>>>>>>>>
80742>>>>>>>>>        Get psConnectionString to sConnectionString
80743>>>>>>>>>
80743>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
80743>>>>>>>>>        // the dbType.
80743>>>>>>>>>        Get piDbType to iDbType
80744>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
80746>>>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
80748>>>>>>>>>                Move MSSQLDRV_ID to sDriverID
80749>>>>>>>>>            End
80749>>>>>>>>>>
80749>>>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
80751>>>>>>>>>                Move DB2_DRV_ID to sDriverID
80752>>>>>>>>>            End
80752>>>>>>>>>>
80752>>>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
80754>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
80755>>>>>>>>>            End
80755>>>>>>>>>>
80755>>>>>>>>>        End
80755>>>>>>>>>>
80755>>>>>>>>>
80755>>>>>>>>>        Case Begin
80755>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80757>>>>>>>>>                Get _SqlTableArrayDAW to asReturnArray
80758>>>>>>>>>                Case Break
80759>>>>>>>>>
80759>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80762>>>>>>>>>                Get _SqlTableArrayDAW to asReturnArray
80763>>>>>>>>>                Case Break
80764>>>>>>>>>
80764>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
80767>>>>>>>>>                Get _SqlTableArrayDAW to asReturnArray
80768>>>>>>>>>                Case Break
80769>>>>>>>>>
80769>>>>>>>>>            Case Else
80769>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTables function."
80770>>>>>>>>>>
80770>>>>>>>>>                Case Break
80771>>>>>>>>>        Case End
80771>>>>>>>>>
80771>>>>>>>>>        Function_Return asReturnArray
80772>>>>>>>>>    End_Function
80773>>>>>>>>>
80773>>>>>>>>>    // Returns all table spaces as a string array for the passed driver id.
80773>>>>>>>>>    Function _SqlUtilEnumerateTablespaces String sDriverID Returns String[]
80775>>>>>>>>>        String[] sReturnArray
80776>>>>>>>>>        Boolean bOK
80776>>>>>>>>>
80776>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80777>>>>>>>>>        If (bOK = False) Begin
80779>>>>>>>>>            Function_Return sReturnArray
80780>>>>>>>>>        End
80780>>>>>>>>>>
80780>>>>>>>>>
80780>>>>>>>>>        Case Begin
80780>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80782>>>>>>>>>                Get _SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
80783>>>>>>>>>                Case Break
80784>>>>>>>>>
80784>>>>>>>>>            Case Else
80784>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTablespaces function."
80785>>>>>>>>>>
80785>>>>>>>>>                Case Break
80786>>>>>>>>>        Case End
80786>>>>>>>>>
80786>>>>>>>>>        Function_Return sReturnArray
80787>>>>>>>>>    End_Function
80788>>>>>>>>>
80788>>>>>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
80788>>>>>>>>>    Function _SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
80790>>>>>>>>>        String[] sReturnArray
80791>>>>>>>>>        String sConnectionString sSelect sSchema
80791>>>>>>>>>        Boolean bOK
80791>>>>>>>>>        Integer iDbType
80791>>>>>>>>>
80791>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80792>>>>>>>>>        If (bOK = False) Begin
80794>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80795>>>>>>>>>>
80795>>>>>>>>>            Function_Return sReturnArray
80796>>>>>>>>>        End
80796>>>>>>>>>>
80796>>>>>>>>>
80796>>>>>>>>>        Get psConnectionString to sConnectionString
80797>>>>>>>>>        Get psSchema to sSchema
80798>>>>>>>>>
80798>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
80798>>>>>>>>>        // the dbType.
80798>>>>>>>>>        Get piDbType to iDbType
80799>>>>>>>>>
80799>>>>>>>>>        Case Begin
80799>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
80801>>>>>>>>>                If (iDbType = EN_DbTypeMySQL) Begin
80803>>>>>>>>>                    Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
80804>>>>>>>>>                End
80804>>>>>>>>>>
80804>>>>>>>>>                If (iDbType = EN_DbTypePostgre) Begin
80806>>>>>>>>>                    Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
80807>>>>>>>>>                End
80807>>>>>>>>>>
80807>>>>>>>>>                If (iDbType = EN_DbTypeMSSQL) Begin
80809>>>>>>>>>                    Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
80810>>>>>>>>>                End
80810>>>>>>>>>>
80810>>>>>>>>>
80810>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80811>>>>>>>>>                Case Break
80812>>>>>>>>>
80812>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80815>>>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
80816>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80817>>>>>>>>>                Case Break
80818>>>>>>>>>
80818>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80821>>>>>>>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
80822>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80823>>>>>>>>>                Case Break
80824>>>>>>>>>
80824>>>>>>>>>            Case Else
80824>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateColumns function."
80825>>>>>>>>>>
80825>>>>>>>>>                Case Break
80826>>>>>>>>>        Case End
80826>>>>>>>>>
80826>>>>>>>>>        Function_Return sReturnArray
80827>>>>>>>>>    End_Function
80828>>>>>>>>>
80828>>>>>>>>>
80828>>>>>>>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
80828>>>>>>>>>    Function _SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
80830>>>>>>>>>        String[] asReturnArray asReturnArray2
80832>>>>>>>>>        String sConnectionString sSelect sSchema
80832>>>>>>>>>        Boolean bOK
80832>>>>>>>>>        Integer iCount iSize
80832>>>>>>>>>
80832>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80833>>>>>>>>>        If (bOK = False) Begin
80835>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80836>>>>>>>>>>
80836>>>>>>>>>            Function_Return asReturnArray
80837>>>>>>>>>        End
80837>>>>>>>>>>
80837>>>>>>>>>
80837>>>>>>>>>        Get psConnectionString to sConnectionString
80838>>>>>>>>>        Get psSchema to sSchema
80839>>>>>>>>>
80839>>>>>>>>>        Case Begin
80839>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80841>>>>>>>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
80842>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to asReturnArray
80843>>>>>>>>>                Case Break
80844>>>>>>>>>
80844>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80847>>>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
80848>>>>>>>>>>
80848>>>>>>>>>//                Move () to sSelect
80848>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to asReturnArray
80848>>>>>>>>>                Case Break
80849>>>>>>>>>
80849>>>>>>>>>            Case Else
80849>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateIndexes function."
80850>>>>>>>>>>
80850>>>>>>>>>                Case Break
80851>>>>>>>>>        Case End
80851>>>>>>>>>
80851>>>>>>>>>        Move (SizeOfArray(asReturnArray)) to iSize
80852>>>>>>>>>        Decrement iSize
80853>>>>>>>>>        For iCount from 0 to iSize
80859>>>>>>>>>>
80859>>>>>>>>>            If (Trim(asReturnArray[iCount]) <> "") Begin
80861>>>>>>>>>                Move asReturnArray[iCount] to asReturnArray2[SizeOfArray(asReturnArray2)]
80862>>>>>>>>>            End
80862>>>>>>>>>>
80862>>>>>>>>>        Loop
80863>>>>>>>>>>
80863>>>>>>>>>
80863>>>>>>>>>        Function_Return asReturnArray2
80864>>>>>>>>>    End_Function
80865>>>>>>>>>
80865>>>>>>>>>    // Returns a string array with all table names the passed table handle has relation ships with.
80865>>>>>>>>>    // The format of the array is "TableName.FieldName"
80865>>>>>>>>>    Function _SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
80867>>>>>>>>>        String[] sFileNameArray sFieldNameArray
80869>>>>>>>>>        tSQLRelation[] sRelationsArray
80869>>>>>>>>>        tSQLRelation[] sRelationsArray
80870>>>>>>>>>        String sConnectionString sSelect sSchema sFileName sFieldName
80870>>>>>>>>>        Boolean bOK
80870>>>>>>>>>        Integer iCount iSize iLength
80870>>>>>>>>>
80870>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80871>>>>>>>>>        If (bOK = False) Begin
80873>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80874>>>>>>>>>>
80874>>>>>>>>>            Function_Return sRelationsArray
80875>>>>>>>>>        End
80875>>>>>>>>>>
80875>>>>>>>>>
80875>>>>>>>>>        Get psConnectionString to sConnectionString
80876>>>>>>>>>        Get psSchema to sSchema
80877>>>>>>>>>
80877>>>>>>>>>        Case Begin
80877>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80879>>>>>>>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
80880>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
80881>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
80882>>>>>>>>>                Case Break
80883>>>>>>>>>
80883>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80886>>>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
80887>>>>>>>>>>
80887>>>>>>>>>//                Move () to sSelect
80887>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80887>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
80887>>>>>>>>>                Case Break
80888>>>>>>>>>
80888>>>>>>>>>            Case Else
80888>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to the _SqlUtilEnumerateRelations function."
80889>>>>>>>>>>
80889>>>>>>>>>                Case Break
80890>>>>>>>>>        Case End
80890>>>>>>>>>
80890>>>>>>>>>        Move (Length(sTableName)) to iLength
80891>>>>>>>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
80892>>>>>>>>>        Move (SizeOfArray(sFileNameArray)) to iSize
80893>>>>>>>>>        Decrement iSize
80894>>>>>>>>>        For iCount from 0 to iSize
80900>>>>>>>>>>
80900>>>>>>>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
80902>>>>>>>>>                Move sFileNameArray[iCount]         to sFileName
80903>>>>>>>>>                Move sFieldNameArray[iCount]        to sFieldName
80904>>>>>>>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
80905>>>>>>>>>                Move sFileName  to sRelationsArray[iCount].sFileName
80906>>>>>>>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
80907>>>>>>>>>            End
80907>>>>>>>>>>
80907>>>>>>>>>        Loop
80908>>>>>>>>>>
80908>>>>>>>>>
80908>>>>>>>>>        Function_Return sRelationsArray
80909>>>>>>>>>    End_Function
80910>>>>>>>>>
80910>>>>>>>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
80912>>>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
80912>>>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
80913>>>>>>>>>        String[] sUsers sPrograms
80915>>>>>>>>>        String sSelect
80915>>>>>>>>>        Integer iSize iCount
80915>>>>>>>>>
80915>>>>>>>>>        Case Begin
80915>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80917>>>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
80918>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sUsers
80919>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sPrograms
80920>>>>>>>>>                Case Break
80921>>>>>>>>>            Case Else
80921>>>>>>>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
80922>>>>>>>>>>
80922>>>>>>>>>        Case End
80922>>>>>>>>>
80922>>>>>>>>>        Move (SizeOfArray(sUsers)) to iSize
80923>>>>>>>>>        Decrement iSize
80924>>>>>>>>>        For iCount from 0 to iSize
80930>>>>>>>>>>
80930>>>>>>>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
80931>>>>>>>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
80932>>>>>>>>>        Loop
80933>>>>>>>>>>
80933>>>>>>>>>
80933>>>>>>>>>        Function_Return SQLLoggedInUser
80934>>>>>>>>>    End_Function
80935>>>>>>>>>
80935>>>>>>>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
80935>>>>>>>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
80935>>>>>>>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
80937>>>>>>>>>        String[] sFilesData
80938>>>>>>>>>        Boolean bExists
80938>>>>>>>>>        Integer iCh
80938>>>>>>>>>        String sFileName sExt
80938>>>>>>>>>
80938>>>>>>>>>        Get vFolderExists sDataPath to bExists
80939>>>>>>>>>        If (bExists = True) Begin
80941>>>>>>>>>            Move (Utf8ToAnsi(Trim(sDataPath))) to sDataPath
80942>>>>>>>>>            Move ("dir:" + sDataPath)      to sDataPath
80943>>>>>>>>>            Get Seq_New_Channel to iCh  // get free channel for input
80944>>>>>>>>>            Direct_Input channel iCh sDataPath
80946>>>>>>>>>                Repeat
80946>>>>>>>>>>
80946>>>>>>>>>                    Readln channel iCh sFileName
80948>>>>>>>>>                    Get ParseFileExtension sFileName to sExt
80949>>>>>>>>>                    If (Uppercase(sExt) = "INT") Begin
80951>>>>>>>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
80953>>>>>>>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
80954>>>>>>>>>                        End
80954>>>>>>>>>>
80954>>>>>>>>>                    End
80954>>>>>>>>>>
80954>>>>>>>>>                Until (SeqEof = True)
80956>>>>>>>>>            Close_Input channel iCh
80958>>>>>>>>>            Send Seq_Release_Channel iCh
80959>>>>>>>>>        End
80959>>>>>>>>>>
80959>>>>>>>>>        Function_Return sFilesData
80960>>>>>>>>>    End_Function
80961>>>>>>>>>
80961>>>>>>>>>    // Only done for MSSQLDRV_ID so far...
80961>>>>>>>>>    Function _SqlEnumerateDatabaseCollations String sDriverID Returns String[]
80963>>>>>>>>>        String sSQL sConnectionID sConnectionString sSelect sName sPre
80963>>>>>>>>>        String sDescription sFrom sSys sValue sPrevious
80963>>>>>>>>>        Handle hStmt hoSQLManager hoSQLConnect
80963>>>>>>>>>        Integer iFetchResult iRows iColumn iPos
80963>>>>>>>>>        tSQLConnection SQLConnection
80963>>>>>>>>>        tSQLConnection SQLConnection
80963>>>>>>>>>        String[] asCollations
80964>>>>>>>>>        
80964>>>>>>>>>        If (sDriverID = "") Begin
80966>>>>>>>>>            Error DFERR_PROGRAM "The database driver ID was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
80967>>>>>>>>>>
80967>>>>>>>>>            Function_Return asCollations
80968>>>>>>>>>        End
80968>>>>>>>>>>
80968>>>>>>>>>
80968>>>>>>>>>        // Only done for MSSQLDRV_ID so far...
80968>>>>>>>>>        If (sDriverID <> MSSQLDRV_ID) Begin
80970>>>>>>>>>            Function_Return asCollations
80971>>>>>>>>>        End                 
80971>>>>>>>>>>
80971>>>>>>>>>
80971>>>>>>>>>        Get phoSQLManager to hoSQLManager
80972>>>>>>>>>        Get psConnectionID     to sConnectionID
80973>>>>>>>>>        Get psConnectionString to sConnectionString
80974>>>>>>>>>        Move 0 to LastErr
80975>>>>>>>>>
80975>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80976>>>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hoSQLConnect
80977>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80978>>>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
80980>>>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
80981>>>>>>>>>>
80981>>>>>>>>>            Function_Return asCollations
80982>>>>>>>>>        End
80982>>>>>>>>>>
80982>>>>>>>>>
80982>>>>>>>>>        Get SqlOpen of hoSQLConnect to hStmt
80983>>>>>>>>>
80983>>>>>>>>>        If (hStmt = 0) Begin
80985>>>>>>>>>            Send SqlDisconnect of hoSQLManager
80986>>>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
80987>>>>>>>>>>
80987>>>>>>>>>            Function_Return asCollations
80988>>>>>>>>>        End
80988>>>>>>>>>>
80988>>>>>>>>>
80988>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect      to sSelect
80989>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName        to sName
80990>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDescription to sDescription
80991>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom        to sFrom
80992>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys         to sSys
80993>>>>>>>>>
80993>>>>>>>>>        // MS-SQL Syntax:  
80993>>>>>>>>>        // SELECT name, description
80993>>>>>>>>>        //   from sys.fn_helpcollations();
80993>>>>>>>>>        Move (sSelect  * String(sName) * String(",") * String(sDescription) * String(sFrom) * String(sSys) * String(".fn_helpcollations();")) to sSQL
80994>>>>>>>>>
80994>>>>>>>>>        Move 1 to iColumn
80995>>>>>>>>>        Send SqlExecDirect of hStmt sSQL
80996>>>>>>>>>        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
80997>>>>>>>>>        Repeat
80997>>>>>>>>>>
80997>>>>>>>>>            Get SQLFetch of hStmt to iFetchResult
80998>>>>>>>>>            If (iFetchResult <> 0) Begin
81000>>>>>>>>>                Get SQLColumnValue of hStmt iColumn to sValue 
81001>>>>>>>>>                If (sValue <> sPrevious) Begin         
81003>>>>>>>>>                    // We need to skip all collations starting with "SQL" because they
81003>>>>>>>>>                    // are obsolete and for pre-SQL Server 2000.
81003>>>>>>>>>                    Move (Pos("SQL", Uppercase(sValue))) to iPos
81004>>>>>>>>>                    If (iPos <> 1) Begin
81006>>>>>>>>>                        Move (Trim(sValue)) to asCollations[SizeOfArray(asCollations)
81007>>>>>>>>>                    End
81007>>>>>>>>>>
81007>>>>>>>>>                End
81007>>>>>>>>>>
81007>>>>>>>>>                Move sValue to sPrevious
81008>>>>>>>>>            End
81008>>>>>>>>>>
81008>>>>>>>>>        Until (iFetchResult = 0)
81010>>>>>>>>>        Send SQLClose of hStmt
81011>>>>>>>>>        Send SQLDisconnect of hoSQLConnect
81012>>>>>>>>>
81012>>>>>>>>>        Function_Return asCollations
81013>>>>>>>>>    End_Function
81014>>>>>>>>>
81014>>>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
81014>>>>>>>>>    // for DAW drivers.
81014>>>>>>>>>    // Returns: A string array.
81014>>>>>>>>>    Function _SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
81016>>>>>>>>>        String[] sReturnArray
81017>>>>>>>>>        String sValue sPrevious
81017>>>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
81017>>>>>>>>>        Integer iFetchResult iRows
81017>>>>>>>>>        tSQLConnection SQLConnection
81017>>>>>>>>>        tSQLConnection SQLConnection
81017>>>>>>>>>
81017>>>>>>>>>        Get phoSQLManager to hoSQLHandler
81018>>>>>>>>>
81018>>>>>>>>>        If (hoSQLHandler <> 0) Begin
81020>>>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81021>>>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
81022>>>>>>>>>
81022>>>>>>>>>            If (hoSQLConnect <> 0) Begin
81024>>>>>>>>>                Get SQLOpen of hoSQLConnect to hstmt
81025>>>>>>>>>                If (hstmt <> 0) Begin
81027>>>>>>>>>                    Send SqlExecDirect of hstmt sStmt
81028>>>>>>>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
81029>>>>>>>>>                    Repeat
81029>>>>>>>>>>
81029>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
81030>>>>>>>>>                        If (iFetchResult <> 0) Begin
81032>>>>>>>>>                            Get SQLColumnValue of hstmt iColumn to sValue
81033>>>>>>>>>                            If (sValue <> sPrevious) Begin
81035>>>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
81036>>>>>>>>>                            End
81036>>>>>>>>>>
81036>>>>>>>>>                            Move sValue to sPrevious
81037>>>>>>>>>                        End
81037>>>>>>>>>>
81037>>>>>>>>>                    Until (iFetchResult = 0)
81039>>>>>>>>>                    Send SQLClose of hstmt
81040>>>>>>>>>                End
81040>>>>>>>>>>
81040>>>>>>>>>                Send SQLDisconnect of hoSQLConnect
81041>>>>>>>>>            End
81041>>>>>>>>>>
81041>>>>>>>>>        End
81041>>>>>>>>>>
81041>>>>>>>>>
81041>>>>>>>>>        Function_Return sReturnArray
81042>>>>>>>>>    End_Function
81043>>>>>>>>>
81043>>>>>>>>>    Function _SqlDatabasesArrayDB2 Returns String[]
81045>>>>>>>>>        String[] sReturnArray
81046>>>>>>>>>        String sDataSource
81046>>>>>>>>>        Handle hoSQLHandler
81046>>>>>>>>>        Integer iItem
81046>>>>>>>>>
81046>>>>>>>>>        Get phoDB2SQLHandler to hoSQLHandler
81047>>>>>>>>>        Send SeedDataSources of hoSQLHandler
81048>>>>>>>>>
81048>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81049>>>>>>>>>
81049>>>>>>>>>        Repeat
81049>>>>>>>>>>
81049>>>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
81050>>>>>>>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
81051>>>>>>>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
81052>>>>>>>>>            Increment iItem
81053>>>>>>>>>        Until (sDataSource = "")
81055>>>>>>>>>
81055>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81056>>>>>>>>>
81056>>>>>>>>>        Function_Return sReturnArray
81057>>>>>>>>>    End_Function
81058>>>>>>>>>
81058>>>>>>>>>    Function _SqlDatabaseSourcesArrayODBC Returns String[]
81060>>>>>>>>>        String[] sReturnArray
81061>>>>>>>>>        String sDataSource
81061>>>>>>>>>        Handle hoSQLHandler
81061>>>>>>>>>        Integer iItem
81061>>>>>>>>>
81061>>>>>>>>>        Get phoODBCSQLHandler to hoSQLHandler
81062>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81063>>>>>>>>>
81063>>>>>>>>>        Send SeedDataSources of hoSQLHandler
81064>>>>>>>>>
81064>>>>>>>>>        Repeat
81064>>>>>>>>>>
81064>>>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
81065>>>>>>>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
81067>>>>>>>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
81068>>>>>>>>>                Increment iItem
81069>>>>>>>>>            End
81069>>>>>>>>>>
81069>>>>>>>>>        Until (sDataSource = "")
81071>>>>>>>>>
81071>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81072>>>>>>>>>
81072>>>>>>>>>        Function_Return sReturnArray
81073>>>>>>>>>    End_Function
81074>>>>>>>>>
81074>>>>>>>>>    Function _SqlDatabasesArrayODBC Returns tSQLIntTableInfo[]
81076>>>>>>>>>        String[] sDataSources
81077>>>>>>>>>        tSQLConnection SQLConnection
81077>>>>>>>>>        tSQLConnection SQLConnection
81077>>>>>>>>>        tSQLIntTableInfo[] sReturnArray
81077>>>>>>>>>        tSQLIntTableInfo[] sReturnArray
81078>>>>>>>>>        Integer iDataSources iCount iItem
81078>>>>>>>>>        String sConnection sServer sDatabase sKey sSubKey
81078>>>>>>>>>        Handle hoIniFile hoRegistry hoODBCDataSources
81078>>>>>>>>>        Boolean bExists bKeyOpened
81078>>>>>>>>>
81078>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81079>>>>>>>>>        Move SQLConnection.sConnectionString to sConnection
81080>>>>>>>>>        Move SQLConnection.sServer           to sServer
81081>>>>>>>>>
81081>>>>>>>>>        // FileDSN - read DATABASE name from DSN ini-file
81081>>>>>>>>>        If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
81083>>>>>>>>>            Get Create (RefClass(cIniFile)) to hoIniFile
81084>>>>>>>>>            Set psFileName of hoIniFile to sServer
81085>>>>>>>>>            Get ReadString of hoIniFile CS_SQLODBCIniSectionName CS_SQLIniDatabaseKeyword "" to sDatabase
81086>>>>>>>>>            Move sDatabase to sReturnArray[0].sDatabaseName
81087>>>>>>>>>            Send Destroy of hoIniFile
81088>>>>>>>>>        End
81088>>>>>>>>>>
81088>>>>>>>>>
81088>>>>>>>>>        // DSN - read DATABASE name from the registry
81088>>>>>>>>>        Else Begin
81089>>>>>>>>>            Get Create (RefClass(cRegistry)) to hoRegistry
81090>>>>>>>>>
81090>>>>>>>>>            // We start with checking the "System DNS" area in the registry as it is the
81090>>>>>>>>>            // most probably place the info is kept that we're after.
81090>>>>>>>>>            Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
81091>>>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
81092>>>>>>>>>            Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
81093>>>>>>>>>            If (bExists = True) Begin
81095>>>>>>>>>                Move "SOFTWARE\Wow6432Node\ODBC\ODBC.INI" to sKey
81096>>>>>>>>>            End
81096>>>>>>>>>>
81096>>>>>>>>>            Else Begin
81097>>>>>>>>>                Move "SOFTWARE\ODBC\ODBC.INI" to sKey
81098>>>>>>>>>            End
81098>>>>>>>>>>
81098>>>>>>>>>
81098>>>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
81099>>>>>>>>>            If (bExists) Begin
81101>>>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
81102>>>>>>>>>                If (bKeyOpened) Begin
81104>>>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
81105>>>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
81106>>>>>>>>>                    If (iDataSources > 0) Begin
81108>>>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
81109>>>>>>>>>                        Decrement iDataSources
81110>>>>>>>>>                        for iCount from 0 to iDataSources
81116>>>>>>>>>>
81116>>>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
81117>>>>>>>>>                        Loop
81118>>>>>>>>>>
81118>>>>>>>>>                        Move 0 to iItem
81119>>>>>>>>>                        for iCount from 0 to iDataSources
81125>>>>>>>>>>
81125>>>>>>>>>                            Move sDataSources[iCount] to sSubKey
81126>>>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
81127>>>>>>>>>                            If (bKeyOpened = True) Begin
81129>>>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
81130>>>>>>>>>                                If (bExists = True) Begin
81132>>>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
81133>>>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
81134>>>>>>>>>                                    Increment iItem
81135>>>>>>>>>                                End
81135>>>>>>>>>>
81135>>>>>>>>>                            End
81135>>>>>>>>>>
81135>>>>>>>>>                        Loop
81136>>>>>>>>>>
81136>>>>>>>>>                    End
81136>>>>>>>>>>
81136>>>>>>>>>                    Send CloseKey of hoRegistry
81137>>>>>>>>>                    Send Destroy of hoODBCDataSources
81138>>>>>>>>>                End
81138>>>>>>>>>>
81138>>>>>>>>>            End
81138>>>>>>>>>>
81138>>>>>>>>>
81138>>>>>>>>>            // We then check the "User DNS" area in the registry.
81138>>>>>>>>>            Set phRootKey of hoRegistry to HKEY_CURRENT_USER
81139>>>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
81140>>>>>>>>>            Move "SOFTWARE\ODBC\ODBC.INI" to sKey
81141>>>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
81142>>>>>>>>>
81142>>>>>>>>>            If (bExists) Begin
81144>>>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
81145>>>>>>>>>                If (bKeyOpened) Begin
81147>>>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
81148>>>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
81149>>>>>>>>>                    If (iDataSources > 0) Begin
81151>>>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
81152>>>>>>>>>                        Decrement iDataSources
81153>>>>>>>>>                        for iCount from 0 to iDataSources
81159>>>>>>>>>>
81159>>>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
81160>>>>>>>>>                        Loop
81161>>>>>>>>>>
81161>>>>>>>>>                        for iCount from 0 to iDataSources
81167>>>>>>>>>>
81167>>>>>>>>>                            Move sDataSources[iCount] to sSubKey
81168>>>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
81169>>>>>>>>>                            If (bKeyOpened = True) Begin
81171>>>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
81172>>>>>>>>>                                If (bExists = True) Begin
81174>>>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
81175>>>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
81176>>>>>>>>>                                    Increment iItem
81177>>>>>>>>>                                End
81177>>>>>>>>>>
81177>>>>>>>>>                            End
81177>>>>>>>>>>
81177>>>>>>>>>                        Loop
81178>>>>>>>>>>
81178>>>>>>>>>                    End
81178>>>>>>>>>>
81178>>>>>>>>>                    Send CloseKey of hoRegistry
81179>>>>>>>>>                    Send Destroy of hoODBCDataSources
81180>>>>>>>>>                End
81180>>>>>>>>>>
81180>>>>>>>>>            End
81180>>>>>>>>>>
81180>>>>>>>>>
81180>>>>>>>>>            Send Destroy of hoRegistry
81181>>>>>>>>>        End
81181>>>>>>>>>>
81181>>>>>>>>>
81181>>>>>>>>>        Function_Return sReturnArray
81182>>>>>>>>>    End_Function
81183>>>>>>>>>
81183>>>>>>>>>    // We might have a split Sql script where the info about which database to use is
81183>>>>>>>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
81183>>>>>>>>>    // insert it for scriplets to come after the first one.
81183>>>>>>>>>    Function _SqlFormatStatement String sStmt Returns String
81185>>>>>>>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
81185>>>>>>>>>        Integer iStart iEnd iDbType
81185>>>>>>>>>        Boolean bOK
81185>>>>>>>>>
81185>>>>>>>>>        Get piDbType to iDbType
81186>>>>>>>>>        Get psDriverID to sDriverID
81187>>>>>>>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
81188>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
81189>>>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
81190>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
81191>>>>>>>>>        Move (Replaces(" ", sStmt, "")) to sTmp
81192>>>>>>>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
81194>>>>>>>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
81195>>>>>>>>>            Move (Pos("]", sTmp)) to iEnd
81196>>>>>>>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
81197>>>>>>>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
81198>>>>>>>>>            Set Private.psUseDatabase to sUseDatabase
81199>>>>>>>>>        End
81199>>>>>>>>>>
81199>>>>>>>>>        Else Begin
81200>>>>>>>>>            Move (Uppercase(sStmt)) to sTmp
81201>>>>>>>>>
81201>>>>>>>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
81201>>>>>>>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
81203>>>>>>>>>                Get Private.psUseDatabase to sUseDatabase
81204>>>>>>>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
81205>>>>>>>>>            End
81205>>>>>>>>>>
81205>>>>>>>>>
81205>>>>>>>>>            // This is a bit special to place here but was done so because it was easier that way.
81205>>>>>>>>>            // We will get an error when trying to create a view if it already exists.
81205>>>>>>>>>            // So to avoid such errors; we first remove it & then recreate it.
81205>>>>>>>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
81208>>>>>>>>>                // Make sure we only have one space between statements/words.
81208>>>>>>>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
81209>>>>>>>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
81210>>>>>>>>>                Move (Trim(sTmp)) to sTmp
81211>>>>>>>>>                Move (Pos(" ", sTmp)) to iEnd
81212>>>>>>>>>                Move (Left(sTmp, iEnd)) to sTmp
81213>>>>>>>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
81215>>>>>>>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
81216>>>>>>>>>                End
81216>>>>>>>>>>
81216>>>>>>>>>                Move (Trim(sTmp)) to sTmp
81217>>>>>>>>>                // Remove data view as it already exists!
81217>>>>>>>>>                Get _SqlViewRemove sDriverID sTmp to bOK
81218>>>>>>>>>            End
81218>>>>>>>>>>
81218>>>>>>>>>        End
81218>>>>>>>>>>
81218>>>>>>>>>
81218>>>>>>>>>        Function_Return sStmt
81219>>>>>>>>>    End_Function
81220>>>>>>>>>
81220>>>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
81220>>>>>>>>>    Function _SqlViewRemove String sDataView Returns Boolean
81222>>>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
81222>>>>>>>>>        Integer iRetval
81222>>>>>>>>>        Boolean bOK
81222>>>>>>>>>
81222>>>>>>>>>        Get psDriverID to sDriverID
81223>>>>>>>>>        Get _UtilDeleteCacheFile sDataView to iRetval
81224>>>>>>>>>
81224>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
81225>>>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
81226>>>>>>>>>        Set psSQLStatementString to sSQLString
81227>>>>>>>>>
81227>>>>>>>>>        // As we don't check if the view exist or not, it might happen
81227>>>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
81227>>>>>>>>>        Move False to Err
81228>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
81229>>>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
81230>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
81231>>>>>>>>>        Move 0 to LastErr
81232>>>>>>>>>
81232>>>>>>>>>        // We also need to remove the cache-file since the table has been changed
81232>>>>>>>>>        Get _UtilDeleteCacheFile sDataView to bOK
81233>>>>>>>>>
81233>>>>>>>>>        Function_Return (Err = False)
81234>>>>>>>>>    End_Function
81235>>>>>>>>>
81235>>>>>>>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
81235>>>>>>>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
81237>>>>>>>>>        String sRetval
81237>>>>>>>>>        Integer iDbType iIndex
81237>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
81237>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
81238>>>>>>>>>        tSQLKeyWords   SQLKeyWords
81238>>>>>>>>>        tSQLKeyWords   SQLKeyWords
81238>>>>>>>>>
81238>>>>>>>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
81238>>>>>>>>>        Move "" to sRetval
81239>>>>>>>>>        Get piDbType to iDbType
81240>>>>>>>>>        Move iDbType             to SQLKeyWords.iSQLDbType
81241>>>>>>>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
81242>>>>>>>>>
81242>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
81243>>>>>>>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
81244>>>>>>>>>        If (iIndex >= 0) Begin
81246>>>>>>>>>            Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
81247>>>>>>>>>        End
81247>>>>>>>>>>
81247>>>>>>>>>
81247>>>>>>>>>        Function_Return sRetval
81248>>>>>>>>>    End_Function
81249>>>>>>>>>
81249>>>>>>>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
81249>>>>>>>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
81251>>>>>>>>>        String[] sSQLScriptArray
81252>>>>>>>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
81252>>>>>>>>>        Integer iSize iCount
81252>>>>>>>>>        Boolean bCommentStart bCommentEnd bDashComment
81252>>>>>>>>>
81252>>>>>>>>>        Move False to bCommentStart
81253>>>>>>>>>        Move False to bCommentEnd
81254>>>>>>>>>        Move False to bDashComment
81255>>>>>>>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
81256>>>>>>>>>        Move "*/"  to sCommentEnd
81257>>>>>>>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
81258>>>>>>>>>
81258>>>>>>>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
81259>>>>>>>>>        Decrement iSize
81260>>>>>>>>>        Move "" to sText
81261>>>>>>>>>
81261>>>>>>>>>        for iCount from 0 to iSize
81267>>>>>>>>>>
81267>>>>>>>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
81268>>>>>>>>>            Move (Trim(sLine)) to sTmp
81269>>>>>>>>>            If (sTmp <> "") Begin
81271>>>>>>>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
81272>>>>>>>>>                If (bCommentStart = False) Begin
81274>>>>>>>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
81275>>>>>>>>>                    If (bCommentStart = False) Begin
81277>>>>>>>>>                    End
81277>>>>>>>>>>
81277>>>>>>>>>                End
81277>>>>>>>>>>
81277>>>>>>>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
81278>>>>>>>>>                If (bCommentEnd = True) Begin
81280>>>>>>>>>                    Move False to bCommentStart
81281>>>>>>>>>                End
81281>>>>>>>>>>
81281>>>>>>>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
81283>>>>>>>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
81284>>>>>>>>>                End
81284>>>>>>>>>>
81284>>>>>>>>>            End
81284>>>>>>>>>>
81284>>>>>>>>>        Loop
81285>>>>>>>>>>
81285>>>>>>>>>
81285>>>>>>>>>        // Update the retval struct array:
81285>>>>>>>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
81286>>>>>>>>>        Function_Return SqlScriptArray
81287>>>>>>>>>    End_Function
81288>>>>>>>>>
81288>>>>>>>>>    // Helper function that builds a string like;
81288>>>>>>>>>    // "SELECT name from [Master].[sys].[databases] where name"
81288>>>>>>>>>    Function _SqlSelectFromWhereName Returns String
81290>>>>>>>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
81290>>>>>>>>>
81290>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
81291>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName         to sName
81292>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
81293>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
81294>>>>>>>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
81295>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
81296>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
81297>>>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
81298>>>>>>>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
81299>>>>>>>>>        Function_Return sRetval
81300>>>>>>>>>    End_Function
81301>>>>>>>>>
81301>>>>>>>>>    // Helper function to create a SQL statement like;
81301>>>>>>>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
81301>>>>>>>>>    // Used for checking if an index exists.
81301>>>>>>>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
81303>>>>>>>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
81303>>>>>>>>>
81303>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
81304>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
81305>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
81306>>>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
81307>>>>>>>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
81308>>>>>>>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
81309>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName to sName
81310>>>>>>>>>
81310>>>>>>>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
81311>>>>>>>>>
81311>>>>>>>>>        Function_Return sRetval
81312>>>>>>>>>    End_Function
81313>>>>>>>>>
81313>>>>>>>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
81313>>>>>>>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
81313>>>>>>>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
81315>>>>>>>>>        String sRetval
81315>>>>>>>>>        If (iLength <> 0) Begin
81317>>>>>>>>>            Move ("(" + String(iLength)) to sRetval
81318>>>>>>>>>            If (iDecimals <> 0) Begin
81320>>>>>>>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
81321>>>>>>>>>            End
81321>>>>>>>>>>
81321>>>>>>>>>            Move (sRetval + ")") to sRetval
81322>>>>>>>>>        End
81322>>>>>>>>>>
81322>>>>>>>>>        Function_Return sRetval
81323>>>>>>>>>    End_Function
81324>>>>>>>>>
81324>>>>>>>>>    // Checks that the passed sDriverID is defined.
81324>>>>>>>>>    // Also checks if the driver has been loaded; else it gets loaded.
81324>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
81326>>>>>>>>>        Boolean bOK
81326>>>>>>>>>        Integer iDriver
81326>>>>>>>>>
81326>>>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
81328>>>>>>>>>            Function_Return False
81329>>>>>>>>>        End
81329>>>>>>>>>>
81329>>>>>>>>>
81329>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
81330>>>>>>>>>
81330>>>>>>>>>        If (bOK = False) Begin
81332>>>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, or ODBC_DRV"
81333>>>>>>>>>>
81333>>>>>>>>>            Function_Return False
81334>>>>>>>>>        End
81334>>>>>>>>>>
81334>>>>>>>>>
81334>>>>>>>>>        Get DriverIndex sDriverID to iDriver
81335>>>>>>>>>        If (iDriver = 0) Begin
81337>>>>>>>>>            Load_Driver sDriverID
81338>>>>>>>>>        End
81338>>>>>>>>>>
81338>>>>>>>>>
81338>>>>>>>>>        Function_Return True
81339>>>>>>>>>    End_Function
81340>>>>>>>>>
81340>>>>>>>>>    // Checks that the length parameter has been passed correctly.
81340>>>>>>>>>    // This is only of concern for certain SQL data types.
81340>>>>>>>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
81342>>>>>>>>>        Integer iLength
81342>>>>>>>>>        Boolean bOK bCheckTypeLength
81342>>>>>>>>>
81342>>>>>>>>>        If (num_arguments > 1) Begin
81344>>>>>>>>>            Move iLen to iLength
81345>>>>>>>>>        End
81345>>>>>>>>>>
81345>>>>>>>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
81346>>>>>>>>>
81346>>>>>>>>>        If (bCheckTypeLength = True) Begin
81348>>>>>>>>>            Move (iLength > 0) to bOK
81349>>>>>>>>>        End
81349>>>>>>>>>>
81349>>>>>>>>>
81349>>>>>>>>>        Function_Return (bOK = True)
81350>>>>>>>>>    End_Function
81351>>>>>>>>>
81351>>>>>>>>>    Function _SqlProperTableName String sTableName Returns String
81353>>>>>>>>>        String sVal sSchema sDriverID
81353>>>>>>>>>        Integer iDbType
81353>>>>>>>>>
81353>>>>>>>>>        If (Trim(sTableName) = "") Begin
81355>>>>>>>>>            Function_Return ""
81356>>>>>>>>>        End
81356>>>>>>>>>>
81356>>>>>>>>>
81356>>>>>>>>>        Get psDriverID to sDriverID
81357>>>>>>>>>        Get piDbType   to iDbType
81358>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
81360>>>>>>>>>            Get psUserID to sSchema
81361>>>>>>>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
81361>>>>>>>>>            Move (Uppercase(sSchema)) to sSchema
81362>>>>>>>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
81363>>>>>>>>>            Function_Return sTableName
81364>>>>>>>>>        End
81364>>>>>>>>>>
81364>>>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
81366>>>>>>>>>            Get psDatabase to sVal
81367>>>>>>>>>            Move (sVal + "." + sTableName) to sTableName
81368>>>>>>>>>            Function_Return sTableName
81369>>>>>>>>>        End
81369>>>>>>>>>>
81369>>>>>>>>>        If (iDbType = EN_DbTypePostgre) Begin
81371>>>>>>>>>            Move ('"' + sTableName + '"') to sTableName
81372>>>>>>>>>            Function_Return sTableName
81373>>>>>>>>>        End
81373>>>>>>>>>>
81373>>>>>>>>>
81373>>>>>>>>>        Get psSchema to sSchema
81374>>>>>>>>>        If (sSchema = "") Begin
81376>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
81377>>>>>>>>>        End
81377>>>>>>>>>>
81377>>>>>>>>>
81377>>>>>>>>>        Move (Uppercase(sTableName)) to sVal
81378>>>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
81380>>>>>>>>>            If (iDbType = EN_dbTypeDB2) Begin
81382>>>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
81383>>>>>>>>>            End
81383>>>>>>>>>>
81383>>>>>>>>>            Else Begin
81384>>>>>>>>>                Move (sSchema + "." + sTableName) to sTableName
81385>>>>>>>>>            End
81385>>>>>>>>>>
81385>>>>>>>>>        End
81385>>>>>>>>>>
81385>>>>>>>>>
81385>>>>>>>>>        Function_Return sTableName
81386>>>>>>>>>    End_Function
81387>>>>>>>>>
81387>>>>>>>>>    // SQL column names can be case-sensitive. This function is used to check that
81387>>>>>>>>>    // the passed sFieldName has the correct spelling.
81387>>>>>>>>>    // Used with Embedded SQL statement calls.
81387>>>>>>>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
81387>>>>>>>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
81389>>>>>>>>>        String sRetval sValue sDriverID
81389>>>>>>>>>        String[] sColumnNamesArray
81390>>>>>>>>>        Integer iCount iColumns
81390>>>>>>>>>
81390>>>>>>>>>        Move "" to sRetval
81391>>>>>>>>>        Get psDriverID to sDriverID
81392>>>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
81393>>>>>>>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
81394>>>>>>>>>        Decrement iColumns
81395>>>>>>>>>
81395>>>>>>>>>        For iCount from 0 to iColumns
81401>>>>>>>>>>
81401>>>>>>>>>            Move sColumnNamesArray[iCount] to sValue
81402>>>>>>>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
81404>>>>>>>>>                Move sValue to sRetval
81405>>>>>>>>>                Move iColumns to iCount // We're done.
81406>>>>>>>>>            End
81406>>>>>>>>>>
81406>>>>>>>>>        Loop
81407>>>>>>>>>>
81407>>>>>>>>>
81407>>>>>>>>>        Function_Return sRetval
81408>>>>>>>>>    End_Function
81409>>>>>>>>>
81409>>>>>>>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
81411>>>>>>>>>        String[] sReturnArray
81412>>>>>>>>>        Handle hoSQLHandler
81412>>>>>>>>>        Integer iCount iSize iItem
81412>>>>>>>>>        String sServer
81412>>>>>>>>>        tSQLConnection SQLConnection
81412>>>>>>>>>        tSQLConnection SQLConnection
81412>>>>>>>>>
81412>>>>>>>>>        Get phoMSSQLHandler to hoSQLHandler
81413>>>>>>>>>        Send Delete_Data    of hoSQLHandler
81414>>>>>>>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
81415>>>>>>>>>
81415>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81416>>>>>>>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
81417>>>>>>>>>        Decrement iSize
81418>>>>>>>>>
81418>>>>>>>>>        For iCount from 0 to iSize
81424>>>>>>>>>>
81424>>>>>>>>>            Get String_Value of hoSQLHandler iCount to sServer
81425>>>>>>>>>            Move (Trim(sServer)) to sReturnArray[iItem]
81426>>>>>>>>>            Increment iItem
81427>>>>>>>>>        Loop
81428>>>>>>>>>>
81428>>>>>>>>>
81428>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81429>>>>>>>>>
81429>>>>>>>>>        Function_Return sReturnArray
81430>>>>>>>>>    End_Function
81431>>>>>>>>>
81431>>>>>>>>>    Function _SqlTableArrayDAW Returns String[]
81433>>>>>>>>>        String[] sReturnArray
81434>>>>>>>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord sConnectionString
81434>>>>>>>>>        Handle hoSQLHandler
81434>>>>>>>>>        Integer iCount iSize iItem iPos
81434>>>>>>>>>        Boolean bOK
81434>>>>>>>>>        tSQLConnection SQLConnection
81434>>>>>>>>>        tSQLConnection SQLConnection
81434>>>>>>>>>
81434>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81435>>>>>>>>>        If (SQLConnection.sConnectionString = "") Begin
81437>>>>>>>>>            Function_Return sReturnArray
81438>>>>>>>>>        End
81438>>>>>>>>>>
81438>>>>>>>>>
81438>>>>>>>>>        Move SQLConnection.sSchema      to sDefSchema
81439>>>>>>>>>        Move (Uppercase(sDefSchema))    to sDefSchema
81440>>>>>>>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
81441>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
81442>>>>>>>>>
81442>>>>>>>>>        Get phoCLIHandler to hoSQLHandler
81443>>>>>>>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
81444>>>>>>>>>        Send Delete_Data  of hoSQLHandler
81445>>>>>>>>>
81445>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81446>>>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
81447>>>>>>>>>        // 2020-03-14 This was not correct when testing a MS-SQL ODBC driver connection from CMOS.
81447>>>>>>>>>//        If (SQLConnection.sDriverID = ODBC_DRV_ID) Begin
81447>>>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
81447>>>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
81447>>>>>>>>>//                If (iPos > 0) Begin
81447>>>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
81447>>>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
81447>>>>>>>>>//                End
81447>>>>>>>>>//            End
81447>>>>>>>>>//        End
81447>>>>>>>>>
81447>>>>>>>>>        Get EnumerateTables of hoSQLHandler sConnectionString to iSize
81448>>>>>>>>>        Move False to Err
81449>>>>>>>>>        Move 0 to iItem
81450>>>>>>>>>
81450>>>>>>>>>        // Note that the enumeration starts from table no 1. (not zero)
81450>>>>>>>>>        For iCount from 1 to iSize
81456>>>>>>>>>>
81456>>>>>>>>>            Get TableName    of hoSQLHandler iCount to sTable
81457>>>>>>>>>            Get TableType    of hoSQLHandler iCount to sTableType
81458>>>>>>>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
81459>>>>>>>>>            If (sSchema = "") Begin
81461>>>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
81462>>>>>>>>>            End
81462>>>>>>>>>>
81462>>>>>>>>>            Get TableComment of hoSQLHandler iCount to sComment
81463>>>>>>>>>            Move (Trim(sTable)) to sTable
81464>>>>>>>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
81466>>>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
81467>>>>>>>>>            End
81467>>>>>>>>>>
81467>>>>>>>>>            Else Begin
81468>>>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
81469>>>>>>>>>            End
81469>>>>>>>>>>
81469>>>>>>>>>            If (bOK = True) Begin
81471>>>>>>>>>                Move sTable to sReturnArray[iItem]
81472>>>>>>>>>                Increment iItem
81473>>>>>>>>>            End
81473>>>>>>>>>>
81473>>>>>>>>>        Loop
81474>>>>>>>>>>
81474>>>>>>>>>
81474>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81475>>>>>>>>>
81475>>>>>>>>>        Function_Return sReturnArray
81476>>>>>>>>>    End_Function
81477>>>>>>>>>
81477>>>>>>>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
81479>>>>>>>>>        String[] sReturnArray
81480>>>>>>>>>        String sValue
81480>>>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
81480>>>>>>>>>        Integer iRetval iCols iFetchResult
81480>>>>>>>>>        tSQLConnection SQLConnection
81480>>>>>>>>>        tSQLConnection SQLConnection
81480>>>>>>>>>
81480>>>>>>>>>        Get phoSQLManager to hoSQLHandler
81481>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81482>>>>>>>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
81483>>>>>>>>>
81483>>>>>>>>>        If (hoSQLConnect <> 0) Begin
81485>>>>>>>>>            Get SqlOpen of hoSQLConnect to hStmt
81486>>>>>>>>>            If (hStmt <> 0) Begin
81488>>>>>>>>>                Send SqlSetProcedurename of hStmt sStmt
81489>>>>>>>>>                If (sArgument <> "") Begin
81491>>>>>>>>>                    Send SqlSetArgument  of hStmt 1 sArgument
81492>>>>>>>>>                End
81492>>>>>>>>>>
81492>>>>>>>>>
81492>>>>>>>>>                Send SqlCall             of hStmt
81493>>>>>>>>>                Get SqlReturnValue       of hStmt to iRetval
81494>>>>>>>>>                If (iRetval = 0) Begin
81496>>>>>>>>>                    Repeat
81496>>>>>>>>>>
81496>>>>>>>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
81497>>>>>>>>>                        If (iCols > 0) Begin
81499>>>>>>>>>                            Repeat
81499>>>>>>>>>>
81499>>>>>>>>>                                Get SqlFetch of hStmt to iFetchResult
81500>>>>>>>>>                                If (iFetchResult <> 0) Begin
81502>>>>>>>>>                                    Get SqlColumnValue of hStmt 1 to sValue
81503>>>>>>>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
81504>>>>>>>>>                                End
81504>>>>>>>>>>
81504>>>>>>>>>                            Until (iFetchResult = 0)
81506>>>>>>>>>                        End
81506>>>>>>>>>>
81506>>>>>>>>>                        Get SqlNextResultSet of hStmt to iRetval
81507>>>>>>>>>                    Until (iRetval = 0)
81509>>>>>>>>>                    Send SqlClose of hStmt
81510>>>>>>>>>                End
81510>>>>>>>>>>
81510>>>>>>>>>            End
81510>>>>>>>>>>
81510>>>>>>>>>            Send SqlDisconnect of hoSQLConnect
81511>>>>>>>>>        End
81511>>>>>>>>>>
81511>>>>>>>>>        Function_Return sReturnArray
81512>>>>>>>>>    End_Function
81513>>>>>>>>>
81513>>>>>>>>>    Function _SqlUtilUpdateIntFile Integer hTable Returns Boolean
81515>>>>>>>>>        String sOrgFormat sNewFormat sRootName hTableName sPhysicalFileName sDriverID sDataPath
81515>>>>>>>>>        Boolean bOpened bOK
81515>>>>>>>>>
81515>>>>>>>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
81515>>>>>>>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
81515>>>>>>>>>        // which makes the program unable to run because they can't be opened.
81515>>>>>>>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
81515>>>>>>>>>        // proper .int files for the two tables.
81515>>>>>>>>>//        If (Uppercase(hTableName) = "CODETYPE" or Uppercase(hTableName) = "CODEMAST") Begin
81515>>>>>>>>>//            Function_Return True
81515>>>>>>>>>//        End
81515>>>>>>>>>
81515>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81518>>>>>>>>>        Get _TableNameOnly sRootName to hTableName
81519>>>>>>>>>        Move CS_OEM_Txt  to sOrgFormat
81520>>>>>>>>>        Move CS_ANSI_Txt to sNewFormat
81521>>>>>>>>>        Get AutoConnectionIDLogin to bOK
81522>>>>>>>>>
81522>>>>>>>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
81522>>>>>>>>>//        Sleep 1  
81522>>>>>>>>>        Get _UtilDeleteCacheFile hTableName to bOK
81523>>>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
81526>>>>>>>>>        If (bOpened = False) Begin
81528>>>>>>>>>            Open hTable
81530>>>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
81533>>>>>>>>>        End
81533>>>>>>>>>>
81533>>>>>>>>>        If (bOpened = False) Begin
81535>>>>>>>>>            Function_Return False
81536>>>>>>>>>        End
81536>>>>>>>>>>
81536>>>>>>>>>
81536>>>>>>>>>        Get psDriverID to sDriverID
81537>>>>>>>>>
81537>>>>>>>>>        Move False to Err
81538>>>>>>>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81541>>>>>>>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
81542>>>>>>>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
81542>>>>>>>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
81542>>>>>>>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
81543>>>>>>>>>
81543>>>>>>>>>        Move False to Err
81544>>>>>>>>>
81544>>>>>>>>>        If (hTable > 0) Begin
81546>>>>>>>>>            Structure_Start hTable
81547>>>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81550>>>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81553>>>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
81555>>>>>>>>>        End
81555>>>>>>>>>>
81555>>>>>>>>>        Else Begin
81556>>>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81559>>>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81562>>>>>>>>>        End
81562>>>>>>>>>>
81562>>>>>>>>>        Function_Return (Err = False)
81563>>>>>>>>>    End_Function
81564>>>>>>>>>
81564>>>>>>>>>    // Subfunction to the ApiTableUpdate function (et al)
81564>>>>>>>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
81566>>>>>>>>>        Handle hTable
81566>>>>>>>>>        String sConnectionID sRootName sLogicalName sDisplayName
81566>>>>>>>>>        Boolean bTableExists bSameTableNames bANSI bOK
81566>>>>>>>>>
81566>>>>>>>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
81567>>>>>>>>>        If (bSameTableNames = True) Begin
81569>>>>>>>>>            Function_Return True
81570>>>>>>>>>        End
81570>>>>>>>>>>
81570>>>>>>>>>
81570>>>>>>>>>        Move True to bOK
81571>>>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
81572>>>>>>>>>        Set Private.phCurrentTable              to hTable
81573>>>>>>>>>        
81573>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME         of hTable to sRootName
81576>>>>>>>>>        If (sRootName <> APITableNameInfoFrom.sRootName) Begin
81578>>>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to APITableNameInfoFrom.sRootName
81581>>>>>>>>>        End
81581>>>>>>>>>>
81581>>>>>>>>>        
81581>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME      of hTable to sLogicalName
81584>>>>>>>>>        If (sLogicalName <> APITableNameInfoFrom.sLogicalName) Begin
81586>>>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to APITableNameInfoFrom.sLogicalName
81589>>>>>>>>>        End
81589>>>>>>>>>>
81589>>>>>>>>>        
81589>>>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME      of hTable to sDisplayName
81592>>>>>>>>>        If (sDisplayName <> APITableNameInfoFrom.sDisplayName) Begin
81594>>>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to APITableNameInfoFrom.sDisplayName
81597>>>>>>>>>        End
81597>>>>>>>>>>
81597>>>>>>>>>
81597>>>>>>>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
81599>>>>>>>>>            Get psConnectionID to sConnectionID
81600>>>>>>>>>            Get _UtilTableExists hTable to bTableExists
81601>>>>>>>>>            If (bTableExists = True) Begin
81603>>>>>>>>>                Get _SqlUtilUpdateIntFile hTable to bOK
81604>>>>>>>>>            End
81604>>>>>>>>>>
81604>>>>>>>>>            Else Begin
81605>>>>>>>>>                Get pbToANSI to bANSI
81606>>>>>>>>>                Get _SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
81607>>>>>>>>>            End
81607>>>>>>>>>>
81607>>>>>>>>>        End
81607>>>>>>>>>>
81607>>>>>>>>>
81607>>>>>>>>>        Function_Return bOK
81608>>>>>>>>>    End_Function
81609>>>>>>>>>
81609>>>>>>>>>    // The table must already exist in the filelist for this function to work.
81609>>>>>>>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
81609>>>>>>>>>    // Note: This is not enough to re-create an .int file!
81609>>>>>>>>>    //       It is also necessary (as the DUF framework does when it is called) to call a Structure_Start/Structure_End,
81609>>>>>>>>>    //       to have the driver make a proper update of the .int file.
81609>>>>>>>>>    //       Sample:
81609>>>>>>>>>    //               Open hTable
81609>>>>>>>>>    //               Structure_Start hTable sDriver
81609>>>>>>>>>    //               Structure_End hTable DF_STRUCTEND_OPT_FORCE
81609>>>>>>>>>    //               Note the "DF_STRUCTEND_OPT_FORCE" to force a restructure(!)
81609>>>>>>>>>    Function _SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
81611>>>>>>>>>        Boolean bOK bExists bUseConnectionID 
81611>>>>>>>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString hTableName sSchemaName sANSI_OEM sNoDriverRootName
81611>>>>>>>>>        String[] asIndexArray
81612>>>>>>>>>        Integer iCount iCh iSize iPos
81612>>>>>>>>>
81612>>>>>>>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
81613>>>>>>>>>        Get psConnectionString to sConnectionString
81614>>>>>>>>>
81614>>>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
81615>>>>>>>>>        If (bANSI = False) Begin
81617>>>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
81618>>>>>>>>>        End
81618>>>>>>>>>>
81618>>>>>>>>>
81618>>>>>>>>>        Get psDataPathFirstPart to sDataPath
81619>>>>>>>>>        Get vFolderExists sDataPath to bOK
81620>>>>>>>>>        If (bOK = False) Begin
81622>>>>>>>>>            Error DFERR_PROGRAM "Function _SqlUtilCreateIntFile; psDataPath not found!"
81623>>>>>>>>>>
81623>>>>>>>>>            Function_Return False
81624>>>>>>>>>        End
81624>>>>>>>>>>
81624>>>>>>>>>        Get vFolderFormat sDataPath to sDataPath
81625>>>>>>>>>
81625>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName 
81628>>>>>>>>>        Move (Pos(":", sRootName)) to iPos
81629>>>>>>>>>        If (iPos <> 0) Begin
81631>>>>>>>>>            Move (Mid(sRootName, Length(sRootName), iPos +1)) to sNoDriverRootName
81632>>>>>>>>>        End
81632>>>>>>>>>>
81632>>>>>>>>>        Else Begin
81633>>>>>>>>>            Move sRootName to sNoDriverRootName
81634>>>>>>>>>        End
81634>>>>>>>>>>
81634>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
81637>>>>>>>>>        Get _TableNameOnly sRootName to hTableName
81638>>>>>>>>>        Move sLogicalName  to sPhysicalFileName
81639>>>>>>>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
81640>>>>>>>>>
81640>>>>>>>>>        Get psSchema hTable to sSchemaName
81641>>>>>>>>>        If (sSchemaName = "") Begin
81643>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
81644>>>>>>>>>        End
81644>>>>>>>>>>
81644>>>>>>>>>
81644>>>>>>>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
81644>>>>>>>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
81645>>>>>>>>>        If (bExists = True) Begin
81647>>>>>>>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
81648>>>>>>>>>        End
81648>>>>>>>>>>
81648>>>>>>>>>
81648>>>>>>>>>        Get _UtilDeleteCacheFile sNoDriverRootName to bOK
81649>>>>>>>>>        Get _SqlUtilEnumerateIndexes sNoDriverRootName sDriverID to asIndexArray
81650>>>>>>>>>
81650>>>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
81651>>>>>>>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
81656>>>>>>>>>            If (bUseConnectionID = True) Begin
81658>>>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
81665>>>>>>>>>            End
81665>>>>>>>>>>
81665>>>>>>>>>            Else Begin
81666>>>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
81673>>>>>>>>>            End
81673>>>>>>>>>>
81673>>>>>>>>>            Writeln channel iCh CS_DATABASE_NAME          " " hTableName
81678>>>>>>>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
81683>>>>>>>>>            // There seems to be a new order how these are set from DF19.
81683>>>>>>>>>            If (bSysFile = True) Begin
81685>>>>>>>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
81690>>>>>>>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
81695>>>>>>>>>            End
81695>>>>>>>>>>
81695>>>>>>>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
81700>>>>>>>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
81705>>>>>>>>>
81705>>>>>>>>>            If (bSysFile = False) Begin
81707>>>>>>>>>                Move (SizeOfArray(asIndexArray)) to iSize
81708>>>>>>>>>                Move (SortArray(asIndexArray)) to asIndexArray
81709>>>>>>>>>                If (iSize > 0) Begin
81711>>>>>>>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
81714>>>>>>>>>                    Writeln channel iCh // Just an empty line
81716>>>>>>>>>                End
81716>>>>>>>>>>
81716>>>>>>>>>                Decrement iSize
81717>>>>>>>>>                for iCount from 0 to iSize
81723>>>>>>>>>>
81723>>>>>>>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
81726>>>>>>>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(asIndexArray[iCount]))
81729>>>>>>>>>                    Writeln channel iCh
81731>>>>>>>>>                Loop
81732>>>>>>>>>>
81732>>>>>>>>>            End
81732>>>>>>>>>>
81732>>>>>>>>>        Send Seq_Close_Channel iCh 
81733>>>>>>>>>        
81733>>>>>>>>>        Open hTable
81735>>>>>>>>>        Structure_Start hTable sDriverID
81736>>>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_FORCE
81738>>>>>>>>>
81738>>>>>>>>>        // Wait a sec for Windows to finish writing the file:
81738>>>>>>>>>//        Sleep 1
81738>>>>>>>>>
81738>>>>>>>>>        Function_Return (bOK = True)
81739>>>>>>>>>    End_Function 
81740>>>>>>>>>    
81740>>>>>>>>>    Function _SqlUtilRefreshIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean        
81742>>>>>>>>>        String sOrgFormat sNewFormat
81742>>>>>>>>>        
81742>>>>>>>>>        Move False to Err
81743>>>>>>>>>        Open hTable
81745>>>>>>>>>        If (Err = True) Begin
81747>>>>>>>>>            Function_Return False
81748>>>>>>>>>        End
81748>>>>>>>>>>
81748>>>>>>>>>        
81748>>>>>>>>>//        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81748>>>>>>>>>//        Move (Uppercase(sOrgFormat)) to sOrgFormat
81748>>>>>>>>>//        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
81748>>>>>>>>>//        // to "touch" the table so the driver feels there has been a change and updates the .int file.
81748>>>>>>>>>//        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
81748>>>>>>>>>
81748>>>>>>>>>        Structure_Start hTable
81749>>>>>>>>>//            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81749>>>>>>>>>//            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81749>>>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
81751>>>>>>>>>    End_Function
81752>>>>>>>>>
81752>>>>>>>>>    Function _UtilDeleteCacheFile String sTableName Returns Boolean
81754>>>>>>>>>        String sDataPath sDriverID
81754>>>>>>>>>        Boolean bOK
81754>>>>>>>>>        Integer iPos
81754>>>>>>>>>
81754>>>>>>>>>        If (sTableName contains ".") Begin
81756>>>>>>>>>            Move (Pos(".", sTableName)) to iPos
81757>>>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
81758>>>>>>>>>        End
81758>>>>>>>>>>
81758>>>>>>>>>
81758>>>>>>>>>        Get psDriverID to sDriverID
81759>>>>>>>>>        Get psDataPathFirstPart to sDataPath
81760>>>>>>>>>        // First delete the cache file:
81760>>>>>>>>>        Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
81761>>>>>>>>>
81761>>>>>>>>>        Function_Return bOK
81762>>>>>>>>>    End_Function
81763>>>>>>>>>
81763>>>>>>>>>    // Collects all tables from the SQL Database backend and sets the pasSQLTables property.
81763>>>>>>>>>    Procedure UtilFillSQLTables
81765>>>>>>>>>        String[] asSQLTables
81766>>>>>>>>>        String sDataBase
81766>>>>>>>>>        Integer iSize iCount
81766>>>>>>>>>
81766>>>>>>>>>        Get psDatabase to sDataBase
81767>>>>>>>>>        Get _SqlUtilEnumerateTables MSSQLDRV_ID sDataBase "" to asSQLTables
81768>>>>>>>>>        Set pasSQLDataTables to asSQLTables
81769>>>>>>>>>    End_Procedure
81770>>>>>>>>>
81770>>>>>>>>>    // This collects *all* filelist entries and sets the pFileListArray struct property.
81770>>>>>>>>>    Procedure UtilFillFileListStruct
81772>>>>>>>>>        tFilelist[] Tables
81772>>>>>>>>>        tFilelist[] Tables
81773>>>>>>>>>        String sRootName sLogicalName sDisplayName sDriver sNoDriverRootname
81773>>>>>>>>>        Handle hTable
81773>>>>>>>>>        Integer iItem iCount
81773>>>>>>>>>        Boolean bIsSystem bIsAlias bOpened
81773>>>>>>>>>        
81773>>>>>>>>>        Move 0 to iItem
81774>>>>>>>>>        Move 0 to hTable 
81775>>>>>>>>>        Repeat
81775>>>>>>>>>>
81775>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81778>>>>>>>>>            // 0 = no more table in Filelist.cfg, 50 = Flexerrs.
81778>>>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin  
81780>>>>>>>>>                Move False to Err
81781>>>>>>>>>                Move False to bIsSystem
81782>>>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
81785>>>>>>>>>                Get _DriverIDFromRootName sRootName to sDriver
81786>>>>>>>>>                Set Message_Text of ghoStatusPanel to ("Opening table" * String(hTable) * "RootName =" * sRootName)
81787>>>>>>>>>                Send Ignore_All of Error_Object_Id
81788>>>>>>>>>                Open hTable
81790>>>>>>>>>                Get_Attribute DF_FILE_OPENED         of hTable to bOpened
81793>>>>>>>>>                Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bIsSystem
81796>>>>>>>>>                Send Trap_All of Error_Object_Id
81797>>>>>>>>>                Close hTable
81798>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
81801>>>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
81804>>>>>>>>>                Get _TableNameOnly sRootName to sNoDriverRootname
81805>>>>>>>>>                Move hTable              to Tables[iItem].hTable
81806>>>>>>>>>                Move sRootName           to Tables[iItem].sRootName
81807>>>>>>>>>                Move sLogicalName        to Tables[iItem].sLogicalName
81808>>>>>>>>>                Move sDisplayName        to Tables[iItem].sDisplayName
81809>>>>>>>>>                Move sNoDriverRootname   to Tables[iItem].sNoDriverRootname
81810>>>>>>>>>                Move sDriver             to Tables[iItem].sDriver 
81811>>>>>>>>>                Move bIsSystem           to Tables[iItem].bIsSystemFile
81812>>>>>>>>>                Move (bOpened = False)   to Tables[iItem].bErrorOpening
81813>>>>>>>>>                Get _IsAliasTable hTable to Tables[iItem].bIsAlias 
81814>>>>>>>>>                Move False to Err
81815>>>>>>>>>                Increment iItem
81816>>>>>>>>>            End
81816>>>>>>>>>>
81816>>>>>>>>>        Until (hTable = 0)
81818>>>>>>>>>        
81818>>>>>>>>>        Set Message_Text of ghoStatusPanel to ""
81819>>>>>>>>>        Set pFileListArray to Tables
81820>>>>>>>>>    End_Procedure   
81821>>>>>>>>>    
81821>>>>>>>>>    // Special array search function for the tFilelistLogicalName struct.
81821>>>>>>>>>    // Used by e.g. UtilAliasToMasterTableHandle
81821>>>>>>>>>    Function CompareFileListTable tFilelistLogicalName FileListTable1 tFilelistLogicalName FileListTable2 Returns Integer
81823>>>>>>>>>        If (Lowercase(FileListTable1.sLogicalName) < Lowercase(FileListTable2.sLogicalName)) ;            Function_Return (LT)
81826>>>>>>>>>        If (Lowercase(FileListTable1.sLogicalName) > Lowercase(FileListTable2.sLogicalName)) ;            Function_Return (GT)
81829>>>>>>>>>
81829>>>>>>>>>        If (Lowercase(FileListTable1.sNoDriverRootname) < Lowercase(FileListTable2.sNoDriverRootname)) ;            Function_Return (LT)
81832>>>>>>>>>        If (Lowercase(FileListTable1.sNoDriverRootname) > Lowercase(FileListTable2.sNoDriverRootname)) ;            Function_Return (GT)
81835>>>>>>>>>            
81835>>>>>>>>>        Function_Return (EQ)
81836>>>>>>>>>    End_Function
81837>>>>>>>>>
81837>>>>>>>>>    // Finds the corresponding Master table for the passed Alias handle
81837>>>>>>>>>    Function UtilAliasToMasterTableHandle Handle hTable Returns Handle
81839>>>>>>>>>        Handle hMasterTable
81839>>>>>>>>>        String sDriver sRootNameAlias sNoDriverRootnameAlias
81839>>>>>>>>>        Boolean bIsAlias bFound bIsIntTable
81839>>>>>>>>>        Integer iSize iCount iItem 
81839>>>>>>>>>        tFilelistLogicalName[] FilelistLogicalTables
81839>>>>>>>>>        tFilelistLogicalName[] FilelistLogicalTables
81840>>>>>>>>>        tFilelistLogicalName FileListTable
81840>>>>>>>>>        tFilelistLogicalName FileListTable
81840>>>>>>>>>        
81840>>>>>>>>>        Get _IsAliasTable hTable to bIsAlias
81841>>>>>>>>>        If (bIsAlias = False) Begin
81843>>>>>>>>>            Function_Return 0
81844>>>>>>>>>        End
81844>>>>>>>>>>
81844>>>>>>>>>        
81844>>>>>>>>>        Move 0 to hMasterTable
81845>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameAlias 
81848>>>>>>>>>        Get _TableNameOnly sRootNameAlias to sNoDriverRootnameAlias
81849>>>>>>>>>        Get _IsIntEntry hTable to bIsIntTable
81850>>>>>>>>>        Get pFilelistLogicalTables  to FilelistLogicalTables
81851>>>>>>>>>        Move sNoDriverRootnameAlias to FileListTable.sLogicalName
81852>>>>>>>>>        Move sNoDriverRootnameAlias to FileListTable.sNoDriverRootname
81853>>>>>>>>>        Move (SearchArray(FileListTable, FilelistLogicalTables, Self, (RefFunc(CompareFileListTable)))) to iItem
81854>>>>>>>>>        If (iItem = -1) Begin
81856>>>>>>>>>            Function_Return 0
81857>>>>>>>>>        End
81857>>>>>>>>>>
81857>>>>>>>>>        Move (Lowercase(sNoDriverRootnameAlias) = Lowercase(FilelistLogicalTables[iItem].sNoDriverRootname) and Lowercase(FilelistLogicalTables[iItem].sNoDriverRootname) = Lowercase(FilelistLogicalTables[iItem].sLogicalName)) to bFound
81858>>>>>>>>>        If (bFound = True) Begin
81860>>>>>>>>>            Move FilelistLogicalTables[iItem].hTable to hMasterTable
81861>>>>>>>>>            Function_Return hMasterTable
81862>>>>>>>>>        End
81862>>>>>>>>>>
81862>>>>>>>>>        
81862>>>>>>>>>        Function_Return hMasterTable
81863>>>>>>>>>    End_Function
81864>>>>>>>>>     
81864>>>>>>>>>    Function pFilelistLogicalTables Returns tFilelistLogicalName
81866>>>>>>>>>        tFilelistLogicalName[] FilelistLogicalTables
81866>>>>>>>>>        tFilelistLogicalName[] FilelistLogicalTables
81867>>>>>>>>>        tFilelist[] FileListTables
81867>>>>>>>>>        tFilelist[] FileListTables
81868>>>>>>>>>        Integer iSize iCount
81868>>>>>>>>>        
81868>>>>>>>>>        Get pFileListArray to FileListTables
81869>>>>>>>>>        Move (SizeOfArray(FileListTables)) to iSize
81870>>>>>>>>>        Decrement iSize
81871>>>>>>>>>        for iCount from 0 to iSize
81877>>>>>>>>>>
81877>>>>>>>>>            Move FileListTables[iCount].bErrorOpening       to FilelistLogicalTables[iCount].bErrorOpening    
81878>>>>>>>>>            Move FileListTables[iCount].bIsAlias            to FilelistLogicalTables[iCount].bIsAlias
81879>>>>>>>>>            Move FileListTables[iCount].bIsSystemFile       to FilelistLogicalTables[iCount].bIsSystemFile
81880>>>>>>>>>            Move FileListTables[iCount].hTable              to FilelistLogicalTables[iCount].hTable
81881>>>>>>>>>            Move FileListTables[iCount].sDisplayName        to FilelistLogicalTables[iCount].sDisplayName
81882>>>>>>>>>            Move FileListTables[iCount].sDriver             to FilelistLogicalTables[iCount].sDriver
81883>>>>>>>>>            Move FileListTables[iCount].sLogicalName        to FilelistLogicalTables[iCount].sLogicalName
81884>>>>>>>>>            Move FileListTables[iCount].sNoDriverRootname   to FilelistLogicalTables[iCount].sNoDriverRootname
81885>>>>>>>>>            Move FileListTables[iCount].sRootName           to FilelistLogicalTables[iCount].sRootName
81886>>>>>>>>>        Loop
81887>>>>>>>>>>
81887>>>>>>>>>        Move (SortArray(FilelistLogicalTables)) to FilelistLogicalTables
81888>>>>>>>>>        Function_Return FilelistLogicalTables
81889>>>>>>>>>    End_Function 
81890>>>>>>>>>    
81890>>>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
81890>>>>>>>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
81890>>>>>>>>>    // if it is an SQL table
81890>>>>>>>>>    Function _UtilTableExists Handle hTable Returns Boolean
81892>>>>>>>>>        Boolean bExists bIsSQLTable
81892>>>>>>>>>        String sDataPath sRootName
81892>>>>>>>>>
81892>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
81893>>>>>>>>>        If (bExists = False) Begin
81895>>>>>>>>>            Function_Return False
81896>>>>>>>>>        End
81896>>>>>>>>>>
81896>>>>>>>>>
81896>>>>>>>>>        Move False to bIsSQLTable
81897>>>>>>>>>        If (hTable > 0) Begin
81899>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81902>>>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
81903>>>>>>>>>        End
81903>>>>>>>>>>
81903>>>>>>>>>        If (bIsSQLTable = True) Begin
81905>>>>>>>>>            Get _UtilTableIsSql hTable to bExists
81906>>>>>>>>>            Function_Return bExists
81907>>>>>>>>>        End
81907>>>>>>>>>>
81907>>>>>>>>>        Else Begin
81908>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
81909>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
81910>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
81911>>>>>>>>>        End
81911>>>>>>>>>>
81911>>>>>>>>>
81911>>>>>>>>>        Function_Return bExists
81912>>>>>>>>>    End_Function
81913>>>>>>>>>
81913>>>>>>>>>    // Note: This variant uses the pasSQLDataTables property!
81913>>>>>>>>>    //       Thus, that property needs to have been initialized before
81913>>>>>>>>>    //       calling.
81913>>>>>>>>>    // It checks that the SQL table exists on the SQL end, *or*
81913>>>>>>>>>    // if embedded database, that the .dat file exists on disk.
81913>>>>>>>>>    Function _UtilTableExists_Ex Handle hTable Returns Boolean
81915>>>>>>>>>        Boolean bExists bIsSQLTable
81915>>>>>>>>>        String sDataPath sRootName
81915>>>>>>>>>
81915>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
81916>>>>>>>>>        If (bExists = False) Begin
81918>>>>>>>>>            Function_Return False
81919>>>>>>>>>        End
81919>>>>>>>>>>
81919>>>>>>>>>
81919>>>>>>>>>        Move False to bIsSQLTable
81920>>>>>>>>>        If (hTable > 0) Begin
81922>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81925>>>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
81926>>>>>>>>>        End
81926>>>>>>>>>>
81926>>>>>>>>>        If (bIsSQLTable = True) Begin
81928>>>>>>>>>            Get _UtilTableIsSql_Ex hTable to bExists
81929>>>>>>>>>            Function_Return bExists
81930>>>>>>>>>        End
81930>>>>>>>>>>
81930>>>>>>>>>        Else Begin
81931>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
81932>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
81933>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
81934>>>>>>>>>        End
81934>>>>>>>>>>
81934>>>>>>>>>
81934>>>>>>>>>        Function_Return bExists
81935>>>>>>>>>    End_Function
81936>>>>>>>>>
81936>>>>>>>>>    // Pass a table handle
81936>>>>>>>>>    // Returns True if the table exists in filelist.cfg.
81936>>>>>>>>>    Function _UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
81938>>>>>>>>>        Handle hTable
81938>>>>>>>>>        Boolean bFound
81938>>>>>>>>>
81938>>>>>>>>>        Move False to bFound
81939>>>>>>>>>        Move 0 to hTable
81940>>>>>>>>>        Repeat
81940>>>>>>>>>>
81940>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81943>>>>>>>>>            If (hTable > 0) Begin
81945>>>>>>>>>                If (hTable = hCheckTable) Begin
81947>>>>>>>>>                    Move True to bFound
81948>>>>>>>>>                End
81948>>>>>>>>>>
81948>>>>>>>>>            End
81948>>>>>>>>>>
81948>>>>>>>>>            If (bFound = True) ;                Break
81951>>>>>>>>>        Until (hTable = 0)
81953>>>>>>>>>
81953>>>>>>>>>        Function_Return bFound
81954>>>>>>>>>    End_Function
81955>>>>>>>>>
81955>>>>>>>>>    // DataFlex Embedded Database Data Types:
81955>>>>>>>>>    // Helper function for _UtilEnumerateColumnTypes
81955>>>>>>>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
81957>>>>>>>>>        tColumnType[] ColumnType
81957>>>>>>>>>        tColumnType[] ColumnType
81958>>>>>>>>>        Integer i
81958>>>>>>>>>
81958>>>>>>>>>        Move DF_ASCII           to ColumnType[i].iSQLType
81959>>>>>>>>>        Move "ASCII"            to ColumnType[i].sSQLType
81960>>>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
81961>>>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
81962>>>>>>>>>        Move "254"              to ColumnType[i].sPrecision
81963>>>>>>>>>        Increment i
81964>>>>>>>>>
81964>>>>>>>>>        Move DF_BCD             to ColumnType[i].iSQLType
81965>>>>>>>>>        Move "Numeric"          to ColumnType[i].sSQLType
81966>>>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
81967>>>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
81968>>>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
81969>>>>>>>>>        Increment i
81970>>>>>>>>>
81970>>>>>>>>>        Move DF_DATE            to ColumnType[i].iSQLType
81971>>>>>>>>>        Move "Date"             to ColumnType[i].sSQLType
81972>>>>>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
81973>>>>>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
81974>>>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
81975>>>>>>>>>        Move True               to ColumnType[i].bCanEditSize
81976>>>>>>>>>        Increment i
81977>>>>>>>>>
81977>>>>>>>>>        Move DF_TEXT            to ColumnType[i].iSQLType
81978>>>>>>>>>        Move "Text"             to ColumnType[i].sSQLType
81979>>>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
81980>>>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
81981>>>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
81982>>>>>>>>>        Increment i
81983>>>>>>>>>
81983>>>>>>>>>        Move DF_BINARY          to ColumnType[i].iSQLType
81984>>>>>>>>>        Move "Binary"           to ColumnType[i].sSQLType
81985>>>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
81986>>>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
81987>>>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
81988>>>>>>>>>        Increment i
81989>>>>>>>>>
81989>>>>>>>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
81990>>>>>>>>>        Move "DateTime"         to ColumnType[i].sSQLType
81991>>>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
81992>>>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
81993>>>>>>>>>        Move "23"               to ColumnType[i].sPrecision
81994>>>>>>>>>        Move True               to ColumnType[i].bCanEditSize
81995>>>>>>>>>        Increment i
81996>>>>>>>>>
81996>>>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
81997>>>>>>>>>        Move "Overlap"          to ColumnType[i].sSQLType
81998>>>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
81999>>>>>>>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
82000>>>>>>>>>        Move "0.0"              to ColumnType[i].sPrecision
82001>>>>>>>>>
82001>>>>>>>>>        Function_Return ColumnType
82002>>>>>>>>>    End_Function
82003>>>>>>>>>
82003>>>>>>>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
82005>>>>>>>>>        tColumnType[] aColumnType
82005>>>>>>>>>        tColumnType[] aColumnType
82006>>>>>>>>>        Integer i
82006>>>>>>>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DB2_DRV_DriverDef.inc)
82006>>>>>>>>>>// Generated By The Database Update Framework
82006>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.1\bin\MSSQLDRV_DriverDef.xml
82006>>>>>>>>>>// Driver COLUMN DATA TYPES
82006>>>>>>>>>>//
82006>>>>>>>>>>// Created: 2019-07-18 18:57:13.935
82006>>>>>>>>>>
82006>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82007>>>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
82008>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82009>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82010>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82011>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82012>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82013>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82014>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82015>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82016>>>>>>>>>>            Increment i
82017>>>>>>>>>>
82017>>>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
82018>>>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
82019>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82020>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82021>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82022>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82023>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82024>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82025>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82026>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82027>>>>>>>>>>            Increment i
82028>>>>>>>>>>
82028>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82029>>>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
82030>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82031>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82032>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82033>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82034>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82035>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82036>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82037>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82038>>>>>>>>>>            Increment i
82039>>>>>>>>>>
82039>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82040>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82041>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82042>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82043>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82044>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82045>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82046>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82047>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82048>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82049>>>>>>>>>>            Increment i
82050>>>>>>>>>>
82050>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82051>>>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
82052>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82053>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82054>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82055>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82056>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82057>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82058>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82059>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82060>>>>>>>>>>            Increment i
82061>>>>>>>>>>
82061>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
82062>>>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
82063>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82064>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82065>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82066>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82067>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82068>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82069>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82070>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82071>>>>>>>>>>            Increment i
82072>>>>>>>>>>
82072>>>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
82073>>>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
82074>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82075>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82076>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82077>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
82078>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82079>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82080>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82081>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82082>>>>>>>>>>            Increment i
82083>>>>>>>>>>
82083>>>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
82084>>>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
82085>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82086>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82087>>>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
82088>>>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
82089>>>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
82090>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82091>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82092>>>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
82093>>>>>>>>>>            Increment i
82094>>>>>>>>>>
82094>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82095>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82096>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82097>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82098>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82099>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82100>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82101>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82102>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82103>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82104>>>>>>>>>>            Increment i
82105>>>>>>>>>>
82105>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82106>>>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
82107>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82108>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82109>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82110>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82111>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82112>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82113>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82114>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82115>>>>>>>>>>            Increment i
82116>>>>>>>>>>
82116>>>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
82117>>>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
82118>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82119>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82120>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82121>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82122>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82123>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82124>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82125>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82126>>>>>>>>>>            Increment i
82127>>>>>>>>>>
82127>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82128>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82129>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82130>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82131>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82132>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82133>>>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
82134>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82135>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82136>>>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
82137>>>>>>>>>>            Increment i
82138>>>>>>>>>>
82138>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
82139>>>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
82140>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82141>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82142>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82143>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82144>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82145>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82146>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82147>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82148>>>>>>>>>>            Increment i
82149>>>>>>>>>>
82149>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
82150>>>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
82151>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82152>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82153>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82154>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82155>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82156>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82157>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82158>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82159>>>>>>>>>>            Increment i
82160>>>>>>>>>>
82160>>>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
82161>>>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
82162>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82163>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82164>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82165>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82166>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82167>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82168>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82169>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82170>>>>>>>>>>            Increment i
82171>>>>>>>>>>
82171>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
82172>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82173>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82174>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82175>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82176>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82177>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82178>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82179>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82180>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82181>>>>>>>>>>            Increment i
82182>>>>>>>>>>
82182>>>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
82183>>>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
82184>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82185>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82186>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82187>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82188>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82189>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82190>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82191>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82192>>>>>>>>>>            Increment i
82193>>>>>>>>>>
82193>>>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
82194>>>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
82195>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82196>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82197>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82198>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82199>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82200>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82201>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82202>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82203>>>>>>>>>>            Increment i
82204>>>>>>>>>>
82204>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
82205>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82206>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82207>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82208>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82209>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82210>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82211>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82212>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82213>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82214>>>>>>>>>>            Increment i
82215>>>>>>>>>>
82215>>>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
82216>>>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
82217>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82218>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82219>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82220>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82221>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82222>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82223>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82224>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82225>>>>>>>>>>            Increment i
82226>>>>>>>>>>
82226>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82227>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82228>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82229>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82230>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82231>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82232>>>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
82233>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82234>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82235>>>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
82236>>>>>>>>>>            Increment i
82237>>>>>>>>>>
82237>>>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
82238>>>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
82239>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82240>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82241>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82242>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82243>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82244>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82245>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82246>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82247>>>>>>>>>>            Increment i
82248>>>>>>>>>>
82248>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82249>>>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
82250>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82251>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82252>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82253>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82254>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82255>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82256>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82257>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82258>>>>>>>>>>            Increment i
82259>>>>>>>>>>
82259>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82260>>>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
82261>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82262>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82263>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82264>>>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
82265>>>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
82266>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82267>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82268>>>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
82269>>>>>>>>>>            Increment i
82270>>>>>>>>>>
82270>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82271>>>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
82272>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82273>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82274>>>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
82275>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82276>>>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
82277>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82278>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82279>>>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
82280>>>>>>>>>>            Increment i
82281>>>>>>>>>>
82281>>>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
82282>>>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
82283>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82284>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82285>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82286>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82287>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82288>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82289>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82290>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82291>>>>>>>>>>            Increment i
82292>>>>>>>>>>
82292>>>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
82293>>>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
82294>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82295>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82296>>>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
82297>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82298>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82299>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82300>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82301>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82302>>>>>>>>>>            Increment i
82303>>>>>>>>>>
82303>>>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
82304>>>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
82305>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82306>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82307>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82308>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82309>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82310>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82311>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82312>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82313>>>>>>>>>>            Increment i
82314>>>>>>>>>>
82314>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82315>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82316>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82317>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82318>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82319>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82320>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82321>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82322>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82323>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82324>>>>>>>>>>            Increment i
82325>>>>>>>>>>
82325>>>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
82326>>>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
82327>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82328>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82329>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82330>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82331>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82332>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82333>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82334>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82335>>>>>>>>>>            Increment i
82336>>>>>>>>>>
82336>>>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
82337>>>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
82338>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82339>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82340>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82341>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82342>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82343>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82344>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82345>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82346>>>>>>>>>>            Increment i
82347>>>>>>>>>>
82347>>>>>>>>>>
82347>>>>>>>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
82347>>>>>>>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
82347>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82347>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82347>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82347>>>>>>>>>//        Increment i
82347>>>>>>>>>//
82347>>>>>>>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
82347>>>>>>>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
82347>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82347>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82347>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82347>>>>>>>>>//        Increment i
82347>>>>>>>>>//
82347>>>>>>>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
82347>>>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
82347>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82347>>>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
82347>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82347>>>>>>>>>//        Increment i
82347>>>>>>>>>//
82347>>>>>>>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
82347>>>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
82347>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82347>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82347>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82347>>>>>>>>>//        Increment i
82347>>>>>>>>>//
82347>>>>>>>>>//        // ToDo: We need to change the sType when using this!
82347>>>>>>>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
82347>>>>>>>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
82347>>>>>>>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
82347>>>>>>>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
82347>>>>>>>>>//        Move "254"                  to ColumnType[i].sPrecision
82347>>>>>>>>>//        Increment i
82347>>>>>>>>>//
82347>>>>>>>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
82347>>>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
82347>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
82347>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82347>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82347>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82347>>>>>>>>>//        Increment i
82347>>>>>>>>>//
82347>>>>>>>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
82347>>>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
82347>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82347>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82347>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82347>>>>>>>>>//        Increment i
82347>>>>>>>>>//
82347>>>>>>>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
82347>>>>>>>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
82347>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82347>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82347>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82347>>>>>>>>>//        Increment i
82347>>>>>>>>>//
82347>>>>>>>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
82347>>>>>>>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
82347>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82347>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82347>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82347>>>>>>>>>//        Increment i
82347>>>>>>>>>//
82347>>>>>>>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
82347>>>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
82347>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82347>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82347>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82347>>>>>>>>>//        Increment i
82347>>>>>>>>>//
82347>>>>>>>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
82347>>>>>>>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
82347>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82347>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82347>>>>>>>>>//        Move "255"              to ColumnType[i].sPrecision
82347>>>>>>>>>//        Increment i
82347>>>>>>>>>//
82347>>>>>>>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
82347>>>>>>>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
82347>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82347>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82347>>>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
82347>>>>>>>>>//        Increment i
82347>>>>>>>>>//
82347>>>>>>>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
82347>>>>>>>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
82347>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82347>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82347>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82347>>>>>>>>>//        Increment i
82347>>>>>>>>>//
82347>>>>>>>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
82347>>>>>>>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
82347>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82347>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82347>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82347>>>>>>>>>//        Increment i
82347>>>>>>>>>//
82347>>>>>>>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
82347>>>>>>>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
82347>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82347>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82347>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82347>>>>>>>>>//        Increment i
82347>>>>>>>>>//
82347>>>>>>>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
82347>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
82347>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82347>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82347>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82347>>>>>>>>>//        Increment i
82347>>>>>>>>>//
82347>>>>>>>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
82347>>>>>>>>>//        Move "REAL"             to ColumnType[i].sSQLType
82347>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82347>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82347>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82347>>>>>>>>>//        Increment i
82347>>>>>>>>>//
82347>>>>>>>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
82347>>>>>>>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
82347>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82347>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82347>>>>>>>>>//        Move "5.0"              to ColumnType[i].sPrecision
82347>>>>>>>>>//        Increment i
82347>>>>>>>>>//
82347>>>>>>>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
82347>>>>>>>>>//        Move "TIME"             to ColumnType[i].sSQLType
82347>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82347>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82347>>>>>>>>>//        Move "19.0"             to ColumnType[i].sPrecision
82347>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82347>>>>>>>>>//        Increment i
82347>>>>>>>>>//
82347>>>>>>>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
82347>>>>>>>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
82347>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82347>>>>>>>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
82347>>>>>>>>>//        Move "23.6"             to ColumnType[i].sPrecision
82347>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82347>>>>>>>>>//        Increment i
82347>>>>>>>>>//
82347>>>>>>>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
82347>>>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
82347>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82347>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82347>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82347>>>>>>>>>//        Increment i
82347>>>>>>>>>//
82347>>>>>>>>>//        // ToDo: We need to change the sType when using this!
82347>>>>>>>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
82347>>>>>>>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
82347>>>>>>>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
82347>>>>>>>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
82347>>>>>>>>>//        Move "16384"                to ColumnType[i].sPrecision
82347>>>>>>>>>//        Increment i
82347>>>>>>>>>//
82347>>>>>>>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
82347>>>>>>>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
82347>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82347>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82347>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82347>>>>>>>>>//
82347>>>>>>>>>//        Move SQL_XML            to ColumnType[i].iSQLType
82347>>>>>>>>>//        Move "XML"              to ColumnType[i].sSQLType
82347>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82347>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82347>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82347>>>>>>>>>
82347>>>>>>>>>        Function_Return aColumnType
82348>>>>>>>>>    End_Function
82349>>>>>>>>>
82349>>>>>>>>>    // Microsoft SQL Server Database Data Types:
82349>>>>>>>>>    // Helper function for _UtilEnumerateColumnTypes
82349>>>>>>>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
82351>>>>>>>>>        tColumnType[] aColumnType
82351>>>>>>>>>        tColumnType[] aColumnType
82352>>>>>>>>>        Integer i
82352>>>>>>>>>
82352>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSQLDRV_DriverDef.inc)
82354>>>>>>>>>>// Generated By The Database Update Framework
82354>>>>>>>>>>// Driver XML File: C:\Program Files\DataFlex 20.0\Lib\MSSQLDRV_DriverDef.xml
82354>>>>>>>>>>// Driver COLUMN DATA TYPES
82354>>>>>>>>>>//
82354>>>>>>>>>>// Created: 2019-11-15 21:57:51.001
82354>>>>>>>>>>
82354>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82355>>>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
82356>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82357>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82358>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82359>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82360>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82361>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82362>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82363>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82364>>>>>>>>>>            Increment i
82365>>>>>>>>>>
82365>>>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
82366>>>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
82367>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82368>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82369>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82370>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82371>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82372>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82373>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82374>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82375>>>>>>>>>>            Increment i
82376>>>>>>>>>>
82376>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82377>>>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
82378>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82379>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82380>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82381>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82382>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82383>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82384>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82385>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82386>>>>>>>>>>            Increment i
82387>>>>>>>>>>
82387>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82388>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82389>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82390>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82391>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82392>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82393>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82394>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82395>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82396>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82397>>>>>>>>>>            Increment i
82398>>>>>>>>>>
82398>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82399>>>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
82400>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82401>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82402>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82403>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82404>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82405>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82406>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82407>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82408>>>>>>>>>>            Increment i
82409>>>>>>>>>>
82409>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
82410>>>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
82411>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82412>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82413>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82414>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82415>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82416>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82417>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82418>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82419>>>>>>>>>>            Increment i
82420>>>>>>>>>>
82420>>>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
82421>>>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
82422>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82423>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82424>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82425>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
82426>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82427>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82428>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82429>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82430>>>>>>>>>>            Increment i
82431>>>>>>>>>>
82431>>>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
82432>>>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
82433>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82434>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82435>>>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
82436>>>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
82437>>>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
82438>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82439>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82440>>>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
82441>>>>>>>>>>            Increment i
82442>>>>>>>>>>
82442>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82443>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82444>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82445>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82446>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82447>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82448>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82449>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82450>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82451>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82452>>>>>>>>>>            Increment i
82453>>>>>>>>>>
82453>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82454>>>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
82455>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82456>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82457>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82458>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82459>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82460>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82461>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82462>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82463>>>>>>>>>>            Increment i
82464>>>>>>>>>>
82464>>>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
82465>>>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
82466>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82467>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82468>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82469>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82470>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82471>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82472>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82473>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82474>>>>>>>>>>            Increment i
82475>>>>>>>>>>
82475>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82476>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82477>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82478>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82479>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82480>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82481>>>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
82482>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82483>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82484>>>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
82485>>>>>>>>>>            Increment i
82486>>>>>>>>>>
82486>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
82487>>>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
82488>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82489>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82490>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82491>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82492>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82493>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82494>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82495>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82496>>>>>>>>>>            Increment i
82497>>>>>>>>>>
82497>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
82498>>>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
82499>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82500>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82501>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82502>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82503>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82504>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82505>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82506>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82507>>>>>>>>>>            Increment i
82508>>>>>>>>>>
82508>>>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
82509>>>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
82510>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82511>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82512>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82513>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82514>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82515>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82516>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82517>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82518>>>>>>>>>>            Increment i
82519>>>>>>>>>>
82519>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
82520>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82521>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82522>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82523>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82524>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82525>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82526>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82527>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82528>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82529>>>>>>>>>>            Increment i
82530>>>>>>>>>>
82530>>>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
82531>>>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
82532>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82533>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82534>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82535>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82536>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82537>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82538>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82539>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82540>>>>>>>>>>            Increment i
82541>>>>>>>>>>
82541>>>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
82542>>>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
82543>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82544>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82545>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82546>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82547>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82548>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82549>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82550>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82551>>>>>>>>>>            Increment i
82552>>>>>>>>>>
82552>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
82553>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82554>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82555>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82556>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82557>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82558>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82559>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82560>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82561>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82562>>>>>>>>>>            Increment i
82563>>>>>>>>>>
82563>>>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
82564>>>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
82565>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82566>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82567>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82568>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82569>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82570>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82571>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82572>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82573>>>>>>>>>>            Increment i
82574>>>>>>>>>>
82574>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82575>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82576>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82577>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82578>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82579>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82580>>>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
82581>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82582>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82583>>>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
82584>>>>>>>>>>            Increment i
82585>>>>>>>>>>
82585>>>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
82586>>>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
82587>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82588>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82589>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82590>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82591>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82592>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82593>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82594>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82595>>>>>>>>>>            Increment i
82596>>>>>>>>>>
82596>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82597>>>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
82598>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82599>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82600>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82601>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82602>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82603>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82604>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82605>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82606>>>>>>>>>>            Increment i
82607>>>>>>>>>>
82607>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82608>>>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
82609>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82610>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82611>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82612>>>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
82613>>>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
82614>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82615>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82616>>>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
82617>>>>>>>>>>            Increment i
82618>>>>>>>>>>
82618>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82619>>>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
82620>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82621>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82622>>>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
82623>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82624>>>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
82625>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82626>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82627>>>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
82628>>>>>>>>>>            Increment i
82629>>>>>>>>>>
82629>>>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
82630>>>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
82631>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82632>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82633>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82634>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82635>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82636>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82637>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82638>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82639>>>>>>>>>>            Increment i
82640>>>>>>>>>>
82640>>>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
82641>>>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
82642>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82643>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82644>>>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
82645>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82646>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82647>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82648>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82649>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82650>>>>>>>>>>            Increment i
82651>>>>>>>>>>
82651>>>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
82652>>>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
82653>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82654>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82655>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82656>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82657>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82658>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82659>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82660>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82661>>>>>>>>>>            Increment i
82662>>>>>>>>>>
82662>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82663>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82664>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82665>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82666>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82667>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82668>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82669>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82670>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82671>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82672>>>>>>>>>>            Increment i
82673>>>>>>>>>>
82673>>>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
82674>>>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
82675>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82676>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82677>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82678>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82679>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82680>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82681>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82682>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82683>>>>>>>>>>            Increment i
82684>>>>>>>>>>
82684>>>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
82685>>>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
82686>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82687>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82688>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82689>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82690>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82691>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82692>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82693>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82694>>>>>>>>>>            Increment i
82695>>>>>>>>>>
82695>>>>>>>>>>
82695>>>>>>>>>
82695>>>>>>>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "bigint"           to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
82695>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "binary"           to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "bit"              to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
82695>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "char"             to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "date"             to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
82695>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "23.3"             to ColumnType[i].sPrecision
82695>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "datetime2"         to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "23.6"              to ColumnType[i].sPrecision
82695>>>>>>>>>//            Move True                to ColumnType[i].bCanEditSize
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "34.0"                 to ColumnType[i].sPrecision
82695>>>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "decimal"          to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "float"            to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "int"              to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "8.0"              to ColumnType[i].sPrecision
82695>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "money"            to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "nchar"            to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "ntext"            to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "numeric"          to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82695>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "real"             to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "23.0"                 to ColumnType[i].sPrecision
82695>>>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "smallint"         to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "4.0"              to ColumnType[i].sPrecision
82695>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "10.0"              to ColumnType[i].sPrecision
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "text"             to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82695>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "19.0"             to ColumnType[i].sPrecision
82695>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "tinyint"          to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "2.0"              to ColumnType[i].sPrecision
82695>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "36"               to ColumnType[i].sPrecision
82695>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "varbinary"        to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82695>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "varchar"          to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
82695>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82695>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "xml"              to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "DATE"             to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "date"             to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
82695>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "8.7"              to ColumnType[i].sPrecision
82695>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>//
82695>>>>>>>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
82695>>>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
82695>>>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
82695>>>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
82695>>>>>>>>>//            Move "23.6"             to ColumnType[i].sPrecision
82695>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82695>>>>>>>>>//            Increment i
82695>>>>>>>>>
82695>>>>>>>>>        End
82695>>>>>>>>>>
82695>>>>>>>>>
82695>>>>>>>>>        Function_Return aColumnType
82696>>>>>>>>>    End_Function
82697>>>>>>>>>
82697>>>>>>>>>    // MySQL Data Types
82697>>>>>>>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
82699>>>>>>>>>        tColumnType[] aColumnType
82699>>>>>>>>>        tColumnType[] aColumnType
82700>>>>>>>>>        Integer i
82700>>>>>>>>>
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdsmysql_DriverDef.inc)
82700>>>>>>>>>>// Generated By The Database Update Framework
82700>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
82700>>>>>>>>>>// Driver COLUMN DATA TYPES
82700>>>>>>>>>>//
82700>>>>>>>>>>// Created: 2018-03-14 23:46:49.593
82700>>>>>>>>>>
82700>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82701>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
82702>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82703>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82704>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82705>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82706>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82707>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82708>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82709>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82710>>>>>>>>>>            Increment i
82711>>>>>>>>>>
82711>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82712>>>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
82713>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82714>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82715>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82716>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82717>>>>>>>>>>            Move 64                                      to aColumnType[i].nMaxSize
82718>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82719>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82720>>>>>>>>>>            Move 64                                      to aColumnType[i].sPrecision
82721>>>>>>>>>>            Increment i
82722>>>>>>>>>>
82722>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
82723>>>>>>>>>>            Move 252                                     to aColumnType[i].iSQLType
82724>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82725>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82726>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82727>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82728>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82729>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82730>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82731>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82732>>>>>>>>>>            Increment i
82733>>>>>>>>>>
82733>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82734>>>>>>>>>>            Move 254                                     to aColumnType[i].iSQLType
82735>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82736>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82737>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82738>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82739>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82740>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82741>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82742>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82743>>>>>>>>>>            Increment i
82744>>>>>>>>>>
82744>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82745>>>>>>>>>>            Move 10                                      to aColumnType[i].iSQLType
82746>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82747>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82748>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82749>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82750>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82751>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82752>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82753>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82754>>>>>>>>>>            Increment i
82755>>>>>>>>>>
82755>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
82756>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82757>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82758>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82759>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82760>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82761>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82762>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82763>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82764>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82765>>>>>>>>>>            Increment i
82766>>>>>>>>>>
82766>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82767>>>>>>>>>>            Move 246                                     to aColumnType[i].iSQLType
82768>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82769>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82770>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82771>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82772>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82773>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82774>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82775>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82776>>>>>>>>>>            Increment i
82777>>>>>>>>>>
82777>>>>>>>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
82778>>>>>>>>>>            Move 0                                       to aColumnType[i].iSQLType
82779>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82780>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82781>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82782>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82783>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82784>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82785>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82786>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82787>>>>>>>>>>            Increment i
82788>>>>>>>>>>
82788>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
82789>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82790>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82791>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82792>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82793>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82794>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82795>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82796>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82797>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82798>>>>>>>>>>            Increment i
82799>>>>>>>>>>
82799>>>>>>>>>>            Move "enum"                                  to aColumnType[i].sSQLType
82800>>>>>>>>>>            Move 247                                     to aColumnType[i].iSQLType
82801>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82802>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82803>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82804>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82805>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82806>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82807>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82808>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82809>>>>>>>>>>            Increment i
82810>>>>>>>>>>
82810>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82811>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82812>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82813>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82814>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82815>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82816>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82817>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82818>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82819>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82820>>>>>>>>>>            Increment i
82821>>>>>>>>>>
82821>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82822>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82823>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82824>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82825>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82826>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82827>>>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
82828>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82829>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82830>>>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
82831>>>>>>>>>>            Increment i
82832>>>>>>>>>>
82832>>>>>>>>>>            Move "longblob"                              to aColumnType[i].sSQLType
82833>>>>>>>>>>            Move 251                                     to aColumnType[i].iSQLType
82834>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82835>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82836>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82837>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82838>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82839>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82840>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82841>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82842>>>>>>>>>>            Increment i
82843>>>>>>>>>>
82843>>>>>>>>>>            Move "longtext"                              to aColumnType[i].sSQLType
82844>>>>>>>>>>            Move -251                                    to aColumnType[i].iSQLType
82845>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82846>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82847>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82848>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82849>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82850>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82851>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82852>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82853>>>>>>>>>>            Increment i
82854>>>>>>>>>>
82854>>>>>>>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
82855>>>>>>>>>>            Move 250                                     to aColumnType[i].iSQLType
82856>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82857>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82858>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82859>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82860>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82861>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82862>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82863>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82864>>>>>>>>>>            Increment i
82865>>>>>>>>>>
82865>>>>>>>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
82866>>>>>>>>>>            Move 9                                       to aColumnType[i].iSQLType
82867>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82868>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82869>>>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
82870>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82871>>>>>>>>>>            Move 9                                       to aColumnType[i].nMaxSize
82872>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82873>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82874>>>>>>>>>>            Move 9                                       to aColumnType[i].sPrecision
82875>>>>>>>>>>            Increment i
82876>>>>>>>>>>
82876>>>>>>>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
82877>>>>>>>>>>            Move -250                                    to aColumnType[i].iSQLType
82878>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82879>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82880>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82881>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82882>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82883>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82884>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82885>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82886>>>>>>>>>>            Increment i
82887>>>>>>>>>>
82887>>>>>>>>>>            Move "set"                                   to aColumnType[i].sSQLType
82888>>>>>>>>>>            Move 248                                     to aColumnType[i].iSQLType
82889>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82890>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82891>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82892>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82893>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82894>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82895>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82896>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82897>>>>>>>>>>            Increment i
82898>>>>>>>>>>
82898>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82899>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82900>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82901>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82902>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82903>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82904>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
82905>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82906>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82907>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82908>>>>>>>>>>            Increment i
82909>>>>>>>>>>
82909>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82910>>>>>>>>>>            Move -252                                    to aColumnType[i].iSQLType
82911>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82912>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82913>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82914>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82915>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82916>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82917>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82918>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82919>>>>>>>>>>            Increment i
82920>>>>>>>>>>
82920>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82921>>>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
82922>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82923>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82924>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82925>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82926>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82927>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82928>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82929>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82930>>>>>>>>>>            Increment i
82931>>>>>>>>>>
82931>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
82932>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82933>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82934>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82935>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82936>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82937>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82938>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82939>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82940>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82941>>>>>>>>>>            Increment i
82942>>>>>>>>>>
82942>>>>>>>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
82943>>>>>>>>>>            Move 249                                     to aColumnType[i].iSQLType
82944>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82945>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82946>>>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
82947>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82948>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82949>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82950>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82951>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82952>>>>>>>>>>            Increment i
82953>>>>>>>>>>
82953>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82954>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82955>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82956>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82957>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82958>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82959>>>>>>>>>>            Move 4                                       to aColumnType[i].nMaxSize
82960>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82961>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82962>>>>>>>>>>            Move 4                                       to aColumnType[i].sPrecision
82963>>>>>>>>>>            Increment i
82964>>>>>>>>>>
82964>>>>>>>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
82965>>>>>>>>>>            Move -249                                    to aColumnType[i].iSQLType
82966>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82967>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82968>>>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
82969>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82970>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82971>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82972>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82973>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82974>>>>>>>>>>            Increment i
82975>>>>>>>>>>
82975>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82976>>>>>>>>>>            Move 253                                     to aColumnType[i].iSQLType
82977>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82978>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82979>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82980>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82981>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82982>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82983>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82984>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82985>>>>>>>>>>            Increment i
82986>>>>>>>>>>
82986>>>>>>>>>>            Move "year"                                  to aColumnType[i].sSQLType
82987>>>>>>>>>>            Move 13                                      to aColumnType[i].iSQLType
82988>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82989>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82990>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82991>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82992>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82993>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82994>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82995>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82996>>>>>>>>>>            Increment i
82997>>>>>>>>>>
82997>>>>>>>>>>
82997>>>>>>>>>
82997>>>>>>>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
82997>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "blob"             to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82997>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "datetime"         to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82997>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "enum"             to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "float"            to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "int"              to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "longblob"         to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "longtext"         to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "mediumint"        to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "set"              to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "10.0"             to ColumnType[i].sPrecision
82997>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82997>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "tinyint"          to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "tinytext"         to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>//
82997>>>>>>>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
82997>>>>>>>>>//        Move "year"             to ColumnType[i].sSQLType
82997>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82997>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82997>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
82997>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82997>>>>>>>>>//        Increment i
82997>>>>>>>>>
82997>>>>>>>>>        Function_Return aColumnType
82998>>>>>>>>>    End_Function
82999>>>>>>>>>
82999>>>>>>>>>    // Oracle Data Types
82999>>>>>>>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
83001>>>>>>>>>        tColumnType[] aColumnType
83001>>>>>>>>>        tColumnType[] aColumnType
83002>>>>>>>>>        Integer i
83002>>>>>>>>>
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ora_drv_DriverDef.inc)
83002>>>>>>>>>>// Generated By The Database Update Framework
83002>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
83002>>>>>>>>>>// Driver COLUMN DATA TYPES
83002>>>>>>>>>>//
83002>>>>>>>>>>// Created: 2018-03-14 23:47:34.82
83002>>>>>>>>>>
83002>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
83003>>>>>>>>>>            Move 113                                     to aColumnType[i].iSQLType
83004>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83005>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83006>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83007>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83008>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83009>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83010>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83011>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83012>>>>>>>>>>            Increment i
83013>>>>>>>>>>
83013>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
83014>>>>>>>>>>            Move 96                                      to aColumnType[i].iSQLType
83015>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83016>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83017>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83018>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83019>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
83020>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83021>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83022>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
83023>>>>>>>>>>            Increment i
83024>>>>>>>>>>
83024>>>>>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
83025>>>>>>>>>>            Move 112                                     to aColumnType[i].iSQLType
83026>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83027>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83028>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83029>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83030>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83031>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
83032>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
83033>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83034>>>>>>>>>>            Increment i
83035>>>>>>>>>>
83035>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
83036>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
83037>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83038>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83039>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83040>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
83041>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
83042>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
83043>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
83044>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83045>>>>>>>>>>            Increment i
83046>>>>>>>>>>
83046>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
83047>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
83048>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83049>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83050>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83051>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83052>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83053>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83054>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83055>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83056>>>>>>>>>>            Increment i
83057>>>>>>>>>>
83057>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
83058>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
83059>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83060>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83061>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83062>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83063>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83064>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83065>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83066>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83067>>>>>>>>>>            Increment i
83068>>>>>>>>>>
83068>>>>>>>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
83069>>>>>>>>>>            Move 190                                     to aColumnType[i].iSQLType
83070>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83071>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83072>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83073>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83074>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83075>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83076>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83077>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83078>>>>>>>>>>            Increment i
83079>>>>>>>>>>
83079>>>>>>>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
83080>>>>>>>>>>            Move 189                                     to aColumnType[i].iSQLType
83081>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83082>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83083>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83084>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83085>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83086>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83087>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83088>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83089>>>>>>>>>>            Increment i
83090>>>>>>>>>>
83090>>>>>>>>>>            Move "long"                                  to aColumnType[i].sSQLType
83091>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
83092>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83093>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83094>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83095>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83096>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83097>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83098>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83099>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83100>>>>>>>>>>            Increment i
83101>>>>>>>>>>
83101>>>>>>>>>>            Move "longraw"                               to aColumnType[i].sSQLType
83102>>>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
83103>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83104>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83105>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83106>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83107>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83108>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83109>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83110>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83111>>>>>>>>>>            Increment i
83112>>>>>>>>>>
83112>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
83113>>>>>>>>>>            Move 286                                     to aColumnType[i].iSQLType
83114>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83115>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83116>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83117>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83118>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
83119>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83120>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83121>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
83122>>>>>>>>>>            Increment i
83123>>>>>>>>>>
83123>>>>>>>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
83124>>>>>>>>>>            Move 288                                     to aColumnType[i].iSQLType
83125>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83126>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83127>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83128>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83129>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83130>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
83131>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
83132>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83133>>>>>>>>>>            Increment i
83134>>>>>>>>>>
83134>>>>>>>>>>            Move "number"                                to aColumnType[i].sSQLType
83135>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
83136>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83137>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83138>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83139>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83140>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83141>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83142>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83143>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83144>>>>>>>>>>            Increment i
83145>>>>>>>>>>
83145>>>>>>>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
83146>>>>>>>>>>            Move 287                                     to aColumnType[i].iSQLType
83147>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83148>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83149>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83150>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83151>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
83152>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83153>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83154>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
83155>>>>>>>>>>            Increment i
83156>>>>>>>>>>
83156>>>>>>>>>>            Move "raw"                                   to aColumnType[i].sSQLType
83157>>>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
83158>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83159>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83160>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83161>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83162>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
83163>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83164>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83165>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
83166>>>>>>>>>>            Increment i
83167>>>>>>>>>>
83167>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
83168>>>>>>>>>>            Move 187                                     to aColumnType[i].iSQLType
83169>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83170>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83171>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83172>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83173>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83174>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83175>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83176>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83177>>>>>>>>>>            Increment i
83178>>>>>>>>>>
83178>>>>>>>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
83179>>>>>>>>>>            Move 232                                     to aColumnType[i].iSQLType
83180>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83181>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83182>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83183>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83184>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83185>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83186>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83187>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83188>>>>>>>>>>            Increment i
83189>>>>>>>>>>
83189>>>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
83190>>>>>>>>>>            Move 188                                     to aColumnType[i].iSQLType
83191>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83192>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83193>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83194>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83195>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83196>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83197>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83198>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83199>>>>>>>>>>            Increment i
83200>>>>>>>>>>
83200>>>>>>>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
83201>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
83202>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83203>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83204>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83205>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83206>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
83207>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83208>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83209>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
83210>>>>>>>>>>            Increment i
83211>>>>>>>>>>
83211>>>>>>>>>>
83211>>>>>>>>>
83211>>>>>>>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
83211>>>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
83211>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83211>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83211>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83211>>>>>>>>>//        Increment i
83211>>>>>>>>>//
83211>>>>>>>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
83211>>>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
83211>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83211>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83211>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83211>>>>>>>>>//        Increment i
83211>>>>>>>>>//
83211>>>>>>>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
83211>>>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
83211>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83211>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83211>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83211>>>>>>>>>//        Increment i
83211>>>>>>>>>//
83211>>>>>>>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
83211>>>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
83211>>>>>>>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
83211>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
83211>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83211>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83211>>>>>>>>>//        Increment i
83211>>>>>>>>>//
83211>>>>>>>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
83211>>>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
83211>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83211>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
83211>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83211>>>>>>>>>//        Increment i
83211>>>>>>>>>//
83211>>>>>>>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
83211>>>>>>>>>//        Move "INT"              to ColumnType[i].sSQLType
83211>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83211>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
83211>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
83211>>>>>>>>>//        Increment i
83211>>>>>>>>>//
83211>>>>>>>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
83211>>>>>>>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
83211>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83211>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83211>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
83211>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83211>>>>>>>>>//        Increment i
83211>>>>>>>>>//
83211>>>>>>>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
83211>>>>>>>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
83211>>>>>>>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
83211>>>>>>>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
83211>>>>>>>>>//        Move "23.0"              to ColumnType[i].sPrecision
83211>>>>>>>>>//        Move True                to ColumnType[i].bCanEditSize
83211>>>>>>>>>//        Increment i
83211>>>>>>>>>//
83211>>>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
83211>>>>>>>>>//        Move "LONG"             to ColumnType[i].sSQLType
83211>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83211>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83211>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83211>>>>>>>>>//        Increment i
83211>>>>>>>>>//
83211>>>>>>>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
83211>>>>>>>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
83211>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83211>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83211>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83211>>>>>>>>>//        Increment i
83211>>>>>>>>>//
83211>>>>>>>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
83211>>>>>>>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
83211>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83211>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83211>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83211>>>>>>>>>//        Increment i
83211>>>>>>>>>//
83211>>>>>>>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
83211>>>>>>>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
83211>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83211>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83211>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83211>>>>>>>>>//        Increment i
83211>>>>>>>>>//
83211>>>>>>>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
83211>>>>>>>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
83211>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83211>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
83211>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83211>>>>>>>>>//        Increment i
83211>>>>>>>>>//
83211>>>>>>>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
83211>>>>>>>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
83211>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83211>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83211>>>>>>>>>//        Move "4000"             to ColumnType[i].sPrecision
83211>>>>>>>>>//        Increment i
83211>>>>>>>>>//
83211>>>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
83211>>>>>>>>>//        Move "RAW"              to ColumnType[i].sSQLType
83211>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83211>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83211>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83211>>>>>>>>>//        Increment i
83211>>>>>>>>>//
83211>>>>>>>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
83211>>>>>>>>>//        Move "ROWID"            to ColumnType[i].sSQLType
83211>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83211>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83211>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83211>>>>>>>>>//        Increment i
83211>>>>>>>>>//
83211>>>>>>>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
83211>>>>>>>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
83211>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83211>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83211>>>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
83211>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83211>>>>>>>>>//        Increment i
83211>>>>>>>>>//
83211>>>>>>>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
83211>>>>>>>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
83211>>>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
83211>>>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
83211>>>>>>>>>//        Move "13.0"                 to ColumnType[i].sPrecision
83211>>>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
83211>>>>>>>>>//        Increment i
83211>>>>>>>>>//
83211>>>>>>>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
83211>>>>>>>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
83211>>>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
83211>>>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
83211>>>>>>>>>//        Move "11.0"                 to ColumnType[i].sPrecision
83211>>>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
83211>>>>>>>>>//        Increment i
83211>>>>>>>>>//
83211>>>>>>>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
83211>>>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
83211>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83211>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83211>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83211>>>>>>>>>
83211>>>>>>>>>        Function_Return aColumnType
83212>>>>>>>>>    End_Function
83213>>>>>>>>>
83213>>>>>>>>>    // PostgreSQL Data Types
83213>>>>>>>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
83215>>>>>>>>>        tColumnType[] aColumnType
83215>>>>>>>>>        tColumnType[] aColumnType
83216>>>>>>>>>        Integer i
83216>>>>>>>>>
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdspgsql_DriverDef.inc)
83216>>>>>>>>>>// Generated By The Database Update Framework
83216>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
83216>>>>>>>>>>// Driver COLUMN DATA TYPES
83216>>>>>>>>>>//
83216>>>>>>>>>>// Created: 2018-03-14 23:47:02.984
83216>>>>>>>>>>
83216>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
83217>>>>>>>>>>            Move 20                                      to aColumnType[i].iSQLType
83218>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83219>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83220>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83221>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83222>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83223>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83224>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83225>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83226>>>>>>>>>>            Increment i
83227>>>>>>>>>>
83227>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
83228>>>>>>>>>>            Move 1560                                    to aColumnType[i].iSQLType
83229>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83230>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83231>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83232>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83233>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83234>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83235>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83236>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83237>>>>>>>>>>            Increment i
83238>>>>>>>>>>
83238>>>>>>>>>>            Move "boolean"                               to aColumnType[i].sSQLType
83239>>>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
83240>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83241>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83242>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83243>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83244>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83245>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83246>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83247>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83248>>>>>>>>>>            Increment i
83249>>>>>>>>>>
83249>>>>>>>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
83250>>>>>>>>>>            Move 17                                      to aColumnType[i].iSQLType
83251>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83252>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83253>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83254>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83255>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83256>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83257>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83258>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83259>>>>>>>>>>            Increment i
83260>>>>>>>>>>
83260>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
83261>>>>>>>>>>            Move 18                                      to aColumnType[i].iSQLType
83262>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83263>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83264>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83265>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83266>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83267>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83268>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83269>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83270>>>>>>>>>>            Increment i
83271>>>>>>>>>>
83271>>>>>>>>>>            Move "citext"                                to aColumnType[i].sSQLType
83272>>>>>>>>>>            Move -25                                     to aColumnType[i].iSQLType
83273>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83274>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83275>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83276>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83277>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83278>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83279>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83280>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83281>>>>>>>>>>            Increment i
83282>>>>>>>>>>
83282>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
83283>>>>>>>>>>            Move 1082                                    to aColumnType[i].iSQLType
83284>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83285>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83286>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83287>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83288>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83289>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
83290>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
83291>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83292>>>>>>>>>>            Increment i
83293>>>>>>>>>>
83293>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
83294>>>>>>>>>>            Move 701                                     to aColumnType[i].iSQLType
83295>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83296>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83297>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83298>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83299>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83300>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83301>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83302>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83303>>>>>>>>>>            Increment i
83304>>>>>>>>>>
83304>>>>>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
83305>>>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
83306>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83307>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83308>>>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
83309>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83310>>>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
83311>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83312>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83313>>>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
83314>>>>>>>>>>            Increment i
83315>>>>>>>>>>
83315>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
83316>>>>>>>>>>            Move 790                                     to aColumnType[i].iSQLType
83317>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83318>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83319>>>>>>>>>>            Move 30                                      to aColumnType[i].iDefaultSize
83320>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83321>>>>>>>>>>            Move 30                                      to aColumnType[i].nMaxSize
83322>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83323>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83324>>>>>>>>>>            Move 30                                      to aColumnType[i].sPrecision
83325>>>>>>>>>>            Increment i
83326>>>>>>>>>>
83326>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
83327>>>>>>>>>>            Move 1700                                    to aColumnType[i].iSQLType
83328>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83329>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83330>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83331>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83332>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83333>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83334>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83335>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83336>>>>>>>>>>            Increment i
83337>>>>>>>>>>
83337>>>>>>>>>>            Move "oid"                                   to aColumnType[i].sSQLType
83338>>>>>>>>>>            Move 26                                      to aColumnType[i].iSQLType
83339>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83340>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83341>>>>>>>>>>            Move 20                                      to aColumnType[i].iDefaultSize
83342>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83343>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83344>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83345>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83346>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83347>>>>>>>>>>            Increment i
83348>>>>>>>>>>
83348>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
83349>>>>>>>>>>            Move 700                                     to aColumnType[i].iSQLType
83350>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83351>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83352>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83353>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83354>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
83355>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83356>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83357>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83358>>>>>>>>>>            Increment i
83359>>>>>>>>>>
83359>>>>>>>>>>            Move "regproc"                               to aColumnType[i].sSQLType
83360>>>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
83361>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83362>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83363>>>>>>>>>>            Move 64                                      to aColumnType[i].iDefaultSize
83364>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83365>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83366>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83367>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83368>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83369>>>>>>>>>>            Increment i
83370>>>>>>>>>>
83370>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
83371>>>>>>>>>>            Move 21                                      to aColumnType[i].iSQLType
83372>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83373>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83374>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83375>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83376>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
83377>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83378>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83379>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83380>>>>>>>>>>            Increment i
83381>>>>>>>>>>
83381>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
83382>>>>>>>>>>            Move 25                                      to aColumnType[i].iSQLType
83383>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83384>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83385>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83386>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83387>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83388>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83389>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83390>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83391>>>>>>>>>>            Increment i
83392>>>>>>>>>>
83392>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
83393>>>>>>>>>>            Move 1083                                    to aColumnType[i].iSQLType
83394>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83395>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83396>>>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
83397>>>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
83398>>>>>>>>>>            Move 15                                      to aColumnType[i].nMaxSize
83399>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83400>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83401>>>>>>>>>>            Move 15                                      to aColumnType[i].sPrecision
83402>>>>>>>>>>            Increment i
83403>>>>>>>>>>
83403>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
83404>>>>>>>>>>            Move 1114                                    to aColumnType[i].iSQLType
83405>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83406>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83407>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83408>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83409>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83410>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83411>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83412>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83413>>>>>>>>>>            Increment i
83414>>>>>>>>>>
83414>>>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
83415>>>>>>>>>>            Move 1184                                    to aColumnType[i].iSQLType
83416>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83417>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83418>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83419>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83420>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83421>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83422>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83423>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83424>>>>>>>>>>            Increment i
83425>>>>>>>>>>
83425>>>>>>>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
83426>>>>>>>>>>            Move 2950                                    to aColumnType[i].iSQLType
83427>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83428>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83429>>>>>>>>>>            Move 40                                      to aColumnType[i].iDefaultSize
83430>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83431>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83432>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83433>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83434>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83435>>>>>>>>>>            Increment i
83436>>>>>>>>>>
83436>>>>>>>>>>            Move "varbit"                                to aColumnType[i].sSQLType
83437>>>>>>>>>>            Move 1562                                    to aColumnType[i].iSQLType
83438>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83439>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83440>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83441>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83442>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83443>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83444>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83445>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83446>>>>>>>>>>            Increment i
83447>>>>>>>>>>
83447>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
83448>>>>>>>>>>            Move 1043                                    to aColumnType[i].iSQLType
83449>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83450>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83451>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83452>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83453>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83454>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83455>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83456>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83457>>>>>>>>>>            Increment i
83458>>>>>>>>>>
83458>>>>>>>>>>
83458>>>>>>>>>
83458>>>>>>>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
83458>>>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
83458>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83458>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83458>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
83458>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83458>>>>>>>>>//        Increment i
83458>>>>>>>>>//
83458>>>>>>>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
83458>>>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
83458>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83458>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83458>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83458>>>>>>>>>//        Increment i
83458>>>>>>>>>//
83458>>>>>>>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
83458>>>>>>>>>//        Move "boolean"          to ColumnType[i].sSQLType
83458>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83458>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83458>>>>>>>>>//        Move "1"                to ColumnType[i].sPrecision
83458>>>>>>>>>//        Increment i
83458>>>>>>>>>//
83458>>>>>>>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
83458>>>>>>>>>//        Move "bytea"            to ColumnType[i].sSQLType
83458>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83458>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83458>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83458>>>>>>>>>//        Increment i
83458>>>>>>>>>//
83458>>>>>>>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
83458>>>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
83458>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83458>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83458>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83458>>>>>>>>>//        Increment i
83458>>>>>>>>>//
83458>>>>>>>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
83458>>>>>>>>>//        Move "citext"           to ColumnType[i].sSQLType
83458>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83458>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83458>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
83458>>>>>>>>>//        Increment i
83458>>>>>>>>>//
83458>>>>>>>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
83458>>>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
83458>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
83458>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
83458>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83458>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83458>>>>>>>>>//        Increment i
83458>>>>>>>>>//
83458>>>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
83458>>>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
83458>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83458>>>>>>>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
83458>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83458>>>>>>>>>//        Increment i
83458>>>>>>>>>//
83458>>>>>>>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
83458>>>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
83458>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83458>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83458>>>>>>>>>//        Move "22"               to ColumnType[i].sPrecision
83458>>>>>>>>>//        Increment i
83458>>>>>>>>>//
83458>>>>>>>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
83458>>>>>>>>>//        Move "integer"          to ColumnType[i].sSQLType
83458>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83458>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83458>>>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
83458>>>>>>>>>//        Increment i
83458>>>>>>>>>//
83458>>>>>>>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
83458>>>>>>>>>//        Move "money"            to ColumnType[i].sSQLType
83458>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83458>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83458>>>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
83458>>>>>>>>>//        Increment i
83458>>>>>>>>>//
83458>>>>>>>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
83458>>>>>>>>>//        Move "oid"              to ColumnType[i].sSQLType
83458>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83458>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83458>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83458>>>>>>>>>//        Increment i
83458>>>>>>>>>//
83458>>>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
83458>>>>>>>>>//        Move "real"             to ColumnType[i].sSQLType
83458>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83458>>>>>>>>>//        Move "Real"             to ColumnType[i].sDataFlexType
83458>>>>>>>>>//        Move "6.6"              to ColumnType[i].sPrecision
83458>>>>>>>>>//        Increment i
83458>>>>>>>>>//
83458>>>>>>>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
83458>>>>>>>>>//        Move "regproc"          to ColumnType[i].sSQLType
83458>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83458>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83458>>>>>>>>>//        Move "64"               to ColumnType[i].sPrecision
83458>>>>>>>>>//        Increment i
83458>>>>>>>>>//
83458>>>>>>>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
83458>>>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
83458>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83458>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83458>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83458>>>>>>>>>//        Increment i
83458>>>>>>>>>//
83458>>>>>>>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
83458>>>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
83458>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83458>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83458>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83458>>>>>>>>>//        Increment i
83458>>>>>>>>>//
83458>>>>>>>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
83458>>>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
83458>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83458>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83458>>>>>>>>>//        Move "15.0"             to ColumnType[i].sPrecision
83458>>>>>>>>>//        Increment i
83458>>>>>>>>>//
83458>>>>>>>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
83458>>>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
83458>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83458>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83458>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
83458>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83458>>>>>>>>>//        Increment i
83458>>>>>>>>>//
83458>>>>>>>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
83458>>>>>>>>>//        Move "uuid"             to ColumnType[i].sSQLType
83458>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83458>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83458>>>>>>>>>//        Move "40"               to ColumnType[i].sPrecision
83458>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83458>>>>>>>>>//        Increment i
83458>>>>>>>>>//
83458>>>>>>>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
83458>>>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
83458>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83458>>>>>>>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
83458>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83458>>>>>>>>>//        Increment i
83458>>>>>>>>>
83458>>>>>>>>>        Function_Return aColumnType
83459>>>>>>>>>    End_Function
83460>>>>>>>>>
83460>>>>>>>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
83460>>>>>>>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
83462>>>>>>>>>        Integer iValue iSize iCount iStart iItem
83462>>>>>>>>>        tColumnType[] ColumnTypeArray
83462>>>>>>>>>        tColumnType[] ColumnTypeArray
83463>>>>>>>>>        tColumnType RetvalType
83463>>>>>>>>>        tColumnType RetvalType
83463>>>>>>>>>        String sValue
83463>>>>>>>>>        Boolean bFrameworkDataFlexType
83463>>>>>>>>>
83463>>>>>>>>>        Move "Undefined" to RetvalType.sSQLType
83464>>>>>>>>>        Move -1999       to RetvalType.iSQLType
83465>>>>>>>>>
83465>>>>>>>>>        Move 0 to iStart
83466>>>>>>>>>        Move (Uppercase(sType)) to sType
83467>>>>>>>>>        Move (iType <= -1490) to bFrameworkDataFlexType
83468>>>>>>>>>        If (bFrameworkDataFlexType = True) Begin
83470>>>>>>>>>            Get _UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
83471>>>>>>>>>            Function_Return RetvalType
83472>>>>>>>>>        End
83472>>>>>>>>>>
83472>>>>>>>>>
83472>>>>>>>>>        Get _UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
83473>>>>>>>>>        Move iType to RetvalType.iSQLType
83474>>>>>>>>>        Move sType to RetvalType.sSQLType 
83475>>>>>>>>>        Move (SearchArray(RetvalType, ColumnTypeArray)) to iItem
83476>>>>>>>>>        
83476>>>>>>>>>        If (iItem = -1) Begin
83478>>>>>>>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
83479>>>>>>>>>            Move (SearchArray(RetvalType, ColumnTypeArray)) to iItem
83480>>>>>>>>>        End
83480>>>>>>>>>>
83480>>>>>>>>>        If (iItem <> -1) Begin
83482>>>>>>>>>            Move ColumnTypeArray[iItem].sSQLType       to RetvalType.sSQLType
83483>>>>>>>>>            Move ColumnTypeArray[iItem].iSQLType       to RetvalType.iSQLType
83484>>>>>>>>>            Move ColumnTypeArray[iItem].sDataFlexType  to RetvalType.sDataFlexType
83485>>>>>>>>>            Move ColumnTypeArray[iItem].iDataFlexType  to RetvalType.iDataFlexType
83486>>>>>>>>>            Move ColumnTypeArray[iItem].sPrecision     to RetvalType.sPrecision
83487>>>>>>>>>            Move ColumnTypeArray[iItem].bCanEditSize   to RetvalType.bCanEditSize
83488>>>>>>>>>        End
83488>>>>>>>>>>
83488>>>>>>>>>
83488>>>>>>>>>        Function_Return RetvalType
83489>>>>>>>>>    End_Function
83490>>>>>>>>>
83490>>>>>>>>>    // Returns a struct array with all data types for the passed driver & dbtype.
83490>>>>>>>>>    Function _UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
83492>>>>>>>>>        tColumnType[] ColumnType
83492>>>>>>>>>        tColumnType[] ColumnType
83493>>>>>>>>>
83493>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
83493>>>>>>>>>        // the dbType.
83493>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83495>>>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
83497>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
83498>>>>>>>>>            End
83498>>>>>>>>>>
83498>>>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
83500>>>>>>>>>                Move MSSQLDRV_ID to sDriverID
83501>>>>>>>>>            End
83501>>>>>>>>>>
83501>>>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
83503>>>>>>>>>                Move DB2_DRV_ID to sDriverID
83504>>>>>>>>>            End
83504>>>>>>>>>>
83504>>>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
83506>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
83507>>>>>>>>>            End
83507>>>>>>>>>>
83507>>>>>>>>>        End
83507>>>>>>>>>>
83507>>>>>>>>>
83507>>>>>>>>>        Case Begin
83507>>>>>>>>>            Case (iDbType = EN_dbTypeDataFlex)
83509>>>>>>>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
83510>>>>>>>>>                Case Break
83511>>>>>>>>>
83511>>>>>>>>>            Case (iDbType = EN_DbTypeDB2)
83514>>>>>>>>>                Get _UtilEnumerateDB2Types to ColumnType
83515>>>>>>>>>                Case Break
83516>>>>>>>>>
83516>>>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
83519>>>>>>>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
83520>>>>>>>>>                Case Break
83521>>>>>>>>>        Case End
83521>>>>>>>>>
83521>>>>>>>>>        Function_Return ColumnType
83522>>>>>>>>>    End_Function
83523>>>>>>>>>
83523>>>>>>>>>    // Returns a struct with the default column types for the SQL back-end and how they
83523>>>>>>>>>    // are mapped to a DUF data type.
83523>>>>>>>>>    Function _UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
83525>>>>>>>>>        tColumnType ColumnType
83525>>>>>>>>>        tColumnType ColumnType
83525>>>>>>>>>        String sDataType
83525>>>>>>>>>        Integer iDriverID iCount
83525>>>>>>>>>
83525>>>>>>>>>        Move 0 to iCount
83526>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
83527>>>>>>>>>
83527>>>>>>>>>        Case Begin
83527>>>>>>>>>            // DF_ASCII
83527>>>>>>>>>            Case (iType = DF_ASCII_DUF)
83529>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83531>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
83534>>>>>>>>>                End
83534>>>>>>>>>>
83534>>>>>>>>>                Else Begin
83535>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
83538>>>>>>>>>                End
83538>>>>>>>>>>
83538>>>>>>>>>                Move DF_ASCII    to ColumnType.iDataFlexType
83539>>>>>>>>>                Move "ASCII"     to ColumnType.sDataFlexType
83540>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83541>>>>>>>>>                Move DF_ASCII    to ColumnType.iSQLType
83542>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83543>>>>>>>>>                Case Break
83544>>>>>>>>>
83544>>>>>>>>>            // DF_BINARY
83544>>>>>>>>>            Case (iType = DF_BINARY_DUF)
83547>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83549>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
83552>>>>>>>>>                End
83552>>>>>>>>>>
83552>>>>>>>>>                Else Begin
83553>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
83556>>>>>>>>>                End
83556>>>>>>>>>>
83556>>>>>>>>>                Move DF_BINARY   to ColumnType.iDataFlexType
83557>>>>>>>>>                Move "Binary"    to ColumnType.sDataFlexType
83558>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83559>>>>>>>>>                Move DF_BINARY   to ColumnType.iSQLType
83560>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83561>>>>>>>>>                Case Break
83562>>>>>>>>>
83562>>>>>>>>>            // DF_DATE
83562>>>>>>>>>            Case (iType = DF_DATE_DUF)
83565>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83567>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83570>>>>>>>>>                End
83570>>>>>>>>>>
83570>>>>>>>>>                Else Begin
83571>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83574>>>>>>>>>                End
83574>>>>>>>>>>
83574>>>>>>>>>                Move DF_DATE     to ColumnType.iDataFlexType
83575>>>>>>>>>                Move "Date"      to ColumnType.sDataFlexType
83576>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83577>>>>>>>>>                Move DF_DATE     to ColumnType.iSQLType
83578>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83579>>>>>>>>>                Case Break
83580>>>>>>>>>
83580>>>>>>>>>            // DF_DATETIME
83580>>>>>>>>>            Case (iType = DF_DATETIME_DUF)
83583>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83585>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
83588>>>>>>>>>                End
83588>>>>>>>>>>
83588>>>>>>>>>                Else Begin
83589>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
83592>>>>>>>>>                End
83592>>>>>>>>>>
83592>>>>>>>>>                Move DF_DATETIME to ColumnType.iDataFlexType
83593>>>>>>>>>                Move "DateTime"  to ColumnType.sDataFlexType
83594>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83595>>>>>>>>>                Move DF_DATETIME to ColumnType.iSQLType
83596>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83597>>>>>>>>>                Case Break
83598>>>>>>>>>
83598>>>>>>>>>            // DF_NUMERIC
83598>>>>>>>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
83598>>>>>>>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
83598>>>>>>>>>            // we make them here all "Numeric"...
83598>>>>>>>>>            // If (sDriverID = ODBC_DRV_ID) Begin
83598>>>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83598>>>>>>>>>            // End
83598>>>>>>>>>            // Else Begin
83598>>>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83598>>>>>>>>>            // End
83598>>>>>>>>>            // ToDo: How should we find the best "Numeric" data type here?
83598>>>>>>>>>            Case (iType = DF_BCD_DUF)
83601>>>>>>>>>                Move DF_BCD      to ColumnType.iDataFlexType
83602>>>>>>>>>                Move "Numeric"   to ColumnType.sDataFlexType
83603>>>>>>>>>                Move "Numeric"   to ColumnType.sSQLType
83604>>>>>>>>>                Move SQL_NUMERIC to ColumnType.iSQLType
83605>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83606>>>>>>>>>                Case Break
83607>>>>>>>>>
83607>>>>>>>>>            // DF_TEXT
83607>>>>>>>>>            Case (iType = DF_TEXT_DUF)
83610>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83612>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
83615>>>>>>>>>                End
83615>>>>>>>>>>
83615>>>>>>>>>                Else Begin
83616>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
83619>>>>>>>>>                End
83619>>>>>>>>>>
83619>>>>>>>>>                Move DF_TEXT     to ColumnType.iDataFlexType
83620>>>>>>>>>                Move "Text"      to ColumnType.sDataFlexType
83621>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83622>>>>>>>>>                Move DF_TEXT     to ColumnType.iSQLType
83623>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83624>>>>>>>>>                Case Break
83625>>>>>>>>>
83625>>>>>>>>>            Case Else
83625>>>>>>>>>                Move -1999       to ColumnType.iDataFlexType
83626>>>>>>>>>                Move "Undefined" to ColumnType.sDataFlexType
83627>>>>>>>>>                Move "Undefined" to ColumnType.sSQLType
83628>>>>>>>>>                Move -1999       to ColumnType.iSQLType
83629>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83630>>>>>>>>>
83630>>>>>>>>>        Case End
83630>>>>>>>>>
83630>>>>>>>>>        Function_Return ColumnType
83631>>>>>>>>>    End_Function
83632>>>>>>>>>
83632>>>>>>>>>    Function _AllTablesToConvert Returns Integer[]
83634>>>>>>>>>        Integer[] aTableConvertExceptions iTablesArray
83636>>>>>>>>>        Handle hTable
83636>>>>>>>>>        Integer iIndex
83636>>>>>>>>>        String sTableName
83636>>>>>>>>>        Boolean bFlexErrs
83636>>>>>>>>>
83636>>>>>>>>>        // a) Get the exception table array the developer has specified
83636>>>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
83637>>>>>>>>>
83637>>>>>>>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
83637>>>>>>>>>        Repeat
83637>>>>>>>>>>
83637>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83640>>>>>>>>>            If (hTable <> 0) Begin
83642>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83645>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83646>>>>>>>>>                If (bFlexErrs = False) Begin
83648>>>>>>>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
83650>>>>>>>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
83651>>>>>>>>>                        If (iIndex = -1) Begin
83653>>>>>>>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
83654>>>>>>>>>                        End
83654>>>>>>>>>>
83654>>>>>>>>>                    End
83654>>>>>>>>>>
83654>>>>>>>>>                End
83654>>>>>>>>>>
83654>>>>>>>>>            End
83654>>>>>>>>>>
83654>>>>>>>>>        Until (hTable = 0)
83656>>>>>>>>>
83656>>>>>>>>>        Move 0 to hTable
83657>>>>>>>>>
83657>>>>>>>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
83657>>>>>>>>>        Repeat
83657>>>>>>>>>>
83657>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83660>>>>>>>>>            If (hTable > 0) Begin
83662>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83665>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83666>>>>>>>>>                If (bFlexErrs = False) Begin
83668>>>>>>>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
83669>>>>>>>>>                    If (iIndex = -1) Begin
83671>>>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
83672>>>>>>>>>                    End
83672>>>>>>>>>>
83672>>>>>>>>>                End
83672>>>>>>>>>>
83672>>>>>>>>>            End
83672>>>>>>>>>>
83672>>>>>>>>>        Until (hTable = 0)
83674>>>>>>>>>
83674>>>>>>>>>        Function_Return iTablesArray
83675>>>>>>>>>    End_Function
83676>>>>>>>>>
83676>>>>>>>>>    Function _AllTablesDateCorrections Returns Integer[]
83678>>>>>>>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
83680>>>>>>>>>        Handle hTable
83680>>>>>>>>>        Integer iIndex
83680>>>>>>>>>        String sTableName
83680>>>>>>>>>        Boolean bFlexErrs
83680>>>>>>>>>
83680>>>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
83681>>>>>>>>>        Move 0 to hTable
83682>>>>>>>>>
83682>>>>>>>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
83682>>>>>>>>>        Repeat
83682>>>>>>>>>>
83682>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83685>>>>>>>>>            If (hTable > 0) Begin
83687>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83690>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83691>>>>>>>>>                If (bFlexErrs = False) Begin
83693>>>>>>>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
83694>>>>>>>>>                    If (iIndex = -1) Begin
83696>>>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
83697>>>>>>>>>                    End
83697>>>>>>>>>>
83697>>>>>>>>>                End
83697>>>>>>>>>>
83697>>>>>>>>>            End
83697>>>>>>>>>>
83697>>>>>>>>>        Until (hTable = 0)
83699>>>>>>>>>
83699>>>>>>>>>        Function_Return iTablesArray
83700>>>>>>>>>    End_Function
83701>>>>>>>>>
83701>>>>>>>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
83703>>>>>>>>>        tAPIColumn NewAPIColumn
83703>>>>>>>>>        tAPIColumn NewAPIColumn
83703>>>>>>>>>
83703>>>>>>>>>        Move sFieldName to NewAPIColumn.sFieldName
83704>>>>>>>>>        Move iType      to NewAPIColumn.iType
83705>>>>>>>>>        Move iLength    to NewAPIColumn.iLength
83706>>>>>>>>>        Move iPrecision to NewAPIColumn.iPrecision
83707>>>>>>>>>        Move iOptions   to NewAPIColumn.iOptions
83708>>>>>>>>>
83708>>>>>>>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
83709>>>>>>>>>
83709>>>>>>>>>        Function_Return aCurrent
83710>>>>>>>>>    End_Function
83711>>>>>>>>>
83711>>>>>>>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
83713>>>>>>>>>        String sRetval sFieldName
83713>>>>>>>>>        Integer iCount iSize
83713>>>>>>>>>
83713>>>>>>>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
83714>>>>>>>>>        Decrement iSize
83715>>>>>>>>>        For iCount from 0 to iSize
83721>>>>>>>>>>
83721>>>>>>>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
83722>>>>>>>>>            Move (sRetval * (String(sFieldName))) to sRetval
83723>>>>>>>>>        Loop
83724>>>>>>>>>>
83724>>>>>>>>>        Move (Trim(sRetval)) to sRetval
83725>>>>>>>>>
83725>>>>>>>>>        Function_Return sRetval
83726>>>>>>>>>    End_Function
83727>>>>>>>>>
83727>>>>>>>>>    // *** Miscellaneous other functions ***
83727>>>>>>>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
83727>>>>>>>>>    //
83727>>>>>>>>>
83727>>>>>>>>>    // Callback functionality used when e.g. calling driver functions directly.
83727>>>>>>>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
83729>>>>>>>>>        Integer iPerc
83729>>>>>>>>>        Number nReady nTotal
83729>>>>>>>>>
83729>>>>>>>>>        Send DoAdvance of ghoProgressBar
83730>>>>>>>>>
83730>>>>>>>>>        If (sCallback_Text contains "Copy records") Begin
83732>>>>>>>>>            Move CS_DUF_CopyingData to sCallback_Text
83733>>>>>>>>>        End
83733>>>>>>>>>>
83733>>>>>>>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
83735>>>>>>>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
83736>>>>>>>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
83737>>>>>>>>>        End
83737>>>>>>>>>>
83737>>>>>>>>>        If (sCallback_Text contains "Creating index") Begin
83739>>>>>>>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
83740>>>>>>>>>        End
83740>>>>>>>>>>
83740>>>>>>>>>
83740>>>>>>>>>        Case Begin
83740>>>>>>>>>            Case (iCallback_Type = DF_Message_Text)
83742>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83743>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83744>>>>>>>>>                Case Break
83745>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_1)
83748>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83749>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83750>>>>>>>>>                Case Break
83751>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_2)
83754>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83755>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83756>>>>>>>>>                Case Break
83757>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_3)
83760>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83761>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83762>>>>>>>>>                Case Break
83763>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_4)
83766>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83767>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83768>>>>>>>>>                Case Break
83769>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_5)
83772>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83773>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83774>>>>>>>>>                Case Break
83775>>>>>>>>>            Case (iCallback_Type = DF_Message_Warning)
83778>>>>>>>>>                Send None
83779>>>>>>>>>                Case Break
83780>>>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Title)
83783>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83784>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83785>>>>>>>>>                Case Break
83786>>>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Value)
83789>>>>>>>>>                //*** Interpret numbers
83789>>>>>>>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
83790>>>>>>>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
83791>>>>>>>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
83792>>>>>>>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
83793>>>>>>>>>                Case Break
83794>>>>>>>>>            Case Else
83794>>>>>>>>>                Set Message_Text to ""
83795>>>>>>>>>                Set Action_Text  to ""
83796>>>>>>>>>        Case End
83796>>>>>>>>>
83796>>>>>>>>>        Send ProcessEvents of ghoStatusPanel
83797>>>>>>>>>        Function_Return False
83798>>>>>>>>>    End_Function
83799>>>>>>>>>
83799>>>>>>>>>    // * Dummy function for the Studio's Code Explorer *
83799>>>>>>>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
83801>>>>>>>>>        Function_Return False
83802>>>>>>>>>    End_Function
83803>>>>>>>>>
83803>>>>>>>>>    // *** Helper functions with compiled sql script code ***
83803>>>>>>>>>    //
83803>>>>>>>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
83803>>>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
83803>>>>>>>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
83803>>>>>>>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
83803>>>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
83803>>>>>>>>>    //   ALTER TABLE MyTable
83803>>>>>>>>>    //       REBUILD
83803>>>>>>>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
83805>>>>>>>>>        Boolean bOK
83805>>>>>>>>>
83805>>>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
83807>>>>>>>>>            Function_Return False
83808>>>>>>>>>        End
83808>>>>>>>>>>
83808>>>>>>>>>
83808>>>>>>>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
83808>>>>>>>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
83809>>>>>>>>>
83809>>>>>>>>>        Function_Return (bOK = True)
83810>>>>>>>>>    End_Function
83811>>>>>>>>>
83811>>>>>>>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
83811>>>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
83811>>>>>>>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
83811>>>>>>>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
83811>>>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
83811>>>>>>>>>    //   ALTER TABLE MyTable
83811>>>>>>>>>    //       REBUILD
83811>>>>>>>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
83813>>>>>>>>>        tSQLScriptArray SQLScriptArray
83813>>>>>>>>>        tSQLScriptArray SQLScriptArray
83813>>>>>>>>>        String sDriverID
83813>>>>>>>>>        Boolean bOK
83813>>>>>>>>>        Integer iSize iCount
83813>>>>>>>>>
83813>>>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
83815>>>>>>>>>            Function_Return False
83816>>>>>>>>>        End
83816>>>>>>>>>>
83816>>>>>>>>>
83816>>>>>>>>>        Get psDriverID to sDriverID
83817>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83818>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
83820>>>>>>>>>            Function_Return False
83821>>>>>>>>>        End
83821>>>>>>>>>>
83821>>>>>>>>>
83821>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83822>>>>>>>>>        Decrement iSize
83823>>>>>>>>>
83823>>>>>>>>>        For iCount from 0 to iSize
83829>>>>>>>>>>
83829>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
83831>>>>>>>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
83832>>>>>>>>>            End
83832>>>>>>>>>>
83832>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
83834>>>>>>>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
83835>>>>>>>>>            End
83835>>>>>>>>>>
83835>>>>>>>>>        Loop
83836>>>>>>>>>>
83836>>>>>>>>>
83836>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83837>>>>>>>>>
83837>>>>>>>>>        Function_Return (bOK = True)
83838>>>>>>>>>    End_Function
83839>>>>>>>>>
83839>>>>>>>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
83839>>>>>>>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
83839>>>>>>>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
83839>>>>>>>>>    Function _SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
83841>>>>>>>>>        Integer iChannel iArgumentSize iCount
83841>>>>>>>>>        Number nByteCount
83841>>>>>>>>>        String sSQLScript
83841>>>>>>>>>        tSQLScriptArray SqlScriptArray
83841>>>>>>>>>        tSQLScriptArray SqlScriptArray
83841>>>>>>>>>        UChar[] uCharData
83842>>>>>>>>>
83842>>>>>>>>>        Move False to Err
83843>>>>>>>>>        Get Seq_New_Channel to iChannel
83844>>>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83846>>>>>>>>>            Error DFERR_PROGRAM 'No channel available...'
83847>>>>>>>>>>
83847>>>>>>>>>            Move True to SqlScriptArray.bError
83848>>>>>>>>>            Function_Return SqlScriptArray
83849>>>>>>>>>        End
83849>>>>>>>>>>
83849>>>>>>>>>
83849>>>>>>>>>        // First decide the size of the script
83849>>>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83851>>>>>>>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
83853>>>>>>>>>        Close_Input channel iChannel
83855>>>>>>>>>
83855>>>>>>>>>        Move (SizeOfArray(uCharData)) to nByteCount
83856>>>>>>>>>        If (nByteCount  < 1) Begin
83858>>>>>>>>>            Send Seq_Release_Channel iChannel
83859>>>>>>>>>            Move True to SqlScriptArray.bError
83860>>>>>>>>>            Function_Return SqlScriptArray
83861>>>>>>>>>        End
83861>>>>>>>>>>
83861>>>>>>>>>
83861>>>>>>>>>        // If necessary change the string argument_size
83861>>>>>>>>>        // Read the script file from memory line-by-line
83861>>>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83863>>>>>>>>>            Move 0 to iCount
83864>>>>>>>>>            Repeat
83864>>>>>>>>>>
83864>>>>>>>>>                Readln channel iChannel sSQLScript
83866>>>>>>>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
83867>>>>>>>>>                Increment iCount
83868>>>>>>>>>            Until (SeqEof = True)
83870>>>>>>>>>        Close_Input channel iChannel
83872>>>>>>>>>        Send Seq_Release_Channel iChannel
83873>>>>>>>>>
83873>>>>>>>>>        // Finally "sanitize" the script by removing all comments.
83873>>>>>>>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
83874>>>>>>>>>
83874>>>>>>>>>        Function_Return SqlScriptArray
83875>>>>>>>>>    End_Function
83876>>>>>>>>>
83876>>>>>>>>>    Function _SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
83878>>>>>>>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
83878>>>>>>>>>        Handle hoSql hoSQLConnect hoStmt hoError
83878>>>>>>>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage iPos
83878>>>>>>>>>        String[] sMsg aSQLQueryMessages
83880>>>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd
83880>>>>>>>>>        TimeSpan tsQuery
83880>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83880>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83880>>>>>>>>>        tSQLConnection SQLConnection
83880>>>>>>>>>        tSQLConnection SQLConnection
83880>>>>>>>>>        Boolean bShowProgress
83880>>>>>>>>>
83880>>>>>>>>>        If (num_arguments > 4) Begin
83882>>>>>>>>>            Move bShowProgr to bShowProgress
83883>>>>>>>>>        End
83883>>>>>>>>>>
83883>>>>>>>>>        Get phoSQLManager to hoSql
83884>>>>>>>>>
83884>>>>>>>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
83885>>>>>>>>>        // There seems to be a problem to pass strings when their value gets really big, aka
83885>>>>>>>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
83885>>>>>>>>>        // or later SqlExecDirect stops working correctly with no error messages!
83885>>>>>>>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
83885>>>>>>>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
83885>>>>>>>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
83885>>>>>>>>>        Get piChunkMax to iChunkMax
83886>>>>>>>>>        Move 0 to iChunkCounter
83887>>>>>>>>>        Move "" to sStmt
83888>>>>>>>>>
83888>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
83889>>>>>>>>>        Move (Character(13) + Character(10)) to sCR
83890>>>>>>>>>
83890>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
83891>>>>>>>>>
83891>>>>>>>>>        Get phoSQLManager  to hoSQL
83892>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83894>>>>>>>>>            If (Uppercase(SQLConnection.sConnectionString) contains CS_SQLIniDSNKeyword) Begin
83896>>>>>>>>>                Move (Pos(";", SQLConnection.sConnectionString)) to iPos
83897>>>>>>>>>                If (iPos > 0) Begin
83899>>>>>>>>>                    Move (Left(SQLConnection.sConnectionString, (iPos - 1))) to SQLConnection.sConnectionString
83900>>>>>>>>>                    Move (Trim(SQLConnection.sConnectionString)) to SQLConnection.sConnectionString
83901>>>>>>>>>                End
83901>>>>>>>>>>
83901>>>>>>>>>            End
83901>>>>>>>>>>
83901>>>>>>>>>        End
83901>>>>>>>>>>
83901>>>>>>>>>        Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
83902>>>>>>>>>        Get SqlConnect     of hoSQL "" "" to hoSQLConnect
83903>>>>>>>>>
83903>>>>>>>>>        If (hoSQLConnect <> 0) Begin
83905>>>>>>>>>            Move False to Err
83906>>>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
83907>>>>>>>>>            If (hoStmt <> 0) Begin
83909>>>>>>>>>
83909>>>>>>>>>                // If the embedded resource should be written as a script file to disk:
83909>>>>>>>>>                If (bCreateScriptFile = True) Begin
83911>>>>>>>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
83912>>>>>>>>>                    Get vFolderFormat sExportFile to sExportFile
83913>>>>>>>>>                    Move (sExportFile + sMemFileName) to sExportFile
83914>>>>>>>>>                    Get Seq_New_Channel to iOut
83915>>>>>>>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83917>>>>>>>>>                        Direct_Output channel iOut sExportFile
83919>>>>>>>>>                    End
83919>>>>>>>>>>
83919>>>>>>>>>                End
83919>>>>>>>>>>
83919>>>>>>>>>
83919>>>>>>>>>                // Record starting date/time stamp
83919>>>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
83920>>>>>>>>>                // Turn on error handling if enabled
83920>>>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
83922>>>>>>>>>                    Set pbSqlError to False
83923>>>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
83924>>>>>>>>>                    Move Error_Object_Id to hoError
83925>>>>>>>>>                    Move Self to Error_Object_Id
83926>>>>>>>>>                End
83926>>>>>>>>>>
83926>>>>>>>>>
83926>>>>>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
83927>>>>>>>>>                Decrement iRows
83928>>>>>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
83930>>>>>>>>>                    Move (sNoCountKeyWord + sCR) to sStmt
83931>>>>>>>>>                End
83931>>>>>>>>>>
83931>>>>>>>>>
83931>>>>>>>>>                for iCount from 0 to iRows
83937>>>>>>>>>>
83937>>>>>>>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
83938>>>>>>>>>
83938>>>>>>>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
83940>>>>>>>>>                        If (sSQLVal <> "") Begin
83942>>>>>>>>>                            Move (sSQLVal + sCR) to sSQLVal
83943>>>>>>>>>                        End
83943>>>>>>>>>>
83943>>>>>>>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
83944>>>>>>>>>                    End
83944>>>>>>>>>>
83944>>>>>>>>>
83944>>>>>>>>>                    // - Each time we encounter a "GO" statement we execute it,
83944>>>>>>>>>                    // or if at the very end of the script.
83944>>>>>>>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
83946>>>>>>>>>
83946>>>>>>>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
83946>>>>>>>>>                        // instead of all in one go.
83946>>>>>>>>>                        Send SqlExecDirect of hoStmt sStmt
83947>>>>>>>>>
83947>>>>>>>>>                        If (bCreateScriptFile = True) Begin
83949>>>>>>>>>                            Write channel iOut sStmt
83951>>>>>>>>>                        End
83951>>>>>>>>>>
83951>>>>>>>>>                        Move "" to sStmt
83952>>>>>>>>>                        Move 0 to iChunkCounter
83953>>>>>>>>>                    End
83953>>>>>>>>>>
83953>>>>>>>>>                    Increment iChunkCounter
83954>>>>>>>>>                Loop
83955>>>>>>>>>>
83955>>>>>>>>>
83955>>>>>>>>>                Repeat
83955>>>>>>>>>>
83955>>>>>>>>>                    If (pbHandleQueryErrors(Self)) Begin
83957>>>>>>>>>                        Move hoError to Error_Object_Id
83958>>>>>>>>>                    End
83958>>>>>>>>>>
83958>>>>>>>>>                    Move (CurrentDateTime()) to dtQueryExecEnd
83959>>>>>>>>>
83959>>>>>>>>>                    Send _SqlColumnInfo hoStmt
83960>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
83961>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
83962>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
83963>>>>>>>>>                    Set piRows    to iRows
83964>>>>>>>>>                    Set piRowType to iRowType
83965>>>>>>>>>
83965>>>>>>>>>                    If (iMsgs <> 0) Begin
83967>>>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
83969>>>>>>>>>                            Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83970>>>>>>>>>                        End
83970>>>>>>>>>>
83970>>>>>>>>>                        for i from 1 to iMsgs
83976>>>>>>>>>>
83976>>>>>>>>>                            Get SqlGetMessage of hoStmt i to sMessage
83977>>>>>>>>>                            Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
83978>>>>>>>>>                            If (bShowProgress = True) Begin
83980>>>>>>>>>                                If (Active_State(ghoStatusPanel)) Begin
83982>>>>>>>>>                                    Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
83983>>>>>>>>>                                End
83983>>>>>>>>>>
83983>>>>>>>>>                                Else Begin
83984>>>>>>>>>                                    Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
83986>>>>>>>>>                                End
83986>>>>>>>>>>
83986>>>>>>>>>                            End
83986>>>>>>>>>>
83986>>>>>>>>>                            Move sMessage to sMsg[SizeOfArray(sMsg)]
83987>>>>>>>>>                            Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
83988>>>>>>>>>                        Loop
83989>>>>>>>>>>
83989>>>>>>>>>
83989>>>>>>>>>
83989>>>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
83991>>>>>>>>>                            Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83992>>>>>>>>>                        End
83992>>>>>>>>>>
83992>>>>>>>>>                        Set paQueryMessages to sMsg
83993>>>>>>>>>                    End
83993>>>>>>>>>>
83993>>>>>>>>>
83993>>>>>>>>>                    Get SQLNextResultSet of hoStmt to iNextSet
83994>>>>>>>>>                Until (iNextSet = 0)
83996>>>>>>>>>
83996>>>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
83997>>>>>>>>>            End
83997>>>>>>>>>>
83997>>>>>>>>>
83997>>>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
83998>>>>>>>>>            Set ptsQueryExec to tsQuery
83999>>>>>>>>>            Send SqlClose of hoStmt
84000>>>>>>>>>
84000>>>>>>>>>            If (bCreateScriptFile = True) Begin
84002>>>>>>>>>                Close_Output channel iOut
84004>>>>>>>>>                Send Seq_Release_Channel iOut
84005>>>>>>>>>            End
84005>>>>>>>>>>
84005>>>>>>>>>        End
84005>>>>>>>>>>
84005>>>>>>>>>        Send SqlDisconnect of hoSQLConnect
84006>>>>>>>>>
84006>>>>>>>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
84007>>>>>>>>>    End_Function
84008>>>>>>>>>
84008>>>>>>>>>    Function _SqlUtilCreatePostGreSQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
84010>>>>>>>>>        tSQLScriptArray SQLScriptArray
84010>>>>>>>>>        tSQLScriptArray SQLScriptArray
84010>>>>>>>>>        String sDriverID sCollation
84010>>>>>>>>>        Boolean bOK
84010>>>>>>>>>        Integer iSize iCount
84010>>>>>>>>>
84010>>>>>>>>>        If (Trim(sDatabaseName) = "") Begin
84012>>>>>>>>>            Function_Return False
84013>>>>>>>>>        End
84013>>>>>>>>>>
84013>>>>>>>>>
84013>>>>>>>>>        Get psDriverID  to sDriverID
84014>>>>>>>>>        Get psCollation to sCollation
84015>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
84016>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
84018>>>>>>>>>            Function_Return False
84019>>>>>>>>>        End
84019>>>>>>>>>>
84019>>>>>>>>>
84019>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
84020>>>>>>>>>        Decrement iSize
84021>>>>>>>>>
84021>>>>>>>>>        For iCount from 0 to iSize
84027>>>>>>>>>>
84027>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
84029>>>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
84030>>>>>>>>>            End
84030>>>>>>>>>>
84030>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
84032>>>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
84033>>>>>>>>>            End
84033>>>>>>>>>>
84033>>>>>>>>>        Loop
84034>>>>>>>>>>
84034>>>>>>>>>
84034>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
84035>>>>>>>>>
84035>>>>>>>>>        Function_Return (bOK = True)
84036>>>>>>>>>    End_Function
84037>>>>>>>>>
84037>>>>>>>>>    Function _SqlUtilCreateMySQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
84039>>>>>>>>>        tSQLScriptArray SQLScriptArray
84039>>>>>>>>>        tSQLScriptArray SQLScriptArray
84039>>>>>>>>>        String sDriverID sCollation
84039>>>>>>>>>        Boolean bOK
84039>>>>>>>>>        Integer iSize iCount
84039>>>>>>>>>
84039>>>>>>>>>        If (Trim(sDatabaseName) = "") Begin
84041>>>>>>>>>            Function_Return False
84042>>>>>>>>>        End
84042>>>>>>>>>>
84042>>>>>>>>>
84042>>>>>>>>>        Get psDriverID  to sDriverID
84043>>>>>>>>>        Get psCollation to sCollation
84044>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
84045>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
84047>>>>>>>>>            Function_Return False
84048>>>>>>>>>        End
84048>>>>>>>>>>
84048>>>>>>>>>
84048>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
84049>>>>>>>>>        Decrement iSize
84050>>>>>>>>>
84050>>>>>>>>>        For iCount from 0 to iSize
84056>>>>>>>>>>
84056>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
84058>>>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
84059>>>>>>>>>            End
84059>>>>>>>>>>
84059>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
84061>>>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
84062>>>>>>>>>            End
84062>>>>>>>>>>
84062>>>>>>>>>        Loop
84063>>>>>>>>>>
84063>>>>>>>>>        // ToDo: THIS FAILS BUT THE SQL SCRIPT WORKS IN MYSQL!
84063>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
84064>>>>>>>>>
84064>>>>>>>>>        Function_Return (bOK = True)
84065>>>>>>>>>    End_Function
84066>>>>>>>>>
84066>>>>>>>>>    Function _StrToFieldNumber Integer iFile String sField Returns Integer
84068>>>>>>>>>        Integer iMax iPos
84068>>>>>>>>>        String sName
84068>>>>>>>>>
84068>>>>>>>>>        Move (Lowercase(sField)) to sField
84069>>>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
84072>>>>>>>>>        For iPos from 0 to iMax
84078>>>>>>>>>>
84078>>>>>>>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
84081>>>>>>>>>            Move (Lowercase(sName)) to sName
84082>>>>>>>>>            If (sName = sField) Begin
84084>>>>>>>>>                Function_Return iPos
84085>>>>>>>>>            End
84085>>>>>>>>>>
84085>>>>>>>>>        Loop
84086>>>>>>>>>>
84086>>>>>>>>>        Function_Return -1
84087>>>>>>>>>    End_Function
84088>>>>>>>>>
84088>>>>>>>>>    // Checks if the passed connection id exists in the CLI interface.
84088>>>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
84088>>>>>>>>>    // the connection id hasn't been established with the driver's CLI interface.
84088>>>>>>>>>    // NOTE: Only applicable for DAW drivers.
84088>>>>>>>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
84090>>>>>>>>>        String sID sConnString
84090>>>>>>>>>        Integer iDriver iNumConn iCount
84090>>>>>>>>>        Handle hoCLI
84090>>>>>>>>>        Boolean bOK
84090>>>>>>>>>
84090>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
84091>>>>>>>>>        If (bOK = False) Begin
84093>>>>>>>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers."
84094>>>>>>>>>>
84094>>>>>>>>>            Function_Return False
84095>>>>>>>>>        End
84095>>>>>>>>>>
84095>>>>>>>>>
84095>>>>>>>>>        Move False to bOK
84096>>>>>>>>>        Get phoCLIHandler to hoCLI
84097>>>>>>>>>        If (hoCLI <> 0) Begin
84099>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
84100>>>>>>>>>            Get DriverIndex of hoCLI sDriverID to iDriver
84101>>>>>>>>>
84101>>>>>>>>>            // If driver not loaded; load it.
84101>>>>>>>>>            If (iDriver = 0) Begin
84103>>>>>>>>>                Load_Driver sDriverID
84104>>>>>>>>>                Get DriverIndex sDriverID to iDriver
84105>>>>>>>>>            End
84105>>>>>>>>>>
84105>>>>>>>>>            If (iDriver <> 0) Begin
84107>>>>>>>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
84110>>>>>>>>>                Decrement iNumConn
84111>>>>>>>>>                For iCount from 0 to iNumConn
84117>>>>>>>>>>
84117>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
84120>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
84123>>>>>>>>>                    If (sID = sConnectionID) Begin
84125>>>>>>>>>                        Move True to bOK
84126>>>>>>>>>                    End
84126>>>>>>>>>>
84126>>>>>>>>>                Loop
84127>>>>>>>>>>
84127>>>>>>>>>            End
84127>>>>>>>>>>
84127>>>>>>>>>        End
84127>>>>>>>>>>
84127>>>>>>>>>
84127>>>>>>>>>        Function_Return bOK
84128>>>>>>>>>    End_Function
84129>>>>>>>>>
84129>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
84131>>>>>>>>>        Boolean bOK
84131>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
84132>>>>>>>>>        Function_Return bOK
84133>>>>>>>>>    End_Function
84134>>>>>>>>>
84134>>>>>>>>>    Function IsMSSQLDriver Returns Boolean
84136>>>>>>>>>        Integer iDriverIndex
84136>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
84137>>>>>>>>>        Function_Return (iDriverIndex <> 0)
84138>>>>>>>>>    End_Function
84139>>>>>>>>>
84139>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
84139>>>>>>>>>    // attempt to load the driver.
84139>>>>>>>>>    // Returns true if the passed driver is SQL based.
84139>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
84141>>>>>>>>>        Boolean bOK
84141>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
84142>>>>>>>>>        Function_Return bOK
84143>>>>>>>>>    End_Function
84144>>>>>>>>>
84144>>>>>>>>>    // *** Error Handler ***
84144>>>>>>>>>    //
84144>>>>>>>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
84144>>>>>>>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
84144>>>>>>>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
84146>>>>>>>>>        Integer iSize iErrorMode
84146>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84146>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84146>>>>>>>>>
84146>>>>>>>>>        If (pbProcessingError(Self)) Begin
84148>>>>>>>>>            Procedure_Return
84149>>>>>>>>>        End
84149>>>>>>>>>>
84149>>>>>>>>>
84149>>>>>>>>>        Get Error_Report_Mode to iErrorMode
84150>>>>>>>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
84152>>>>>>>>>            Set Private.pbProcessingError to False
84153>>>>>>>>>            Procedure_Return
84154>>>>>>>>>        End
84154>>>>>>>>>>
84154>>>>>>>>>
84154>>>>>>>>>        Set pbProcessingError to True
84155>>>>>>>>>        Set pbSqlError to True
84156>>>>>>>>>        Get paSqlErrorArray      to aSqlErrorArray
84157>>>>>>>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
84158>>>>>>>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
84159>>>>>>>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
84160>>>>>>>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
84161>>>>>>>>>        Set paSqlErrorArray      to aSqlErrorArray
84162>>>>>>>>>        Set pbProcessingError to False
84163>>>>>>>>>    End_Procedure
84164>>>>>>>>>
84164>>>>>>>>>    // *** Miscellanous Helper Functions ***
84164>>>>>>>>>    //
84164>>>>>>>>>    // Helper function. Takes a DF_FILE_ROOT_NAME value as parameter and
84164>>>>>>>>>    // returns the table name only; stripped of any prefix, path or filename extension.
84164>>>>>>>>>    Function _TableNameOnly String sTableName Returns String
84166>>>>>>>>>        Integer iPos
84166>>>>>>>>>        Move (Pos(":", sTableName)) to iPos
84167>>>>>>>>>        If (iPos <> 0) Begin
84169>>>>>>>>>            Move (Mid(sTableName, Length(sTableName), (iPos +1))) to sTableName
84170>>>>>>>>>        End  
84170>>>>>>>>>>
84170>>>>>>>>>        Move (Pos(".int", Lowercase(sTableName))) to iPos
84171>>>>>>>>>        If (iPos <> 0) Begin
84173>>>>>>>>>            Move (Left(sTableName, (iPos -1))) to sTableName
84174>>>>>>>>>        End  
84174>>>>>>>>>>
84174>>>>>>>>>        Function_Return sTableName
84175>>>>>>>>>    End_Function
84176>>>>>>>>>
84176>>>>>>>>>    // Removes any prefix from a table name.
84176>>>>>>>>>    // Example mssqldrv:mytable returns mytable
84176>>>>>>>>>    //         dbo.mytable returns mytable
84176>>>>>>>>>    Function _TableNoPrefix String sName Returns String
84178>>>>>>>>>        Integer iPos
84178>>>>>>>>>        Move (Pos(":", sName)) to iPos
84179>>>>>>>>>        If (iPos <> 0) Begin
84181>>>>>>>>>            Move (Mid(sName, Length(sName), (iPos + 1))) to sName
84182>>>>>>>>>        End
84182>>>>>>>>>>
84182>>>>>>>>>        Move (Pos(".", sName)) to iPos
84183>>>>>>>>>        If (iPos <> 0) Begin
84185>>>>>>>>>            Move (Mid(sName, Length(sName), (iPos + 1))) to sName
84186>>>>>>>>>        End
84186>>>>>>>>>>
84186>>>>>>>>>        Function_Return sName
84187>>>>>>>>>    End_Function
84188>>>>>>>>>    
84188>>>>>>>>>    Function _DriverIDFromRootName String sRootName Returns String
84190>>>>>>>>>        String sDriverID
84190>>>>>>>>>        Integer iPos
84190>>>>>>>>>        Move DATAFLEX_ID to sDriverID
84191>>>>>>>>>        Move (Pos(":", sRootName)) to iPos
84192>>>>>>>>>        If (iPos <> 0) Begin
84194>>>>>>>>>            Move (Left(sRootName, (iPos -1))) to sDriverID
84195>>>>>>>>>        End
84195>>>>>>>>>>
84195>>>>>>>>>        Function_Return sDriverID
84196>>>>>>>>>    End_Function
84197>>>>>>>>>    // Does the Rootname points to a .dat file?
84197>>>>>>>>>    Function _IsDatEntry Handle hTable Returns Boolean
84199>>>>>>>>>        Boolean bFound bIsIntEntry
84199>>>>>>>>>        String sRootName sNoDriverRootname sDriver
84199>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84202>>>>>>>>>        Get _DriverIDFromRootName sRootName to sDriver
84203>>>>>>>>>        Get _TableNameOnly sRootName to sNoDriverRootname
84204>>>>>>>>>        Get _IsIntEntry hTable to bIsIntEntry
84205>>>>>>>>>        Move (bIsIntEntry = False and sDriver = DATAFLEX_ID) to bFound
84206>>>>>>>>>        Function_Return bFound
84207>>>>>>>>>    End_Function
84208>>>>>>>>>
84208>>>>>>>>>    // Checks that the RootName points to a .dat file and that the .dat file exists on disk.
84208>>>>>>>>>    Function _DatFileExists Handle hTable Returns Boolean
84210>>>>>>>>>        Boolean bExists
84210>>>>>>>>>        String sDataPath sRootName sNoDriverRootname
84210>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84213>>>>>>>>>        Get _TableNameOnly sRootName to sNoDriverRootname
84214>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84215>>>>>>>>>        File_Exist (sDataPath + "\" + sNoDriverRootname + ".dat") bExists
84216>>>>>>>>>        Function_Return bExists
84217>>>>>>>>>    End_Function
84218>>>>>>>>>    
84218>>>>>>>>>    // Does the Rootname contain a ".int" suffix.
84218>>>>>>>>>    Function _IsIntEntry Handle hTable Returns Boolean
84220>>>>>>>>>        Boolean bFound
84220>>>>>>>>>        String sRootName
84220>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84223>>>>>>>>>        Move (Lowercase(sRootName) contains ".int") to bFound
84224>>>>>>>>>        Function_Return bFound
84225>>>>>>>>>    End_Function
84226>>>>>>>>>
84226>>>>>>>>>    // Checks to see if the .int file actually exists in the Data folder.
84226>>>>>>>>>    Function _IntFileExists Handle hTable Returns Boolean
84228>>>>>>>>>        Boolean bExists bIsIntFile
84228>>>>>>>>>        String sDataPath sIntFileName
84228>>>>>>>>>        Integer iPos
84228>>>>>>>>>        
84228>>>>>>>>>        Move False to bExists
84229>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84230>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName
84233>>>>>>>>>        Get _TableNameOnly sIntFileName to sIntFileName
84234>>>>>>>>>        Move (Pos(".int", Lowercase(sIntFileName))) to iPos
84235>>>>>>>>>        If (iPos = 0) Begin
84237>>>>>>>>>            Move (sIntFileName + ".int") to sIntFileName
84238>>>>>>>>>        End
84238>>>>>>>>>>
84238>>>>>>>>>        File_Exist (sDataPath + "\" + sIntFileName) bExists
84239>>>>>>>>>        Function_Return bExists    
84240>>>>>>>>>    End_Function
84241>>>>>>>>>        
84241>>>>>>>>>    // Returns True if the hTable's RootName has a driver <> DataFlex
84241>>>>>>>>>    Function _IsSQLEntry Handle hTable Returns Boolean
84243>>>>>>>>>        Boolean bFound bIsIntFile
84243>>>>>>>>>        String sLogicalName sRootName sNoDriverRootname sDriver
84243>>>>>>>>>        
84243>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84246>>>>>>>>>        Get _DriverIDFromRootName sRootName to sDriver
84247>>>>>>>>>        Get _IsIntEntry hTable to bIsIntFile
84248>>>>>>>>>        Get _TableNameOnly sRootName to sNoDriverRootname
84249>>>>>>>>>        Move (bIsIntFile = True or sDriver <> DATAFLEX_ID) to bFound
84250>>>>>>>>>        Function_Return bFound
84251>>>>>>>>>    End_Function
84252>>>>>>>>>
84252>>>>>>>>>    // This is used in place of the DF_FILE_OPENED table attribute, because
84252>>>>>>>>>    // the table then needs to be open, which takes time.
84252>>>>>>>>>    Function _IsAliasTable Handle hTable Returns Boolean
84254>>>>>>>>>        Boolean bFound bIsIntTable
84254>>>>>>>>>        String sLogicalName sRootName sNoDriverRootname
84254>>>>>>>>>        
84254>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
84257>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84260>>>>>>>>>        Get _TableNameOnly sRootName to sNoDriverRootname
84261>>>>>>>>>        Get _IsIntEntry hTable to bIsIntTable
84262>>>>>>>>>        // Do we have an Alias table?
84262>>>>>>>>>        Move (Lowercase(sLogicalName) <> Lowercase(sNoDriverRootname)) to bFound
84263>>>>>>>>>        Function_Return bFound
84264>>>>>>>>>    End_Function
84265>>>>>>>>>
84265>>>>>>>>>    // If the SQL table cannot be opened, we do this checking a bit different.
84265>>>>>>>>>    Function _IsSystemFile Handle hTable Returns Boolean
84267>>>>>>>>>        Boolean bIsSystem bIsSQL bExists
84267>>>>>>>>>        String sRootName sDataPath sDriver
84267>>>>>>>>>        String[] asIndexes
84268>>>>>>>>>        Move False to bIsSystem
84269>>>>>>>>>        
84269>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84272>>>>>>>>>        Get _DriverIDFromRootName sRootName to sDriver
84273>>>>>>>>>        Get _TableNameOnly sRootName to sRootName
84274>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84275>>>>>>>>>        Get _IsSQLEntry hTable to bIsSQL
84276>>>>>>>>>        If (bIsSQL = False) Begin
84278>>>>>>>>>            File_Exist (sDataPath + "\" + sRootName + ".dat") bExists
84279>>>>>>>>>            If (bExists = True) Begin
84281>>>>>>>>>                Open (sDataPath + "\" + sRootName + ".dat") as hTable
84283>>>>>>>>>                Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bIsSystem 
84286>>>>>>>>>                Close hTable
84287>>>>>>>>>            End
84287>>>>>>>>>>
84287>>>>>>>>>        End 
84287>>>>>>>>>>
84287>>>>>>>>>        Else Begin
84288>>>>>>>>>            Get _SqlUtilEnumerateIndexes sRootName sDriver to asIndexes
84289>>>>>>>>>            Move (SizeOfArray(asIndexes) = 0) to bIsSystem
84290>>>>>>>>>        End
84290>>>>>>>>>>
84290>>>>>>>>>        Function_Return bIsSystem
84291>>>>>>>>>    End_Function
84292>>>>>>>>>                          
84292>>>>>>>>>    // Removes any driver prefix and any .int suffix from the Rootname
84292>>>>>>>>>    // If any driver found, it will be placed in the ByRef param: sDriver.
84292>>>>>>>>>    Function _RemoveDriverFromRootName String sRootname String ByRef sDriver Returns String
84294>>>>>>>>>        String sNoDriverRootname
84294>>>>>>>>>        Integer iPos
84294>>>>>>>>>        
84294>>>>>>>>>        Move sRootname to sNoDriverRootname
84295>>>>>>>>>        Move (Pos(":", sRootname)) to iPos
84296>>>>>>>>>        If (iPos <> 0) Begin
84298>>>>>>>>>            Move (Left(sRootname, iPos -1)) to sDriver
84299>>>>>>>>>            Move (Mid(sRootname, Length(sRootname), iPos +1)) to sNoDriverRootname    
84300>>>>>>>>>        End
84300>>>>>>>>>>
84300>>>>>>>>>        Else Begin
84301>>>>>>>>>            Move DATAFLEX_ID to sDriver
84302>>>>>>>>>        End
84302>>>>>>>>>>
84302>>>>>>>>>        Move (Pos(".int", Lowercase(sNoDriverRootname))) to iPos
84303>>>>>>>>>        If (iPos <> 0) Begin
84305>>>>>>>>>            Move (Left(sNoDriverRootname, iPos -1)) to sNoDriverRootname
84306>>>>>>>>>        End
84306>>>>>>>>>>
84306>>>>>>>>>        Function_Return sNoDriverRootname    
84307>>>>>>>>>    End_Function
84308>>>>>>>>>
84308>>>>>>>>>    Function _CountFilelistSystemTables Returns Integer
84310>>>>>>>>>        tFilelist[] FileListTables
84310>>>>>>>>>        tFilelist[] FileListTables
84311>>>>>>>>>        Integer iCount iSize iItems
84311>>>>>>>>>        
84311>>>>>>>>>        Move 0 to iItems
84312>>>>>>>>>        Get pFileListArray to FileListTables
84313>>>>>>>>>        Move (SizeOfArray(FileListTables)) to iSize
84314>>>>>>>>>        If (iSize <> 0) Begin
84316>>>>>>>>>            Decrement iSize
84317>>>>>>>>>            for iCount from 0 to iSize
84323>>>>>>>>>>
84323>>>>>>>>>                If (FileListTables[iCount].bIsSystemFile = True) Begin
84325>>>>>>>>>                    Increment iItems
84326>>>>>>>>>                End
84326>>>>>>>>>>
84326>>>>>>>>>            Loop
84327>>>>>>>>>>
84327>>>>>>>>>        End
84327>>>>>>>>>>
84327>>>>>>>>>        Function_Return iItems    
84328>>>>>>>>>    End_Function
84329>>>>>>>>>
84329>>>>>>>>>    Function _CountFileListAliasTables Returns Integer
84331>>>>>>>>>        tFilelist[] FileListTables
84331>>>>>>>>>        tFilelist[] FileListTables
84332>>>>>>>>>        Integer iCount iSize iItems
84332>>>>>>>>>        
84332>>>>>>>>>        Move 0 to iItems
84333>>>>>>>>>        Get pFileListArray to FileListTables
84334>>>>>>>>>        Move (SizeOfArray(FileListTables)) to iSize
84335>>>>>>>>>        If (iSize <> 0) Begin
84337>>>>>>>>>            Decrement iSize
84338>>>>>>>>>            for iCount from 0 to iSize
84344>>>>>>>>>>
84344>>>>>>>>>                If (FileListTables[iCount].bIsAlias = True) Begin
84346>>>>>>>>>                    Increment iItems
84347>>>>>>>>>                End
84347>>>>>>>>>>
84347>>>>>>>>>            Loop
84348>>>>>>>>>>
84348>>>>>>>>>        End
84348>>>>>>>>>>
84348>>>>>>>>>        Function_Return iItems    
84349>>>>>>>>>    End_Function
84350>>>>>>>>>
84350>>>>>>>>>    Function _CountFileListMasterTables Returns Integer
84352>>>>>>>>>        String sRootName sLogicalName sDriver sNoDriverRootname
84352>>>>>>>>>        Handle hTable
84352>>>>>>>>>        Integer iSize iItems
84352>>>>>>>>>        Boolean bIsAlias bIsIntTable
84352>>>>>>>>>        
84352>>>>>>>>>        Move 0 to iItems
84353>>>>>>>>>        Move 0 to hTable 
84354>>>>>>>>>        Repeat
84354>>>>>>>>>>
84354>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
84357>>>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin
84359>>>>>>>>>                Get _IsAliasTable hTable to bIsAlias
84360>>>>>>>>>                If (bIsAlias = False) Begin
84362>>>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84365>>>>>>>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName                    
84368>>>>>>>>>                    Get _RemoveDriverFromRootName sRootName (&sDriver) to sNoDriverRootname
84369>>>>>>>>>                    Get _IsIntEntry hTable to bIsIntTable
84370>>>>>>>>>                    If (sDriver <> DATAFLEX_ID and Lowercase(sNoDriverRootname) = Lowercase(sLogicalName)) Begin
84372>>>>>>>>>                        Increment iItems
84373>>>>>>>>>                    End
84373>>>>>>>>>>
84373>>>>>>>>>                End
84373>>>>>>>>>>
84373>>>>>>>>>            End
84373>>>>>>>>>>
84373>>>>>>>>>        Until (hTable = 0)
84375>>>>>>>>>        
84375>>>>>>>>>        Function_Return iItems
84376>>>>>>>>>    End_Function
84377>>>>>>>>>
84377>>>>>>>>>    Function _CountFileListOpenErrors Returns Integer
84379>>>>>>>>>        tFilelist[] FileListTables
84379>>>>>>>>>        tFilelist[] FileListTables
84380>>>>>>>>>        Integer iCount iSize iItems
84380>>>>>>>>>        
84380>>>>>>>>>        Move 0 to iItems
84381>>>>>>>>>        Get pFileListArray to FileListTables
84382>>>>>>>>>        Move (SizeOfArray(FileListTables)) to iSize
84383>>>>>>>>>        If (iSize <> 0) Begin
84385>>>>>>>>>            Decrement iSize
84386>>>>>>>>>            for iCount from 0 to iSize
84392>>>>>>>>>>
84392>>>>>>>>>                If (FileListTables[iCount].bErrorOpening = True) Begin
84394>>>>>>>>>                    Increment iItems
84395>>>>>>>>>                End
84395>>>>>>>>>>
84395>>>>>>>>>            Loop
84396>>>>>>>>>>
84396>>>>>>>>>        End
84396>>>>>>>>>>
84396>>>>>>>>>        Function_Return iItems    
84397>>>>>>>>>    End_Function 
84398>>>>>>>>>
84398>>>>>>>>>    // Checks all Alias Filelist entries for errors,
84398>>>>>>>>>    // and return them as a string array of RootNames.
84398>>>>>>>>>    Function _CountFileListAliasErrors Returns tFilelist[]
84400>>>>>>>>>        Integer iCount iItem
84400>>>>>>>>>        Handle hTable
84400>>>>>>>>>        Boolean bIsAlias bOK
84400>>>>>>>>>        String sRootName
84400>>>>>>>>>        tFilelist[] FileListArray
84400>>>>>>>>>        tFilelist[] FileListArray
84401>>>>>>>>>        
84401>>>>>>>>>        Move 0 to iCount
84402>>>>>>>>>        Move 0 to hTable
84403>>>>>>>>>        Repeat
84403>>>>>>>>>>
84403>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
84406>>>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin
84408>>>>>>>>>                Get _IsAliasTable hTable to bIsAlias
84409>>>>>>>>>                If (bIsAlias = True) Begin
84411>>>>>>>>>                    Get _FindAliasEntryError hTable to iItem
84412>>>>>>>>>                    If (iItem <> 0) Begin
84414>>>>>>>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84417>>>>>>>>>                        Move hTable    to FileListArray[iCount].hTable
84418>>>>>>>>>                        Move sRootName to FileListArray[iCount].sRootName
84419>>>>>>>>>                    End
84419>>>>>>>>>>
84419>>>>>>>>>                    Add iItem to iCount
84420>>>>>>>>>                End
84420>>>>>>>>>>
84420>>>>>>>>>            End
84420>>>>>>>>>>
84420>>>>>>>>>        Until (hTable = 0)
84422>>>>>>>>>        
84422>>>>>>>>>        Function_Return FileListArray
84423>>>>>>>>>    End_Function
84424>>>>>>>>>
84424>>>>>>>>>    // Helper function for _CountFileListAliasErrors.
84424>>>>>>>>>    // Checks to see if an Alias Filelist entry is correct
84424>>>>>>>>>    // What it does:
84424>>>>>>>>>    //  1. Checks that the Filelist entry is an Alias table
84424>>>>>>>>>    //  2. If an Alias, checks if the RootName points to a valid Table
84424>>>>>>>>>    Function _FindAliasEntryError Handle hTable Returns Integer
84426>>>>>>>>>        Handle hMasterTable
84426>>>>>>>>>        String sDataPath sDriver sLogicalNameAlias sRootNameAlias sNoDriverRootnameAlias sLogicalNameMaster sRootNameMaster sNoDriverRootnameMaster
84426>>>>>>>>>        Boolean bOK bFound bIsAlias bIsAliasSQL bIsMasterSQL bIsIntFile
84426>>>>>>>>>        Integer iRetval
84426>>>>>>>>>        
84426>>>>>>>>>        Get _IsAliasTable hTable to bIsAlias
84427>>>>>>>>>        If (bIsAlias = False) Begin
84429>>>>>>>>>            Function_Return 0
84430>>>>>>>>>        End
84430>>>>>>>>>>
84430>>>>>>>>>        
84430>>>>>>>>>        Move 0 to iRetval
84431>>>>>>>>>        Move False to bOK
84432>>>>>>>>>        Move False to bIsAliasSQL
84433>>>>>>>>>        Move False to bIsMasterSQL
84434>>>>>>>>>
84434>>>>>>>>>        Get _IsIntEntry hTable to bIsIntFile
84435>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootNameAlias
84438>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameAlias
84441>>>>>>>>>        Get _TableNameOnly sRootNameAlias to sNoDriverRootnameAlias
84442>>>>>>>>>        Get UtilAliasToMasterTableHandle hTable to hMasterTable
84443>>>>>>>>>        Move (hMasterTable <> 0) to bOK
84444>>>>>>>>>        If (bOK = True) Begin
84446>>>>>>>>>            Get _IsSQLEntry hTable       to bIsAliasSQL
84447>>>>>>>>>            Get _IsSQLEntry hMasterTable to bIsMasterSQL 
84448>>>>>>>>>            Move (bIsAliasSQL = bIsMasterSQL) to bOK
84449>>>>>>>>>        End
84449>>>>>>>>>>
84449>>>>>>>>>        
84449>>>>>>>>>        // Checks that the .int file exists in the Data folder
84449>>>>>>>>>        If (bIsIntFile = True) Begin
84451>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84452>>>>>>>>>            File_Exist (sDataPath + "\" + sNoDriverRootnameAlias) bOK
84453>>>>>>>>>        End
84453>>>>>>>>>>
84453>>>>>>>>>
84453>>>>>>>>>        If (bOK = False) Begin
84455>>>>>>>>>            Move 1 to iRetval
84456>>>>>>>>>        End
84456>>>>>>>>>>
84456>>>>>>>>>        Function_Return iRetval
84457>>>>>>>>>    End_Function
84458>>>>>>>>>        
84458>>>>>>>>>    // Returns the first datapath found in the psDataPath property.
84458>>>>>>>>>    // The returned path always ends with a "\"
84458>>>>>>>>>    Function psDataPathFirstPart Returns String
84460>>>>>>>>>        String sDataPath
84460>>>>>>>>>        Integer iCount
84460>>>>>>>>>
84460>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84461>>>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
84462>>>>>>>>>        If (iCount > 1) Begin
84464>>>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
84465>>>>>>>>>        End
84465>>>>>>>>>>
84465>>>>>>>>>        If (sDataPath <> "") Begin
84467>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
84468>>>>>>>>>        End
84468>>>>>>>>>>
84468>>>>>>>>>
84468>>>>>>>>>        Function_Return sDataPath
84469>>>>>>>>>    End_Function
84470>>>>>>>>>
84470>>>>>>>>>    Function psLogTextFileWithPath Returns String
84472>>>>>>>>>        String sFileName
84472>>>>>>>>>        Handle hoLogFile
84472>>>>>>>>>        Get phoLogFile to hoLogFile
84473>>>>>>>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
84474>>>>>>>>>        Function_Return sFileName
84475>>>>>>>>>    End_Function
84476>>>>>>>>>
84476>>>>>>>>>    Function phoLogFile Returns Handle
84478>>>>>>>>>        Handle hoLogFile   
84478>>>>>>>>>        Boolean bErr
84478>>>>>>>>>        
84478>>>>>>>>>        Move Err to bErr
84479>>>>>>>>>        Move 0 to hoLogFile
84480>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
84481>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
84482>>>>>>>>>        Delegate Get phoLogFile to hoLogFile
84484>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
84485>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84486>>>>>>>>>        Move bErr to Err
84487>>>>>>>>>        
84487>>>>>>>>>        Function_Return hoLogFile
84488>>>>>>>>>    End_Function
84489>>>>>>>>>
84489>>>>>>>>>    Function pnCurrentVersionUpdate Returns Number
84491>>>>>>>>>        Number nCurrentVersionUpdate
84491>>>>>>>>>
84491>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84492>>>>>>>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
84494>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84495>>>>>>>>>
84495>>>>>>>>>        Function_Return nCurrentVersionUpdate
84496>>>>>>>>>    End_Function
84497>>>>>>>>>
84497>>>>>>>>>    Procedure LogError String sText Boolean bError
84499>>>>>>>>>        Handle hoLogFile
84499>>>>>>>>>        Number nCurrentVersionUpdate
84499>>>>>>>>>
84499>>>>>>>>>        Get phoLogFile to hoLogFile
84500>>>>>>>>>        If (hoLogFile = 0) Begin
84502>>>>>>>>>            Procedure_Return
84503>>>>>>>>>        End
84503>>>>>>>>>>
84503>>>>>>>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
84504>>>>>>>>>
84504>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84505>>>>>>>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
84506>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84507>>>>>>>>>    End_Procedure
84508>>>>>>>>>
84508>>>>>>>>>    Function pbContinueOnError Returns Boolean
84510>>>>>>>>>        Boolean bContinueOnError
84510>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
84512>>>>>>>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
84513>>>>>>>>>        End
84513>>>>>>>>>>
84513>>>>>>>>>        Function_Return bContinueOnError
84514>>>>>>>>>    End_Function
84515>>>>>>>>>
84515>>>>>>>>>
84515>>>>>>>>>    Function _UtilUpdateTAGFile String sFullTAGFileName String sColumnName Returns Boolean
84517>>>>>>>>>        Integer iChIn iChOut // iCount
84517>>>>>>>>>        Boolean bExists
84517>>>>>>>>>        String sExistingColumn
84517>>>>>>>>>
84517>>>>>>>>>        Move False to bExists
84518>>>>>>>>>        Get Seq_New_Channel to iChIn
84519>>>>>>>>>        Get Seq_New_Channel to iChOut
84520>>>>>>>>>        If (iChIn = DF_SEQ_CHANNEL_NOT_AVAILABLE or iChOut = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
84522>>>>>>>>>            Function_Return True
84523>>>>>>>>>        End
84523>>>>>>>>>>
84523>>>>>>>>>
84523>>>>>>>>>        Move False to Err
84524>>>>>>>>>        // The following line should also use the channel attribute. (Thank you, Hans van de Laar)
84524>>>>>>>>>        Direct_Input channel iChIn ("'" + sFullTAGFileName + "'")
84526>>>>>>>>>        While (not(SeqEof))
84530>>>>>>>>>            Readln channel iChIn sExistingColumn
84532>>>>>>>>>            If (Uppercase(sExistingColumn) = Uppercase(sColumnName)) Begin
84534>>>>>>>>>                Move True to bExists
84535>>>>>>>>>            End
84535>>>>>>>>>>
84535>>>>>>>>>            If (Trim(sExistingColumn) = "") Begin
84537>>>>>>>>>                Move True to SeqEof
84538>>>>>>>>>            End
84538>>>>>>>>>>
84538>>>>>>>>>        Loop
84539>>>>>>>>>>
84539>>>>>>>>>        Close_Input channel iChIn
84541>>>>>>>>>        Send Seq_Release_Channel iChIn
84542>>>>>>>>>
84542>>>>>>>>>        If (bExists = False) Begin
84544>>>>>>>>>            Append_Output channel iChOut sFullTAGFileName
84546>>>>>>>>>            Writeln channel iChOut sColumnName
84549>>>>>>>>>            Close_Output channel iChOut
84551>>>>>>>>>            Send Seq_Release_Channel iChOut
84552>>>>>>>>>        End
84552>>>>>>>>>>
84552>>>>>>>>>
84552>>>>>>>>>        Function_Return (Err = False)
84553>>>>>>>>>    End_Function
84554>>>>>>>>>
84554>>>>>>>>>    // Changes source code files.
84554>>>>>>>>>    // Pass a file name with full path and a value to search for, together with the value
84554>>>>>>>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
84554>>>>>>>>>    // to use a Connection ID.
84554>>>>>>>>>    // Sample: Get _UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
84554>>>>>>>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
84554>>>>>>>>>    // Returns True if no errors occured.
84554>>>>>>>>>    Function _UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
84556>>>>>>>>>        Integer iCh iRow iItems iCount
84556>>>>>>>>>        String sValue sRow
84556>>>>>>>>>        String[] sFileArray
84557>>>>>>>>>        Boolean bExists bIsActive bFileChange
84557>>>>>>>>>
84557>>>>>>>>>        Move False to Err
84558>>>>>>>>>        Move 0 to iRow
84559>>>>>>>>>        Move False to bFileChange
84560>>>>>>>>>
84560>>>>>>>>>        If (ghoStatusPanel <> 0) Begin
84562>>>>>>>>>            Get Active_state of ghoStatusPanel to bIsActive
84563>>>>>>>>>        End
84563>>>>>>>>>>
84563>>>>>>>>>
84563>>>>>>>>>        Get vFilePathExists sFileName to bExists
84564>>>>>>>>>        If (bExists = False) Begin
84566>>>>>>>>>            If (bShowResult = True) Begin
84568>>>>>>>>>                If (bIsActive = True) Begin
84570>>>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
84571>>>>>>>>>                End
84571>>>>>>>>>>
84571>>>>>>>>>                Else Begin
84572>>>>>>>>>                    Showln "File does not exist: " sFileName
84575>>>>>>>>>                End
84575>>>>>>>>>>
84575>>>>>>>>>            End
84575>>>>>>>>>>
84575>>>>>>>>>            Function_Return False
84576>>>>>>>>>        End
84576>>>>>>>>>>
84576>>>>>>>>>
84576>>>>>>>>>        Get Seq_Open_Input_Channel sFileName to iCh
84577>>>>>>>>>        If (iCh < 1) Begin
84579>>>>>>>>>            Function_Return False
84580>>>>>>>>>        End
84580>>>>>>>>>>
84580>>>>>>>>>
84580>>>>>>>>>        If (bShowResult = True) Begin
84582>>>>>>>>>            If (ghoStatusPanel <> 0) Begin
84584>>>>>>>>>                Get Active_state of ghoStatusPanel to bIsActive
84585>>>>>>>>>                If (bIsActive = True) Begin
84587>>>>>>>>>                    Set Message_Text of ghoStatusPanel to sFileName
84588>>>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
84589>>>>>>>>>                    Send DoAdvance of ghoProgressBar
84590>>>>>>>>>                End
84590>>>>>>>>>>
84590>>>>>>>>>            End
84590>>>>>>>>>>
84590>>>>>>>>>            Else Begin
84591>>>>>>>>>                Showln ""
84593>>>>>>>>>                Showln "sFileName = " sFileName
84596>>>>>>>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
84601>>>>>>>>>            End
84601>>>>>>>>>>
84601>>>>>>>>>        End
84601>>>>>>>>>>
84601>>>>>>>>>
84601>>>>>>>>>        While (not(SeqEof))
84605>>>>>>>>>            Readln channel iCh sRow
84607>>>>>>>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
84609>>>>>>>>>                // Change the whole line to the new connection id:
84609>>>>>>>>>                Move sChangeTo to sRow 
84610>>>>>>>>>                Move True to bFileChange
84611>>>>>>>>>            End
84611>>>>>>>>>>
84611>>>>>>>>>            Move sRow to sFileArray[iRow]
84612>>>>>>>>>            Increment iRow
84613>>>>>>>>>        Loop
84614>>>>>>>>>>
84614>>>>>>>>>        Send Seq_Close_Channel iCh
84615>>>>>>>>>
84615>>>>>>>>>//        Sleep 1 // Wait for Windows to close the file
84615>>>>>>>>>
84615>>>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
84616>>>>>>>>>        If (iCh < 1) Begin
84618>>>>>>>>>            Function_Return False
84619>>>>>>>>>        End
84619>>>>>>>>>>
84619>>>>>>>>>        Move (SizeOfArray(sFileArray)) to iItems
84620>>>>>>>>>        Decrement iItems
84621>>>>>>>>>
84621>>>>>>>>>        for iCount from 0 to iItems
84627>>>>>>>>>>
84627>>>>>>>>>            Move sFileArray[iCount] to sValue
84628>>>>>>>>>            Writeln channel iCh sValue
84631>>>>>>>>>        Loop
84632>>>>>>>>>>
84632>>>>>>>>>        Send Seq_Close_Channel iCh
84633>>>>>>>>>
84633>>>>>>>>>        Function_Return bFileChange
84634>>>>>>>>>    End_Function
84635>>>>>>>>>
84635>>>>>>>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
84635>>>>>>>>>    // and opens it in "notepad.exe".
84635>>>>>>>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
84635>>>>>>>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
84635>>>>>>>>>    Procedure _UtilShowErrorList
84637>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84637>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84637>>>>>>>>>        Integer iRows iCount iCh iErrorNum
84637>>>>>>>>>        String sPath sFileName sErrorTxt sStatement
84637>>>>>>>>>
84637>>>>>>>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
84638>>>>>>>>>        Get vFolderFormat sPath to sPath
84639>>>>>>>>>        Move "SQLErrorLog.txt"  to sFileName
84640>>>>>>>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
84641>>>>>>>>>            Get paSqlErrorArray to aSqlErrorArray
84642>>>>>>>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
84643>>>>>>>>>            If (iRows > 0) Begin
84645>>>>>>>>>                Decrement iRows
84646>>>>>>>>>                for iCount from 0 to iRows
84652>>>>>>>>>>
84652>>>>>>>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
84653>>>>>>>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
84654>>>>>>>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
84655>>>>>>>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
84661>>>>>>>>>                    Writeln channel iCh "SQL Statement: " sStatement
84665>>>>>>>>>                Loop
84666>>>>>>>>>>
84666>>>>>>>>>            End
84666>>>>>>>>>>
84666>>>>>>>>>        Send Seq_Close_Channel iCh
84667>>>>>>>>>
84667>>>>>>>>>        If (iRows > 0) Begin
84669>>>>>>>>>            Runprogram Shell Background (sPath + sFileName)
84670>>>>>>>>>        End
84670>>>>>>>>>>
84670>>>>>>>>>    End_Procedure
84671>>>>>>>>>
84671>>>>>>>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
84671>>>>>>>>>    // and the table needs to exist as an SQL table.
84671>>>>>>>>>    Function _UtilTableIsSql Handle hTable Returns Boolean
84673>>>>>>>>>        String sRootName sDriverID
84673>>>>>>>>>        Boolean bIsSQL
84673>>>>>>>>>
84673>>>>>>>>>        Move False to bIsSQL
84674>>>>>>>>>        If (hTable > 0) Begin
84676>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84679>>>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQL
84680>>>>>>>>>            If (bIsSQL = True) Begin
84682>>>>>>>>>                Get psDriverID to sDriverID
84683>>>>>>>>>                Get _TableNameOnly sRootName to sRootName
84684>>>>>>>>>                Get _SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
84685>>>>>>>>>            End
84685>>>>>>>>>>
84685>>>>>>>>>        End
84685>>>>>>>>>>
84685>>>>>>>>>
84685>>>>>>>>>        Function_Return bIsSQL
84686>>>>>>>>>    End_Function
84687>>>>>>>>>
84687>>>>>>>>>    // Note: This version uses the pasSQLDataTables array(!)
84687>>>>>>>>>    //       Thus that property needs to have been initialized before
84687>>>>>>>>>    //       calling this function.
84687>>>>>>>>>    Function _UtilTableIsSql_Ex Handle hTable Returns Boolean
84689>>>>>>>>>        String sRootName sDriverID
84689>>>>>>>>>        Boolean bIsSQL
84689>>>>>>>>>
84689>>>>>>>>>        Move False to bIsSQL
84690>>>>>>>>>        If (hTable > 0) Begin
84692>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84695>>>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQL
84696>>>>>>>>>            If (bIsSQL = True) Begin
84698>>>>>>>>>                Get psDriverID to sDriverID
84699>>>>>>>>>                Get _TableNameOnly sRootName to sRootName
84700>>>>>>>>>                Get _SqlUtilCheckIfTableNameExists_Ex sRootName sDriverID to bIsSQL
84701>>>>>>>>>            End
84701>>>>>>>>>>
84701>>>>>>>>>        End
84701>>>>>>>>>>
84701>>>>>>>>>
84701>>>>>>>>>        Function_Return bIsSQL
84702>>>>>>>>>    End_Function
84703>>>>>>>>>
84703>>>>>>>>>    Function _UtilTableIsSqlByRootName String sRootName Returns Boolean
84705>>>>>>>>>        Boolean bIsSQL
84705>>>>>>>>>        Move (sRootName contains ":") to bIsSQL
84706>>>>>>>>>        Function_Return bIsSQL
84707>>>>>>>>>    End_Function
84708>>>>>>>>>
84708>>>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
84708>>>>>>>>>    Function _SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
84710>>>>>>>>>        String sDatabase sSchema sVal
84710>>>>>>>>>        Boolean bExists
84710>>>>>>>>>        String[] asTablesArray
84711>>>>>>>>>        Integer iItem
84711>>>>>>>>>
84711>>>>>>>>>        Move False to bExists
84712>>>>>>>>>        Get psDatabase to sDatabase
84713>>>>>>>>>        Get psSchema   to sSchema
84714>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDatabase = "") Begin
84716>>>>>>>>>            Error DFERR_PROGRAM ("Function _SqlUtilCheckIfTableNameExists: psDatabase =" * String(sDatabase) * "psDriver =" * String(sDriverID))
84717>>>>>>>>>>
84717>>>>>>>>>            Function_Return False
84718>>>>>>>>>        End
84718>>>>>>>>>>
84718>>>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to asTablesArray
84719>>>>>>>>>        Move (SearchArray(sTableName, asTablesArray, Desktop, (RefFunc(DFSTRICMP)))) to iItem
84720>>>>>>>>>        If (iItem <> -1) Begin
84722>>>>>>>>>            Move True to bExists
84723>>>>>>>>>        End
84723>>>>>>>>>>
84723>>>>>>>>>        Function_Return bExists
84724>>>>>>>>>    End_Function
84725>>>>>>>>>
84725>>>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
84725>>>>>>>>>    // This alternative is much faster as it first enumerates all SQL tables
84725>>>>>>>>>    Function _SqlUtilCheckIfTableNameExists_Ex String sTableName String sDriverID Returns Boolean
84727>>>>>>>>>        String sDatabase sSchema sVal
84727>>>>>>>>>        Boolean bExists
84727>>>>>>>>>        String[] asTablesArray
84728>>>>>>>>>        Integer iItem
84728>>>>>>>>>
84728>>>>>>>>>        Move False to bExists
84729>>>>>>>>>        Get psDatabase to sDatabase
84730>>>>>>>>>        Get psSchema   to sSchema
84731>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDatabase = "") Begin
84733>>>>>>>>>            Error DFERR_PROGRAM ("Function _SqlUtilCheckIfTableNameExists: psDatabase =" * String(sDatabase) * "psDriver =" * String(sDriverID))
84734>>>>>>>>>>
84734>>>>>>>>>            Function_Return False
84735>>>>>>>>>        End
84735>>>>>>>>>>
84735>>>>>>>>>        Get pasSQLDataTables to asTablesArray
84736>>>>>>>>>        Move (SearchArray(sTableName, asTablesArray, Desktop, (RefFunc(DFSTRICMP)))) to iItem
84737>>>>>>>>>        If (iItem <> -1) Begin
84739>>>>>>>>>            Move True to bExists
84740>>>>>>>>>        End
84740>>>>>>>>>>
84740>>>>>>>>>        Function_Return bExists
84741>>>>>>>>>    End_Function
84742>>>>>>>>>
84742>>>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
84742>>>>>>>>>    // that the embedded .dat file exists on disk.
84742>>>>>>>>>    Function _UtilTableIsEmbedded Handle hTable Returns Boolean
84744>>>>>>>>>        Boolean bExists bIsEmbedded
84744>>>>>>>>>        String sDataPath sRootName
84744>>>>>>>>>
84744>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
84745>>>>>>>>>        If (bExists = False) Begin
84747>>>>>>>>>            Function_Return False
84748>>>>>>>>>        End
84748>>>>>>>>>>
84748>>>>>>>>>
84748>>>>>>>>>        Move False to bIsEmbedded
84749>>>>>>>>>        If (hTable > 0) Begin
84751>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84754>>>>>>>>>            Move (not(sRootName contains ":")) to bIsEmbedded
84755>>>>>>>>>        End
84755>>>>>>>>>>
84755>>>>>>>>>        If (bIsEmbedded = True) Begin
84757>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84758>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
84759>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bIsEmbedded
84760>>>>>>>>>        End
84760>>>>>>>>>>
84760>>>>>>>>>
84760>>>>>>>>>        Function_Return bIsEmbedded
84761>>>>>>>>>    End_Function
84762>>>>>>>>>
84762>>>>>>>>>    // Returns the DateTime of the passed file name was modified, with seconds (only) precision.
84762>>>>>>>>>    Function FileModTime String sFileName Returns DateTime
84764>>>>>>>>>        Date dDate
84764>>>>>>>>>        Integer iYY iHH iMM iSS
84764>>>>>>>>>        Boolean bExists
84764>>>>>>>>>        DateTime dtFileDateTime
84764>>>>>>>>>
84764>>>>>>>>>        Move (NullDateTime()) to dtFileDateTime
84765>>>>>>>>>        Get vFilePathExists sFileName to bExists
84766>>>>>>>>>        If (bExists = True) Begin
84768>>>>>>>>>            Get_File_Mod_Time sFileName to dDate iHH iMM iSS
84772>>>>>>>>>            Move dDate            to dtFileDateTime
84773>>>>>>>>>            Move (DateGetYear       (dtFileDateTime))      to iYY
84774>>>>>>>>>            Move (DateSetYear       (dtFileDateTime, iYY)) to dtFileDateTime
84775>>>>>>>>>            Move (DateSetHour       (dtFileDateTime, iHH)) to dtFileDateTime
84776>>>>>>>>>            Move (DateSetMinute     (dtFileDateTime, iMM)) to dtFileDateTime
84777>>>>>>>>>            Move (DateSetSecond     (dtFileDateTime, iSS)) to dtFileDateTime
84778>>>>>>>>>            Move (DateSetMillisecond(dtFileDateTime, 0))   to dtFileDateTime
84779>>>>>>>>>        End
84779>>>>>>>>>>
84779>>>>>>>>>
84779>>>>>>>>>        Function_Return dtFileDateTime
84780>>>>>>>>>    End_Function
84781>>>>>>>>>
84781>>>>>>>>>    // Returns True if the file passed as sFileName1 is newer than sFileName2.
84781>>>>>>>>>    Function IsFileTimeNewer String sFileName1 String sFileName2 Returns Boolean
84783>>>>>>>>>        Boolean bExists bIsNewer
84783>>>>>>>>>        DateTime dtFileDateTime1 dtFileDateTime2
84783>>>>>>>>>
84783>>>>>>>>>        Move False to bIsNewer
84784>>>>>>>>>        Get vFilePathExists sFileName1 to bExists
84785>>>>>>>>>        If (bExists = True) Begin
84787>>>>>>>>>            Get FileModTime sFileName1  to dtFileDateTime1
84788>>>>>>>>>            Get FileModTime sFileName2  to dtFileDateTime2
84789>>>>>>>>>            Move (dtFileDateTime1 > dtFileDateTime2) to bIsNewer
84790>>>>>>>>>        End
84790>>>>>>>>>>
84790>>>>>>>>>        Function_Return bIsNewer
84791>>>>>>>>>    End_Function
84792>>>>>>>>>
84792>>>>>>>>>End_Class
84793>>>>>>>
84793>>>>>>>Register_Function pbExitIfDebuggerActive Returns Boolean
84793>>>>>>>Class cDbUpdateFunctionLibrary is a cBaseDbUpdateFuncLib
84794>>>>>>>
84794>>>>>>>    Procedure Construct_Object
84796>>>>>>>        Forward Send Construct_Object
84798>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
84799>>>>>>>    End_Procedure
84800>>>>>>>
84800>>>>>>>    Procedure End_Construct_Object
84802>>>>>>>        Forward Send End_Construct_Object
84804>>>>>>>    End_Procedure
84805>>>>>>>
84805>>>>>>>    // *** SQL Messages for making changes to the SQL back-end ***
84805>>>>>>>    //
84805>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84805>>>>>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
84807>>>>>>>        Function_Return False
84808>>>>>>>    End_Function
84809>>>>>>>
84809>>>>>>>    // Function for creating a new *Database*.
84809>>>>>>>    // Note: This is for creating SQL DATABASES - not tables!
84809>>>>>>>    // Returns True if successful.
84809>>>>>>>    // ToDo: Currently only works for MS-SQL...
84809>>>>>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
84811>>>>>>>        String sSQL sSQL1 sConnectionID sConnectionString
84811>>>>>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
84811>>>>>>>        Handle hConnection hStmt hoSQLManager
84811>>>>>>>        Integer iFetchResult iDbType
84811>>>>>>>        Boolean bOK bExists
84811>>>>>>>
84811>>>>>>>        Get piDbType to iDbType
84812>>>>>>>        If (iDbType <> EN_DbTypeMSSQL and iDbType <> EN_DbTypeDB2 and iDbType <> EN_DbTypeMySQL and iDbType <> EN_DbTypePostgre) Begin
84814>>>>>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL, MySQL & PostGre and DB2 drivers"
84815>>>>>>>>
84815>>>>>>>            Function_Return False
84816>>>>>>>        End
84816>>>>>>>>
84816>>>>>>>
84816>>>>>>>        Get SqlUtilCheckIfDatabaseExists sDatabase to bExists
84817>>>>>>>        If (bExists = True) Begin
84819>>>>>>>            Function_Return True
84820>>>>>>>        End
84820>>>>>>>>
84820>>>>>>>
84820>>>>>>>        Get phoSQLManager to hoSQLManager
84821>>>>>>>
84821>>>>>>>        Get psConnectionID     to sConnectionID
84822>>>>>>>        Get psConnectionString to sConnectionString
84823>>>>>>>        Move 0 to LastErr
84824>>>>>>>
84824>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
84826>>>>>>>            // If an ODBC data source (DSN) we cannot pass the UID & PWD; so strip them from the connection string.
84826>>>>>>>            // ToDo: 2018-08-11 I think this is wrong and the uid & pw should be there.
84826>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
84826>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
84826>>>>>>>//                If (iPos > 0) Begin
84826>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
84826>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
84826>>>>>>>//                End
84826>>>>>>>//            End
84826>>>>>>>        End
84826>>>>>>>>
84826>>>>>>>
84826>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84827>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84828>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84829>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84831>>>>>>>            Error DFERR_PROGRAM (CS_DUF_LoginToDbServerFailed + "\n" + sConnectionString)
84832>>>>>>>>
84832>>>>>>>            Function_Return False
84833>>>>>>>        End
84833>>>>>>>>
84833>>>>>>>
84833>>>>>>>        Get SqlOpen of hConnection to hStmt
84834>>>>>>>
84834>>>>>>>        If (hStmt = 0) Begin
84836>>>>>>>            Send SqlDisconnect of hoSQLManager
84837>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
84838>>>>>>>>
84838>>>>>>>            Function_Return False
84839>>>>>>>        End
84839>>>>>>>>
84839>>>>>>>
84839>>>>>>>        Get psCollation to sCollation
84840>>>>>>>
84840>>>>>>>        Case Begin
84840>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
84842>>>>>>>                Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
84843>>>>>>>                Get _SqlSelectFromWhereName to sSelectFromWhereName
84844>>>>>>>                Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
84845>>>>>>>
84845>>>>>>>                // Check if database exists
84845>>>>>>>                Send SqlExecDirect of hStmt sSQL
84846>>>>>>>                Get SqlFetch of hStmt to iFetchResult
84847>>>>>>>                Send SqlClose of hStmt
84848>>>>>>>                Send SqlDisconnect of hConnection
84849>>>>>>>                // If database already exists we're out of here!
84849>>>>>>>                // Note that we return True as this is not an error.
84849>>>>>>>                If (iFetchResult > 0) Begin
84851>>>>>>>                    Function_Return True
84852>>>>>>>                End
84852>>>>>>>>
84852>>>>>>>                // Database doesn't exist, create it.
84852>>>>>>>                If (iFetchResult = 0) Begin
84854>>>>>>>                    Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
84855>>>>>>>                    Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84856>>>>>>>                    If (sCollation <> "") Begin
84858>>>>>>>                        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
84859>>>>>>>                        Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
84860>>>>>>>                    End
84860>>>>>>>>
84860>>>>>>>                    Send SqlUtilExecuteQuery sSQL1 sDriverID
84861>>>>>>>                    Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84862>>>>>>>                    If (LastErr = CLIERR_GENERAL_ERROR) Begin
84864>>>>>>>                        Function_Return False
84865>>>>>>>                    End
84865>>>>>>>>
84865>>>>>>>                    // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
84865>>>>>>>                    Sleep 1
84866>>>>>>>                    Send SqlUtilExecuteQuery sSQL sDriverID
84867>>>>>>>                End
84867>>>>>>>>
84867>>>>>>>                Case Break
84868>>>>>>>
84868>>>>>>>            Case (iDbType = EN_DbTypeMySQL and sDriverID = ODBC_DRV_ID)
84871>>>>>>>                // ToDo: How should this be set/checked?
84871>>>>>>>//                If (Lowercase(Left(sCollation, 3)) <> "utf") Begin
84871>>>>>>>//                    Set psCollation to "utf8"
84871>>>>>>>//                End
84871>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreateMySQLDatabase.sql as CreateMySQLDatabase.sql
84871>>>>>>>                Get _SqlUtilCreateMySQLDatabaseByScript "CreateMySQLDatabase.sql" sDatabase to bOK
84872>>>>>>>                Case Break
84873>>>>>>>
84873>>>>>>>            Case Else
84873>>>>>>>                Error DFERR_PROGRAM "Unsupported database type"
84874>>>>>>>>
84874>>>>>>>        Case End
84874>>>>>>>
84874>>>>>>>        If (Err = False) Begin
84876>>>>>>>            Send LogError ("The Database:" * String(sDatabase) * "was created successfully for driver:" * String(sDriverID)) False
84877>>>>>>>        End
84877>>>>>>>>
84877>>>>>>>        // If used in e.g. the cDbUpdateHandler we want to change the login database name to
84877>>>>>>>        // the one we just created.
84877>>>>>>>        If (bUpdateConnectionString = True and Err = False) Begin
84879>>>>>>>            Set psDatabase to sDatabase
84880>>>>>>>            //...and perhaps also the SQLConnections.ini file setting.
84880>>>>>>>            If (bPermanantly = True) Begin
84882>>>>>>>                If (ghoSQLConnectionHandler <> 0) Begin
84884>>>>>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
84885>>>>>>>                End
84885>>>>>>>>
84885>>>>>>>            End
84885>>>>>>>>
84885>>>>>>>        End
84885>>>>>>>>
84885>>>>>>>
84885>>>>>>>        Function_Return (Err = False)
84886>>>>>>>    End_Function
84887>>>>>>>
84887>>>>>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
84887>>>>>>>    // will be used.
84887>>>>>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
84889>>>>>>>        Boolean bOK bExists bShowProgress bErr
84889>>>>>>>        String sStatement sDriverID
84889>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84889>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84889>>>>>>>        Integer iDbType
84889>>>>>>>
84889>>>>>>>        If (sDatabase = "") Begin
84891>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84892>>>>>>>>
84892>>>>>>>            Function_Return False
84893>>>>>>>        End
84893>>>>>>>>
84893>>>>>>>        If (sBackupName = "") Begin
84895>>>>>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84896>>>>>>>>
84896>>>>>>>            Function_Return False
84897>>>>>>>        End
84897>>>>>>>>
84897>>>>>>>
84897>>>>>>>        // Create backup-folder if it doesn't exist
84897>>>>>>>        Get vFolderExists sPath to bExists
84898>>>>>>>        If (bExists = False) Begin
84900>>>>>>>            Get vCreateDirectory sPath to bErr
84901>>>>>>>            If (bErr = True) Begin
84903>>>>>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
84904>>>>>>>>
84904>>>>>>>                Function_Return False
84905>>>>>>>            End
84905>>>>>>>>
84905>>>>>>>        End
84905>>>>>>>>
84905>>>>>>>        // Make sure the path ends with a back-slash
84905>>>>>>>        If (sPath <> "") Begin
84907>>>>>>>            Get vFolderFormat sPath to sPath
84908>>>>>>>        End
84908>>>>>>>>
84908>>>>>>>
84908>>>>>>>        Get psDriverID to sDriverID
84909>>>>>>>        Get piDbType   to iDbType
84910>>>>>>>        If (num_arguments > 3) Begin
84912>>>>>>>            Move bShowProg to bShowProgress
84913>>>>>>>        End
84913>>>>>>>>
84913>>>>>>>
84913>>>>>>>        Case Begin
84913>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84915>>>>>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
84915>>>>>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
84915>>>>>>>                Get _SqlUtilReadResource  "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
84916>>>>>>>                Get _SqlUtilReadResource "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
84917>>>>>>>
84917>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84918>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
84919>>>>>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
84920>>>>>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
84921>>>>>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
84922>>>>>>>                Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" bShowProgress to bOK
84923>>>>>>>                Case Break
84924>>>>>>>            Case Else
84924>>>>>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
84925>>>>>>>        Case End
84925>>>>>>>
84925>>>>>>>        Function_Return bOK
84926>>>>>>>    End_Function
84927>>>>>>>
84927>>>>>>>    Function SqlDatabaseCollationQuery String sDatabase Boolean bSilent Returns String
84929>>>>>>>        String sStatement sDriverID sRetval //sPrevious
84929>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84929>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84929>>>>>>>        Integer iDbType iRows iFetchResult //iColumn
84929>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
84929>>>>>>>        tSQLConnection SQLConnection
84929>>>>>>>        tSQLConnection SQLConnection
84929>>>>>>>
84929>>>>>>>        If (sDatabase = "") Begin
84931>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
84932>>>>>>>>
84932>>>>>>>            Function_Return ""
84933>>>>>>>        End
84933>>>>>>>>
84933>>>>>>>
84933>>>>>>>        Move "" to sRetval
84934>>>>>>>        Get psDriverID to sDriverID
84935>>>>>>>        Get piDbType   to iDbType
84936>>>>>>>
84936>>>>>>>        Case Begin
84936>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84938>>>>>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
84938>>>>>>>                Get _SqlUtilReadResource "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
84939>>>>>>>
84939>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84940>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
84941>>>>>>>                Get phoSQLManager to hoSQLHandler
84942>>>>>>>
84942>>>>>>>                If (hoSQLHandler <> 0) Begin
84944>>>>>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
84945>>>>>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
84946>>>>>>>
84946>>>>>>>                    If (hoSQLConnect <> 0) Begin
84948>>>>>>>                        Get SQLOpen of hoSQLConnect to hstmt
84949>>>>>>>                        If (hstmt <> 0) Begin
84951>>>>>>>                            Send SqlExecDirect of hstmt sStatement
84952>>>>>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
84953>>>>>>>                            Get SQLFetch of hstmt to iFetchResult
84954>>>>>>>                            If (iFetchResult <> 0) Begin
84956>>>>>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
84957>>>>>>>                            End
84957>>>>>>>>
84957>>>>>>>                            Send SQLClose of hstmt
84958>>>>>>>                        End
84958>>>>>>>>
84958>>>>>>>                        Send SQLDisconnect of hoSQLConnect
84959>>>>>>>                    End
84959>>>>>>>>
84959>>>>>>>                End
84959>>>>>>>>
84959>>>>>>>                Case Break
84960>>>>>>>            Case Else
84960>>>>>>>                If (bSilent = False) Begin
84962>>>>>>>                    Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for this driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
84963>>>>>>>                End
84963>>>>>>>>
84963>>>>>>>        Case End
84963>>>>>>>
84963>>>>>>>        Function_Return sRetval
84964>>>>>>>    End_Function
84965>>>>>>>
84965>>>>>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
84967>>>>>>>        String sDriverID sSQL sConnectionID sConnectionString sSet sWith // sSQL1 
84967>>>>>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
84967>>>>>>>        Handle hConnection hStmt hoSQLManager
84967>>>>>>>        Integer iDbType // iFetchResult
84967>>>>>>>
84967>>>>>>>        If (sDatabase = "") Begin
84969>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84970>>>>>>>>
84970>>>>>>>            Function_Return False
84971>>>>>>>        End
84971>>>>>>>>
84971>>>>>>>
84971>>>>>>>        If (sSQLCollation = "") Begin
84973>>>>>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84974>>>>>>>>
84974>>>>>>>            Function_Return False
84975>>>>>>>        End
84975>>>>>>>>
84975>>>>>>>
84975>>>>>>>        Get psDriverID to sDriverID
84976>>>>>>>        Get piDbType   to iDbType
84977>>>>>>>
84977>>>>>>>        Get phoSQLManager to hoSQLManager
84978>>>>>>>        Get psConnectionID     to sConnectionID
84979>>>>>>>        Get psConnectionString to sConnectionString
84980>>>>>>>        Move 0 to LastErr
84981>>>>>>>
84981>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84982>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84983>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84984>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84986>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
84987>>>>>>>>
84987>>>>>>>            Function_Return False
84988>>>>>>>        End
84988>>>>>>>>
84988>>>>>>>
84988>>>>>>>        Get SqlOpen of hConnection to hStmt
84989>>>>>>>
84989>>>>>>>        If (hStmt = 0) Begin
84991>>>>>>>            Send SqlDisconnect of hoSQLManager
84992>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
84993>>>>>>>>
84993>>>>>>>            Function_Return False
84994>>>>>>>        End
84994>>>>>>>>
84994>>>>>>>
84994>>>>>>>        // Check if collation already exists
84994>>>>>>>        Get SqlDatabaseCollationQuery sDatabase False to sSQLCollationCheck
84995>>>>>>>        // If the current collate is the same as the new; do nothing.
84995>>>>>>>        If (sSQLCollation = sSQLCollationCheck) Begin
84997>>>>>>>            Function_Return True
84998>>>>>>>        End
84998>>>>>>>>
84998>>>>>>>
84998>>>>>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
84999>>>>>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
85000>>>>>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
85001>>>>>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
85002>>>>>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
85003>>>>>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
85004>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
85005>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
85006>>>>>>>
85006>>>>>>>        // MS-SQL Syntax:
85006>>>>>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
85006>>>>>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
85006>>>>>>>        // ALTER DATABASE [database] SET MULTI_USER;
85006>>>>>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
85007>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
85008>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
85009>>>>>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
85009>>>>>>>
85009>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85010>>>>>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
85011>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85012>>>>>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
85014>>>>>>>           Function_Return False
85015>>>>>>>        End
85015>>>>>>>>
85015>>>>>>>
85015>>>>>>>        Function_Return (Err = False)
85016>>>>>>>    End_Function
85017>>>>>>>
85017>>>>>>>
85017>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85017>>>>>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
85019>>>>>>>        Function_Return False
85020>>>>>>>    End_Function
85021>>>>>>>
85021>>>>>>>    // Converts from SQL to Embedded (DataFlex .dat files).
85021>>>>>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
85021>>>>>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
85021>>>>>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
85021>>>>>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
85021>>>>>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
85023>>>>>>>        Handle hToTable
85023>>>>>>>        Boolean bOK bExists bOpened bCopyData
85023>>>>>>>        String sDriverID sPhysicalName sRootName sDisplayName
85023>>>>>>>        tSQLConnection SQLConnection
85023>>>>>>>        tSQLConnection SQLConnection
85023>>>>>>>        Integer iPos iMaxRecords
85023>>>>>>>
85023>>>>>>>        Get psDriverID to sDriverID
85024>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
85025>>>>>>>        If (bExists = False) Begin
85027>>>>>>>            Function_Return False
85028>>>>>>>        End
85028>>>>>>>>
85028>>>>>>>
85028>>>>>>>        If (num_arguments > 1) Begin
85030>>>>>>>            Move bCpyDat to bCopyData
85031>>>>>>>        End
85031>>>>>>>>
85031>>>>>>>        Else Begin
85032>>>>>>>            Move False to bCopyData
85033>>>>>>>        End
85033>>>>>>>>
85033>>>>>>>
85033>>>>>>>        Open hTable
85035>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85038>>>>>>>        If (bOpened = False) Begin
85040>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
85041>>>>>>>>
85041>>>>>>>            Function_Return False
85042>>>>>>>        End
85042>>>>>>>>
85042>>>>>>>        Move 0 to hToTable
85043>>>>>>>
85043>>>>>>>        Move 16711679 to iMaxRecords
85044>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85047>>>>>>>        Move (Pos(".", sDisplayName)) to iPos
85048>>>>>>>        If (iPos > 0) Begin
85050>>>>>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
85051>>>>>>>        End
85051>>>>>>>>
85051>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85054>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
85055>>>>>>>        Move (sRootName + ".dat")                    to sPhysicalName
85056>>>>>>>
85056>>>>>>>        If (ghoProgressBar <> 0) Begin
85058>>>>>>>            Send DoAdvance of ghoProgressBar
85059>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
85060>>>>>>>        End
85060>>>>>>>>
85060>>>>>>>
85060>>>>>>>        Move False to Err
85061>>>>>>>
85061>>>>>>>        Structure_Start hToTable DATAFLEX_ID
85062>>>>>>>            Structure_Copy hTable to hToTable
85063>>>>>>>
85063>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
85066>>>>>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
85069>>>>>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
85072>>>>>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
85075>>>>>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
85078>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85079>>>>>>>
85079>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85081>>>>>>>
85081>>>>>>>        Set Action_Text of ghoStatusPanel to ""
85082>>>>>>>        Move (not(Err)) to bOK
85083>>>>>>>        If (bOK = True and bCopyData = True) Begin
85085>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
85086>>>>>>>        End
85086>>>>>>>>
85086>>>>>>>
85086>>>>>>>        // This must be after copying data...
85086>>>>>>>        If (Err = False) Begin
85088>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85091>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85094>>>>>>>        End
85094>>>>>>>>
85094>>>>>>>        Move (not(Err)) to bOK
85095>>>>>>>
85095>>>>>>>        Function_Return (bOK = True)
85096>>>>>>>    End_Function
85097>>>>>>>
85097>>>>>>>    // Creates an SQL Table at the SQL end by its filelist number;
85097>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
85097>>>>>>>    Function SqlTableCreate Integer hTable Returns Boolean
85099>>>>>>>        String sTableName sSQLString sPath sCreateTable sDriverID
85099>>>>>>>        Integer iDbType
85099>>>>>>>        Boolean bExists
85099>>>>>>>
85099>>>>>>>        Get psDriverID to sDriverID
85100>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85101>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
85102>>>>>>>        If (bExists = True) Begin
85104>>>>>>>            Function_Return False
85105>>>>>>>        End
85105>>>>>>>>
85105>>>>>>>
85105>>>>>>>        Get psDataPathFirstPart to sPath
85106>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
85107>>>>>>>
85107>>>>>>>        Get piDbType to iDbType
85108>>>>>>>        Get _SqlProperTableName sTableName to sTableName
85109>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
85110>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
85111>>>>>>>
85111>>>>>>>        Move False to Err
85112>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85113>>>>>>>
85113>>>>>>>        Function_Return (Err = False)
85114>>>>>>>    End_Function
85115>>>>>>>
85115>>>>>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
85115>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
85115>>>>>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
85117>>>>>>>        String sSQLString sPath sCreateTable sDriverID
85117>>>>>>>        Integer iDbType
85117>>>>>>>        Boolean bExists
85117>>>>>>>
85117>>>>>>>        Get psDriverID to sDriverID
85118>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
85119>>>>>>>        If (bExists = True) Begin
85121>>>>>>>            Function_Return False
85122>>>>>>>        End
85122>>>>>>>>
85122>>>>>>>
85122>>>>>>>        Get psDataPathFirstPart to sPath
85123>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
85124>>>>>>>        If (bExists = True) Begin
85126>>>>>>>            // ToDo: What should we do if an .int file already exists?
85126>>>>>>>        End
85126>>>>>>>>
85126>>>>>>>
85126>>>>>>>        Get piDbType to iDbType
85127>>>>>>>        Get _SqlProperTableName sTableName to sTableName
85128>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
85129>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
85130>>>>>>>
85130>>>>>>>        Move False to Err
85131>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85132>>>>>>>
85132>>>>>>>        Function_Return (Err = False)
85133>>>>>>>    End_Function
85134>>>>>>>    
85134>>>>>>>    // ToDo: 2019-09-23 This needs to be finilized 
85134>>>>>>>    // It resets SQL constraints after a Structure_End, if necessary.
85134>>>>>>>    Function SqlTableRecreateConstraints Handle hTable Returns Boolean
85136>>>>>>>        Boolean bOK                                                            
85136>>>>>>>        String sStatement
85136>>>>>>>        Move "ALTER TABLE [dbo].[THREADS] ADD  DEFAULT ((0)) FOR [SEGMENTS]" to sStatement
85137>>>>>>>        Function_Return bOK
85138>>>>>>>    End_Function
85139>>>>>>>    
85139>>>>>>>    // First deletes the data cache file and then drops the passed SQL table.
85139>>>>>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
85139>>>>>>>    //       else try using the SqlTableRemoveByTableName message.
85139>>>>>>>    Function SqlTableRemove Handle hTable Returns Boolean
85141>>>>>>>        String sSQLString sPath sDropTable sTableName sDriverID
85141>>>>>>>        Integer iRetval iDbType
85141>>>>>>>        Boolean bExists bOK
85141>>>>>>>
85141>>>>>>>        Get psDriverID to sDriverID
85142>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85143>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
85144>>>>>>>        If (bExists = False) Begin
85146>>>>>>>            Function_Return False
85147>>>>>>>        End
85147>>>>>>>>
85147>>>>>>>
85147>>>>>>>        Get psDataPathFirstPart to sPath
85148>>>>>>>        Get _UtilDeleteCacheFile sTableName to iRetval
85149>>>>>>>
85149>>>>>>>        Get piDbType to iDbType
85150>>>>>>>        Get _SqlProperTableName sTableName to sTableName
85151>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
85152>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
85153>>>>>>>
85153>>>>>>>        Move False to Err
85154>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85155>>>>>>>
85155>>>>>>>        // We also need to remove the cache-file since the table has been changed
85155>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85156>>>>>>>
85156>>>>>>>        Function_Return (Err = False)
85157>>>>>>>    End_Function
85158>>>>>>>
85158>>>>>>>    // First deletes the data cache file and then drops the passed data table.
85158>>>>>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
85160>>>>>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
85160>>>>>>>        Integer iRetval iDbType
85160>>>>>>>        Boolean bOK
85160>>>>>>>
85160>>>>>>>        Get psDriverID to sDriverID
85161>>>>>>>        Get psDataPathFirstPart to sPath
85162>>>>>>>        Get _UtilDeleteCacheFile sTableName to iRetval
85163>>>>>>>
85163>>>>>>>        Get piDbType to iDbType
85164>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
85165>>>>>>>        Get psSchema to sSchema
85166>>>>>>>        If (sSchema = "") Begin
85168>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
85169>>>>>>>        End
85169>>>>>>>>
85169>>>>>>>        Move (Uppercase(sTableName)) to sVal
85170>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
85172>>>>>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
85173>>>>>>>        End
85173>>>>>>>>
85173>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
85174>>>>>>>
85174>>>>>>>        Move False to Err
85175>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85176>>>>>>>
85176>>>>>>>        // We also need to remove the cache-file since the table has been changed
85176>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85177>>>>>>>
85177>>>>>>>        Function_Return (Err = False)
85178>>>>>>>    End_Function
85179>>>>>>>
85179>>>>>>>    // *** Sql View Messages ***
85179>>>>>>>
85179>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
85179>>>>>>>    Function SqlViewRemove String sDataView Returns Boolean
85181>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
85181>>>>>>>        Integer iRetval
85181>>>>>>>        Boolean bOK
85181>>>>>>>
85181>>>>>>>        Get psDriverID to sDriverID
85182>>>>>>>        Get _UtilDeleteCacheFile sDataView to iRetval
85183>>>>>>>
85183>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
85184>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
85185>>>>>>>        Set psSQLStatementString to sSQLString
85186>>>>>>>
85186>>>>>>>        // As we don't check if the view exist or not, it might happen
85186>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
85186>>>>>>>        Move False to Err
85187>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85188>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85189>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85190>>>>>>>        Move 0 to LastErr
85191>>>>>>>
85191>>>>>>>        // We also need to remove the cache-file since the table has been changed
85191>>>>>>>        Get _UtilDeleteCacheFile sDataView to bOK
85192>>>>>>>
85192>>>>>>>        Function_Return (Err = False)
85193>>>>>>>    End_Function
85194>>>>>>>
85194>>>>>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
85196>>>>>>>        Boolean bOK
85196>>>>>>>        Integer iDbType
85196>>>>>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
85196>>>>>>>
85196>>>>>>>        Get psDriverID to sDriverID
85197>>>>>>>        Get piDbType   to iDbType
85198>>>>>>>
85198>>>>>>>        Case Begin
85198>>>>>>>            Case (iDbType = EN_DbTypeDB2)
85200>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85201>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85202>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
85203>>>>>>>            Break
85204>>>>>>>
85204>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
85207>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85208>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85209>>>>>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - String(sNewtTableName) - "'") to sSQLString
85210>>>>>>>            Break
85211>>>>>>>
85211>>>>>>>            Case (iDbType = EN_DbTypeOracle)
85214>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85215>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85216>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
85217>>>>>>>            Break
85218>>>>>>>
85218>>>>>>>            Case (iDbType = EN_DbTypePostgre)
85221>>>>>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
85222>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85223>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85224>>>>>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * String(sNewtTableName)) to sSQLString
85225>>>>>>>            Break
85226>>>>>>>
85226>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
85229>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85230>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85231>>>>>>>                Move (Replaces("-", sNewtTableName, "_")) to sNewtTableName
85232>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
85233>>>>>>>            Break
85234>>>>>>>        Case End
85234>>>>>>>
85234>>>>>>>        Move False to Err
85235>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85236>>>>>>>        Move (Err = False) to bOK
85237>>>>>>>
85237>>>>>>>        Function_Return bOK
85238>>>>>>>    End_Function
85239>>>>>>>
85239>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85239>>>>>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
85241>>>>>>>        Function_Return False
85242>>>>>>>    End_Function
85243>>>>>>>
85243>>>>>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
85243>>>>>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
85245>>>>>>>        Integer iLength iDecimals
85245>>>>>>>        String sColumnValue
85245>>>>>>>        String sTableName sDriverID
85245>>>>>>>        Boolean bOK bInitializeValue
85245>>>>>>>
85245>>>>>>>        Get psDriverID to sDriverID
85246>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85247>>>>>>>        If (bOK = False) Begin
85249>>>>>>>            Function_Return False
85250>>>>>>>        End
85250>>>>>>>>
85250>>>>>>>
85250>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85251>>>>>>>        If (sTableName = "") Begin
85253>>>>>>>            Function_Return False
85254>>>>>>>        End
85254>>>>>>>>
85254>>>>>>>
85254>>>>>>>        If (num_arguments > 3) Begin
85256>>>>>>>            Move iLen     to iLength
85257>>>>>>>            Move iDec     to iDecimals
85258>>>>>>>            Move bInitVal to bInitializeValue
85259>>>>>>>            Move sColVal  to sColumnValue
85260>>>>>>>        End
85260>>>>>>>>
85260>>>>>>>
85260>>>>>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
85261>>>>>>>
85261>>>>>>>        Function_Return (bOK = True)
85262>>>>>>>    End_Function
85263>>>>>>>
85263>>>>>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
85263>>>>>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
85265>>>>>>>        Integer iDbType iLength iDecimals iDriver
85265>>>>>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
85265>>>>>>>        String sDriverID sNotNull
85265>>>>>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState
85265>>>>>>>        Handle hTable
85265>>>>>>>
85265>>>>>>>        Get psDriverID to sDriverID
85266>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85267>>>>>>>        If (bOK = False) Begin
85269>>>>>>>            Function_Return True
85270>>>>>>>        End
85270>>>>>>>>
85270>>>>>>>
85270>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
85271>>>>>>>        If (hTable = 0) Begin
85273>>>>>>>            Get NextFreeFilelistSlot to hTable
85274>>>>>>>        End
85274>>>>>>>>
85274>>>>>>>
85274>>>>>>>        Get piDbType to iDbType
85275>>>>>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
85275>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
85276>>>>>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
85278>>>>>>>            Function_Return True
85279>>>>>>>        End
85279>>>>>>>>
85279>>>>>>>
85279>>>>>>>        Get DriverIndex sDriverID to iDriver
85280>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85283>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
85286>>>>>>>
85286>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
85287>>>>>>>        If (num_arguments > 3) Begin
85289>>>>>>>            Move iLen     to iLength
85290>>>>>>>            Move iDec     to iDecimals
85291>>>>>>>            Move bInitVal to bInitializeValue
85292>>>>>>>            Move sColVal  to sColumnValue
85293>>>>>>>        End
85293>>>>>>>>
85293>>>>>>>
85293>>>>>>>        Get _SqlProperTableName sTableName   to sTableName
85294>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
85295>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
85296>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
85297>>>>>>>
85297>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
85298>>>>>>>        If (bFixed = False) Begin
85300>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
85301>>>>>>>        End
85301>>>>>>>>
85301>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
85302>>>>>>>
85302>>>>>>>        Move False to Err
85303>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85304>>>>>>>
85304>>>>>>>        If (bInitializeValue = True and Err = False) Begin
85306>>>>>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
85307>>>>>>>        End
85307>>>>>>>>
85307>>>>>>>
85307>>>>>>>        If (Err = False) Begin
85309>>>>>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
85310>>>>>>>        End
85310>>>>>>>>
85310>>>>>>>
85310>>>>>>>        Move (not(Err)) to bRetval
85311>>>>>>>
85311>>>>>>>        // We also need to remove the cache-file since the table has been changed
85311>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85312>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85315>>>>>>>
85315>>>>>>>        Function_Return bRetval
85316>>>>>>>    End_Function
85317>>>>>>>
85317>>>>>>>    // To update all current rows for a table column with a common value.
85317>>>>>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
85319>>>>>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sSqlSafe_Updates sStmt
85319>>>>>>>        Boolean bRetval bSQLDriver
85319>>>>>>>        Integer iCurrErr iDbType
85319>>>>>>>
85319>>>>>>>        Move False to bRetval
85320>>>>>>>        Get piDbType to iDbType
85321>>>>>>>        Get psDriverID to sDriverID
85322>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
85323>>>>>>>        If (bSQLDriver = False) Begin
85325>>>>>>>            Function_Return bRetval
85326>>>>>>>        End
85326>>>>>>>>
85326>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85327>>>>>>>
85327>>>>>>>        Move Err to iCurrErr
85328>>>>>>>        Move False to Err
85329>>>>>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
85330>>>>>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
85331>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
85332>>>>>>>        // If MySQL and DAW's ODBC driver is used we need to do it slightly different.
85332>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
85334>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
85335>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
85336>>>>>>>        End
85336>>>>>>>>
85336>>>>>>>        Else Begin
85337>>>>>>>            Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
85338>>>>>>>        End
85338>>>>>>>>
85338>>>>>>>
85338>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85339>>>>>>>        Move (Err = False) to bRetval
85340>>>>>>>        Move iCurrErr to Err
85341>>>>>>>
85341>>>>>>>        Function_Return bRetval
85342>>>>>>>    End_Function
85343>>>>>>>
85343>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
85343>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
85343>>>>>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
85345>>>>>>>        String sDriverID sTableName
85345>>>>>>>        Boolean bOK
85345>>>>>>>
85345>>>>>>>        Get psDriverID to sDriverID
85346>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85347>>>>>>>        If (bOK = False) Begin
85349>>>>>>>            Function_Return False
85350>>>>>>>        End
85350>>>>>>>>
85350>>>>>>>
85350>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85351>>>>>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
85352>>>>>>>
85352>>>>>>>        Function_Return (Err = False)
85353>>>>>>>    End_Function
85354>>>>>>>
85354>>>>>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
85354>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
85354>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
85354>>>>>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
85356>>>>>>>        Integer iDbType iLength iDecimals
85356>>>>>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
85356>>>>>>>        Boolean bExists bOK bFixed
85356>>>>>>>        Handle hTable
85356>>>>>>>
85356>>>>>>>        Get psDriverID to sDriverID
85357>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85358>>>>>>>        If (bOK = False) Begin
85360>>>>>>>            Function_Return False
85361>>>>>>>        End
85361>>>>>>>>
85361>>>>>>>
85361>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
85362>>>>>>>        If (hTable = 0) Begin
85364>>>>>>>            Get NextFreeFilelistSlot to hTable
85365>>>>>>>        End
85365>>>>>>>>
85365>>>>>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
85366>>>>>>>        If (bExists = False) Begin
85368>>>>>>>            Function_Return False
85369>>>>>>>        End
85369>>>>>>>>
85369>>>>>>>
85369>>>>>>>        If (num_arguments > 3) Begin
85371>>>>>>>            Move iLen to iLength
85372>>>>>>>        End
85372>>>>>>>>
85372>>>>>>>        If (num_arguments > 4) Begin
85374>>>>>>>            Move iDec to iDecimals
85375>>>>>>>        End
85375>>>>>>>>
85375>>>>>>>
85375>>>>>>>        Get piDbType to iDbType
85376>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
85377>>>>>>>
85377>>>>>>>        Move False to Err
85378>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
85379>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
85380>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
85381>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
85382>>>>>>>
85382>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
85383>>>>>>>        If (bFixed = False) Begin
85385>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
85386>>>>>>>        End
85386>>>>>>>>
85386>>>>>>>
85386>>>>>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
85387>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85388>>>>>>>
85388>>>>>>>        // We also need to remove the cache-file since the table has been changed
85388>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85389>>>>>>>
85389>>>>>>>        Function_Return (Err = False)
85390>>>>>>>    End_Function
85391>>>>>>>
85391>>>>>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
85393>>>>>>>        Boolean bOK bErr bIsSQLDriver
85393>>>>>>>        String sDriverID
85393>>>>>>>        Integer iDataType
85393>>>>>>>
85393>>>>>>>        Get psDriverID to sDriverID
85394>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
85395>>>>>>>        If (bIsSQLDriver = False) Begin
85397>>>>>>>            Function_Return False
85398>>>>>>>        End
85398>>>>>>>>
85398>>>>>>>
85398>>>>>>>        Move Err to bErr
85399>>>>>>>        Move False to bErr
85400>>>>>>>
85400>>>>>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
85400>>>>>>>        // inserts randomly character(10) and spaces, so we correct from that here:
85400>>>>>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
85401>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType
85404>>>>>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
85406>>>>>>>            Move ("[" + String(sValue) + "]") to sValue
85407>>>>>>>        End
85407>>>>>>>>
85407>>>>>>>
85407>>>>>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
85410>>>>>>>        Move (not(Err)) to bOK
85411>>>>>>>        Move bErr to Err
85412>>>>>>>
85412>>>>>>>        Function_Return bOK
85413>>>>>>>    End_Function
85414>>>>>>>
85414>>>>>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
85416>>>>>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
85416>>>>>>>        String sDriverID
85416>>>>>>>
85416>>>>>>>        Get psDriverID to sDriverID
85417>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
85418>>>>>>>        If (bIsSQLDriver = False) Begin
85420>>>>>>>            Function_Return False
85421>>>>>>>        End
85421>>>>>>>>
85421>>>>>>>
85421>>>>>>>        Move Err to bErr
85422>>>>>>>        Move False to bErr
85423>>>>>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
85426>>>>>>>        If (bNullable = bCurrentState) Begin
85428>>>>>>>            Function_Return True
85429>>>>>>>        End
85429>>>>>>>>
85429>>>>>>>
85429>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
85432>>>>>>>        If (bOpen = False) Begin
85434>>>>>>>            Get AutoConnectionIDLogin to bOK
85435>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
85436>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
85437>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85438>>>>>>>            Open hTable
85440>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
85441>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
85442>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85443>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
85446>>>>>>>        End
85446>>>>>>>>
85446>>>>>>>        If (bOpen = True) Begin
85448>>>>>>>            Structure_Start hTable sDriverID
85449>>>>>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
85452>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
85453>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85455>>>>>>>            Set Action_Text of ghoStatusPanel to ""
85456>>>>>>>        End
85456>>>>>>>>
85456>>>>>>>
85456>>>>>>>        Move (not(Err)) to bOK
85457>>>>>>>        Move bErr to Err
85458>>>>>>>
85458>>>>>>>        Function_Return bOK
85459>>>>>>>    End_Function
85460>>>>>>>
85460>>>>>>>    // Drop column by its table handle
85460>>>>>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
85462>>>>>>>        String sDriverID sTableName
85462>>>>>>>        Boolean bOK
85462>>>>>>>
85462>>>>>>>        Get psDriverID to sDriverID
85463>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85464>>>>>>>        If (bOK = False) Begin
85466>>>>>>>            Function_Return False
85467>>>>>>>        End
85467>>>>>>>>
85467>>>>>>>
85467>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85468>>>>>>>        If (sTableName = "") Begin
85470>>>>>>>            Function_Return False
85471>>>>>>>        End
85471>>>>>>>>
85471>>>>>>>
85471>>>>>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
85472>>>>>>>
85472>>>>>>>        Function_Return (bOK = True)
85473>>>>>>>    End_Function
85474>>>>>>>
85474>>>>>>>    // Drop column by its table name as a string.
85474>>>>>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
85476>>>>>>>        Integer iDbType iDriver
85476>>>>>>>        String sDriverID sStmt sAlterTable sDropColumn
85476>>>>>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
85476>>>>>>>        Handle hTable
85476>>>>>>>
85476>>>>>>>        Get psDriverID to sDriverID
85477>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85478>>>>>>>        If (bOK = False) Begin
85480>>>>>>>            Function_Return False
85481>>>>>>>        End
85481>>>>>>>>
85481>>>>>>>
85481>>>>>>>        Get DriverIndex sDriverID to iDriver
85482>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85485>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
85488>>>>>>>
85488>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
85489>>>>>>>        If (hTable <> 0) Begin
85491>>>>>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
85492>>>>>>>            If (bExists = False) Begin
85494>>>>>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85497>>>>>>>                Function_Return False
85498>>>>>>>            End
85498>>>>>>>>
85498>>>>>>>        End
85498>>>>>>>>
85498>>>>>>>
85498>>>>>>>        Get piDbType to iDbType
85499>>>>>>>        If (iDbType = EN_DbTypeMSSQL) Begin
85501>>>>>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
85502>>>>>>>            Get _UtilDeleteCacheFile sTableName to bOK
85503>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85506>>>>>>>            Function_Return bOK
85507>>>>>>>        End
85507>>>>>>>>
85507>>>>>>>
85507>>>>>>>        Move False to Err
85508>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
85509>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
85510>>>>>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
85511>>>>>>>
85511>>>>>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
85512>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85513>>>>>>>        Move (not(Err)) to bRetval
85514>>>>>>>
85514>>>>>>>        // We also need to remove the cache-file since the table has been changed
85514>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85515>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85518>>>>>>>
85518>>>>>>>        Function_Return bRetval
85519>>>>>>>    End_Function
85520>>>>>>>
85520>>>>>>>    // Rename a field/column by table handle (filelist number)
85520>>>>>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
85522>>>>>>>        String sDriverID sTableName
85522>>>>>>>        Boolean bOK
85522>>>>>>>
85522>>>>>>>        Get psDriverID to sDriverID
85523>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85524>>>>>>>        If (bOK = False) Begin
85526>>>>>>>            Function_Return False
85527>>>>>>>        End
85527>>>>>>>>
85527>>>>>>>
85527>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85528>>>>>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
85529>>>>>>>
85529>>>>>>>        Function_Return (Err = False)
85530>>>>>>>    End_Function
85531>>>>>>>
85531>>>>>>>    // Rename a field/column by table name.
85531>>>>>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
85533>>>>>>>        Integer iDbType iDataType
85533>>>>>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
85533>>>>>>>        Boolean bOK bRetval
85533>>>>>>>        Handle hTable
85533>>>>>>>
85533>>>>>>>        Move sTableName to sOrgTableName
85534>>>>>>>        Get psDriverID to sDriverID
85535>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85536>>>>>>>        If (bOK = False) Begin
85538>>>>>>>            Function_Return False
85539>>>>>>>        End
85539>>>>>>>>
85539>>>>>>>
85539>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
85540>>>>>>>        If (sVal = "") Begin
85542>>>>>>>            Function_Return False
85543>>>>>>>        End
85543>>>>>>>>
85543>>>>>>>
85543>>>>>>>        Get piDbType to iDbType
85544>>>>>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
85545>>>>>>>        Get _SqlProperTableName sTableName     to sTableName
85546>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
85547>>>>>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
85548>>>>>>>
85548>>>>>>>        Case Begin
85548>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
85550>>>>>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
85551>>>>>>>                Case Break
85552>>>>>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
85552>>>>>>>            Case (iDbType = EN_dbTypeOracle)
85555>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85556>>>>>>>                Case Break
85557>>>>>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
85557>>>>>>>            Case (iDbType = EN_dbTypeDB2)
85560>>>>>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85561>>>>>>>                Case Break
85562>>>>>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
85562>>>>>>>            Case (iDbType = EN_dbTypePostgre)
85565>>>>>>>                Move sOrgTableName to sTableName
85566>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85567>>>>>>>                Case Break
85568>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
85571>>>>>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
85571>>>>>>>                Move sOrgTableName to sTableName
85572>>>>>>>                Get psDatabase to sDatabase
85573>>>>>>>                Get UtilTableNameToHandle sTableName to hTable
85574>>>>>>>                If (hTable = 0) Begin
85576>>>>>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
85577>>>>>>>                    If (bOK = False) Begin
85579>>>>>>>                        Function_Return False
85580>>>>>>>                    End
85580>>>>>>>>
85580>>>>>>>                    Get NextFreeFilelistSlot to hTable
85581>>>>>>>                End
85581>>>>>>>>
85581>>>>>>>                Else Begin
85582>>>>>>>                    Open hTable
85584>>>>>>>                End
85584>>>>>>>>
85584>>>>>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
85585>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
85586>>>>>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
85587>>>>>>>                Case Break
85588>>>>>>>            Case Else
85588>>>>>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
85589>>>>>>>        Case End
85589>>>>>>>
85589>>>>>>>        Move False to Err
85590>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85591>>>>>>>        Move (Err = False) to bRetval
85592>>>>>>>        // We also need to remove the cache-file since the table has been changed
85592>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85593>>>>>>>
85593>>>>>>>        Function_Return bRetval
85594>>>>>>>    End_Function
85595>>>>>>>
85595>>>>>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
85597>>>>>>>        Handle hoSQLHandler hSQLConnect hStmt
85597>>>>>>>        Integer iNumCols iCount iDataType
85597>>>>>>>        String sValue
85597>>>>>>>
85597>>>>>>>        Get phoSQLManager to hoSQLHandler
85598>>>>>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
85599>>>>>>>        If (hSQLConnect <> 0) Begin
85601>>>>>>>            Get SQLOpen of hSQLConnect to hStmt
85602>>>>>>>            If (hStmt <> 0) Begin
85604>>>>>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
85605>>>>>>>
85605>>>>>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
85606>>>>>>>                For iCount from 1 to iNumCols
85612>>>>>>>>
85612>>>>>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
85613>>>>>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
85615>>>>>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
85616>>>>>>>                        Move iNumCols to iCount // We're out of here
85617>>>>>>>                    End
85617>>>>>>>>
85617>>>>>>>                Loop
85618>>>>>>>>
85618>>>>>>>
85618>>>>>>>                Send SQLClose of hStmt
85619>>>>>>>            End
85619>>>>>>>>
85619>>>>>>>            Send SQLDisconnect of hSQLConnect
85620>>>>>>>        End
85620>>>>>>>>
85620>>>>>>>
85620>>>>>>>        Function_Return iDataType
85621>>>>>>>    End_Function
85622>>>>>>>
85622>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85622>>>>>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
85624>>>>>>>        Function_Return False
85625>>>>>>>    End_Function
85626>>>>>>>
85626>>>>>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
85628>>>>>>>        String sMessage // sConnectionString
85628>>>>>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
85628>>>>>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
85628>>>>>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
85631>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
85631>>>>>>>        TimeSpan tsQuery tsFetch
85631>>>>>>>        tSqlErrorArray aSqlErrorArray
85631>>>>>>>        tSqlErrorArray aSqlErrorArray
85631>>>>>>>        Boolean bOK bShowProgress
85631>>>>>>>        tSQLConnection SQLConnection
85631>>>>>>>        tSQLConnection SQLConnection
85631>>>>>>>
85631>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85632>>>>>>>        If (bOK = False) Begin
85634>>>>>>>            Procedure_Return
85635>>>>>>>        End
85635>>>>>>>>
85635>>>>>>>
85635>>>>>>>        If (num_arguments > 2) Begin
85637>>>>>>>            Move bShowProgr to bShowProgress
85638>>>>>>>        End
85638>>>>>>>>
85638>>>>>>>
85638>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85639>>>>>>>        Get phoSQLManager to hoSqlHandler
85640>>>>>>>        Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
85641>>>>>>>        Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
85642>>>>>>>
85642>>>>>>>        If (hoSQLConnect <> 0) Begin
85644>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
85645>>>>>>>            If (hoStmt <> 0) Begin
85647>>>>>>>                // record starting date/time stamp
85647>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
85648>>>>>>>                // turn on error handling if enabled
85648>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85650>>>>>>>                    Set pbSqlError to False
85651>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
85652>>>>>>>                    Move Error_Object_Id to hoError
85653>>>>>>>                    If (ghoDbUpdateHandler <> 0) Begin
85655>>>>>>>                        Move ghoDbUpdateHandler to Error_Object_Id
85656>>>>>>>                    End
85656>>>>>>>>
85656>>>>>>>                    Else Begin
85657>>>>>>>                        Move Self to Error_Object_Id
85658>>>>>>>                    End
85658>>>>>>>>
85658>>>>>>>                End
85658>>>>>>>>
85658>>>>>>>
85658>>>>>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
85658>>>>>>>                Set psSQLStatementString to sStmt
85659>>>>>>>                Send Cursor_Wait of Cursor_Control
85660>>>>>>>                Send SqlExecDirect of hoStmt sStmt
85661>>>>>>>                Send Cursor_Ready of Cursor_Control
85662>>>>>>>
85662>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85664>>>>>>>                    Move hoError to Error_Object_Id
85665>>>>>>>                End
85665>>>>>>>>
85665>>>>>>>
85665>>>>>>>                Move 0 to iMsgs
85666>>>>>>>                Move Err to iErr
85667>>>>>>>                Move LastErr to iLastErr
85668>>>>>>>                Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
85669>>>>>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
85670>>>>>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
85671>>>>>>>                Send _SqlColumnInfo hoStmt
85672>>>>>>>                Send Ignore_Error of Error_Object_Id 12289
85673>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85674>>>>>>>                Repeat
85674>>>>>>>>
85674>>>>>>>                    Get SqlFetch of hoStmt to iFetchResult
85675>>>>>>>                    If (iFetchResult <> 0) Begin
85677>>>>>>>                        Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
85678>>>>>>>                    End
85678>>>>>>>>
85678>>>>>>>                Until (iFetchResult = 0)
85680>>>>>>>                Send Trap_Error of Error_Object_Id 12289
85681>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
85682>>>>>>>                Move iErr to Err
85683>>>>>>>                Move iLastErr to LastErr
85684>>>>>>>                Set paSQLFetchResults to aSQLFetchResults
85685>>>>>>>
85685>>>>>>>                Set piRows    to iRows
85686>>>>>>>                Set piRowType to iRowType
85687>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
85688>>>>>>>                Move (CurrentDateTime()) to dtFetchStart
85689>>>>>>>
85689>>>>>>>                If (iMsgs <> 0) Begin
85691>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
85693>>>>>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85694>>>>>>>                    End
85694>>>>>>>>
85694>>>>>>>                    For i from 1 to iMsgs
85700>>>>>>>>
85700>>>>>>>                        Get SqlGetMessage of hoStmt i to sMessage
85701>>>>>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
85702>>>>>>>                        If (bShowProgress = True) Begin
85704>>>>>>>                            If (Active_State(ghoStatusPanel)) Begin
85706>>>>>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85707>>>>>>>                            End
85707>>>>>>>>
85707>>>>>>>                            Else Begin
85708>>>>>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85710>>>>>>>                            End
85710>>>>>>>>
85710>>>>>>>                        End
85710>>>>>>>>
85710>>>>>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
85711>>>>>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
85712>>>>>>>                    Loop
85713>>>>>>>>
85713>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
85715>>>>>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85716>>>>>>>                    End
85716>>>>>>>>
85716>>>>>>>                    Set paQueryMessages to sMsg
85717>>>>>>>                End
85717>>>>>>>>
85717>>>>>>>                Else Begin
85718>>>>>>>                    If (bShowProgress = True) Begin
85720>>>>>>>                        Get paSqlErrorArray to aSqlErrorArray
85721>>>>>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
85723>>>>>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
85724>>>>>>>                            Decrement iMsgs
85725>>>>>>>                            For i from 0 to iMsgs
85731>>>>>>>>
85731>>>>>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
85734>>>>>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
85737>>>>>>>                            Loop
85738>>>>>>>>
85738>>>>>>>                        End
85738>>>>>>>>
85738>>>>>>>                    End
85738>>>>>>>>
85738>>>>>>>                End
85738>>>>>>>>
85738>>>>>>>                Move (CurrentDateTime()) to dtFetchEnd
85739>>>>>>>            End
85739>>>>>>>>
85739>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
85740>>>>>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
85741>>>>>>>            Set ptsQueryExec to tsQuery
85742>>>>>>>            Set ptsFetchResults to tsFetch
85743>>>>>>>            Send SqlClose of hoStmt
85744>>>>>>>        End
85744>>>>>>>>
85744>>>>>>>
85744>>>>>>>        Send SqlDisconnect of hoSQLConnect
85745>>>>>>>    End_Procedure
85746>>>>>>>
85746>>>>>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
85746>>>>>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
85746>>>>>>>    // Returns False if no error occured.
85746>>>>>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
85748>>>>>>>        Boolean bOK bShowProgress
85748>>>>>>>        tSQLScriptArray SQLScriptArray
85748>>>>>>>        tSQLScriptArray SQLScriptArray
85748>>>>>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
85748>>>>>>>        TimeSpan tsTotalTime
85748>>>>>>>
85748>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryStart
85749>>>>>>>        Get _SqlUtilReadResource sMemFileName to SQLScriptArray
85750>>>>>>>        If (SQLScriptArray.bError = True) Begin
85752>>>>>>>            Function_Return False
85753>>>>>>>        End
85753>>>>>>>>
85753>>>>>>>
85753>>>>>>>        If (num_arguments > 3) Begin
85755>>>>>>>            Move bShowProgr to bShowProgress
85756>>>>>>>        End
85756>>>>>>>>
85756>>>>>>>
85756>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85757>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
85758>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85759>>>>>>>
85759>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
85760>>>>>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
85761>>>>>>>        Set ptsTotalQueryTime to tsTotalTime
85762>>>>>>>
85762>>>>>>>        Function_Return bOK
85763>>>>>>>    End_Function
85764>>>>>>>
85764>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85764>>>>>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
85766>>>>>>>        Function_Return False
85767>>>>>>>    End_Function
85768>>>>>>>
85768>>>>>>>    // Does three things with auxilirary files;
85768>>>>>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
85768>>>>>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
85768>>>>>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
85768>>>>>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
85770>>>>>>>        String sDataPath sDDSrcPath sDriverID
85770>>>>>>>        Boolean bOK bExists
85770>>>>>>>        Integer iCount iCh iPos
85770>>>>>>>
85770>>>>>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
85770>>>>>>>        If (sTableName contains ".") Begin
85772>>>>>>>            Move (Pos(".", sTableName)) to iPos
85773>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
85774>>>>>>>        End
85774>>>>>>>>
85774>>>>>>>
85774>>>>>>>        Get psDriverID to sDriverID
85775>>>>>>>        Get psDataPathFirstPart to sDataPath
85776>>>>>>>        Get vFolderExists sDataPath to bOK
85777>>>>>>>        If (bOK = False) Begin
85779>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
85780>>>>>>>>
85780>>>>>>>            Function_Return False
85781>>>>>>>        End
85781>>>>>>>>
85781>>>>>>>
85781>>>>>>>        // First delete the cache file:
85781>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85782>>>>>>>
85782>>>>>>>        Get Seq_New_Channel to iCh
85783>>>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
85785>>>>>>>            Function_Return False
85786>>>>>>>        End
85786>>>>>>>>
85786>>>>>>>
85786>>>>>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
85787>>>>>>>        If (bExists = False) Begin
85789>>>>>>>            Function_Return False
85790>>>>>>>        End
85790>>>>>>>>
85790>>>>>>>
85790>>>>>>>        Get _SqlUtilUpdateIntFile hTable to bOK
85791>>>>>>>        // Add the new column name to the .tag filen (if it doesn't exist):
85791>>>>>>>        Get _UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sColumnName to bOK
85792>>>>>>>
85792>>>>>>>        // If in development environment; output new .fd file:
85792>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
85793>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
85794>>>>>>>        If (iCount > 1) Begin
85796>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
85797>>>>>>>        End
85797>>>>>>>>
85797>>>>>>>        Get vFolderExists sDDSrcPath to bExists
85798>>>>>>>        If (bExists = True) Begin
85800>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
85801>>>>>>>            Move False to Err
85802>>>>>>>            Get AutoConnectionIDLogin to bOK
85803>>>>>>>            If (hTable <> 0) Begin
85805>>>>>>>                Open hTable
85807>>>>>>>            End
85807>>>>>>>>
85807>>>>>>>            Else Begin
85808>>>>>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
85809>>>>>>>            End
85809>>>>>>>>
85809>>>>>>>
85809>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
85812>>>>>>>            If (bOK = True) Begin
85814>>>>>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
85816>>>>>>>            End
85816>>>>>>>>
85816>>>>>>>            If (Err = True) Begin
85818>>>>>>>                Move False to bOK
85819>>>>>>>            End
85819>>>>>>>>
85819>>>>>>>        End
85819>>>>>>>>
85819>>>>>>>
85819>>>>>>>        Function_Return (bOK = True)
85820>>>>>>>    End_Function
85821>>>>>>>
85821>>>>>>>    // Message for changing .int files to use connection ID's
85821>>>>>>>    //
85821>>>>>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
85821>>>>>>>    // OR changes an existing connection id to a new id.
85821>>>>>>>    // Pass the full path to the data folder and the name of the connection id (string value).
85821>>>>>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
85821>>>>>>>    Function SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult Returns String[] 
85823>>>>>>>        String sFileName sDriverID sDriverFile sConnectionString sPath
85823>>>>>>>        String[] sFilesData asFileChanges
85825>>>>>>>        Boolean bOK bCancel bChange
85825>>>>>>>        Integer iSize iCount
85825>>>>>>>
85825>>>>>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
85826>>>>>>>        Move (SizeOfArray(sFilesData))    to iSize
85827>>>>>>>        If (iSize = 0) Begin
85829>>>>>>>            If (ghoStatusPanel <> 0) Begin
85831>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
85833>>>>>>>                    Send Stop_StatusPanel of ghoStatusPanel
85834>>>>>>>                End
85834>>>>>>>>
85834>>>>>>>            End
85834>>>>>>>>
85834>>>>>>>            Send Info_Box CS_DUF_NoIntFilesFound
85835>>>>>>>            Function_Return 0
85836>>>>>>>        End
85836>>>>>>>>
85836>>>>>>>
85836>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
85837>>>>>>>        Get vFolderFormat sDataPath to sDataPath
85838>>>>>>>        Decrement iSize
85839>>>>>>>        For iCount from 0 to iSize
85845>>>>>>>>
85845>>>>>>>            Move sFilesData[iCount] to sFileName
85846>>>>>>>            If (Lowercase(sFileName) <> "mssqldrv.int" and Lowercase(sFileName) <> "db2_drv.int" and Lowercase(sFileName) <> "odbc_drv.int") Begin
85848>>>>>>>            // This makes sure that we also can change an existing connection id to something new:
85848>>>>>>>            Get _UtilChangeSourceCodeLine (sDataPath + sFileName) (CS_SERVER_NAME * CS_SERVER) (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bChange
85849>>>>>>>            If (bChange = True) Begin
85851>>>>>>>                Move sFileName to asFileChanges[SizeOfArray(asFileChanges)]
85852>>>>>>>            End
85852>>>>>>>>
85852>>>>>>>            If (ghoStatusPanel <> 0) Begin
85854>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
85856>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
85857>>>>>>>                    If (bCancel = True) Begin
85859>>>>>>>                        Send Deactivate of ghoStatusPanel
85860>>>>>>>                        Function_Return asFileChanges
85861>>>>>>>                        End
85861>>>>>>>>
85861>>>>>>>                    End
85861>>>>>>>>
85861>>>>>>>                End
85861>>>>>>>>
85861>>>>>>>            End
85861>>>>>>>>
85861>>>>>>>        Loop
85862>>>>>>>>
85862>>>>>>>
85862>>>>>>>         // ToDo: Not sure at all we want to do this automatically:
85862>>>>>>>//        Get psDriverID to sDriverID
85862>>>>>>>//         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
85862>>>>>>>//        Move "" to sFileName
85862>>>>>>>//        If (sDriverID = MSSQLDRV_ID) Begin
85862>>>>>>>//            Move "MSSQLDrv.int" to sFileName
85862>>>>>>>//        End
85862>>>>>>>//        If (sDriverID = DB2_DRV_ID) Begin
85862>>>>>>>//            Move "DB2_Drv.int" to sFileName
85862>>>>>>>//        End
85862>>>>>>>//        If (sDriverID = ODBC_DRV_ID) Begin
85862>>>>>>>//            Move "ODBC_Drv.int" to sFileName
85862>>>>>>>//        End
85862>>>>>>>//        If (sFileName <> "") Begin
85862>>>>>>>//            Move "" to sDriverFile
85862>>>>>>>//            Get_File_Path sFileName to sDriverFile
85862>>>>>>>//            Get ParseFolderName sDriverFile to sPath
85862>>>>>>>//            If (sDataPath <> sPath) Begin
85862>>>>>>>//                Move "" to sDriverFile
85862>>>>>>>//            End
85862>>>>>>>//            If (sDriverFile <> "") Begin
85862>>>>>>>//                Get psConnectionString to sConnectionString
85862>>>>>>>//                Get _UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
85862>>>>>>>//            End
85862>>>>>>>//        End     
85862>>>>>>>        
85862>>>>>>>        Function_Return asFileChanges
85863>>>>>>>    End_Function
85864>>>>>>>
85864>>>>>>>    // Checks if the database exists in SQL. Returns = True if it does.
85864>>>>>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
85866>>>>>>>        String[] sDatabaseArray
85867>>>>>>>        String sVal sServer sDriverID
85867>>>>>>>        Integer iCount iSize iPos
85867>>>>>>>        Boolean bExists
85867>>>>>>>        tSQLConnection SQLConnection
85867>>>>>>>        tSQLConnection SQLConnection
85867>>>>>>>
85867>>>>>>>        Move False to bExists
85868>>>>>>>        Get psDriverID to sDriverID
85869>>>>>>>        // DB2 doesn't have a "Database" name, so we always return True.
85869>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
85871>>>>>>>            Function_Return bExists
85872>>>>>>>        End
85872>>>>>>>>
85872>>>>>>>
85872>>>>>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
85873>>>>>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
85875>>>>>>>            Function_Return False
85876>>>>>>>        End
85876>>>>>>>>
85876>>>>>>>
85876>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85877>>>>>>>        Move SQLConnection.sServer to sServer
85878>>>>>>>
85878>>>>>>>        // Special code to handle a FILEDSN that also can contain "/"
85878>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
85880>>>>>>>            Move sDatabaseArray[0] to sVal  // Dummy!
85881>>>>>>>        End
85881>>>>>>>>
85881>>>>>>>        Else If (sServer contains "/") Begin
85884>>>>>>>            Move (Pos("/", sServer)) to iPos
85885>>>>>>>            Move (Mid(sServer, 999, (iPos +1))) to sDatabase
85886>>>>>>>        End
85886>>>>>>>>
85886>>>>>>>
85886>>>>>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
85887>>>>>>>        Decrement iSize
85888>>>>>>>        For iCount from 0 to iSize
85894>>>>>>>>
85894>>>>>>>            Move sDatabaseArray[iCount] to sVal
85895>>>>>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
85897>>>>>>>                Move True to bExists
85898>>>>>>>                If (bExists = True) Begin
85900>>>>>>>                    Move iSize to iCount // We're done.
85901>>>>>>>                End
85901>>>>>>>>
85901>>>>>>>            End
85901>>>>>>>>
85901>>>>>>>        Loop
85902>>>>>>>>
85902>>>>>>>
85902>>>>>>>        Function_Return bExists
85903>>>>>>>    End_Function
85904>>>>>>>
85904>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
85904>>>>>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
85906>>>>>>>        String sDatabase sSchema sTableName sVal
85906>>>>>>>        Boolean bExists
85906>>>>>>>        String[] sTablesArray
85907>>>>>>>        Integer iSize iCount
85907>>>>>>>
85907>>>>>>>        Move False to bExists
85908>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85909>>>>>>>        Get psDatabase to sDatabase
85910>>>>>>>        Get psSchema   to sSchema
85911>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
85912>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
85913>>>>>>>        Decrement iSize
85914>>>>>>>        For iCount from 0 to iSize
85920>>>>>>>>
85920>>>>>>>            Move sTablesArray[iCount] to sVal
85921>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85923>>>>>>>                Move True to bExists
85924>>>>>>>                Move iSize to iCount // We're done!
85925>>>>>>>            End
85925>>>>>>>>
85925>>>>>>>        Loop
85926>>>>>>>>
85926>>>>>>>
85926>>>>>>>        Function_Return bExists
85927>>>>>>>    End_Function
85928>>>>>>>
85928>>>>>>>    Function SqlUtilCheckIfTableNameSpelling String sDriverID String sDatabase String sTableName String sSchema Returns String
85930>>>>>>>        String sVal sTableSpelledCorrectly
85930>>>>>>>        Boolean bExists
85930>>>>>>>        String[] sTablesArray
85931>>>>>>>        Integer iSize iCount
85931>>>>>>>
85931>>>>>>>        Move False to bExists
85932>>>>>>>        Move sTableName to sTableSpelledCorrectly
85933>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
85934>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
85935>>>>>>>        Decrement iSize
85936>>>>>>>        For iCount from 0 to iSize
85942>>>>>>>>
85942>>>>>>>            Move sTablesArray[iCount] to sVal
85943>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85945>>>>>>>                Move sVal to sTableSpelledCorrectly
85946>>>>>>>                Move iSize to iCount // We're done!
85947>>>>>>>            End
85947>>>>>>>>
85947>>>>>>>        Loop
85948>>>>>>>>
85948>>>>>>>
85948>>>>>>>        Function_Return sTableSpelledCorrectly
85949>>>>>>>    End_Function
85950>>>>>>>
85950>>>>>>>    // ToDo: This index name function needs to be finished...
85950>>>>>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
85952>>>>>>>        String sSchema sTableName sDriverID
85952>>>>>>>        Boolean bExists
85952>>>>>>>
85952>>>>>>>        Get psDriverID to sDriverID
85953>>>>>>>        Get psSchema to sSchema
85954>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85955>>>>>>>
85955>>>>>>>        Function_Return bExists
85956>>>>>>>    End_Function
85957>>>>>>>
85957>>>>>>>    // Checks if a column/field name exists in a SQL table definition
85957>>>>>>>    // Returns True if it does
85957>>>>>>>    // Sample:
85957>>>>>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
85957>>>>>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
85959>>>>>>>        Integer iNumColumns iColumn
85959>>>>>>>        String sColumn sDriverID
85959>>>>>>>        String[] sColumnsArray
85960>>>>>>>        Boolean bExists bOK
85960>>>>>>>
85960>>>>>>>        Move False to bExists
85961>>>>>>>        Get AutoConnectionIDLogin to bOK
85962>>>>>>>        Get psDriverID to sDriverID
85963>>>>>>>
85963>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
85964>>>>>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
85965>>>>>>>        Decrement iNumColumns
85966>>>>>>>        For iColumn from 0 to iNumColumns
85972>>>>>>>>
85972>>>>>>>            Move sColumnsArray[iColumn] to sColumn
85973>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
85975>>>>>>>                Move True to bExists
85976>>>>>>>                Move iNumColumns to iColumn // We're out of here
85977>>>>>>>            End
85977>>>>>>>>
85977>>>>>>>        Loop
85978>>>>>>>>
85978>>>>>>>
85978>>>>>>>        Function_Return bExists
85979>>>>>>>    End_Function
85980>>>>>>>
85980>>>>>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
85982>>>>>>>        Integer iNumColumns iColumn iDFType iNativeType
85982>>>>>>>        Boolean bOpened bOK
85982>>>>>>>        String sColumnName sNativeTypeName
85982>>>>>>>
85982>>>>>>>        Get AutoConnectionIDLogin to bOK
85983>>>>>>>        Get OpenTableExclusive hTable to bOK
85984>>>>>>>        If (bOK = False) Begin
85986>>>>>>>            Function_Return False
85987>>>>>>>        End
85987>>>>>>>>
85987>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85990>>>>>>>        If (bOpened = False) Begin
85992>>>>>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
85993>>>>>>>>
85993>>>>>>>            Function_Return False
85994>>>>>>>        End
85994>>>>>>>>
85994>>>>>>>
85994>>>>>>>        Move False to Err
85995>>>>>>>
85995>>>>>>>        Structure_Start hTable
85996>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
85999>>>>>>>
85999>>>>>>>            For iColumn from 1 to iNumColumns
86005>>>>>>>>
86005>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
86008>>>>>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
86011>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
86014>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
86017>>>>>>>
86017>>>>>>>                Case Begin
86017>>>>>>>                    Case (iDFType = DF_DATE)
86019>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
86021>>>>>>>                            // Convert datetime to date
86021>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
86024>>>>>>>                        End
86024>>>>>>>>
86024>>>>>>>                        Case Break
86025>>>>>>>                    Case (iDFType = DF_DATETIME)
86028>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
86030>>>>>>>                            // Convert datetime to datetime2
86030>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
86033>>>>>>>                        End
86033>>>>>>>>
86033>>>>>>>                        Case Break
86034>>>>>>>                    Case (iDFType = DF_ASCII)
86037>>>>>>>                        If (iNativeType = SQL_CHAR) Begin
86039>>>>>>>                            // Convert char to varchar
86039>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
86042>>>>>>>                        End
86042>>>>>>>>
86042>>>>>>>                        Case Break
86043>>>>>>>                    Case (iDFType = DF_TEXT)
86046>>>>>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
86048>>>>>>>                            // Convert text to varchar(max)
86048>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
86051>>>>>>>                        End
86051>>>>>>>>
86051>>>>>>>                        Case Break
86052>>>>>>>                    Case (iDFType = DF_BINARY)
86055>>>>>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
86057>>>>>>>                            // Convert image to varbinary(max)
86057>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
86060>>>>>>>                        End
86060>>>>>>>>
86060>>>>>>>                        Case Break
86061>>>>>>>                Case End
86061>>>>>>>            Loop
86062>>>>>>>>
86062>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86063>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86065>>>>>>>
86065>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86066>>>>>>>        Function_Return (Err = False)
86067>>>>>>>    End_Function
86068>>>>>>>
86068>>>>>>>
86068>>>>>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
86068>>>>>>>    // the DbUpdateVersion database revision in.
86068>>>>>>>    // Also pass the file number of the current (embedded?) table number used in development.
86068>>>>>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
86068>>>>>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
86070>>>>>>>        Boolean bOK bOpened
86070>>>>>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
86070>>>>>>>
86070>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
86073>>>>>>>        Get _TableNameOnly sTableName to sTableName
86074>>>>>>>        If (sTableName = "") Begin
86076>>>>>>>            Function_Return False
86077>>>>>>>        End
86077>>>>>>>>
86077>>>>>>>
86077>>>>>>>        // This just creates the table and a "dummy" column.
86077>>>>>>>        Get SqlTableCreate hTable sDriverID to bOK
86078>>>>>>>        If (bOK = False) Begin
86080>>>>>>>            Function_Return False
86081>>>>>>>        End
86081>>>>>>>>
86081>>>>>>>
86081>>>>>>>        Close hTable
86082>>>>>>>        Move False to Err
86083>>>>>>>
86083>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
86084>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
86085>>>>>>>        Move "Decimal" to sDataType
86086>>>>>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
86087>>>>>>>
86087>>>>>>>        // Adds the "sColumnName" passed to the function
86087>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
86088>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
86089>>>>>>>
86089>>>>>>>        // Now we can delete the dummy column:
86089>>>>>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
86090>>>>>>>
86090>>>>>>>        // Finally, we attach to the newly created table.
86090>>>>>>>        If (Err = False) Begin
86092>>>>>>>            Get ApiTableAttachToSQL hTable True to bOK
86093>>>>>>>        End
86093>>>>>>>>
86093>>>>>>>        Open hTable
86095>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86098>>>>>>>
86098>>>>>>>        Function_Return (Err = False and bOK = True and bOpened = True)
86099>>>>>>>    End_Function
86100>>>>>>>
86100>>>>>>>    // Returns a handle to the SQL server associated with the passed driver ID.
86100>>>>>>>    // Pass e.g. the psServer property to determine the current connection server.
86100>>>>>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
86100>>>>>>>    // This handle can be used to obtain attributes about the server, such as default
86100>>>>>>>    // column types.
86100>>>>>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
86102>>>>>>>        Handle hDatabase
86102>>>>>>>        Integer iDriver iServers iCount
86102>>>>>>>        String sValue
86102>>>>>>>
86102>>>>>>>        If (sServer = "") Begin
86104>>>>>>>            Function_Return 0
86105>>>>>>>        End
86105>>>>>>>>
86105>>>>>>>
86105>>>>>>>        Get DriverIndex sDriverID to iDriver
86106>>>>>>>        If (iDriver = 0) Begin
86108>>>>>>>            Function_Return 0
86109>>>>>>>        End
86109>>>>>>>>
86109>>>>>>>
86109>>>>>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
86112>>>>>>>        For iCount from 1 to iServers
86118>>>>>>>>
86118>>>>>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
86121>>>>>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
86123>>>>>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
86126>>>>>>>            End
86126>>>>>>>>
86126>>>>>>>        Loop
86127>>>>>>>>
86127>>>>>>>
86127>>>>>>>        Function_Return hDatabase
86128>>>>>>>    End_Function
86129>>>>>>>
86129>>>>>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
86129>>>>>>>//        String sRootName
86129>>>>>>>//        Boolean bOK
86129>>>>>>>//
86129>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86129>>>>>>>//        Move (sRootName contains sDriverID) to bOK
86129>>>>>>>//
86129>>>>>>>//        Function_Return bOK
86129>>>>>>>//    End_Function
86129>>>>>>>
86129>>>>>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
86129>>>>>>>//        String sDriverID sRootName sDisplayName sSchema sVal
86129>>>>>>>//        Integer iDbType
86129>>>>>>>//        Boolean bOK
86129>>>>>>>//
86129>>>>>>>//        Get UtilIsFilelistEntryDriverBased to bOK
86129>>>>>>>//        If (bOK = True) Begin
86129>>>>>>>//            Function_Return False
86129>>>>>>>//        End
86129>>>>>>>//
86129>>>>>>>//        Get psDriverID to sDriverID
86129>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
86129>>>>>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
86129>>>>>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86129>>>>>>>//
86129>>>>>>>//        Get psDriverID to sDriverID
86129>>>>>>>//        Get piDbType   to iDbType
86129>>>>>>>//        Get psSchema   to sSchema
86129>>>>>>>//        If (sSchema = "") Begin
86129>>>>>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
86129>>>>>>>//        End
86129>>>>>>>//
86129>>>>>>>//        Move (Uppercase(sDisplayName)) to sVal
86129>>>>>>>//        If (not(sVal contains (sSchema + "."))) Begin
86129>>>>>>>//            If (iDbType = EN_dbTypeDB2) Begin
86129>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
86129>>>>>>>//            End
86129>>>>>>>//            Else Begin
86129>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
86129>>>>>>>//            End
86129>>>>>>>//        End
86129>>>>>>>//
86129>>>>>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
86129>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86129>>>>>>>//
86129>>>>>>>//        Function_Return True
86129>>>>>>>//    End_Function
86129>>>>>>>
86129>>>>>>>    // Removes all driver identifications (e.g. "MSSQLDRV:MyTable")
86129>>>>>>>    // from the passed filelist.
86129>>>>>>>    // Returns the number of tables affected.
86129>>>>>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
86131>>>>>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
86131>>>>>>>        Integer iRetval
86131>>>>>>>        Handle hTable
86131>>>>>>>
86131>>>>>>>        // We first save the current filelist as the passed filelist name
86131>>>>>>>        // may come from another workspace, to restore it when we're ready.
86131>>>>>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
86134>>>>>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
86137>>>>>>>        Move 0 to hTable
86138>>>>>>>        Move 0 to iRetval
86139>>>>>>>
86139>>>>>>>        Repeat
86139>>>>>>>>
86139>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
86142>>>>>>>            If (hTable <> 0) Begin
86144>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
86147>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86150>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86153>>>>>>>                Move (Uppercase(sRootName)) to sVal
86154>>>>>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
86156>>>>>>>                    // Prefixes:
86156>>>>>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
86157>>>>>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
86158>>>>>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
86159>>>>>>>                    // Suffixes:
86159>>>>>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
86160>>>>>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
86161>>>>>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
86162>>>>>>>
86162>>>>>>>                    // Change Filelist entry:
86162>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
86165>>>>>>>
86165>>>>>>>                    Move (Lowercase(sDisplayName)) to sVal
86166>>>>>>>                    If (sVal contains "dbo.") Begin
86168>>>>>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
86169>>>>>>>
86169>>>>>>>                        // Change Filelist entry:
86169>>>>>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
86172>>>>>>>                    End
86172>>>>>>>>
86172>>>>>>>                    Increment iRetval
86173>>>>>>>                End
86173>>>>>>>>
86173>>>>>>>            End
86173>>>>>>>>
86173>>>>>>>        Until (hTable = 0)
86175>>>>>>>
86175>>>>>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
86178>>>>>>>
86178>>>>>>>        Function_Return iRetval
86179>>>>>>>    End_Function
86180>>>>>>>
86180>>>>>>>    // To open all Sql based tables in Filelist.cfg
86180>>>>>>>    Procedure SqlUtilOpenAllTables
86182>>>>>>>        Handle hTable
86182>>>>>>>        String sRoot sDriverID
86182>>>>>>>        Boolean bOK
86182>>>>>>>
86182>>>>>>>        Move 0 to hTable
86183>>>>>>>        Move "" to sDriverID
86184>>>>>>>        Get AutoConnectionIDLogin to bOK
86185>>>>>>>
86185>>>>>>>        Repeat
86185>>>>>>>>
86185>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
86188>>>>>>>            If (hTable > 0) Begin
86190>>>>>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
86193>>>>>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
86195>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
86198>>>>>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
86200>>>>>>>                        Open hTable
86202>>>>>>>                    End
86202>>>>>>>>
86202>>>>>>>                End
86202>>>>>>>>
86202>>>>>>>            End
86202>>>>>>>>
86202>>>>>>>
86202>>>>>>>        Until (hTable = 0)
86204>>>>>>>    End_Procedure
86205>>>>>>>
86205>>>>>>>//    Function SqlUtilSchemaName Handle hTable Returns String
86205>>>>>>>//        String sRetval sDriverID
86205>>>>>>>//        String sTableName
86205>>>>>>>//        Integer iDbType iIndex
86205>>>>>>>//        Boolean bOK
86205>>>>>>>//
86205>>>>>>>//        Get psDriverID to sDriverID
86205>>>>>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
86205>>>>>>>//        If (hTable = 0 or bOK = False) Begin
86205>>>>>>>//            Function_Return ""
86205>>>>>>>//        End
86205>>>>>>>//
86205>>>>>>>//        Move False to Err
86205>>>>>>>//        Get UtilTableHandleToString hTable to sTableName
86205>>>>>>>//        Get piDbType to iDbType
86205>>>>>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
86205>>>>>>>//        If (iIndex = -1) Begin
86205>>>>>>>//            Function_Return ""
86205>>>>>>>//        End
86205>>>>>>>//
86205>>>>>>>//        Function_Return sRetval
86205>>>>>>>//    End_Function
86205>>>>>>>
86205>>>>>>>    // Checks if the passed Table;
86205>>>>>>>    // 1) Already has a Filelist entry that points to SQL and
86205>>>>>>>    // 2) It has an .int file.
86205>>>>>>>    // If both is True it should already be connected to SQL
86205>>>>>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
86207>>>>>>>        Boolean bExists bRootName
86207>>>>>>>        String sRootName sDataPath
86207>>>>>>>
86207>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86210>>>>>>>        Move (sRootName contains sDriverID) to bRootName
86211>>>>>>>
86211>>>>>>>        Get psDataPathFirstPart to sDataPath
86212>>>>>>>        Get vFolderExists sDataPath to bExists
86213>>>>>>>        If (bExists = False) Begin
86215>>>>>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
86215>>>>>>>            Function_Return False
86216>>>>>>>        End
86216>>>>>>>>
86216>>>>>>>
86216>>>>>>>        Get vFolderFormat sDataPath to sDataPath
86217>>>>>>>        Get _TableNameOnly sRootName to sRootName
86218>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
86219>>>>>>>
86219>>>>>>>        Function_Return (bRootName = True and bExists = True)
86220>>>>>>>    End_Function
86221>>>>>>>
86221>>>>>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
86223>>>>>>>        Boolean bViewTableType bOpen bOK
86223>>>>>>>        Integer iTableCount iNumTables
86223>>>>>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
86223>>>>>>>        Handle hoCliHandler
86223>>>>>>>        tSQLConnection SQLConnection
86223>>>>>>>        tSQLConnection SQLConnection
86223>>>>>>>
86223>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
86226>>>>>>>        If (bOpen = False) Begin
86228>>>>>>>            Get AutoConnectionIDLogin to bOK
86229>>>>>>>            Open hTable
86231>>>>>>>        End
86231>>>>>>>>
86231>>>>>>>
86231>>>>>>>        Get pSQLConnection to SQLConnection
86232>>>>>>>        Get phoCLIHandler to hoCliHandler
86233>>>>>>>        Set psDriverID of hoCliHandler to sDriverID
86234>>>>>>>
86234>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
86237>>>>>>>        Get _TableNameOnly sTableName to sTableName
86238>>>>>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
86241>>>>>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
86242>>>>>>>
86242>>>>>>>        For iTableCount from 1 to iNumTables
86248>>>>>>>>
86248>>>>>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
86249>>>>>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
86250>>>>>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
86252>>>>>>>                Get TableType of hoCliHandler iTableCount to sTableType
86253>>>>>>>                Move iNumTables to iTableCount // We're done.
86254>>>>>>>            End
86254>>>>>>>>
86254>>>>>>>        Loop
86255>>>>>>>>
86255>>>>>>>
86255>>>>>>>        Move (sTableType = "VIEW") to bViewTableType
86256>>>>>>>        If (bOpen = False) Begin
86258>>>>>>>            Close hTable
86259>>>>>>>        End
86259>>>>>>>>
86259>>>>>>>
86259>>>>>>>        Function_Return bViewTableType
86260>>>>>>>    End_Function
86261>>>>>>>
86261>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
86261>>>>>>>    //
86261>>>>>>>    // SQL utility function that returns a database type (string) constant
86261>>>>>>>    // corresponding to the passed iDbType.
86261>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
86263>>>>>>>        String sRetval
86263>>>>>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
86264>>>>>>>        Function_Return sRetval
86265>>>>>>>    End_Function
86266>>>>>>>
86266>>>>>>>    // SQL utility function that returns a database type constant (integer)
86266>>>>>>>    // corresponding to the passed sDbType string constant.
86266>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
86268>>>>>>>        Integer iRetval
86268>>>>>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
86269>>>>>>>        Function_Return iRetval
86270>>>>>>>    End_Function
86271>>>>>>>
86271>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
86271>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
86271>>>>>>>    // the SQL Connection program's grid.
86271>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
86273>>>>>>>        String sRetval
86273>>>>>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
86274>>>>>>>        Function_Return sRetval
86275>>>>>>>    End_Function
86276>>>>>>>
86276>>>>>>>    // Pass a driver name as a string and the function will return
86276>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
86276>>>>>>>    // quite work and always returns "MS SQL Server"
86276>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
86278>>>>>>>        Integer iRetval
86278>>>>>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
86279>>>>>>>        Function_Return iRetval
86280>>>>>>>    End_Function
86281>>>>>>>
86281>>>>>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
86281>>>>>>>    // that "fits" in the max allowed length for table names.
86281>>>>>>>    // Max number of characters allowed for table names;
86281>>>>>>>    // IBM DB2      = 128
86281>>>>>>>    // MS-SQL       = 128
86281>>>>>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
86281>>>>>>>    // MySQL        = 64
86281>>>>>>>    // PostgreSQL   = 64
86281>>>>>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
86283>>>>>>>        String sGUIDName
86283>>>>>>>        Integer iDbType iLength
86283>>>>>>>
86283>>>>>>>        Get piDbType to iDbType
86284>>>>>>>        Move (RandomHexUUID()) to sGUIDName
86285>>>>>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
86286>>>>>>>        Move (Length(sGUIDName)) to iLength
86287>>>>>>>
86287>>>>>>>        Case Begin
86287>>>>>>>            Case (iDbType = EN_DbTypeDB2)
86289>>>>>>>            If (iLength > 128) Begin
86291>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
86292>>>>>>>            End
86292>>>>>>>>
86292>>>>>>>            Case Break
86293>>>>>>>
86293>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
86296>>>>>>>            If (iLength > 128) Begin
86298>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
86299>>>>>>>            End
86299>>>>>>>>
86299>>>>>>>            Case Break
86300>>>>>>>
86300>>>>>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
86303>>>>>>>            If (iLength > 128) Begin
86305>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
86306>>>>>>>            End
86306>>>>>>>>
86306>>>>>>>            Case Break
86307>>>>>>>
86307>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
86310>>>>>>>            If (iLength > 64) Begin
86312>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
86313>>>>>>>            End
86313>>>>>>>>
86313>>>>>>>            Case Break
86314>>>>>>>
86314>>>>>>>            Case (iDbType = EN_DbTypePostgre)
86317>>>>>>>            If (iLength > 64) Begin
86319>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
86320>>>>>>>            End
86320>>>>>>>>
86320>>>>>>>        Case End
86320>>>>>>>
86320>>>>>>>        Function_Return sGUIDName
86321>>>>>>>    End_Function
86322>>>>>>>
86322>>>>>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
86322>>>>>>>    // Pass the memory resource file reference and the filename to be created,
86322>>>>>>>    // including full path.
86322>>>>>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
86324>>>>>>>        String sText
86324>>>>>>>        Integer iCh iSize iArgSize
86324>>>>>>>
86324>>>>>>>        Move ("Resource:" + sMemFileName) to sMemFileName
86325>>>>>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
86326>>>>>>>        Get_Channel_Size iCh to iSize
86327>>>>>>>        Read_Block channel iCh sText iSize
86329>>>>>>>        Send Seq_Close_Channel iCh
86330>>>>>>>
86330>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
86331>>>>>>>            Write channel iCh sText
86333>>>>>>>        Send Seq_Close_Channel iCh
86334>>>>>>>
86334>>>>>>>        // Wait for file to be written to disk.
86334>>>>>>>        Sleep 2
86335>>>>>>>    End_Procedure
86336>>>>>>>
86336>>>>>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
86338>>>>>>>        String sNotNull sRetval sDefaultValue
86338>>>>>>>        Boolean bOK
86338>>>>>>>
86338>>>>>>>        Get IsSQLDriver sDriverID to bOK
86339>>>>>>>        If (bOK = False) Begin
86341>>>>>>>            Function_Return ""
86342>>>>>>>        End
86342>>>>>>>>
86342>>>>>>>
86342>>>>>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
86343>>>>>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
86344>>>>>>>
86344>>>>>>>        Case Begin
86344>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
86346>>>>>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
86347>>>>>>>                Case Break
86348>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
86351>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
86352>>>>>>>                Case Break
86353>>>>>>>            Case (iDbType = EN_dbTypePostgre)
86356>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
86357>>>>>>>                Case Break
86358>>>>>>>            Case (iDbType = EN_dbTypeDB2)
86361>>>>>>>                Move (String(sNotNull))                                     to sRetval
86362>>>>>>>                Case Break
86363>>>>>>>
86363>>>>>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
86363>>>>>>>            // ToDo: We need to look deeper into how Oracle handles NULL
86363>>>>>>>            Case (iDbType = EN_dbTypeOracle)
86366>>>>>>>                Move  ""                                                    to sRetval
86367>>>>>>>                Case Break
86368>>>>>>>
86368>>>>>>>            Case Else
86368>>>>>>>                Move  ""                                                    to sRetval
86369>>>>>>>        Case End
86369>>>>>>>
86369>>>>>>>        Function_Return sRetval
86370>>>>>>>    End_Function
86371>>>>>>>
86371>>>>>>>    // * Dummy function for the Studio's Code Explorer *
86371>>>>>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
86373>>>>>>>        Function_Return False
86374>>>>>>>    End_Function
86375>>>>>>>
86375>>>>>>>    // Enumerate SQL Servers.
86375>>>>>>>    // Pass a driver id. Returns a string array.
86375>>>>>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
86375>>>>>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
86375>>>>>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
86377>>>>>>>        String[] sReturnArray
86378>>>>>>>        Handle hoSQLHandler
86378>>>>>>>        String sServer
86378>>>>>>>        Integer iCount iNumItems iDataSourceType
86378>>>>>>>
86378>>>>>>>        If (num_arguments > 1) Begin
86380>>>>>>>            Move iDatSrcType to iDataSourceType
86381>>>>>>>        End
86381>>>>>>>>
86381>>>>>>>
86381>>>>>>>        Case Begin
86381>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86383>>>>>>>                Get phoMSSQLHandler to hoSQLHandler 
86384>>>>>>>                Get EnumerateServersLocal of hoSQLHandler to iNumItems
86385>>>>>>>                If (iNumItems = 0) Begin
86387>>>>>>>                    Get EnumerateServers of hoSQLHandler to iNumItems 
86388>>>>>>>                End
86388>>>>>>>>
86388>>>>>>>                For iCount from 0 to (iNumItems - 1)
86394>>>>>>>>
86394>>>>>>>                    Get String_Value of hoSQLHandler iCount to sServer
86395>>>>>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
86396>>>>>>>                Loop
86397>>>>>>>>
86397>>>>>>>                Case Break
86398>>>>>>>
86398>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86401>>>>>>>                Get phoDB2SQLHandler to hoSQLHandler
86402>>>>>>>                Send SeedDataSources of hoSQLHandler
86403>>>>>>>                Move 0 to iCount
86404>>>>>>>                Repeat
86404>>>>>>>>
86404>>>>>>>                    Get DataSources of hoSQLHandler to sServer
86405>>>>>>>                    If (sServer <> "") Begin
86407>>>>>>>                        Move (Replace(",", sServer, "")) to sServer
86408>>>>>>>                        Move sServer to sReturnArray[iCount]
86409>>>>>>>                    End
86409>>>>>>>>
86409>>>>>>>                    Increment iCount
86410>>>>>>>                Until (sServer = "")
86412>>>>>>>                Case Break
86413>>>>>>>
86413>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86416>>>>>>>                Get phoODBCSQLHandler to hoSQLHandler
86417>>>>>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
86418>>>>>>>                Move 0 to iCount
86419>>>>>>>                Repeat
86419>>>>>>>>
86419>>>>>>>                    Get DataSources of hoSQLHandler to sServer
86420>>>>>>>                    If (sServer <> "") Begin
86422>>>>>>>                        Move (Replace(",", sServer, ", ")) to sServer
86423>>>>>>>                        Move sServer to sReturnArray[iCount]
86424>>>>>>>                    End
86424>>>>>>>>
86424>>>>>>>                    Increment iCount
86425>>>>>>>                Until (sServer = "")
86427>>>>>>>                Case Break
86428>>>>>>>
86428>>>>>>>            Case Else
86428>>>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
86429>>>>>>>>
86429>>>>>>>        Case End
86429>>>>>>>
86429>>>>>>>        Function_Return sReturnArray
86430>>>>>>>    End_Function
86431>>>>>>>
86431>>>>>>>    // Returns all databases as a string array for the passed driver id.
86431>>>>>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
86433>>>>>>>        String[] sReturnArray
86434>>>>>>>        String sServer sVal
86434>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
86434>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
86435>>>>>>>        tSQLConnection SQLConnection
86435>>>>>>>        tSQLConnection SQLConnection
86435>>>>>>>        Boolean bOK
86435>>>>>>>        Integer iCount iSize
86435>>>>>>>
86435>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86436>>>>>>>        If (bOK = False) Begin
86438>>>>>>>            Function_Return sReturnArray
86439>>>>>>>        End
86439>>>>>>>>
86439>>>>>>>
86439>>>>>>>        Case Begin
86439>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86441>>>>>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
86442>>>>>>>                Case Break
86443>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86446>>>>>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
86447>>>>>>>                Case Break
86448>>>>>>>
86448>>>>>>>            // This is needed to be able to check if a database exists or not.
86448>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86451>>>>>>>                Get _SqlDatabasesArrayODBC to sReturnStructArray
86452>>>>>>>                If (SizeOfArray(sReturnStructArray)) Begin
86454>>>>>>>                    If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
86456>>>>>>>                        // If a FILEDSN: (can only be one database name)
86456>>>>>>>                        Move sReturnStructArray[0].sDatabaseName to sReturnArray[0]
86457>>>>>>>                    End
86457>>>>>>>>
86457>>>>>>>                    Else Begin
86458>>>>>>>                        // Else the DSN's were read from the registry.
86458>>>>>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86459>>>>>>>                        Move SQLConnection.sServer to sServer
86460>>>>>>>                        Move (SizeOfArray(sReturnStructArray)) to iSize
86461>>>>>>>                        Decrement iSize
86462>>>>>>>                        for iCount from 0 to iSize
86468>>>>>>>>
86468>>>>>>>                            Move (sReturnStructArray[iCount].sServerName) to sVal
86469>>>>>>>                            If (Uppercase(sServer) = Uppercase(sVal)) Begin
86471>>>>>>>                                Move sReturnStructArray[iCount].sDatabaseName to sReturnArray[0]
86472>>>>>>>                                Move iSize to iCount // We're done.
86473>>>>>>>                            End
86473>>>>>>>>
86473>>>>>>>                        Loop
86474>>>>>>>>
86474>>>>>>>                    End
86474>>>>>>>>
86474>>>>>>>                End
86474>>>>>>>>
86474>>>>>>>                Case Break
86475>>>>>>>
86475>>>>>>>            Case Else
86475>>>>>>>//                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
86475>>>>>>>        Case End
86475>>>>>>>
86475>>>>>>>        Function_Return sReturnArray
86476>>>>>>>    End_Function
86477>>>>>>>
86477>>>>>>>    
86477>>>>>>>    // *** Database API Functions: ***
86477>>>>>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
86477>>>>>>>    // make changes/updates to the database.
86477>>>>>>>
86477>>>>>>>    // * Dummy function for the Studio's Code Explorer *
86477>>>>>>>    Function API_TABLE_FUNCTIONS Returns Boolean
86479>>>>>>>        Function_Return False
86480>>>>>>>    End_Function
86481>>>>>>>
86481>>>>>>>    // This might not do what you think - Here's what it does:
86481>>>>>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
86481>>>>>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
86481>>>>>>>    // to the SQL table.
86481>>>>>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
86481>>>>>>>    // already exists in SQL.
86481>>>>>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
86481>>>>>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
86481>>>>>>>    // restructuring an existing table.
86481>>>>>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
86483>>>>>>>        Boolean bExists bOpened bOK bSystemFile bUseConnectionID bIsAlias
86483>>>>>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
86483>>>>>>>        Handle hToTable
86483>>>>>>>
86483>>>>>>>        Move True to bUseConnectionID
86484>>>>>>>        If (num_arguments > 1) Begin
86486>>>>>>>            Move bUseConnID to bUseConnectionID
86487>>>>>>>        End
86487>>>>>>>>
86487>>>>>>>
86487>>>>>>>        Get psDriverID to sDriverID
86488>>>>>>>        // If the table doesn't exist on the SQL back-end we do nothing.
86488>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86489>>>>>>>        If (bExists = False) Begin
86491>>>>>>>            Function_Return False
86492>>>>>>>        End
86492>>>>>>>>
86492>>>>>>>
86492>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
86493>>>>>>>
86493>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86494>>>>>>>        If (bOK = False) Begin
86496>>>>>>>            Function_Return False
86497>>>>>>>        End
86497>>>>>>>>
86497>>>>>>>
86497>>>>>>>        // Then we need to check that the function hasn't been called before; which in case
86497>>>>>>>        // we do nothing
86497>>>>>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
86498>>>>>>>        If (bExists = True) Begin
86500>>>>>>>            Function_Return False
86501>>>>>>>        End
86501>>>>>>>>
86501>>>>>>>
86501>>>>>>>        Get psConnectionID     to sConnectionID
86502>>>>>>>        Get psConnectionString to sConnectionString
86503>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
86505>>>>>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
86506>>>>>>>>
86506>>>>>>>            Function_Return False
86507>>>>>>>        End
86507>>>>>>>>
86507>>>>>>>
86507>>>>>>>        Set Private.phCurrentTable to hTable
86508>>>>>>>        Get psSchema to sSchema
86509>>>>>>>        If (sSchema = "") Begin
86511>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
86512>>>>>>>        End
86512>>>>>>>>
86512>>>>>>>
86512>>>>>>>        // If we should use a connection id we need to check it exists;
86512>>>>>>>        // else we create it before attempting creating the table
86512>>>>>>>        If (bUseConnectionID = True) Begin
86514>>>>>>>            Get AutoConnectionIDLogin to bOK
86515>>>>>>>            If (bOk = False) Begin
86517>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
86518>>>>>>>>
86518>>>>>>>                Function_Return False
86519>>>>>>>            End
86519>>>>>>>>
86519>>>>>>>        End
86519>>>>>>>>
86519>>>>>>>
86519>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86522>>>>>>>        Get _TableNameOnly sRootName to sRootName
86523>>>>>>>        If (sRootName = "") Begin
86525>>>>>>>            Function_Return False
86526>>>>>>>        End
86526>>>>>>>>
86526>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
86527>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86530>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86533>>>>>>>
86533>>>>>>>        // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
86533>>>>>>>        //
86533>>>>>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
86533>>>>>>>        // because then the table should not be visible to users.
86533>>>>>>>//        Move (Pos("@", sDisplayName)) to iPos
86533>>>>>>>//        If (iPos <> 1) Begin
86533>>>>>>>//            If (sDisplayName contains ".") Begin
86533>>>>>>>//                Move (Pos(".", sDisplayName)) to iPos
86533>>>>>>>//                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
86533>>>>>>>//                Move (sSchema + "." + sDisplayName)       to sDisplayName
86533>>>>>>>//            End
86533>>>>>>>//            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86533>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
86533>>>>>>>//            End
86533>>>>>>>//        End
86533>>>>>>>
86533>>>>>>>        If (bIsAlias = False) Begin
86535>>>>>>>            Get OpenTableExclusive hTable to bOpened
86536>>>>>>>            If (bOpened = False) Begin
86538>>>>>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
86539>>>>>>>>
86539>>>>>>>                Function_Return False
86540>>>>>>>            End
86540>>>>>>>>
86540>>>>>>>        End
86540>>>>>>>>
86540>>>>>>>
86540>>>>>>>        If (ghoProgressBar <> 0) Begin
86542>>>>>>>            Send DoAdvance of ghoProgressBar
86543>>>>>>>            Set Message_Text of ghoStatusPanel to ""
86544>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
86545>>>>>>>        End
86545>>>>>>>>
86545>>>>>>>        // Note: The hToTable will get changed by the Structure_xxx command...
86545>>>>>>>        Move hTable to hToTable
86546>>>>>>>        Move False to Err
86547>>>>>>>
86547>>>>>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
86547>>>>>>>        // then we do a pseudo .int file change with the "_SqlUtilUpdateIntFile" function. After that we have
86547>>>>>>>        // a proper and updated .int file.
86547>>>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
86550>>>>>>>        Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
86551>>>>>>>
86551>>>>>>>        If (bIsAlias = False) Begin
86553>>>>>>>            Structure_Start hToTable sDriverID
86554>>>>>>>                Set Private.phCurrentTable to hTable
86555>>>>>>>                If (bUseConnectionID = True) Begin
86557>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
86560>>>>>>>                End
86560>>>>>>>>
86560>>>>>>>                Else Begin
86561>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
86564>>>>>>>                End
86564>>>>>>>>
86564>>>>>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
86567>>>>>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
86567>>>>>>>                Move False to Err
86568>>>>>>>                Move 0 to LastErr
86569>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
86570>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86572>>>>>>>            Set Action_Text of ghoStatusPanel to ""
86573>>>>>>>        End
86573>>>>>>>>
86573>>>>>>>
86573>>>>>>>        Move (not(Err)) to bOK
86574>>>>>>>        If (bOK = True) Begin
86576>>>>>>>            // The attributes set above will always trigger an error
86576>>>>>>>            // We also adjust the Filelist entries
86576>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
86579>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86582>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86585>>>>>>>
86585>>>>>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
86585>>>>>>>            Get _SqlUtilUpdateIntFile hTable to bOK
86586>>>>>>>        End
86586>>>>>>>>
86586>>>>>>>
86586>>>>>>>        Function_Return (bOK = True)
86587>>>>>>>    End_Function
86588>>>>>>>
86588>>>>>>>    // Sample usage:
86588>>>>>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
86588>>>>>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
86588>>>>>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
86590>>>>>>>        Boolean bOK bIsSQLTable
86590>>>>>>>
86590>>>>>>>        Get AutoConnectionIDLogin to bOK
86591>>>>>>>        Move False to Err
86592>>>>>>>        Get OpenTableExclusive hTable to bOK
86593>>>>>>>        If (bOK = False) Begin
86595>>>>>>>            Function_Return False
86596>>>>>>>        End
86596>>>>>>>>
86596>>>>>>>
86596>>>>>>>        // ToDo: Add to all table change functions!
86596>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
86597>>>>>>>            If (bIsSQLTable = True) Begin
86599>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
86602>>>>>>>            End
86602>>>>>>>>
86602>>>>>>>
86602>>>>>>>        Set Private.phCurrentTable to hTable
86603>>>>>>>        Structure_Start hTable
86604>>>>>>>            Set_Attribute iAttribute of hTable to iValue
86607>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86608>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86610>>>>>>>
86610>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86611>>>>>>>        Function_Return (Err = False)
86612>>>>>>>    End_Function
86613>>>>>>>
86613>>>>>>>    Function ApiTableMoveFileListEntry String sRootName String sLogicalName String sDisplayName Handle hFromSlot Handle hToSlot String sDriverID Returns Boolean
86615>>>>>>>        Boolean bOK
86615>>>>>>>        
86615>>>>>>>        Get ApiTableChangeFileListSlot sRootName sLogicalName sDisplayName hToSlot sDriverID to bOK
86616>>>>>>>        If (bOK = True) Begin
86618>>>>>>>            Get ApiTableChangeFileListSlot "" "" "" hFromSlot sDriverID to bOK
86619>>>>>>>        End
86619>>>>>>>>
86619>>>>>>>        
86619>>>>>>>        Function_Return (bOK = True)
86620>>>>>>>    End_Function
86621>>>>>>>    
86621>>>>>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
86621>>>>>>>    // or to change the filelist slot names.
86621>>>>>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
86623>>>>>>>        String sFileListName
86623>>>>>>>        
86623>>>>>>>        Move False to Err
86624>>>>>>>
86624>>>>>>>        If (ghoProgressBar <> 0) Begin
86626>>>>>>>            Send DoAdvance of ghoProgressBar
86627>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
86628>>>>>>>        End
86628>>>>>>>>
86628>>>>>>>        // If all strings are empty it means that we should remove this entry from filelist.
86628>>>>>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
86630>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
86633>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
86636>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
86639>>>>>>>            Function_Return (Err = False) // And we're done.
86640>>>>>>>        End
86640>>>>>>>>
86640>>>>>>>
86640>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86642>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86642>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
86643>>>>>>>        End
86643>>>>>>>>
86643>>>>>>>//        Else Begin
86643>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86643>>>>>>>//        End
86643>>>>>>>//
86643>>>>>>>//        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86643>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86643>>>>>>>
86643>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86646>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86649>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86652>>>>>>>        
86652>>>>>>>        Function_Return (Err = False)
86653>>>>>>>    End_Function
86654>>>>>>>
86654>>>>>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
86656>>>>>>>        Boolean bOK
86656>>>>>>>
86656>>>>>>>        Get AutoConnectionIDLogin to bOK
86657>>>>>>>        Move False to Err
86658>>>>>>>        Get OpenTableExclusive hTable to bOK
86659>>>>>>>        If (bOK = False) Begin
86661>>>>>>>            Function_Return False
86662>>>>>>>        End
86662>>>>>>>>
86662>>>>>>>
86662>>>>>>>        Set Private.phCurrentTable to hTable
86663>>>>>>>        Structure_Start hTable
86664>>>>>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
86667>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86668>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86670>>>>>>>
86670>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86671>>>>>>>        Function_Return (Err = False)
86672>>>>>>>    End_Function
86673>>>>>>>
86673>>>>>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
86675>>>>>>>        Boolean bOK bIsSQLTable
86675>>>>>>>
86675>>>>>>>        Move False to Err
86676>>>>>>>        Get AutoConnectionIDLogin to bOK
86677>>>>>>>        Open hToTable
86679>>>>>>>        Get OpenTableExclusive hTable to bOK
86680>>>>>>>        If (bOK = False) Begin
86682>>>>>>>            Function_Return False
86683>>>>>>>        End
86683>>>>>>>>
86683>>>>>>>
86683>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
86684>>>>>>>            If (bIsSQLTable = True) Begin
86686>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
86689>>>>>>>            End
86689>>>>>>>>
86689>>>>>>>
86689>>>>>>>        Set Private.phCurrentTable to hTable
86690>>>>>>>        Structure_Start hTable
86691>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
86694>>>>>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
86697>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86698>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86700>>>>>>>
86700>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86701>>>>>>>        Function_Return (Err = False)
86702>>>>>>>    End_Function
86703>>>>>>>
86703>>>>>>>    Procedure ApiTableConvertAllAddException Integer hTable
86705>>>>>>>        Integer[] aTableConvertExceptions
86706>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
86707>>>>>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
86708>>>>>>>        Set paTableConvertExceptions to aTableConvertExceptions
86709>>>>>>>    End_Procedure
86710>>>>>>>
86710>>>>>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
86712>>>>>>>        Integer[] aTableDateCorrectionExceptions
86713>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
86714>>>>>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
86715>>>>>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
86716>>>>>>>    End_Procedure
86717>>>>>>>
86717>>>>>>>    Procedure ApiTableConvertALLToSql
86719>>>>>>>        Integer[] iTablesArray
86720>>>>>>>        Integer iSize iCount
86720>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
86720>>>>>>>        String sDriverID
86720>>>>>>>
86720>>>>>>>        Get psDriverID to sDriverID
86721>>>>>>>        Get pbUseConnectionID to bUseConnectionID
86722>>>>>>>        Get pbToANSI          to bToANSI
86723>>>>>>>        Get pbRecnum          to bRecnum
86724>>>>>>>        Get pbCopyData        to bCopyData
86725>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
86727>>>>>>>            Get pbContinueOnError to bContinueOnError
86728>>>>>>>        End
86728>>>>>>>>
86728>>>>>>>
86728>>>>>>>        Get _AllTablesToConvert to iTablesArray
86729>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
86730>>>>>>>        Set pbVisible   of ghoProgressBarOverall to True
86731>>>>>>>        Set piPosition  of ghoProgressBarOverall to 0
86732>>>>>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
86733>>>>>>>        Set piMaximum   of ghoProgressBarOverall to iSize
86734>>>>>>>
86734>>>>>>>        Decrement iSize
86735>>>>>>>        For iCount from 0 to iSize
86741>>>>>>>>
86741>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
86742>>>>>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
86743>>>>>>>            // Probably the right logic here is to just continue trying to convert every table even
86743>>>>>>>            // if there was an error converting one table...
86743>>>>>>>            //If (bContinueOnError = False and bOK = False) Break
86743>>>>>>>        Loop
86744>>>>>>>>
86744>>>>>>>
86744>>>>>>>    End_Procedure
86745>>>>>>>
86745>>>>>>>    Procedure ApiTableAttachALLToSql
86747>>>>>>>        Integer[] iTablesArray
86748>>>>>>>        Integer iSize iCount
86748>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
86748>>>>>>>        String sDriverID
86748>>>>>>>
86748>>>>>>>        Get psDriverID to sDriverID
86749>>>>>>>        Get pbUseConnectionID to bUseConnectionID
86750>>>>>>>        Get pbToANSI          to bToANSI
86751>>>>>>>        Get pbRecnum          to bRecnum
86752>>>>>>>        Get pbCopyData        to bCopyData
86753>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
86755>>>>>>>            Get pbContinueOnError to bContinueOnError
86756>>>>>>>        End
86756>>>>>>>>
86756>>>>>>>
86756>>>>>>>        Get _AllTablesToConvert to iTablesArray
86757>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
86758>>>>>>>        Decrement iSize
86759>>>>>>>        For iCount from 0 to iSize
86765>>>>>>>>
86765>>>>>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
86766>>>>>>>        Loop
86767>>>>>>>>
86767>>>>>>>
86767>>>>>>>    End_Procedure
86768>>>>>>>
86768>>>>>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
86770>>>>>>>        Handle hToTable hoLogFile
86770>>>>>>>        Boolean bOK bExists bOpened bDAWDriver bContinueOnError bIsAlias
86770>>>>>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
86770>>>>>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
86770>>>>>>>        tSQLConnection SQLConnection
86770>>>>>>>        tSQLConnection SQLConnection
86770>>>>>>>        // ToDo: Redo logic. Instead create the new table!
86770>>>>>>>        Get _UtilTableExists hTable to bExists
86771>>>>>>>        If (bExists = False) Begin
86773>>>>>>>            Set Private.phCurrentTable to hTable
86774>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end.(Or Filelist.cfg contains a driver but the table doesn't exists on the SQL back-end)"
86775>>>>>>>>
86775>>>>>>>            Function_Return False
86776>>>>>>>        End
86776>>>>>>>>
86776>>>>>>>
86776>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
86777>>>>>>>        // If this is an Alias file there is nothing to convert to SQL.
86777>>>>>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
86777>>>>>>>        If (bIsAlias = True) Begin
86779>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86782>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
86784>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86787>>>>>>>                Get psConnectionID to sConnectionID
86788>>>>>>>                Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
86789>>>>>>>            End
86789>>>>>>>>
86789>>>>>>>            Function_Return True
86790>>>>>>>        End
86790>>>>>>>>
86790>>>>>>>
86790>>>>>>>        Set Private.phCurrentTable to hTable
86791>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
86794>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86797>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86800>>>>>>>
86800>>>>>>>        If (ghoProgressBar <> 0) Begin
86802>>>>>>>            Send DoAdvance of ghoProgressBar
86803>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
86804>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
86805>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
86806>>>>>>>        End
86806>>>>>>>>
86806>>>>>>>
86806>>>>>>>        // Marco Kuipers suggestion;
86806>>>>>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
86806>>>>>>>        // an SQL table; Instead of creating the table in SQL, attach it to the existing
86806>>>>>>>        // SQL table.
86806>>>>>>>        Get _UtilTableIsSql hTable to bOK
86807>>>>>>>        If (bOK = False) Begin
86809>>>>>>>            Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86810>>>>>>>            If (bExists = True) Begin
86812>>>>>>>//                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86812>>>>>>>//                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86812>>>>>>>                Get phoLogFile to hoLogFile
86813>>>>>>>                If (hoLogFile <> 0) Begin          
86815>>>>>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The table was NOT converted to SQL but instead ATTACHED to the existing SQL table.") to sWarning
86816>>>>>>>//                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
86816>>>>>>>                    Send LogError sWarning False
86817>>>>>>>                End
86817>>>>>>>>
86817>>>>>>>                Else Begin
86818>>>>>>>                    Error DFERR_PROGRAM sWarning
86819>>>>>>>>
86819>>>>>>>                End                                                       
86819>>>>>>>>
86819>>>>>>>                Get ApiTableAttachToSql hTable bUseConnectionID to bOK
86820>>>>>>>                Function_Return bOK // We're done (We have attached to an existing SQL table instead of converting it.
86821>>>>>>>            End
86821>>>>>>>>
86821>>>>>>>        End
86821>>>>>>>>
86821>>>>>>>
86821>>>>>>>        // Does the rootname contain a driver?
86821>>>>>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
86823>>>>>>>            // Does the table already exist as an SQL table?
86823>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86824>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
86824>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
86824>>>>>>>            If (bExists = False) Begin
86826>>>>>>>                Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86827>>>>>>>            End
86827>>>>>>>>
86827>>>>>>>            If (bExists = True) Begin
86829>>>>>>>                Set TableName_Text of ghoStatusPanel to ""
86830>>>>>>>                Function_Return False
86831>>>>>>>            End
86831>>>>>>>>
86831>>>>>>>        End
86831>>>>>>>>
86831>>>>>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
86832>>>>>>>
86832>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
86833>>>>>>>        If (bUseConnectionID = True) Begin
86835>>>>>>>            Move False to bUseConnectionID
86836>>>>>>>        End
86836>>>>>>>>
86836>>>>>>>
86836>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86837>>>>>>>        Move SQLConnection.sSchema           to sSchema
86838>>>>>>>        If (sSchema = "") Begin
86840>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
86841>>>>>>>            Move (Lowercase(sSchema))        to sSchema
86842>>>>>>>        End
86842>>>>>>>>
86842>>>>>>>
86842>>>>>>>        Move SQLConnection.sDatabase         to sDatabase
86843>>>>>>>        Move SQLConnection.sConnectionID     to sConnectionID
86844>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
86845>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
86847>>>>>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
86848>>>>>>>>
86848>>>>>>>            Function_Return False
86849>>>>>>>        End
86849>>>>>>>>
86849>>>>>>>
86849>>>>>>>        Get AutoConnectionIDLogin to bOK
86850>>>>>>>        Open hTable
86852>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86855>>>>>>>        If (bOpened = False) Begin
86857>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
86858>>>>>>>>
86858>>>>>>>            Function_Return False
86859>>>>>>>        End
86859>>>>>>>>
86859>>>>>>>
86859>>>>>>>        If (ghoProgressBar <> 0) Begin
86861>>>>>>>            Send DoAdvance of ghoProgressBar
86862>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
86863>>>>>>>        End
86863>>>>>>>>
86863>>>>>>>
86863>>>>>>>        Move 0 to hToTable
86864>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
86865>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
86866>>>>>>>
86866>>>>>>>        Case Begin
86866>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86868>>>>>>>                Case Break
86869>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86872>>>>>>>                Case Break
86873>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86876>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
86877>>>>>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
86878>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
86879>>>>>>>                Case Break
86880>>>>>>>            Case (sDriverID = DATAFLEX_ID)
86883>>>>>>>                Case Break
86884>>>>>>>            Case Else
86884>>>>>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
86885>>>>>>>>
86885>>>>>>>                Case Break
86886>>>>>>>        Case End
86886>>>>>>>
86886>>>>>>>        Move False to Err
86887>>>>>>>
86887>>>>>>>        Structure_Start hToTable sDriverID
86888>>>>>>>            Structure_Copy hTable to hToTable
86889>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
86892>>>>>>>
86892>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
86894>>>>>>>                If (bUseConnectionID = True) Begin
86896>>>>>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to (CS_DFCONNID + "=" + sConnectionID)
86899>>>>>>>                End
86899>>>>>>>>
86899>>>>>>>                Else Begin
86900>>>>>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to sConnectionString
86903>>>>>>>                End
86903>>>>>>>>
86903>>>>>>>
86903>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE of hToTable to bRecnum
86906>>>>>>>
86906>>>>>>>                If (sSchema <> "") Begin
86908>>>>>>>                    Set_Attribute DF_FILE_OWNER of hToTable to sSchema
86911>>>>>>>                End
86911>>>>>>>>
86911>>>>>>>
86911>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
86913>>>>>>>                    If (sLongTableSpace <> "") Begin
86915>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
86918>>>>>>>                    End
86918>>>>>>>>
86918>>>>>>>                    If (sBaseTableSpace <> "") Begin
86920>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
86923>>>>>>>                    End
86923>>>>>>>>
86923>>>>>>>                    If (sIndexTableSpace <> "") Begin
86925>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
86928>>>>>>>                    End
86928>>>>>>>>
86928>>>>>>>                End
86928>>>>>>>>
86928>>>>>>>            End
86928>>>>>>>>
86928>>>>>>>
86928>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86929>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86931>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86932>>>>>>>
86932>>>>>>>        Move (not(Err)) to bOK
86933>>>>>>>
86933>>>>>>>        If (bOK = True and bCopyData = True) Begin
86935>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
86936>>>>>>>
86936>>>>>>>            If (ghoDbUpdateHandler > 0) Begin
86938>>>>>>>                Get pbContinueOnError to bContinueOnError
86939>>>>>>>            End
86939>>>>>>>>
86939>>>>>>>            // If the data copy failed we will keep the newly created SQL table but
86939>>>>>>>            // rename it by adding a GUID to the end of the table name
86939>>>>>>>            // - or as much as "fit" because different SQL back-ends have
86939>>>>>>>            // different rules how long a table name can be.
86939>>>>>>>            // The new table will probably contain data but something went
86939>>>>>>>            // wrong while converting the data from embedded to SQL.
86939>>>>>>>            If (bOK = False and bContinueOnError = False) Begin
86941>>>>>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86942>>>>>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86943>>>>>>>                Error DFERR_PROGRAM ("Copying of" * sLogicalName * " data failed due to bad data. Either duplicate records and/or bad e.g Date/DateTime data. The SQL table was renamed to:" * String(sGUIDName) * "and its Filelist.cfg entry was NOT changed.")
86944>>>>>>>>
86944>>>>>>>            End
86944>>>>>>>>
86944>>>>>>>        End
86944>>>>>>>>
86944>>>>>>>
86944>>>>>>>        // This must be after copying data...
86944>>>>>>>        If (Err = False) Begin
86946>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86949>>>>>>>            // It seems the Studio does not do this any more, so commented out.
86949>>>>>>>            // We also adjust the display name by prefixing it by the schema name;
86949>>>>>>>            //            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86949>>>>>>>            //                // The max length for the display_name is 31 characters...
86949>>>>>>>            //                If (Length(sSchema + "." + sDisplayName) < 31) Begin
86949>>>>>>>            //                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
86949>>>>>>>            //                End
86949>>>>>>>            //            End
86949>>>>>>>        End
86949>>>>>>>>
86949>>>>>>>
86949>>>>>>>        Close hTable
86950>>>>>>>        Move (not(Err)) to bOK
86951>>>>>>>        Function_Return bOK
86952>>>>>>>    End_Function
86953>>>>>>>
86953>>>>>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
86953>>>>>>>    // It will first drop all indicies, copy the data and then recreate indicies.
86953>>>>>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
86953>>>>>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
86955>>>>>>>        Boolean bOpened bOK
86955>>>>>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
86955>>>>>>>        String sErrorFile sEmpty sPath
86955>>>>>>>
86955>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
86958>>>>>>>        Get AutoConnectionIDLogin to bOK
86959>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
86961>>>>>>>            Send IncreaseSortBufferSize
86962>>>>>>>//            Send SetAllIndexesToBatch hToTable
86962>>>>>>>        End
86962>>>>>>>>
86962>>>>>>>
86962>>>>>>>        Move False to Err
86963>>>>>>>        Open sPhysicalName as hToTable
86965>>>>>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
86968>>>>>>>        If (bOpened = False) Begin
86970>>>>>>>            Function_Return False
86971>>>>>>>        End
86971>>>>>>>>
86971>>>>>>>
86971>>>>>>>        If (ghoStatusPanel <> 0) Begin
86973>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
86974>>>>>>>            Set piMinimum of ghoProgressBar to 0
86975>>>>>>>            Set piMaximum of ghoProgressBar to 100 // 100%
86976>>>>>>>        End
86976>>>>>>>>
86976>>>>>>>
86976>>>>>>>        Move "" to sEmpty
86977>>>>>>>        Move False to Err
86978>>>>>>>        Move True to bOK
86979>>>>>>>        Set Private.phCurrentTable to hToTable
86980>>>>>>>
86980>>>>>>>        // No need to get the record identifier
86980>>>>>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False
86983>>>>>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86986>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86988>>>>>>>            // Remove all indices to speed up copying of data:
86988>>>>>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
86993>>>>>>>            If (iRetval <> 0) Begin       
86995>>>>>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86996>>>>>>>>
86996>>>>>>>                Close hToTable
86997>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87000>>>>>>>                Function_Return False
87001>>>>>>>            End
87001>>>>>>>>
87001>>>>>>>        End
87001>>>>>>>>
87001>>>>>>>
87001>>>>>>>        Move (sRootName + ".err") to sErrorFile
87002>>>>>>>        Move 0 to iIndex
87003>>>>>>>        Move False to Err
87004>>>>>>>
87004>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
87006>>>>>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
87009>>>>>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
87014>>>>>>>            If (iRetval <> 0) Begin
87016>>>>>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
87017>>>>>>>>
87017>>>>>>>                Close hToTable
87018>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87021>>>>>>>                Function_Return False
87022>>>>>>>            End
87022>>>>>>>>
87022>>>>>>>        End
87022>>>>>>>>
87022>>>>>>>        Else Begin
87023>>>>>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
87026>>>>>>>        End
87026>>>>>>>>
87026>>>>>>>
87026>>>>>>>        If (Err = False) Begin
87028>>>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
87029>>>>>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
87030>>>>>>>        End
87030>>>>>>>>
87030>>>>>>>
87030>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87032>>>>>>>            // Recreate indices:
87032>>>>>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
87037>>>>>>>            If (iRetval <> 0) Begin
87039>>>>>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
87040>>>>>>>>
87040>>>>>>>                Close hToTable
87041>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87044>>>>>>>                Function_Return False
87045>>>>>>>            End
87045>>>>>>>>
87045>>>>>>>        End
87045>>>>>>>>
87045>>>>>>>
87045>>>>>>>        Close hToTable
87046>>>>>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87049>>>>>>>
87049>>>>>>>        If (bOK = True) Begin
87051>>>>>>>            Move (not(Err)) to bOK
87052>>>>>>>        End
87052>>>>>>>>
87052>>>>>>>
87052>>>>>>>        If (ghoStatusPanel <> 0) Begin
87054>>>>>>>            Set TableName_Text of ghoStatusPanel to ""
87055>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
87056>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
87057>>>>>>>        End
87057>>>>>>>>
87057>>>>>>>
87057>>>>>>>        Function_Return (bOK = True)
87058>>>>>>>    End_Function
87059>>>>>>>
87059>>>>>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
87059>>>>>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
87059>>>>>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
87061>>>>>>>        Handle hFile
87061>>>>>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
87061>>>>>>>        Integer iIdentityType iDataType iDbType iCount iSize
87061>>>>>>>        Boolean bOk bExists bSqlDriver bDeleteDummy bExistsInFilelist bSysFile
87061>>>>>>>        tSQLConnection SQLConnection
87061>>>>>>>        tSQLConnection SQLConnection
87061>>>>>>>        tAPIColumn[] aColumns
87061>>>>>>>        tAPIColumn[] aColumns
87062>>>>>>>        tColumnType ColumnType
87062>>>>>>>        tColumnType ColumnType
87062>>>>>>>
87062>>>>>>>        // First check if the passed filenumber already exists; in case we do nothing
87062>>>>>>>        Get _UtilTableExists hTable to bOk
87063>>>>>>>        If (bOk = True) Begin
87065>>>>>>>            Function_Return False
87066>>>>>>>        End
87066>>>>>>>>
87066>>>>>>>
87066>>>>>>>        Set Private.phCurrentTable to hTable
87067>>>>>>>        Move sLogicalName to sTableName
87068>>>>>>>        If (ghoProgressBar <> 0) Begin
87070>>>>>>>            Send DoAdvance of ghoProgressBar
87071>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
87072>>>>>>>        End
87072>>>>>>>>
87072>>>>>>>
87072>>>>>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
87073>>>>>>>        Get psDriverID to sDriverID
87074>>>>>>>        Get IsSQLDriver sDriverID to bSqlDriver
87075>>>>>>>        Get piDbType to iDbType
87076>>>>>>>
87076>>>>>>>        // If no columns passed in, we need to create a "dummy" column
87076>>>>>>>        Move False to bDeleteDummy
87077>>>>>>>        If (Num_Arguments = 8) Begin
87079>>>>>>>            Move aColumnIn to aColumns
87080>>>>>>>        End
87080>>>>>>>>
87080>>>>>>>        If ((SizeOfArray(aColumns)) = 0) Begin
87082>>>>>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
87083>>>>>>>            Move ColumnType.iSQLType to iDataType
87084>>>>>>>            If (bRecnum = False) Begin
87086>>>>>>>                Move C_tAPIColumn_Identity to iIdentityType
87087>>>>>>>            End
87087>>>>>>>>
87087>>>>>>>            Else Begin
87088>>>>>>>                Move C_tAPIColumn_None     to iIdentityType
87089>>>>>>>            End
87089>>>>>>>>
87089>>>>>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
87090>>>>>>>            Move True to bDeleteDummy
87091>>>>>>>        End
87091>>>>>>>>
87091>>>>>>>
87091>>>>>>>        // If columns have been passed as an array we need to check if an identity column
87091>>>>>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
87091>>>>>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
87091>>>>>>>        // two identity columns and SQL doesn't like that and throws an error.
87091>>>>>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
87093>>>>>>>            Move (SizeOfArray(aColumns)) to iSize
87094>>>>>>>            Decrement iSize
87095>>>>>>>            for iCount from 0 to iSize
87101>>>>>>>>
87101>>>>>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
87103>>>>>>>                    Move False to bRecnum
87104>>>>>>>                    Move iSize to iCount
87105>>>>>>>                End
87105>>>>>>>>
87105>>>>>>>            Loop
87106>>>>>>>>
87106>>>>>>>        End
87106>>>>>>>>
87106>>>>>>>
87106>>>>>>>        // If this is a SQL based driver we also check if the table exists
87106>>>>>>>        // in the SQL back end; in case we do nothing.
87106>>>>>>>        If (bSqlDriver = True) Begin
87108>>>>>>>            // Get all connection properties
87108>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
87109>>>>>>>            Move SQLConnection.sSchema to sSchema
87110>>>>>>>            If (sSchema = "") Begin
87112>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
87113>>>>>>>            End
87113>>>>>>>>
87113>>>>>>>
87113>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
87114>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
87114>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
87114>>>>>>>            If (bExists = False) Begin
87116>>>>>>>                Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
87117>>>>>>>            End
87117>>>>>>>>
87117>>>>>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
87117>>>>>>>            // we will just add it to Filelist.cfg
87117>>>>>>>            If (bExists = True) Begin
87119>>>>>>>                If (bExistsInFilelist = False) Begin
87121>>>>>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
87123>>>>>>>                        Move (sDriverID + ":" + sRootName) to sRootName
87124>>>>>>>                    End
87124>>>>>>>>
87124>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87127>>>>>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87130>>>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87133>>>>>>>                    Move False to bSysFile
87134>>>>>>>                    Get _SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
87135>>>>>>>                End
87135>>>>>>>>
87135>>>>>>>                Function_Return False
87136>>>>>>>            End
87136>>>>>>>>
87136>>>>>>>        End
87136>>>>>>>>
87136>>>>>>>
87136>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
87137>>>>>>>        If (num_arguments > 6) Begin
87139>>>>>>>            If (bANSI = False) Begin
87141>>>>>>>                Move CS_OEM_Txt to sANSI_OEM
87142>>>>>>>            End
87142>>>>>>>>
87142>>>>>>>        End
87142>>>>>>>>
87142>>>>>>>
87142>>>>>>>        Move False to Err
87143>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
87145>>>>>>>            Move sRootName to sPhysicalFile
87146>>>>>>>        End
87146>>>>>>>>
87146>>>>>>>
87146>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87148>>>>>>>            Move SQLConnection.sConnectionID to sConnectionID
87149>>>>>>>
87149>>>>>>>            // If DAW driver and we should use a connection id we need to
87149>>>>>>>            // check if the connection ID exists; else we create it before attempting creating the table
87149>>>>>>>            If (bUseConnectionID = True) Begin
87151>>>>>>>                Get IsConnectionID sConnectionID sDriverID to bExists
87152>>>>>>>                If (bExists = False) Begin
87154>>>>>>>                    Get AutoSetConnectionID sConnectionID to bOk
87155>>>>>>>                    If (bOk = False) Begin
87157>>>>>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
87158>>>>>>>>
87158>>>>>>>                        Function_Return False
87159>>>>>>>                    End
87159>>>>>>>>
87159>>>>>>>                End
87159>>>>>>>>
87159>>>>>>>            End
87159>>>>>>>>
87159>>>>>>>
87159>>>>>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
87161>>>>>>>                Move (sTableName + ".int") to sPhysicalFile
87162>>>>>>>            End
87162>>>>>>>>
87162>>>>>>>            Else Begin
87163>>>>>>>                Move (sRootName + ".int") to sPhysicalFile
87164>>>>>>>            End
87164>>>>>>>>
87164>>>>>>>            Move (Uppercase(sDisplayName)) to sVal
87165>>>>>>>//            If (not(sVal contains (sSchema + "."))) Begin
87165>>>>>>>//                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
87165>>>>>>>//            End
87165>>>>>>>        End
87165>>>>>>>>
87165>>>>>>>        Move False to Err
87166>>>>>>>        Move 0 to hFile
87167>>>>>>>
87167>>>>>>>        Structure_Start hFile sDriverID
87168>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
87170>>>>>>>                If (bUseConnectionID = True) Begin
87172>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
87175>>>>>>>                End
87175>>>>>>>>
87175>>>>>>>                Else Begin
87176>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
87179>>>>>>>                End
87179>>>>>>>>
87179>>>>>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
87182>>>>>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
87185>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
87188>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
87191>>>>>>>
87191>>>>>>>                If (sSchema <> "") Begin
87193>>>>>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
87196>>>>>>>                End
87196>>>>>>>>
87196>>>>>>>
87196>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
87198>>>>>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
87200>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
87203>>>>>>>                    End
87203>>>>>>>>
87203>>>>>>>                End
87203>>>>>>>>
87203>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
87205>>>>>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
87207>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
87210>>>>>>>                    End
87210>>>>>>>>
87210>>>>>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
87212>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
87215>>>>>>>                    End
87215>>>>>>>>
87215>>>>>>>                End
87215>>>>>>>>
87215>>>>>>>            End
87215>>>>>>>>
87215>>>>>>>
87215>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
87218>>>>>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
87219>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87220>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87222>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87223>>>>>>>
87223>>>>>>>        Move (not(Err)) to bOK
87224>>>>>>>        If (bOk = True) Begin
87226>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
87228>>>>>>>                Move (sDriverID + ":" + sRootName) to sRootName
87229>>>>>>>            End
87229>>>>>>>>
87229>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87232>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87235>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87238>>>>>>>
87238>>>>>>>            // Lastly we remove the temporary column we created above, if all went well.
87238>>>>>>>            If (bDeleteDummy) Begin
87240>>>>>>>                Get ApiColumnRemove hTable "temp" to bOk
87241>>>>>>>            End
87241>>>>>>>>
87241>>>>>>>        End
87241>>>>>>>>
87241>>>>>>>
87241>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
87242>>>>>>>        Close hTable
87243>>>>>>>        Function_Return bOK
87244>>>>>>>    End_Function
87245>>>>>>>
87245>>>>>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
87247>>>>>>>        Move False to Err
87248>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
87251>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
87254>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
87257>>>>>>>
87257>>>>>>>        Function_Return (Err = False)
87258>>>>>>>    End_Function
87259>>>>>>>
87259>>>>>>>    // ToDo: Needs to be revised
87259>>>>>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
87261>>>>>>>        Handle hTable
87261>>>>>>>        String sDEFName sDataPath
87261>>>>>>>        Boolean bExists
87261>>>>>>>
87261>>>>>>>        // Do nothing if MSSQL Driver.
87261>>>>>>>//        Get IsMSSQLDriver to bExists
87261>>>>>>>//        If (bExists = True) Begin
87261>>>>>>>//            Procedure_Return
87261>>>>>>>//        End
87261>>>>>>>
87261>>>>>>>        Get psDataPathFirstPart to sDataPath
87262>>>>>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
87263>>>>>>>        If (bExists = True) Begin
87265>>>>>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
87265>>>>>>>            // still be missing from the filelist and needs to be added.
87265>>>>>>>            Get _UtilTableNumberIsInUse iFilelistSlot to bExists
87266>>>>>>>            If (bExists = True) Begin
87268>>>>>>>                Procedure_Return
87269>>>>>>>            End
87269>>>>>>>>
87269>>>>>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
87269>>>>>>>            Else Begin
87270>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
87273>>>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
87276>>>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
87279>>>>>>>                Procedure_Return
87280>>>>>>>            End
87280>>>>>>>>
87280>>>>>>>        End
87280>>>>>>>>
87280>>>>>>>
87280>>>>>>>        Move (sPath + sFileName + ".def") to sDEFName
87281>>>>>>>        Move 0 to hTable
87282>>>>>>>        Move False to Err
87283>>>>>>>
87283>>>>>>>        Structure_Start hTable DATAFLEX_ID
87284>>>>>>>            Load_Def sDEFName Onto hTable
87285>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
87288>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87289>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87291>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87292>>>>>>>
87292>>>>>>>        Move iFilelistSlot to hTable
87293>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
87296>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
87299>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
87302>>>>>>>
87302>>>>>>>    End_Procedure
87303>>>>>>>
87303>>>>>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
87305>>>>>>>        Boolean bTmp bErr bOK
87305>>>>>>>        String sTableName sDisplayName sFileName
87305>>>>>>>
87305>>>>>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
87305>>>>>>>        Move Err to bTmp
87306>>>>>>>        Move False to Err
87307>>>>>>>
87307>>>>>>>        Get AutoConnectionIDLogin to bOK
87308>>>>>>>        // First get the info for the current filelist slot:
87308>>>>>>>        Open iFromFileSlot
87310>>>>>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
87313>>>>>>>        If (bOK = True) Begin
87315>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
87318>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
87321>>>>>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
87324>>>>>>>
87324>>>>>>>            //...then move it.
87324>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
87327>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
87330>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
87333>>>>>>>
87333>>>>>>>            //...and finally remove the old filelist values.
87333>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
87336>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
87339>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
87342>>>>>>>        End
87342>>>>>>>>
87342>>>>>>>        Close iFromFileSlot
87343>>>>>>>
87343>>>>>>>        Move Err to bErr
87344>>>>>>>        Move bTmp to Err
87345>>>>>>>        Function_Return (bErr = False)
87346>>>>>>>    End_Function
87347>>>>>>>
87347>>>>>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
87349>>>>>>>        Handle hTable
87349>>>>>>>        Boolean bOK
87349>>>>>>>        String sDriverID
87349>>>>>>>
87349>>>>>>>        Get _UtilTableExists hTableFrom to bOK
87350>>>>>>>        If (bOK = False) Begin
87352>>>>>>>            Set Private.phCurrentTable to hTableFrom
87353>>>>>>>            Error DFERR_PROGRAM ("Func: ApiTableRelate. From Table:" * String(hTableFrom) * "exists in Filelist.cfg but not on disk or SQL back-end.")
87354>>>>>>>>
87354>>>>>>>            Function_Return False
87355>>>>>>>        End
87355>>>>>>>>
87355>>>>>>>
87355>>>>>>>        Get _UtilTableExists hTableTo to bOK
87356>>>>>>>        If (bOK = False) Begin
87358>>>>>>>            Set Private.phCurrentTable to hTableTo
87359>>>>>>>            Error DFERR_PROGRAM ("Func: ApiTableRelate. To Table:" * String(hTableTo) * "exists in Filelist.cfg but not on disk or SQL back-end.")
87360>>>>>>>>
87360>>>>>>>            Function_Return False
87361>>>>>>>        End
87361>>>>>>>>
87361>>>>>>>
87361>>>>>>>        Get AutoConnectionIDLogin to bOK
87362>>>>>>>        Get UtilTableOpen hTableFrom "" DF_EXCLUSIVE to bOK
87363>>>>>>>        If (bOK = False) Begin
87365>>>>>>>            Function_Return False
87366>>>>>>>        End
87366>>>>>>>>
87366>>>>>>>
87366>>>>>>>        Move False to Err
87367>>>>>>>        Open hTableTo
87369>>>>>>>
87369>>>>>>>        Move hTableFrom to hTable
87370>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87373>>>>>>>        Set Private.phCurrentTable to hTable
87374>>>>>>>
87374>>>>>>>        Structure_Start hTable sDriverID
87375>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
87378>>>>>>>            If (iColumnTo <> 0) Begin
87380>>>>>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
87383>>>>>>>            End
87383>>>>>>>>
87383>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87384>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87386>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87387>>>>>>>
87387>>>>>>>        If (hTableTo > 0) Begin
87389>>>>>>>            Close hTableTo
87390>>>>>>>        End
87390>>>>>>>>
87390>>>>>>>
87390>>>>>>>        Function_Return (Err = False)
87391>>>>>>>    End_Function
87392>>>>>>>
87392>>>>>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
87392>>>>>>>    Function ApiTableRemove Handle hTable Returns Boolean
87394>>>>>>>        String sTableName sDriverID
87394>>>>>>>        Boolean bOk
87394>>>>>>>        String sDataPath
87394>>>>>>>
87394>>>>>>>        Get AutoConnectionIDLogin to bOK
87395>>>>>>>        Move False to Err
87396>>>>>>>        Get psDriverID to sDriverID
87397>>>>>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
87398>>>>>>>        If (sTableName = "") Begin
87400>>>>>>>            Function_Return False
87401>>>>>>>        End
87401>>>>>>>>
87401>>>>>>>
87401>>>>>>>        Set Private.phCurrentTable to hTable
87402>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
87403>>>>>>>        Delete_db sTableName
87404>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
87405>>>>>>>
87405>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87407>>>>>>>//            Get SqlTableRemoveByTableName sTableName to bOk  // We don't have to do this because the database is already removed by 'delete_db' above
87407>>>>>>>            Get psDataPathFirstPart to sDataPath
87408>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
87409>>>>>>>        End
87409>>>>>>>>
87409>>>>>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
87409>>>>>>>        If (hTable <> 0) Begin
87411>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
87414>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
87417>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
87420>>>>>>>        End
87420>>>>>>>>
87420>>>>>>>
87420>>>>>>>        Close hTable
87421>>>>>>>        Function_Return (hTable <> 0)
87422>>>>>>>    End_Function
87423>>>>>>>
87423>>>>>>>    Function ApiTableRemoveRelation Handle hTableFrom Integer iColumn Returns Boolean
87425>>>>>>>        Handle hTable
87425>>>>>>>        Boolean bOK
87425>>>>>>>
87425>>>>>>>        Get AutoConnectionIDLogin to bOK
87426>>>>>>>        Move False to Err
87427>>>>>>>        Open hTableFrom Mode DF_EXCLUSIVE
87429>>>>>>>        Move hTableFrom to hTable
87430>>>>>>>
87430>>>>>>>        Structure_Start hTable
87431>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
87434>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87435>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87437>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87438>>>>>>>
87438>>>>>>>        Close hTableFrom
87439>>>>>>>        Function_Return (Err = False)
87440>>>>>>>    End_Function
87441>>>>>>>
87441>>>>>>>    Function ApiTableRename Handle hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
87443>>>>>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
87443>>>>>>>        Boolean bOK bExists bOpened
87443>>>>>>>        tAPITableNameInfo APITableNameInfo
87443>>>>>>>        tAPITableNameInfo APITableNameInfo
87443>>>>>>>
87443>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
87446>>>>>>>        If (bOpened = False) Begin
87448>>>>>>>            Get OpenTableExclusive hTable to bOpened
87449>>>>>>>            If (bOpened = False) Begin
87451>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
87452>>>>>>>                Function_Return False
87453>>>>>>>            End
87453>>>>>>>>
87453>>>>>>>        End
87453>>>>>>>>
87453>>>>>>>
87453>>>>>>>        Set Private.phCurrentTable to hTable
87454>>>>>>>        Move hTable         to APITableNameInfo.iTableNumber
87455>>>>>>>        Move sRootName      to APITableNameInfo.sRootName
87456>>>>>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
87457>>>>>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
87458>>>>>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfo to bExists
87459>>>>>>>        If (bExists = True) Begin
87461>>>>>>>            Function_Return True
87462>>>>>>>        End
87462>>>>>>>>
87462>>>>>>>
87462>>>>>>>        Set Private.phCurrentTable to hTable
87463>>>>>>>        Move False to Err
87464>>>>>>>        Get psDataPathFirstPart to sDataPath
87465>>>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
87468>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
87471>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
87474>>>>>>>
87474>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87477>>>>>>>        Close hTable
87478>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
87480>>>>>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
87481>>>>>>>            If (bExists = True) Begin
87483>>>>>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
87485>>>>>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
87488>>>>>>>                    // We need a short break here before attempting to delete the physical old files or Windows
87488>>>>>>>                    // might report "File in use..." and the deletion will fail.
87488>>>>>>>                    Sleep 2
87489>>>>>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
87490>>>>>>>                End
87490>>>>>>>>
87490>>>>>>>            End
87490>>>>>>>>
87490>>>>>>>        End
87490>>>>>>>>
87490>>>>>>>
87490>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87492>>>>>>>            If (not(sPhysicalName contains ".")) Begin
87494>>>>>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
87495>>>>>>>            End
87495>>>>>>>>
87495>>>>>>>
87495>>>>>>>            // Change the table name in the .int file to the new table new:
87495>>>>>>>            Get _UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
87496>>>>>>>            If (bOK = False) Begin
87498>>>>>>>                Function_Return False
87499>>>>>>>            End
87499>>>>>>>>
87499>>>>>>>
87499>>>>>>>            // Change table name at the SQL side:
87499>>>>>>>            Get psSchema to sSchema
87500>>>>>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK
87501>>>>>>>
87501>>>>>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
87502>>>>>>>            // Remove cache file and Rename the physical file names:
87502>>>>>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK
87503>>>>>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
87504>>>>>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
87505>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
87506>>>>>>>
87506>>>>>>>            // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
87506>>>>>>>//            If (not(sDisplayName contains ".")) Begin
87506>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
87506>>>>>>>//            End
87506>>>>>>>        End
87506>>>>>>>>
87506>>>>>>>
87506>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87509>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87512>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87515>>>>>>>
87515>>>>>>>        Function_Return (Err = False)
87516>>>>>>>    End_Function
87517>>>>>>>
87517>>>>>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
87519>>>>>>>        Move False to Err
87520>>>>>>>        Set Private.phCurrentTable to hTable
87521>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87524>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87527>>>>>>>
87527>>>>>>>        Function_Return (Err = False)
87528>>>>>>>    End_Function
87529>>>>>>>
87529>>>>>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
87531>>>>>>>        Handle hTable
87531>>>>>>>        String sTableName
87531>>>>>>>        String sDriverIDFrom sDriverIDTo sLogicalNameTo
87531>>>>>>>        Integer iDbType
87531>>>>>>>        Boolean bOk bOpened bApiTableUpdateAuto bLogicalNameOK
87531>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
87531>>>>>>>        Boolean bIsSame bFilelistError bIsAliasFrom bIsSQLTableFrom bIsSQLTableTo
87531>>>>>>>        tSQLConnection SQLConnection
87531>>>>>>>        tSQLConnection SQLConnection
87531>>>>>>>        tAPITable      APITableFrom APITableTo
87531>>>>>>>        tAPITable      APITableFrom APITableTo
87531>>>>>>>        tColumnType    ColumnType
87531>>>>>>>        tColumnType    ColumnType
87531>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
87531>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
87532>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
87532>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
87533>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
87533>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
87534>>>>>>>
87534>>>>>>>        // We don't allow changes to the framework's DbVersion table.
87534>>>>>>>        If (Lowercase(sTableName) = "dbversion") Begin
87536>>>>>>>            Function_Return False
87537>>>>>>>        End
87537>>>>>>>>
87537>>>>>>>        
87537>>>>>>>        Move True to bOk
87538>>>>>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
87539>>>>>>>        Get piDbType                            to iDbType
87540>>>>>>>        Get pbRecnum                            to bRecnum
87541>>>>>>>        Get pbToANSI                            to bToANSI
87542>>>>>>>        Get pbCopyData                          to bCopyData
87543>>>>>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
87544>>>>>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
87545>>>>>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
87546>>>>>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase
87547>>>>>>>        Get pbUseConnectionID                   to bUseConnectionID
87548>>>>>>>
87548>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
87549>>>>>>>        Set Private.phCurrentTable              to hTable
87550>>>>>>>        Get _UtilTableExists  hTable            to bTableExists
87551>>>>>>>
87551>>>>>>>        If (ghoProgressBar <> 0) Begin
87553>>>>>>>            Send DoAdvance of ghoProgressBar
87554>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
87555>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
87556>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
87557>>>>>>>        End
87557>>>>>>>>
87557>>>>>>>
87557>>>>>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
87558>>>>>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
87559>>>>>>>        Get _UtilTableIsSql hTable              to bIsSQLTableTo
87560>>>>>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
87561>>>>>>>        Move True                               to APITableFrom.bFromTable
87562>>>>>>>        Move hTable                             to APITableFrom.hTable
87563>>>>>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
87564>>>>>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
87565>>>>>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
87566>>>>>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
87567>>>>>>>
87567>>>>>>>        // Check both the Filelist slot AND the LogicalName are the same! Else declare an error and break out of here!
87567>>>>>>>        If (bTableExists = True and sDriverIDTo <> DATAFLEX_ID) Begin
87569>>>>>>>            Get _SqlUtilCheckIfTableNameExists APITableFrom.ApiTableInfo.sLogicalName sDriverIDTo to bLogicalNameOK
87570>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
87571>>>>>>>            If (bOk = True and bLogicalNameOK = False) Begin
87573>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameTo
87576>>>>>>>                Error DFERR_PROGRAM ("The Filelist slot:" * String(hTable) * "exists on the client, but the Logical names are differnt! New Logical Name:" ;                                      * String(APITableFrom.ApiTableInfo.sLogicalName) * "existing Logical Name:" * String(sLogicalNameTo) * "- The file needs to be manually moved to another file slot (or removed) before this process can be started!")
87577>>>>>>>>
87577>>>>>>>                Function_Return False
87578>>>>>>>            End
87578>>>>>>>>
87578>>>>>>>        End
87578>>>>>>>>
87578>>>>>>>
87578>>>>>>>        If (bTableExists = True) Begin
87580>>>>>>>            If (bIsSQLTableTo = True) Begin
87582>>>>>>>                Get _UtilDeleteCacheFile APITableFrom.ApiTableInfo.sLogicalName to bOk
87583>>>>>>>            End
87583>>>>>>>>
87583>>>>>>>            Get OpenTableExclusive hTable to bOpened
87584>>>>>>>            If (bOpened = False) Begin
87586>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
87587>>>>>>>                Function_Return False
87588>>>>>>>            End
87588>>>>>>>>
87588>>>>>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
87589>>>>>>>            Get UtilColumnCombineFromAndToArrays   APITableFrom.aApiColumns   APITableTo.aApiColumns    to aAPIColumnCompare
87590>>>>>>>            Get UtilIndexCombineFromAndToArrays    APITableFrom.aApiIndexes   APITableTo.aApiIndexes    to aAPIIndexCompare
87591>>>>>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
87592>>>>>>>        End
87592>>>>>>>>
87592>>>>>>>
87592>>>>>>>        Move True to bOk
87593>>>>>>>        Move False to Err
87594>>>>>>>        Case Begin
87594>>>>>>>            // Alias table:
87594>>>>>>>            Case (bIsAliasFrom = True)
87596>>>>>>>                // Do nothing. Get _UtilTableCheckChangeFilelistNames is called below
87596>>>>>>>                Case Break
87597>>>>>>>
87597>>>>>>>            Case (bIsSQLTableFrom = True and bIsSQLTableTo = False and bTableExists = True)
87600>>>>>>>                    Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOk
87601>>>>>>>                    If (bOk = True) Begin
87603>>>>>>>                        Send LogError ("DataFlex table:" * String(APITableNameInfoFrom.sLogicalName) * "successfully converted to use driver:" * String(sDriverIDFrom)) False
87604>>>>>>>                    End
87604>>>>>>>>
87604>>>>>>>                Case Break
87605>>>>>>>            // New Table:
87605>>>>>>>            Case (bTableExists = False)
87608>>>>>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
87609>>>>>>>                //LR 20191112 Begin: Make file a system file if bIsSystemFile = True
87609>>>>>>>                If (APITableNameInfoFrom.bIsSystemFile) Begin
87611>>>>>>>                    Get ApiTableChangeAttribute hTable DF_FILE_IS_SYSTEM_FILE True to bOK
87612>>>>>>>                End                                                                 
87612>>>>>>>>
87612>>>>>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
87613>>>>>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
87614>>>>>>>                Case Break
87615>>>>>>>
87615>>>>>>>            // Update table:
87615>>>>>>>            Case (bTableExists = True)
87618>>>>>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
87619>>>>>>>                If (bIsSame = True) Begin
87621>>>>>>>                    Case Break
87622>>>>>>>                End
87622>>>>>>>>
87622>>>>>>>                If (bFilelistError = True) Begin
87624>>>>>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
87625>>>>>>>                    If (bOk = False) Begin
87627>>>>>>>                        Case Break
87628>>>>>>>                    End
87628>>>>>>>>
87628>>>>>>>                End
87628>>>>>>>>
87628>>>>>>>
87628>>>>>>>                If (ghoProgressBar <> 0) Begin
87630>>>>>>>                    Send DoAdvance of ghoProgressBar
87631>>>>>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
87632>>>>>>>                End
87632>>>>>>>>
87632>>>>>>>
87632>>>>>>>                // Columns:
87632>>>>>>>                Move True to bOk
87633>>>>>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
87634>>>>>>>                If (bIsSame = False) Begin
87636>>>>>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
87637>>>>>>>                End
87637>>>>>>>>
87637>>>>>>>                If (bOk = False) Begin
87639>>>>>>>                    Case Break
87640>>>>>>>                End
87640>>>>>>>>
87640>>>>>>>
87640>>>>>>>                // Indexes:
87640>>>>>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
87641>>>>>>>                If (bIsSame = False) Begin
87643>>>>>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
87644>>>>>>>                End
87644>>>>>>>>
87644>>>>>>>
87644>>>>>>>                // Relations:
87644>>>>>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
87645>>>>>>>                If (bIsSame = False) Begin
87647>>>>>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
87648>>>>>>>                    If (bOk = False) Begin
87650>>>>>>>                        Case Break
87651>>>>>>>                    End
87651>>>>>>>>
87651>>>>>>>                End
87651>>>>>>>>
87651>>>>>>>
87651>>>>>>>                Case Break
87652>>>>>>>
87652>>>>>>>            Case Else
87652>>>>>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
87653>>>>>>>>
87653>>>>>>>                Move False to bOk
87654>>>>>>>        Case End
87654>>>>>>>        
87654>>>>>>>        If (bOk = True) Begin
87656>>>>>>>            // Note: If the from table was SQL; we should either connect to an existing SQL to table,
87656>>>>>>>            // or convert an embedded table to SQL
87656>>>>>>>            If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87658>>>>>>>                Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
87659>>>>>>>                If (bOk = False) Begin
87661>>>>>>>                    Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOK
87662>>>>>>>                End
87662>>>>>>>>
87662>>>>>>>            End
87662>>>>>>>>
87662>>>>>>>            Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
87665>>>>>>>                Get SqlTableConvertToEmbedded hTable True to bOk
87666>>>>>>>            End
87666>>>>>>>>
87666>>>>>>>            
87666>>>>>>>            // Filelist Names:
87666>>>>>>>            Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
87667>>>>>>>        End
87667>>>>>>>>
87667>>>>>>>        
87667>>>>>>>        Close hTable
87668>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
87669>>>>>>>
87669>>>>>>>        Function_Return bOK
87670>>>>>>>    End_Function
87671>>>>>>>
87671>>>>>>>    // * Dummy function for the Studio's Code Explorer *
87671>>>>>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
87673>>>>>>>        Function_Return False
87674>>>>>>>    End_Function
87675>>>>>>>
87675>>>>>>>    // Adds a column name to the passed table number.
87675>>>>>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
87677>>>>>>>        Integer iColumn iCount iFile iPrecision iLastErr
87677>>>>>>>        Boolean bExists bOK bInitializeValue bRetval
87677>>>>>>>        String sDataPath sDdSrcPath sTableName sColumnValue sDriverID
87677>>>>>>>
87677>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
87678>>>>>>>        If (bExists = True) Begin
87680>>>>>>>            Function_Return False
87681>>>>>>>        End
87681>>>>>>>>
87681>>>>>>>
87681>>>>>>>        Move False to Err
87682>>>>>>>        If (num_arguments > 4) Begin
87684>>>>>>>            Move iPrec to iPrecision
87685>>>>>>>        End
87685>>>>>>>>
87685>>>>>>>        If (num_arguments > 6) Begin
87687>>>>>>>            Move bInitVal to bInitializeValue
87688>>>>>>>            Move sColVal  to sColumnValue
87689>>>>>>>        End
87689>>>>>>>>
87689>>>>>>>        If (iType < -1490) Begin
87691>>>>>>>            Move (iType + 1500) to iType
87692>>>>>>>        End
87692>>>>>>>>
87692>>>>>>>
87692>>>>>>>        Move hTable to iFile
87693>>>>>>>        Get psDriverID to sDriverID
87694>>>>>>>        Get AutoConnectionIDLogin to bOK
87695>>>>>>>        Move False to Err
87696>>>>>>>        Move LastErr to iLastErr
87697>>>>>>>        Get OpenTableExclusive iFile to bOK
87698>>>>>>>        Set Private.phCurrentTable to hTable
87699>>>>>>>
87699>>>>>>>        Structure_Start iFile sDriverID
87700>>>>>>>            Move 0 to iColumn
87701>>>>>>>            Set Private.piCurrentField to iColumn
87702>>>>>>>            Create_Field hTable At iColumn
87703>>>>>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
87706>>>>>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
87709>>>>>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
87712>>>>>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
87715>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87716>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87718>>>>>>>
87718>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87719>>>>>>>
87719>>>>>>>        // If in development environment; create .fd file:
87719>>>>>>>        Open hTable
87721>>>>>>>        Get psDdSrcPath  of (phoWorkspace(ghoApplication)) to sDDSrcPath
87722>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87723>>>>>>>        If (iCount > 1) Begin
87725>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87726>>>>>>>        End
87726>>>>>>>>
87726>>>>>>>        Get vFolderExists sDDSrcPath to bExists
87727>>>>>>>        If (bExists = True) Begin
87729>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87730>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87733>>>>>>>            Get _TableNameOnly sTableName to sTableName
87734>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87736>>>>>>>        End
87736>>>>>>>>
87736>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin  // We only want a tag if DataFlex embedded db
87738>>>>>>>            Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
87739>>>>>>>            Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
87740>>>>>>>            If (iCount > 1) Begin
87742>>>>>>>                Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
87743>>>>>>>            End
87743>>>>>>>>
87743>>>>>>>            Get vFolderFormat sDataPath to sDataPath
87744>>>>>>>            // Add the new column name to the .tag filen (if it doesn't exist):
87744>>>>>>>            // The following line should not be necexxary for the DataFlex driver. (Thank you, Hans van de Laar)
87744>>>>>>>            //Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sFieldName to bOK
87744>>>>>>>        End
87744>>>>>>>>
87744>>>>>>>        // Check for a default value
87744>>>>>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
87746>>>>>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
87747>>>>>>>        End
87747>>>>>>>>
87747>>>>>>>        Close hTable
87748>>>>>>>
87748>>>>>>>        Function_Return (Err = False)
87749>>>>>>>    End_Function
87750>>>>>>>
87750>>>>>>>    // Adds a column name to the passed table number.
87750>>>>>>>    Function ApiColumnInsert String sDriverIDFrom Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
87752>>>>>>>        Integer iCount iFile iPrecision iNumberOfFields iDbType
87752>>>>>>>        Boolean bExists bOK bIsDateType bIsSQLTypeTo
87752>>>>>>>        String sDdSrcPath sTableName
87752>>>>>>>
87752>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
87753>>>>>>>        Move False to Err
87754>>>>>>>        If (bExists = True) Begin
87756>>>>>>>            Function_Return False
87757>>>>>>>        End
87757>>>>>>>>
87757>>>>>>>        If (num_arguments > 4) Begin
87759>>>>>>>            Move iPrec to iPrecision
87760>>>>>>>        End
87760>>>>>>>>
87760>>>>>>>        If (iType < -1490) Begin
87762>>>>>>>            Move (iType + 1500) to iType
87763>>>>>>>        End
87763>>>>>>>>
87763>>>>>>>
87763>>>>>>>        Get AutoConnectionIDLogin to bOK
87764>>>>>>>        Move False to Err
87765>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTypeTo
87766>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
87766>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types. 
87766>>>>>>>        Get piDbType to iDbType
87767>>>>>>>        If (bIsSQLTypeTo = False) Begin
87769>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iType iLength to iType
87770>>>>>>>            If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87772>>>>>>>                Move DF_DATE to iType
87773>>>>>>>            End
87773>>>>>>>>
87773>>>>>>>        End
87773>>>>>>>>
87773>>>>>>>
87773>>>>>>>        // Structure_start will change the value of hTable...
87773>>>>>>>        Move hTable to iFile
87774>>>>>>>        Get OpenTableExclusive iFile to bOK
87775>>>>>>>        If (bOK = False) Begin
87777>>>>>>>            Function_Return False
87778>>>>>>>        End
87778>>>>>>>>
87778>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
87781>>>>>>>
87781>>>>>>>        // If the passed column number is higher than the current number of fields
87781>>>>>>>        // in the table, this means we should _not_ insert a field but rather add
87781>>>>>>>        // a new field to the end:
87781>>>>>>>        If (iColumn > iNumberOfFields) Begin
87783>>>>>>>            Move 0 to iColumn
87784>>>>>>>        End
87784>>>>>>>>
87784>>>>>>>
87784>>>>>>>        Set Private.phCurrentTable to hTable
87785>>>>>>>        Set Private.piCurrentField to iColumn
87786>>>>>>>
87786>>>>>>>        Structure_Start iFile
87787>>>>>>>            Create_Field iFile At iColumn
87788>>>>>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
87791>>>>>>>            If (bIsSQLTypeTo = False) Begin
87793>>>>>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
87796>>>>>>>            End
87796>>>>>>>>
87796>>>>>>>            Else Begin
87797>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
87800>>>>>>>            End
87800>>>>>>>>
87800>>>>>>>            Get UtilColumnIsDateType iType bIsSQLTypeTo to bIsDateType
87801>>>>>>>            If (bIsDateType = False) Begin
87803>>>>>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
87806>>>>>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
87809>>>>>>>            End
87809>>>>>>>>
87809>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87810>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87812>>>>>>>
87812>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87813>>>>>>>        // If in development environment; create .fd file:
87813>>>>>>>        Open hTable
87815>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
87816>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87817>>>>>>>        If (iCount > 1) Begin
87819>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87820>>>>>>>        End
87820>>>>>>>>
87820>>>>>>>        Get vFolderExists sDDSrcPath to bExists
87821>>>>>>>        If (bExists = True) Begin
87823>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87824>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87827>>>>>>>            Get _TableNameOnly sTableName to sTableName
87828>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87830>>>>>>>        End
87830>>>>>>>>
87830>>>>>>>
87830>>>>>>>        // Check for a default value
87830>>>>>>>        Close hTable
87831>>>>>>>
87831>>>>>>>        Function_Return (Err = False)
87832>>>>>>>    End_Function
87833>>>>>>>
87833>>>>>>>    // To update all records for a table column with a fixed value.
87833>>>>>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
87835>>>>>>>        Integer iRecs iCurrErr iField iRecord
87835>>>>>>>        Boolean bRetval bOpen
87835>>>>>>>
87835>>>>>>>        Move 0 to iRecs
87836>>>>>>>        Move False to bRetval
87837>>>>>>>        Move Err to iCurrErr
87838>>>>>>>        Move False to Err
87839>>>>>>>
87839>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
87842>>>>>>>        If (bOpen = False) Begin
87844>>>>>>>            Open hTable
87846>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
87849>>>>>>>            If (bOpen = False) Begin
87851>>>>>>>                Function_Return bRetval
87852>>>>>>>            End
87852>>>>>>>>
87852>>>>>>>        End
87852>>>>>>>>
87852>>>>>>>
87852>>>>>>>        Field_Map hTable sFieldName to iField
87854>>>>>>>        If (iField <> 0) Begin
87856>>>>>>>            Set Private.phCurrentTable to hTable
87857>>>>>>>            Set Private.piCurrentField to iField
87858>>>>>>>            Clear hTable
87859>>>>>>>            Repeat
87859>>>>>>>>
87859>>>>>>>                Vfind hTable 0 GT
87861>>>>>>>                If (Found) Begin
87863>>>>>>>                    If (ghoStatusPanel <> 0) Begin
87865>>>>>>>                        Get_Field_Value hTable 0 to iRecord
87868>>>>>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_DUF_UpdateVersion * String(iRecord))
87869>>>>>>>                    End
87869>>>>>>>>
87869>>>>>>>                    Reread hTable
87873>>>>>>>                        Set_Field_Value hTable iField to sColumnValue
87876>>>>>>>                        SaveRecord hTable
87877>>>>>>>                    Unlock
87878>>>>>>>>
87878>>>>>>>                End
87878>>>>>>>>
87878>>>>>>>           Until (not(Found))
87880>>>>>>>        End
87880>>>>>>>>
87880>>>>>>>
87880>>>>>>>        Move (Err = False) to bRetval
87881>>>>>>>        Move iCurrErr to Err
87882>>>>>>>
87882>>>>>>>        Function_Return bRetval
87883>>>>>>>    End_Function
87884>>>>>>>
87884>>>>>>>    // Note: This can only be used from within a Structure_Start/End construct.
87884>>>>>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
87886>>>>>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
87886>>>>>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
87886>>>>>>>        String sFieldName sDriverID sTableName sDefaultValue
87886>>>>>>>
87886>>>>>>>        Get psDriverID to sDriverID
87887>>>>>>>        Get piDbType to iDbType
87888>>>>>>>        Get UtilTableHandleToString hTable to sTableName
87889>>>>>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
87890>>>>>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
87891>>>>>>>        Get _UtilTableIsSql hTable to bIsSqlTable
87892>>>>>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
87894>>>>>>>            Move True to bIsSqlTable
87895>>>>>>>        End
87895>>>>>>>>
87895>>>>>>>        Move False to bIsOpen
87896>>>>>>>        If (hTable > 0) Begin
87898>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87901>>>>>>>        End
87901>>>>>>>>
87901>>>>>>>        If (bIsOpen = True) Begin
87903>>>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
87906>>>>>>>        End
87906>>>>>>>>
87906>>>>>>>        Else Begin
87907>>>>>>>            Get pbRecnum to bRecnumTable
87908>>>>>>>        End
87908>>>>>>>>
87908>>>>>>>
87908>>>>>>>        Move False to Err
87909>>>>>>>        Move (SizeOfArray(aColumns)) to iSize
87910>>>>>>>        Decrement iSize
87911>>>>>>>        for iCount from 0 to iSize
87917>>>>>>>>
87917>>>>>>>            Move aColumns[iCount].sFieldName to sFieldName
87918>>>>>>>            If (hTable > 0) Begin
87920>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87921>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87922>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
87925>>>>>>>                Move (Trim(sFieldName) <> "") to bFieldExists
87926>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
87927>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87928>>>>>>>            End
87928>>>>>>>>
87928>>>>>>>            Else Begin
87929>>>>>>>                Move False to bFieldExists
87930>>>>>>>            End
87930>>>>>>>>
87930>>>>>>>
87930>>>>>>>            If (bFieldExists = False) Begin
87932>>>>>>>                Move 0 to iColumn
87933>>>>>>>                Create_Field hTable At iColumn
87934>>>>>>>            End
87934>>>>>>>>
87934>>>>>>>            Else Begin
87935>>>>>>>                Move iCount to iColumn
87936>>>>>>>            End
87936>>>>>>>>
87936>>>>>>>
87936>>>>>>>            Set Private.piCurrentField to iColumn
87937>>>>>>>
87937>>>>>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
87938>>>>>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
87941>>>>>>>
87941>>>>>>>            Move aColumns[iCount].iType to iType
87942>>>>>>>            Move (not(iType < -1490)) to bNativeType
87943>>>>>>>            If (iType < -1490) Begin
87945>>>>>>>                Move (iType + 1500) to iType
87946>>>>>>>            End
87946>>>>>>>>
87946>>>>>>>
87946>>>>>>>            If (bIsSqlTable = True) Begin
87948>>>>>>>                If (aColumns[iCount].bIsSQLType = True) Begin
87950>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
87951>>>>>>>//                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
87951>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType
87954>>>>>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
87957>>>>>>>
87957>>>>>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
87958>>>>>>>                    If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
87960>>>>>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
87961>>>>>>>                    End
87961>>>>>>>>
87961>>>>>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue
87964>>>>>>>
87964>>>>>>>                End
87964>>>>>>>>
87964>>>>>>>                Else Begin
87965>>>>>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
87968>>>>>>>                End
87968>>>>>>>>
87968>>>>>>>            End
87968>>>>>>>>
87968>>>>>>>            Else Begin
87969>>>>>>>                If (bCreating = False) Begin
87971>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
87972>>>>>>>                    If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87974>>>>>>>                        Move DF_DATE to iType
87975>>>>>>>                    End
87975>>>>>>>>
87975>>>>>>>                End
87975>>>>>>>>
87975>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
87978>>>>>>>            End
87978>>>>>>>>
87978>>>>>>>
87978>>>>>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
87979>>>>>>>            If (bIsDateType = False) Begin
87981>>>>>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
87984>>>>>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
87987>>>>>>>            End
87987>>>>>>>>
87987>>>>>>>
87987>>>>>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
87989>>>>>>>                Move 0 to iIndex
87990>>>>>>>                Create_Index hTable at iIndex
87991>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
87994>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
87997>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
88000>>>>>>>
88000>>>>>>>                // If we have an identity table - we must create a primary_key table.
88000>>>>>>>                If (bIsSqlTable = True) Begin
88002>>>>>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to True
88005>>>>>>>                        Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True
88008>>>>>>>                End
88008>>>>>>>>
88008>>>>>>>            End
88008>>>>>>>>
88008>>>>>>>        Loop
88009>>>>>>>>
88009>>>>>>>
88009>>>>>>>        Function_Return (Err = False)
88010>>>>>>>    End_Function
88011>>>>>>>
88011>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
88011>>>>>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
88013>>>>>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
88013>>>>>>>        Boolean bOK bIsSqlTable
88013>>>>>>>        String sFieldNameTo
88013>>>>>>>
88013>>>>>>>        If (num_arguments > 4) Begin
88015>>>>>>>            Move iPrec to iPrecFrom
88016>>>>>>>        End
88016>>>>>>>>
88016>>>>>>>        If (iTypeFrom < -1490) Begin
88018>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
88019>>>>>>>        End
88019>>>>>>>>
88019>>>>>>>
88019>>>>>>>        Get AutoConnectionIDLogin to bOK
88020>>>>>>>        Move False to Err
88021>>>>>>>        Get OpenTableExclusive hTable to bOK
88022>>>>>>>        If (bOK = False) Begin
88024>>>>>>>            Function_Return False
88025>>>>>>>        End
88025>>>>>>>>
88025>>>>>>>
88025>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88026>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88027>>>>>>>        Field_Map hTable sFieldNameFrom to iColumn
88029>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88030>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88031>>>>>>>        If (Err = True) Begin
88033>>>>>>>            Function_Return False
88034>>>>>>>        End
88034>>>>>>>>
88034>>>>>>>
88034>>>>>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
88037>>>>>>>        Get _UtilTableIsSql hTable to bIsSqlTable
88038>>>>>>>        If (bIsSqlTable = False) Begin
88040>>>>>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
88043>>>>>>>        End
88043>>>>>>>>
88043>>>>>>>        Else Begin
88044>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
88047>>>>>>>        End
88047>>>>>>>>
88047>>>>>>>        // Let the driver decide the other values;
88047>>>>>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
88050>>>>>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
88053>>>>>>>
88053>>>>>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
88055>>>>>>>            Function_Return False
88056>>>>>>>        End
88056>>>>>>>>
88056>>>>>>>
88056>>>>>>>        Set Private.phCurrentTable to hTable
88057>>>>>>>        Set Private.piCurrentField to iColumn
88058>>>>>>>
88058>>>>>>>        Structure_Start hTable
88059>>>>>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
88062>>>>>>>            If (bIsSqlTable = False) Begin
88064>>>>>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
88067>>>>>>>            End
88067>>>>>>>>
88067>>>>>>>            Else Begin
88068>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
88071>>>>>>>            End
88071>>>>>>>>
88071>>>>>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to (iLengthFrom + iPrecFrom)
88074>>>>>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
88077>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88078>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88080>>>>>>>
88080>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88081>>>>>>>        Function_Return (Err = False)
88082>>>>>>>    End_Function
88083>>>>>>>
88083>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
88083>>>>>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
88085>>>>>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
88085>>>>>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
88085>>>>>>>        String sFieldNameTo sDriverIDTo
88085>>>>>>>        tColumnType ColumnType
88085>>>>>>>        tColumnType ColumnType
88085>>>>>>>
88085>>>>>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
88086>>>>>>>        Get piDbType to iDbType
88087>>>>>>>        If (num_arguments > 4) Begin
88089>>>>>>>            Move iPrec to iPrecFrom
88090>>>>>>>            Move iOpt  to iOptionFrom
88091>>>>>>>        End
88091>>>>>>>>
88091>>>>>>>        If (iTypeFrom < -1490) Begin
88093>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
88094>>>>>>>        End
88094>>>>>>>>
88094>>>>>>>
88094>>>>>>>        Get AutoConnectionIDLogin to bOK
88095>>>>>>>        Move False to Err
88096>>>>>>>        Close hTable
88097>>>>>>>        Get OpenTableExclusive hTable to bOK
88098>>>>>>>        If (bOK = False) Begin
88100>>>>>>>            Function_Return False
88101>>>>>>>        End
88101>>>>>>>>
88101>>>>>>>
88101>>>>>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
88104>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
88107>>>>>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
88108>>>>>>>        If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88110>>>>>>>            Move DF_DATE to iDataFlexType
88111>>>>>>>        End
88111>>>>>>>>
88111>>>>>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
88114>>>>>>>
88114>>>>>>>        If (bIsSQLTableTo = True) Begin
88116>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeTo
88119>>>>>>>        End
88119>>>>>>>>
88119>>>>>>>        Else Begin
88120>>>>>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
88123>>>>>>>        End
88123>>>>>>>>
88123>>>>>>>
88123>>>>>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
88126>>>>>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
88129>>>>>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo
88132>>>>>>>
88132>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
88132>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types.
88132>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
88134>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeTo
88135>>>>>>>            If (iTypeTo = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88137>>>>>>>                Move DF_DATE to iTypeTo  
88138>>>>>>>            End
88138>>>>>>>>
88138>>>>>>>        End
88138>>>>>>>>
88138>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
88141>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeFrom
88142>>>>>>>        End
88142>>>>>>>>
88142>>>>>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
88143>>>>>>>
88143>>>>>>>        If (bCompareDate_DateTime = False) Begin
88145>>>>>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
88146>>>>>>>            If (bSkip = True) Begin
88148>>>>>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
88150>>>>>>>                    Function_Return True
88151>>>>>>>                End
88151>>>>>>>>
88151>>>>>>>            End
88151>>>>>>>>
88151>>>>>>>        End
88151>>>>>>>>
88151>>>>>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
88154>>>>>>>            Function_Return True
88155>>>>>>>        End
88155>>>>>>>>
88155>>>>>>>
88155>>>>>>>        Set Private.phCurrentTable to hTable
88156>>>>>>>        Set Private.piCurrentField to iColumn
88157>>>>>>>
88157>>>>>>>        Structure_Start hTable
88158>>>>>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
88160>>>>>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
88163>>>>>>>            End
88163>>>>>>>>
88163>>>>>>>
88163>>>>>>>            If (bIsSameDataType = False) Begin
88165>>>>>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
88168>>>>>>>                If (bIsSQLTableTo = True) Begin
88170>>>>>>>                        Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iTypeFrom
88173>>>>>>>                End
88173>>>>>>>>
88173>>>>>>>            End
88173>>>>>>>>
88173>>>>>>>
88173>>>>>>>            If (iLengthFrom <> iLengthTo) Begin
88175>>>>>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
88178>>>>>>>            End
88178>>>>>>>>
88178>>>>>>>            If (iPrecFrom <> iPrecTo) Begin
88180>>>>>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
88183>>>>>>>            End
88183>>>>>>>>
88183>>>>>>>
88183>>>>>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
88185>>>>>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
88185>>>>>>>                If (bRecnumTable = True) Begin
88187>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
88190>>>>>>>                End
88190>>>>>>>>
88190>>>>>>>
88190>>>>>>>                // We might need to create an index here.
88190>>>>>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
88190>>>>>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
88190>>>>>>>                // index update checking logic.
88190>>>>>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
88193>>>>>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
88195>>>>>>>                    Create_Index hTable At iIndex
88196>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
88199>>>>>>>                End
88199>>>>>>>>
88199>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
88202>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
88205>>>>>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
88208>>>>>>>                If (bIsSQLTableTo = True) Begin
88210>>>>>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
88213>>>>>>>                End
88213>>>>>>>>
88213>>>>>>>            End
88213>>>>>>>>
88213>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88214>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88216>>>>>>>
88216>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88217>>>>>>>        Function_Return (Err = False)
88218>>>>>>>    End_Function
88219>>>>>>>
88219>>>>>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
88221>>>>>>>        Boolean bOK
88221>>>>>>>
88221>>>>>>>        Get AutoConnectionIDLogin to bOK
88222>>>>>>>        Move False to Err
88223>>>>>>>        Get OpenTableExclusive hTable to bOK
88224>>>>>>>        If (bOK = False) Begin
88226>>>>>>>            Function_Return False
88227>>>>>>>        End
88227>>>>>>>>
88227>>>>>>>
88227>>>>>>>        Structure_Start hTable
88228>>>>>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
88231>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88232>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88234>>>>>>>
88234>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88235>>>>>>>        Function_Return (Err = False)
88236>>>>>>>    End_Function
88237>>>>>>>
88237>>>>>>>    // To move an existing field to another position in a table.
88237>>>>>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Integer iLength Integer iPrecision Returns Boolean
88239>>>>>>>        String sColumn sDriverID
88239>>>>>>>        Integer iType iSQLType
88239>>>>>>>        Boolean bOK bIsDate
88239>>>>>>>
88239>>>>>>>        Close hTable
88240>>>>>>>        Get AutoConnectionIDLogin to bOK
88241>>>>>>>        Get OpenTableExclusive hTable to bOK
88242>>>>>>>        If (bOK = False) Begin
88244>>>>>>>            Function_Return False
88245>>>>>>>        End
88245>>>>>>>>
88245>>>>>>>
88245>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88248>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
88250>>>>>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
88251>>>>>>>>
88251>>>>>>>            Function_Return False
88252>>>>>>>        End
88252>>>>>>>>
88252>>>>>>>
88252>>>>>>>        Set Action_Text of ghoStatusPanel to "Restructures table..."
88253>>>>>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
88256>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
88259>>>>>>>        If (bIsSQLType = True) Begin
88261>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iOld to iSQLType
88264>>>>>>>            Get UtilColumnIsDateType iSQLType bIsSQLType  to bIsDate
88265>>>>>>>        End
88265>>>>>>>>
88265>>>>>>>        Else Begin
88266>>>>>>>            Get UtilColumnIsDateType iType bIsSQLType  to bIsDate
88267>>>>>>>        End
88267>>>>>>>>
88267>>>>>>>
88267>>>>>>>        Set Private.phCurrentTable to hTable
88268>>>>>>>        Set Private.piCurrentField to iOld
88269>>>>>>>
88269>>>>>>>        Move False to Err
88270>>>>>>>
88270>>>>>>>        Structure_Start hTable
88271>>>>>>>            Delete_Field hTable iOld
88272>>>>>>>            Create_Field hTable At iNew
88273>>>>>>>            
88273>>>>>>>            // This one is the crucial line:
88273>>>>>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
88276>>>>>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
88279>>>>>>>            
88279>>>>>>>            // If SQL table it is important that we don't try to change the field type, as MS-SQL then will generate an error.
88279>>>>>>>            If (bIsSQLType = True and bIsDate = False) Begin
88281>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType
88284>>>>>>>            End
88284>>>>>>>>
88284>>>>>>>            If (bIsDate = False) Begin
88286>>>>>>>                Set_Attribute DF_FIELD_TYPE   of hTable iNew to iType
88289>>>>>>>                Set_Attribute DF_FIELD_LENGTH of hTable iNew to iLength
88292>>>>>>>            End
88292>>>>>>>>
88292>>>>>>>            If (iType = DF_BCD) Begin
88294>>>>>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
88297>>>>>>>            End
88297>>>>>>>>
88297>>>>>>>
88297>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88299>>>>>>>
88299>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88300>>>>>>>        Move (not(Err)) to bOK
88301>>>>>>>        Move False to Err
88302>>>>>>>        Move 0 to LastErr
88303>>>>>>>        Function_Return bOK
88304>>>>>>>    End_Function 
88305>>>>>>>    
88305>>>>>>>    // Deletes a column name for the passed table number (and column number).
88305>>>>>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
88307>>>>>>>        Integer iColumn
88307>>>>>>>        Boolean bOK
88307>>>>>>>
88307>>>>>>>        Get AutoConnectionIDLogin to bOK
88308>>>>>>>        Move False to Err
88309>>>>>>>        Close hTable
88310>>>>>>>        Get OpenTableExclusive hTable to bOK
88311>>>>>>>        If (bOK = False) Begin
88313>>>>>>>            Function_Return False
88314>>>>>>>        End
88314>>>>>>>>
88314>>>>>>>
88314>>>>>>>        If (not(Err)) Begin
88316>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88317>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88318>>>>>>>            Field_Map hTable sFieldName to iColumn
88320>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
88321>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88322>>>>>>>            If (iColumn = 0) Begin
88324>>>>>>>                Move 0 to LastErr
88325>>>>>>>                Function_Return False
88326>>>>>>>            End
88326>>>>>>>>
88326>>>>>>>            Move False to Err
88327>>>>>>>
88327>>>>>>>            Set Private.phCurrentTable to hTable
88328>>>>>>>            Set Private.piCurrentField to iColumn
88329>>>>>>>
88329>>>>>>>            Structure_Start hTable
88330>>>>>>>                Delete_Field hTable iColumn
88331>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88332>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88334>>>>>>>            Set Action_Text of ghoStatusPanel to ""
88335>>>>>>>        End
88335>>>>>>>>
88335>>>>>>>        Else Begin
88336>>>>>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
88337>>>>>>>>
88337>>>>>>>        End
88337>>>>>>>>
88337>>>>>>>
88337>>>>>>>        Function_Return (Err = False)
88338>>>>>>>    End_Function
88339>>>>>>>
88339>>>>>>>    // Renames a field for the passed table number & old field name & new field name
88339>>>>>>>    // Returns True if no errors occured.
88339>>>>>>>    // Sample usage:
88339>>>>>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
88339>>>>>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
88341>>>>>>>        Integer iField
88341>>>>>>>        Boolean bOK bExists bIsOpen
88341>>>>>>>
88341>>>>>>>        Get UtilColumnExists hTable sNewFieldName to bExists
88342>>>>>>>        If (bExists = True) Begin
88344>>>>>>>            Function_Return False
88345>>>>>>>        End
88345>>>>>>>>
88345>>>>>>>
88345>>>>>>>        // Note: The Field_Map command does _not_ work if the table has been
88345>>>>>>>        //       opened exclusively, so we first open it in normal mode.
88345>>>>>>>        Close hTable
88346>>>>>>>        Open hTable
88348>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88351>>>>>>>        If (bIsOpen = False) Begin
88353>>>>>>>            Function_Return False
88354>>>>>>>        End
88354>>>>>>>>
88354>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88355>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88356>>>>>>>        Field_Map hTable sOldFieldName to iField
88358>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88359>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88360>>>>>>>
88360>>>>>>>        Get AutoConnectionIDLogin to bOK
88361>>>>>>>        Get OpenTableExclusive hTable to bOK
88362>>>>>>>        If (bOK = False) Begin
88364>>>>>>>            Function_Return False
88365>>>>>>>        End
88365>>>>>>>>
88365>>>>>>>
88365>>>>>>>        Move False to Err
88366>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
88367>>>>>>>        Set Private.phCurrentTable to hTable
88368>>>>>>>        Set Private.piCurrentField to iField
88369>>>>>>>
88369>>>>>>>        If (iField > 0) Begin
88371>>>>>>>            Structure_Start hTable
88372>>>>>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
88375>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88376>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88378>>>>>>>        End
88378>>>>>>>>
88378>>>>>>>        Else Begin
88379>>>>>>>            Move 0 to LastErr
88380>>>>>>>            Move False to Err
88381>>>>>>>        End
88381>>>>>>>>
88381>>>>>>>
88381>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88382>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
88383>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88384>>>>>>>
88384>>>>>>>        Function_Return (Err = False)
88385>>>>>>>    End_Function
88386>>>>>>>
88386>>>>>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
88388>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
88388>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
88389>>>>>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo iColumnNumber
88389>>>>>>>        Boolean bRenameField
88389>>>>>>>
88389>>>>>>>        Open hTable
88391>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88392>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88393>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88394>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
88397>>>>>>>        Move (iSize max iNumberOfFieldsTo) to iSize
88398>>>>>>>        Decrement iSize
88399>>>>>>>        for iCount from 0 to iSize
88405>>>>>>>>
88405>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
88407>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88408>>>>>>>
88408>>>>>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
88410>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iFieldTo = 0) Begin
88412>>>>>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iColumnNumber
88413>>>>>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount]      to bRenameField
88414>>>>>>>                    If (iColumnNumber = -1 and bRenameField = False) Begin
88416>>>>>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber
88417>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
88418>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom
88419>>>>>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
88420>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
88421>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
88422>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
88423>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
88424>>>>>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
88425>>>>>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
88426>>>>>>>                        Increment iItem
88427>>>>>>>                    End
88427>>>>>>>>
88427>>>>>>>                End
88427>>>>>>>>
88427>>>>>>>            End
88427>>>>>>>>
88427>>>>>>>        Loop
88428>>>>>>>>
88428>>>>>>>
88428>>>>>>>        Move False to Err
88429>>>>>>>        Move 0 to LastErr
88430>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88431>>>>>>>        Function_Return aAPIColumnsToInsert
88432>>>>>>>    End_Function
88433>>>>>>>
88433>>>>>>>    Function UtilColumnsInsert String sDriverIDFrom Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
88435>>>>>>>        Integer iSize iCount
88435>>>>>>>        Boolean bOK
88435>>>>>>>        tAPIColumn[] aColumnsTo
88435>>>>>>>        tAPIColumn[] aColumnsTo
88436>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88436>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88437>>>>>>>
88437>>>>>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
88438>>>>>>>        If (iSize = 0) Begin
88440>>>>>>>            Function_Return True
88441>>>>>>>        End
88441>>>>>>>>
88441>>>>>>>
88441>>>>>>>        Move False to Err
88442>>>>>>>        Decrement iSize
88443>>>>>>>        for iCount from 0 to iSize
88449>>>>>>>>
88449>>>>>>>            Get ApiColumnInsert sDriverIDFrom hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
88450>>>>>>>        Loop
88451>>>>>>>>
88451>>>>>>>
88451>>>>>>>        Function_Return bOK
88452>>>>>>>    End_Function
88453>>>>>>>
88453>>>>>>>    // Returns a struct array with fields that has the same names but different field numbers.
88453>>>>>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
88455>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
88455>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
88456>>>>>>>        Integer iSize iCount iItem iShouldMove
88456>>>>>>>
88456>>>>>>>        Move 0 to iItem
88457>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88458>>>>>>>        Decrement iSize
88459>>>>>>>        for iCount from 0 to iSize
88465>>>>>>>>
88465>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
88467>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
88468>>>>>>>                If (iShouldMove <> -1) Begin
88470>>>>>>>                    Move aAPIColumnCompare[iCount] to aAPIColumnsToMove[iItem]
88471>>>>>>>                    Move iShouldMove               to aAPIColumnsToMove[iItem].iFieldNumberTo
88472>>>>>>>                    Move aAPIColumnCompare[iShouldMove - 1].sFieldNameTo to aAPIColumnsToMove[iItem].sFieldNameTo
88473>>>>>>>                    Increment iItem
88474>>>>>>>                End
88474>>>>>>>>
88474>>>>>>>            End
88474>>>>>>>>
88474>>>>>>>        Loop
88475>>>>>>>>
88475>>>>>>>
88475>>>>>>>        Move False to Err
88476>>>>>>>        Move 0 to LastErr
88477>>>>>>>        Function_Return aAPIColumnsToMove
88478>>>>>>>    End_Function
88479>>>>>>>
88479>>>>>>>    Function UtilColumnsMove Handle hTable tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
88481>>>>>>>        Integer iSize iCount
88481>>>>>>>        Boolean bOK
88481>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88481>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88482>>>>>>>
88482>>>>>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
88483>>>>>>>        If (iSize = 0) Begin
88485>>>>>>>            Function_Return True
88486>>>>>>>        End
88486>>>>>>>>
88486>>>>>>>
88486>>>>>>>        Move False to Err
88487>>>>>>>        Decrement iSize
88488>>>>>>>        for iCount from 0 to iSize
88494>>>>>>>>
88494>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88495>>>>>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
88497>>>>>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom aAPIColumnsToMove[iCount].iLengthFrom aAPIColumnsToMove[iCount].iPrecisionFrom to bOK
88498>>>>>>>                If (bOK = True) Begin
88500>>>>>>>                    Get UtilColumnsStructFill hTable to aColumnsTo
88501>>>>>>>                    Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88502>>>>>>>                    Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIColumnsToMove
88503>>>>>>>                    If (SizeOfArray(aAPIColumnsToMove)) Begin
88505>>>>>>>                        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
88506>>>>>>>                        Decrement iSize
88507>>>>>>>                        Move 0 to iCount
88508>>>>>>>                    End
88508>>>>>>>>
88508>>>>>>>                End
88508>>>>>>>>
88508>>>>>>>                Else Begin
88509>>>>>>>                    Move iSize to iCount // We're out of here! Else there will be an error generated for each field.
88510>>>>>>>                End
88510>>>>>>>>
88510>>>>>>>            End
88510>>>>>>>>
88510>>>>>>>        Loop
88511>>>>>>>>
88511>>>>>>>
88511>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88512>>>>>>>        If (LastErr = DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) Begin
88514>>>>>>>            Move 0 to LastErr
88515>>>>>>>        End
88515>>>>>>>>
88515>>>>>>>        Function_Return bOK
88516>>>>>>>    End_Function
88517>>>>>>>
88517>>>>>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
88517>>>>>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
88517>>>>>>>    // - The "FROM" field name is <> "TO" field name
88517>>>>>>>    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
88517>>>>>>>    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
88517>>>>>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
88519>>>>>>>        Boolean bShouldRename
88519>>>>>>>        String sFieldNameFrom sFieldNameTo
88519>>>>>>>
88519>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
88520>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo
88521>>>>>>>        If (sFieldNameFrom = sFieldNameTo) Begin
88523>>>>>>>            Function_Return False
88524>>>>>>>        End
88524>>>>>>>>
88524>>>>>>>
88524>>>>>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
88525>>>>>>>//        If (bShouldRename = False) Begin
88525>>>>>>>//            Function_Return False
88525>>>>>>>//        End
88525>>>>>>>//
88525>>>>>>>//        If (sFieldNameFrom contains sFieldNameTo) Begin
88525>>>>>>>//            Function_Return True
88525>>>>>>>//        End
88525>>>>>>>
88525>>>>>>>        Function_Return bShouldRename
88526>>>>>>>    End_Function
88527>>>>>>>
88527>>>>>>>    // Returns -1 if the passed iColumn number doesn't exist with the same name in the aAPIColumnCompare struct array.
88527>>>>>>>    // Else it returns the column/field number of the field that exists in another position.
88527>>>>>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Integer
88529>>>>>>>        Integer iCount iSize iRetval
88529>>>>>>>        String sFieldNameFrom
88529>>>>>>>
88529>>>>>>>        Move -1 to iRetval
88530>>>>>>>        If (aAPIColumnCompare[iColumn].bExistsFrom = False or aAPIColumnCompare[iColumn].bExistsTo = False) Begin
88532>>>>>>>            Function_Return iRetval
88533>>>>>>>        End
88533>>>>>>>>
88533>>>>>>>
88533>>>>>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
88534>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88535>>>>>>>        Decrement iSize
88536>>>>>>>        for iCount from 0 to iSize
88542>>>>>>>>
88542>>>>>>>            // We're only interested in fields other than the passed field/column number:
88542>>>>>>>            If (iCount <> iColumn) Begin
88544>>>>>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
88546>>>>>>>                    Move (iCount + 1) to iRetval
88547>>>>>>>                End
88547>>>>>>>>
88547>>>>>>>            End
88547>>>>>>>>
88547>>>>>>>        Loop
88548>>>>>>>>
88548>>>>>>>
88548>>>>>>>        Move 0 to LastErr
88549>>>>>>>        Function_Return iRetval
88550>>>>>>>    End_Function
88551>>>>>>>
88551>>>>>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
88553>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
88553>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
88554>>>>>>>        Integer iSize iCount iItem iFieldTo iShouldMove
88554>>>>>>>        Boolean bRenameField
88554>>>>>>>
88554>>>>>>>        Open hTable
88556>>>>>>>        Move 0 to iItem
88557>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88558>>>>>>>        Decrement iSize
88559>>>>>>>        for iCount from 0 to iSize
88565>>>>>>>>
88565>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
88567>>>>>>>                // Check if the field exists in another position (other field number)
88567>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
88568>>>>>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
88569>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iShouldMove = -1 and bRenameField = True) Begin
88571>>>>>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber
88572>>>>>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo
88573>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
88574>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
88575>>>>>>>                    Increment iItem
88576>>>>>>>                End
88576>>>>>>>>
88576>>>>>>>            End
88576>>>>>>>>
88576>>>>>>>        Loop
88577>>>>>>>>
88577>>>>>>>
88577>>>>>>>        Move False to Err
88578>>>>>>>        Move 0 to LastErr
88579>>>>>>>        Function_Return aAPIColumnsToRename
88580>>>>>>>    End_Function
88581>>>>>>>
88581>>>>>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
88583>>>>>>>        Integer iSize iCount
88583>>>>>>>        Boolean bOK
88583>>>>>>>        tAPIColumn[] aColumnsTo
88583>>>>>>>        tAPIColumn[] aColumnsTo
88584>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88584>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88585>>>>>>>
88585>>>>>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
88586>>>>>>>        If (iSize = 0) Begin
88588>>>>>>>            Function_Return True
88589>>>>>>>        End
88589>>>>>>>>
88589>>>>>>>
88589>>>>>>>        Move False to Err
88590>>>>>>>        Decrement iSize
88591>>>>>>>        For iCount from 0 to iSize
88597>>>>>>>>
88597>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88598>>>>>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK
88599>>>>>>>        Loop
88600>>>>>>>>
88600>>>>>>>
88600>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88601>>>>>>>        Function_Return bOK
88602>>>>>>>    End_Function
88603>>>>>>>
88603>>>>>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
88605>>>>>>>        Boolean bDateType
88605>>>>>>>
88605>>>>>>>        If (bIsSQLTableTo = True) Begin
88607>>>>>>>            Move (iType = SQL_DATE or iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
88608>>>>>>>        End
88608>>>>>>>>
88608>>>>>>>        Else Begin
88609>>>>>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
88610>>>>>>>        End
88610>>>>>>>>
88610>>>>>>>
88610>>>>>>>        Function_Return bDateType
88611>>>>>>>    End_Function
88612>>>>>>>
88612>>>>>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
88614>>>>>>>        Integer iCount iColumns iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
88614>>>>>>>        Integer iCount2 iColumn2
88614>>>>>>>        Handle hFile
88614>>>>>>>        Boolean bFieldExistsFrom bFieldExistsTo bIsSQLDriver bIsSame bOK bSkip
88614>>>>>>>        Boolean bRecnum bIsSQLTableTo bRecnumTable bIsOpen bSkipTypeChange bIsDateType
88614>>>>>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
88614>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
88614>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
88619>>>>>>>        tColumnType ColumnType
88619>>>>>>>        tColumnType ColumnType
88619>>>>>>>
88619>>>>>>>        Move False to Err
88620>>>>>>>        Close hTable
88621>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88622>>>>>>>        If (bIsOpen = False) Begin
88624>>>>>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
88625>>>>>>>>
88625>>>>>>>            Function_Return False
88626>>>>>>>        End 
88626>>>>>>>>
88626>>>>>>>        
88626>>>>>>>        Get piDbType to iDbType
88627>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
88630>>>>>>>        Move bIsSQLTableFrom to bIsSQLDriver
88631>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
88632>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
88635>>>>>>>
88635>>>>>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88636>>>>>>>
88636>>>>>>>        // Before we start to change the table we need to do three things;
88636>>>>>>>        // 1) Insert any new fields
88636>>>>>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
88637>>>>>>>        If (SizeOfArray(aApiInsertColumns)) Begin
88639>>>>>>>            Get UtilColumnsInsert sDriverIDFrom hTable aApiInsertColumns to bOK
88640>>>>>>>            If (bOK = False) Begin
88642>>>>>>>                Function_Return False
88643>>>>>>>            End
88643>>>>>>>>
88643>>>>>>>            // Update info with changes made.
88643>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88644>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88645>>>>>>>        End
88645>>>>>>>>
88645>>>>>>>
88645>>>>>>>        // 2) Move fields with same names
88645>>>>>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
88646>>>>>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
88648>>>>>>>            Get UtilColumnsMove hTable aColumnsFrom aColumnsTo aAPIMoveColumns to bOK
88649>>>>>>>            If (bOK = False) Begin
88651>>>>>>>                Function_Return False
88652>>>>>>>            End
88652>>>>>>>>
88652>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88653>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88654>>>>>>>        End
88654>>>>>>>>
88654>>>>>>>        
88654>>>>>>>        // 3) Rename fields
88654>>>>>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
88655>>>>>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
88657>>>>>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
88658>>>>>>>            If (bOK = False) Begin
88660>>>>>>>                Function_Return False
88661>>>>>>>            End
88661>>>>>>>>
88661>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88662>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88663>>>>>>>        End
88663>>>>>>>>
88663>>>>>>>
88663>>>>>>>        // Note: Fields will be removed if needed in the Structure_Start/End below.
88663>>>>>>>        // Get utilColumnsCheckForRemoves hTable aAPIColumnCompare to aAPIRemoveColumns
88663>>>>>>>
88663>>>>>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again:
88663>>>>>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
88665>>>>>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
88666>>>>>>>            If (bIsSame = True) Begin
88668>>>>>>>                Function_Return True
88669>>>>>>>            End
88669>>>>>>>>
88669>>>>>>>        End
88669>>>>>>>>
88669>>>>>>>
88669>>>>>>>        Move False to Err
88670>>>>>>>        // We can now continue to make standard field changes:
88670>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88671>>>>>>>        Set Private.phCurrentTable to hTable
88672>>>>>>>        Move hTable to hFile
88673>>>>>>>        Structure_Start hFile sDriverIDTo
88674>>>>>>>
88674>>>>>>>            Move (SizeOfArray(aAPIColumnCompare)) to iColumns
88675>>>>>>>            Decrement iColumns
88676>>>>>>>            for iCount from 0 to iColumns
88682>>>>>>>>
88682>>>>>>>                Send DoAdvance of ghoProgressBar
88683>>>>>>>
88683>>>>>>>                Move aAPIColumnCompare[iCount].iFieldNumber to iColumn
88684>>>>>>>                Set Private.piCurrentField                  to iColumn
88685>>>>>>>                Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom aAPIColumnCompare[iCount].bIsSQLTypeTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
88686>>>>>>>                If (bIsSame = False) Begin
88688>>>>>>>
88688>>>>>>>                    Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
88689>>>>>>>                    If (bFieldExistsFrom = True) Begin
88691>>>>>>>                        Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
88692>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
88693>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom
88694>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
88695>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
88696>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
88697>>>>>>>
88697>>>>>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
88698>>>>>>>                        If (iTypeFrom < -1490) Begin
88700>>>>>>>                            Move (iTypeFrom + 1500)                     to iTypeFrom
88701>>>>>>>                        End
88701>>>>>>>>
88701>>>>>>>
88701>>>>>>>                        // If one of the two tables are SQL and the other Embedded we need to "translate"
88701>>>>>>>                        // data types between Embedded and SQL, else we can't compare the data types.
88701>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
88703>>>>>>>                            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
88704>>>>>>>                            If (iTypeFrom = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88706>>>>>>>                                Move DF_DATE to iTypeFrom
88707>>>>>>>                            End
88707>>>>>>>>
88707>>>>>>>                        End
88707>>>>>>>>
88707>>>>>>>                        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
88710>>>>>>>                            Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
88711>>>>>>>                        End
88711>>>>>>>>
88711>>>>>>>
88711>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
88712>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
88713>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
88714>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
88715>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
88716>>>>>>>
88716>>>>>>>                        Move False to bSkipTypeChange
88717>>>>>>>                        If (bCompareDate_DateTime = False) Begin
88719>>>>>>>                            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
88720>>>>>>>                        End
88720>>>>>>>>
88720>>>>>>>
88720>>>>>>>                        If (bFieldExistsTo = False) Begin
88722>>>>>>>                            Move 0 to iColumn
88723>>>>>>>                            Create_Field hFile At iColumn
88724>>>>>>>                            Set Private.piCurrentField to iColumn
88725>>>>>>>                        End
88725>>>>>>>>
88725>>>>>>>
88725>>>>>>>                        If (sFieldNameFrom <> sFieldNameTo) Begin
88727>>>>>>>                            Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
88730>>>>>>>                        End
88730>>>>>>>>
88730>>>>>>>
88730>>>>>>>                        // Note: In MS-SQL it is vital that *nothing* gets changed for e.g. a "datetime" column, else error: 22018 is generated by the SQL backend:
88730>>>>>>>                        //       "Explicit conversion from data type int to datetime2 is not allowed", which will make the update to fail, and all changes for the table is rollbacked. 
88730>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity and bSkipTypeChange = False) Begin
88732>>>>>>>                            Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
88735>>>>>>>                            Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
88736>>>>>>>                            If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
88738>>>>>>>                                Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
88739>>>>>>>                            End
88739>>>>>>>>
88739>>>>>>>                            Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
88742>>>>>>>                        End
88742>>>>>>>>
88742>>>>>>>
88742>>>>>>>                        If (bSkipTypeChange = False) Begin
88744>>>>>>>                            If (iTypeFrom <> iTypeTo) Begin
88746>>>>>>>                                If (bIsSQLTableTo = True) Begin
88748>>>>>>>                                    Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iTypeFrom
88751>>>>>>>                                End
88751>>>>>>>>
88751>>>>>>>                                Else Begin                                                   
88752>>>>>>>                                    If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88754>>>>>>>                                        Move DF_DATE to iDataFlexType  // Date
88755>>>>>>>                                    End
88755>>>>>>>>
88755>>>>>>>                                    Set_Attribute DF_FIELD_TYPE of hFile iColumn to iDataFlexType
88758>>>>>>>                                End
88758>>>>>>>>
88758>>>>>>>                            End
88758>>>>>>>>
88758>>>>>>>                        End
88758>>>>>>>>
88758>>>>>>>
88758>>>>>>>                        Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType
88759>>>>>>>                        // We can't set the length or precision for Date type columns (they are fixed).
88759>>>>>>>                        If (bIsDateType = False and iLengthFrom <> iLengthTo) Begin
88761>>>>>>>                            Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
88764>>>>>>>                        End
88764>>>>>>>>
88764>>>>>>>                        // We do want to set the precision for e.g. DateTime2 (can be 3 or 7, but DataFlex can just handle "3").
88764>>>>>>>                        If (iPrecisionFrom <> iPrecisionTo) Begin
88766>>>>>>>                            Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
88769>>>>>>>                        End
88769>>>>>>>>
88769>>>>>>>
88769>>>>>>>                        If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
88771>>>>>>>                            // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
88771>>>>>>>                            If (bRecnumTable = True) Begin
88773>>>>>>>                                Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
88776>>>>>>>                            End
88776>>>>>>>>
88776>>>>>>>
88776>>>>>>>                            // We might need to create an index here.
88776>>>>>>>                            // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
88776>>>>>>>                            // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
88776>>>>>>>                            // index update checking logic.
88776>>>>>>>                            Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
88779>>>>>>>                            If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
88781>>>>>>>                                Create_Index hFile at iIndex
88782>>>>>>>                                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
88785>>>>>>>                            End
88785>>>>>>>>
88785>>>>>>>
88785>>>>>>>                            Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
88788>>>>>>>                            Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
88791>>>>>>>                                // Note: The order here is crucial!
88791>>>>>>>                                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
88794>>>>>>>                                Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
88797>>>>>>>                        End
88797>>>>>>>>
88797>>>>>>>                    End
88797>>>>>>>>
88797>>>>>>>                    Else Begin
88798>>>>>>>                        Delete_Field hFile iColumn
88799>>>>>>>                        Move (RemoveFromArray(aColumnsTo, iCount)) to aColumnsTo
88800>>>>>>>                        Move (SizeOfArray(aColumnsTo)) to iCount2
88801>>>>>>>                        Decrement iCount2
88802>>>>>>>                        // We need to adjust FieldNumbers in the array with one, as we just deleted a field,
88802>>>>>>>                        // starting with the array number we just deleted the field for.
88802>>>>>>>                        for iColumn2 from iCount to iCount2
88808>>>>>>>>
88808>>>>>>>                            Move (aColumnsTo[iColumn2].iFieldNumber - 1) to aColumnsTo[iColumn2].iFieldNumber
88809>>>>>>>                        Loop
88810>>>>>>>>
88810>>>>>>>                        Decrement iCount
88811>>>>>>>                        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88812>>>>>>>                        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
88813>>>>>>>                        If (SizeOfArray(aColumnsFrom) = SizeOfArray(aColumnsTo)) Begin
88815>>>>>>>                            Move iColumns to iCount 
88816>>>>>>>                        End
88816>>>>>>>>
88816>>>>>>>                    End
88816>>>>>>>>
88816>>>>>>>                End 
88816>>>>>>>>
88816>>>>>>>                If (Err = True) Begin 
88818>>>>>>>                    Move False to bOK
88819>>>>>>>                    Move iColumns to iCount
88820>>>>>>>                End
88820>>>>>>>>
88820>>>>>>>            Loop
88821>>>>>>>>
88821>>>>>>>
88821>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructuring table..."
88822>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88824>>>>>>>
88824>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88825>>>>>>>        Function_Return (Not(Err))
88826>>>>>>>    End_Function
88827>>>>>>>
88827>>>>>>>    // * Dummy function for the Studio's Code Explorer *
88827>>>>>>>    Function API_INDEX_FUNCTIONS Returns Boolean
88829>>>>>>>        Function_Return False
88830>>>>>>>    End_Function
88831>>>>>>>
88831>>>>>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
88831>>>>>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
88831>>>>>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
88831>>>>>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
88833>>>>>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10  iIndexSegments
88833>>>>>>>        String sDriverID
88833>>>>>>>        Boolean bOK bExists bIsSQLTable
88833>>>>>>>
88833>>>>>>>        Get AutoConnectionIDLogin to bOK
88834>>>>>>>        Get OpenTableExclusive hTable to bOK
88835>>>>>>>        If (bOK = False) Begin
88837>>>>>>>            Function_Return False
88838>>>>>>>        End
88838>>>>>>>>
88838>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88841>>>>>>>
88841>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88842>>>>>>>            If (bIsSQLTable = True) Begin
88844>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88847>>>>>>>            End
88847>>>>>>>>
88847>>>>>>>
88847>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iIndexSegments
88850>>>>>>>        Move (iIndexSegments > 0) to bExists
88851>>>>>>>        If (bExists = True) Begin
88853>>>>>>>            Function_Return True
88854>>>>>>>        End
88854>>>>>>>>
88854>>>>>>>
88854>>>>>>>        Move -1 to iSegment1
88855>>>>>>>        Move -1 to iSegment2
88856>>>>>>>        Move -1 to iSegment3
88857>>>>>>>        Move -1 to iSegment4
88858>>>>>>>        Move -1 to iSegment5
88859>>>>>>>        Move -1 to iSegment6
88860>>>>>>>        Move -1 to iSegment7
88861>>>>>>>        Move -1 to iSegment8
88862>>>>>>>        Move -1 to iSegment9
88863>>>>>>>        Move -1 to iSegment10
88864>>>>>>>
88864>>>>>>>        If (num_arguments > 3) Begin
88866>>>>>>>            Move iSgmnt1 to iSegment1
88867>>>>>>>        End
88867>>>>>>>>
88867>>>>>>>        If (num_arguments > 4) Begin
88869>>>>>>>            Move iSgmnt2 to iSegment2
88870>>>>>>>        End
88870>>>>>>>>
88870>>>>>>>        If (num_arguments > 5) Begin
88872>>>>>>>            Move iSgmnt3 to iSegment3
88873>>>>>>>        End
88873>>>>>>>>
88873>>>>>>>        If (num_arguments > 6) Begin
88875>>>>>>>            Move iSgmnt4 to iSegment4
88876>>>>>>>        End
88876>>>>>>>>
88876>>>>>>>        If (num_arguments > 7) Begin
88878>>>>>>>            Move iSgmnt5 to iSegment5
88879>>>>>>>        End
88879>>>>>>>>
88879>>>>>>>        If (num_arguments > 8) Begin
88881>>>>>>>            Move iSgmnt6 to iSegment6
88882>>>>>>>        End
88882>>>>>>>>
88882>>>>>>>        If (num_arguments > 9) Begin
88884>>>>>>>            Move iSgmnt7 to iSegment7
88885>>>>>>>        End
88885>>>>>>>>
88885>>>>>>>        If (num_arguments > 10) Begin
88887>>>>>>>            Move iSgmnt8 to iSegment8
88888>>>>>>>        End
88888>>>>>>>>
88888>>>>>>>        If (num_arguments > 11) Begin
88890>>>>>>>            Move iSgmnt9 to iSegment9
88891>>>>>>>        End
88891>>>>>>>>
88891>>>>>>>        If (num_arguments > 12) Begin
88893>>>>>>>            Move iSgmnt10 to iSegment10
88894>>>>>>>        End
88894>>>>>>>>
88894>>>>>>>
88894>>>>>>>        Move False to Err
88895>>>>>>>        Move hTable to iTableNo
88896>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88897>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88898>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88899>>>>>>>
88899>>>>>>>        // We start by deleting the index, if it exists.
88899>>>>>>>        If (bExists = True) Begin
88901>>>>>>>            Structure_Start hTable sDriverID
88902>>>>>>>                Delete_Index iTableNo iIndex
88903>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88904>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88906>>>>>>>        End
88906>>>>>>>>
88906>>>>>>>
88906>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88907>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88908>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88909>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88910>>>>>>>        Move False to Err
88911>>>>>>>        Move 0 to LastErr
88912>>>>>>>
88912>>>>>>>        // Need to re-open if index deleted.
88912>>>>>>>        Move iTableNo to hTable
88913>>>>>>>        Get OpenTableExclusive hTable to bOK
88914>>>>>>>        If (bOK = False) Begin
88916>>>>>>>            Function_Return False
88917>>>>>>>        End
88917>>>>>>>>
88917>>>>>>>
88917>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88918>>>>>>>        Structure_Start hTable sDriverID
88919>>>>>>>            Create_Index hTable At iIndex
88920>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
88923>>>>>>>
88923>>>>>>>            If (iSgmnt1 <> -1) Begin
88925>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
88928>>>>>>>            End
88928>>>>>>>>
88928>>>>>>>            If (iSegment2 <> -1) Begin
88930>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
88933>>>>>>>            End
88933>>>>>>>>
88933>>>>>>>            If (iSegment3 <> -1) Begin
88935>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
88938>>>>>>>            End
88938>>>>>>>>
88938>>>>>>>            If (iSegment4 <> -1) Begin
88940>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
88943>>>>>>>            End
88943>>>>>>>>
88943>>>>>>>            If (iSegment5 <> -1) Begin
88945>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
88948>>>>>>>            End
88948>>>>>>>>
88948>>>>>>>            If (iSegment6 <> -1) Begin
88950>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
88953>>>>>>>            End
88953>>>>>>>>
88953>>>>>>>            If (iSegment7 <> -1) Begin
88955>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
88958>>>>>>>            End
88958>>>>>>>>
88958>>>>>>>            If (iSegment8 <> -1) Begin
88960>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
88963>>>>>>>            End
88963>>>>>>>>
88963>>>>>>>            If (iSegment9 <> -1) Begin
88965>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
88968>>>>>>>            End
88968>>>>>>>>
88968>>>>>>>            If (iSegment10 <> -1) Begin
88970>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
88973>>>>>>>            End
88973>>>>>>>>
88973>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88974>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88976>>>>>>>
88976>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88977>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88978>>>>>>>
88978>>>>>>>        Function_Return (Err = False)
88979>>>>>>>    End_Function
88980>>>>>>>
88980>>>>>>>    // Example:
88980>>>>>>>    // Get ApiIndexCreateEx hTable 1 (StrSplitToArray("1,5,6,7,8,2,3,4,10,9,11", ",")) to bOk
88980>>>>>>>    // Note: The StrSplitToArray function was introduced with DataFlex 18.2
88980>>>>>>>    Function ApiIndexCreateEx Handle hTable Integer iIndex Integer[] iSgmnts Returns Boolean
88982>>>>>>>        Integer iTableNo iNumSgmnt iNumSgmnts
88982>>>>>>>        String sDriverID
88982>>>>>>>        Boolean bOK bIsSQLTable
88982>>>>>>>
88982>>>>>>>        Get AutoConnectionIDLogin to bOK
88983>>>>>>>
88983>>>>>>>        Move False to Err
88984>>>>>>>        Move hTable to iTableNo
88985>>>>>>>        Get OpenTableExclusive hTable to bOK
88986>>>>>>>        If (bOK = False) Begin
88988>>>>>>>            Function_Return False
88989>>>>>>>        End
88989>>>>>>>>
88989>>>>>>>
88989>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88992>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88993>>>>>>>            If (bIsSQLTable = True) Begin
88995>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88998>>>>>>>            End
88998>>>>>>>>
88998>>>>>>>
88998>>>>>>>        // We start by deleting the index
88998>>>>>>>        Structure_Start hTable sDriverID
88999>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89000>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
89001>>>>>>>            Delete_Index iTableNo iIndex
89002>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
89003>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
89004>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
89006>>>>>>>
89006>>>>>>>        Move False to Err
89007>>>>>>>        Move iTableNo to hTable
89008>>>>>>>        Get OpenTableExclusive hTable to bOK
89009>>>>>>>        If (bOK = False) Begin
89011>>>>>>>            Function_Return False
89012>>>>>>>        End
89012>>>>>>>>
89012>>>>>>>
89012>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89013>>>>>>>        Structure_Start hTable sDriverID
89014>>>>>>>            Move (SizeOfArray(iSgmnts)) to iNumSgmnts
89015>>>>>>>
89015>>>>>>>            Create_Index hTable at iIndex
89016>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSgmnts
89019>>>>>>>
89019>>>>>>>            for iNumSgmnt from 0 to (iNumSgmnts - 1)
89025>>>>>>>>
89025>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iNumSgmnt + 1) to iSgmnts[iNumSgmnt]
89028>>>>>>>            Loop
89029>>>>>>>>
89029>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
89031>>>>>>>
89031>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89032>>>>>>>
89032>>>>>>>        Function_Return (Err = False)
89033>>>>>>>    End_Function
89034>>>>>>>
89034>>>>>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
89036>>>>>>>        Integer iCount iSegmentsFrom iFieldFrom iSegmentsTo iSQLIndexType iTableNo
89036>>>>>>>        String sDriverID sSQLIndexName
89036>>>>>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
89036>>>>>>>
89036>>>>>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
89037>>>>>>>        If (iSegmentsFrom = 0) Begin
89039>>>>>>>            Function_Return False
89040>>>>>>>        End
89040>>>>>>>>
89040>>>>>>>
89040>>>>>>>        Get AutoConnectionIDLogin to bOK
89041>>>>>>>        Move False to Err
89042>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
89043>>>>>>>        If (bIsOpen = False) Begin
89045>>>>>>>            Function_Return False
89046>>>>>>>        End
89046>>>>>>>>
89046>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89049>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
89050>>>>>>>            If (bIsSQLTable = True) Begin
89052>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89055>>>>>>>            End
89055>>>>>>>>
89055>>>>>>>
89055>>>>>>>        Move 0     to iSegmentsTo
89056>>>>>>>        Move 0     to iSQLIndexType
89057>>>>>>>        Move ""    to sSQLIndexName
89058>>>>>>>        Move False to bIsSQLTemporaryIndex
89059>>>>>>>        Move False to bIsSQLPrimaryKey
89060>>>>>>>        Move False to bIsSQLClustered
89061>>>>>>>
89061>>>>>>>            Get UtilIndexTempRenameSQLName hTable APIIndex.sSQLIndexName sDriverID          to bOK
89062>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber              to iSegmentsTo
89065>>>>>>>        Move (iSegmentsTo > 0) to bExists
89066>>>>>>>        If (bExists = True) Begin
89068>>>>>>>            If (bIsSQLTable = True and iSegmentsTo > 0) Begin
89070>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber                 to sSQLIndexName
89073>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
89076>>>>>>>                        Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
89077>>>>>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
89080>>>>>>>                    Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
89083>>>>>>>            End
89083>>>>>>>>
89083>>>>>>>        End
89083>>>>>>>>
89083>>>>>>>
89083>>>>>>>        Move hTable to iTableNo
89084>>>>>>>        Move False to Err
89085>>>>>>>        Move 0 to LastErr
89086>>>>>>>
89086>>>>>>>        Structure_Start hTable sDriverID
89087>>>>>>>            If (bExists = True) Begin
89089>>>>>>>                Delete_Index iTableNo APIIndex.iIndexNumber
89090>>>>>>>            End
89090>>>>>>>>
89090>>>>>>>
89090>>>>>>>            Create_Index hTable At APIIndex.iIndexNumber
89091>>>>>>>
89091>>>>>>>                If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
89093>>>>>>>                    Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType
89096>>>>>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
89099>>>>>>>                    Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
89102>>>>>>>                    Set_Attribute DF_INDEX_NAME            of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
89105>>>>>>>                End
89105>>>>>>>>
89105>>>>>>>
89105>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
89108>>>>>>>
89108>>>>>>>            for iCount from 0 to (iSegmentsFrom -1)
89114>>>>>>>>
89114>>>>>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom
89115>>>>>>>                If (iFieldFrom <> -1 ) Begin
89117>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
89120>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bAscending
89123>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bUppercase
89126>>>>>>>                End
89126>>>>>>>>
89126>>>>>>>            Loop
89127>>>>>>>>
89127>>>>>>>
89127>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89128>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89130>>>>>>>
89130>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89131>>>>>>>
89131>>>>>>>        Function_Return (Err = False)
89132>>>>>>>    End_Function
89133>>>>>>>
89133>>>>>>>    // If an SQL index is to be renamed we need to check that the name doesn't exist already, but
89133>>>>>>>    // with another index number. If we find one we temporarily renames it by adding "TMP" to the SQL name.
89133>>>>>>>    Function UtilIndexTempRenameSQLName Handle hTable String sSQLIndexName String sDriverID Returns Boolean
89135>>>>>>>        Integer iLastIndex iCount iTableNo iSegments
89135>>>>>>>        String sSQLIndexNameCompare sTmpIndexName
89135>>>>>>>        Boolean bIsOpen bExists bIsSQLDriver 
89135>>>>>>>
89135>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
89136>>>>>>>        
89136>>>>>>>        If (bIsSQLDriver = False) Begin
89138>>>>>>>            Function_Return False
89139>>>>>>>        End
89139>>>>>>>>
89139>>>>>>>
89139>>>>>>>        Move False to Err
89140>>>>>>>        Move hTable to iTableNo
89141>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
89144>>>>>>>        for iCount from 0 to iLastIndex
89150>>>>>>>>
89150>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iSegments
89153>>>>>>>            Move (iSegments > 0) to bExists
89154>>>>>>>            If (bExists = True) Begin
89156>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable iCount to sSQLIndexNameCompare
89159>>>>>>>                If (Lowercase(sSQLIndexName) = Lowercase(sSQLIndexNameCompare)) Begin
89161>>>>>>>                    Move (sSQLIndexNameCompare + String("_TMP")) to sTmpIndexName
89162>>>>>>>                    Structure_Start iTableNo sDriverID
89163>>>>>>>                        Set_Attribute DF_INDEX_NAME of iTableNo iCount to sTmpIndexName
89166>>>>>>>                    Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89168>>>>>>>                    Open hTable
89170>>>>>>>                End
89170>>>>>>>>
89170>>>>>>>            End
89170>>>>>>>>
89170>>>>>>>        Loop
89171>>>>>>>>
89171>>>>>>>
89171>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89174>>>>>>>        If (bIsOpen = False) Begin
89176>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
89177>>>>>>>        End
89177>>>>>>>>
89177>>>>>>>        If (bIsOpen = False) Begin
89179>>>>>>>            Function_Return False
89180>>>>>>>        End
89180>>>>>>>>
89180>>>>>>>
89180>>>>>>>        Function_Return (Err = False)
89181>>>>>>>    End_Function
89182>>>>>>>
89182>>>>>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
89182>>>>>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
89182>>>>>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
89184>>>>>>>        Integer iSize iCount
89184>>>>>>>        Integer iRetVal
89184>>>>>>>
89184>>>>>>>        Move 0 to iRetVal
89185>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
89188>>>>>>>        If (iRetVal = 0) Begin
89190>>>>>>>            Function_Return 0
89191>>>>>>>        End
89191>>>>>>>>
89191>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSize
89192>>>>>>>        Decrement iSize
89193>>>>>>>        for iCount from 0 to iSize
89199>>>>>>>>
89199>>>>>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
89201>>>>>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
89203>>>>>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
89204>>>>>>>                End
89204>>>>>>>>
89204>>>>>>>            End
89204>>>>>>>>
89204>>>>>>>        Loop
89205>>>>>>>>
89205>>>>>>>
89205>>>>>>>        Function_Return iRetVal
89206>>>>>>>    End_Function
89207>>>>>>>
89207>>>>>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
89209>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
89209>>>>>>>        Boolean bIsSQLTable
89209>>>>>>>        
89209>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89210>>>>>>>            If (bIsSQLTable = True) Begin
89212>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89215>>>>>>>            End
89215>>>>>>>>
89215>>>>>>>
89215>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89218>>>>>>>        If (iSegment = iNumSegments) Begin
89220>>>>>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89220>>>>>>>        End
89220>>>>>>>>
89220>>>>>>>
89220>>>>>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89223>>>>>>>            for iCurSegment from iSegment to (iNumSegments - 1)
89229>>>>>>>>
89229>>>>>>>                //*** Move index segment attributes
89229>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89232>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
89235>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
89238>>>>>>>
89238>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
89241>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
89244>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
89247>>>>>>>            Loop
89248>>>>>>>>
89248>>>>>>>
89248>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89251>>>>>>>        End
89251>>>>>>>>
89251>>>>>>>
89251>>>>>>>        Function_Return (Err = False)
89252>>>>>>>    End_Function
89253>>>>>>>
89253>>>>>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
89255>>>>>>>        Integer iCount iSize iIndex
89255>>>>>>>        String sDriverID
89255>>>>>>>        Boolean bOK bIsSQLTable bIsOpen
89255>>>>>>>
89255>>>>>>>        Move (SizeOfArray(APIIndex)) to iSize
89256>>>>>>>        If (iSize = 0) Begin
89258>>>>>>>            Function_Return True
89259>>>>>>>        End
89259>>>>>>>>
89259>>>>>>>
89259>>>>>>>        Get AutoConnectionIDLogin to bOK
89260>>>>>>>        Move False to Err
89261>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89264>>>>>>>        If (bIsOpen = False) Begin
89266>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
89267>>>>>>>            If (bIsOpen = False) Begin
89269>>>>>>>                Function_Return False
89270>>>>>>>            End
89270>>>>>>>>
89270>>>>>>>        End
89270>>>>>>>>
89270>>>>>>>
89270>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89273>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
89274>>>>>>>            If (bIsSQLTable = True) Begin
89276>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89279>>>>>>>            End
89279>>>>>>>>
89279>>>>>>>
89279>>>>>>>        Move False to Err
89280>>>>>>>        Move 0 to LastErr
89281>>>>>>>        Decrement iSize
89282>>>>>>>
89282>>>>>>>        Structure_Start hTable sDriverID
89283>>>>>>>            for iCount from 0 to iSize
89289>>>>>>>>
89289>>>>>>>//                Move False to bIsSQLPrimaryKey
89289>>>>>>>//                #IF (!@ > 180)   // DF 18.1 and up
89289>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89289>>>>>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
89289>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
89289>>>>>>>//                #ENDIF
89289>>>>>>>                // We can't delete if this is a primary key index:
89289>>>>>>>//                If (bIsSQLPrimaryKey = False) Begin
89289>>>>>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
89290>>>>>>>                    Delete_Index hTable iIndex
89291>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
89291>>>>>>>//                End
89291>>>>>>>            Loop
89292>>>>>>>>
89292>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89293>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89295>>>>>>>//        Move False to Err
89295>>>>>>>        Move 0 to LastErr
89296>>>>>>>
89296>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89297>>>>>>>        Function_Return (Err = False)
89298>>>>>>>    End_Function
89299>>>>>>>
89299>>>>>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
89301>>>>>>>        Boolean bOK
89301>>>>>>>
89301>>>>>>>        Get AutoConnectionIDLogin to bOK
89302>>>>>>>        Move False to Err
89303>>>>>>>        Get OpenTableExclusive hTable to bOK
89304>>>>>>>        If (bOK = False) Begin
89306>>>>>>>            Function_Return False
89307>>>>>>>        End
89307>>>>>>>>
89307>>>>>>>        Structure_Start hTable
89308>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
89311>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89312>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89314>>>>>>>
89314>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89315>>>>>>>        Function_Return (Err = False)
89316>>>>>>>    End_Function
89317>>>>>>>
89317>>>>>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
89319>>>>>>>        Integer iCase
89319>>>>>>>        Boolean bOK
89319>>>>>>>
89319>>>>>>>        If (bUppercase = True) Begin
89321>>>>>>>            Move DF_CASE_IGNORED to iCase
89322>>>>>>>        End
89322>>>>>>>>
89322>>>>>>>        Else Begin
89323>>>>>>>            Move DF_CASE_USED to iCase
89324>>>>>>>        End
89324>>>>>>>>
89324>>>>>>>
89324>>>>>>>        Get AutoConnectionIDLogin to bOK
89325>>>>>>>        Move False to Err
89326>>>>>>>        Get OpenTableExclusive hTable to bOK
89327>>>>>>>        If (bOK = False) Begin
89329>>>>>>>            Function_Return False
89330>>>>>>>        End
89330>>>>>>>>
89330>>>>>>>        Structure_Start hTable
89331>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
89334>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89335>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89337>>>>>>>
89337>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89338>>>>>>>        Function_Return (Err = False)
89339>>>>>>>    End_Function
89340>>>>>>>
89340>>>>>>>    // To delete an index
89340>>>>>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
89342>>>>>>>        Integer iTableNo iNumSegments
89342>>>>>>>        String sDriverID
89342>>>>>>>        Boolean bOK bIsSQLTable
89342>>>>>>>
89342>>>>>>>        Get AutoConnectionIDLogin to bOK
89343>>>>>>>        Move False to Err
89344>>>>>>>        Move hTable to iTableNo
89345>>>>>>>        Get OpenTableExclusive hTable to bOK
89346>>>>>>>        If (bOK = False) Begin
89348>>>>>>>            Function_Return False
89349>>>>>>>        End
89349>>>>>>>>
89349>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89352>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89353>>>>>>>            If (bIsSQLTable = True) Begin
89355>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89358>>>>>>>            End
89358>>>>>>>>
89358>>>>>>>
89358>>>>>>>        // Check to see if the index exists or not...
89358>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89361>>>>>>>        If (iNumSegments = 0) Begin
89363>>>>>>>            Function_Return True // Then nothing to do.
89364>>>>>>>        End
89364>>>>>>>>
89364>>>>>>>
89364>>>>>>>        Structure_Start hTable sDriverID
89365>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
89366>>>>>>>            Delete_Index iTableNo iIndex
89367>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
89368>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89369>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89371>>>>>>>
89371>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89372>>>>>>>        Function_Return (Err = False)
89373>>>>>>>    End_Function
89374>>>>>>>
89374>>>>>>>    // Delete an Index Segment
89374>>>>>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
89376>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
89376>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
89376>>>>>>>        Integer iIndexType
89376>>>>>>>        String sDriverID
89376>>>>>>>
89376>>>>>>>        Get AutoConnectionIDLogin to bOK
89377>>>>>>>        Move False to Err
89378>>>>>>>
89378>>>>>>>        Get OpenTableExclusive hTable to bOK
89379>>>>>>>        If (bOK = False) Begin
89381>>>>>>>            Function_Return False
89382>>>>>>>        End
89382>>>>>>>>
89382>>>>>>>
89382>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89383>>>>>>>            If (bIsSQLTable = True) Begin
89385>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89388>>>>>>>            End
89388>>>>>>>>
89388>>>>>>>
89388>>>>>>>        // Check to see if the index exists or not...
89388>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89391>>>>>>>        If (iNumSegments = 0) Begin
89393>>>>>>>            Function_Return False
89394>>>>>>>        End
89394>>>>>>>>
89394>>>>>>>
89394>>>>>>>        Move False to bIndexTemporary
89395>>>>>>>        Get psDriverID to sDriverID
89396>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
89397>>>>>>>        If (bSQLDriver) Begin
89399>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
89402>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
89405>>>>>>>                Move True to bIndexTemporary
89406>>>>>>>        End
89406>>>>>>>>
89406>>>>>>>
89406>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
89406>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
89408>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89411>>>>>>>            If (iSegment = iNumSegments) Begin
89413>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89416>>>>>>>            End
89416>>>>>>>>
89416>>>>>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89419>>>>>>>                For iCurSegment from iSegment to (iNumSegments - 1)
89425>>>>>>>>
89425>>>>>>>                    //*** Move index segment attributes
89425>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89428>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
89431>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
89434>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89437>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89440>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89443>>>>>>>                Loop
89444>>>>>>>>
89444>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89447>>>>>>>            End
89447>>>>>>>>
89447>>>>>>>        End
89447>>>>>>>>
89447>>>>>>>
89447>>>>>>>        Else Begin
89448>>>>>>>           Structure_Start hTable
89449>>>>>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89452>>>>>>>               If (iSegment = iNumSegments) Begin
89454>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89457>>>>>>>               End
89457>>>>>>>>
89457>>>>>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89460>>>>>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
89466>>>>>>>>
89466>>>>>>>                       //*** Move index segment attributes
89466>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89469>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
89472>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
89475>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89478>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89481>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89484>>>>>>>                   Loop
89485>>>>>>>>
89485>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89488>>>>>>>               End
89488>>>>>>>>
89488>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
89489>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89491>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89492>>>>>>>        End
89492>>>>>>>>
89492>>>>>>>
89492>>>>>>>        Function_Return (Err = False)
89493>>>>>>>    End_Function
89494>>>>>>>
89494>>>>>>>    // Add/Insert an Index Segment
89494>>>>>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
89496>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
89496>>>>>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
89496>>>>>>>        Integer iIndexType
89496>>>>>>>        String sDriverId
89496>>>>>>>
89496>>>>>>>        Get AutoConnectionIDLogin to bOK
89497>>>>>>>        Move False to Err
89498>>>>>>>
89498>>>>>>>        Get OpenTableExclusive hTable to bOK
89499>>>>>>>        If (bOK = False) Begin
89501>>>>>>>            Function_Return False
89502>>>>>>>        End
89502>>>>>>>>
89502>>>>>>>
89502>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89503>>>>>>>            If (bIsSQLTable = True) Begin
89505>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89508>>>>>>>            End
89508>>>>>>>>
89508>>>>>>>
89508>>>>>>>        Move False to bIndexTemporary
89509>>>>>>>        // Check to see if the index exists or not...
89509>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89512>>>>>>>        If (iNumSegments = 0) Begin
89514>>>>>>>            Function_Return False
89515>>>>>>>        End
89515>>>>>>>>
89515>>>>>>>
89515>>>>>>>        Get psDriverID to sDriverID
89516>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
89517>>>>>>>        If (bSQLDriver) Begin
89519>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
89522>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
89525>>>>>>>                Move True to bIndexTemporary
89526>>>>>>>        End
89526>>>>>>>>
89526>>>>>>>
89526>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
89526>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
89528>>>>>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89531>>>>>>>
89531>>>>>>>           If (iSegment > iNumSegments) Begin
89533>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89536>>>>>>>               Move (iNumSegments + 1) to iCurSegment
89537>>>>>>>           End
89537>>>>>>>>
89537>>>>>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
89540>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89543>>>>>>>               Move iNumSegments to iCurSegment
89544>>>>>>>
89544>>>>>>>               While (iCurSegment > iSegment)
89548>>>>>>>                   //*** Move index segment attributes
89548>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
89551>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
89554>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
89557>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
89560>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
89563>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
89566>>>>>>>                   Decrement iCurSegment
89567>>>>>>>               Loop
89568>>>>>>>>
89568>>>>>>>
89568>>>>>>>               //*** Now set new segment attributes
89568>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
89571>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
89574>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
89577>>>>>>>           End
89577>>>>>>>>
89577>>>>>>>        End
89577>>>>>>>>
89577>>>>>>>
89577>>>>>>>        Else Begin
89578>>>>>>>        Structure_Start hTable
89579>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89582>>>>>>>
89582>>>>>>>            If (iSegment > iNumSegments) Begin
89584>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89587>>>>>>>                Move (iNumSegments + 1) to iCurSegment
89588>>>>>>>            End
89588>>>>>>>>
89588>>>>>>>            Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
89591>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89594>>>>>>>                Move iNumSegments to iCurSegment
89595>>>>>>>
89595>>>>>>>                While (iCurSegment > iSegment)
89599>>>>>>>                    //*** Move index segment attributes
89599>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
89602>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
89605>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
89608>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89611>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89614>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89617>>>>>>>                    Decrement iCurSegment
89618>>>>>>>                Loop
89619>>>>>>>>
89619>>>>>>>
89619>>>>>>>                //*** Now set new segment attributes
89619>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
89622>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
89625>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
89628>>>>>>>            End
89628>>>>>>>>
89628>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89629>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89631>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89632>>>>>>>        End
89632>>>>>>>>
89632>>>>>>>
89632>>>>>>>        Function_Return (Err = False)
89633>>>>>>>    End_Function
89634>>>>>>>
89634>>>>>>>    // * Dummy function for the Studio's Code Explorer *
89634>>>>>>>    Function TABLE_UTILITY_FUNCTIONS Returns Boolean
89636>>>>>>>        Function_Return False
89637>>>>>>>    End_Function  
89638>>>>>>>    
89638>>>>>>>    // Preparation message before an SQL onversion. It will check and wash all embedded data tables and prepare them
89638>>>>>>>    // for an SQL conversion.
89638>>>>>>>    Function UtilPrepareDataFolderForSQLConversion Boolean bMoveMiscFilesToBackup Boolean bFixALLBogusFilelistEntries Boolean bConvertTo30Format Boolean bRepairAndReindex Boolean bFixBogusDates Returns Boolean
89640>>>>>>>        Boolean bConvertTo30FormatbOK bRepairAndReindexOK bFixBogusDatesOK bMoveMiscFilesToBackupOK
89640>>>>>>>        
89640>>>>>>>        Move True to bConvertTo30FormatbOK
89641>>>>>>>        Move True to bRepairAndReindexOK
89642>>>>>>>        Move True to bFixBogusDatesOK
89643>>>>>>>        Move True to bMoveMiscFilesToBackupOK
89644>>>>>>>        
89644>>>>>>>        If (bMoveMiscFilesToBackup = True) Begin   
89646>>>>>>>            Set Message_Text of ghoStatusPanel to "Moving misc. files to backup..."
89647>>>>>>>            Get UtilMoveMiscFilesToBackupFolder to bMoveMiscFilesToBackupOK
89648>>>>>>>        End                                                                                
89648>>>>>>>>
89648>>>>>>>        If (bFixALLBogusFilelistEntries = True) Begin
89650>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus Filelist.cfg entries..."
89651>>>>>>>            Get UtilTableFixALLBogusFilelistEntries to bFixALLBogusFilelistEntries
89652>>>>>>>        End
89652>>>>>>>>
89652>>>>>>>        If (bConvertTo30Format = True) Begin
89654>>>>>>>            Set Message_Text of ghoStatusPanel to "Converting .dat files from 2.3->..."
89655>>>>>>>            Get UtilTableConvertALLTablesFrom23Format to bConvertTo30FormatbOK
89656>>>>>>>        End                                                 
89656>>>>>>>>
89656>>>>>>>        If (bRepairAndReindex = True) Begin
89658>>>>>>>            Set Message_Text of ghoStatusPanel to "Repairing and reindexing..."
89659>>>>>>>            Get UtilTableRepairAndReindexALL to bRepairAndReindexOK
89660>>>>>>>        End  
89660>>>>>>>>
89660>>>>>>>        If (bFixBogusDates = True) Begin
89662>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
89663>>>>>>>            Get UtilTablesFixAllDateBogusValues True False to bFixBogusDatesOK
89664>>>>>>>        End                                    
89664>>>>>>>>
89664>>>>>>>        
89664>>>>>>>        Function_Return (bConvertTo30FormatbOK = True and bFixALLBogusFilelistEntries = True and bRepairAndReindexOK = True and bFixBogusDatesOK = True and bMoveMiscFilesToBackupOK = True)
89665>>>>>>>    End_Function
89666>>>>>>>
89666>>>>>>>    Function UtilTableConvertALLTablesFrom23Format Returns Boolean
89668>>>>>>>        Boolean bOK bFlexErrs bTemp
89668>>>>>>>        Handle hTable
89668>>>>>>>        String sTableName
89668>>>>>>>        Integer iCount iSize
89668>>>>>>>        
89668>>>>>>>        Move True to bOK
89669>>>>>>>        Move 0 to hTable    
89670>>>>>>>
89670>>>>>>>        Get UtilFilelistNoOfTables to iSize
89671>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89672>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89673>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89674>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89675>>>>>>>
89675>>>>>>>        Repeat
89675>>>>>>>>
89675>>>>>>>            Set Action_Text of ghoStatusPanel to "Checking if table is in 2.3 format..."
89676>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount  
89677>>>>>>>            Increment iCount
89678>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89681>>>>>>>            If (hTable > 0) Begin
89683>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89686>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
89687>>>>>>>                If (bFlexErrs = False) Begin
89689>>>>>>>                    Get UtilTableConvertFrom23Format hTable to bTemp
89690>>>>>>>                    If (bTemp = False) Begin
89692>>>>>>>                        Move False to bOK
89693>>>>>>>                    End
89693>>>>>>>>
89693>>>>>>>                End
89693>>>>>>>>
89693>>>>>>>            End
89693>>>>>>>>
89693>>>>>>>        Until (hTable = 0)
89695>>>>>>>        
89695>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89696>>>>>>>        Function_Return bOK
89697>>>>>>>    End_Function
89698>>>>>>>    
89698>>>>>>>    // Converts an embedded table from 2.3 -> 3.0.
89698>>>>>>>    // Returns: FALSE only if the table can't be opened or the conversion fails.
89698>>>>>>>    // It will return a TRUE if successful or the table is an SQL table.
89698>>>>>>>    Function UtilTableConvertFrom23Format Handle hTable Returns Boolean
89700>>>>>>>        Boolean bOK bIsEmbedded bIsAlias
89700>>>>>>>        String sRevision
89700>>>>>>>        
89700>>>>>>>        Get AutoConnectionIDLogin to bOK
89701>>>>>>>        If (bOK = False) Begin
89703>>>>>>>            Function_Return True
89704>>>>>>>        End
89704>>>>>>>>
89704>>>>>>>        Get OpenTableExclusive hTable to bOK
89705>>>>>>>        If (bOK = False) Begin
89707>>>>>>>            Function_Return True
89708>>>>>>>        End
89708>>>>>>>>
89708>>>>>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
89709>>>>>>>        If (bIsEmbedded = False) Begin
89711>>>>>>>            Function_Return True
89712>>>>>>>        End                             
89712>>>>>>>>
89712>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
89713>>>>>>>        If (bIsAlias = True) Begin
89715>>>>>>>            Function_Return True
89716>>>>>>>        End                     
89716>>>>>>>>
89716>>>>>>>        
89716>>>>>>>        Move False to Err
89717>>>>>>>        Get_Attribute DF_FILE_REVISION of hTable to sRevision
89720>>>>>>>        If (sRevision contains "2.3") Begin
89722>>>>>>>            Move False to Err
89723>>>>>>>            Set Private.phCurrentTable to hTable
89724>>>>>>>            Structure_Start hTable    
89725>>>>>>>                Set_Attribute DF_FILE_INTEGRITY_CHECK of hTable to True
89728>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table to 3.0/4.0"
89729>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
89731>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89732>>>>>>>        End
89732>>>>>>>>
89732>>>>>>>        
89732>>>>>>>        Function_Return (Err = False)
89733>>>>>>>    End_Function
89734>>>>>>>
89734>>>>>>>    Function UtilTableFixALLBogusFilelistEntries Returns Boolean
89736>>>>>>>        Boolean bIgnore bExists bOK bResponse
89736>>>>>>>        Handle hTable   
89736>>>>>>>        String sTableName
89736>>>>>>>        
89736>>>>>>>        Move False to Err 
89737>>>>>>>        Move True to bOK
89738>>>>>>>        Move 0 to hTable
89739>>>>>>>        Repeat
89739>>>>>>>>
89739>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89742>>>>>>>            If (hTable > 0) Begin
89744>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89747>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST")  to bIgnore
89748>>>>>>>                If (bIgnore = False) Begin
89750>>>>>>>                    Get _UtilTableExists hTable to bExists
89751>>>>>>>                    If (bExists = False) Begin
89753>>>>>>>                        Get ApiTableChangeFileListSlot "" "" "" hTable DATAFLEX_ID to bResponse
89754>>>>>>>                        If (bResponse = False) Begin
89756>>>>>>>                            Move False to bOK
89757>>>>>>>                        End
89757>>>>>>>>
89757>>>>>>>                        
89757>>>>>>>                    End
89757>>>>>>>>
89757>>>>>>>                End
89757>>>>>>>>
89757>>>>>>>            End
89757>>>>>>>>
89757>>>>>>>        Until (hTable = 0)                     
89759>>>>>>>        
89759>>>>>>>        Set Action_Text of ghoStatusPanel to "" 
89760>>>>>>>        Function_Return bOK
89761>>>>>>>    End_Function
89762>>>>>>>    
89762>>>>>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
89762>>>>>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
89762>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
89762>>>>>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
89762>>>>>>>    //
89762>>>>>>>    // The root of the problem is the following:
89762>>>>>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
89762>>>>>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
89762>>>>>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside
89762>>>>>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
89762>>>>>>>    // an SQL error will be thrown;
89762>>>>>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
89762>>>>>>>    Function UtilTablesFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
89764>>>>>>>        Boolean bOK bIsAlias bIsSQL
89764>>>>>>>        Integer iCount iSize iDateSize
89764>>>>>>>        Handle hTable
89764>>>>>>>        String sLogicalName
89764>>>>>>>        Integer[] aTablesToCheck aDateFields
89766>>>>>>>
89766>>>>>>>        Get _AllTablesDateCorrections to aTablesToCheck
89767>>>>>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
89768>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89769>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89770>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89771>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89772>>>>>>>
89772>>>>>>>        Move True to bOK
89773>>>>>>>        Decrement iSize
89774>>>>>>>        for iCount from 0 to iSize
89780>>>>>>>>
89780>>>>>>>            Move aTablesToCheck[iCount] to hTable
89781>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
89782>>>>>>>            Get UtilTableIsAlias hTable to bIsAlias
89783>>>>>>>            Get _UtilTableIsSql   hTable to bIsSQL
89784>>>>>>>
89784>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89787>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
89788>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
89789>>>>>>>
89789>>>>>>>            If (bIsAlias = False and bIsSQL = False) Begin
89791>>>>>>>                Get UtilCheckForDateFields hTable to aDateFields
89792>>>>>>>                Move (SizeOfArray(aDateFields)) to iDateSize
89793>>>>>>>                If (iDateSize > 0) Begin
89795>>>>>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
89796>>>>>>>                    Close hTable
89797>>>>>>>                End
89797>>>>>>>>
89797>>>>>>>            End
89797>>>>>>>>
89797>>>>>>>        Loop
89798>>>>>>>>
89798>>>>>>>
89798>>>>>>>        Close DF_ALL
89799>>>>>>>        Function_Return bOK
89800>>>>>>>    End_Function
89801>>>>>>>
89801>>>>>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
89801>>>>>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
89803>>>>>>>        Integer[] aDateFields aDateFieldsEmpty
89805>>>>>>>        Integer iSize iCount iType
89805>>>>>>>        Boolean bOpen bOK
89805>>>>>>>        
89805>>>>>>>        Get _UtilTableExists hTable to bOK
89806>>>>>>>        If (bOK = False) Begin
89808>>>>>>>            Set Private.phCurrentTable to hTable
89809>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
89810>>>>>>>>
89810>>>>>>>            Function_Return aDateFieldsEmpty
89811>>>>>>>        End
89811>>>>>>>>
89811>>>>>>>        Set Private.phCurrentTable to hTable
89812>>>>>>>        Set Private.piCurrentField to 0
89813>>>>>>>
89813>>>>>>>        Open hTable
89815>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89818>>>>>>>        If (bOpen = False) Begin
89820>>>>>>>            Function_Return aDateFieldsEmpty
89821>>>>>>>        End
89821>>>>>>>>
89821>>>>>>>
89821>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
89824>>>>>>>        For iCount from 1 to iSize
89830>>>>>>>>
89830>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
89833>>>>>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
89835>>>>>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
89836>>>>>>>            End
89836>>>>>>>>
89836>>>>>>>        Loop
89837>>>>>>>>
89837>>>>>>>
89837>>>>>>>        Function_Return aDateFields
89838>>>>>>>    End_Function
89839>>>>>>>
89839>>>>>>>    // Loops through all records for the passed hTable, and checks that all Date values
89839>>>>>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
89839>>>>>>>    // and the record is saved
89839>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
89839>>>>>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
89839>>>>>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
89841>>>>>>>        Integer iSize iCount iField iRecord iTotalRecords iDateFormat iDriverIndex
89841>>>>>>>        String sDriverID sDateMin
89841>>>>>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges 
89841>>>>>>>        Date dDate dDateMin
89841>>>>>>>        Integer[] iaChangeField
89842>>>>>>>
89842>>>>>>>        Get _UtilTableExists hTable to bOK
89843>>>>>>>        // I believe we should just skip files not found and not report an error.
89843>>>>>>>        // This is because a filelist may have entries but no files/tables on disk, but
89843>>>>>>>        // this may be adjusted by other calls to DUF in a later update package. 
89843>>>>>>>        // Especially considering that this call is probably done at the very
89843>>>>>>>        // beginning of a DUF update.
89843>>>>>>>        If (bOK = False) Begin
89845>>>>>>>//            Set Private.phCurrentTable to hTable
89845>>>>>>>//            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
89845>>>>>>>//            Function_Return False
89845>>>>>>>            Function_Return True
89846>>>>>>>        End
89846>>>>>>>>
89846>>>>>>>
89846>>>>>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the
89846>>>>>>>        // date format to "USA" = "MM/DD/YYYY"
89846>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
89849>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
89852>>>>>>>
89852>>>>>>>//        Send SetAllIndexesToBatch hTable True
89852>>>>>>>        Open hTable
89854>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
89857>>>>>>>        If (bOpened = False) Begin
89859>>>>>>>            Function_Return False
89860>>>>>>>        End
89860>>>>>>>>
89860>>>>>>>        
89860>>>>>>>        Set Private.phCurrentTable to hTable
89861>>>>>>>        Move 0 to iRecord
89862>>>>>>>        Move (SizeOfArray(aDateFields)) to iSize
89863>>>>>>>        Decrement iSize
89864>>>>>>>
89864>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89867>>>>>>>        Get DriverIndex sDriverID to iDriverIndex
89868>>>>>>>        If (iDriverIndex <> 0) Begin
89870>>>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDateMin
89873>>>>>>>            If (sDateMin = "") Begin
89875>>>>>>>                Move CS_DUFLowestAllowedDateValue to dDateMin
89876>>>>>>>            End
89876>>>>>>>>
89876>>>>>>>            Else Begin
89877>>>>>>>                If (IsDate(sDateMin)) Begin
89879>>>>>>>                    Move sDateMin to dDateMin
89880>>>>>>>                End
89880>>>>>>>>
89880>>>>>>>                Else Begin
89881>>>>>>>                    Move CS_DUFLowestAllowedDateValue to dDateMin
89882>>>>>>>                End
89882>>>>>>>>
89882>>>>>>>            End
89882>>>>>>>>
89882>>>>>>>        End
89882>>>>>>>>
89882>>>>>>>        Else Begin
89883>>>>>>>            Move CS_DUFLowestAllowedDateValue to dDateMin
89884>>>>>>>        End
89884>>>>>>>>
89884>>>>>>>
89884>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
89887>>>>>>>        Set piPosition   of ghoProgressBar to 0
89888>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 100
89889>>>>>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
89890>>>>>>>        Move False to Err
89891>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89892>>>>>>>
89892>>>>>>>        Clear hTable
89893>>>>>>>        Repeat
89893>>>>>>>>
89893>>>>>>>            Vfind hTable 0 GT
89895>>>>>>>            Move Found to bFound
89896>>>>>>>            If (bFound = True) Begin
89898>>>>>>>                Move False to bSaveChanges
89899>>>>>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField
89900>>>>>>>                Move (SizeOfArray(aDateFields)) to iSize
89901>>>>>>>                Decrement iSize
89902>>>>>>>                For iCount from 0 to iSize
89908>>>>>>>>
89908>>>>>>>                    Move aDateFields[iCount] to iField
89909>>>>>>>                    Get_Field_Value hTable iField to dDate
89912>>>>>>>                    If (bFixZeroDates = True) Begin
89914>>>>>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
89915>>>>>>>                    End
89915>>>>>>>>
89915>>>>>>>                    Else Begin
89916>>>>>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
89917>>>>>>>                    End
89917>>>>>>>>
89917>>>>>>>                    If (bChange = True) Begin
89919>>>>>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]
89920>>>>>>>                    End
89920>>>>>>>>
89920>>>>>>>                Loop
89921>>>>>>>>
89921>>>>>>>
89921>>>>>>>                // Only change Date fields that needs to be changed.
89921>>>>>>>                If (SizeOfArray(iaChangeField)) Begin
89923>>>>>>>                    Reread hTable
89927>>>>>>>                        Move (SizeOfArray(iaChangeField)) to iSize
89928>>>>>>>                        Decrement iSize
89929>>>>>>>                        For iCount from 0 to iSize
89935>>>>>>>>
89935>>>>>>>                            Move iaChangeField[iCount] to iField
89936>>>>>>>                            Set Private.piCurrentField to iField
89937>>>>>>>                            Set_Field_Value hTable iField to dDateMin
89940>>>>>>>                        Loop
89941>>>>>>>>
89941>>>>>>>                        Move False to Err
89942>>>>>>>                        SaveRecord hTable
89943>>>>>>>                    Unlock
89944>>>>>>>>
89944>>>>>>>                End
89944>>>>>>>>
89944>>>>>>>
89944>>>>>>>                Increment iRecord
89945>>>>>>>                // Increment the StatusPanel counter and check the
89945>>>>>>>                // cancel status every 100 records rather than every
89945>>>>>>>                // record, it's way faster.
89945>>>>>>>                If (Mod(iRecord, 100) = 0) Begin
89947>>>>>>>                    Send DoAdvance of ghoProgressBar
89948>>>>>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
89949>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
89950>>>>>>>                End
89950>>>>>>>>
89950>>>>>>>            End
89950>>>>>>>>
89950>>>>>>>        Until (bFound = False)
89952>>>>>>>
89952>>>>>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
89955>>>>>>>        If (bResetIndexesToOnLine = True) Begin
89957>>>>>>>            Send SetAllIndexesToBatch hTable False
89958>>>>>>>        End
89958>>>>>>>>
89958>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89959>>>>>>>
89959>>>>>>>        Function_Return (Err = False)
89960>>>>>>>    End_Function
89961>>>>>>>
89961>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
89961>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
89961>>>>>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
89963>>>>>>>        Boolean bIsSame
89963>>>>>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
89963>>>>>>>
89963>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
89964>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
89965>>>>>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
89966>>>>>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
89967>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
89968>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
89969>>>>>>>
89969>>>>>>>        If (bCompareFilelistUppercase = True) Begin
89971>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
89972>>>>>>>        End
89972>>>>>>>>
89972>>>>>>>        Else Begin
89973>>>>>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
89974>>>>>>>        End
89974>>>>>>>>
89974>>>>>>>        If (bIsSame = False) Begin
89976>>>>>>>            Function_Return False
89977>>>>>>>        End
89977>>>>>>>>
89977>>>>>>>
89977>>>>>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
89978>>>>>>>        If (bIsSame = False) Begin
89980>>>>>>>            Function_Return False
89981>>>>>>>        End
89981>>>>>>>>
89981>>>>>>>
89981>>>>>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
89982>>>>>>>        If (bIsSame = False) Begin
89984>>>>>>>            Function_Return False
89985>>>>>>>        End
89985>>>>>>>>
89985>>>>>>>
89985>>>>>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
89986>>>>>>>        If (bIsSame = False) Begin
89988>>>>>>>            Function_Return False
89989>>>>>>>        End
89989>>>>>>>>
89989>>>>>>>
89989>>>>>>>        Function_Return bIsSame
89990>>>>>>>    End_Function
89991>>>>>>>
89991>>>>>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89993>>>>>>>        Handle hTableFrom hTableTo
89993>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
89993>>>>>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
89993>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
89993>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89993>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89994>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89994>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89995>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89995>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89996>>>>>>>
89996>>>>>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
89997>>>>>>>        If (bIsSame = True) Begin
89999>>>>>>>            Function_Return True
90000>>>>>>>        End
90000>>>>>>>>
90000>>>>>>>
90000>>>>>>>        Move False to bFilelistError
90001>>>>>>>        Move True to bIsSame
90002>>>>>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
90003>>>>>>>        Get pbCompareIndexAscending to bCompareIndexAscending
90004>>>>>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
90005>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
90006>>>>>>>        Set Private.phCurrentTable to hTableFrom
90007>>>>>>>        
90007>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
90008>>>>>>>
90008>>>>>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
90009>>>>>>>        Get _TableNameOnly sRootName             to sRootName
90010>>>>>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
90011>>>>>>>
90011>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
90011>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
90011>>>>>>>        If (bCodeGenerateMode = True) Begin
90013>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
90013>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
90015>>>>>>>                Function_Return False
90016>>>>>>>            End
90016>>>>>>>>
90016>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
90017>>>>>>>            If (bIsSame = False) Begin
90019>>>>>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
90020>>>>>>>                Move True to bFilelistError
90021>>>>>>>                Function_Return False
90022>>>>>>>            End
90022>>>>>>>>
90022>>>>>>>        End
90022>>>>>>>>
90022>>>>>>>
90022>>>>>>>        If (bCodeGenerateMode = False) Begin
90024>>>>>>>            // Then we want to create this table
90024>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
90026>>>>>>>                Function_Return False
90027>>>>>>>            End
90027>>>>>>>>
90027>>>>>>>
90027>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
90028>>>>>>>            If (bIsSame = False) Begin
90030>>>>>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
90031>>>>>>>>
90031>>>>>>>                Move True to bFilelistError
90032>>>>>>>                Function_Return False
90033>>>>>>>            End
90033>>>>>>>>
90033>>>>>>>        End
90033>>>>>>>>
90033>>>>>>>
90033>>>>>>>        // Check columns:
90033>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
90034>>>>>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
90035>>>>>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
90036>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
90037>>>>>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
90038>>>>>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
90039>>>>>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
90040>>>>>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
90041>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
90042>>>>>>>        If (bIsSame = False) Begin
90044>>>>>>>            Function_Return False
90045>>>>>>>        End
90045>>>>>>>>
90045>>>>>>>
90045>>>>>>>        // ...then check indexes:
90045>>>>>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
90046>>>>>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
90047>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
90048>>>>>>>        If (bIsSame = False) Begin
90050>>>>>>>            Function_Return False
90051>>>>>>>        End
90051>>>>>>>>
90051>>>>>>>
90051>>>>>>>        // ...and finally relationships:
90051>>>>>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
90052>>>>>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
90053>>>>>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
90054>>>>>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
90055>>>>>>>
90055>>>>>>>        Function_Return (bIsSame = True)
90056>>>>>>>    End_Function
90057>>>>>>>
90057>>>>>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
90057>>>>>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
90059>>>>>>>        Handle hTable
90059>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
90059>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
90059>>>>>>>
90059>>>>>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
90061>>>>>>>            Move True to bFilelistError
90062>>>>>>>            Function_Return False
90063>>>>>>>        End
90063>>>>>>>>
90063>>>>>>>
90063>>>>>>>        Move APITableCompare.hTable to hTable
90064>>>>>>>        Move True  to bIsSame
90065>>>>>>>        Move False to bFilelistError
90066>>>>>>>
90066>>>>>>>        If (APITableCompare.bExistsFrom = True) Begin
90068>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
90069>>>>>>>        End
90069>>>>>>>>
90069>>>>>>>        Else Begin
90070>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
90071>>>>>>>        End
90071>>>>>>>>
90071>>>>>>>        Get _TableNameOnly sRootName                                   to sRootName
90072>>>>>>>
90072>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
90073>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
90074>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
90075>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
90076>>>>>>>
90076>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
90076>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
90076>>>>>>>        If (bCodeGenerateMode = True) Begin
90078>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
90078>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
90080>>>>>>>                Function_Return False
90081>>>>>>>            End
90081>>>>>>>>
90081>>>>>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
90082>>>>>>>            If (bIsSame = False) Begin
90084>>>>>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
90085>>>>>>>                Move True to bFilelistError
90086>>>>>>>                Function_Return False
90087>>>>>>>            End
90087>>>>>>>>
90087>>>>>>>        End
90087>>>>>>>>
90087>>>>>>>
90087>>>>>>>        If (bCodeGenerateMode = False) Begin
90089>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
90091>>>>>>>                // Then we might want to create this table
90091>>>>>>>                Function_Return False
90092>>>>>>>            End
90092>>>>>>>>
90092>>>>>>>
90092>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
90093>>>>>>>            If (bIsSame = False) Begin
90095>>>>>>>                Function_Return False
90096>>>>>>>            End
90096>>>>>>>>
90096>>>>>>>
90096>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
90097>>>>>>>            If (bIsSame = False) Begin
90099>>>>>>>                Function_Return False
90100>>>>>>>            End
90100>>>>>>>>
90100>>>>>>>
90100>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
90101>>>>>>>            If (bIsSame = False) Begin
90103>>>>>>>                Function_Return False
90104>>>>>>>            End
90104>>>>>>>>
90104>>>>>>>
90104>>>>>>>            // Check table names et al.
90104>>>>>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
90105>>>>>>>            If (bIsSame = False) Begin
90107>>>>>>>                Function_Return False
90108>>>>>>>            End
90108>>>>>>>>
90108>>>>>>>        End
90108>>>>>>>>
90108>>>>>>>
90108>>>>>>>        // Check Columns:
90108>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
90109>>>>>>>        If (bIsSame = False) Begin
90111>>>>>>>            Function_Return False
90112>>>>>>>        End
90112>>>>>>>>
90112>>>>>>>
90112>>>>>>>        // ...then check Indexes:
90112>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
90113>>>>>>>        If (bIsSame = False) Begin
90115>>>>>>>            Function_Return False
90116>>>>>>>        End
90116>>>>>>>>
90116>>>>>>>
90116>>>>>>>        // ...and finally Relationships:
90116>>>>>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
90117>>>>>>>
90117>>>>>>>        Function_Return (bIsSame = True)
90118>>>>>>>    End_Function
90119>>>>>>>
90119>>>>>>>    // To fill a complete Table array structure (tAPITable[]) with data.
90119>>>>>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
90119>>>>>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
90119>>>>>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
90119>>>>>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
90121>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90121>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90121>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
90121>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
90123>>>>>>>        tAPIColumn[]    aApiColumns
90123>>>>>>>        tAPIColumn[]    aApiColumns
90124>>>>>>>        tAPIIndex[]     aApiIndexes
90124>>>>>>>        tAPIIndex[]     aApiIndexes
90125>>>>>>>        tAPIRelation[]  aApiRelations
90125>>>>>>>        tAPIRelation[]  aApiRelations
90126>>>>>>>        Handle hTable
90126>>>>>>>        Integer iCount
90126>>>>>>>        Boolean bUserCancel bOK
90126>>>>>>>        String sLogicalName sMessageText
90126>>>>>>>
90126>>>>>>>        Get AutoConnectionIDLogin to bOK
90127>>>>>>>        Move 0 to hTable
90128>>>>>>>        If (bFromTables = True) Begin
90130>>>>>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
90131>>>>>>>            If (bCompareUtil = True) Begin
90133>>>>>>>                Move (sMessageText * "(1 of 3)") to sMessageText
90134>>>>>>>            End
90134>>>>>>>>
90134>>>>>>>        End
90134>>>>>>>>
90134>>>>>>>        Else Begin
90135>>>>>>>            Move "Reading 'TO' Table Structure:" to sMessageText
90136>>>>>>>            If (bCompareUtil = True) Begin
90138>>>>>>>                Move (sMessageText * "(2 of 3)") to sMessageText
90139>>>>>>>            End
90139>>>>>>>>
90139>>>>>>>        End
90139>>>>>>>>
90139>>>>>>>        Set Message_Text of ghoStatusPanel to sMessageText
90140>>>>>>>
90140>>>>>>>        Get UtilFilelistNoOfTables to iCount
90141>>>>>>>        Set piMaximum of ghoProgressBar to iCount
90142>>>>>>>        Move 0 to iCount
90143>>>>>>>
90143>>>>>>>        Repeat
90143>>>>>>>>
90143>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90146>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
90148>>>>>>>
90148>>>>>>>                Open hTable
90150>>>>>>>                // ToDo: Needs to be revised
90150>>>>>>>                // For some reason tables may be reported as "unopened", while in
90150>>>>>>>                // fact the open was successful (!)
90150>>>>>>>//                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90150>>>>>>>//                If (bIsOpen = False) Begin
90150>>>>>>>//                    Move True to aApiTablesEmpty[0].bError
90150>>>>>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
90150>>>>>>>//                    Function_Return aApiTablesEmpty
90150>>>>>>>//                End
90150>>>>>>>
90150>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90153>>>>>>>                Set piPosition of ghoProgressBar to iCount
90154>>>>>>>                Send DoAdvance of ghoProgressBarOverall
90155>>>>>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
90156>>>>>>>
90156>>>>>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
90157>>>>>>>//                Close hTable DF_PERMANENT
90157>>>>>>>                Increment iCount
90158>>>>>>>            End
90158>>>>>>>>
90158>>>>>>>
90158>>>>>>>            If (bStatusPanel = True) Begin
90160>>>>>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
90161>>>>>>>                If (bUserCancel = True) Begin
90163>>>>>>>                    Move True to aApiTablesEmpty[0].bCancel
90164>>>>>>>                    Function_Return aApiTablesEmpty
90165>>>>>>>                End
90165>>>>>>>>
90165>>>>>>>            End
90165>>>>>>>>
90165>>>>>>>
90165>>>>>>>        Until (hTable = 0)
90167>>>>>>>
90167>>>>>>>        Function_Return aApiTables
90168>>>>>>>    End_Function
90169>>>>>>>
90169>>>>>>>    // Returns a 'single' table APITable struct.
90169>>>>>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
90171>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90171>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90171>>>>>>>        tAPITable         ApiTable ApiTableEmpty
90171>>>>>>>        tAPITable         ApiTable ApiTableEmpty
90171>>>>>>>        tAPIColumn[]     aApiColumns
90171>>>>>>>        tAPIColumn[]     aApiColumns
90172>>>>>>>        tAPIIndex[]      aApiIndexes
90172>>>>>>>        tAPIIndex[]      aApiIndexes
90173>>>>>>>        tAPIRelation[]   aApiRelations
90173>>>>>>>        tAPIRelation[]   aApiRelations
90174>>>>>>>        Boolean bIsOpen
90174>>>>>>>
90174>>>>>>>        Open hTable
90176>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90179>>>>>>>        If (bIsOpen = False) Begin
90181>>>>>>>            Move True to ApiTableEmpty.bError
90182>>>>>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90183>>>>>>>            Function_Return ApiTableEmpty
90184>>>>>>>        End
90184>>>>>>>>
90184>>>>>>>
90184>>>>>>>        // Fill Table Name Info
90184>>>>>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
90185>>>>>>>
90185>>>>>>>        // Fill columns
90185>>>>>>>        Get UtilColumnsStructFill hTable to aApiColumns
90186>>>>>>>        If (SizeOfArray(aApiColumns)) Begin
90188>>>>>>>            If (aApiColumns[0].bCancel = True) Begin
90190>>>>>>>                Move True to ApiTableEmpty.bError
90191>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90192>>>>>>>                Function_Return ApiTableEmpty
90193>>>>>>>            End
90193>>>>>>>>
90193>>>>>>>        End
90193>>>>>>>>
90193>>>>>>>
90193>>>>>>>        // Fill indexes
90193>>>>>>>        Get UtilIndexesStructFill hTable to aApiIndexes
90194>>>>>>>        If (SizeOfArray(aApiIndexes)) Begin
90196>>>>>>>            If (aApiIndexes[0].bCancel = True) Begin
90198>>>>>>>                Move True to ApiTableEmpty.bError
90199>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90200>>>>>>>                Function_Return ApiTableEmpty
90201>>>>>>>            End
90201>>>>>>>>
90201>>>>>>>        End
90201>>>>>>>>
90201>>>>>>>
90201>>>>>>>        // Fill relationships
90201>>>>>>>        Get UtilRelationsStructFill hTable to aApiRelations
90202>>>>>>>        If (SizeOfArray(aApiRelations)) Begin
90204>>>>>>>            If (aApiRelations[0].bCancel = True) Begin
90206>>>>>>>                Move True to ApiTableEmpty.bError
90207>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90208>>>>>>>                Function_Return ApiTableEmpty
90209>>>>>>>            End
90209>>>>>>>>
90209>>>>>>>        End
90209>>>>>>>>
90209>>>>>>>
90209>>>>>>>        Move hTable             to ApiTable.hTable
90210>>>>>>>        Move bFromTables        to ApiTable.bFromTable
90211>>>>>>>        Move (not(bFromTables)) to ApiTable.bToTable
90212>>>>>>>
90212>>>>>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
90213>>>>>>>        Move aApiColumns        to ApiTable.aApiColumns
90214>>>>>>>        Move aApiIndexes        to ApiTable.aApiIndexes
90215>>>>>>>        Move aApiRelations      to ApiTable.aApiRelations
90216>>>>>>>
90216>>>>>>>        Function_Return ApiTable
90217>>>>>>>    End_Function
90218>>>>>>>
90218>>>>>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
90220>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
90220>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
90220>>>>>>>        Boolean bIsOpen
90220>>>>>>>
90220>>>>>>>        Open hTable
90222>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90225>>>>>>>        If (bIsOpen = False) Begin
90227>>>>>>>            Move True   to APITableNameInfoEmpty.bError
90228>>>>>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
90229>>>>>>>            Function_Return APITableNameInfoEmpty
90230>>>>>>>        End
90230>>>>>>>>
90230>>>>>>>
90230>>>>>>>        Move hTable                                  to APITableNameInfo.iTableNumber
90231>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
90234>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
90237>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
90240>>>>>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
90243>>>>>>>
90243>>>>>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
90244>>>>>>>        Get _UtilTableIsSql                   hTable to APITableNameInfo.bIsSQL
90245>>>>>>>
90245>>>>>>>        Function_Return APITableNameInfo
90246>>>>>>>    End_Function
90247>>>>>>>
90247>>>>>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
90249>>>>>>>        Integer iSize iCount iItem
90249>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90249>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90249>>>>>>>
90249>>>>>>>        Move -1 to iItem
90250>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
90251>>>>>>>        Decrement iSize
90252>>>>>>>        for iCount from 0 to iSize
90258>>>>>>>>
90258>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
90259>>>>>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
90261>>>>>>>                Move iCount to iItem
90262>>>>>>>                Move iSize  to iCount // We're done.
90263>>>>>>>            End
90263>>>>>>>>
90263>>>>>>>        Loop
90264>>>>>>>>
90264>>>>>>>
90264>>>>>>>        Function_Return iItem
90265>>>>>>>    End_Function
90266>>>>>>>
90266>>>>>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
90268>>>>>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
90271>>>>>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
90274>>>>>>>
90274>>>>>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
90277>>>>>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
90280>>>>>>>
90280>>>>>>>        Function_Return (EQ)
90281>>>>>>>    End_Function
90282>>>>>>>
90282>>>>>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
90284>>>>>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
90284>>>>>>>        Handle hTable
90284>>>>>>>        tAPITable[] aAPITableFromAndTo
90284>>>>>>>        tAPITable[] aAPITableFromAndTo
90285>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
90285>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
90285>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90285>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90285>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
90285>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
90286>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
90286>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
90287>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
90287>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
90288>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
90288>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
90289>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
90289>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
90289>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
90289>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
90292>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
90292>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
90295>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
90295>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
90298>>>>>>>
90298>>>>>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
90299>>>>>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
90300>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
90302>>>>>>>            Function_Return aAPITableCompare
90303>>>>>>>        End
90303>>>>>>>>
90303>>>>>>>
90303>>>>>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
90304>>>>>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
90305>>>>>>>
90305>>>>>>>        Move 0 to iItem
90306>>>>>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
90307>>>>>>>        Decrement iSize
90308>>>>>>>        for iCount from 0 to iSize
90314>>>>>>>>
90314>>>>>>>
90314>>>>>>>            Move iCount to iItemFrom
90315>>>>>>>            Move iCount to iItemTo
90316>>>>>>>            Move APITableEmpty to APITableFrom
90317>>>>>>>            Move APITableEmpty to APITableTo
90318>>>>>>>
90318>>>>>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
90320>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
90321>>>>>>>            End
90321>>>>>>>>
90321>>>>>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
90323>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
90324>>>>>>>            End
90324>>>>>>>>
90324>>>>>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
90326>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
90327>>>>>>>                Move (iCount + 1) to iItemTo
90328>>>>>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
90329>>>>>>>            End
90329>>>>>>>>
90329>>>>>>>            If (APITableFrom.hTable > APITableTo.hTable) Begin
90331>>>>>>>                Get FindTableNumber aAPITableTo APITableFrom.hTable to iItemTo
90332>>>>>>>                If (iItemTo <> -1) Begin
90334>>>>>>>                    Move aAPITableTo[iItemTo] to APITableTo
90335>>>>>>>                End
90335>>>>>>>>
90335>>>>>>>                Else Begin
90336>>>>>>>                    Move APITableEmpty to APITableTo
90337>>>>>>>                End
90337>>>>>>>>
90337>>>>>>>            End
90337>>>>>>>>
90337>>>>>>>
90337>>>>>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
90338>>>>>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
90339>>>>>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
90340>>>>>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
90341>>>>>>>
90341>>>>>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
90342>>>>>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
90343>>>>>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
90344>>>>>>>            Move APITableTo.aApiRelations   to aApiRelationTo
90345>>>>>>>
90345>>>>>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
90346>>>>>>>
90346>>>>>>>            If (hTable > 0) Begin
90348>>>>>>>
90348>>>>>>>                // Table info:
90348>>>>>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
90349>>>>>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
90350>>>>>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
90351>>>>>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
90352>>>>>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
90353>>>>>>>
90353>>>>>>>                // Column info:
90353>>>>>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
90354>>>>>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
90355>>>>>>>
90355>>>>>>>                // Index info:
90355>>>>>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
90356>>>>>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
90357>>>>>>>
90357>>>>>>>                // Relation info:
90357>>>>>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
90358>>>>>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
90359>>>>>>>
90359>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
90360>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
90361>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bError
90362>>>>>>>                If (iItemTo > iItemFrom) Begin
90364>>>>>>>                    Increment iCount
90365>>>>>>>                End
90365>>>>>>>>
90365>>>>>>>                Increment iItem
90366>>>>>>>            End
90366>>>>>>>>
90366>>>>>>>
90366>>>>>>>        Loop
90367>>>>>>>>
90367>>>>>>>
90367>>>>>>>        Function_Return aAPITableCompare
90368>>>>>>>    End_Function
90369>>>>>>>
90369>>>>>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
90371>>>>>>>        Integer iSize iCount iItem
90371>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90371>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90371>>>>>>>
90371>>>>>>>        Move -1 to iItem
90372>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
90373>>>>>>>        Decrement iSize
90374>>>>>>>        For iCount from 0 to iSize
90380>>>>>>>>
90380>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
90381>>>>>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
90383>>>>>>>                Move iCount to iItem
90384>>>>>>>                Move iSize  to iCount // We're done.
90385>>>>>>>            End
90385>>>>>>>>
90385>>>>>>>        Loop
90386>>>>>>>>
90386>>>>>>>
90386>>>>>>>        Function_Return iItem
90387>>>>>>>    End_Function
90388>>>>>>>
90388>>>>>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
90390>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90390>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90390>>>>>>>
90390>>>>>>>        If (APITableNameInfoFrom.iTableNumber = 0 and APITableNameInfoTo.iTableNumber = 0) Begin
90392>>>>>>>            Function_Return APITableNameInfoCompare
90393>>>>>>>        End
90393>>>>>>>>
90393>>>>>>>
90393>>>>>>>        // FROM database info:
90393>>>>>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
90395>>>>>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
90396>>>>>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
90397>>>>>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
90398>>>>>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
90399>>>>>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
90400>>>>>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
90401>>>>>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
90402>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
90403>>>>>>>        End
90403>>>>>>>>
90403>>>>>>>
90403>>>>>>>        // TO database info:
90403>>>>>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
90405>>>>>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
90406>>>>>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
90407>>>>>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
90408>>>>>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
90409>>>>>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
90410>>>>>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
90411>>>>>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
90412>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsTo
90413>>>>>>>        End
90413>>>>>>>>
90413>>>>>>>
90413>>>>>>>        Function_Return APITableNameInfoCompare
90414>>>>>>>    End_Function
90415>>>>>>>
90415>>>>>>>    // Note:
90415>>>>>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
90415>>>>>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
90415>>>>>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
90415>>>>>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
90415>>>>>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
90415>>>>>>>    Function UtilTableHandleToString Handle hTable Returns String
90417>>>>>>>        String sTableName
90417>>>>>>>        Boolean bOpen bExists bOK
90417>>>>>>>
90417>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
90418>>>>>>>        If (bExists = False) Begin
90420>>>>>>>            Function_Return ""
90421>>>>>>>        End
90421>>>>>>>>
90421>>>>>>>
90421>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90422>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90425>>>>>>>        If (bOpen = False) Begin
90427>>>>>>>            Get AutoConnectionIDLogin to bOK
90428>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90429>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
90430>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
90431>>>>>>>            Open hTable
90433>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90434>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
90435>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
90436>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
90439>>>>>>>        End
90439>>>>>>>>
90439>>>>>>>        If (bOpen = True) Begin
90441>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90442>>>>>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
90445>>>>>>>            // If blank it is an embedded table:
90445>>>>>>>            If (sTableName = "") Begin
90447>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
90450>>>>>>>                Move 0 to LastErr
90451>>>>>>>                Move False to Err
90452>>>>>>>            End
90452>>>>>>>>
90452>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90453>>>>>>>        End
90453>>>>>>>>
90453>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90454>>>>>>>        Move 0 to LastErr
90455>>>>>>>
90455>>>>>>>        Function_Return sTableName
90456>>>>>>>    End_Function
90457>>>>>>>
90457>>>>>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
90457>>>>>>>    // Returns 0 if unsuccessful.
90457>>>>>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
90457>>>>>>>    Function UtilTableNameToHandle String sTableName Returns Integer
90459>>>>>>>        String sValue sPrefixTableName sDriverID
90459>>>>>>>        Handle hTable hRetval
90459>>>>>>>
90459>>>>>>>        Get psDriverID to sDriverID
90460>>>>>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
90462>>>>>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
90463>>>>>>>        End
90463>>>>>>>>
90463>>>>>>>        Move 0 to hTable
90464>>>>>>>        Move 0 to hRetval
90465>>>>>>>        Repeat
90465>>>>>>>>
90465>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90468>>>>>>>            If (hTable <> 0) Begin
90470>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
90473>>>>>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
90475>>>>>>>                    Move hTable to hRetval
90476>>>>>>>                    Move 0 to hTable
90477>>>>>>>                End
90477>>>>>>>>
90477>>>>>>>            End
90477>>>>>>>>
90477>>>>>>>        Until (hTable = 0)
90479>>>>>>>
90479>>>>>>>        Function_Return hRetval
90480>>>>>>>    End_Function
90481>>>>>>>
90481>>>>>>>    // Use function to move all *.dat, *.k?? & *.hdr files to a "Data\Backup" folder
90481>>>>>>>    // _after_ all tables have successfully been converted to SQL (.int files)
90481>>>>>>>    Function UtilMoveAllEmbeddedToBackupFolder Returns Boolean
90483>>>>>>>        Boolean bOK bExists
90483>>>>>>>        String sDataPath sBackupFolder
90483>>>>>>>
90483>>>>>>>        Close DF_ALL DF_PERMANENT
90484>>>>>>>        Send DoAdvance of ghoProgressBar
90485>>>>>>>
90485>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
90486>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
90487>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
90488>>>>>>>        Get vFolderFormat sDataPath to sDataPath
90489>>>>>>>
90489>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
90490>>>>>>>        If (bExists = False) Begin
90492>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
90493>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
90494>>>>>>>            If (bExists = False) Begin
90496>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
90497>>>>>>>>
90497>>>>>>>                Function_Return False
90498>>>>>>>            End
90498>>>>>>>>
90498>>>>>>>        End
90498>>>>>>>>
90498>>>>>>>
90498>>>>>>>        Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
90499>>>>>>>        Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
90500>>>>>>>        Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
90501>>>>>>>        Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
90502>>>>>>>        // We need to wait for Windows before we can copy files back
90502>>>>>>>        Sleep 2  
90503>>>>>>>        
90503>>>>>>>        //...except for these files that needs to be copied back to the Data folder:
90503>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeMast.*")  sDataPath to bOK 
90504>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeType.*")  sDataPath to bOK                                 
90505>>>>>>>        Get vCopyFile (sBackupFolder + "\Flexerrs.*")  sDataPath to bOK                                 
90506>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr001.*")  sDataPath to bOK                                 
90507>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr002.*")  sDataPath to bOK                                 
90508>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr003.*")  sDataPath to bOK                                 
90509>>>>>>>//            Get vCopyFile (sBackupFolder + "\DbVersion.*") sDataPath to bOK  
90509>>>>>>>        
90509>>>>>>>
90509>>>>>>>        Set Message_Text of ghoStatusPanel to ""
90510>>>>>>>        Function_Return True
90511>>>>>>>    End_Function
90512>>>>>>>    
90512>>>>>>>    Function UtilTableRepairAndReindexALL Returns Boolean
90514>>>>>>>        Boolean bOK bRetval
90514>>>>>>>        Handle hTable
90514>>>>>>>        Integer iSize iCount
90514>>>>>>>        
90514>>>>>>>        Move True to bOK
90515>>>>>>>        Get UtilFilelistNoOfTables to iSize
90516>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
90517>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
90518>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
90519>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
90520>>>>>>>
90520>>>>>>>        Repeat
90520>>>>>>>>
90520>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
90521>>>>>>>            Increment iCount
90522>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90525>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin // 50 = Flexerrs.
90527>>>>>>>                Get UtilTableRepairAndReindex hTable to bRetval
90528>>>>>>>                If (bRetval = False) Begin
90530>>>>>>>                    Move False to bOK
90531>>>>>>>                End
90531>>>>>>>>
90531>>>>>>>            End
90531>>>>>>>>
90531>>>>>>>        Until (hTable = 0)
90533>>>>>>>                
90533>>>>>>>        Function_Return bOK
90534>>>>>>>    End_Function           
90535>>>>>>>    
90535>>>>>>>    // Checks if an Embedded (DataFlex) data-file needs to be repaired.
90535>>>>>>>    // After the header has been repaired - also makes a re-index.  
90535>>>>>>>    // Returns TRUE if successful OR the table was an an ALIAS or SQL table in case we do nothing.
90535>>>>>>>    Function UtilTableRepairAndReindex Handle hTable Returns Boolean
90537>>>>>>>        Boolean bOK bIsAlias bIsEmbedded bIsOpen bBadExists
90537>>>>>>>        Integer iRetval
90537>>>>>>>        String sRootName sFileName sDataPath
90537>>>>>>>        
90537>>>>>>>        Move False to Err
90538>>>>>>>        Move 0 to LastErr 
90539>>>>>>>        Move True to bOK
90540>>>>>>>        
90540>>>>>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
90541>>>>>>>        If (bIsEmbedded = False or hTable = 50) Begin // 50 = Flexerrs
90543>>>>>>>            Function_Return True
90544>>>>>>>        End
90544>>>>>>>>
90544>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias 
90545>>>>>>>        If (bIsAlias = True) Begin
90547>>>>>>>            Function_Return True
90548>>>>>>>        End
90548>>>>>>>>
90548>>>>>>>        
90548>>>>>>>        // Check for bad file and remove if exists
90548>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
90551>>>>>>>        Set private.phCurrentTable to hTable  
90552>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
90553>>>>>>>        
90553>>>>>>>        // This is important! Else it can happen that the table can't be opened,
90553>>>>>>>        // with a "4077 - File in use" error.
90553>>>>>>>        Close DF_ALL DF_PERMANENT    
90554>>>>>>>        Open hTable
90556>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90559>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90560>>>>>>>        If (bIsOpen = False) Begin
90562>>>>>>>            Error DFERR_PROGRAM ("Could not open table to be repaired and reindexed:" * String(sRootName))
90563>>>>>>>>
90563>>>>>>>            Function_Return False        
90564>>>>>>>        End
90564>>>>>>>>
90564>>>>>>>
90564>>>>>>>        Get vFilePathExists (sRootName + ".BAD")  to bBadExists
90565>>>>>>>        If (bBadExists = True) Begin
90567>>>>>>>            Get_File_Path (sRootName + ".BAD") to sFileName
90568>>>>>>>            Get vDeleteFile sFileName to iRetval
90569>>>>>>>        End
90569>>>>>>>>
90569>>>>>>>        
90569>>>>>>>        Set TableName_Text of ghoStatusPanel to ("Repairing and reindex Table Name:" * sRootName * "Number:" * String(hTable))
90570>>>>>>>        
90570>>>>>>>        Move False to Err
90571>>>>>>>        // **** Repair and reindex the table. ****
90571>>>>>>>        Get UtilTableRepairEmbedded hTable sRootName to bOK
90572>>>>>>>
90572>>>>>>>        // Check for bad file: if it exists, something went wrong
90572>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
90573>>>>>>>        Get vFolderFormat sDataPath to sDataPath
90574>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".BAD") to bBadExists
90575>>>>>>>        If (bBadExists = True) Begin
90577>>>>>>>            Error DFERR_PROGRAM ("Error while sorting data. .BAD file created:"  * String(sRootName) + ".BAD")
90578>>>>>>>>
90578>>>>>>>            Move False to bOK
90579>>>>>>>        End
90579>>>>>>>>
90579>>>>>>>        Close hTable
90580>>>>>>>
90580>>>>>>>        Function_Return bOK
90581>>>>>>>    End_Function
90582>>>>>>>
90582>>>>>>>    // Repair and reindex the named DataFlex data-table.
90582>>>>>>>    // No checks are done if the passed table name is an embedded or SQL,
90582>>>>>>>    // so use with care (make sure you only pass embedded table names).
90582>>>>>>>    Function UtilTableRepairEmbedded Handle hTable String sTableName Returns Boolean
90584>>>>>>>        String sMode
90584>>>>>>>        Integer iVoid
90584>>>>>>>
90584>>>>>>>        Set Message_Text of ghoStatusPanel to "Repair/Reindex in progress..."
90585>>>>>>>        Move "0" to sMode   // 0=Reindex after repair!    
90586>>>>>>>        Close hTable        // The table needs to be closed, else error 4177 "Table in use".
90587>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_REPAIR_FILE Callback ghoDbUpdateHandler Passing sTableName sMode 0 Result iVoid 
90592>>>>>>>        Set Message_Text of ghoStatusPanel to ""
90593>>>>>>>        Function_Return (iVoid = 0)
90594>>>>>>>    End_Function
90595>>>>>>>
90595>>>>>>>    // Returns _two_ arrays.
90595>>>>>>>    // Returns all files that are Master files in array ByRef iaFileIsMaster
90595>>>>>>>    // Also returns all files that are Alias files in a second array.
90595>>>>>>>    // IMPORTANT: All master & alias files _must_ have been included into
90595>>>>>>>    //            the DoSetAllMasterAndAlias message.
90595>>>>>>>    Function UtilTableAllMasterAndAliasFiles Integer[] ByRef iaFileIsMaster Returns Integer[]
90597>>>>>>>        Integer[] iaFileIsAlias
90598>>>>>>>        Integer hTable iFileAlias iSize
90598>>>>>>>        Boolean bOpen
90598>>>>>>>
90598>>>>>>>        Move 0 to hTable
90599>>>>>>>        Repeat
90599>>>>>>>>
90599>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90602>>>>>>>            If (hTable <> 0) Begin
90604>>>>>>>                Open hTable
90606>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
90609>>>>>>>                If (bOpen = True) Begin
90611>>>>>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iFileAlias
90614>>>>>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
90616>>>>>>>                        Move (SizeOfArray(iaFileIsMaster)) to iSize
90617>>>>>>>                        Move hTable to iaFileIsMaster[iSize]
90618>>>>>>>                    End
90618>>>>>>>>
90618>>>>>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
90621>>>>>>>                        Move (SizeOfArray(iaFileIsAlias)) to iSize
90622>>>>>>>                        Move hTable to iaFileIsAlias[iSize]
90623>>>>>>>                    End
90623>>>>>>>>
90623>>>>>>>                End
90623>>>>>>>>
90623>>>>>>>            End
90623>>>>>>>>
90623>>>>>>>        Until (hTable = 0)
90625>>>>>>>
90625>>>>>>>        Function_Return iaFileIsAlias
90626>>>>>>>    End_Function  
90627>>>>>>>    
90627>>>>>>>    // Is a repair of the data-header necessary? (Embedded tables only)
90627>>>>>>>    Function UtilTableRepairIsNeeded Handle hTable String sTableName Returns Integer
90629>>>>>>>        String sMode
90629>>>>>>>        Integer iRepairNeeded bIsOpen
90629>>>>>>>
90629>>>>>>>        Move "0" to sMode
90630>>>>>>>        Set private.phCurrentTable to hTable 
90631>>>>>>>        Close hTable
90632>>>>>>>        Open hTable
90634>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90637>>>>>>>        Call_Driver hTable DATAFLEX_ID Function FLEX_GET_REPAIRS_NEEDED Callback 0 Passing sTableName sMode 0 Result iRepairNeeded
90642>>>>>>>
90642>>>>>>>        Function_Return iRepairNeeded
90643>>>>>>>    End_Function
90644>>>>>>>
90644>>>>>>>    // Helper function
90644>>>>>>>    // Takes two params:
90644>>>>>>>    //   1. An array with all master table numbers  (Function UtilTableAllMasterAndAliasFiles)
90644>>>>>>>    //   2. An array with all alias table numbers   (Function UtilTableAllMasterAndAliasFiles)
90644>>>>>>>    // Returns:
90644>>>>>>>    //  DF_FILE_ALIAS_DEFAULT if no master or alias
90644>>>>>>>    //  DF_FILE_IS_MASTER if master
90644>>>>>>>    //  DF_FILE_IS_ALIAS if alias
90644>>>>>>>    Function UtilTableIsMasterAlias Handle hTable Integer[] iaFileIsMaster Integer[] iaFileIsAlias Returns Integer
90646>>>>>>>        Integer i iSize
90646>>>>>>>
90646>>>>>>>        Move (SizeOfArray(iaFileIsMaster)) to iSize
90647>>>>>>>        Decrement iSize
90648>>>>>>>        for i from 0 to iSize
90654>>>>>>>>
90654>>>>>>>            If (hTable = iaFileIsMaster[i]) Begin
90656>>>>>>>                Function_Return DF_FILE_IS_MASTER
90657>>>>>>>            End
90657>>>>>>>>
90657>>>>>>>        Loop
90658>>>>>>>>
90658>>>>>>>
90658>>>>>>>        Move (SizeOfArray(iaFileIsAlias)) to iSize
90659>>>>>>>        Decrement iSize
90660>>>>>>>        for i from 0 to iSize
90666>>>>>>>>
90666>>>>>>>            If (hTable = iaFileIsAlias[i]) Begin
90668>>>>>>>                Function_Return DF_FILE_IS_ALIAS
90669>>>>>>>            End
90669>>>>>>>>
90669>>>>>>>        Loop
90670>>>>>>>>
90670>>>>>>>
90670>>>>>>>        Function_Return DF_FILE_ALIAS_DEFAULT
90671>>>>>>>    End_Function
90672>>>>>>>
90672>>>>>>>    // Determine the available indexes of a table.
90672>>>>>>>    //
90672>>>>>>>    // Arguments:
90672>>>>>>>    //   Handle hTable - The number of the table
90672>>>>>>>    //
90672>>>>>>>    // Returns:
90672>>>>>>>    //   String - A string to be used with the sort command
90672>>>>>>>    //   to re-index all indexes of a table.
90672>>>>>>>    Function UtilTableIndexString Handle hTable Returns String
90674>>>>>>>        String  sSortString
90674>>>>>>>        Integer iLastIndex iNumSegments iCount
90674>>>>>>>
90674>>>>>>>        Move "" to sSortString
90675>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
90678>>>>>>>
90678>>>>>>>        for iCount from 1 to iLastIndex
90684>>>>>>>>
90684>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iNumSegments
90687>>>>>>>            If iNumSegments Begin
90689>>>>>>>                If (Length(sSortString)) ;                    Move (Append(sSortString, " ")) to sSortString
90692>>>>>>>                Move (Append(sSortString, iCount)) to sSortString
90693>>>>>>>            End
90693>>>>>>>>
90693>>>>>>>        Loop
90694>>>>>>>>
90694>>>>>>>
90694>>>>>>>        Function_Return sSortString
90695>>>>>>>    End_Function
90696>>>>>>>
90696>>>>>>>    
90696>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90696>>>>>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
90698>>>>>>>        Function_Return False
90699>>>>>>>    End_Function
90700>>>>>>>
90700>>>>>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
90700>>>>>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90702>>>>>>>        Boolean bIsSame
90702>>>>>>>        Integer iCount iColumns iColumn
90702>>>>>>>
90702>>>>>>>        Move True to bIsSame
90703>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
90704>>>>>>>        Set piMaximum of ghoProgressBar  to iColumns
90705>>>>>>>        Decrement iColumns
90706>>>>>>>
90706>>>>>>>        for iCount from 0 to iColumns
90712>>>>>>>>
90712>>>>>>>            Set piPosition of ghoProgressBar to iCount
90713>>>>>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
90714>>>>>>>            If (bIsSame = False) Begin
90716>>>>>>>                Function_Return False
90717>>>>>>>            End
90717>>>>>>>>
90717>>>>>>>        Loop
90718>>>>>>>>
90718>>>>>>>
90718>>>>>>>        Function_Return (bIsSame = True)
90719>>>>>>>    End_Function
90720>>>>>>>
90720>>>>>>>    // Compares a single column (For 'FROM' & 'TO' tables)
90720>>>>>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90722>>>>>>>        Integer iFromType iToType iDbType
90722>>>>>>>        tColumnType ColumnType
90722>>>>>>>        tColumnType ColumnType
90722>>>>>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
90722>>>>>>>
90722>>>>>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
90724>>>>>>>            Function_Return False
90725>>>>>>>        End
90725>>>>>>>>
90725>>>>>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
90727>>>>>>>            Function_Return False
90728>>>>>>>        End
90728>>>>>>>>
90728>>>>>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
90730>>>>>>>            Function_Return False
90731>>>>>>>        End                                                                
90731>>>>>>>>
90731>>>>>>>
90731>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = True) Begin
90733>>>>>>>            If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
90735>>>>>>>                Function_Return False
90736>>>>>>>            End
90736>>>>>>>>
90736>>>>>>>            If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
90738>>>>>>>                If ((APIColumnCompare.sDefaultValueFrom = ""   and APIColumnCompare.sDefaultValueTo = "''") or ;                    (APIColumnCompare.sDefaultValueFrom = "''" and APIColumnCompare.sDefaultValueTo = "")) Begin
90740>>>>>>>                    End
90740>>>>>>>>
90740>>>>>>>                Else Begin
90741>>>>>>>                    Function_Return False
90742>>>>>>>                End
90742>>>>>>>>
90742>>>>>>>            End
90742>>>>>>>>
90742>>>>>>>        End
90742>>>>>>>>
90742>>>>>>>
90742>>>>>>>        Get piDbType                       to iDbType
90743>>>>>>>        Move APIColumnCompare.iTypeFrom    to iFromType
90744>>>>>>>        Move APIColumnCompare.iTypeTo      to iToType
90745>>>>>>>
90745>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
90745>>>>>>>        // data types between Embedded and SQL.
90745>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
90747>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
90748>>>>>>>        End
90748>>>>>>>>
90748>>>>>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
90750>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
90751>>>>>>>        End
90751>>>>>>>>
90751>>>>>>>
90751>>>>>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
90752>>>>>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
90753>>>>>>>
90753>>>>>>>        // Make Date and DateTime comparison?
90753>>>>>>>        If (bCompareDate_DataTime = True) Begin
90755>>>>>>>            If (iFromType <> iToType) Begin
90757>>>>>>>                Function_Return False
90758>>>>>>>            End
90758>>>>>>>>
90758>>>>>>>        End
90758>>>>>>>>
90758>>>>>>>
90758>>>>>>>        // This is when not checking for Date/DateTime differences but all other other field types...
90758>>>>>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
90760>>>>>>>            If (iFromType <> iToType) Begin
90762>>>>>>>                Function_Return False
90763>>>>>>>            End
90763>>>>>>>>
90763>>>>>>>        End
90763>>>>>>>>
90763>>>>>>>
90763>>>>>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
90763>>>>>>>        If (bIsDateTypeFrom = False) Begin
90765>>>>>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
90767>>>>>>>                Function_Return False
90768>>>>>>>            End
90768>>>>>>>>
90768>>>>>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
90770>>>>>>>                Function_Return False
90771>>>>>>>            End
90771>>>>>>>>
90771>>>>>>>        End
90771>>>>>>>>
90771>>>>>>>
90771>>>>>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
90773>>>>>>>            Function_Return False
90774>>>>>>>        End
90774>>>>>>>>
90774>>>>>>>
90774>>>>>>>        Function_Return True
90775>>>>>>>    End_Function
90776>>>>>>>
90776>>>>>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
90778>>>>>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iCheckFieldNumber iDriverID
90778>>>>>>>        Boolean bIdentityKey bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
90778>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90778>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90780>>>>>>>        String sDriverID sRootName sLogicalName sDataType
90780>>>>>>>
90780>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90781>>>>>>>        Get piDbType to iDbType
90782>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90785>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
90788>>>>>>>
90788>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90791>>>>>>>        If (bIsOpen = False) Begin
90793>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90794>>>>>>>            Open hTable
90796>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90797>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90800>>>>>>>            If (bIsOpen = False) Begin
90802>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90803>>>>>>>                Move True to APIColumnsEmpty[0].bError
90804>>>>>>>                Function_Return APIColumnsEmpty
90805>>>>>>>            End
90805>>>>>>>>
90805>>>>>>>        End
90805>>>>>>>>
90805>>>>>>>
90805>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
90808>>>>>>>        Get IsSQLDriver    sDriverID to bSqlDriver
90809>>>>>>>        Get _UtilTableIsSqlByRootName sRootName to bIsSqlTable
90810>>>>>>>        If (bIsSqlTable = True) Begin
90812>>>>>>>            Get _UtilTableExists hTable to bExists
90813>>>>>>>            If (bExists = False) Begin
90815>>>>>>>                Move True to APIColumnsEmpty[0].bError
90816>>>>>>>                Function_Return APIColumnsEmpty
90817>>>>>>>            End
90817>>>>>>>>
90817>>>>>>>        End
90817>>>>>>>>
90817>>>>>>>//        Get DriverIndex sDriverID to iDriverID
90817>>>>>>>//        If (sDriverID = MSSQLDRV_ID) Begin
90817>>>>>>>//            Set_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE of iDriverId to 'datetime2'
90817>>>>>>>//        End
90817>>>>>>>
90817>>>>>>>        Move 0 to iCount
90818>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90821>>>>>>>        Set piMaximum of ghoProgressBar to iNumColumns
90822>>>>>>>
90822>>>>>>>        for iColumn from 1 to iNumColumns
90828>>>>>>>>
90828>>>>>>>            Move 0 to iOptions
90829>>>>>>>            Move False to bIdentityKey
90830>>>>>>>            Move False to Err
90831>>>>>>>            Move 0     to LastErr
90832>>>>>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
90833>>>>>>>            Set piPosition of ghoProgressBar to iColumn
90834>>>>>>>
90834>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90835>>>>>>>            If (bIsSqlTable = True) Begin 
90837>>>>>>>//                If (iType = DF_DATE) Begin
90837>>>>>>>//                    // Note: This is actually the same as SQL_DATETIME
90837>>>>>>>//                    Move SQL_DATE to iType
90837>>>>>>>//                    Move 3 to APIColumns[iCouknt].iPrecision
90837>>>>>>>//                End
90837>>>>>>>//                Else If (iType = DF_DATET Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iTypeIME) Begin
90837>>>>>>>//                    // In modern MS-SQL databases SQL_DATETIME will be = to "datetime2".
90837>>>>>>>//                    // By default MS-SQL will create such a field with 7 (!) decimal places.
90837>>>>>>>//                    // This is just a waste because DataFlex will truncate that to 3 decimal
90837>>>>>>>//                    // places. Therefore, we hard-code the precision to be only thee decimals.
90837>>>>>>>//                    Move SQL_DATETIME to iType
90837>>>>>>>//                    Move 3 to APIColumns[iCount].iPrecision
90837>>>>>>>//                End
90837>>>>>>>//                Move iType                                                to APIColumns[iCount].iType
90837>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to APIColumns[iCount].iType
90840>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
90843>>>>>>>                Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
90846>>>>>>>                Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue
90849>>>>>>>            End
90849>>>>>>>>
90849>>>>>>>            Else Begin
90850>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
90853>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90854>>>>>>>            End
90854>>>>>>>>
90854>>>>>>>
90854>>>>>>>            // If the array value is out of bounce it means that this column doesn't exist on the backend.
90854>>>>>>>            Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
90857>>>>>>>            Move (iCheckFieldNumber >= 0) to bExists
90858>>>>>>>            If (bExists = False) Begin
90860>>>>>>>                Move 0 to APIColumns[iCount].iType
90861>>>>>>>            End
90861>>>>>>>>
90861>>>>>>>            If (bExists = True) Begin
90863>>>>>>>                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
90866>>>>>>>            End
90866>>>>>>>>
90866>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90867>>>>>>>            If (bIdentityKey = True) Begin
90869>>>>>>>                Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
90870>>>>>>>            End
90870>>>>>>>>
90870>>>>>>>
90870>>>>>>>//            Else Begin
90870>>>>>>>//                Move False to Err
90870>>>>>>>//                Move 0     to LastErr
90870>>>>>>>//                If (bIsSqlTable = True) Begin
90870>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
90870>>>>>>>//                End
90870>>>>>>>//                Else Begin
90870>>>>>>>//                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
90870>>>>>>>//                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90870>>>>>>>//                End
90870>>>>>>>//                // If the array value is out of bounce it means that this column doesn't exist on the backend.
90870>>>>>>>//                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
90870>>>>>>>//                If (bExists = False) Begin
90870>>>>>>>//                    Move 0 to APIColumns[iCount].iType
90870>>>>>>>//                End
90870>>>>>>>//            End
90870>>>>>>>
90870>>>>>>>            If (bExists = True) Begin
90872>>>>>>>                Move iColumn to APIColumns[iCount].iFieldNumber
90873>>>>>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
90876>>>>>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
90876>>>>>>>//                If (bIsSqlTable = True) Begin
90876>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
90876>>>>>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90876>>>>>>>//                End
90876>>>>>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength 
90879>>>>>>>                If (APIColumns[iCount].iPrecision = 0) Begin
90881>>>>>>>                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90884>>>>>>>                End
90884>>>>>>>>
90884>>>>>>>
90884>>>>>>>                // If the length was zero we might have an Overlap(!) field.
90884>>>>>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
90884>>>>>>>                If (APIColumns[iCount].iLength = 0) Begin
90886>>>>>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
90889>>>>>>>                    If (iType = DF_OVERLAP) Begin
90891>>>>>>>                        Move 0 to APIColumns[iCount].iFieldNumber
90892>>>>>>>                        Move 0 to APIColumns[iCount].iLength
90893>>>>>>>                        Move 0 to APIColumns[iCount].iOptions
90894>>>>>>>                        Move 0 to APIColumns[iCount].iPrecision
90895>>>>>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
90896>>>>>>>                        Move "" to APIColumns[iCount].sFieldName
90897>>>>>>>                        Decrement iCount
90898>>>>>>>                    End
90898>>>>>>>>
90898>>>>>>>                End
90898>>>>>>>>
90898>>>>>>>            End
90898>>>>>>>>
90898>>>>>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
90899>>>>>>>            If (bUserCancel = True) Begin
90901>>>>>>>                Move True to APIColumnsEmpty[0].bCancel
90902>>>>>>>                Function_Return APIColumnsEmpty
90903>>>>>>>            End
90903>>>>>>>>
90903>>>>>>>            Increment iCount
90904>>>>>>>        Loop
90905>>>>>>>>
90905>>>>>>>
90905>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90906>>>>>>>        Function_Return APIColumns
90907>>>>>>>    End_Function
90908>>>>>>>     
90908>>>>>>>    // ToDo: Shouldn't this be the other way round? The From bit last? That is what should be of interest??
90908>>>>>>>    // *** 
90908>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO column arrays.
90908>>>>>>>    // The combined data will be sorted on the first struct member: iFieldNumber
90908>>>>>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
90910>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
90910>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
90911>>>>>>>        tAPIColumnCompare   APIColumnCompare
90911>>>>>>>        tAPIColumnCompare   APIColumnCompare
90911>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90911>>>>>>>
90911>>>>>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
90912>>>>>>>        Decrement iSizeFrom
90913>>>>>>>        for iCount from 0 to iSizeFrom
90919>>>>>>>>
90919>>>>>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
90920>>>>>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
90921>>>>>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
90922>>>>>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
90923>>>>>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
90924>>>>>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
90925>>>>>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
90926>>>>>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom
90927>>>>>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
90928>>>>>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
90929>>>>>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
90930>>>>>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
90931>>>>>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
90932>>>>>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
90933>>>>>>>        Loop
90934>>>>>>>>
90934>>>>>>>
90934>>>>>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
90935>>>>>>>        Decrement iSizeTo
90936>>>>>>>        for iCount from 0 to iSizeTo
90942>>>>>>>>
90942>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
90943>>>>>>>            // Search if the field number already exists in the "to" array; else add it. <
90943>>>>>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
90944>>>>>>>            If (iItem = -1) Begin
90946>>>>>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
90947>>>>>>>            End
90947>>>>>>>>
90947>>>>>>>
90947>>>>>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
90948>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
90949>>>>>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
90950>>>>>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
90951>>>>>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
90952>>>>>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
90953>>>>>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
90954>>>>>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
90955>>>>>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
90956>>>>>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
90957>>>>>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
90958>>>>>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
90959>>>>>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
90960>>>>>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
90961>>>>>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
90962>>>>>>>        Loop
90963>>>>>>>>
90963>>>>>>>
90963>>>>>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
90964>>>>>>>
90964>>>>>>>        Function_Return aAPIColumnCompare
90965>>>>>>>    End_Function
90966>>>>>>>
90966>>>>>>>    // Checks if a field name exists in a table definition
90966>>>>>>>    // Returns True if it does
90966>>>>>>>    // Sample:
90966>>>>>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
90966>>>>>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
90968>>>>>>>        Integer iNumColumns iColumn
90968>>>>>>>        String sColumn
90968>>>>>>>        Boolean bExists bOK bOpen
90968>>>>>>>
90968>>>>>>>        Get AutoConnectionIDLogin to bOK
90969>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90970>>>>>>>        Open hTable
90972>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90973>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90976>>>>>>>        If (bOpen = False) Begin
90978>>>>>>>            Function_Return False
90979>>>>>>>        End
90979>>>>>>>>
90979>>>>>>>
90979>>>>>>>        Move False to bExists
90980>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90983>>>>>>>        for iColumn from 1 to iNumColumns
90989>>>>>>>>
90989>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90992>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90994>>>>>>>                Move iNumColumns to iColumn
90995>>>>>>>                Move True to bExists
90996>>>>>>>            End
90996>>>>>>>>
90996>>>>>>>        Loop
90997>>>>>>>>
90997>>>>>>>        Close hTable
90998>>>>>>>
90998>>>>>>>        Function_Return bExists
90999>>>>>>>    End_Function
91000>>>>>>>
91000>>>>>>>    // Returns the field/column number for the passed FieldName as an integer.
91000>>>>>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
91002>>>>>>>        Integer iNumColumns iColumn iRetval
91002>>>>>>>        String sColumn
91002>>>>>>>        Boolean bOK bOpen
91002>>>>>>>
91002>>>>>>>        Get AutoConnectionIDLogin to bOK
91003>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91004>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91005>>>>>>>        Open hTable
91007>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91008>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91011>>>>>>>        If (bOpen = False) Begin
91013>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
91014>>>>>>>            Function_Return False
91015>>>>>>>        End
91015>>>>>>>>
91015>>>>>>>
91015>>>>>>>        Move 0 to iColumn
91016>>>>>>>        Move 0 to iRetval
91017>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
91020>>>>>>>        for iColumn from 1 to iNumColumns
91026>>>>>>>>
91026>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
91029>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
91031>>>>>>>                Move iColumn to iRetval
91032>>>>>>>                Move iNumColumns to iColumn
91033>>>>>>>            End
91033>>>>>>>>
91033>>>>>>>        Loop
91034>>>>>>>>
91034>>>>>>>        Close hTable
91035>>>>>>>
91035>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91036>>>>>>>        Function_Return iRetval
91037>>>>>>>    End_Function
91038>>>>>>>
91038>>>>>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
91038>>>>>>>    // The reciprocal function is UtilColumnTypeToString.
91038>>>>>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
91040>>>>>>>        tColumnType RetvalType
91040>>>>>>>        tColumnType RetvalType
91040>>>>>>>
91040>>>>>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
91041>>>>>>>        Function_Return RetvalType.iSQLType
91042>>>>>>>    End_Function
91043>>>>>>>
91043>>>>>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
91043>>>>>>>    // The reciprocal function is UtilColumnTypeToString.
91043>>>>>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
91045>>>>>>>        tColumnType RetvalType
91045>>>>>>>        tColumnType RetvalType
91045>>>>>>>
91045>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91046>>>>>>>        Function_Return RetvalType.sSQLType
91047>>>>>>>    End_Function
91048>>>>>>>
91048>>>>>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
91050>>>>>>>        tColumnType RetvalType
91050>>>>>>>        tColumnType RetvalType
91050>>>>>>>
91050>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91051>>>>>>>        Function_Return RetvalType.sPrecision
91052>>>>>>>    End_Function
91053>>>>>>>
91053>>>>>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
91055>>>>>>>        tColumnType RetvalType
91055>>>>>>>        tColumnType RetvalType
91055>>>>>>>
91055>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91056>>>>>>>        // Nils 2019-02-15. This return value seems to have been wrong. The function should return False
91056>>>>>>>        // if the column type length is _not_ fixed.
91056>>>>>>>        Function_Return (RetvalType.bCanEditSize = False)
91057>>>>>>>    End_Function
91058>>>>>>>
91058>>>>>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
91060>>>>>>>        tColumnType RetvalType
91060>>>>>>>        tColumnType RetvalType
91060>>>>>>>        String sValue
91060>>>>>>>        Integer iRetval iPos
91060>>>>>>>
91060>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91061>>>>>>>        Move RetvalType.sPrecision to sValue
91062>>>>>>>        Move (Pos(".", sValue)) to iPos
91063>>>>>>>        If (iPos <> 0) Begin
91065>>>>>>>            Move (Left(sValue, (iPos -1))) to iRetval
91066>>>>>>>        End
91066>>>>>>>>
91066>>>>>>>        Else Begin
91067>>>>>>>            Move sValue to iRetval
91068>>>>>>>        End
91068>>>>>>>>
91068>>>>>>>        Function_Return iRetval
91069>>>>>>>    End_Function
91070>>>>>>>
91070>>>>>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
91072>>>>>>>        tColumnType RetvalType
91072>>>>>>>        tColumnType RetvalType
91072>>>>>>>        String sValue
91072>>>>>>>        Integer iRetval iPos
91072>>>>>>>
91072>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91073>>>>>>>        Move RetvalType.sPrecision to sValue
91074>>>>>>>        Move (Pos(".", sValue)) to iPos
91075>>>>>>>        If (iPos = 0) Begin
91077>>>>>>>            Function_Return 0
91078>>>>>>>        End
91078>>>>>>>>
91078>>>>>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
91079>>>>>>>
91079>>>>>>>        Function_Return iRetval
91080>>>>>>>    End_Function
91081>>>>>>>
91081>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91081>>>>>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
91083>>>>>>>        Function_Return False
91084>>>>>>>    End_Function
91085>>>>>>>
91085>>>>>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
91085>>>>>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
91087>>>>>>>        Boolean bIsSame
91087>>>>>>>        Integer iCount iSize
91087>>>>>>>
91087>>>>>>>        Move True to bIsSame
91088>>>>>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
91089>>>>>>>        Decrement iSize
91090>>>>>>>        For iCount from 0 to iSize
91096>>>>>>>>
91096>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91097>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
91098>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
91099>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
91100>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
91101>>>>>>>            If (bIsSame = False) Begin
91103>>>>>>>                Function_Return False
91104>>>>>>>            End
91104>>>>>>>>
91104>>>>>>>        Loop
91105>>>>>>>>
91105>>>>>>>
91105>>>>>>>        Function_Return bIsSame
91106>>>>>>>    End_Function
91107>>>>>>>
91107>>>>>>>    // Compares a single index for a 'FROM' and a 'TO' table.
91107>>>>>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
91109>>>>>>>        Boolean bIsSame
91109>>>>>>>        Integer iSegment
91109>>>>>>>
91109>>>>>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
91110>>>>>>>        If (bIsSame = False) Begin
91112>>>>>>>            Function_Return False
91113>>>>>>>        End
91113>>>>>>>>
91113>>>>>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
91114>>>>>>>        If (bIsSame = False) Begin
91116>>>>>>>            Function_Return False
91117>>>>>>>        End
91117>>>>>>>>
91117>>>>>>>
91117>>>>>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
91119>>>>>>>            // * We should probably not compare SQL index names?
91119>>>>>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
91119>>>>>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
91119>>>>>>>            //     Function_Return False
91119>>>>>>>            // End
91119>>>>>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
91120>>>>>>>            If (bIsSame = False) Begin
91122>>>>>>>                Function_Return False
91123>>>>>>>            End
91123>>>>>>>>
91123>>>>>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
91124>>>>>>>            If (bIsSame = False) Begin
91126>>>>>>>                Function_Return False
91127>>>>>>>            End
91127>>>>>>>>
91127>>>>>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
91128>>>>>>>            If (bIsSame = False) Begin
91130>>>>>>>                Function_Return False
91131>>>>>>>            End
91131>>>>>>>>
91131>>>>>>>            Move (Uppercase(APIIndexCompare.sSQLIndexNameFrom) = Uppercase(APIIndexCompare.sSQLIndexNameTo)) to bIsSame
91132>>>>>>>            If (bIsSame = False) Begin
91134>>>>>>>                Function_Return False
91135>>>>>>>            End
91135>>>>>>>>
91135>>>>>>>        End
91135>>>>>>>>
91135>>>>>>>
91135>>>>>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
91136>>>>>>>        Move (iSegment = -1) to bIsSame
91137>>>>>>>
91137>>>>>>>        Function_Return (bIsSame = True)
91138>>>>>>>    End_Function
91139>>>>>>>
91139>>>>>>>    // Compares each segment for the passed index.
91139>>>>>>>    // Returns -1 if same; else returns the index segment that differs.
91139>>>>>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
91141>>>>>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
91141>>>>>>>        Boolean bIsSame
91141>>>>>>>
91141>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
91142>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91143>>>>>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
91144>>>>>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
91145>>>>>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
91146>>>>>>>
91146>>>>>>>        Decrement iNumSegments
91147>>>>>>>        for iSegment from 0 to iNumSegments
91153>>>>>>>>
91153>>>>>>>            Move False to bIsSame
91154>>>>>>>            If (iSegment < iNumSegmentsFrom and iSegment < iNumSegmentsTo) Begin
91156>>>>>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
91157>>>>>>>            End
91157>>>>>>>>
91157>>>>>>>            If (bIsSame = False) Begin
91159>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
91160>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91161>>>>>>>                Function_Return iSegment
91162>>>>>>>            End
91162>>>>>>>>
91162>>>>>>>        Loop
91163>>>>>>>>
91163>>>>>>>
91163>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91164>>>>>>>        Function_Return -1 // This means bIsSame = True
91165>>>>>>>    End_Function
91166>>>>>>>
91166>>>>>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
91168>>>>>>>        Boolean bIsSame
91168>>>>>>>
91168>>>>>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
91169>>>>>>>        If (bIsSame = False) Begin
91171>>>>>>>            Function_Return False
91172>>>>>>>        End
91172>>>>>>>>
91172>>>>>>>        If (bCompareIndexUppercase = True) Begin
91174>>>>>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
91175>>>>>>>            If (bIsSame = False) Begin
91177>>>>>>>                Function_Return False
91178>>>>>>>            End
91178>>>>>>>>
91178>>>>>>>        End
91178>>>>>>>>
91178>>>>>>>        If (bCompareIndexAscending = True) Begin
91180>>>>>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
91181>>>>>>>            If (bIsSame = False) Begin
91183>>>>>>>                Function_Return False
91184>>>>>>>            End
91184>>>>>>>>
91184>>>>>>>        End
91184>>>>>>>>
91184>>>>>>>
91184>>>>>>>        Function_Return True
91185>>>>>>>    End_Function
91186>>>>>>>
91186>>>>>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
91188>>>>>>>        Boolean bIsSame bOK
91188>>>>>>>        Integer iSize iSizeTo iCount
91188>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
91188>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
91189>>>>>>>
91189>>>>>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
91190>>>>>>>        If (iSize = 0) Begin
91192>>>>>>>            Function_Return True
91193>>>>>>>        End
91193>>>>>>>>
91193>>>>>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo
91194>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
91195>>>>>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
91196>>>>>>>
91196>>>>>>>        for iCount from 0 to (iSize - 1)
91202>>>>>>>>
91202>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
91203>>>>>>>            If (bIsSame = False) Begin
91205>>>>>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
91206>>>>>>>            End
91206>>>>>>>>
91206>>>>>>>        Loop
91207>>>>>>>>
91207>>>>>>>
91207>>>>>>>        // We probably should delete other indexes if they exists.
91207>>>>>>>        for iCount from (iSize +1) to iSizeTo
91213>>>>>>>>
91213>>>>>>>            Get ApiIndexRemove hTable iCount to bOK
91214>>>>>>>        Loop
91215>>>>>>>>
91215>>>>>>>
91215>>>>>>>        Function_Return bOK
91216>>>>>>>    End_Function
91217>>>>>>>
91217>>>>>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
91219>>>>>>>        tAPIIndex[] APIIndexes
91219>>>>>>>        tAPIIndex[] APIIndexes
91220>>>>>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
91220>>>>>>>        String sDriverID
91220>>>>>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable
91220>>>>>>>
91220>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91221>>>>>>>        Get psDriverID to sDriverID
91222>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
91223>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
91224>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91227>>>>>>>        If (bIsOpen = False) Begin
91229>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91230>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91231>>>>>>>            Open hTable
91233>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
91234>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91235>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91238>>>>>>>            If (bIsOpen = False) Begin
91240>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91241>>>>>>>                Move True to APIIndexes[0].bError
91242>>>>>>>                Function_Return APIIndexes
91243>>>>>>>            End
91243>>>>>>>>
91243>>>>>>>        End
91243>>>>>>>>
91243>>>>>>>
91243>>>>>>>        Move 0 to iCount
91244>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
91247>>>>>>>        for iIndex from 1 to iIndexes
91253>>>>>>>>
91253>>>>>>>            // This is a test that the index exists as there might be "holes" aka the index
91253>>>>>>>            // numbers doesn't not need to be consequitive:
91253>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
91256>>>>>>>            If (iNumSegments > 0) Begin
91258>>>>>>>
91258>>>>>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
91259>>>>>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
91262>>>>>>>                If (bIsSQLTable = True) Begin
91264>>>>>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
91267>>>>>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
91270>>>>>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
91273>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
91276>>>>>>>                End
91276>>>>>>>>
91276>>>>>>>
91276>>>>>>>                Move 0 to iSegmentCount
91277>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
91280>>>>>>>                For iSegment from 1 to iNumSegments
91286>>>>>>>>
91286>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
91289>>>>>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
91290>>>>>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
91293>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
91296>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
91299>>>>>>>                    Increment iSegmentCount
91300>>>>>>>                Loop
91301>>>>>>>>
91301>>>>>>>                Increment iCount
91302>>>>>>>            End
91302>>>>>>>>
91302>>>>>>>        Loop
91303>>>>>>>>
91303>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91304>>>>>>>
91304>>>>>>>        Function_Return APIIndexes
91305>>>>>>>    End_Function
91306>>>>>>>
91306>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
91306>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
91306>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
91306>>>>>>>    // have "holes" in the series of index numbers.
91306>>>>>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
91308>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
91308>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
91309>>>>>>>        tAPIIndexCompare   APIIndexCompare
91309>>>>>>>        tAPIIndexCompare   APIIndexCompare
91309>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
91309>>>>>>>
91309>>>>>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
91310>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
91311>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
91313>>>>>>>            Function_Return aAPIIndexCompare
91314>>>>>>>        End
91314>>>>>>>>
91314>>>>>>>
91314>>>>>>>        Decrement iSizeFrom
91315>>>>>>>        for iCount from 0 to iSizeFrom
91321>>>>>>>>
91321>>>>>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
91322>>>>>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
91323>>>>>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
91324>>>>>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
91325>>>>>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
91326>>>>>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
91327>>>>>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
91328>>>>>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
91329>>>>>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
91330>>>>>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
91331>>>>>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
91332>>>>>>>        Loop
91333>>>>>>>>
91333>>>>>>>
91333>>>>>>>        Decrement iSizeTo
91334>>>>>>>        for iCount from 0 to iSizeTo
91340>>>>>>>>
91340>>>>>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
91341>>>>>>>            // Search if the Index number already exists in the array; else add it.
91341>>>>>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
91342>>>>>>>            If (iItem = -1) Begin
91344>>>>>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
91345>>>>>>>            End
91345>>>>>>>>
91345>>>>>>>
91345>>>>>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
91346>>>>>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
91347>>>>>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
91348>>>>>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
91349>>>>>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
91350>>>>>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
91351>>>>>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
91352>>>>>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
91353>>>>>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
91354>>>>>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
91355>>>>>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
91356>>>>>>>        Loop
91357>>>>>>>>
91357>>>>>>>
91357>>>>>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
91358>>>>>>>
91358>>>>>>>        Function_Return aAPIIndexCompare
91359>>>>>>>    End_Function
91360>>>>>>>
91360>>>>>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
91360>>>>>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
91362>>>>>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
91362>>>>>>>        String sDriverID
91362>>>>>>>
91362>>>>>>>        Get psDriverID to sDriverID
91363>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
91364>>>>>>>        Get IsSQLDriver sDriverID to bIsSqlTable
91365>>>>>>>        If (bIsSqlTable = True) Begin
91367>>>>>>>            Get _UtilTableIsSql hTable to bIsSqlTable
91368>>>>>>>        End
91368>>>>>>>>
91368>>>>>>>
91368>>>>>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
91369>>>>>>>        If (bIsSame = False) Begin
91371>>>>>>>            Function_Return False
91372>>>>>>>        End
91372>>>>>>>>
91372>>>>>>>
91372>>>>>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
91374>>>>>>>            // Don't think we should do this. Or should we?
91374>>>>>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
91374>>>>>>>
91374>>>>>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
91375>>>>>>>            If (bIsSame = False) Begin
91377>>>>>>>                Function_Return False
91378>>>>>>>            End
91378>>>>>>>>
91378>>>>>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
91379>>>>>>>            If (bIsSame = False) Begin
91381>>>>>>>                Function_Return False
91382>>>>>>>            End
91382>>>>>>>>
91382>>>>>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
91383>>>>>>>            If (bIsSame = False) Begin
91385>>>>>>>                Function_Return False
91386>>>>>>>            End
91386>>>>>>>>
91386>>>>>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
91387>>>>>>>            If (bIsSame = False) Begin
91389>>>>>>>                Function_Return False
91390>>>>>>>            End
91390>>>>>>>>
91390>>>>>>>        End
91390>>>>>>>>
91390>>>>>>>
91390>>>>>>>        Function_Return bIsSame
91391>>>>>>>    End_Function
91392>>>>>>>
91392>>>>>>>    // DF_INDEX_SQL_TYPE values
91392>>>>>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
91392>>>>>>>    // returns a string with the name.
91392>>>>>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
91394>>>>>>>        String sRetval
91394>>>>>>>            Case Begin
91394>>>>>>>                Case (iIndexType = DF_INDEX_CLIENT)
91396>>>>>>>                    Move "DF_INDEX_CLIENT" to sRetval
91397>>>>>>>                    Case Break
91398>>>>>>>                Case (iIndexType = DF_INDEX_SERVER)
91401>>>>>>>                    Move "DF_INDEX_SERVER" to sRetval
91402>>>>>>>                    Case Break
91403>>>>>>>                Case (iIndexType = DF_INDEX_SERVER_ONLY)
91406>>>>>>>                    Move "DF_INDEX_SERVER_ONLY" to sRetval
91407>>>>>>>                    Case Break
91408>>>>>>>                Case (iIndexType = DF_INDEX_TEMPORARY)
91411>>>>>>>                    Move "DF_INDEX_TEMPORARY" to sRetval
91412>>>>>>>                    Case Break
91413>>>>>>>                Case Else
91413>>>>>>>                    Move "UNKNOWN INDEX TYPE" to sRetval
91414>>>>>>>            Case End
91414>>>>>>>        Function_Return sRetval
91415>>>>>>>    End_Function
91416>>>>>>>
91416>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91416>>>>>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
91418>>>>>>>        Function_Return False
91419>>>>>>>    End_Function
91420>>>>>>>
91420>>>>>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
91420>>>>>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
91422>>>>>>>        Boolean bIsSame
91422>>>>>>>        Integer iSize iCount
91422>>>>>>>
91422>>>>>>>        Move True to bIsSame
91423>>>>>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
91424>>>>>>>        Decrement iSize
91425>>>>>>>        For iCount from 0 to iSize
91431>>>>>>>>
91431>>>>>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
91432>>>>>>>            If (bIsSame = False) Begin
91434>>>>>>>                Function_Return False
91435>>>>>>>            End
91435>>>>>>>>
91435>>>>>>>        Loop
91436>>>>>>>>
91436>>>>>>>
91436>>>>>>>        Function_Return bIsSame
91437>>>>>>>    End_Function
91438>>>>>>>
91438>>>>>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
91438>>>>>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
91440>>>>>>>        Boolean bIsSame
91440>>>>>>>
91440>>>>>>>        Move True to bIsSame
91441>>>>>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
91443>>>>>>>            Function_Return False
91444>>>>>>>        End
91444>>>>>>>>
91444>>>>>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
91446>>>>>>>            Function_Return False
91447>>>>>>>        End
91447>>>>>>>>
91447>>>>>>>
91447>>>>>>>        // We could also compare field names, but I don't think that is necessary...
91447>>>>>>>
91447>>>>>>>        Function_Return bIsSame
91448>>>>>>>    End_Function
91449>>>>>>>
91449>>>>>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
91449>>>>>>>    // already exists.
91449>>>>>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
91451>>>>>>>        Boolean bOK
91451>>>>>>>        Integer iSizeTo iSize iCount iColumn
91451>>>>>>>        String sDriverID
91451>>>>>>>
91451>>>>>>>        Move True to bOK
91452>>>>>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
91453>>>>>>>        If (iSizeTo > 0) Begin
91455>>>>>>>            Get AutoConnectionIDLogin to bOK
91456>>>>>>>            Move False to Err
91457>>>>>>>            Open hTable Mode DF_EXCLUSIVE
91459>>>>>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
91462>>>>>>>            Decrement iSizeTo
91463>>>>>>>
91463>>>>>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
91463>>>>>>>            // for the "TO" database. But start by deleting all current "TO" relations:
91463>>>>>>>            Structure_Start hTable sDriverID
91464>>>>>>>                for iCount from 0 to iSizeTo
91470>>>>>>>>
91470>>>>>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
91471>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
91474>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
91477>>>>>>>                Loop
91478>>>>>>>>
91478>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
91479>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91481>>>>>>>            Set Action_Text of ghoStatusPanel to ""
91482>>>>>>>        End
91482>>>>>>>>
91482>>>>>>>
91482>>>>>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
91483>>>>>>>        Decrement iSize
91484>>>>>>>        for iCount from 0 to iSize
91490>>>>>>>>
91490>>>>>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
91491>>>>>>>        Loop
91492>>>>>>>>
91492>>>>>>>
91492>>>>>>>        Function_Return bOK
91493>>>>>>>    End_Function
91494>>>>>>>
91494>>>>>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
91496>>>>>>>        tAPIRelation[] APIRelations
91496>>>>>>>        tAPIRelation[] APIRelations
91497>>>>>>>        Integer iColumn iColumnTo iNumColumns iCount
91497>>>>>>>        Handle hParent
91497>>>>>>>        Boolean bIsOpen
91497>>>>>>>
91497>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91498>>>>>>>        Move 0 to iCount
91499>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91502>>>>>>>        If (bIsOpen = False) Begin
91504>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91505>>>>>>>            Open hTable
91507>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91508>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91511>>>>>>>            If (bIsOpen = False) Begin
91513>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91514>>>>>>>                Move True to APIRelations[0].bError
91515>>>>>>>                Function_Return APIRelations
91516>>>>>>>            End
91516>>>>>>>>
91516>>>>>>>        End
91516>>>>>>>>
91516>>>>>>>
91516>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
91519>>>>>>>        For iColumn from 1 to iNumColumns
91525>>>>>>>>
91525>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
91528>>>>>>>            If (hParent <> 0) Begin
91530>>>>>>>                Open hParent
91532>>>>>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
91533>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
91536>>>>>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
91537>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
91540>>>>>>>
91540>>>>>>>                Move hParent                                            to APIRelations[iCount].hTableTo
91541>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
91544>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
91547>>>>>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
91548>>>>>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
91551>>>>>>>                Move False                                              to APIRelations[iCount].bShouldChange
91552>>>>>>>                Move False                                              to APIRelations[iCount].bCancel
91553>>>>>>>                Move False                                              to APIRelations[iCount].bError
91554>>>>>>>                Close hParent
91555>>>>>>>                Increment iCount
91556>>>>>>>            End
91556>>>>>>>>
91556>>>>>>>        Loop
91557>>>>>>>>
91557>>>>>>>
91557>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91558>>>>>>>        Function_Return APIRelations
91559>>>>>>>    End_Function
91560>>>>>>>
91560>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO relation arrays.
91560>>>>>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
91560>>>>>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
91562>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
91562>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
91563>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
91563>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
91564>>>>>>>        tAPIRelationCompare   APIRelationCompare
91564>>>>>>>        tAPIRelationCompare   APIRelationCompare
91564>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
91564>>>>>>>
91564>>>>>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
91565>>>>>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
91566>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
91568>>>>>>>            Function_Return aAPIRelationCompare
91569>>>>>>>        End
91569>>>>>>>>
91569>>>>>>>
91569>>>>>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
91570>>>>>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(__UtilRelationArrayCompare))) to aAPIRelationFromAndTo
91571>>>>>>>
91571>>>>>>>        Decrement iSizeFrom
91572>>>>>>>        for iCount from 0 to iSizeFrom
91578>>>>>>>>
91578>>>>>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
91579>>>>>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
91580>>>>>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
91581>>>>>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
91582>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
91583>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
91584>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
91585>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
91586>>>>>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
91587>>>>>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
91588>>>>>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
91589>>>>>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
91590>>>>>>>        Loop
91591>>>>>>>>
91591>>>>>>>
91591>>>>>>>        Decrement iSizeTo
91592>>>>>>>        for iCount from 0 to iSizeTo
91598>>>>>>>>
91598>>>>>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
91599>>>>>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
91600>>>>>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
91601>>>>>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
91602>>>>>>>
91602>>>>>>>            // Search if the relation already exists in the array; else add it.
91602>>>>>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to iItem
91603>>>>>>>            If (iItem = -1) Begin
91605>>>>>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
91606>>>>>>>            End
91606>>>>>>>>
91606>>>>>>>
91606>>>>>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
91607>>>>>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
91608>>>>>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
91609>>>>>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
91610>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
91611>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
91612>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
91613>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
91614>>>>>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
91615>>>>>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
91616>>>>>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
91617>>>>>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
91618>>>>>>>        Loop
91619>>>>>>>>
91619>>>>>>>
91619>>>>>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to aAPIRelationCompare
91620>>>>>>>
91620>>>>>>>        Function_Return aAPIRelationCompare
91621>>>>>>>    End_Function
91622>>>>>>>
91622>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91622>>>>>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
91624>>>>>>>        Function_Return False
91625>>>>>>>    End_Function
91626>>>>>>>
91626>>>>>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
91626>>>>>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
91626>>>>>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
91626>>>>>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
91628>>>>>>>        Boolean bFound
91628>>>>>>>
91628>>>>>>>        Move False to Err
91629>>>>>>>        Open CodeMast
91631>>>>>>>        Open CodeType
91633>>>>>>>
91633>>>>>>>        If (bCodeType = True) Begin
91635>>>>>>>            Set Private.phCurrentTable to CODETYPE.File_Number
91636>>>>>>>            Clear CodeType
91637>>>>>>>            Move sTypeValue to CODETYPE.Type
91638>>>>>>>            Find eq CODETYPE by 1
91639>>>>>>>>
91639>>>>>>>            Move Found to bFound
91640>>>>>>>            If (bFound = True) Begin
91642>>>>>>>                Reread CodeType
91646>>>>>>>            End
91646>>>>>>>>
91646>>>>>>>            Else Begin
91647>>>>>>>                Clear CodeType
91648>>>>>>>            End
91648>>>>>>>>
91648>>>>>>>
91648>>>>>>>            Move sTypeValue to CODETYPE.Type
91649>>>>>>>            Move sValue2    to CODETYPE.Description
91650>>>>>>>            Move sValue3    to CODETYPE.Comment
91651>>>>>>>            SaveRecord CODETYPE
91652>>>>>>>
91652>>>>>>>            If (bFound = True) Begin
91654>>>>>>>                Unlock
91655>>>>>>>>
91655>>>>>>>            End
91655>>>>>>>>
91655>>>>>>>        End
91655>>>>>>>>
91655>>>>>>>
91655>>>>>>>        If (bCodeType = False) Begin
91657>>>>>>>            Set Private.phCurrentTable to CODEMAST.File_Number
91658>>>>>>>            Clear CODEMAST
91659>>>>>>>            Move sTypeValue to CODEMAST.Type
91660>>>>>>>            Move sValue2    to CODEMAST.Code
91661>>>>>>>            Find eq CODEMAST by 1
91662>>>>>>>>
91662>>>>>>>            Move Found to bFound
91663>>>>>>>            If (bFound = True) Begin
91665>>>>>>>                Reread CODEMAST
91669>>>>>>>            End
91669>>>>>>>>
91669>>>>>>>            Else Begin
91670>>>>>>>                Clear CODEMAST
91671>>>>>>>            End
91671>>>>>>>>
91671>>>>>>>
91671>>>>>>>            Move sTypeValue to CODEMAST.Type
91672>>>>>>>            Move sValue2    to CODEMAST.Code
91673>>>>>>>            Move sValue3    to CODEMAST.Description
91674>>>>>>>            SaveRecord CODEMAST
91675>>>>>>>
91675>>>>>>>            If (bFound = True) Begin
91677>>>>>>>                Unlock
91678>>>>>>>>
91678>>>>>>>            End
91678>>>>>>>>
91678>>>>>>>        End
91678>>>>>>>>
91678>>>>>>>
91678>>>>>>>        Close CodeMast
91679>>>>>>>        Close CodeType
91680>>>>>>>
91680>>>>>>>        Function_Return (Err = False)
91681>>>>>>>    End_Function
91682>>>>>>>
91682>>>>>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
91682>>>>>>>    // CodeType and then spins through all CodeMast records to change all related records.
91682>>>>>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
91684>>>>>>>        Boolean bFound
91684>>>>>>>
91684>>>>>>>        Move False to Err
91685>>>>>>>        Open CodeMast
91687>>>>>>>        Open CodeType
91689>>>>>>>
91689>>>>>>>        Clear CodeType
91690>>>>>>>        Move sFromValue to CODETYPE.Type
91691>>>>>>>        Find eq CODETYPE.Type
91692>>>>>>>>
91692>>>>>>>        If (Found = True) Begin
91694>>>>>>>            Reread CODETYPE
91698>>>>>>>                Move sToValue to CODETYPE.Type
91699>>>>>>>                SaveRecord CODETYPE
91700>>>>>>>            Unlock
91701>>>>>>>>
91701>>>>>>>        End
91701>>>>>>>>
91701>>>>>>>
91701>>>>>>>        Clear CODEMAST
91702>>>>>>>        Find gt CODEMAST by Recnum
91703>>>>>>>>
91703>>>>>>>        While (Found = True)
91707>>>>>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
91708>>>>>>>            If (bFound = True) Begin
91710>>>>>>>                Reread CODEMAST
91714>>>>>>>                    Move sToValue to CODEMAST.Type
91715>>>>>>>                    SaveRecord CODEMAST
91716>>>>>>>                Unlock
91717>>>>>>>>
91717>>>>>>>            End
91717>>>>>>>>
91717>>>>>>>            Find gt CODEMAST by Recnum
91718>>>>>>>>
91718>>>>>>>        Loop
91719>>>>>>>>
91719>>>>>>>
91719>>>>>>>        Close CodeMast
91720>>>>>>>        Close CodeType
91721>>>>>>>
91721>>>>>>>        Function_Return (Err = False)
91722>>>>>>>    End_Function
91723>>>>>>>
91723>>>>>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
91723>>>>>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
91725>>>>>>>        Boolean bFound
91725>>>>>>>
91725>>>>>>>        Move False to Err
91726>>>>>>>        Open CodeMast
91728>>>>>>>
91728>>>>>>>        Clear CODEMAST
91729>>>>>>>        Move sTypeValue to CODEMAST.Type
91730>>>>>>>        Move sValue2    to CODEMAST.Code
91731>>>>>>>        Find eq CODEMAST.Code
91732>>>>>>>>
91732>>>>>>>        Move Found to bFound
91733>>>>>>>        If (bFound = True) Begin
91735>>>>>>>            Delete CODEMAST
91736>>>>>>>        End
91736>>>>>>>>
91736>>>>>>>
91736>>>>>>>        Close CodeMast
91737>>>>>>>
91737>>>>>>>        Function_Return (Err = False)
91738>>>>>>>    End_Function
91739>>>>>>>
91739>>>>>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
91741>>>>>>>        Boolean bRecnum bToAnsi
91741>>>>>>>        Integer iCh
91741>>>>>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
91741>>>>>>>
91741>>>>>>>        If (Trim(sDataPath) = "") Begin
91743>>>>>>>            Function_Return False
91744>>>>>>>        End
91744>>>>>>>>
91744>>>>>>>
91744>>>>>>>        Move False to Err
91745>>>>>>>        Get psDriverID     to sDriverID
91746>>>>>>>        Get psConnectionID to sConnectionID
91747>>>>>>>        Get psSchema       to sSchemaName
91748>>>>>>>        Get True           to bRecnum
91749>>>>>>>        Get pbToANSI       to bToAnsi
91750>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
91751>>>>>>>        If (bToAnsi = False) Begin
91753>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
91754>>>>>>>        End
91754>>>>>>>>
91754>>>>>>>
91754>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91755>>>>>>>        Move "CodeMast.int"         to sFileName
91756>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91757>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91760>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91763>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
91766>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91769>>>>>>>            Writeln channel iCh ("")
91772>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91775>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91778>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91781>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91784>>>>>>>            Writeln channel iCh ("")
91787>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91790>>>>>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
91793>>>>>>>            Writeln channel iCh ("")
91796>>>>>>>        Send Seq_Close_Channel iCh
91797>>>>>>>
91797>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91798>>>>>>>        Move "CodeType.int"         to sFileName
91799>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91800>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91803>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91806>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
91809>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91812>>>>>>>            Writeln channel iCh ("")
91815>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91818>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91821>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91824>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91827>>>>>>>            Writeln channel iCh ("")
91830>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 0")
91833>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
91836>>>>>>>            Writeln channel iCh ("")
91839>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91842>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
91845>>>>>>>            Writeln channel iCh ("")
91848>>>>>>>        Send Seq_Close_Channel iCh
91849>>>>>>>
91849>>>>>>>        Function_Return (Err = False)
91850>>>>>>>    End_Function
91851>>>>>>>
91851>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91851>>>>>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
91853>>>>>>>        Function_Return False
91854>>>>>>>    End_Function
91855>>>>>>>
91855>>>>>>>    // Use function to move *.fd, termlist.*, collate.*, dfcollate.* files to a "Data\Backup" folder,
91855>>>>>>>    // and to remove all *.cch files (DAW SQL driver cache files. They will get recreated when needed.)
91855>>>>>>>    Function UtilMoveMiscFilesToBackupFolder Returns Boolean
91857>>>>>>>        Boolean bOK bExists
91857>>>>>>>        String sDataPath sBackupFolder
91857>>>>>>>
91857>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving misc. files to Backup folder."
91858>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
91859>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
91860>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91861>>>>>>>
91861>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91862>>>>>>>        If (bExists = False) Begin
91864>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
91865>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91866>>>>>>>            If (bExists = False) Begin
91868>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all misc. files to. You need to move them somewhere manually.")
91869>>>>>>>>
91869>>>>>>>                Function_Return False
91870>>>>>>>            End
91870>>>>>>>>
91870>>>>>>>            Get vMoveFile (sDataPath + "*.fd")         (sDataPath + sBackupFolder) to bOK  
91871>>>>>>>            Get vMoveFile (sDataPath + "*.bad")        (sDataPath + sBackupFolder) to bOK  
91872>>>>>>>            Get vMoveFile (sDataPath + "*.err")        (sDataPath + sBackupFolder) to bOK  
91873>>>>>>>            Get vMoveFile (sDataPath + "*.bak")        (sDataPath + sBackupFolder) to bOK
91874>>>>>>>            Get vMoveFile (sDataPath + "*.def")        (sDataPath + sBackupFolder) to bOK
91875>>>>>>>            Get vMoveFile (sDataPath + "*.fil")        (sDataPath + sBackupFolder) to bOK
91876>>>>>>>            Get vMoveFile (sDataPath + "*.hlp")        (sDataPath + sBackupFolder) to bOK
91877>>>>>>>            Get vMoveFile (sDataPath + "*.old")        (sDataPath + sBackupFolder) to bOK           
91878>>>>>>>            Get vMoveFile (sDataPath + "*.prn")        (sDataPath + sBackupFolder) to bOK           
91879>>>>>>>            Get vMoveFile (sDataPath + "*.sts")        (sDataPath + sBackupFolder) to bOK           
91880>>>>>>>            Get vMoveFile (sDataPath + "*.td")         (sDataPath + sBackupFolder) to bOK           
91881>>>>>>>            Get vMoveFile (sDataPath + "*.log")        (sDataPath + sBackupFolder) to bOK           
91882>>>>>>>            Get vMoveFile (sDataPath + "*.bat")        (sDataPath + sBackupFolder) to bOK           
91883>>>>>>>            Get vMoveFile (sDataPath + "*.cmd")        (sDataPath + sBackupFolder) to bOK           
91884>>>>>>>            Get vMoveFile (sDataPath + "*.zip")        (sDataPath + sBackupFolder) to bOK           
91885>>>>>>>            Get vMoveFile (sDataPath + "*.abs")        (sDataPath + sBackupFolder) to bOK           
91886>>>>>>>            Get vMoveFile (sDataPath + "termlist.*")   (sDataPath + sBackupFolder) to bOK
91887>>>>>>>            Get vMoveFile (sDataPath + "*.dfr")        (sDataPath + sBackupFolder) to bOK
91888>>>>>>>            Get vMoveFile (sDataPath + "vsutil.cfg")   (sDataPath + sBackupFolder) to bOK
91889>>>>>>>            Get vMoveFile (sDataPath + "collate.*")    (sDataPath + sBackupFolder) to bOK
91890>>>>>>>            Get vMoveFile (sDataPath + "df_collate.*") (sDataPath + sBackupFolder) to bOK
91891>>>>>>>            Get vDeleteFile (sDataPath + "*.cch")                                  to bOK
91892>>>>>>>        End
91892>>>>>>>>
91892>>>>>>>
91892>>>>>>>        Set Message_Text of ghoStatusPanel to ""
91893>>>>>>>        Function_Return True
91894>>>>>>>    End_Function
91895>>>>>>>    
91895>>>>>>>    // Check if the file exists in the Data folder,
91895>>>>>>>    // else creates it from memory as it has been compiled into the program as a resource:
91895>>>>>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
91897>>>>>>>        String sPath
91897>>>>>>>        Boolean bExists
91897>>>>>>>
91897>>>>>>>        Get psDataPathFirstPart to sPath
91898>>>>>>>        Move (sPath + sFileName) to sFileName
91899>>>>>>>        Get vFilePathExists sFileName to bExists
91900>>>>>>>
91900>>>>>>>        If (bExists = False) Begin
91902>>>>>>>            // Read from memory & create file on disk.
91902>>>>>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
91903>>>>>>>            Get vFilePathExists sFileName to bExists
91904>>>>>>>        End
91904>>>>>>>>
91904>>>>>>>        Function_Return bExists
91905>>>>>>>    End_Function
91906>>>>>>>
91906>>>>>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
91908>>>>>>>        tColumnType RetvalType
91908>>>>>>>        tColumnType RetvalType
91908>>>>>>>        Integer iRetval
91908>>>>>>>
91908>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91909>>>>>>>        Move RetvalType.iDataFlexType to iRetval
91910>>>>>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
91912>>>>>>>            If (iLength <= 255) Begin
91914>>>>>>>                Move DF_ASCII to iRetval
91915>>>>>>>            End
91915>>>>>>>>
91915>>>>>>>        End
91915>>>>>>>>
91915>>>>>>>        Function_Return iRetval
91916>>>>>>>    End_Function
91917>>>>>>>
91917>>>>>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
91919>>>>>>>        String sRetval
91919>>>>>>>
91919>>>>>>>        Case Begin
91919>>>>>>>            Case (iDataType = DF_ASCII)
91921>>>>>>>                Move "DF_ASCII" to sRetval
91922>>>>>>>                Case Break
91923>>>>>>>            Case (iDataType = DF_BCD)
91926>>>>>>>                Move "DF_BCD" to sRetval
91927>>>>>>>                Case Break
91928>>>>>>>            Case (iDataType = DF_BINARY)
91931>>>>>>>                Move "DF_BINARY" to sRetval
91932>>>>>>>                Case Break
91933>>>>>>>            Case (iDataType = DF_DATE)
91936>>>>>>>                Move "DF_DATE" to sRetval
91937>>>>>>>                Case Break
91938>>>>>>>            Case (iDataType = DF_DATETIME)
91941>>>>>>>                Move "DF_DATETIME" to sRetval
91942>>>>>>>                Case Break
91943>>>>>>>            Case (iDataType = DF_TEXT)
91946>>>>>>>                Move "DF_TEXT" to sRetval
91947>>>>>>>                Case Break
91948>>>>>>>            Case Else
91948>>>>>>>                Move "" to sRetval
91949>>>>>>>        Case End
91949>>>>>>>
91949>>>>>>>        Function_Return sRetval
91950>>>>>>>    End_Function
91951>>>>>>>
91951>>>>>>>    // The default value used for a datatype as specified in the driver int file.
91951>>>>>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
91953>>>>>>>        String sRetval sServer
91953>>>>>>>        tColumnType RetvalType
91953>>>>>>>        tColumnType RetvalType
91953>>>>>>>        Integer iDriver iDataFlexType
91953>>>>>>>        Handle hDatabase
91953>>>>>>>
91953>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91954>>>>>>>        Move RetvalType.iDataFlexType to iDataFlexType
91955>>>>>>>        Get DriverIndex sDriverID to iDriver
91956>>>>>>>        Get psServer to sServer
91957>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91958>>>>>>>        If (hDatabase = 0) Begin
91960>>>>>>>            Function_Return ""
91961>>>>>>>        End
91961>>>>>>>>
91961>>>>>>>
91961>>>>>>>        Case Begin
91961>>>>>>>            Case (iDataFlexType = DF_ASCII)
91963>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
91966>>>>>>>                Case Break
91967>>>>>>>            Case (iDataFlexType = DF_BCD)
91970>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
91973>>>>>>>                Case Break
91974>>>>>>>            Case (iDataFlexType = DF_BINARY)
91977>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
91980>>>>>>>                Case Break
91981>>>>>>>            Case (iDataFlexType = DF_DATE)
91984>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
91987>>>>>>>                Case Break
91988>>>>>>>            Case (iDataFlexType = DF_DATETIME)
91991>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
91994>>>>>>>                Case Break
91995>>>>>>>            Case (iDataFlexType = DF_TEXT)
91998>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
92001>>>>>>>                Case Break
92002>>>>>>>            Case Else
92002>>>>>>>                Move "" to sRetval
92003>>>>>>>        Case End
92003>>>>>>>
92003>>>>>>>        Function_Return sRetval
92004>>>>>>>    End_Function
92005>>>>>>>
92005>>>>>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
92007>>>>>>>        String sDriverID sServer
92007>>>>>>>        tColumnType RetvalType
92007>>>>>>>        tColumnType RetvalType
92007>>>>>>>        Integer iDbType iDriver
92007>>>>>>>        Handle hDatabase
92007>>>>>>>
92007>>>>>>>        Get psDriverID to sDriverID
92008>>>>>>>        Get piDbType   to iDbType
92009>>>>>>>        Get DriverIndex sDriverID to iDriver
92010>>>>>>>        Get psServer to sServer
92011>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
92012>>>>>>>        If (hDatabase = 0) Begin
92014>>>>>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database. (Check that at least one connection is 'Enabled')"
92015>>>>>>>>
92015>>>>>>>            Procedure_Return
92016>>>>>>>        End
92016>>>>>>>>
92016>>>>>>>
92016>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
92019>>>>>>>
92019>>>>>>>    End_Procedure
92020>>>>>>>
92020>>>>>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
92022>>>>>>>        String sDriverID sServer
92022>>>>>>>        tColumnType RetvalType
92022>>>>>>>        tColumnType RetvalType
92022>>>>>>>        Integer iDbType iDriver
92022>>>>>>>        Handle hDatabase
92022>>>>>>>
92022>>>>>>>        Get psDriverID to sDriverID
92023>>>>>>>        Get piDbType   to iDbType
92024>>>>>>>        Get DriverIndex sDriverID to iDriver
92025>>>>>>>        Get psServer to sServer
92026>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
92027>>>>>>>        If (hDatabase = 0) Begin
92029>>>>>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
92030>>>>>>>>
92030>>>>>>>            Procedure_Return
92031>>>>>>>        End
92031>>>>>>>>
92031>>>>>>>
92031>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
92034>>>>>>>
92034>>>>>>>    End_Procedure
92035>>>>>>>
92035>>>>>>>    // Returns a struct array with the default column types for the SQL back-end and how they
92035>>>>>>>    // are mapped to the standard DataFlex data types.
92035>>>>>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
92035>>>>>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
92037>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
92037>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
92039>>>>>>>        String sDataType
92039>>>>>>>        Integer iDataType iDriverID iCount
92039>>>>>>>        Boolean bSQLDriver
92039>>>>>>>
92039>>>>>>>        Move 0 to iCount
92040>>>>>>>        Get DriverIndex sDriverID to iDriverID
92041>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
92042>>>>>>>        If (bSQLDriver = False) Begin
92044>>>>>>>            Function_Return EmptyArray
92045>>>>>>>        End
92045>>>>>>>>
92045>>>>>>>
92045>>>>>>>        // DF_ASCII
92045>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92047>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
92050>>>>>>>        End
92050>>>>>>>>
92050>>>>>>>        Else Begin
92051>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
92054>>>>>>>        End
92054>>>>>>>>
92054>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92055>>>>>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
92056>>>>>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
92057>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92058>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92059>>>>>>>        Increment iCount
92060>>>>>>>
92060>>>>>>>        // DF_BINARY
92060>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92062>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
92065>>>>>>>        End
92065>>>>>>>>
92065>>>>>>>        Else Begin
92066>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
92069>>>>>>>        End
92069>>>>>>>>
92069>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92070>>>>>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
92071>>>>>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
92072>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92073>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92074>>>>>>>        Increment iCount
92075>>>>>>>
92075>>>>>>>        // DF_DATE
92075>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92077>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
92080>>>>>>>        End
92080>>>>>>>>
92080>>>>>>>        Else Begin
92081>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
92084>>>>>>>        End
92084>>>>>>>>
92084>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92085>>>>>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
92086>>>>>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
92087>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92088>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92089>>>>>>>        Increment iCount
92090>>>>>>>
92090>>>>>>>        // DF_DATETIME
92090>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92092>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
92095>>>>>>>        End
92095>>>>>>>>
92095>>>>>>>        Else Begin
92096>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
92099>>>>>>>        End
92099>>>>>>>>
92099>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92100>>>>>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
92101>>>>>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
92102>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92103>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92104>>>>>>>        Increment iCount
92105>>>>>>>
92105>>>>>>>        // DF_NUMERIC
92105>>>>>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
92105>>>>>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
92105>>>>>>>        // we make them here all "Numeric"...
92105>>>>>>>        Case Begin
92105>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
92107>>>>>>>                Move SQL_NUMERIC to iDataType
92108>>>>>>>                Move "numeric"   to sDataType
92109>>>>>>>                Case Break
92110>>>>>>>            Case (sDriverID = DB2_DRV_ID)
92113>>>>>>>                Move SQL_NUMERIC to iDataType
92114>>>>>>>                Move "NUMERIC"   to sDataType
92115>>>>>>>                Case Break
92116>>>>>>>            Case Else
92116>>>>>>>                Move DF_BCD      to iDataType
92117>>>>>>>                Move "Numeric"   to sDataType
92118>>>>>>>        Case End
92118>>>>>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
92119>>>>>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
92120>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92121>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92122>>>>>>>        Increment iCount
92123>>>>>>>
92123>>>>>>>        // DF_TEXT
92123>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92125>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
92128>>>>>>>        End
92128>>>>>>>>
92128>>>>>>>        Else Begin
92129>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
92132>>>>>>>        End
92132>>>>>>>>
92132>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92133>>>>>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
92134>>>>>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
92135>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92136>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92137>>>>>>>
92137>>>>>>>        Function_Return ColumnTypeArray
92138>>>>>>>    End_Function
92139>>>>>>>
92139>>>>>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
92141>>>>>>>        tColumnType[] ColumnTypeArray
92141>>>>>>>        tColumnType[] ColumnTypeArray
92142>>>>>>>        tColumnType   ColumnType
92142>>>>>>>        tColumnType   ColumnType
92142>>>>>>>        Integer iCount iSize
92142>>>>>>>
92142>>>>>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
92143>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
92144>>>>>>>        Decrement iSize
92145>>>>>>>
92145>>>>>>>        for iCount from 0 to iSize
92151>>>>>>>>
92151>>>>>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
92153>>>>>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
92154>>>>>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
92155>>>>>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
92156>>>>>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
92157>>>>>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
92158>>>>>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
92159>>>>>>>                Move iSize to iCount
92160>>>>>>>            End
92160>>>>>>>>
92160>>>>>>>        Loop
92161>>>>>>>>
92161>>>>>>>
92161>>>>>>>        Function_Return ColumnType
92162>>>>>>>    End_Function
92163>>>>>>>
92163>>>>>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
92163>>>>>>>    // An Alias file/table is a filelist number that share the same Physical filename
92163>>>>>>>    // but the Logical name is different.
92163>>>>>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
92163>>>>>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
92165>>>>>>>        String sRootName sRootNameCompare sLogicalName sLogicalNameCompare
92165>>>>>>>        Handle hInTable hMasterTable 
92165>>>>>>>        Boolean bIsAlias
92165>>>>>>>        
92165>>>>>>>        Move hTable to hInTable
92166>>>>>>>        Move False to bIsAlias
92167>>>>>>>        Move 0 to hMasterTable
92168>>>>>>>        
92168>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92171>>>>>>>        // Remove any prefix with a driver name.
92171>>>>>>>        Get _TableNameOnly sRootName to sRootName     
92172>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
92175>>>>>>>        Get _TableNameOnly sLogicalName to sLogicalName     
92176>>>>>>>        
92176>>>>>>>        // If the table has the same root and logical name it can't be an alias,
92176>>>>>>>        // so we can safely return a "False".
92176>>>>>>>        If (Uppercase(sRootName) <> Uppercase(sLogicalName)) Begin
92178>>>>>>>            Function_Return True
92179>>>>>>>        End
92179>>>>>>>>
92179>>>>>>>        
92179>>>>>>>        Function_Return False
92180>>>>>>>        
92180>>>>>>>        // Now we need to find a master table with the same root name (sRootName above),
92180>>>>>>>        // as the passed hTable root name.
92180>>>>>>>        // A master table always has the same root and logical name (except for any driver name prefix or .int suffix).
92180>>>>>>>//        Move 0 to hTable
92180>>>>>>>//        Repeat
92180>>>>>>>//            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92180>>>>>>>//            If (hTable > 0 and hTable <> 50) Begin
92180>>>>>>>//                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameCompare
92180>>>>>>>//                Get _TableNameOnly sRootNameCompare to sRootNameCompare
92180>>>>>>>//                // If we found another table with the same root and logical name
92180>>>>>>>//                // we have found a master table.
92180>>>>>>>//                If (Uppercase(sRootName) = Uppercase(sRootNameCompare)) Begin
92180>>>>>>>//                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameCompare
92180>>>>>>>//                    Get _TableNameOnly sLogicalNameCompare to sLogicalNameCompare     
92180>>>>>>>//                    If (Uppercase(sRootNameCompare) = Uppercase(sLogicalNameCompare)) Begin
92180>>>>>>>//                        Move hTable to hMasterTable   
92180>>>>>>>//                        Move 0 to hTable // To end the loop.
92180>>>>>>>//                    End
92180>>>>>>>//                End
92180>>>>>>>//            End
92180>>>>>>>//        Until (hTable = 0)
92180>>>>>>>//        
92180>>>>>>>//        If (hMasterTable <> 0 and hMasterTable <> hInTable) Begin
92180>>>>>>>//            Move True to bIsAlias
92180>>>>>>>//        End
92180>>>>>>>//        
92180>>>>>>>//        Function_Return bIsAlias
92180>>>>>>>    End_Function
92181>>>>>>>
92181>>>>>>>    // To Open a table with any driver.
92181>>>>>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
92181>>>>>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
92181>>>>>>>    //
92181>>>>>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
92181>>>>>>>    // The found flag is still used to indicate if the open was successful or not. The function
92181>>>>>>>    // returns a True if successful (table could be opened).
92181>>>>>>>    //
92181>>>>>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
92181>>>>>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
92181>>>>>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
92181>>>>>>>    // set properly we can open the table.
92181>>>>>>>    //
92181>>>>>>>    // DAW Driver Syntax:
92181>>>>>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
92181>>>>>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
92181>>>>>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
92181>>>>>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
92181>>>>>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
92181>>>>>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
92181>>>>>>>    //
92181>>>>>>>    // DAW Driver Sample:
92181>>>>>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
92181>>>>>>>    //
92181>>>>>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
92183>>>>>>>        String sTableNameOrg
92183>>>>>>>        Boolean bOpen bOK
92183>>>>>>>        tSQLConnection SQLConnection
92183>>>>>>>        tSQLConnection SQLConnection
92183>>>>>>>        
92183>>>>>>>        Move False to bOpen
92184>>>>>>>        Move sTableName to sTableNameOrg
92185>>>>>>>        If (hTable > 0) Begin
92187>>>>>>>            Send Ignore_Error of Error_Object_Id 20529
92188>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
92189>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
92190>>>>>>>            Send Ignore_Error of Error_Object_Id 10
92191>>>>>>>            Open hTable Mode iMode
92193>>>>>>>            Send Trap_Error of Error_Object_Id 20529
92194>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
92195>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
92196>>>>>>>            Send Trap_Error of Error_Object_Id 10
92197>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
92200>>>>>>>            If (bOpen = True) Begin
92202>>>>>>>                Function_Return True
92203>>>>>>>            End
92203>>>>>>>>
92203>>>>>>>        End
92203>>>>>>>>
92203>>>>>>>
92203>>>>>>>        Get UtilTableOpenAsIntFile hTable sTableName iMode to bOK 
92204>>>>>>>        If (hTable > 0) Begin
92206>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
92209>>>>>>>        End
92209>>>>>>>>
92209>>>>>>>
92209>>>>>>>        Function_Return bOpen
92210>>>>>>>    End_Function
92211>>>>>>>
92211>>>>>>>    Function UtilTableOpenAsIntFile Integer hTable String sTableName Integer iMode Returns Boolean
92213>>>>>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
92213>>>>>>>        Boolean bOpen bOK
92213>>>>>>>        tSQLConnection SQLConnection
92213>>>>>>>        tSQLConnection SQLConnection
92213>>>>>>>
92213>>>>>>>        If (hTable < 1) Begin
92215>>>>>>>            Function_Return False
92216>>>>>>>        End
92216>>>>>>>>
92216>>>>>>>
92216>>>>>>>        Move sTableName to sTableNameOrg
92217>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92218>>>>>>>        Move SQLConnection.sDriverID to sDriverID
92219>>>>>>>        Move SQLConnection.sConnectionString to sConnection
92220>>>>>>>        Move SQLConnection.sSchema to sSchema
92221>>>>>>>        If (sSchema = "") Begin
92223>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
92224>>>>>>>        End
92224>>>>>>>>
92224>>>>>>>
92224>>>>>>>        // We need to remove the ".int" part of the table name because
92224>>>>>>>        // the table name after the "#" in the connection syntax below wants the
92224>>>>>>>        // "bare" table name without any extension.
92224>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
92226>>>>>>>            If (Lowercase(sTableName) contains ".int") Begin
92228>>>>>>>                Get ParseFileExtension sTableName to sExt
92229>>>>>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
92230>>>>>>>            End
92230>>>>>>>>
92230>>>>>>>            Else Begin
92231>>>>>>>                Move sTableName to sTableNameShort
92232>>>>>>>                Move (Append(sTableName, ".int")) to sTableName
92233>>>>>>>            End
92233>>>>>>>>
92233>>>>>>>            Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
92234>>>>>>>            Move sConnection to sTableName
92235>>>>>>>        End
92235>>>>>>>>
92235>>>>>>>
92235>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
92236>>>>>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
92237>>>>>>>        If (hTable = 0) Begin
92239>>>>>>>            Get NextFreeFilelistSlot to hTable
92240>>>>>>>        End
92240>>>>>>>>
92240>>>>>>>
92240>>>>>>>        Case Begin
92240>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
92242>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92242>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
92244>>>>>>>                    Close hTable
92245>>>>>>>                    Open sTableName as hTable
92247>>>>>>>                End
92247>>>>>>>>
92247>>>>>>>                Else Begin
92248>>>>>>>                    Get OpenTableExclusive hTable to bOK
92249>>>>>>>                    If (bOK = False) Begin
92251>>>>>>>                        Function_Return False
92252>>>>>>>                    End
92252>>>>>>>>
92252>>>>>>>                End
92252>>>>>>>>
92252>>>>>>>                Case Break
92253>>>>>>>
92253>>>>>>>            Case (sDriverID = DB2_DRV_ID)
92256>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92256>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
92258>>>>>>>                    Close hTable
92259>>>>>>>                    Open sTableName as hTable
92261>>>>>>>                End
92261>>>>>>>>
92261>>>>>>>                Else Begin
92262>>>>>>>                    Get OpenTableExclusive hTable to bOK
92263>>>>>>>                    If (bOK = False) Begin
92265>>>>>>>                        Function_Return False
92266>>>>>>>                    End
92266>>>>>>>>
92266>>>>>>>                End
92266>>>>>>>>
92266>>>>>>>                Case Break
92267>>>>>>>
92267>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
92270>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92270>>>>>>>                If (iMode = DF_SHARE) Begin
92272>>>>>>>                    Close hTable
92273>>>>>>>                    Open sTableName as hTable
92275>>>>>>>                End
92275>>>>>>>>
92275>>>>>>>                Else Begin
92276>>>>>>>                    Get OpenTableExclusive hTable to bOK
92277>>>>>>>                    If (bOK = False) Begin
92279>>>>>>>                        Function_Return False
92280>>>>>>>                    End
92280>>>>>>>>
92280>>>>>>>                End
92280>>>>>>>>
92280>>>>>>>                Case Break
92281>>>>>>>
92281>>>>>>>            Case (sDriverID = DATAFLEX_ID)
92284>>>>>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
92286>>>>>>>                    Close hTable
92287>>>>>>>                    Open sTableName as hTable
92289>>>>>>>                End
92289>>>>>>>>
92289>>>>>>>                Else If (iMode = DF_EXCLUSIVE) Begin
92292>>>>>>>                    Get OpenTableExclusive hTable to bOK
92293>>>>>>>                    If (bOK = False) Begin
92295>>>>>>>                        Function_Return False
92296>>>>>>>                    End
92296>>>>>>>>
92296>>>>>>>                End
92296>>>>>>>>
92296>>>>>>>                Else Begin
92297>>>>>>>                    Open hTable
92299>>>>>>>                End
92299>>>>>>>>
92299>>>>>>>                Case Break
92300>>>>>>>
92300>>>>>>>            Case Else
92300>>>>>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
92301>>>>>>>>
92301>>>>>>>        Case End
92301>>>>>>>
92301>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
92302>>>>>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
92303>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
92305>>>>>>>            Move False to Found
92306>>>>>>>        End
92306>>>>>>>>
92306>>>>>>>        // If open failed, the Err is set to true,
92306>>>>>>>        // but we don't want that because it could end our loop.
92306>>>>>>>        Move False to Err
92307>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
92310>>>>>>>
92310>>>>>>>        Function_Return bOpen
92311>>>>>>>    End_Function
92312>>>>>>>
92312>>>>>>>    // Pass a table's logical name
92312>>>>>>>    // Returns True if the table exists in filelist.cfg.
92312>>>>>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
92314>>>>>>>        Handle hTable
92314>>>>>>>        Boolean bFound
92314>>>>>>>        String sCompareTable
92314>>>>>>>
92314>>>>>>>        Move False to bFound
92315>>>>>>>        Move 0 to hTable
92316>>>>>>>        Repeat
92316>>>>>>>>
92316>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92319>>>>>>>            If (hTable > 0) Begin
92321>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
92324>>>>>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
92326>>>>>>>                    Move True to bFound
92327>>>>>>>                End
92327>>>>>>>>
92327>>>>>>>            End
92327>>>>>>>>
92327>>>>>>>            If (bFound = True) ;                Break
92330>>>>>>>        Until (hTable = 0)
92332>>>>>>>
92332>>>>>>>        Function_Return (bFound = True)
92333>>>>>>>    End_Function
92334>>>>>>>
92334>>>>>>>    // Function will report the default driver "DATAFLEX" if table can't be opened
92334>>>>>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
92336>>>>>>>        Boolean bOK bExists
92336>>>>>>>        String sDriverID
92336>>>>>>>
92336>>>>>>>        Get _UtilTableExists hTable to bExists
92337>>>>>>>        If (bExists = False) Begin
92339>>>>>>>            Function_Return DATAFLEX_ID
92340>>>>>>>        End
92340>>>>>>>>
92340>>>>>>>        Get OpenTableExclusive hTable to bOK
92341>>>>>>>        If (bOK = False) Begin
92343>>>>>>>            Function_Return DATAFLEX_ID
92344>>>>>>>        End
92344>>>>>>>>
92344>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
92347>>>>>>>        Function_Return sDriverID
92348>>>>>>>    End_Function
92349>>>>>>>
92349>>>>>>>    // Number of tables in Filelist.cfg. Returns integger
92349>>>>>>>    Function UtilFilelistNoOfTables Returns Integer
92351>>>>>>>        Handle hTable
92351>>>>>>>        Integer iRetval
92351>>>>>>>
92351>>>>>>>        Move 0 to hTable
92352>>>>>>>        Move 0 to iRetval
92353>>>>>>>
92353>>>>>>>        Repeat
92353>>>>>>>>
92353>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92356>>>>>>>            If (hTable > 0) Begin
92358>>>>>>>                Increment iRetval
92359>>>>>>>            End
92359>>>>>>>>
92359>>>>>>>        Until (hTable = 0)
92361>>>>>>>
92361>>>>>>>        Function_Return iRetval
92362>>>>>>>    End_Function
92363>>>>>>>
92363>>>>>>>    // Checks if any of the tables in Filelist.cfg is an SQL driver and returns the first Driver ID.
92363>>>>>>>    Function UtilIsAnyFilelistEntrySQLtable Returns String
92365>>>>>>>        Handle hTable
92365>>>>>>>        String sRoot sDriverID
92365>>>>>>>        Boolean bIsSQLTable
92365>>>>>>>        Integer iPos
92365>>>>>>>
92365>>>>>>>        Move 0 to hTable
92366>>>>>>>        Move "" to sDriverID
92367>>>>>>>        Move False to bIsSQLTable
92368>>>>>>>
92368>>>>>>>        Repeat
92368>>>>>>>>
92368>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92371>>>>>>>            If (hTable > 0) Begin
92373>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
92376>>>>>>>                If (sRoot contains ":") Begin
92378>>>>>>>                    Move (Pos(":", sRoot)) to iPos
92379>>>>>>>                    Move (Left(sRoot, (iPos -1))) to sDriverID
92380>>>>>>>                End
92380>>>>>>>>
92380>>>>>>>                Get IsSQLDriver sDriverID to bIsSQLTable
92381>>>>>>>            End
92381>>>>>>>>
92381>>>>>>>
92381>>>>>>>        Until (hTable = 0 or bIsSQLTable = True)
92383>>>>>>>
92383>>>>>>>        Function_Return sDriverID
92384>>>>>>>    End_Function
92385>>>>>>>
92385>>>>>>>    Function UtilIsAllFilelistEntriesDataFlexTables Returns Boolean
92387>>>>>>>        String sRootName
92387>>>>>>>        Boolean bIsSQL
92387>>>>>>>        Handle hTable
92387>>>>>>>
92387>>>>>>>        Move False to bIsSQL
92388>>>>>>>        Move 0 to hTable
92389>>>>>>>        Repeat
92389>>>>>>>>
92389>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92392>>>>>>>            If (hTable > 0) Begin
92394>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92397>>>>>>>                Get _UtilTableIsSqlByRootName sRootName to bIsSQL
92398>>>>>>>                If (bIsSQL = True) Begin
92400>>>>>>>                    Move 0 to hTable
92401>>>>>>>                End
92401>>>>>>>>
92401>>>>>>>            End
92401>>>>>>>>
92401>>>>>>>        Until (hTable = 0)
92403>>>>>>>
92403>>>>>>>        Function_Return (bIsSQL = False)
92404>>>>>>>    End_Function
92405>>>>>>>
92405>>>>>>>    // * Dummy function for the Studio's Code Explorer *
92405>>>>>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
92407>>>>>>>        Function_Return False
92408>>>>>>>    End_Function
92409>>>>>>>
92409>>>>>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
92411>>>>>>>        String  sRetval
92411>>>>>>>        String[] sOverlapFieldsArray
92412>>>>>>>        Integer iType iColumn iColumns
92412>>>>>>>        Boolean bOpen bOverlap
92412>>>>>>>
92412>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
92415>>>>>>>        If (bOpen = False) Begin
92417>>>>>>>            Open hTable
92419>>>>>>>        End
92419>>>>>>>>
92419>>>>>>>
92419>>>>>>>        Move "" to sRetval
92420>>>>>>>
92420>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
92423>>>>>>>
92423>>>>>>>        for iColumn from 0 to iColumns
92429>>>>>>>>
92429>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
92432>>>>>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
92434>>>>>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
92437>>>>>>>                If (bOverlap) Begin
92439>>>>>>>                    If (sRetval <> "") Begin
92441>>>>>>>                        Append sRetval ","
92442>>>>>>>                    End
92442>>>>>>>>
92442>>>>>>>                    Append sRetval iColumn
92443>>>>>>>                End
92443>>>>>>>>
92443>>>>>>>            End
92443>>>>>>>>
92443>>>>>>>        Loop
92444>>>>>>>>
92444>>>>>>>
92444>>>>>>>        If (bOpen = False) Begin
92446>>>>>>>            Close hTable
92447>>>>>>>        End
92447>>>>>>>>
92447>>>>>>>
92447>>>>>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
92448>>>>>>>
92448>>>>>>>        Function_Return sOverlapFieldsArray
92449>>>>>>>    End_Function
92450>>>>>>>
92450>>>>>>>    Function UtilEnumerateODBCDrivers Returns String
92452>>>>>>>        Handle hoRegistry hoODBCDriverNames
92452>>>>>>>        Boolean bExists bKeyOpened
92452>>>>>>>        String sKey
92452>>>>>>>        String[] sDrivers
92453>>>>>>>        Integer iDriverNames iDriverName
92453>>>>>>>
92453>>>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
92454>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
92455>>>>>>>        Set pfAccessRights of hoRegistry to Key_Read
92456>>>>>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
92457>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
92458>>>>>>>        If (bExists) Begin
92460>>>>>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
92461>>>>>>>            If (bKeyOpened) Begin
92463>>>>>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
92464>>>>>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
92465>>>>>>>                If (iDriverNames > 0) Begin
92467>>>>>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
92468>>>>>>>                    Decrement iDriverNames
92469>>>>>>>                    for iDriverName from 0 to iDriverNames
92475>>>>>>>>
92475>>>>>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
92476>>>>>>>                    Loop
92477>>>>>>>>
92477>>>>>>>                End
92477>>>>>>>>
92477>>>>>>>                Send CloseKey of hoRegistry
92478>>>>>>>            End
92478>>>>>>>>
92478>>>>>>>        End
92478>>>>>>>>
92478>>>>>>>        Send Destroy of hoRegistry
92479>>>>>>>
92479>>>>>>>        Function_Return sDrivers
92480>>>>>>>    End_Function
92481>>>>>>>
92481>>>>>>>    Procedure IncreaseSortBufferSize
92483>>>>>>>        String sNull
92483>>>>>>>        Integer iSortBufferSize
92483>>>>>>>        Boolean bBufferSet
92483>>>>>>>
92483>>>>>>>        Move "" to sNull
92484>>>>>>>        Move (1024 * 128) to iSortBufferSize
92485>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
92490>>>>>>>
92490>>>>>>>    End_Procedure
92491>>>>>>>
92491>>>>>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
92493>>>>>>>        Integer iLastIndex iIndex iNumSegments
92493>>>>>>>        Boolean bOK
92493>>>>>>>        String sDriverID
92493>>>>>>>
92493>>>>>>>        If (hTable > 0) Begin
92495>>>>>>>            Get UtilDriverFromTableNumber hTable to sDriverID
92496>>>>>>>            Close hTable
92497>>>>>>>            Get OpenTableExclusive hTable to bOK
92498>>>>>>>            If (bOK = False) Begin
92500>>>>>>>                Procedure_Return
92501>>>>>>>            End
92501>>>>>>>>
92501>>>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
92504>>>>>>>            Structure_Start hTable sDriverID
92505>>>>>>>                for iIndex from 1 to iLastIndex
92511>>>>>>>>
92511>>>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
92514>>>>>>>                    If (iNumSegments > 0) Begin
92516>>>>>>>                        If (bSetToBatch = True) Begin
92518>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
92521>>>>>>>                        End
92521>>>>>>>>
92521>>>>>>>                        Else Begin
92522>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
92525>>>>>>>                        End
92525>>>>>>>>
92525>>>>>>>                    End
92525>>>>>>>>
92525>>>>>>>                Loop
92526>>>>>>>>
92526>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92528>>>>>>>        End
92528>>>>>>>>
92528>>>>>>>    End_Procedure
92529>>>>>>>
92529>>>>>>>    Function NextFreeFilelistSlot Returns Handle
92531>>>>>>>        Handle hTable
92531>>>>>>>
92531>>>>>>>        Move 0 to hTable
92532>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
92535>>>>>>>
92535>>>>>>>        Function_Return hTable
92536>>>>>>>    End_Function
92537>>>>>>>
92537>>>>>>>    // For debugging purposes. To print Sql statements as they are build...
92537>>>>>>>    Procedure DebugPrint String sStmt String sFileName
92539>>>>>>>        Integer iCh
92539>>>>>>>        Get Seq_Append_Output_Channel sFileName to iCh
92540>>>>>>>            Write channel iCh sStmt
92542>>>>>>>        Send Seq_Close_Channel iCh
92543>>>>>>>    End_Procedure
92544>>>>>>>
92544>>>>>>>    // Returns the integer number for the passed Driver ID that is
92544>>>>>>>    // needed by some database API calls.
92544>>>>>>>    Function DriverIndex String sDriverID Returns Integer
92546>>>>>>>        String  sCurrentDriver
92546>>>>>>>        Integer iNumberOfDrivers iDriver iCount
92546>>>>>>>
92546>>>>>>>        Move 0 to iDriver
92547>>>>>>>
92547>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
92550>>>>>>>        for iCount from 1 to iNumberOfDrivers
92556>>>>>>>>
92556>>>>>>>
92556>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
92559>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
92561>>>>>>>                Move iCount to iDriver
92562>>>>>>>            End
92562>>>>>>>>
92562>>>>>>>        Loop
92563>>>>>>>>
92563>>>>>>>
92563>>>>>>>        // In case it was not found, it wasn't loaded so we do that now.
92563>>>>>>>        If (iDriver = 0) Begin
92565>>>>>>>            Move False to Err
92566>>>>>>>            Load_Driver sDriverID
92567>>>>>>>            If (Err = False) Begin
92569>>>>>>>                Get_Attribute DF_NUMBER_DRIVERS to iDriver
92572>>>>>>>            End
92572>>>>>>>>
92572>>>>>>>        End
92572>>>>>>>>
92572>>>>>>>
92572>>>>>>>        Function_Return iDriver
92573>>>>>>>    End_Function
92574>>>>>>>
92574>>>>>>>
92574>>>>>>>    Function SqlServerClientVersionName for cMSSQLHandler Integer iClientVersion  Returns String
92576>>>>>>>        String  sSqlServerClientVersionName
92576>>>>>>>        
92576>>>>>>>        Case Begin
92576>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
92578>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientVersionName
92579>>>>>>>                Case Break
92580>>>>>>>
92580>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
92583>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
92584>>>>>>>                Case Break
92585>>>>>>>                
92585>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
92588>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
92589>>>>>>>                Case Break
92590>>>>>>>            
92590>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
92593>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
92594>>>>>>>                Case Break
92595>>>>>>>            
92595>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
92598>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
92599>>>>>>>                Case Break
92600>>>>>>>            
92600>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
92603>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
92604>>>>>>>                Case Break
92605>>>>>>>            
92605>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
92608>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
92609>>>>>>>                Case Break
92610>>>>>>>            
92610>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
92613>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
92614>>>>>>>                Case Break
92615>>>>>>>            
92615>>>>>>>            Case Else
92615>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
92616>>>>>>>        Case End
92616>>>>>>>        
92616>>>>>>>        Function_Return sSqlServerClientVersionName
92617>>>>>>>    End_Function
92618>>>>>>>
92618>>>>>>>    Function SqlServerClientDriverName for cMSSQLHandler Integer iClientVersion  Returns String
92620>>>>>>>        String  sSqlServerClientDriverName
92620>>>>>>>        
92620>>>>>>>        Case Begin
92620>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
92622>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientDriverName
92623>>>>>>>                Case Break
92624>>>>>>>
92624>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
92627>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
92628>>>>>>>                Case Break
92629>>>>>>>                
92629>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
92632>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
92633>>>>>>>                Case Break
92634>>>>>>>            
92634>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
92637>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
92638>>>>>>>                Case Break
92639>>>>>>>            
92639>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
92642>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
92643>>>>>>>                Case Break
92644>>>>>>>            
92644>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
92647>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
92648>>>>>>>                Case Break
92649>>>>>>>            
92649>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
92652>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
92653>>>>>>>                Case Break
92654>>>>>>>            
92654>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
92657>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
92658>>>>>>>                Case Break
92659>>>>>>>            
92659>>>>>>>            Case Else
92659>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
92660>>>>>>>        Case End
92660>>>>>>>        
92660>>>>>>>        Function_Return sSqlServerClientDriverName
92661>>>>>>>    End_Function
92662>>>>>>>    
92662>>>>>>>    Function MinMSSQLDRV_And_ClientVersion String sMSSQLDRVVersion Integer iClientVersion Boolean bShowErrorDialog Boolean bExitProgram Returns String
92664>>>>>>>        String sDriverID sVersion sClient sClientLowest sRetval
92664>>>>>>>        Integer iNumberOfDrivers iDriver iClient
92664>>>>>>>        Handle hoCLIHandler hoMSSQLHandler   
92664>>>>>>>        Boolean bOK
92664>>>>>>>        
92664>>>>>>>        Move "" to sRetval
92665>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLIHandler
92666>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMSSQLHandler
92667>>>>>>>        Load_Driver MSSQLDRV_ID
92668>>>>>>>
92668>>>>>>>        // Loop through all loaded drivers.
92668>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
92671>>>>>>>        For iDriver from 1 to iNumberOfDrivers
92677>>>>>>>>
92677>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
92680>>>>>>>            If (sDriverID = MSSQLDRV_ID) Begin
92682>>>>>>>                Set psDriverID of hoCLIHandler to sDriverID
92683>>>>>>>                Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient   
92686>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClientVersion to sClientLowest 
92687>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClient to sClient 
92688>>>>>>>                Get CKRevision of hoCLIHandler to sVersion
92689>>>>>>>                Move (SFormat (String(C_$DatabaseDriver), (sDriverID * "-" * (String(C_$Version) + ": " + String(sVersion))))) to sRetval
92690>>>>>>>                If (sClient <> "" and sRetval <> "") Begin
92692>>>>>>>                    Move (String(sRetval) + "\n" + String(C_$SQL_Client_Text) + "\n" + Trim(sClient)) to sRetval
92693>>>>>>>                End                                
92693>>>>>>>>
92693>>>>>>>                Else Begin
92694>>>>>>>                    Move (String(C_$SQL_Client_Text) + "\n" + Trim(sClient) * "(" + String(iClient) + ")") to sRetval
92695>>>>>>>                End
92695>>>>>>>>
92695>>>>>>>            End
92695>>>>>>>>
92695>>>>>>>        Loop
92696>>>>>>>>
92696>>>>>>>        Send Destroy of hoCLIHandler  
92697>>>>>>>        Send Destroy of hoMSSQLHandler  
92698>>>>>>>        If (bShowErrorDialog = True) Begin
92700>>>>>>>            Get IsFirstStringGreaterThanSecond sVersion sMSSQLDRVVersion to bOK
92701>>>>>>>            If (bOK = False or (iClient < iClientVersion)) Begin
92703>>>>>>>                Move (MSSQLDRV_ID + ".dll" * String(C_$SQL_Driver_Version_Min_Text) *  String(sMSSQLDRVVersion) + String("\n") + String(C_$SQL_Client_Version_Min_Text) + "\n" + String(sClientLowest) + String("\n\n") + String(C_$SQL_Versions_Are_Text) + String("\n") + String(sRetval)) to sRetval
92704>>>>>>>                If (bExitProgram = True) Begin
92706>>>>>>>                    Move (String(sRetval) + String("\n\n") + String(C_$PleaseAdjustTxt) * String(C_$ProgramWillExit_Text)) to sRetval
92707>>>>>>>                End
92707>>>>>>>>
92707>>>>>>>                Send Stop_Box sRetval  
92708>>>>>>>                If (bExitProgram = True) Begin
92710>>>>>>>                    Send Exit_Application
92711>>>>>>>                End
92711>>>>>>>>
92711>>>>>>>            End
92711>>>>>>>>
92711>>>>>>>        End
92711>>>>>>>>
92711>>>>>>>        
92711>>>>>>>        Function_Return sRetval
92712>>>>>>>    End_Function  
92713>>>>>>>    
92713>>>>>>>    // Returns True if first "." separated string is greater than the second.
92713>>>>>>>    // It checks from left to right, one part of the string at a time.
92713>>>>>>>    // E.g. if sVersion="20.1.31.10 and sSQLVersion="6.3.0.13" the function would return TRUE.
92713>>>>>>>    Function IsFirstStringGreaterThanSecond Global String sVersion String sSQLVersion Returns Boolean
92715>>>>>>>        String[] asVersion asSQLVersion          
92717>>>>>>>        Integer iSize iCount iVersion iSQLVersion
92717>>>>>>>        
92717>>>>>>>        Move (StrSplitToArray(sVersion, "."))    to asVersion
92718>>>>>>>        Move (StrSplitToArray(sSQLVersion, ".")) to asSQLVersion
92719>>>>>>>        Move (SizeOfArray(asVersion)) to iSize
92720>>>>>>>        // Make sure the two arrays are of the same size:
92720>>>>>>>        If (SizeOfArray(asSQLVersion) < iSize) Begin
92722>>>>>>>            Move (ResizeArray(asSQLVersion, iSize, 0)) to asSQLVersion
92723>>>>>>>        End
92723>>>>>>>>
92723>>>>>>>        Decrement iSize
92724>>>>>>>        for iCount from 0 to iSize
92730>>>>>>>>
92730>>>>>>>            Move asVersion[iCount]    to iVersion
92731>>>>>>>            Move asSQLVersion[iCount] to iSQLVersion
92732>>>>>>>            CompilerWarnings Off
92732>>>>>>>            If (iVersion > iSQLVersion) Break
92735>>>>>>>            CompilerWarnings On
92735>>>>>>>        Loop
92736>>>>>>>>
92736>>>>>>>        
92736>>>>>>>        Function_Return (iVersion >= iSQLVersion)
92737>>>>>>>    End_Function
92738>>>>>>>
92738>>>>>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
92738>>>>>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
92738>>>>>>>    //       so in that case we "cheat" and report those tables were opened OK.
92738>>>>>>>    Function OpenTableExclusive Handle hTable Returns Boolean
92740>>>>>>>        Integer iMode iErrorObject
92740>>>>>>>        Boolean bOpened bExitIfDebuggerActive
92740>>>>>>>        String sTableName 
92740>>>>>>>        Handle hoCurrentErrorHandler
92740>>>>>>>        
92740>>>>>>>        Move False to bExitIfDebuggerActive
92741>>>>>>>        If (ghoDbUpdateHandler <> 0) Begin
92743>>>>>>>            Get pbExitIfDebuggerActive of ghoDbUpdateHandler to bExitIfDebuggerActive
92744>>>>>>>        End
92744>>>>>>>>
92744>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92745>>>>>>>        // Can't open a table properly if run through the Debugger/Studio,
92745>>>>>>>        // so we generate an error here:
92745>>>>>>>        If (IsDebuggerPresent() and bExitIfDebuggerActive = True) Begin
92747>>>>>>>            Move Error_Object_Id to hoCurrentErrorHandler
92748>>>>>>>            Get piOrgErrorHandlerID to iErrorObject
92749>>>>>>>            If (iErrorObject <> 0) Begin
92751>>>>>>>                Move iErrorObject to Error_Object_Id
92752>>>>>>>            End
92752>>>>>>>>
92752>>>>>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio! You need to run this program from outside of the Studio."
92753>>>>>>>>
92753>>>>>>>            Move hoCurrentErrorHandler to Error_Object_Id
92754>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
92755>>>>>>>            Function_Return False
92756>>>>>>>        End
92756>>>>>>>>
92756>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92759>>>>>>>        If (bOpened) Begin
92761>>>>>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
92764>>>>>>>            If (iMode = DF_EXCLUSIVE) Begin
92766>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92767>>>>>>>                Function_Return True
92768>>>>>>>            End
92768>>>>>>>>
92768>>>>>>>            Close hTable
92769>>>>>>>        End
92769>>>>>>>>
92769>>>>>>>        Else Begin
92770>>>>>>>            Open hTable
92772>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
92775>>>>>>>            If (bOpened and IsDebuggerPresent()) Begin
92777>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
92780>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
92782>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
92783>>>>>>>                    Function_Return True
92784>>>>>>>                End
92784>>>>>>>>
92784>>>>>>>            End
92784>>>>>>>>
92784>>>>>>>
92784>>>>>>>        End
92784>>>>>>>>
92784>>>>>>>
92784>>>>>>>        Close hTable
92785>>>>>>>        Open hTable Mode DF_EXCLUSIVE
92787>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92790>>>>>>>
92790>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92791>>>>>>>        Function_Return bOpened
92792>>>>>>>    End_Function
92793>>>>>>>
92793>>>>>>>    Function AutoConnectionIDLogin Returns Boolean
92795>>>>>>>        String sConnectionID sConnectionString sDriverID
92795>>>>>>>        Boolean bExists bOK bSQLDriver
92795>>>>>>>        Handle hoCLI hoDriver
92795>>>>>>>        Integer iRetval
92795>>>>>>>        tSQLConnection SQLConnection
92795>>>>>>>        tSQLConnection SQLConnection
92795>>>>>>>
92795>>>>>>>        Get psDriverID to sDriverID
92796>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
92797>>>>>>>        If (bSQLDriver = False) Begin
92799>>>>>>>            Function_Return True
92800>>>>>>>        End
92800>>>>>>>>
92800>>>>>>>
92800>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92801>>>>>>>        Move SQLConnection.sDriverID                  to sDriverID
92802>>>>>>>        Move SQLConnection.sConnectionString          to sConnectionString
92803>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
92804>>>>>>>
92804>>>>>>>        Get IsConnectionID sConnectionID sDriverID to bExists
92805>>>>>>>        If (bExists = False) Begin
92807>>>>>>>            // We always start by deleting the current connection - if any - because the
92807>>>>>>>            // login details my have changed.
92807>>>>>>>            Get phoCLIHandler to hoCLI
92808>>>>>>>            Set psDriverID    of hoCLI to sDriverID
92809>>>>>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
92810>>>>>>>            Get AutoSetConnectionID sConnectionID to bOk
92811>>>>>>>            If (bOk = False) Begin
92813>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
92814>>>>>>>>
92814>>>>>>>                Function_Return False
92815>>>>>>>            End
92815>>>>>>>>
92815>>>>>>>            Move bOK to bExists
92816>>>>>>>        End
92816>>>>>>>>
92816>>>>>>>
92816>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
92817>>>>>>>        Set Name of hoDriver to "oDbUpdateDatabaseDriver"
92818>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
92819>>>>>>>        Get DbLogin of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
92820>>>>>>>        Send Destroy of hoDriver
92821>>>>>>>
92821>>>>>>>        Function_Return (bExists = True)
92822>>>>>>>    End_Function
92823>>>>>>>
92823>>>>>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
92823>>>>>>>    // Returns: False if nobody else is running
92823>>>>>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
92823>>>>>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
92823>>>>>>>    //      tables are not locked as DataFlex tables are.
92823>>>>>>>    Function IsDatabaseInUse Returns Boolean
92825>>>>>>>        Handle  hTable
92825>>>>>>>        String  sRootName sDatabase sSchema sDriverID
92825>>>>>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs bExists
92825>>>>>>>        Integer iCount iTables
92825>>>>>>>        String[] asTablesArray asTablesArrayEmpty
92827>>>>>>>        
92827>>>>>>>        Move 0 to iTables
92828>>>>>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
92829>>>>>>>        Get AutoConnectionIDLogin to bOK
92830>>>>>>>        Get UtilFilelistNoOfTables to iTables
92831>>>>>>>        Set piPosition   of ghoProgressBar to 0
92832>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 1
92833>>>>>>>        Set piMaximum    of ghoProgressBar to iTables
92834>>>>>>>        Close DF_ALL
92835>>>>>>>        Move 0 to hTable
92836>>>>>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92839>>>>>>>        Move False to bErr
92840>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92841>>>>>>>
92841>>>>>>>        Get psDriverID to sDriverID
92842>>>>>>>        Get psDatabase to sDatabase
92843>>>>>>>        Get psSchema   to sSchema
92844>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to asTablesArray
92845>>>>>>>        Set pasSQLDataTables to asTablesArray
92846>>>>>>>        Repeat
92846>>>>>>>>
92846>>>>>>>            Set piPosition of ghoProgressBar to iCount
92847>>>>>>>            Increment iCount
92848>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92851>>>>>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
92852>>>>>>>
92852>>>>>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
92852>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQLTable
92853>>>>>>>            Move False to bOpen
92854>>>>>>>            // _UtilTableExists_Ex is a variant of "_UtilTableExists", but it needs that the pasSQLDataTables
92854>>>>>>>            // property has been set/updated before usage! This makes the loop much faster.
92854>>>>>>>            Get _UtilTableExists_Ex hTable to bExists
92855>>>>>>>            // Don't bother about CodeType (253, CodeMast (254) or) FlexErrs (Normally table 50)
92855>>>>>>>            If (bIsSQLTable = False and bExists = True and hTable <> 0 and hTable <> 253 and hTable <> 254 and bFlexErrs = False) Begin
92857>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92858>>>>>>>                Open hTable
92860>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
92863>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92864>>>>>>>                If (bOpen = True) Begin
92866>>>>>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
92866>>>>>>>                    Get UtilTableIsAlias hTable to bAlias
92867>>>>>>>                    If (bAlias = False) Begin
92869>>>>>>>                        Close hTable
92870>>>>>>>                        Get OpenTableExclusive hTable to bOpen
92871>>>>>>>                        If (bOpen = False) Begin
92873>>>>>>>                            Move True to bErr
92874>>>>>>>                        End
92874>>>>>>>>
92874>>>>>>>                    End
92874>>>>>>>>
92874>>>>>>>                End
92874>>>>>>>>
92874>>>>>>>            End
92874>>>>>>>>
92874>>>>>>>            Close hTable
92875>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92878>>>>>>>            If (bErr = True ) ;                Break
92881>>>>>>>        Until (not(hTable))
92883>>>>>>>
92883>>>>>>>        // Reset the temporary used data tables property to blank:
92883>>>>>>>        Set pasSQLDataTables to asTablesArrayEmpty
92884>>>>>>>        Set Action_Text of ghoStatusPanel to ""
92885>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92886>>>>>>>        Move False to Err
92887>>>>>>>
92887>>>>>>>        Function_Return bErr
92888>>>>>>>    End_Function
92889>>>>>>>
92889>>>>>>>End_Class
92890>>>>>Use for_all.pkg // Handy to have available in the OnUpdate event.
Including file: for_all.pkg    (C:\Program Files\DataFlex 24.0\Pkg\for_all.pkg)
92890>>>>>>>// This module contains the command definitions for the FOR_ALL construct.
92890>>>>>>>//
92890>>>>>>>// FOR_ALL is used to select and process a set of records in a database file;
92890>>>>>>>// FOR_ALL constructs may be nested. FOR_ALL is intended to work in
92890>>>>>>>// conjunction with constraint-clauses.
92890>>>>>>>//
92890>>>>>>>// SYNTAX:
92890>>>>>>>//
92890>>>>>>>//  For_All <File> BY|DOWN <Index> {AS QUE|QUEUE} {DO}
92890>>>>>>>//    <Constraints...>
92890>>>>>>>//    {DO}
92890>>>>>>>//      <loop body>
92890>>>>>>>//  End_For_All
92890>>>>>>>//
92890>>>>>>>// This set of macros implements a constraint-oriented file enumeration
92890>>>>>>>// syntax.  For example, to list all Customers by name in reverse order:
92890>>>>>>>//
92890>>>>>>>//   For_All Customer DOWN Customer.Customer_Name DO
92890>>>>>>>//     showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92890>>>>>>>//   End_For_All
92890>>>>>>>//
92890>>>>>>>// To list only Customers with a Balance greater than their credit limit:
92890>>>>>>>//
92890>>>>>>>//   For_All Customer BY Index.1
92890>>>>>>>//     CONSTRAIN Customer.Balance GT Customer.Credit_Limit
92890>>>>>>>//     DO
92890>>>>>>>//       showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92890>>>>>>>//   End_For_All
92890>>>>>>>//
92890>>>>>>>// Constraint clauses are:
92890>>>>>>>//
92890>>>>>>>//   CONSTRAIN <File> RELATES TO <File> ...
92890>>>>>>>//   CONSTRAIN <File> AS <Expression>
92890>>>>>>>//   CONSTRAIN <File.Field> AS <Expression>
92890>>>>>>>//   CONSTRAIN <File.Field> BETWEEN <lowBound> AND <highBound>
92890>>>>>>>//
92890>>>>>>>// For example, to list all customers with a bad status whose names start
92890>>>>>>>// with "A" and which have not made a payment in thirty days:
92890>>>>>>>//
92890>>>>>>>//    For_All Customer BY Index.2       //Index.2 = <Status>+<Name>
92890>>>>>>>//      CONSTRAIN Customer.Status EQ BAD
92890>>>>>>>//      CONSTRAIN Customer.Customer_Name GE "A"
92890>>>>>>>//      CONSTRAIN Customer.Customer_Name LT "B"
92890>>>>>>>//      CONSTRAIN Customer.Last_Pymt_Date LE (Today - 30)
92890>>>>>>>//      DO
92890>>>>>>>//        showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92890>>>>>>>//    End_For_All
92890>>>>>>>//
92890>>>>>>>
92890>>>>>>>
92890>>>>>>>//This command starts the loop process body when constraints are used;
92890>>>>>>>//If no constraints are required, DO should be specified on the FOR_ALL
92890>>>>>>>//command line, and not on a line by itself
92890>>>>>>>//
92890>>>>>>>
92890>>>>>>>//Ends a For_All loop
92890>>>>>>>//
92890>>>>>>>
92890>>>>>>>
92890>>>>>
92890>>>>>
92890>>>>>Class cDbUpdateVersion is a cObject
92891>>>>>
92891>>>>>    Procedure Construct_Object    
92893>>>>>        Boolean bOnCreateExecuted bUseCustomDbVersion
92893>>>>>        String[] aSQLQueryMessages
92894>>>>>        
92894>>>>>        Forward Send Construct_Object
92896>>>>>
92896>>>>>        // cDbUpdateHandler object event.
92896>>>>>        Delegate Get Private.pbOnCreateExecuted to bOnCreateExecuted
92898>>>>>        If (bOnCreateExecuted = False) Begin    
92900>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
92902>>>>>            If (bUseCustomDbVersion = False) Begin
92904>>>>>                Delegate Send CheckAutoCreateDbVersionTable 
92906>>>>>            End
92906>>>>>>
92906>>>>>            Delegate Send OnCreate
92908>>>>>            Delegate Set Private.pbOnCreateExecuted to True
92910>>>>>        End
92910>>>>>>
92910>>>>>
92910>>>>>        // Don't touch! It is used by class logic to indicate if the OnUpdate
92910>>>>>        // event was triggered, thus an actual change of the database was made.
92910>>>>>        Property Boolean pbVersionUpdate False
92911>>>>>
92911>>>>>        // This property must be manually set within each cDbUpdateVersion object
92911>>>>>        // by the programmer, to a consecutive number.
92911>>>>>        Property Number pnVersionNumber
92912>>>>>
92912>>>>>        Property Boolean pbUseConnectionID True
92913>>>>>        Property Boolean private.pbToANSI   True
92914>>>>>        Property Boolean private.pbRecnum   True
92915>>>>>        Property Boolean private.pbCopyData True
92916>>>>>        Property Boolean private.pbApiTableUpdateAuto False
92917>>>>>        Property Boolean private.pbCompareDate_DateTime False
92918>>>>>        Property Boolean private.pbCompareIndexAscending False
92919>>>>>        Property Boolean private.pbCompareIndexUppercase False
92920>>>>>        Property String private.psSchema
92921>>>>>        Property String private.psBaseTableSpace
92922>>>>>        Property String private.psLongTableSpace
92923>>>>>        Property String private.psIndexTableSpace
92924>>>>>
92924>>>>>        // Driver default value settings:
92924>>>>>        Property String private.psDriverDefaultValueASCII    ""
92925>>>>>        Property String private.psDriverDefaultValueBinary   ""
92926>>>>>        Property String private.psDriverDefaultValueDate     ""
92927>>>>>        Property String private.psDriverDefaultValueDateTime ""
92928>>>>>        Property String private.psDriverDefaultValueNumeric  ""
92929>>>>>        Property String private.psDriverDefaultValueText     ""
92930>>>>>
92930>>>>>        // Driver "nullability" settings:
92930>>>>>        Property Boolean private.pbDriverDefaultNullableASCII    False
92931>>>>>        Property Boolean private.pbDriverDefaultNullableBinary   False
92932>>>>>        Property Boolean private.pbDriverDefaultNullableDate     False
92933>>>>>        Property Boolean private.pbDriverDefaultNullableDateTime False
92934>>>>>        Property Boolean private.pbDriverDefaultNullableNumeric  False
92935>>>>>        Property Boolean private.pbDriverDefaultNullableText     False
92936>>>>>
92936>>>>>        // paSQLQueryMessages is a property of the container class cDbUpdateHandler.
92936>>>>>        // It is being used to gather ESQL message replies, and is output to the log file
92936>>>>>        // if pbVerboseState = True in the cDbUpdateHandler object.
92936>>>>>        // (See: Procedure Set pbDatabaseWasUpdated in the cDbUpdateHandler class)
92936>>>>>        // We reset it here for each cDbUpdateVersion object
92936>>>>>        Delegate Set paSQLQueryMessages to aSQLQueryMessages
92938>>>>>    End_Procedure
92939>>>>>
92939>>>>>    // *** Main hook event message ***
92939>>>>>    // Place your database update logic here!
92939>>>>>    Procedure OnUpdate
92941>>>>>    End_Procedure
92942>>>>>
92942>>>>>    // These properties also exists in the cDbUpdateFunctionLibray that is
92942>>>>>    // imported to the cDbUpdateHandler container class which should be a
92942>>>>>    // parent object to this object. To have the Studio's Property Panel
92942>>>>>    // "behave" aka show these properties we need to duplicate them in this
92942>>>>>    // class and "relay" them to the parent object.
92942>>>>>    Procedure Set pbToANSI Boolean bState
92944>>>>>        Set private.pbToANSI  to bState
92945>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92946>>>>>        Delegate Set pbToANSI to bState
92948>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92949>>>>>    End_Procedure
92950>>>>>
92950>>>>>    Function pbToANSI Returns Boolean
92952>>>>>        Function_Return (private.pbToAnsi(Self))
92953>>>>>    End_Function
92954>>>>>
92954>>>>>    Procedure Set pbRecnum Boolean bState
92956>>>>>        Set private.pbRecnum  to bState
92957>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92958>>>>>        Delegate Set pbRecnum to bState
92960>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92961>>>>>    End_Procedure
92962>>>>>
92962>>>>>    Function pbRecnum Returns Boolean
92964>>>>>        Function_Return (private.pbRecnum(Self))
92965>>>>>    End_Function
92966>>>>>
92966>>>>>    Procedure Set pbCopyData Boolean bState
92968>>>>>        Set private.pbCopyData  to bState
92969>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92970>>>>>        Delegate Set pbCopyData to bState
92972>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92973>>>>>    End_Procedure
92974>>>>>
92974>>>>>    Function pbCopyData Returns Boolean
92976>>>>>        Function_Return (private.pbCopyData(Self))
92977>>>>>    End_Function
92978>>>>>
92978>>>>>    // ToDo: Should we put these four properties under another "Property Panel" section?
92978>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
92980>>>>>        Set private.pbApiTableUpdateAuto  to bState
92981>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92982>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
92983>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92984>>>>>    End_Procedure
92985>>>>>
92985>>>>>    Function pbApiTableUpdateAuto Returns Boolean
92987>>>>>        Function_Return (private.pbApiTableUpdateAuto(Self))
92988>>>>>    End_Function
92989>>>>>
92989>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
92991>>>>>        Set private.pbCompareDate_DateTime  to bState
92992>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92993>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
92994>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92995>>>>>    End_Procedure
92996>>>>>
92996>>>>>    Function pbCompareDate_DateTime Returns Boolean
92998>>>>>        Function_Return (private.pbCompareDate_DateTime(Self))
92999>>>>>    End_Function
93000>>>>>
93000>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
93002>>>>>        Set private.pbCompareIndexAscending  to bState
93003>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93004>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
93005>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93006>>>>>    End_Procedure
93007>>>>>
93007>>>>>    Function pbCompareIndexAscending Returns Boolean
93009>>>>>        Function_Return (private.pbCompareIndexAscending(Self))
93010>>>>>    End_Function
93011>>>>>
93011>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
93013>>>>>        Set private.pbCompareIndexUppercase  to bState
93014>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93015>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
93016>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93017>>>>>    End_Procedure
93018>>>>>
93018>>>>>    Function pbCompareIndexUppercase Returns Boolean
93020>>>>>        Function_Return (private.pbCompareIndexUppercase(Self))
93021>>>>>    End_Function
93022>>>>>
93022>>>>>    Procedure Set psSchema String sValue
93024>>>>>        Set private.psSchema  to sValue
93025>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93026>>>>>        Delegate Set psSchema to sValue
93028>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93029>>>>>    End_Procedure
93030>>>>>
93030>>>>>    // First retrieve the private value that might have been set in the object.
93030>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93030>>>>>    // it might have been specified in the SQLConnections.ini file.
93030>>>>>    Function psSchema Returns String
93032>>>>>        String sValue
93032>>>>>        Get private.psSchema to sValue
93033>>>>>        If (sValue = "") Begin
93035>>>>>            Get psSchema of ghoSQLConnectionHandler to sValue
93036>>>>>        End
93036>>>>>>
93036>>>>>        Function_Return sValue
93037>>>>>    End_Function
93038>>>>>
93038>>>>>    Procedure Set psBaseTableSpace String sValue
93040>>>>>        Set private.psBaseTableSpace  to sValue
93041>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93042>>>>>        Delegate Set psBaseTableSpace to sValue
93044>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93045>>>>>    End_Procedure
93046>>>>>
93046>>>>>    // First retrieve the private value that might have been set in the object.
93046>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93046>>>>>    // it might have been specified in the SQLConnections.ini file.
93046>>>>>    Function psBaseTableSpace Returns String
93048>>>>>        String sValue
93048>>>>>        Get private.psBaseTableSpace to sValue
93049>>>>>        If (sValue = "") Begin
93051>>>>>            Get psBaseTableSpace of ghoSQLConnectionHandler to sValue
93052>>>>>        End
93052>>>>>>
93052>>>>>        Function_Return sValue
93053>>>>>    End_Function
93054>>>>>
93054>>>>>    Procedure Set psLongTableSpace String sValue
93056>>>>>        Set private.psLongTableSpace  to sValue
93057>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93058>>>>>        Delegate Set psLongTableSpace to sValue
93060>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93061>>>>>    End_Procedure
93062>>>>>
93062>>>>>    // First retrieve the private value that might have been set in the object.
93062>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93062>>>>>    // it might have been specified in the SQLConnections.ini file.
93062>>>>>    Function psLongTableSpace Returns String
93064>>>>>        String sValue
93064>>>>>        Get private.psLongTableSpace to sValue
93065>>>>>        If (sValue = "") Begin
93067>>>>>            Get psLongTableSpace of ghoSQLConnectionHandler to sValue
93068>>>>>        End
93068>>>>>>
93068>>>>>        Function_Return sValue
93069>>>>>    End_Function
93070>>>>>
93070>>>>>    Procedure Set psIndexTableSpace String sValue
93072>>>>>        Set private.psIndexTableSpace  to sValue
93073>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93074>>>>>        Delegate Set psIndexTableSpace to sValue
93076>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93077>>>>>    End_Procedure
93078>>>>>
93078>>>>>    // First retrieve the private value that might have been set in the object.
93078>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93078>>>>>    // it might have been specified in the SQLConnections.ini file.
93078>>>>>    Function psIndexTableSpace Returns String
93080>>>>>        String sValue
93080>>>>>        Get private.psIndexTableSpace to sValue
93081>>>>>        If (sValue = "") Begin
93083>>>>>            Get psIndexTableSpace of ghoSQLConnectionHandler to sValue
93084>>>>>        End
93084>>>>>>
93084>>>>>        Function_Return sValue
93085>>>>>    End_Function
93086>>>>>
93086>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
93088>>>>>        Set private.psDriverDefaultValueASCII  to sValue
93089>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93090>>>>>        Delegate Set psDriverDefaultValueASCII to sValue
93092>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93093>>>>>    End_Procedure
93094>>>>>
93094>>>>>    // First retrieve the private value that might have been set in the object.
93094>>>>>    // If blank; get it from the parent object
93094>>>>>    Function psDriverDefaultValueASCII Returns String
93096>>>>>        String sValue
93096>>>>>        Get private.psDriverDefaultValueASCII to sValue
93097>>>>>        If (sValue = "") Begin
93099>>>>>            Delegate Get psDriverDefaultValueASCII to sValue
93101>>>>>        End
93101>>>>>>
93101>>>>>        Function_Return sValue
93102>>>>>    End_Function
93103>>>>>
93103>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
93105>>>>>        Set private.psDriverDefaultValueBinary  to sValue
93106>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93107>>>>>        Delegate Set psDriverDefaultValueBinary to sValue
93109>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93110>>>>>    End_Procedure
93111>>>>>
93111>>>>>    // First retrieve the private value that might have been set in the object.
93111>>>>>    // If blank; get it from the parent object
93111>>>>>    Function psDriverDefaultValueBinary Returns String
93113>>>>>        String sValue
93113>>>>>        Get private.psDriverDefaultValueBinary to sValue
93114>>>>>        If (sValue = "") Begin
93116>>>>>            Delegate Get psDriverDefaultValueBinary to sValue
93118>>>>>        End
93118>>>>>>
93118>>>>>        Function_Return sValue
93119>>>>>    End_Function
93120>>>>>
93120>>>>>    Procedure Set psDriverDefaultValueDate String sValue
93122>>>>>        Set private.psDriverDefaultValueDate  to sValue
93123>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93124>>>>>        Delegate Set psDriverDefaultValueDate to sValue
93126>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93127>>>>>    End_Procedure
93128>>>>>
93128>>>>>    // First retrieve the private value that might have been set in the object.
93128>>>>>    // If blank; get it from the parent object
93128>>>>>    Function psDriverDefaultValueDate Returns String
93130>>>>>        String sValue
93130>>>>>        Get private.psDriverDefaultValueDate to sValue
93131>>>>>        If (sValue = "") Begin
93133>>>>>            Delegate Get psDriverDefaultValueDate to sValue
93135>>>>>        End
93135>>>>>>
93135>>>>>        Function_Return sValue
93136>>>>>    End_Function
93137>>>>>
93137>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
93139>>>>>        Set private.psDriverDefaultValueDateTime  to sValue
93140>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93141>>>>>        Delegate Set psDriverDefaultValueDateTime to sValue
93143>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93144>>>>>    End_Procedure
93145>>>>>
93145>>>>>    // First retrieve the private value that might have been set in the object.
93145>>>>>    // If blank; get it from the parent object
93145>>>>>    Function psDriverDefaultValueDateTime Returns String
93147>>>>>        String sValue
93147>>>>>        Get private.psDriverDefaultValueDateTime to sValue
93148>>>>>        If (sValue = "") Begin
93150>>>>>            Delegate Get psDriverDefaultValueDateTime to sValue
93152>>>>>        End
93152>>>>>>
93152>>>>>        Function_Return sValue
93153>>>>>    End_Function
93154>>>>>
93154>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
93156>>>>>        Set private.psDriverDefaultValueNumeric  to sValue
93157>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93158>>>>>        Delegate Set psDriverDefaultValueNumeric to sValue
93160>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93161>>>>>    End_Procedure
93162>>>>>
93162>>>>>    // First retrieve the private value that might have been set in the object.
93162>>>>>    // If blank; get it from the parent object
93162>>>>>    Function psDriverDefaultValueNumeric Returns String
93164>>>>>        String sValue
93164>>>>>        Get private.psDriverDefaultValueNumeric to sValue
93165>>>>>        If (sValue = "") Begin
93167>>>>>            Delegate Get psDriverDefaultValueNumeric to sValue
93169>>>>>        End
93169>>>>>>
93169>>>>>        Function_Return sValue
93170>>>>>    End_Function
93171>>>>>
93171>>>>>    Procedure Set psDriverDefaultValueText String sValue
93173>>>>>        Set private.psDriverDefaultValueText  to sValue
93174>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93175>>>>>        Delegate Set psDriverDefaultValueText to sValue
93177>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93178>>>>>    End_Procedure
93179>>>>>
93179>>>>>    // First retrieve the private value that might have been set in the object.
93179>>>>>    // If blank; get it from the parent object
93179>>>>>    Function psDriverDefaultValueText Returns String
93181>>>>>        String sValue
93181>>>>>        Get private.psDriverDefaultValueText to sValue
93182>>>>>        If (sValue = "") Begin
93184>>>>>            Delegate Get psDriverDefaultValueText to sValue
93186>>>>>        End
93186>>>>>>
93186>>>>>        Function_Return sValue
93187>>>>>    End_Function
93188>>>>>
93188>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
93190>>>>>        Set private.pbDriverDefaultNullableASCII  to bState
93191>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93192>>>>>        Delegate Set pbDriverDefaultNullableASCII to bState
93194>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93195>>>>>    End_Procedure
93196>>>>>
93196>>>>>    // First retrieve the private value that might have been set in the object.
93196>>>>>    // If blank; get it from the parent object
93196>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
93198>>>>>        Boolean bState
93198>>>>>        Get private.pbDriverDefaultNullableASCII to bState
93199>>>>>        If (bState = False) Begin
93201>>>>>            Delegate Get pbDriverDefaultNullableASCII to bState
93203>>>>>        End
93203>>>>>>
93203>>>>>        Function_Return bState
93204>>>>>    End_Function
93205>>>>>
93205>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
93207>>>>>        Set private.pbDriverDefaultNullableBinary  to bState
93208>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93209>>>>>        Delegate Set pbDriverDefaultNullableBinary to bState
93211>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93212>>>>>    End_Procedure
93213>>>>>
93213>>>>>    // First retrieve the private value that might have been set in the object.
93213>>>>>    // If blank; get it from the parent object
93213>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
93215>>>>>        Boolean bState
93215>>>>>        Get private.pbDriverDefaultNullableBinary to bState
93216>>>>>        If (bState = False) Begin
93218>>>>>            Delegate Get pbDriverDefaultNullableBinary to bState
93220>>>>>        End
93220>>>>>>
93220>>>>>        Function_Return bState
93221>>>>>    End_Function
93222>>>>>
93222>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
93224>>>>>        Set private.pbDriverDefaultNullableDate  to bState
93225>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93226>>>>>        Delegate Set pbDriverDefaultNullableDate to bState
93228>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93229>>>>>    End_Procedure
93230>>>>>
93230>>>>>    // First retrieve the private value that might have been set in the object.
93230>>>>>    // If blank; get it from the parent object
93230>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
93232>>>>>        Boolean bState
93232>>>>>        Get private.pbDriverDefaultNullableDate to bState
93233>>>>>        If (bState = False) Begin
93235>>>>>            Delegate Get pbDriverDefaultNullableDate to bState
93237>>>>>        End
93237>>>>>>
93237>>>>>        Function_Return bState
93238>>>>>    End_Function
93239>>>>>
93239>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
93241>>>>>        Set private.pbDriverDefaultNullableDateTime  to bState
93242>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93243>>>>>        Delegate Set pbDriverDefaultNullableDateTime to bState
93245>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93246>>>>>    End_Procedure
93247>>>>>
93247>>>>>    // First retrieve the private value that might have been set in the object.
93247>>>>>    // If blank; get it from the parent object
93247>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
93249>>>>>        Boolean bState
93249>>>>>        Get private.pbDriverDefaultNullableDateTime to bState
93250>>>>>        If (bState = False) Begin
93252>>>>>            Delegate Get pbDriverDefaultNullableDateTime to bState
93254>>>>>        End
93254>>>>>>
93254>>>>>        Function_Return bState
93255>>>>>    End_Function
93256>>>>>
93256>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
93258>>>>>        Set private.pbDriverDefaultNullableNumeric  to bState
93259>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93260>>>>>        Delegate Set pbDriverDefaultNullableNumeric to bState
93262>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93263>>>>>    End_Procedure
93264>>>>>
93264>>>>>    // First retrieve the private value that might have been set in the object.
93264>>>>>    // If blank; get it from the parent object
93264>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
93266>>>>>        Boolean bState
93266>>>>>        Get private.pbDriverDefaultNullableNumeric to bState
93267>>>>>        If (bState = False) Begin
93269>>>>>            Delegate Get pbDriverDefaultNullableNumeric to bState
93271>>>>>        End
93271>>>>>>
93271>>>>>        Function_Return bState
93272>>>>>    End_Function
93273>>>>>
93273>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
93275>>>>>        Set private.pbDriverDefaultNullableText  to bState
93276>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93277>>>>>        Delegate Set pbDriverDefaultNullableText to bState
93279>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93280>>>>>    End_Procedure
93281>>>>>
93281>>>>>    // First retrieve the private value that might have been set in the object.
93281>>>>>    // If blank; get it from the parent object
93281>>>>>    Function pbDriverDefaultNullableText Returns Boolean
93283>>>>>        Boolean bState
93283>>>>>        Get private.pbDriverDefaultNullableText to bState
93284>>>>>        If (bState = False) Begin
93286>>>>>            Delegate Get pbDriverDefaultNullableText to bState
93288>>>>>        End
93288>>>>>>
93288>>>>>        Function_Return bState
93289>>>>>    End_Function
93290>>>>>
93290>>>>>    Function ApiTableConvertToSQL Handle hTable Returns Boolean
93292>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK
93292>>>>>        String sDriverID sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace
93292>>>>>
93292>>>>>        Get psDriverID to sDriverID
93293>>>>>        Get psSchema to sSchema
93294>>>>>
93294>>>>>        Get psBaseTableSpace to sBaseTableSpace
93295>>>>>        If (sBaseTableSpace <> "") Begin
93297>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93298>>>>>            Delegate Set psBaseTableSpace to sBaseTableSpace
93300>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93301>>>>>        End
93301>>>>>>
93301>>>>>
93301>>>>>        Get psLongTableSpace to sLongTableSpace
93302>>>>>        If (sLongTableSpace <> "") Begin
93304>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93305>>>>>            Delegate Set psLongTableSpace to sLongTableSpace
93307>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93308>>>>>        End
93308>>>>>>
93308>>>>>
93308>>>>>        Get psIndexTableSpace to sIndexTableSpace
93309>>>>>        If (sIndexTableSpace <> "") Begin
93311>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93312>>>>>            Delegate Set psIndexTableSpace to sIndexTableSpace
93314>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93315>>>>>        End
93315>>>>>>
93315>>>>>
93315>>>>>        Get pbUseConnectionID to bUseConnectionID
93316>>>>>        Get pbToANSI          to bToANSI
93317>>>>>        Get pbRecnum          to bRecnum
93318>>>>>        Get pbCopyData        to bCopyData
93319>>>>>
93319>>>>>        Get ApiTableConvertToSQL_Ex hTable sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
93320>>>>>
93320>>>>>        Function_Return bOK
93321>>>>>    End_Function
93322>>>>>
93322>>>>>//    Function ApiTableMoveAllToBackupFolder Returns Boolean
93322>>>>>//        Boolean bOK bExists
93322>>>>>//        String sDataPath sBackupFolder
93322>>>>>//        
93322>>>>>//        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
93322>>>>>//        Move CS_DUFBackupDataFolder to sBackupFolder
93322>>>>>//        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
93322>>>>>//        Get vFolderFormat sDataPath to sDataPath
93322>>>>>//        
93322>>>>>//        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
93322>>>>>//        If (bExists = False) Begin
93322>>>>>//            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
93322>>>>>//            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
93322>>>>>//            If (bExists = False) Begin
93322>>>>>//                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
93322>>>>>//                Function_Return False
93322>>>>>//            End                                                                                                                                            
93322>>>>>//            Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
93322>>>>>//            Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
93322>>>>>//            Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
93322>>>>>//            Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
93322>>>>>//        End
93322>>>>>//        
93322>>>>>//        Set Message_Text of ghoStatusPanel to ""
93322>>>>>//        Function_Return bOK
93322>>>>>//    End_Function
93322>>>>>//
93322>>>>>    // This is automatically called after the OnUpdate
93322>>>>>    // event has been executed. It will automatically update the
93322>>>>>    // version database field/column with the "pnVersionNumber"
93322>>>>>    // value of the parent cDbUpdateHandler class - if it has been changed.
93322>>>>>    Procedure UpdateVersionColumnValue
93324>>>>>        Number nVersion nCurrentValue
93324>>>>>        Integer hTable iColumn
93324>>>>>        Boolean bVersionUpdate bDbUpdateErrorHasOccured bUseCustomDbVersion
93324>>>>>
93324>>>>>        Move False to Err
93325>>>>>        Move 0 to LastErr
93326>>>>>        // This is a property of the container class; cDbUpdateHandler that gets set when
93326>>>>>        // an error occurres when processing ESQL or database API messages of the cDbUpdateFunctionLibrary.
93326>>>>>        Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
93328>>>>>        Get pbVersionUpdate to bVersionUpdate
93329>>>>>
93329>>>>>        If (bVersionUpdate = True and bDbUpdateErrorHasOccured = False) Begin
93331>>>>>            Get pnVersionNumber to nVersion
93332>>>>>            Delegate Get piDbVersionFileNumber  to hTable
93334>>>>>            Delegate Get piDbVersionFieldNumber to iColumn
93336>>>>>            // NB! We need to permanently close tables as they e.g. now might no longer be embedded
93336>>>>>            // but instead SQL tables. If we don't the "old" embedded table will be opened instead.
93336>>>>>            Close DF_ALL DF_PERMANENT
93337>>>>>
93337>>>>>            Open hTable
93339>>>>>
93339>>>>>            // It is then the developer responsibility to take care of finding
93339>>>>>            // the correct record that is to be updated (The DbVersion table is not used). 
93339>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
93341>>>>>            If (bUseCustomDbVersion = True) Begin
93343>>>>>                Delegate Send OnFindVersionRecord   // cDbUpdateHandler object event (Programmer's hook!).
93345>>>>>            End
93345>>>>>>
93345>>>>>
93345>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
93348>>>>>            If (nCurrentValue < nVersion) Begin
93350>>>>>                Lock
93351>>>>>>
93351>>>>>                    If (bUseCustomDbVersion = False) Begin
93353>>>>>                        Vfind hTable Recnum GE                            
93355>>>>>                    End
93355>>>>>>
93355>>>>>                    Set_Field_Value hTable iColumn to nVersion
93358>>>>>                    SaveRecord hTable
93359>>>>>                Unlock
93360>>>>>>
93360>>>>>            End
93360>>>>>>
93360>>>>>            Close hTable
93361>>>>>        End
93361>>>>>>
93361>>>>>    End_Procedure
93362>>>>>
93362>>>>>// Property of the container object (cDbUpdateHandler)
93362>>>>>Register_Function piCurrentErrorHandlerID Returns Integer
93362>>>>>
93362>>>>>    Procedure End_Construct_Object
93364>>>>>        Forward Send End_Construct_Object
93366>>>>>        Send ProcessUpdate True
93367>>>>>    End_Procedure
93368>>>>>    
93368>>>>>    Procedure ProcessUpdate Boolean bShouldTestForDuplicateVersionNumbers
93370>>>>>        Number nVersion nCurrentValue
93370>>>>>        Integer hTable iColumn iSize iDbVersionFileNumber iStatus iErrorObject
93370>>>>>        Boolean bStopOnFirstError bDbUpdateErrorHasOccured bContinueOnError bOpened 
93370>>>>>        Boolean bSystemTable bUseCustomDbVersion bTableExists bOnPreUpdateExecuted bExitIfDebuggerActive
93370>>>>>        String sObjectName
93370>>>>>        tDbVersionInfo[] dbVersionInfoArray
93370>>>>>        tDbVersionInfo[] dbVersionInfoArray
93371>>>>>
93371>>>>>        Move 0 to nCurrentValue
93372>>>>>        Delegate Set Private.pbUpdateVersionObjectError to False
93374>>>>>
93374>>>>>        Delegate Get pbExitIfDebuggerActive to bExitIfDebuggerActive
93376>>>>>        If (IsDebuggerPresent() and bExitIfDebuggerActive = True) Begin
93378>>>>>            Delegate Get piOrgErrorHandlerID to iErrorObject
93380>>>>>            If (iErrorObject <> 0) Begin
93382>>>>>                Move iErrorObject to Error_Object_Id
93383>>>>>            End
93383>>>>>>
93383>>>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio! You need to run this program from outside of the Studio."
93384>>>>>>
93384>>>>>            Send Exit_Application
93385>>>>>        End
93385>>>>>>
93385>>>>>        // If the programmer forgot to set the version number we do not allow for the application
93385>>>>>        // to continue to run, as this potentially could endanger the integrity of the database. E.g. if
93385>>>>>        // one database update is depended on an earlier update and that earlier version
93385>>>>>        // update was never executed it could lead to disastrous results.
93385>>>>>        // This is a programmer error and should be discovered before any customer sees it. Thus no point in translating...
93385>>>>>        Get pnVersionNumber to nVersion
93386>>>>>        If (nVersion < 0) Begin
93388>>>>>            Get piCurrentErrorHandlerID to Error_Object_Id
93389>>>>>            Move (Name(Self)) to sObjectName
93390>>>>>            Error DFERR_PROGRAM ("The pnVersionNumber property was not set properly by the programmer for the following object; Program will now exit!\n\n" + sObjectName)
93391>>>>>>
93391>>>>>            Send Exit_Application
93392>>>>>        End
93392>>>>>>
93392>>>>>
93392>>>>>        // These are send to the parent container object (cDbUpdateHandler). The order is very sensitive!
93392>>>>>        // Hook event for the developer to e.g. create a database before the update events starts.
93392>>>>>        Delegate Get Private.pbOnPreUpdateExecuted to bOnPreUpdateExecuted
93394>>>>>        If (bOnPreUpdateExecuted = False) Begin
93396>>>>>            Delegate Send OnPreUpdate
93398>>>>>            Delegate Set Private.pbOnPreUpdateExecuted to True
93400>>>>>        End
93400>>>>>>
93400>>>>>        
93400>>>>>        Delegate Get piDbVersionFileNumber to iDbVersionFileNumber
93402>>>>>        
93402>>>>>        Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
93404>>>>>        If (bUseCustomDbVersion = False) Begin
93406>>>>>//            Delegate Send CheckAutoCreateDbVersionTable // cDbUpdateHandler object event.
93406>>>>>        End
93406>>>>>>
93406>>>>>        Else Begin
93407>>>>>            Get _UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
93408>>>>>            If (bTableExists = False) Begin
93410>>>>>                Delegate Send OnCreateCustomDbVersionTable
93412>>>>>            End
93412>>>>>>
93412>>>>>        End
93412>>>>>>
93412>>>>>        
93412>>>>>        // We now check that two or more cDbVersion objects does not have the same pnVersionNumber.
93412>>>>>        // Note that the paDbVersionInfoArray is a property of the container object (cDbUpdateHandler)
93412>>>>>        If (bShouldTestForDuplicateVersionNumbers = True) Begin
93414>>>>>            Delegate Get paDbVersionInfoArray to dbVersionInfoArray
93416>>>>>            Move (SizeOfArray(dbVersionInfoArray)) to iSize
93417>>>>>            Move nVersion to dbVersionInfoArray[iSize].nVersionNumber
93418>>>>>            Move (Self)   to dbVersionInfoArray[iSize].hObject
93419>>>>>            Delegate Set paDbVersionInfoArray to dbVersionInfoArray
93421>>>>>            Delegate Send CheckForDuplicates nVersion   // cDbUpdateHandler object event.
93423>>>>>        End
93423>>>>>>
93423>>>>>
93423>>>>>        Delegate Get piDbVersionFileNumber  to hTable
93425>>>>>        Delegate Get piDbVersionFieldNumber to iColumn
93427>>>>>
93427>>>>>        Open hTable
93429>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
93432>>>>>        If (bOpened = False) Begin
93434>>>>>            Send Stop_Box CS_DUF_DbUpdateTableMissing
93435>>>>>            Send Exit_Application
93436>>>>>        End
93436>>>>>>
93436>>>>>        
93436>>>>>        // It can happen that the table isn't initialized with a record even though it is a system table,
93436>>>>>        // in case we take care of it here.
93436>>>>>        Get_Attribute DF_FILE_STATUS of hTable to iStatus
93439>>>>>        If (iStatus = DF_FILE_INACTIVE) Begin
93441>>>>>            Vfind hTable 0 GT
93443>>>>>        End
93443>>>>>>
93443>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemTable
93446>>>>>        If (bSystemTable = True) Begin
93448>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
93451>>>>>        End
93451>>>>>>
93451>>>>>        Else Begin
93452>>>>>            If (bUseCustomDbVersion = True) Begin
93454>>>>>                Send OnFindVersionRecord
93455>>>>>                Get_Field_Value hTable iColumn to nCurrentValue
93458>>>>>            End
93458>>>>>>
93458>>>>>        End
93458>>>>>>
93458>>>>>
93458>>>>>        Close hTable
93459>>>>>
93459>>>>>        // We also guard from missing 'DatabaseVersionInfoTable' and column properties settings.
93459>>>>>        // If not set we do nothing.
93459>>>>>        If (nCurrentValue < nVersion) Begin
93461>>>>>
93461>>>>>            // If pbStopOnFirstError is True in the parent, the idea is that we do _no_ further
93461>>>>>            // execution of database update code. So if true _and_ one error
93461>>>>>            // has already occured; we're out of here.
93461>>>>>            Delegate Get pbStopOnFirstError        to bStopOnFirstError
93463>>>>>            Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
93465>>>>>            If (bStopOnFirstError = True) Begin
93467>>>>>                If (bDbUpdateErrorHasOccured = True) Begin
93469>>>>>                    Procedure_Return
93470>>>>>                End
93470>>>>>>
93470>>>>>            End
93470>>>>>>
93470>>>>>
93470>>>>>            // This is send to the parent container object (cDbUpdateHandler)
93470>>>>>            Delegate Send InitDatabaseUpdate (Self)    // cDbUpdateHandler object event.
93472>>>>>
93472>>>>>            // If the parent property pbContinueOnError = False, an update
93472>>>>>            // of a following cDbUpdateVersion object should not take place and we're out of here.
93472>>>>>            Delegate Get pbContinueOnError to bContinueOnError
93474>>>>>            If (bContinueOnError = False and bDbUpdateErrorHasOccured = True) Begin
93476>>>>>                Procedure_Return
93477>>>>>            End
93477>>>>>>
93477>>>>>
93477>>>>>            Delegate Set pnCurrentVersionUpdate to nVersion
93479>>>>>
93479>>>>>            Set Title_Text of ghoStatusPanel to (CS_DUF_UpdateVersion * CS_DUF_UpdateFromVersion * String(nCurrentValue) * CS_DUF_UpdateToVersion * String(nVersion))
93480>>>>>
93480>>>>>            // *** Programmer's main hook event for database update functions:
93480>>>>>            Send OnUpdate
93481>>>>>
93481>>>>>            Set pbVersionUpdate to True
93482>>>>>            Send UpdateVersionColumnValue
93483>>>>>            Delegate Set pbDatabaseWasUpdated to True   // cDbUpdateHandler property.
93485>>>>>        End
93485>>>>>>
93485>>>>>
93485>>>>>    End_Procedure
93486>>>>>
93486>>>>>End_Class
93487>>>Use cDbUpdateUserCount.pkg
Including file: cDbUpdateUserCount.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.pkg)
93487>>>>>//****************************************************************************
93487>>>>>// $Module type: Class
93487>>>>>// $Module name: cDbUpdateUserCount.pkg
93487>>>>>// $Author     : Emil Stojanov Quantaris B.V.
93487>>>>>//
93487>>>>>//               Collected from DAW's newsgroups.
93487>>>>>//
93487>>>>>// Description : It uses the windows API to lock bytes in a file.
93487>>>>>//               If the application or PC craches it will release the lock
93487>>>>>//               automatically.
93487>>>>>//
93487>>>>>// Note 1      : It will count the number of running app's, so if a
93487>>>>>//               user starts the app twice on one machine it will count as two users.
93487>>>>>// Note 2      : The class was originally named cUserCount by Emil Stojanov.
93487>>>>>//               However, to not conflict with any other usage of this class it was
93487>>>>>//               renamed to "fit" into the "Database Update Framework" (cDbUpdateHandler
93487>>>>>//               and cDbUpdateVersion classes)
93487>>>>>//
93487>>>>>// $Rev History:
93487>>>>>//    2008-10-17  Module header created (Militaty data format)
93487>>>>>//    2008-10-17  Minor changes by Nils G Svedmyr. Created UI text constants
93487>>>>>//                for easy translation to other languages.
93487>>>>>//                Added the tUserCount struct for easier passing of parameters.
93487>>>>>//                Added the ApplicationPath message.
93487>>>>>//****************************************************************************
93487>>>>>Use LanguageText.pkg
93487>>>>>Use cDbUpdateUserCount.inc
Including file: cDbUpdateUserCount.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.inc)
93487>>>>>>>Use GlobalFunctionsProcedures.pkg
93487>>>>>>>// Sample:
93487>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
93487>>>>>>>
93487>>>>>>>
93487>>>>>>>// Symbols used by UserCounting
93487>>>>>>>    Define GENERIC_READ         for |CI$80000000
93487>>>>>>>    Define GENERIC_WRITE        for |CI$40000000
93487>>>>>>>    Define GENERIC_EXECUTE      for |CI$20000000
93487>>>>>>>    Define GENERIC_ALL          for |CI$10000000
93487>>>>>>>    Define CREATE_NEW           for 1
93487>>>>>>>    Define CREATE_ALWAYS        for 2
93487>>>>>>>    Define OPEN_EXISTING        for 3
93487>>>>>>>    Define OPEN_ALWAYS          for 4
93487>>>>>>>    Define TRUNCATE_EXISTING    for 5
93487>>>>>>>    Define FILE_BEGIN           for 0
93487>>>>>>>    Define FILE_CURRENT         for 1
93487>>>>>>>    Define FILE_END             for 2
93487>>>>>>>    Define FILE_SHARE_READ      for |CI$00000001
93487>>>>>>>    Define FILE_SHARE_WRITE     for |CI$00000002
93487>>>>>>>    Define FILE_SHARE_DELETE    for |CI$00000004
93487>>>>>>>    Define FILE_FLAG_WRITE_THROUGH            for |CI$80000000
93487>>>>>>>    Define _MAX_PATH  for 260
93487>>>>>>>    Define _MAX_DRIVE for 3
93487>>>>>>>    Define _MAX_DIR   for 256
93487>>>>>>>    Define _MAX_FNAME for 256
93487>>>>>>>    Define _MAX_EXT   for 256
93487>>>>>>>
93487>>>>>>>External_Function Win32_CreateFile "CreateFileA" KERNEL32.DLL ;    Pointer lpFileName ;              // file name    DWord dwDesiredAccess ;           // access mode    DWord dwShareMode ;               // share mode    Pointer lpSecurityAttributes ;    // SD    DWord dwCreationDisposition ;     // how to create    DWord dwFlagsAndAttributes ;      // file attributes    Handle hTemplateFile ;            // handle to template file    Returns Handle
93488>>>>>>>
93488>>>>>>>External_Function Win32_ReadFile "ReadFile" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Pointer lpBuffer ;              // pointer to the buffer that receives the data    dWord nNumberOfBytesToRead ;    // number of bytes to read    Pointer lpNumberOfBytesRead ;   // number of bytes read    Pointer lpOverlapped ;          // pointer to an overlapped structure    Returns Integer
93489>>>>>>>
93489>>>>>>>External_Function Win32_WriteFile "WriteFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    Pointer lpBuffer ;                  // pointer to buffer containing data to write    dWord nNumberOfBytesToWrite ;       // number of bytes to write    Pointer lpNumberOfBytesWritten ;    // number of bytes written    Pointer lpOverlapped ;              // pointer to an overlapped structure    Returns Integer
93490>>>>>>>
93490>>>>>>>External_Function Win32_LockFile "LockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToLockLow ;     // low-order word of length    dWord nNumberOfBytesToLockHigh ;    // high-order word of length    Returns Integer
93491>>>>>>>
93491>>>>>>>External_Function Win32_UnlockFile "UnlockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToUnLockLow ;   // low-order word of length    dWord nNumberOfBytesToUnLockHigh ;  // high-order word of length    Returns Integer
93492>>>>>>>
93492>>>>>>>External_Function Win32_SetFilePointer "SetFilePointer" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Integer lDistanceToMove ;       // bytes to move pointer (low-order 32-bits)    Pointer lpDistanceToMoveHigh ;  // bytes to move pointer (high-order 32-bits)    dWord dwMoveMethod ;            // starting point    Returns dWord
93493>>>>>>>
93493>>>>>>>External_Function Win32_CloseHandle "CloseHandle" KERNEL32.DLL ;    Handle hObject ;    // handle to object    Returns Integer
93494>>>>>>>
93494>>>>>>>External_Function SetDefaultPrinterEf "SetDefaultPrinterA" winspool.drv Pointer lpPrinter Returns Boolean
93495>>>>>>>// Sample:
93495>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
93495>>>>>>>Function DoSetDefaultPrinter String sPrinter Returns Boolean
93497>>>>>>>    Boolean bReturn
93497>>>>>>>    Move (Utf8ToAnsi(sPrinter)) to sPrinter
93498>>>>>>>    Move (sPrinter + (Character(0))) to sPrinter
93499>>>>>>>    Move (SetDefaultPrinterEf(AddressOf(sPrinter))) to bReturn
93500>>>>>>>    Function_Return bReturn
93501>>>>>>>End_Function
93502>>>>>Use vWin32fh.pkg
93502>>>>>Use seq_chnl.pkg
93502>>>>>
93502>>>>>// User interface constant strings:
93502>>>>>    Define CS_UserCountError            for "User count error:"
93502>>>>>    Define CS_UnableToInitUserCountSys  for "Unable to initialize user counting system!"
93502>>>>>    Define CS_UnableResetUserCountSys   for "Error resetting usercounting system!"
93502>>>>>    Define CS_ErrorAdvancingPointer     for "Error advancing file pointer!"
93502>>>>>    Define CS_MaxNoOfUserExceeded       for "Maximum number of users exceeded!"
93502>>>>>
93502>>>>>
93502>>>>>
93502>>>>>
93502>>>>>
93502>>>>>
93502>>>>>
93502>>>>>
93502>>>>>
93502>>>>>
93502>>>>>
93502>>>>>
93502>>>>>
93502>>>>>    Struct tUserCount
93502>>>>>        Integer iUserCount
93502>>>>>        Integer iError
93502>>>>>        String  sErrorTxt
93502>>>>>    End_Struct
93502>>>>>
93502>>>>>    Define CI_UserCountMaxUsers for 9999
93502>>>>>
93502>>>>>Class cDbUpdateUserCount is a cObject
93503>>>>>    Procedure Construct_Object
93505>>>>>        Forward Send Construct_Object
93507>>>>>
93507>>>>>        Property String  psLockFileName
93508>>>>>        Property Integer piMaxUsers
93509>>>>>        Property Boolean pbCheckDataFlexUserCount True
93510>>>>>
93510>>>>>        Property Handle  phUserCountFile
93511>>>>>        Property Integer pdwLockPosition
93512>>>>>    End_Procedure
93513>>>>>
93513>>>>>    Function IsProgramRunning Returns Boolean
93515>>>>>        tUserCount UserCount
93515>>>>>        tUserCount UserCount
93515>>>>>
93515>>>>>        Get CheckUserCount to UserCount
93516>>>>>
93516>>>>>        Function_Return (UserCount.iUserCount > 1)
93517>>>>>    End_Function
93518>>>>>
93518>>>>>    // Returns the full path of the Application (no trailing "\")
93518>>>>>    Function ApplicationPath Returns String
93520>>>>>        String sApplicationFileName sPath
93520>>>>>        Integer iNumChars iRetval
93520>>>>>
93520>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
93521>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
93522>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
93523>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
93524>>>>>        Move (CString(sApplicationFileName)) to sPath
93525>>>>>
93525>>>>>        Function_Return sPath
93526>>>>>    End_Function
93527>>>>>
93527>>>>>    Function OpenUserCountFile String sFileName Returns Handle
93529>>>>>        Handle  hFile
93529>>>>>        Pointer pFileName
93529>>>>>        String sPath sFile
93529>>>>>        Integer iCh
93529>>>>>
93529>>>>>        Move (Addressof(sFileName)) to pFileName
93530>>>>>        Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
93531>>>>>
93531>>>>>        // If lock file doesn't exist, create it.
93531>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
93533>>>>>            Get ApplicationPath to sPath
93534>>>>>            Get vFolderFormat sPath to sPath
93535>>>>>            Move (sPath + psLockFileName(Self)) to sFile
93536>>>>>            Get Seq_Open_Output_Channel sFile to iCh
93537>>>>>            If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
93539>>>>>                Function_Return 0
93540>>>>>            End
93540>>>>>>
93540>>>>>            Direct_Output channel iCh sFile
93542>>>>>                Write channel iCh ""
93544>>>>>            Send Seq_Close_Channel iCh
93545>>>>>            Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
93546>>>>>        End
93546>>>>>>
93546>>>>>
93546>>>>>        Function_Return hFile
93547>>>>>    End_Function
93548>>>>>
93548>>>>>    Function CloseUserCountFile Handle hFile Returns Integer
93550>>>>>        Integer iReturnValue 
93550>>>>>        Boolean bOK
93550>>>>>
93550>>>>>        Move (Win32_CloseHandle(hFile)) to iReturnValue
93551>>>>>        If (iReturnValue = 0) Begin
93553>>>>>            Move False to bOK
93554>>>>>        End
93554>>>>>>
93554>>>>>        Else Begin
93555>>>>>            Move True to bOK
93556>>>>>        End
93556>>>>>>
93556>>>>>        Function_Return bOK
93557>>>>>    End_Function
93558>>>>>
93558>>>>>    Function UnlockUserCountFile Handle hFile dWord dwLockPos Returns Integer
93560>>>>>        Integer iReturnValue
93560>>>>>        Boolean bOK
93560>>>>>
93560>>>>>        Move (Win32_UnLockFile(hFile, dwLockPos, 0, 1, 0)) to iReturnValue
93561>>>>>        If (iReturnValue = 0) Begin
93563>>>>>            Move False to bOK
93564>>>>>        End
93564>>>>>>
93564>>>>>        Else Begin
93565>>>>>            Move True to bOK
93566>>>>>        End           
93566>>>>>>
93566>>>>>        Function_Return bOK
93567>>>>>    End_Function
93568>>>>>
93568>>>>>    Function ReSetUserCountPointer Handle hFile Returns dWord
93570>>>>>        dWord dwCurrPos
93570>>>>>
93570>>>>>        Move (Win32_SetFilePointer(hFile, 0, 0, FILE_BEGIN)) to dwCurrPos
93571>>>>>        Function_Return dwCurrPos
93572>>>>>    End_Function
93573>>>>>
93573>>>>>    Function SetUserCountPointer Handle hFile Integer iAdvance Returns dWord
93575>>>>>        DWord dwCurrPos
93575>>>>>
93575>>>>>        Move (Win32_SetFilePointer(hFile, iAdvance, 0, FILE_CURRENT)) to dwCurrPos
93576>>>>>        Function_Return dwCurrPos
93577>>>>>    End_Function
93578>>>>>
93578>>>>>    Function ReadUserCountFile Handle hFile Returns Boolean
93580>>>>>        Integer iReturnValue                               
93580>>>>>        Boolean bOK
93580>>>>>        String  sBuffer
93580>>>>>        Pointer pBuffer
93580>>>>>        String  sSize
93580>>>>>        Pointer pSize
93580>>>>>
93580>>>>>        Move (Repeat((Character(0)),5)) to sBuffer
93581>>>>>        Move (AddressOf(sBuffer)) to pBuffer
93582>>>>>
93582>>>>>        Move (Repeat((Character(0)),4)) to sSize
93583>>>>>        Move (AddressOf(sSize)) to pSize
93584>>>>>
93584>>>>>        Move (Win32_ReadFile(hFile, pBuffer, 1, pSize, 0)) to iReturnValue
93585>>>>>        If (iReturnValue = 0) Begin
93587>>>>>            Move False to bOK
93588>>>>>        End
93588>>>>>>
93588>>>>>        Else Begin
93589>>>>>            Move True to bOK
93590>>>>>        End                 
93590>>>>>>
93590>>>>>        Function_Return bOK
93591>>>>>    End_Function
93592>>>>>
93592>>>>>    Function LockUserCountFile Handle hFile dWord dwFilePos Returns Integer
93594>>>>>        Integer iReturnValue
93594>>>>>
93594>>>>>        Move (Win32_LockFile(hFile, dwFilePos, 0, 1, 0)) to iReturnValue
93595>>>>>        Function_Return iReturnValue
93596>>>>>    End_Function
93597>>>>>
93597>>>>>    Procedure DoCheckUserCount
93599>>>>>        tUserCount UserCount
93599>>>>>        tUserCount UserCount
93599>>>>>
93599>>>>>        Get CheckUserCount to UserCount
93600>>>>>        // If all is fine, we're done.
93600>>>>>        If (UserCount.iError = 0) Begin
93602>>>>>            Procedure_Return
93603>>>>>        End
93603>>>>>>
93603>>>>>
93603>>>>>        Send UserError (CS_UserCountError * String(UserCount.iError) + "\n" + UserCount.sErrorTxt)
93604>>>>>
93604>>>>>        If (UserCount.iUserCount = CI_UserCountMaxUsers) Begin
93606>>>>>            Abort
93607>>>>>>
93607>>>>>        End
93607>>>>>>
93607>>>>>    End_Procedure
93608>>>>>
93608>>>>>    Function CheckUserCount Returns tUserCount
93610>>>>>        Handle  hFile
93610>>>>>        String  sPath sFile
93610>>>>>        Integer iResult
93610>>>>>        DWord   dwFilePos
93610>>>>>        Integer bLocked
93610>>>>>        Integer iMaxUsers
93610>>>>>        Integer iCurUser
93610>>>>>        tUserCount UserCount
93610>>>>>        tUserCount UserCount
93610>>>>>
93610>>>>>        Move 0 to UserCount.iError
93611>>>>>
93611>>>>>        Get phUserCountFile to hFile
93612>>>>>        If (not(hFile)) Begin
93614>>>>>            Get ApplicationPath to sPath
93615>>>>>            Get vFolderFormat sPath to sPath
93616>>>>>            Move (sPath + psLockFileName(Self)) to sFile
93617>>>>>            Get OpenUserCountFile sFile to hFile
93618>>>>>            If (hFile = INVALID_HANDLE_VALUE) Begin
93620>>>>>                Move 1 to UserCount.iUserCount
93621>>>>>                Move 1 to UserCount.iError
93622>>>>>                Move CS_UnableToInitUserCountSys to UserCount.sErrorTxt
93623>>>>>                Function_Return UserCount
93624>>>>>            End
93624>>>>>>
93624>>>>>            Else Begin
93625>>>>>                Move False to bLocked
93626>>>>>                Set phUserCountFile to hFile
93627>>>>>                Get piMaxUsers to iMaxUsers
93628>>>>>
93628>>>>>                // Set Filepointer to beginning of the file
93628>>>>>                Get ResetUserCountPointer hFile to dwFilePos
93629>>>>>                If (dwFilePos = -1) Begin
93631>>>>>                    Move 1 to UserCount.iUserCount
93632>>>>>                    Move 2 to UserCount.iError
93633>>>>>                    Move CS_UnableResetUserCountSys to UserCount.sErrorTxt
93634>>>>>                    Function_Return UserCount
93635>>>>>                End
93635>>>>>>
93635>>>>>                For iCurUser from 1 to iMaxUsers
93641>>>>>>
93641>>>>>                    Get LockUserCountFile hFile dwFilePos to iResult
93642>>>>>                    If (not(iResult)) Begin  // byte is locked
93644>>>>>                        Get SetUserCountPointer hFile 10 to dwFilePos
93645>>>>>                        If (dwFilePos = -1) Begin
93647>>>>>                            Move 1 to UserCount.iUserCount
93648>>>>>                            Move 3 to UserCount.iError
93649>>>>>                            Move CS_ErrorAdvancingPointer to UserCount.sErrorTxt
93650>>>>>                            Function_Return UserCount
93651>>>>>                        End
93651>>>>>>
93651>>>>>                    End
93651>>>>>>
93651>>>>>                    Else Begin  // byte is not locked
93652>>>>>                        Set pdwLockPosition to dwFilePos
93653>>>>>                        Move True to bLocked
93654>>>>>                        Move iMaxUsers to iCurUser
93655>>>>>                    End
93655>>>>>>
93655>>>>>                Loop
93656>>>>>>
93656>>>>>                If (not(bLocked)) Begin
93658>>>>>                    Move CI_UserCountMaxUsers to UserCount.iUserCount
93659>>>>>                    Move 4 to UserCount.iError
93660>>>>>                    Move CS_MaxNoOfUserExceeded to UserCount.sErrorTxt
93661>>>>>                    Function_Return UserCount
93662>>>>>                End
93662>>>>>>
93662>>>>>            End
93662>>>>>>
93662>>>>>        End
93662>>>>>>
93662>>>>>
93662>>>>>        Function_Return UserCount
93663>>>>>    End_Function
93664>>>>>
93664>>>>>
93664>>>>>    Procedure DoReleaseUserCount
93666>>>>>        Integer iResult
93666>>>>>        Handle  hFile
93666>>>>>        DWord   dwLockPos
93666>>>>>
93666>>>>>        Get phUserCountFile to hFile
93667>>>>>        Get pdwLockPosition to dwLockPos
93668>>>>>        If (hFile) Begin
93670>>>>>            If (dwLockPos) Begin
93672>>>>>                Get UnlockUserCountFile hFile dwLockPos to iResult
93673>>>>>            End
93673>>>>>>
93673>>>>>            Get CloseUserCountFile hFile to iResult
93674>>>>>        End
93674>>>>>>
93674>>>>>    End_Procedure
93675>>>>>
93675>>>>>    Function CurrentNumberOfUsers Returns Integer
93677>>>>>        Handle  hFile
93677>>>>>        Integer iMaxUsers
93677>>>>>        DWord   dwFilePos
93677>>>>>        Integer iCurUser
93677>>>>>        Integer iResult
93677>>>>>        Integer iNumberOfLocks
93677>>>>>        String  sPath sFile
93677>>>>>
93677>>>>>        Move 0 to iNumberOfLocks
93678>>>>>
93678>>>>>        Get ApplicationPath to sPath
93679>>>>>        Get vFolderFormat sPath to sPath
93680>>>>>        Move (sPath + psLockFileName(Self)) to sFile
93681>>>>>        Get OpenUserCountFile sFile to hFile
93682>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
93684>>>>>            Send UserError CS_UnableToInitUserCountSys
93685>>>>>            Abort
93686>>>>>>
93686>>>>>        End
93686>>>>>>
93686>>>>>
93686>>>>>        If (hFile > 0) Begin
93688>>>>>            Get piMaxUsers To iMaxUsers
93689>>>>>
93689>>>>>            // Set Filepointer to beginning of the file
93689>>>>>            Get ResetUserCountPointer hFile to dwFilePos
93690>>>>>            If (dwFilePos = -1) Begin
93692>>>>>                Send UserError CS_UnableResetUserCountSys
93693>>>>>                Abort
93694>>>>>>
93694>>>>>            End
93694>>>>>>
93694>>>>>            For iCurUser from 1 to iMaxUsers
93700>>>>>>
93700>>>>>                Get LockUserCountFile hFile dwFilePos to iResult
93701>>>>>                If (Not(iResult)) Begin  // byte is locked
93703>>>>>                    Increment iNumberOfLocks
93704>>>>>                End
93704>>>>>>
93704>>>>>                Else Begin  // byte is not locked
93705>>>>>                    Get UnlockUserCountFile hFile dwFilePos to iResult
93706>>>>>                End
93706>>>>>>
93706>>>>>                Get SetUserCountPointer hFile 10 to dwFilePos
93707>>>>>                If (dwFilePos = -1) Begin
93709>>>>>                    Send UserError CS_ErrorAdvancingPointer
93710>>>>>                    Abort
93711>>>>>>
93711>>>>>                End
93711>>>>>>
93711>>>>>            Loop
93712>>>>>>
93712>>>>>        End
93712>>>>>>
93712>>>>>        Get CloseUserCountFile hFile to iResult
93713>>>>>        Function_Return iNumberOfLocks
93714>>>>>    End_Function
93715>>>>>
93715>>>>>End_Class
93716>>>Use cDbUpdateFunctionLibrary.pkg
93716>>>
93716>>>//{ DataBindable=True }
93716>>>Class cDbUpdateHandler is a cDbUpdateFunctionLibrary
93717>>>
93717>>>    Procedure Construct_Object
93719>>>        tUserCount UserCount
93719>>>        tUserCount UserCount
93719>>>        Integer iUserCount
93719>>>        Handle ho                     
93719>>>
93719>>>        Forward Send Construct_Object
93721>>>        Move Self to ghoDbUpdateHandler  
93722>>>        
93722>>>        // Latin1_General_CI_AS = General Insensitive collation
93722>>>        // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.   
93722>>>        // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
93722>>>        // Good read about which collation to select:
93722>>>        // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
93722>>>        Property String psCollation "Latin1_General_CS_AS" //"SQL_Latin1_General_Cp1_CS_AS"
93723>>>
93723>>>        // Struct array that will contain pnVersionNumbers & object id's of
93723>>>        // all child cDbVersion objects.
93723>>>        Property tDbVersionInfo[] paDbVersionInfoArray
93724>>>
93724>>>        Property Integer Error_Processing_State False  // internal usage
93725>>>        
93725>>>        Property Boolean Private.pbDbVersionCheckDone False
93726>>>
93726>>>        Property Boolean pbUseCustomDbVersion False  
93727>>>        
93727>>>        // If this property = True _and_ no DbVersion table exists 
93727>>>        // when the framework is started, a DbVersion table will be created automatically.
93727>>>        Property Boolean pbAutoCreateDbVersionTable True
93728>>>
93728>>>        // Connected to the pbAutoCreateDbVersionTable property. If it is true,
93728>>>        // the Filelist.cfg slot number indicated by this property will be used
93728>>>        // if a DbVersion table is to be created. If this value = -1 at runtime
93728>>>        // an Unhandled Exception Error will be genereted and the program halted. So
93728>>>        // this property _must_ be set in the cDbUpdateHandler object if pbAutoCreateDbVersionTable = True,
93728>>>        // to a value that corresponds to a free Filelist.cfg slot number.
93728>>>        Property Integer Private.piDbVersionFileNumber -1
93729>>>        Property Integer Private.piDbVersionFieldNumber 1
93730>>>
93730>>>        // This is a message of the cDbUpdateFunctionLibrary_Mixin class
93730>>>        // that creates all library properties
93730>>>        Send CreateDbUpdateLibraryProperties
93731>>>
93731>>>        Property tDbUpdateHandlerMasterAlias[] paDbUpdateHandlerMasterAlias
93732>>>
93732>>>        // Error handling:
93732>>>        Property Boolean Private.pbOnCreateExecuted False
93733>>>        Property Boolean Private.pbOnPreUpdateExecuted False
93734>>>        Property Boolean Private.pbProcessingError False
93735>>>        Property Boolean pbDbUpdateErrorHasOccured False
93736>>>        // Don't touch. It is being used by the cDbUpdateVersion
93736>>>        // subclass to tell if that particular update was a success or not.
93736>>>        Property Boolean Private.pbUpdateVersionObjectError False
93737>>>        Property String[] paSQLQueryMessages
93738>>>        
93738>>>        Property Boolean pbExitIfDebuggerActive True
93739>>>        Property Integer piOrgErrorHandlerID Error_Object_Id
93740>>>        Move Self to Error_Object_Id
93741>>>        // Error handling:
93741>>>        // Temporarily redirect all errors to this object so we can silently
93741>>>        // log all errors that might appear while updating the database.
93741>>>        // We temporarily redirect all errors to this object so we can
93741>>>        // log and write errors to the log file. It will be reset after
93741>>>        // the database updates have been finished.
93741>>>        Property Integer piCurrentErrorHandlerID Error_Object_Id
93742>>>
93742>>>        Property Handle phoLogFile (Create(Self,RefClass(cDbUpdateLogFile)))
93743>>>
93743>>>        // Error Reporting Related
93743>>>        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
93743>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
93744>>>
93744>>>        // If the pbContinueOnError = False, an update
93744>>>        // of another cDbUpdateVersion object will _not_ be
93744>>>        // performed if an error occured in a previous
93744>>>        // cDbUpdateVersion object.
93744>>>        Property Boolean pbContinueOnError False
93745>>>        // Stops execution in other cDbUpdateVersion objecs,
93745>>>        // if errors occurred in one cDbUpdateVersion object.
93745>>>        Property Boolean pbStopOnFirstError False
93746>>>        // If True errors that occured while updating the database
93746>>>        // will be shown in the default app for .txt files when done.
93746>>>        // Note: The log file will _always_ be created in the Data folder.
93746>>>        Property Boolean pbShowErrorLogPostRun True
93747>>>
93747>>>        // Be _very_ careful to set this property to true!
93747>>>        // If = True, no question will be asked if the update
93747>>>        // should begin. Also, even if the pbShowErrorLogPostRun=True,
93747>>>        // the error log won't be shown. The logfile itself will still be created though.
93747>>>        // You have to know what you're doing!
93747>>>        Property Boolean pbSilentMode False
93748>>>        
93748>>>        Property Boolean pbEnableCancelButton False
93749>>>
93749>>>        // Don't touch! Very private. The value is used by the error log to write for which
93749>>>        // cDbUpdateVersion object an error occured.
93749>>>        Property Number pnCurrentVersionUpdate 0
93750>>>
93750>>>        // The user counting logic is used to safe-guard agains anybody else is
93750>>>        // using the application when a database update is to be performed.
93750>>>        // (Garters & suspenders!)
93750>>>        Property Handle phoUserCountSystem (Create(Self,RefClass(cDbUpdateUserCount)))
93751>>>        Set psLockFileName of (phoUserCountSystem(Self)) to "DbUpdateUserCount.ucf"
93752>>>        Set piMaxUsers     of (phoUserCountSystem(Self)) to (CI_UserCountMaxUsers -1) // Large number!
93753>>>
93753>>>        // This lock file is used to guard against somebody else tries to start the
93753>>>        // application while updates are in progress.
93753>>>        Property Handle phoDatabaseUpdateLock (Create(Self,RefClass(cDbUpdateUserCount)))
93754>>>        Set psLockFileName of (phoDatabaseUpdateLock(Self)) to "DbUpdateLock.ucf"
93755>>>        Set piMaxUsers     of (phoDatabaseUpdateLock(Self)) to 1
93756>>>                                                                                      // Only the current user allowed.
93756>>>        // Properties for the table & column of a system file field/column where
93756>>>        // the database version update number gets saved.
93756>>>        Property Integer Private.Data_File  0
93757>>>        Property Integer Private.Data_Field 0
93758>>>
93758>>>        // Property that is used to indicate that we have already
93758>>>        // started the database update.
93758>>>        Property Boolean Private.pbDatabaseUpdateStarted False
93759>>>
93759>>>        // Don't touch! It is used by the child class cDbUpdateVersion logic to indicate that
93759>>>        // at least one OnUpdate child event has been triggered. Thus at least one active
93759>>>        // change of the database has been made.
93759>>>        Property Boolean Private.pbDatabaseWasUpdated False
93760>>>
93760>>>        // We need to trigger the user counting system so that a bit in the
93760>>>        // user counting file is locked. This is to guard that not more than one user
93760>>>        // is currently runnning the program.
93760>>>        Get CheckUserCount of (phoUserCountSystem(Self)) to UserCount
93761>>>
93761>>>        Get CurrentNumberOfUsers of (phoDatabaseUpdateLock(Self)) to iUserCount
93762>>>        If (iUserCount > 0) Begin
93764>>>            Send Stop_Box CS_DUF_UpdateInProgressTxt
93765>>>            Send Exit_Application
93766>>>        End
93766>>>>
93766>>>
93766>>>        Set pbHandleQueryErrors to False
93767>>>            
93767>>>        Property Handle phoSQLConnectionHandler 0
93768>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
93768>>>        // we will create one as it is used for all ConnectionID, ConnectionString
93768>>>        // etc information.
93768>>>        If (ghoSQLConnectionHandler = 0) Begin
93770>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
93771>>>            Set phoSQLConnectionHandler to ho
93772>>>        End             
93772>>>>
93772>>>        
93772>>>        // Do *not* set this property in this object!
93772>>>        // Instead use logic to set it in the Procedure OnCreate of the cApplication
93772>>>        // object. Aka, use phoCommandLine to retrieve an e.g. "-restore" parameter on
93772>>>        // the command line to the program. If such param has been passed, set  pbRestoreIntFilesNow = True.
93772>>>        // The user will then be informed that .int files will be restored and then the program will exit.
93772>>>        Property Boolean pbRestoreIntFilesNow False   
93773>>>        // In parallell with the above property, the pbSaveIntFilesNow can be set. That same property
93773>>>        // also needs to be created in the ghoApplication object.
93773>>>        Property Boolean pbSaveIntFilesNow False
93774>>>        Property Boolean pbUseIntFilesBackup False   
93775>>>        Property Handle  phIntFilesTable -1
93776>>>        Property Boolean Private.pbIntFilesTablesCheckDone False
93777>>>        
93777>>>        Set Icon to "Default.ico"
93778>>>    End_Procedure
93779>>>
93779>>>    Procedure End_Construct_Object
93781>>>        Boolean bCheckIntFiles
93781>>>        
93781>>>        Forward Send End_Construct_Object
93783>>>        If (Private.pbOnCreateExecuted(Self) = False) Begin  
93785>>>            Send OnCreate
93786>>>            Set Private.pbOnCreateExecuted to True
93787>>>        End
93787>>>>
93787>>>        Send Cleanup
93788>>>    End_Procedure
93789>>>    
93789>>>    // Programmers hook event.
93789>>>    Procedure OnCreate
93791>>>    End_Procedure        
93792>>>                                 
93792>>>    // Note: If you get a compile Error 4295: "xxx Can't include resource FILELISTBACKUPFILE.CFG",
93792>>>    //       you will need to manually make a copy of the Filelist.cfg in the Data folder -> "FilelistBackupFile.cfg"
93792>>>    Include_Resource FilelistBackupFile.cfg as res_EmbeddedFilelistCfg type DF_RESOURCE_TYPE_BINARY
93792>>>    // *** MAIN .Int file (and Filelist.cfg) Integrity Check Message ***
93792>>>    //                                                
93792>>>    // The logic is activated by setting the property "pbUseIntFilesBackup = True" in the
93792>>>    // cDbUpdateHandler object.
93792>>>    //
93792>>>    // Checks that all .int files are intact, or else writes new copies to disk. 
93792>>>    // Also checks that there is a Filelist.cfg, and if missing writes a new copy to disk.
93792>>>    //
93792>>>    // If not done previously the phIntFilesTable will be created and filled with data
93792>>>    // from the current set of .int files - iif (if-and-only-if) this is a development
93792>>>    // machine. Which is decided by checking if the DdSrc folder exists. And a copy
93792>>>    // of Filelist.cfg is made for backup purposes.
93792>>>    //
93792>>>    // Note: If an error occurrs the application will exit, as it means that at least one
93792>>>    // .int file is in error or the Filelist.cfg was missing and couldn't be recreated.
93792>>>
93792>>>    // Note: Include_Resource is a compiler directive!
93792>>>    // It will embedd the Filelist.cfg from the developers machine
93792>>>    // into the executable.        
93792>>>    //
93792>>>    // There is a pickle with the Filelist.cfg as it is "busy" as it is open in the Studio,
93792>>>    // when we get here and then the compiler can't embedd it!        
93792>>>    // NOTE: This relies on the "WriteDateTimeHeaderFile" program and that each Project has
93792>>>    //       been setup to run it as the "Before Compilation Process:" (See: Project - Project Properties - Compiler tab-page)
93792>>>    Function SaveUpdateIntFiles String ByRef sErrorText Returns Boolean
93794>>>        Boolean bCheckIntFiles bExists bOK bSaved bIsSQL bFileListExist bResult bDevelop bZipExists bIntFilesTablesCheckDone bNewer bIsIntFileTable  bIsAlias
93794>>>        String sPaths sDataPath sIntFileName sRootName sFileListName sFileListNameBackup sDDSrcPath sCurrentFolder
93794>>>        String sFileListZipFile sParam sProgram sFile 
93794>>>        Integer iDataPaths iCount
93794>>>        Handle hTable hIntFilesTable                    
93794>>>        UChar[] asFileListArray 
93795>>>        String[] asSavedIntFile
93796>>>        tDUFIntFile[] DUFIntFiles
93796>>>        tDUFIntFile[] DUFIntFiles
93797>>>
93797>>>        // This will automatically create the phIntFilesTable if not exists.
93797>>>        // It is used to save data from the current set of .int files.
93797>>>        // We do this on both developer & client machines.
93797>>>        Get IsIntFileTable to bIsIntFileTable
93798>>>        If (bIsIntFileTable = False) Begin
93800>>>            Send AutoCreateIntFilesTable
93801>>>            Get Private.pbIntFilesTablesCheckDone to bOK
93802>>>            If (bOK = False) Begin
93804>>>//                Move CS_DUF_DbUpdatedErrorText to sErrorText
93804>>>                Function_Return False
93805>>>            End
93805>>>>
93805>>>        End                                                       
93805>>>>
93805>>>        
93805>>>        // Check Filelist.cfg & backup file
93805>>>        Get psFileList of (phoWorkspace(ghoApplication)) to sFileListName
93806>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath 
93807>>>        Move (sDataPath + "\" + CS_FilelistBackupFile)   to sFileListNameBackup
93808>>>        Get IsFileTimeNewer sFileListName sFileListNameBackup to bNewer
93809>>>
93809>>>        Move (IsDebuggerPresent()) to bDevelop
93810>>>        // Is this a client machine?
93810>>>        If (bDevelop = False) Begin
93812>>>            If (bNewer = True) Begin
93814>>>                // Create filelist.cfg from resource backup file.
93814>>>                Get ReadFileListResource "res_EmbeddedFilelistCfg" to asFileListArray
93815>>>                Get WriteFileListResource asFileListArray sFileListName to bOK  
93816>>>            End
93816>>>>
93816>>>        End
93816>>>>
93816>>>
93816>>>        Else If (bDevelop = True) Begin
93819>>>            Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
93820>>>            If (bNewer = True) Begin
93822>>>                Get vDeleteFile sFileListNameBackup to bOK
93823>>>                Get vCopyFile sFileListName sFileListNameBackup to bOK
93824>>>                Move "A new backup copy of the Filelist.cfg file was made. In order to include a backup copy of the file into the program, as a resource, you will need to re-compile/restart the program.\n\nThe program will now exit." to sErrorText
93825>>>                Function_Return True
93826>>>            End
93826>>>>
93826>>>        End
93826>>>>
93826>>>        
93826>>>        Move True to bResult        
93827>>>        Send StartStatusPanel
93828>>>        Get phIntFilesTable to hIntFilesTable
93829>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
93830>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths
93831>>>
93831>>>        For iCount from 1 to iDataPaths
93837>>>>
93837>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
93838>>>            Get vFolderFormat sDataPath to sDataPath 
93839>>>            Get vFolderExists sDataPath to bExists
93840>>>            If (bExists = True) Begin                  
93842>>>                Move 0 to hTable
93843>>>                Repeat
93843>>>>
93843>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
93846>>>                    If (hTable <> 0 and hTable <> 50) Begin
93848>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
93851>>>                        Set Message_Text of ghoStatusPanel to ("Saving/updating IntFilesTable:" * String(sIntFileName))
93852>>>                        Get _UtilTableIsSqlByRootName sIntFileName to bIsSQL
93853>>>                        Get UtilTableIsAlias hTable to bIsAlias 
93854>>>                        If (bIsSQL = True and bIsAlias = False) Begin
93856>>>                            If (bIsSQL = True) Begin     
93858>>>                                Get _TableNameOnly sIntFileName to sIntFileName
93859>>>                                Move (sIntFileName + ".int")    to sIntFileName
93860>>>                                Get IsIntFileSaved sIntFileName to bSaved  
93861>>>                                Move True to bOK            
93862>>>                                
93862>>>                                // Save .int file to database if not done previously (both on development- and customer-machines).
93862>>>                                If (bSaved = False) Begin
93864>>>                                    Get SaveIntFileData sDataPath sIntFileName to bOK
93865>>>                                    If (bOK = False) Begin
93867>>>                                        Error DFERR_PROGRAM ("The 'SaveIntFileData' function for the internal database table:" * String(sIntFileName) * "failed.")
93868>>>>
93868>>>                                        Move False to bResult    
93869>>>                                    End
93869>>>>
93869>>>                                End         
93869>>>>
93869>>>                                Else Begin
93870>>>                                    Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
93871>>>                                    If (SizeOfArray(asSavedIntFile) <> 0) Begin
93873>>>                                        Get UpdateIntFileData sDataPath sIntFileName asSavedIntFile to bOK
93874>>>                                        If (bOK = False) Begin
93876>>>                                            Move False to bResult
93877>>>                                            Error DFERR_PROGRAM ("Could not update .int file data to the internal database table:" * String(sIntFileName))
93878>>>>
93878>>>                                        End
93878>>>>
93878>>>                                    End
93878>>>>
93878>>>                                End
93878>>>>
93878>>>                            End
93878>>>>
93878>>>                        End
93878>>>>
93878>>>                    End
93878>>>>
93878>>>                Until (hTable = 0)
93880>>>            End
93880>>>>
93880>>>        Loop       
93881>>>>
93881>>>        
93881>>>        Send Stop_StatusPanel of ghoStatusPanel
93882>>>        // If an error occured we need to exit the application as we cannot start with an uncomplete set of .int files.
93882>>>        If (bResult = False) Begin  
93884>>>            Function_Return False
93885>>>        End 
93885>>>>
93885>>>        Send LogError ("The *.int file backup table was updated:" * String(CS_IntFilesTableLogicalName)) False
93886>>>        Function_Return True
93887>>>    End_Function
93888>>>
93888>>>    // It checks that *.int files on disk corresponds with the content in the
93888>>>    // .int file backup table phIntFilesTable.
93888>>>    Procedure RestoreIntFiles
93890>>>        Boolean bCheckIntFiles bIsIntFileTable bExists bIsSQL bRestored bOK
93890>>>        String sPaths sDataPath sIntFileName 
93890>>>        String[] asSavedIntFile
93891>>>        Integer iDataPaths iCount iRetval
93891>>>        Handle hTable hIntFilesTable
93891>>>
93891>>>        Get IsIntFileTable to bIsIntFileTable
93892>>>        If (bIsIntFileTable = False) Begin
93894>>>            Send Info_Box "The 'IntFilesTable' has not been created. Thus no backup info for .int files exists. The property pbUseIntFilesBackup must have been set to True in the cDbUpdateHandler object for automatic creation of the table and save of all .int files."
93895>>>            Procedure_Return
93896>>>        End
93896>>>>
93896>>>        
93896>>>        Get YesNo_Box "This will restore the content of .int files. Current .int files will be compared to the content in the backup table. If different, files on disk will be updated. Cash files (.cch) will be removed.\n\n Continue?" to iRetval
93897>>>        If (iRetval <> MBR_Yes) Begin
93899>>>            Procedure_Return
93900>>>        End
93900>>>>
93900>>>
93900>>>        Send StartStatusPanel
93901>>>        Move False to bRestored
93902>>>        Get phIntFilesTable to hIntFilesTable
93903>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
93904>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths
93905>>>
93905>>>        For iCount from 1 to iDataPaths
93911>>>>
93911>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
93912>>>            Get vFolderFormat sDataPath to sDataPath 
93913>>>            Get vFolderExists sDataPath to bExists
93914>>>            If (bExists = True) Begin                  
93916>>>                Move 0 to hTable
93917>>>                Repeat
93917>>>>
93917>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable    
93920>>>                    If (hTable <> 0) Begin
93922>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
93925>>>                        Set Message_Text of ghoStatusPanel to ("Checking info for." * String(sIntFileName))
93926>>>                        Get _UtilTableIsSqlByRootName sIntFileName to bIsSQL
93927>>>                        If (bIsSQL = True) Begin     
93929>>>                            Get _TableNameOnly sIntFileName to sIntFileName
93930>>>                            Move (sIntFileName + ".int")    to sIntFileName
93931>>>                            Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
93932>>>                            If (SizeOfArray(asSavedIntFile) <> 0) Begin
93934>>>                                Set Message_Text of ghoStatusPanel to ("Restoring .int file:" * String(sIntFileName))
93935>>>                                Get CreateIntFileFromSavedData sIntFileName sDataPath to bOK
93936>>>                                If (bRestored = False and bOK = True) Begin
93938>>>                                    Move True to bRestored
93939>>>                                End
93939>>>>
93939>>>                                If (bOK = False) Begin
93941>>>                                    Error DFERR_PROGRAM ("Could not create the .int file" * String(sIntFileName) * "from the internal database table:" * String(CS_IntFilesTableLogicalName))
93942>>>>
93942>>>                                End
93942>>>>
93942>>>                            End
93942>>>>
93942>>>                        End
93942>>>>
93942>>>                    End
93942>>>>
93942>>>                Until (hTable = 0)
93944>>>            End
93944>>>>
93944>>>        Loop       
93945>>>>
93945>>>        
93945>>>        Send Stop_StatusPanel of ghoStatusPanel
93946>>>        If (bRestored = True) Begin
93948>>>            Send Info_Box "Ready! All .int files checked and updated if different. The program will now exit."
93949>>>            Send Exit_Application
93950>>>        End
93950>>>>
93950>>>    End_Procedure
93951>>>
93951>>>    Function IsIntFileTable Returns Boolean
93953>>>        Boolean bExists
93953>>>        Handle hTable
93953>>>        String sLogicalName
93953>>>        Move False to bExists
93954>>>        Get phIntFilesTable to hTable
93955>>>        If (hTable > 0) Begin
93957>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
93960>>>            Move (sLogicalName = CS_IntFilesTableLogicalName) to bExists
93961>>>        End
93961>>>>
93961>>>        Function_Return bExists    
93962>>>    End_Function
93963>>>    
93963>>>    // To update currently saved IntFile data to the database.
93963>>>    // Because it is much easier, we first delete all current records and
93963>>>    // then saves the changed .int file to the database.
93963>>>    Function UpdateIntFileData String sDataPath String sIntFileName String[] asSavedIntFile Returns Boolean
93965>>>        Boolean bOK
93965>>>        Move False to bOK
93966>>>        Move (Lowercase(sIntFileName)) to sIntFileName
93967>>>        Get DeleteIntFileData sDataPath sIntFileName to bOK
93968>>>        If (bOK = True) Begin
93970>>>            Get SaveIntFileData sDataPath sIntFileName to bOK
93971>>>        End
93971>>>>
93971>>>        Function_Return bOK
93972>>>    End_Function
93973>>>    
93973>>>    // Note: We use vFind here as the IntFileName may not yet have been created,
93973>>>    //       and thus we cannot compile.
93973>>>    Function IsIntFileSaved String sIntFileName Returns Boolean
93975>>>        Handle hTable
93975>>>        Boolean bOK
93975>>>        Integer iColumn iIndex   
93975>>>        String sFileName
93975>>>        
93975>>>        Move (Lowercase(sIntFileName)) to sIntFileName
93976>>>        Move False to bOK  
93977>>>        Get phIntFilesTable to hTable
93978>>>        Move 2              to iColumn // This is the "InfFileName" field no.
93979>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
93980>>>
93980>>>        Open hTable
93982>>>        Set_Field_Value hTable iColumn to sIntFileName
93985>>>        Vfind hTable iIndex GE
93987>>>        Get_Field_Value hTable iColumn to sFileName
93990>>>        If (Trim(sIntFileName) = Trim(sFileName)) Begin
93992>>>            Move True to bOK    
93993>>>        End
93993>>>>
93993>>>        Close hTable
93994>>>        
93994>>>        Function_Return bOK       
93995>>>    End_Function   
93996>>>    
93996>>>    // Checks that the passed .int file is the same as what is saved in the database.
93996>>>    // If not same, the return string array will contain the read .int file,
93996>>>    // else the returned array will be empty.
93996>>>    Function HasIntFileChanged String sDataPath String sIntFileName Returns String[]
93998>>>        String[] asIntFileOrg asIntFile asSavedIntFile asReturnIntFile
94002>>>        Boolean bIsSame
94002>>>        
94002>>>        Move (Lowercase(sIntFileName)) to sIntFileName
94003>>>        Get ReadIntFileData  sDataPath sIntFileName to asIntFileOrg   
94004>>>        Get SavedIntFileData sDataPath sIntFileName to asSavedIntFile
94005>>>        Get RemoveBlankLines asIntFileOrg   to asIntFile
94006>>>        Get RemoveBlankLines asSavedIntFile to asSavedIntFile
94007>>>        
94007>>>        Move (IsSameArray(asIntFile, asSavedIntFile)) to bIsSame
94008>>>        If (bIsSame = False) Begin
94010>>>            Move asIntFileOrg to asReturnIntFile    
94011>>>        End
94011>>>>
94011>>>        
94011>>>        Function_Return asReturnIntFile    
94012>>>    End_Function                                   
94013>>>    
94013>>>    // Takes a string array as parameter and returns a new
94013>>>    // string array without any empty rows and all rows trimmed.
94013>>>    // This is e.g. used by the HasIntFileChanged message to compare
94013>>>    // two .int file arrays. 
94013>>>    Function RemoveBlankLines String[] asIntFile Returns String[]
94015>>>        Integer iSize iCount iRow
94015>>>        String sVal        
94015>>>        String[] asRetValArray
94016>>>        
94016>>>        Move (SizeOfArray(asIntFile)) to iSize
94017>>>        If (iSize = 0) Begin
94019>>>            Function_Return asRetValArray
94020>>>        End                          
94020>>>>
94020>>>        Decrement iSize         
94021>>>        Move 0 to iRow
94022>>>        
94022>>>        For iCount from 0  to iSize
94028>>>>
94028>>>            Move asIntFile[iCount] to sVal
94029>>>            Move (Trim(sVal)) to sVal
94030>>>            If (sVal <> "") Begin
94032>>>                Move sVal to asRetValArray[iRow]
94033>>>                Increment iRow        
94034>>>            End
94034>>>>
94034>>>        Loop
94035>>>>
94035>>>        
94035>>>        Function_Return asRetValArray
94036>>>    End_Function
94037>>>    
94037>>>    Function SaveIntFileData String sPath String sIntFileName Returns Boolean
94039>>>        Handle hTable
94039>>>        Boolean bOK bErr
94039>>>        Integer iIDCol iFileCol iTextCol iIndex iIDIdx iSize iCount 
94039>>>        Number iID
94039>>>        String sFileName
94039>>>        String[] asIntFile
94040>>>        
94040>>>        // Note: We will lowercase all .int file names, to not get into having duplicates in the database
94040>>>        Move (Lowercase(sIntFileName)) to sIntFileName
94041>>>        
94041>>>        Move Err to bErr
94042>>>        Move False to Err
94043>>>        Move False to bOK
94044>>>        Get phIntFilesTable to hTable  
94045>>>        Move 1              to iIDCol
94046>>>        Move 2              to iFileCol
94047>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
94048>>>        Move 1              to iIDIdx   // Main ID index.
94049>>>        Move 2              to iIndex   // This is the IntFileName + ID index.
94050>>>
94050>>>        Get ReadIntFileData sPath sIntFileName to asIntFile
94051>>>        Move (SizeOfArray(asIntFile)) to iSize
94052>>>        If (iSize = 0) Begin
94054>>>            Function_Return False
94055>>>        End
94055>>>>
94055>>>        Decrement iSize
94056>>>        Open hTable  
94058>>>                  
94058>>>        // Find the last used ID no:
94058>>>        Fill_Field hTable iIDCol with DF_HIGH
94060>>>        Vfind hTable iIDIdx LE
94062>>>        Get_Field_Value hTable iIDCol to iID 
94065>>>        // This only happens the very first time we save a record.
94065>>>        If (iID = 999999999999) Begin
94067>>>            Move 0 to iID
94068>>>        End
94068>>>>
94068>>>        Increment iID
94069>>>        
94069>>>        Lock
94070>>>>
94070>>>            For iCount from 0 to iSize
94076>>>>
94076>>>                Clear hTable
94077>>>                Set_Field_Value hTable iIDCol   to iID     
94080>>>                Set_Field_Value hTable iFileCol to sIntFileName
94083>>>                Set_Field_Value hTable iTextCol to asIntFile[iCount]
94086>>>                SaveRecord hTable
94087>>>                Increment iID
94088>>>            Loop
94089>>>>
94089>>>        Unlock
94090>>>>
94090>>>        Close hTable
94091>>>        
94091>>>        Move (not(Err)) to bOK
94092>>>        Move bErr to Err
94093>>>        
94093>>>        Function_Return bOK
94094>>>    End_Function
94095>>>    
94095>>>    // Deletes all records for the passed sIntFileName value,
94095>>>    // from the phIntFilesTable.
94095>>>    // Returns True if no errors occured.
94095>>>    Function DeleteIntFileData String sPath String sIntFileName Returns Boolean
94097>>>        Handle hTable
94097>>>        Boolean bOK bErr bFound
94097>>>        Integer iFileCol iIndex
94097>>>        String sVal
94097>>>        String[] asIntFile
94098>>>        
94098>>>        Move (Trim(Lowercase(sIntFileName))) to sIntFileName
94099>>>        Move Err to bErr
94100>>>        Move False to Err
94101>>>        Move False to bOK
94102>>>        Move 2              to iFileCol
94103>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
94104>>>        Get phIntFilesTable to hTable  
94105>>>        Open hTable  
94107>>>                  
94107>>>        // Find the first record
94107>>>        Set_Field_Value hTable iFileCol to sIntFileName
94110>>>        Vfind hTable iIndex GE
94112>>>        Get_Field_Value hTable iFileCol to sVal
94115>>>        Move (Trim(Lowercase(sVal))) to sVal
94116>>>        Move (Found and sVal = sIntFileName) to bFound
94117>>>        While (bFound = True)
94121>>>            Delete hTable
94122>>>            Vfind hTable iIndex GT
94124>>>            Get_Field_Value hTable iFileCol to sVal
94127>>>            Move (Trim(Lowercase(sVal))) to sVal
94128>>>            Move (Found and sVal = sIntFileName) to bFound
94129>>>        Loop
94130>>>>
94130>>>        Unlock
94131>>>>
94131>>>        Close hTable
94132>>>        
94132>>>        Move (not(Err)) to bOK
94133>>>        Move bErr to Err
94134>>>        
94134>>>        Function_Return bOK
94135>>>    End_Function
94136>>>
94136>>>    // Returns all saved phIntFilesTable records for the passed 
94136>>>    // sIntFileName value as a string array.
94136>>>    Function SavedIntFileData String sPath String sIntFileName Returns String[]
94138>>>        Handle hTable
94138>>>        Boolean bOK bErr bFound
94138>>>        Integer iFileCol iTextCol iIndex
94138>>>        String sVal sFileName
94138>>>        String[] asIntFile asEmptyArray
94140>>>        
94140>>>        Move (Trim(Lowercase(sIntFileName))) to sIntFileName
94141>>>        Move Err to bErr
94142>>>        Move False to Err
94143>>>        Move False to bOK
94144>>>        Move 2              to iFileCol
94145>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
94146>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
94147>>>        Get phIntFilesTable to hTable  
94148>>>        Open hTable  
94150>>>        
94150>>>        // Find the first record
94150>>>        Set_Field_Value hTable iFileCol to sIntFileName
94153>>>        Vfind hTable iIndex GE
94155>>>        Get_Field_Value hTable iFileCol to sFileName
94158>>>        Move (Trim(Lowercase(sFileName))) to sFileName
94159>>>        Move (Found and sFileName = sIntFileName) to bFound
94160>>>        While (bFound = True)
94164>>>            Get_Field_Value hTable iFileCol   to sFileName
94167>>>            Move (Trim(Lowercase(sFileName))) to sFileName
94168>>>            Move (Found and sFileName = sIntFileName) to bFound
94169>>>            If (bFound = True) Begin
94171>>>                Get_Field_Value hTable iTextCol to sVal
94174>>>                Move (Trim(sVal)) to asIntFile[SizeOfArray(asIntFile)]
94175>>>            End
94175>>>>
94175>>>            Vfind hTable iIndex GT
94177>>>        Loop
94178>>>>
94178>>>        
94178>>>        Close hTable
94179>>>        Move (not(Err)) to bOK
94180>>>        If (bOK = False) Begin
94182>>>            Move asEmptyArray to asIntFile
94183>>>        End
94183>>>>
94183>>>        Move bErr to Err               
94184>>>        
94184>>>        Function_Return asIntFile
94185>>>    End_Function
94186>>>
94186>>>    // Reads the passed sIntFileName from disk and returns its value
94186>>>    // as a string array.
94186>>>    Function ReadIntFileData String sPath String sIntFileName Returns String[]
94188>>>        String[] asIntFile       
94189>>>        String sFileName sLine
94189>>>        Integer iCh iSize iCount
94189>>>        
94189>>>        Move (Lowercase(sIntFileName)) to sIntFileName
94190>>>        Get vFolderFormat sPath to sPath
94191>>>        If (not(sIntFileName contains ".")) Begin
94193>>>            Move (sIntFileName + ".int") to sIntFileName
94194>>>        End
94194>>>>
94194>>>        Move (sPath + sIntFileName) to sFileName
94195>>>        Get Seq_Open_input_Channel sFileName to iCh
94196>>>        If (iCh < 0) Begin
94198>>>            Function_Return asIntFile
94199>>>        End                                 
94199>>>>
94199>>>        
94199>>>        Repeat
94199>>>>
94199>>>            Readln channel iCh sLine
94201>>>            If (SeqEof = False) Begin
94203>>>                Move (Trim(sLine)) to asIntFile[SizeOfArray(asIntFile)]
94204>>>            End
94204>>>>
94204>>>        Until (SeqEof = True)
94206>>>        Send Seq_Close_Channel iCh    
94207>>>        
94207>>>        Function_Return asIntFile
94208>>>    End_Function
94209>>>    
94209>>>    // Reads the Filelist.cfg from memeory as a resource.
94209>>>    // The Filelist.cfg has been compiled into the program.
94209>>>    Function ReadFileListResource String sMemFileName Returns UChar[]
94211>>>        Integer iCh iCount
94211>>>        Number nByteCount
94211>>>        String[] asFileListArray sEmptyArray
94213>>>        String sLine
94213>>>        UChar[] uCharData
94214>>>        
94214>>>        Move False to Err
94215>>>        Get Seq_New_Channel to iCh
94216>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
94218>>>            Error DFERR_PROGRAM 'No channel available...'
94219>>>>
94219>>>            Function_Return sEmptyArray
94220>>>        End
94220>>>>
94220>>>
94220>>>        // First decide the size of the script
94220>>>        Direct_Input channel iCh ("Resource: " + sMemFileName)
94222>>>        Read_Block channel iCh uCharData -1 // -1 means that all data should be read.
94224>>>        Close_Input channel iCh
94226>>>        Send Seq_Release_Channel iCh
94227>>>
94227>>>        Function_Return uCharData
94228>>>    End_Function    
94229>>>    
94229>>>    // Writes a copy of the workspace Filelist.cfg to disk.
94229>>>    // It does so by reading from a memory resource, as the file has
94229>>>    // been compiled into the program.
94229>>>    Function WriteFileListResource UChar[] asFileListArray String sFileListName Returns Boolean
94231>>>        Boolean bOK bErr
94231>>>        Integer iSize iCh
94231>>>        
94231>>>        Move Err to bErr
94232>>>        Move False to Err
94233>>>        Move False to bOK
94234>>>        Move (SizeOfArray(asFileListArray)) to iSize
94235>>>        If (iSize = 0) Begin
94237>>>            Function_Return False
94238>>>        End
94238>>>>
94238>>>
94238>>>        Get Seq_New_Channel to iCh
94239>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
94241>>>            Error DFERR_PROGRAM 'No channel available...'
94242>>>>
94242>>>            Function_Return False
94243>>>        End                      
94243>>>>
94243>>>        
94243>>>        Direct_Output channel iCh sFileListName
94245>>>        Writeln channel iCh asFileListArray
94248>>>                
94248>>>        Close_Input channel iCh
94250>>>        Send Seq_Release_Channel iCh
94251>>>        Move (not(Err)) to bOK
94252>>>        Move bErr to Err
94253>>>        
94253>>>        Function_Return bOK
94254>>>    End_Function
94255>>>
94255>>>    // Writes an .int for the passed sIntFileName file to disk by reading data from the phIntFilesTable data table.
94255>>>    // It first deletes the .cch file (if any).
94255>>>    Function CreateIntFileFromSavedData String sIntFileName String sDataPath Returns Boolean
94257>>>        Boolean bOK bFound bExists bErr
94257>>>        Integer iCh iSize iCount
94257>>>        String sFileName sCCHFileName sVal
94257>>>        String[] asIntFile
94258>>>        
94258>>>        Move (Lowercase(sIntFileName)) to sIntFileName
94259>>>        Move Err to bErr   
94260>>>        Move False to Err
94261>>>        Move False to bOK
94262>>>
94262>>>        Get SavedIntFileData sDataPath sIntFileName to asIntFile
94263>>>        Move (SizeOfArray(asIntFile)) to iSize
94264>>>        If (iSize = 0) Begin
94266>>>            Function_Return False        
94267>>>        End                      
94267>>>>
94267>>>        Decrement iSize
94268>>>        
94268>>>        Get Seq_New_Channel to iCh
94269>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
94271>>>            Function_Return False
94272>>>        End   
94272>>>>
94272>>>        
94272>>>        // Before we start to actually create the new .int file, make sure we delete
94272>>>        // the .cch file.                                     
94272>>>        Move (Uppercase(sIntFileName)) to sCCHFileName
94273>>>        Move (Replace(".INT", sCCHFileName, ".CCH")) to sCCHFileName
94274>>>        Get vFilePathExists (sDataPath + sCCHFileName) to bExists
94275>>>        If (bExists = True) Begin
94277>>>            Get vDeleteFile (sDataPath + sCCHFileName) to bOK
94278>>>            If (bOK = False) Begin
94280>>>                Function_Return False
94281>>>            End
94281>>>>
94281>>>        End
94281>>>>
94281>>>        
94281>>>        Direct_Output channel iCh (sDataPath + sIntFileName)
94283>>>        For iCount from 0 to iSize
94289>>>>
94289>>>            Writeln channel iCh asIntFile[iCount]
94292>>>        Loop
94293>>>>
94293>>>        
94293>>>        Close_Input channel iCh
94295>>>        Send Seq_Release_Channel iCh
94296>>>        Move (not(Err)) to bOK
94297>>>        Move bErr to Err
94298>>>        
94298>>>        Function_Return bOK
94299>>>    End_Function   
94300>>>              
94300>>>    // Automatically writes .int files to disk that is missing.
94300>>>    // We only need to make this test this once, but because the message is called
94300>>>    // from each child cDbUpdateVersion object (and it needs to be called from there),
94300>>>    // we use property Private.pbIntFilesTablesCheckDone to ensure it is only run once.
94300>>>    Procedure AutoCreateIntFilesTable
94302>>>        Integer hTable 
94302>>>        Boolean bIntFilesTablesCheckDone bTableExists bOK
94302>>>        String sInfoTxt 
94302>>>        
94302>>>        Get phIntFilesTable to hTable  
94303>>>        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
94304>>>        If (bIntFilesTablesCheckDone = True) Begin
94306>>>            Procedure_Return
94307>>>        End
94307>>>>
94307>>>
94307>>>        If (hTable < 1) Begin
94309>>>            Set Private.pbIntFilesTablesCheckDone to False
94310>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94311>>>            Error DFERR_PROGRAM "The phIntFilesTable has been set to 0 (!). The default value is 2048 and if changed MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object.\nProgram will now exit!"
94312>>>>
94312>>>            Procedure_Return
94313>>>        End
94313>>>>
94313>>>        
94313>>>        Get IsIntFileTable hTable to bTableExists
94314>>>        If (bTableExists = True) Begin
94316>>>            Set Private.pbIntFilesTablesCheckDone to True
94317>>>            Procedure_Return
94318>>>        End
94318>>>>
94318>>>
94318>>>        Send SubCreateIntFilesTable hTable
94319>>>    End_Procedure
94320>>>                
94320>>>    Procedure SubCreateIntFilesTable Handle hTable
94322>>>        String sTableName sColumnName sInfoTxt sDriverID sDataPath
94322>>>        Boolean bTableExists bOK bUseConnectionID bExists
94322>>>        tAPIColumn[] APIColumn
94322>>>        tAPIColumn[] APIColumn
94323>>>
94323>>>        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
94324>>>        If (bTableExists = True) Begin
94326>>>            Procedure_Return
94327>>>        End
94327>>>>
94327>>>
94327>>>        Move False to Err
94328>>>        Get psDriverID to sDriverID
94329>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
94330>>>
94330>>>        Move CS_IntFilesTableLogicalName to sTableName
94331>>>
94331>>>        Move 1                  to APIColumn[0].iFieldNumber
94332>>>        Move "ID"               to APIColumn[0].sFieldName
94333>>>        Move DF_BCD             to APIColumn[0].iType
94334>>>        Move False              to APIColumn[0].bIsSQLType
94335>>>        Move 12                 to APIColumn[0].iLength
94336>>>        Move 0                  to APIColumn[0].iPrecision
94337>>>
94337>>>        Move 2                  to APIColumn[1].iFieldNumber
94338>>>        Move "IntFileName"      to APIColumn[1].sFieldName
94339>>>        Move DF_ASCII           to APIColumn[1].iType
94340>>>        Move False              to APIColumn[1].bIsSQLType
94341>>>        Move 50                 to APIColumn[1].iLength
94342>>>        Move 0                  to APIColumn[1].iPrecision
94343>>>
94343>>>        Move 3                  to APIColumn[2].iFieldNumber
94344>>>        Move "IntLineText"      to APIColumn[2].sFieldName
94345>>>        Move DF_ASCII           to APIColumn[2].iType
94346>>>        Move False              to APIColumn[2].bIsSQLType
94347>>>        Move 100                to APIColumn[2].iLength
94348>>>        Move 0                  to APIColumn[2].iPrecision
94349>>>
94349>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
94350>>>        
94350>>>        If (bOK = True and Err = False) Begin
94352>>>            Move ("Int Files Table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
94353>>>        End
94353>>>>
94353>>>        Else Begin
94354>>>            Set Private.pbIntFilesTablesCheckDone to False
94355>>>            Move ("ERROR" * "Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
94356>>>            Error DFERR_PROGRAM sInfoTxt
94357>>>>
94357>>>            Procedure_Return
94358>>>        End
94358>>>>
94358>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
94359>>>        
94359>>>        Open hTable
94361>>>        Get ApiIndexCreate hTable 1 1 1   to bOK     // Index 1 = ID
94362>>>        If (bOK = True) Begin
94364>>>            Get ApiIndexCreate hTable 2 2 2 1 to bOK // Index 2 = InteFileName, ID.
94365>>>        End
94365>>>>
94365>>>        If (bOK = False) Begin
94367>>>            Set Private.pbIntFilesTablesCheckDone to False
94368>>>            Move ("ERROR" * "Indexes for Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
94369>>>            Error DFERR_PROGRAM sInfoTxt
94370>>>>
94370>>>            Procedure_Return
94371>>>        End
94371>>>>
94371>>>        
94371>>>        // Check if the new .int file was created. If so and a .dat file exists - delete it.
94371>>>        If (sDriverID <> DATAFLEX_ID) Begin
94373>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
94374>>>            Get vFolderFormat sDataPath to sDataPath
94375>>>            Move (CS_IntFilesTableLogicalName + ".int") to sTableName
94376>>>            Get vFilePathExists (sDataPath + sTableName) to bExists
94377>>>            If (bExists = True) Begin
94379>>>                Move CS_IntFilesTableLogicalName to sTableName
94380>>>                Get vFilePathExists (sDataPath + sTableName + ".dat") to bExists
94381>>>                If (bExists = True) Begin
94383>>>                    Get vDeleteFile (sDataPath + sTableName + ".dat") to bOK
94384>>>                    Get vDeleteFile (sDataPath + sTableName + ".hdr") to bOK
94385>>>                    Get vDeleteFile (sDataPath + sTableName + ".k??") to bOK
94386>>>                End
94386>>>>
94386>>>            End
94386>>>>
94386>>>        End
94386>>>>
94386>>>        
94386>>>        Set Private.pbIntFilesTablesCheckDone to True
94387>>>    End_Procedure
94388>>>
94388>>>    Procedure CheckAutoCreateDbVersionTable
94390>>>        Boolean bDbVersionCheckDone bUseCustomDbVersion bAutoCreateDbVersionTable bTableExists
94390>>>        Integer iDbVersionFileNumber
94390>>>
94390>>>        Get Private.pbDbVersionCheckDone to bDbVersionCheckDone
94391>>>        If (bDbVersionCheckDone = True) Begin
94393>>>            Procedure_Return
94394>>>        End
94394>>>>
94394>>>        Get pbUseCustomDbVersion to bUseCustomDbVersion
94395>>>        If (bUseCustomDbVersion = True) Begin
94397>>>            Procedure_Return
94398>>>        End
94398>>>>
94398>>>
94398>>>        Get piDbVersionFileNumber to iDbVersionFileNumber
94399>>>        Get pbAutoCreateDbVersionTable to bAutoCreateDbVersionTable
94400>>>        If (bAutoCreateDbVersionTable = True and iDbVersionFileNumber < 1) Begin
94402>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94403>>>            Error DFERR_PROGRAM "The iDbVersionFileSlotNumber = -1. It MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object. Could not auto-create the DbVersion table.\nProgram will now exit!"
94404>>>>
94404>>>            Send Exit_Application
94405>>>        End
94405>>>>
94405>>>
94405>>>        Get _UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
94406>>>        If (bTableExists = True) Begin
94408>>>            Set Private.pbDbVersionCheckDone to True
94409>>>            Procedure_Return
94410>>>        End
94410>>>>
94410>>>
94410>>>        Send CreateDbVersionTable iDbVersionFileNumber
94411>>>
94411>>>        // We only need to these DbVersion checks once, but because this message is called
94411>>>        // from each child cDbUpdateVersion object (and it needs to be called from there),
94411>>>        // we use a property to only run these tests once.
94411>>>        Set Private.pbDbVersionCheckDone to True
94412>>>    End_Procedure
94413>>>
94413>>>    Procedure CreateDbVersionTable Handle hTable
94415>>>        String sTableName sColumnName sInfoTxt sDriverID 
94415>>>        Boolean bTableExists bOK bUseConnectionID
94415>>>        tAPIColumn[] APIColumn
94415>>>        tAPIColumn[] APIColumn
94416>>>
94416>>>        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
94417>>>        If (bTableExists = True) Begin
94419>>>            Procedure_Return
94420>>>        End
94420>>>>
94420>>>
94420>>>        Get psDriverID to sDriverID
94421>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
94422>>>
94422>>>        Move "DbVersion"        to sTableName
94423>>>        Move 1                  to APIColumn[0].iFieldNumber
94424>>>        Move "DatabaseVersion"  to APIColumn[0].sFieldName
94425>>>        Move DF_BCD             to APIColumn[0].iType
94426>>>        Move False              to APIColumn[0].bIsSQLType
94427>>>        Move 4                  to APIColumn[0].iLength
94428>>>        Move 2                  to APIColumn[0].iPrecision
94429>>>
94429>>>        Move False to Err                                
94430>>>        
94430>>>        // Note: We always create an embedded DbVersion table. To do this we temporarily need to set the psDriverID to "DATAFLEX".
94430>>>        // To convert the DbVersion table to SQL, use the 'ApiTableConvertToSQL' function.
94430>>>        Set psDriverID to DATAFLEX_ID
94431>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
94432>>>        Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
94433>>>        Set psDriverID to sDriverID
94434>>>        
94434>>>        If (bOK = True and Err = False) Begin
94436>>>//            Move ("Column '" + APIColumn[0].sFieldName + "'" * "NUMERIC" * String(APIColumn[0].iLength) + ", was successfully added to '" + sTableName + "'" * "(at filelist slot:" * String(hTable) + ")") to sInfoTxt
94436>>>            Move ("DbVersion table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
94437>>>        End
94437>>>>
94437>>>        Else Begin
94438>>>            Move ("The column could NOT be added. Either column" * sColumnName * "already exists or the Table name is incorrect?") to sInfoTxt
94439>>>        End
94439>>>>
94439>>>
94439>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
94440>>>    End_Procedure
94441>>>
94441>>>    Procedure Set pbVerboseState Boolean bVerboseState
94443>>>        Handle ho
94443>>>        Get phoLogFile to ho
94444>>>        Set pbVerboseState of ho to bVerboseState
94445>>>    End_Procedure
94446>>>
94446>>>    Function pbVerboseState Returns Boolean
94448>>>        Boolean bVerboseState
94448>>>        Handle ho
94448>>>        Get phoLogFile to ho
94449>>>        Get pbVerboseState of ho to bVerboseState
94450>>>        Function_Return bVerboseState
94451>>>    End_Function
94452>>>
94452>>>    // Callback functionality used when e.g. calling driver functions directly.
94452>>>    // Note that this overrules the callback function of the cDbUpdateFunctionLibrary class.
94452>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
94454>>>        Integer iPerc
94454>>>        Number nReady nTotal nVersion
94454>>>        Boolean bVerboseState
94454>>>        Handle hoLogFile
94454>>>
94454>>>        Get pbVerboseState to bVerboseState
94455>>>        Get pnCurrentVersionUpdate to nVersion
94456>>>        Get phoLogFile     to hoLogFile
94457>>>        Send DoAdvance of ghoProgressBar
94458>>>
94458>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
94460>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
94461>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
94462>>>        End
94462>>>>
94462>>>        If (sCallback_Text contains "Creating index") Begin
94464>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
94465>>>        End
94465>>>>
94465>>>        If (bVerboseState = True and (iCallback_Type <> DF_Message_Progress_Value)) Begin
94467>>>            Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94468>>>        End
94468>>>>
94468>>>        If (iCallback_Type <> DF_Message_Progress_Value) Begin
94470>>>            Set Message_Text of ghoStatusPanel to sCallback_Text
94471>>>            Set Action_Text  of ghoStatusPanel to ""
94472>>>        End
94472>>>>
94472>>>
94472>>>        Case Begin
94472>>>            Case (iCallback_Type = DF_Message_Progress_Title)
94474>>>                Set Action_Text  of ghoStatusPanel to ""
94475>>>                Case Break
94476>>>            Case (iCallback_Type = DF_Message_Progress_Value)
94479>>>                //*** Interpret numbers
94479>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
94480>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
94481>>>                Move ((nReady/nTotal) * 100)                                                      to iPerc
94482>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% (Total:") * String(nTotal) + ")")
94483>>>                Set piPosition of ghoProgressBar to iPerc
94484>>>                Case Break
94485>>>//            Case Else
94485>>>//                Set Message_Text of ghoStatusPanel to ""
94485>>>//                Set Action_Text  of ghoStatusPanel to ""
94485>>>        Case End
94485>>>
94485>>>        Send ProcessEvents of ghoStatusPanel
94486>>>        Function_Return False
94487>>>    End_Function
94488>>>
94488>>>    // This was made to be a procedure/function pair so we
94488>>>    // at the same time can set the property of the cDbUpdateFunctionLibrary
94488>>>
94488>>>    Procedure Set piDbType Integer iDbType
94490>>>        If (ghoSQLConnectionHandler = 0) Begin
94492>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94493>>>>
94493>>>            Procedure_Return
94494>>>        End
94494>>>>
94494>>>        Set piDbType of ghoSQLConnectionHandler to iDbType
94495>>>    End_Procedure
94496>>>
94496>>>    Function piDbType Returns Integer
94498>>>        Integer iDbType
94498>>>        If (ghoSQLConnectionHandler = 0) Begin
94500>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94501>>>>
94501>>>            Function_Return ""
94502>>>        End
94502>>>>
94502>>>        Get piDbType of ghoSQLConnectionHandler to iDbType
94503>>>        Function_Return iDbType
94504>>>    End_Function
94505>>>
94505>>>    Procedure Set psDriverID String sDriverID
94507>>>        If (ghoSQLConnectionHandler = 0) Begin
94509>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94510>>>>
94510>>>            Procedure_Return
94511>>>        End
94511>>>>
94511>>>        Set psDriverID of ghoSQLConnectionHandler to sDriverID
94512>>>    End_Procedure
94513>>>
94513>>>    Function psDriverID Returns String
94515>>>        String sValue
94515>>>        If (ghoSQLConnectionHandler = 0) Begin
94517>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94518>>>>
94518>>>            Function_Return ""
94519>>>        End
94519>>>>
94519>>>        Get psDriverID of ghoSQLConnectionHandler to sValue
94520>>>        Function_Return sValue
94521>>>    End_Function
94522>>>
94522>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
94524>>>        If (ghoSQLConnectionHandler = 0) Begin
94526>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94527>>>>
94527>>>            Procedure_Return
94528>>>        End
94528>>>>
94528>>>        Send CreateSQLConnection of ghoSQLConnectionHandler sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
94529>>>    End_Procedure
94530>>>
94530>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
94532>>>        Integer iRetval
94532>>>        If (ghoSQLConnectionHandler = 0) Begin
94534>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94535>>>>
94535>>>            Function_Return 2
94536>>>        End
94536>>>>
94536>>>
94536>>>        Get RedirectConnection of ghoSQLConnectionHandler to iRetval
94537>>>        Function_Return iRetval
94538>>>    End_Function
94539>>>
94539>>>    Procedure Set psConnectionID String sValue
94541>>>        If (ghoSQLConnectionHandler = 0) Begin
94543>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94544>>>>
94544>>>            Procedure_Return
94545>>>        End
94545>>>>
94545>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
94546>>>    End_Procedure
94547>>>
94547>>>    Function psConnectionID Returns String
94549>>>        String sValue
94549>>>        If (ghoSQLConnectionHandler = 0) Begin
94551>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94552>>>>
94552>>>            Function_Return ""
94553>>>        End
94553>>>>
94553>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
94554>>>
94554>>>        Function_Return sValue
94555>>>    End_Function
94556>>>
94556>>>    // These "properties" are settings of the cCLIHandler class, but are being
94556>>>    // relayed to the ghoSQLConnectionHandler object
94556>>>    // simply by changing one of its parameters.
94556>>>    Procedure Set psServer String sValue
94558>>>        If (ghoSQLConnectionHandler = 0) Begin
94560>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94561>>>>
94561>>>            Procedure_Return
94562>>>        End
94562>>>>
94562>>>        Set psServer of ghoSQLConnectionHandler to sValue
94563>>>    End_Procedure
94564>>>
94564>>>    Function psServer Returns String
94566>>>        String sValue
94566>>>        If (ghoSQLConnectionHandler = 0) Begin
94568>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94569>>>>
94569>>>            Function_Return ""
94570>>>        End
94570>>>>
94570>>>        Get psServer of ghoSQLConnectionHandler to sValue
94571>>>
94571>>>        Function_Return sValue
94572>>>    End_Function
94573>>>
94573>>>    Procedure Set psDatabase String sValue
94575>>>        If (ghoSQLConnectionHandler = 0) Begin
94577>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94578>>>>
94578>>>            Procedure_Return
94579>>>        End
94579>>>>
94579>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
94580>>>    End_Procedure
94581>>>
94581>>>    Function psDatabase Returns String
94583>>>        String sValue
94583>>>        If (ghoSQLConnectionHandler = 0) Begin
94585>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94586>>>>
94586>>>            Function_Return ""
94587>>>        End
94587>>>>
94587>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
94588>>>
94588>>>        Function_Return sValue
94589>>>    End_Function
94590>>>
94590>>>    Procedure Set psUserID String sValue
94592>>>        If (ghoSQLConnectionHandler = 0) Begin
94594>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94595>>>>
94595>>>            Procedure_Return
94596>>>        End
94596>>>>
94596>>>        Set psUserID of ghoSQLConnectionHandler to sValue
94597>>>    End_Procedure
94598>>>
94598>>>    Function psUserID Returns String
94600>>>        String sValue
94600>>>        If (ghoSQLConnectionHandler = 0) Begin
94602>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94603>>>>
94603>>>            Function_Return ""
94604>>>        End
94604>>>>
94604>>>        Get psUserID of ghoSQLConnectionHandler to sValue
94605>>>
94605>>>        Function_Return sValue
94606>>>    End_Function
94607>>>
94607>>>    Procedure Set psPassword String sValue
94609>>>        If (ghoSQLConnectionHandler = 0) Begin
94611>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94612>>>>
94612>>>            Procedure_Return
94613>>>        End
94613>>>>
94613>>>        Set psPassword of ghoSQLConnectionHandler to sValue
94614>>>    End_Procedure
94615>>>
94615>>>    Function psPassword Returns String
94617>>>        String sValue
94617>>>        If (ghoSQLConnectionHandler = 0) Begin
94619>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94620>>>>
94620>>>            Function_Return ""
94621>>>        End
94621>>>>
94621>>>        Get psPassword of ghoSQLConnectionHandler to sValue
94622>>>
94622>>>        Function_Return sValue
94623>>>    End_Function
94624>>>
94624>>>    Procedure Set pbTrusted Boolean bValue
94626>>>        If (ghoSQLConnectionHandler = 0) Begin
94628>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94629>>>>
94629>>>            Procedure_Return
94630>>>        End
94630>>>>
94630>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
94631>>>    End_Procedure
94632>>>
94632>>>    Function pbTrusted Returns Boolean
94634>>>        Boolean bValue
94634>>>        If (ghoSQLConnectionHandler = 0) Begin
94636>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94637>>>>
94637>>>            Function_Return False
94638>>>        End
94638>>>>
94638>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
94639>>>
94639>>>        Function_Return bValue
94640>>>    End_Function
94641>>>
94641>>>    Procedure Set psConnectionString String sValue
94643>>>        If (ghoSQLConnectionHandler = 0) Begin
94645>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94646>>>>
94646>>>            Procedure_Return
94647>>>        End
94647>>>>
94647>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
94648>>>    End_Procedure
94649>>>
94649>>>    Function psConnectionString Returns String
94651>>>        String sValue
94651>>>        If (ghoSQLConnectionHandler = 0) Begin
94653>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94654>>>>
94654>>>            Function_Return ""
94655>>>        End
94655>>>>
94655>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
94656>>>
94656>>>        Function_Return sValue
94657>>>    End_Function
94658>>>
94658>>>    Function piConnectionOptions Returns Integer
94660>>>        Integer iValue
94660>>>        If (ghoSQLConnectionHandler = 0) Begin
94662>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94663>>>>
94663>>>            Function_Return 0
94664>>>        End
94664>>>>
94664>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
94665>>>
94665>>>        Function_Return iValue
94666>>>    End_Function
94667>>>
94667>>>
94667>>>    Procedure Set pbCheckDataFlexUserCount Boolean bState
94669>>>        Set pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
94670>>>    End_Procedure
94671>>>
94671>>>    Function pbCheckDataFlexUserCount Returns Boolean
94673>>>        Boolean bState
94673>>>        Get pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
94674>>>        Function_Return bState
94675>>>    End_Function
94676>>>
94676>>>    Procedure Set psLogTextFile String sValue
94678>>>        Set psLogTextFile of (phoLogFile(Self)) to sValue
94679>>>    End_Procedure
94680>>>
94680>>>    Function psLogTextFile Returns String
94682>>>        String sValue
94682>>>        Get psLogTextFile of (phoLogFile(Self)) to sValue
94683>>>        Function_Return sValue
94684>>>    End_Function
94685>>>
94685>>>    Procedure Set psEditorProgram String sValue
94687>>>        Set psEditorProgram of (phoLogFile(Self)) to sValue
94688>>>    End_Procedure
94689>>>
94689>>>    Function psEditorProgram Returns String
94691>>>        String sValue
94691>>>        Get psEditorProgram of (phoLogFile(Self)) to sValue
94692>>>        Function_Return sValue
94693>>>    End_Function
94694>>>
94694>>>    Procedure Set pbUseDataTableLog Boolean bState
94696>>>        Set pbUseDataTableLog of (phoLogFile(Self)) to bState
94697>>>    End_Procedure
94698>>>
94698>>>    Function pbUseDataTableLog Returns Boolean
94700>>>        Boolean bState
94700>>>        Get pbUseDataTableLog of (phoLogFile(Self)) to bState
94701>>>        Function_Return bState
94702>>>    End_Function
94703>>>
94703>>>    Procedure Set pbQuickWrite Boolean bState
94705>>>        Set pbQuickWrite of (phoLogFile(Self)) to bState
94706>>>    End_Procedure
94707>>>
94707>>>    Function pbQuickWrite Returns Boolean
94709>>>        Boolean bState
94709>>>        Get pbQuickWrite of (phoLogFile(Self)) to bState
94710>>>        Function_Return bState
94711>>>    End_Function
94712>>>
94712>>>    Procedure Set pbDatabaseWasUpdated Boolean bState
94714>>>        Boolean bUpdateVersionObjectError bVerboseState
94714>>>        Integer iSize iCount
94714>>>        Number nVersion
94714>>>        String[] aSQLQueryMessages
94715>>>
94715>>>        Get Private.pbUpdateVersionObjectError to bUpdateVersionObjectError
94716>>>        Set Private.pbDatabaseWasUpdated to bState
94717>>>        // If no errors occurred in the current cDbUpdateVersion object - write
94717>>>        // to the log that it was OK.
94717>>>        If (bUpdateVersionObjectError = False) Begin
94719>>>            Get pnCurrentVersionUpdate to nVersion
94720>>>            Send LogError of (phoLogFile(Self)) nVersion 0 CS_SuccessfulUpdate 0 False
94721>>>        End
94721>>>>
94721>>>
94721>>>        Get pbVerboseState to bVerboseState
94722>>>        If (bVerboseState = True) Begin
94724>>>            Get paSQLQueryMessages to aSQLQueryMessages
94725>>>            Move (SizeOfArray(aSQLQueryMessages)) to iSize
94726>>>            Decrement iSize
94727>>>            For iCount from 0 to iSize
94733>>>>
94733>>>                Send LogError of (phoLogFile(Self)) nVersion 0 aSQLQueryMessages[iCount] 0 False
94734>>>            Loop
94735>>>>
94735>>>        End
94735>>>>
94735>>>
94735>>>    End_Procedure 
94736>>>    
94736>>>    Procedure Set piDbVersionFileNumber Integer iFileNumber
94738>>>        Set Private.piDbVersionFileNumber to iFileNumber
94739>>>    End_Procedure                                         
94740>>>    
94740>>>    Function piDbVersionFileNumber Returns Integer
94742>>>        Function_Return (Private.piDbVersionFileNumber(Self))
94743>>>    End_Function
94744>>>
94744>>>    Procedure Set piDbVersionFieldNumber Integer iFieldNumber
94746>>>        Set Private.piDbVersionFieldNumber to iFieldNumber
94747>>>    End_Procedure                                         
94748>>>    
94748>>>    Function piDbVersionFieldNumber Returns Integer
94750>>>        Function_Return (Private.piDbVersionFieldNumber(Self))
94751>>>    End_Function
94752>>>
94752>>>    Function pbDatabaseWasUpdated Returns Boolean
94754>>>        Function_Return (Private.pbDatabaseWasUpdated(Self))
94755>>>    End_Function
94756>>>    
94756>>>    //
94756>>>    Procedure ReinitializeFramework  
94758>>>        tDbVersionInfo[] aDbVersionInfoArray
94758>>>        tDbVersionInfo[] aDbVersionInfoArray
94759>>>        Handle hoDbVersionObject
94759>>>        Integer iSize iCount
94759>>>        
94759>>>        Set Private.pbDatabaseUpdateStarted to False
94760>>>        Get paDbVersionInfoArray to aDbVersionInfoArray
94761>>>        Move (SizeOfArray(aDbVersionInfoArray)) to iSize
94762>>>        Decrement iSize
94763>>>        
94763>>>        For iCount from 0 to iSize
94769>>>>
94769>>>            Move aDbVersionInfoArray[0].hObject to hoDbVersionObject
94770>>>            Send ProcessUpdate                  of hoDbVersionObject False
94771>>>        Loop
94772>>>>
94772>>>        Send Cleanup
94773>>>    End_Procedure
94774>>>    
94774>>>    Procedure StartStatusPanel
94776>>>        Send EnableCancelButton     of ghoStatusPanel (pbEnableCancelButton(Self))
94777>>>        Send Initialize_StatusPanel of ghoStatusPanel ("   " + CS_DUF_WorkingUpdateText) CS_DUF_WorkingHeaderText ""
94778>>>        Send Start_StatusPanel      of ghoStatusPanel
94779>>>    End_Procedure
94780>>>    
94780>>>    // This event is triggered by the cDbUpdateVersion child class when
94780>>>    // a database change is to be started, and is considered private.
94780>>>    // It is only executed once for the first cDbUpateVersion object!
94780>>>    Procedure InitDatabaseUpdate Handle hDbUpdateVersionObject
94782>>>        Boolean bDatabaseUpdateStarted bInUse bExists bCheckDataFlexUserCount
94782>>>        Integer iRetval iDataFlexUsers iUserCount
94782>>>        Handle hoUserCountSystem
94782>>>        tUserCount UserCount
94782>>>        tUserCount UserCount
94782>>>        DateTime dtUpdateStarted
94782>>>        tSQLConnection SQLConnection
94782>>>        tSQLConnection SQLConnection
94782>>>
94782>>>        // *Important:* If we already started the update; we do no further checking.
94782>>>        Get Private.pbDatabaseUpdateStarted to bDatabaseUpdateStarted
94783>>>        If (bDatabaseUpdateStarted = True) Begin
94785>>>            Procedure_Return
94786>>>        End
94786>>>>
94786>>>
94786>>>        // If not silent mode; Ask user if OK to start database update.
94786>>>        If (pbSilentMode(Self) = False) Begin
94788>>>            Get YesNo_Box CS_DUF_DatabaseNeedsUpdate CS_DUF_HeaderUpdateText to iRetval
94789>>>            If (iRetval <> MBR_Yes) Begin
94791>>>                Send Exit_Application
94792>>>            End
94792>>>>
94792>>>        End
94792>>>>
94792>>>        
94792>>>        Send StartStatusPanel
94793>>>        // This will save the status of all open tables including Master/Alias settings,
94793>>>        // so we can restore them later;
94793>>>        Send SaveOpenTables
94794>>>
94794>>>        Move 0 to iDataFlexUsers
94795>>>        // Make various tests to check that the database is not in use.
94795>>>        Get IsDatabaseInUse of hDbUpdateVersionObject to bInUse
94796>>>        // We also use our own user counting mechanism to guard against the
94796>>>        // database isn't opened already as we need exclusive access to the tables.:
94796>>>        Get phoUserCountSystem to hoUserCountSystem
94797>>>        Get CheckUserCount of hoUserCountSystem to UserCount
94798>>>        Get CurrentNumberOfUsers of hoUserCountSystem to iUserCount
94799>>>
94799>>>        Get pbCheckDataFlexUserCount of hoUserCountSystem to bCheckDataFlexUserCount
94800>>>        // Check DataFlex user count to see if anybody else is using the DataFlex license...
94800>>>        If (bCheckDataFlexUserCount = True) Begin
94802>>>            Get_Current_User_Count to iDataFlexUsers
94803>>>            // For some reason DataFlex - in some cases - might think that 2 users
94803>>>            // are in use while debugging from the Studio.
94803>>>            If (IsDebuggerPresent() and iDataFlexUsers = 2) Begin
94805>>>                Decrement iDataFlexUsers
94806>>>            End
94806>>>>
94806>>>        End 
94806>>>>
94806>>>        Else Begin
94807>>>            Move 1 to iDataFlexUsers 
94808>>>            Move 1 to iUserCount
94809>>>            Move False to bInUse
94810>>>        End
94810>>>>
94810>>>
94810>>>        If (pbSilentMode(Self) = False and iDataFlexUsers > 1) Begin
94812>>>            Get YesNo_Box CS_DUF_DatabaseInUseShort to iRetval
94813>>>            If (iRetval <> MBR_Yes) Begin
94815>>>                Send Exit_Application
94816>>>            End
94816>>>>
94816>>>        End
94816>>>>
94816>>>
94816>>>        If (bInUse = True or (UserCount.iError <> 0) or (iUserCount > 1)) Begin
94818>>>            Send Stop_Box CS_DUF_DatabaseInUseText
94819>>>            Send Exit_Application
94820>>>        End
94820>>>>
94820>>>
94820>>>        // This will put a look on the DbUpdateLock.ucf file.
94820>>>        // It is released when the update process is finished
94820>>>        Get CheckUserCount of (phoDatabaseUpdateLock(Self)) to UserCount
94821>>>
94821>>>        Move (CurrentDateTime()) to dtUpdateStarted
94822>>>        Set pdtUpdateStart of (phoLogFile(Self)) to dtUpdateStarted
94823>>>        Set Private.pbDatabaseUpdateStarted to True
94824>>>
94824>>>        // We need to close all tables before starting to make changes.
94824>>>        Close DF_ALL DF_PERMANENT
94825>>>
94825>>>        // If these properties has not exclicitly been set in the object, set them
94825>>>        // to settings from the SQLConnections.ini file;
94825>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
94826>>>        If (psSchema(Self) = "") Begin
94828>>>            Set psSchema            to SQLConnection.sSchema
94829>>>        End
94829>>>>
94829>>>        If (psBaseTableSpace(Self) = "") Begin
94831>>>            Set psBaseTableSpace    to SQLConnection.sBaseTableSpace
94832>>>        End
94832>>>>
94832>>>        If (psLongTableSpace(Self) = "") Begin
94834>>>            Set psLongTableSpace    to SQLConnection.sLongTableSpace
94835>>>        End
94835>>>>
94835>>>        If (psIndexTableSpace(Self) = "") Begin
94837>>>            Set psIndexTableSpace   to SQLConnection.sIndexTableSpace
94838>>>        End
94838>>>>
94838>>>        If (SQLConnection.sDriverID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
94840>>>            Procedure_Return
94841>>>        End
94841>>>>
94841>>>
94841>>>        Get SQLUtilCheckIfDatabaseExists of hDbUpdateVersionObject SQLConnection.sDatabase to bExists
94842>>>        If (SQLConnection.sDatabase <> "" and bExists = False) Begin
94844>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94845>>>            Send Stop_StatusPanel of ghoStatusPanel
94846>>>            // ToDo: NS 2019-09-23 I think we should always show an error message to the user if this occur (!)
94846>>>            Send Stop_Box (CS_DUF_DatabaseConnStringSpec + SQLConnection.sDatabase + CS_DUF_DatabaseDoesntExist )
94847>>>//            Error DFERR_PROGRAM ("The database specified in the connection string: '" + SQLConnection.sDatabase + "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit.")
94847>>>            Send Exit_Application
94848>>>        End
94848>>>>
94848>>>    End_Procedure
94849>>>
94849>>>    // *** Hook message for pre-processing ***
94849>>>    // Event to be used to auto-create a version table when "DUF_Use_Custom_DbVersion" is used.
94849>>>    // Aka, when another table than the standard "DbVersion" is used.
94849>>>    Procedure OnCreateCustomDbVersionTable
94851>>>    End_Procedure
94852>>>    
94852>>>    // *** Hook message for pre-processing ***
94852>>>    // The programmer can use this event for putting code that
94852>>>    // needs to be executed _before_ code in any of the cDbUpdateVersion
94852>>>    // child objects are executed.
94852>>>    Procedure OnPreUpdate
94854>>>    End_Procedure
94855>>>
94855>>>    // *** Hook message for post-processing ***
94855>>>    // The programmer should use this event for putting code that
94855>>>    // needs to be executed _after_ all database updates have finished.
94855>>>    Procedure OnPostUpdate
94857>>>    End_Procedure
94858>>>
94858>>>    // *** Hook message for custom DbVersion record find ***
94858>>>    // The programmer can use this event for putting code that
94858>>>    // needs to be executed to find a *custom* DbVersion table record.
94858>>>    // By default the DbVersion table is used but this can be
94858>>>    // customized by adding this line to the code;
94858>>>    // "Define DUF_Use_Custom_DbVersion" before the line "Use cDbUpdateHandler.pkg"
94858>>>    // Note: You do _not_ need to use this event if the DbVersion table is used
94858>>>    //       to save the current database version to. Only if you use your own
94858>>>    //       table _and_ it is not a system table (contains only one record).
94858>>>    Procedure OnFindVersionRecord
94860>>>        // Open MyTable
94860>>>        // Move xx to MyTable.Field1
94860>>>        // Move yy to MyTable.Field2
94860>>>        // Find le MyTable by Index.x
94860>>>    End_Procedure
94861>>>
94861>>>    // Hook event for writing header error text (pre-update) to
94861>>>    // a datatable. Only called if the pbUseDataTableLog property = True.
94861>>>    // Don't forget to Open the table first (!) as all
94861>>>    // tables have been closed at this stage.
94861>>>    // The start date & time is passed.
94861>>>    Procedure OnErrorWriteHeader_DataTable DateTime dtUpdateStart
94863>>>    End_Procedure
94864>>>
94864>>>    // Hook event to log errors to a database table.
94864>>>    // Only called if the pbUseDataTableLog = True.
94864>>>    // Don't forget to Open the table first (!) as all
94864>>>    // tables have been closed at this stage.
94864>>>    // If pbQuickWrite = True the DbUpdateErrorArray
94864>>>    // will contain just one row, as it is called for each error
94864>>>    // that occurred. Else it is called once at the end after all updates
94864>>>    // have run and contains all errors.
94864>>>    Procedure OnErrorWriteRow_DataTable tDbUpdateError[] DbUpdateErrorArray
94866>>>    End_Procedure
94867>>>
94867>>>    // Automatically send after all processing is done, but before the OnPostUpdate event.
94867>>>    Procedure Cleanup
94869>>>        Boolean bDatabaseWasUpdated bError bUseIntFilesBackup bOK
94869>>>        String sErrorText
94869>>>        
94869>>>        Move "" to sErrorText
94870>>>        Send CheckAutoCreateDbVersionTable
94871>>>        Send RestoreOpenTables
94872>>>
94872>>>        // The function library have two purposes; one is to use it in the
94872>>>        // Database Update Framework, but it can also be used on its own.
94872>>>        // If that is the case it has its own error handling system, which
94872>>>        // we temporarily disbled when running updates because we have
94872>>>        // error handling/logging here too... We now restore its setting.
94872>>>        If (ghoDbUpdateFunctionLibrary > 0) Begin
94874>>>            Set pbHandleQueryErrors of ghoDbUpdateFunctionLibrary to True
94875>>>        End
94875>>>>
94875>>>        Set pbHandleQueryErrors to True
94876>>>
94876>>>        Get pbDatabaseWasUpdated to bDatabaseWasUpdated
94877>>>        Get pbDbUpdateErrorHasOccured to bError
94878>>>        // Note: We make backup of .int files even if an error occured.
94878>>>        If (bDatabaseWasUpdated = True) Begin
94880>>>            // Check/create/update *.int files backup table:
94880>>>            Get pbUseIntFilesBackup to bUseIntFilesBackup
94881>>>            If (bUseIntFilesBackup = True) Begin
94883>>>                Get SaveUpdateIntFiles (&sErrorText) to bOK
94884>>>                If (bOK = False) Begin
94886>>>                    Send LogError sErrorText True
94887>>>                End
94887>>>>
94887>>>                Else If (sErrorText <> "") Begin
94890>>>                    Send LogError sErrorText False
94891>>>                End
94891>>>>
94891>>>            End
94891>>>>
94891>>>        End            
94891>>>>
94891>>>            
94891>>>        If (bDatabaseWasUpdated = True or bError = True) Begin
94893>>>
94893>>>            // We should always create the log as it also contains info about
94893>>>            // the update being successful.
94893>>>            Send WriteErrorLog of (phoLogFile(Self))
94894>>>
94894>>>            // This is a programmer's hook message:
94894>>>            Send OnPostUpdate
94895>>>
94895>>>            Send Stop_StatusPanel of ghoStatusPanel
94896>>>
94896>>>            If (pbSilentMode(Self) = False) Begin
94898>>>                If (bError = True) Begin
94900>>>                    If (pbShowErrorLogPostRun(Self) = True) Begin
94902>>>                        Send ShowErrorLog of (phoLogFile(Self))
94903>>>                    End
94903>>>>
94903>>>                    Send Info_Box CS_DUF_DbUpdatedErrorText
94904>>>                    Send Exit_Application
94905>>>                End
94905>>>>
94905>>>                Else Begin
94906>>>                    If (Private.pbDatabaseWasUpdated(Self) = True) Begin
94908>>>                        Send Info_Box CS_DUF_DatabaseUpdatedText
94909>>>                    End
94909>>>>
94909>>>                    Else Begin
94910>>>                        Send Info_Box CS_DUF_DatabaseCheckedText
94911>>>                    End
94911>>>>
94911>>>                End
94911>>>>
94911>>>            End
94911>>>>
94911>>>        End
94911>>>>
94911>>>
94911>>>        // Restore the standard error handler:
94911>>>        Get piOrgErrorHandlerID to Error_Object_Id
94912>>>    End_Procedure
94913>>>
94913>>>    // We do this _before_ we close the database to make changes, and save
94913>>>    // all 'Master' & 'Alias' tables settings so we can restore when
94913>>>    // we reopen the database.
94913>>>    Procedure SaveOpenTables
94915>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94915>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94916>>>        Get _MasterAndAliasFiles to aDbUpdateHandlerMasterAlias
94917>>>        Set paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
94918>>>    End_Procedure
94919>>>
94919>>>    // Returns a struct array with all currently open tables and a "state" that indicates if the table
94919>>>    // was opened DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER or DF_FILE_IS_ALIAS
94919>>>    Function _MasterAndAliasFiles Returns tDbUpdateHandlerMasterAlias[]
94921>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94921>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94922>>>        Integer hTable iMasterAliasType iSize
94922>>>        Boolean bOpen
94922>>>
94922>>>        Move 0 to hTable
94923>>>        Repeat
94923>>>>
94923>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94926>>>            If (hTable <> 0) Begin
94928>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
94931>>>                If (bOpen = True) Begin
94933>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iMasterAliasType
94936>>>                    Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
94937>>>                    Move hTable to aDbUpdateHandlerMasterAlias[iSize].hTable
94938>>>                    Move iMasterAliasType to aDbUpdateHandlerMasterAlias[iSize].iMode
94939>>>                End
94939>>>>
94939>>>            End
94939>>>>
94939>>>        Until (hTable = 0)
94941>>>
94941>>>        Function_Return aDbUpdateHandlerMasterAlias
94942>>>    End_Function
94943>>>
94943>>>    // Message that re-opens all files in the filelist.cfg and restores any master & alias attributes.
94943>>>    // Takes one parameter:
94943>>>    //   A struct array with all master & alias
94943>>>    Procedure RestoreOpenTables
94945>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94945>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94946>>>        Integer hTable iFileAlias iSize iCount
94946>>>        Boolean bOpen
94946>>>        String sRootName
94946>>>
94946>>>        Move 0 to hTable
94947>>>        Get paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
94948>>>        Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
94949>>>        Decrement iSize
94950>>>        For iCount from 0 to iSize
94956>>>>
94956>>>            Move aDbUpdateHandlerMasterAlias[iCount].hTable to hTable
94957>>>            // We also need to check that the table hasn't been removed...
94957>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
94960>>>            If (hTable <> 0 and sRootName <> "") Begin
94962>>>                Open hTable
94964>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
94967>>>                If (bOpen = True) Begin
94969>>>                    Move aDbUpdateHandlerMasterAlias[iCount].iMode to iFileAlias
94970>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
94972>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_MASTER
94975>>>                    End
94975>>>>
94975>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
94978>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_ALIAS
94981>>>                    End
94981>>>>
94981>>>                End
94981>>>>
94981>>>            End
94981>>>>
94981>>>        Loop
94982>>>>
94982>>>    End_Procedure
94983>>>
94983>>>    // This checks for both duplicate pnVersionNumbers _and_ that
94983>>>    // the cDbVersion object pnVersionNumber's all are consecutive (higher than the previous).
94983>>>    Procedure CheckForDuplicates Number nVersion
94985>>>        tDbVersionInfo[] DbVersionInfoArray
94985>>>        tDbVersionInfo[] DbVersionInfoArray
94986>>>        Integer iCount iSize iHits iDuplicateIndex
94986>>>        Number nCompare
94986>>>        Handle hObject1 hObject2
94986>>>        String sObjectName1 sObjectName2
94986>>>        Boolean bObjectOrderError
94986>>>
94986>>>        Get paDbVersionInfoArray to DbVersionInfoArray
94987>>>        Move (SizeOfArray(DbVersionInfoArray)) to iSize
94988>>>        Decrement iSize
94989>>>        Move 0 to iHits
94990>>>        Move 0 to nCompare
94991>>>        Move False to bObjectOrderError
94992>>>        For iCount from 0 to iSize
94998>>>>
94998>>>            If (nVersion = DbVersionInfoArray[iCount].nVersionNumber) Begin
95000>>>                Increment iHits
95001>>>                If (iHits > 1) Begin
95003>>>                    Move iCount to iDuplicateIndex
95004>>>                    If (nCompare <> 0) Begin
95006>>>                        Move (nCompare >= DbVersionInfoArray[iCount].nVersionNumber) to bObjectOrderError
95007>>>                    End
95007>>>>
95007>>>                End
95007>>>>
95007>>>            End
95007>>>>
95007>>>            Move DbVersionInfoArray[iCount].nVersionNumber to nCompare
95008>>>        Loop
95009>>>>
95009>>>        If (iHits > 1) Begin
95011>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
95012>>>            Move DbVersionInfoArray[(iDuplicateIndex   )].hObject to hObject1
95013>>>            Move DbVersionInfoArray[(iDuplicateIndex -1)].hObject to hObject2
95014>>>            Move (Name(hObject1)) to sObjectName1
95015>>>            Move (Name(hObject2)) to sObjectName2
95016>>>            Error DFERR_PROGRAM ("Duplicate version numbers! The SAME pnVersionNumber value was set for the following two objects; Program will now exit!\n\n" + sObjectName1 + "\n" + sObjectName2)
95017>>>>
95017>>>            Send Exit_Application
95018>>>        End
95018>>>>
95018>>>        Else If (bObjectOrderError = True) Begin
95021>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
95022>>>            Error DFERR_PROGRAM ("cDbVersion objects out of order! One or more of the cDbVersion objects has been placed out of order. This means that at least one pnVersionNumber is HIGHER than the following object's pnVersionNumber.\nProgram will now exit!")
95023>>>>
95023>>>            Send Exit_Application
95024>>>        End
95024>>>>
95024>>>    End_Procedure
95025>>>
95025>>>    // We take care of all errors in the Error_Report below and
95025>>>    // collect them all to an array property. So just ignore any
95025>>>    // "Ignore_Error" & "Trap_Error" messages that might be send/used
95025>>>    // in some other package.
95025>>>    Procedure Ignore_Error Integer iError
95027>>>    End_Procedure
95028>>>
95028>>>    Procedure Trap_Error Integer iError
95030>>>    End_Procedure
95031>>>
95031>>>    // Build complete error description from Flexerrs and user error message.
95031>>>    Function Error_Description Integer Error# String ErrMsg Returns String
95033>>>        String Full_Error_Text
95033>>>        
95033>>>        Move (Trim(ErrMsg)) to ErrMsg
95034>>>        Move (Trim(Error_Text(DESKTOP, Error#))) to Full_Error_Text
95035>>>        
95035>>>        If (ErrMsg <> "") Begin
95037>>>            
95037>>>            If ((Full_Error_Text<>"" ) and ;                Error_Text_Available( DESKTOP, Error# ) ) Begin
95039>>>                // Make sure last character of error text is a separating symbol.
95039>>>                // if not, add a "." So we have format of "error-text. error-detail"
95039>>>                If (Pos(Right(Full_Error_Text,1),".,:;") =0) ;                    Move (Full_Error_Text - ".") to Full_Error_Text
95042>>>                Move (Full_Error_Text * ErrMsg)  to Full_Error_Text
95043>>>            End
95043>>>>
95043>>>            Else ;                Move ErrMsg to Full_Error_Text
95045>>>            
95045>>>        End
95045>>>>
95045>>>        
95045>>>        Function_Return Full_Error_Text
95046>>>    End_Function
95047>>>
95047>>>    // While we update the database we collect all errors in
95047>>>    // the struct array paDbUpdateErrorArray.
95047>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
95049>>>        Number nVersion
95049>>>        Handle hoLogFile 
95049>>>        
95049>>>        If (Private.pbProcessingError(Self)) Begin
95051>>>            Procedure_Return
95052>>>        End
95052>>>>
95052>>>
95052>>>        // The UtilTableNameFromHandleToString function does a:
95052>>>        // "Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName" call
95052>>>        // and it generates an error if the table is of the embedded type.
95052>>>        // As we don't want to trigger an error in that very specific case,
95052>>>        // we just ignore it here.
95052>>>        //
95052>>>        // If no report mode, just set the err indicator to false.
95052>>>        If (Error_Report_Mode(Self) = DUF_ERROR_NO_REPORT) Begin
95054>>>            Set Private.pbProcessingError to False
95055>>>            Procedure_Return
95056>>>        End
95056>>>>
95056>>>
95056>>>        If (iErrorNumber = DFERR_UNSUPPORTED_ATTRIBUTE) Begin
95058>>>            Set Private.pbProcessingError to False
95059>>>            Procedure_Return
95060>>>        End
95060>>>>
95060>>>
95060>>>        Set Private.pbProcessingError to True
95061>>>        Set Private.pbUpdateVersionObjectError to True
95062>>>
95062>>>        Set pbDbUpdateErrorHasOccured to True
95063>>>        Get pnCurrentVersionUpdate to nVersion
95064>>>        Get phoLogFile to hoLogFile
95065>>>        Send LogError of hoLogFile nVersion iErrorNumber sErrorText iErrorLine True
95066>>>
95066>>>        Set Private.pbProcessingError to False
95067>>>    End_Procedure
95068>>>
95068>>>End_Class
95069>
95069>Object oHtmlHelp is a cHtmlHelp
95071>    Set pbAlwaysOnTop to False
95072>
95072>    // Overriden class message to also handle internet HTML Help links;
95072>    // which in which case we should not try to find the path to the help file.
95072>    Function GetHelpFile Returns String
95075>        String sHelpFile
95075>
95075>        Get psHelpFile of ghoApplication to sHelpFile
95076>        If (sHelpFile <> "" and not(sHelpFile contains "http:")) Begin
95078>            Get_File_Path sHelpFile to sHelpFile
95079>        End
95079>        Function_Return sHelpFile
95080>    End_Function
95081>
95081>End_Object
95082>
95082>Object oApplication is a cApplication
95084>    Set peHelpType to htHtmlHelp
95085>
95085>    // Note: These help file settings gets changed by the Help toolbar button(s).
95085>    Set psHelpFile to "Developer5.chm"
95086>
95086>    Set pbPreserveEnvironment to True
95087>    Set psProduct to "Database Update Framework Lab"
95088>    Set psCompany to "RDC Tools International" 
95089>
95089>    Object oConnection is a cConnection
95091>        Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (C:\Program Files\DataFlex 24.0\Pkg\LoginEncryption.pkg)
95091>>>Use cLoginEncryption.pkg
95091>>>
95091>>>Object oLoginEncryption is a cLoginEncryption
95093>>>
95093>>>    // this must be created in your appsrc directory and must contain an encryption
95093>>>    // key that is set to psEncryptPassword. It will look something like this
95093>>>    //
95093>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
95093>>>    //  
Including file: LoginEncryptionKey.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\LoginEncryptionKey.inc)
95093>>>>// Studio generated login encryption key
95093>>>>Set psEncryptPassword to "%sLm*XHVF>f0yB.:.PHrBx6L)8x70i7zAN{q._WC"
95094>>>>
95094>>>    
95094>>>    // use this to register this object to your cConnection Object. This object
95094>>>    // must be created after the cConnection object
95094>>>    Move Self to ghoLoginEncryption
95095>>>End_Object
95096>        Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (C:\Program Files\DataFlex 24.0\Pkg\DatabaseLoginDialog.dg)
95096>>>
95096>>>Use Windows.pkg
95096>>>Use cConnection.pkg
95096>>>Use dfLine.pkg
95096>>>
95096>>>Object oDatabaseLoginDialog is a ModalPanel
95098>>>    Set Label to "Database Login"
95099>>>    Set Location to 2 2
95100>>>    Set Size to 110 211
95101>>>    
95101>>>    Property String psId
95103>>>    Property Boolean pbOk False
95105>>>    Property Boolean pbChanged False
95107>>>    Property Boolean pbAllowRemember True
95109>>>    
95109>>>    // this registers this object with the cConnection object.
95109>>>    Move Self to ghoLoginConnectDialog
95110>>>    
95110>>>    Object oUserIDForm is a Form
95112>>>        Set Label to "User Name"
95113>>>        Set Size to 12 85
95114>>>        Set Location to 34 79
95115>>>        Set Label_Col_Offset to 64
95116>>>        Set peAnchors to anTopLeftRight
95117>>>    End_Object
95118>>>    
95118>>>    Object oPwdForm is a Form
95120>>>        Set Size to 12 85
95121>>>        Set Location to 49 79
95122>>>        Set Label_Col_Offset to 64
95123>>>        Set Password_State to True
95124>>>        Set peAnchors to anTopLeftRight
95125>>>        Set Label to "Password"
95126>>>    End_Object
95127>>>    
95127>>>    Object oTrustedConnection is a CheckBox
95129>>>        Set Size to 10 50
95130>>>        Set Location to 65 79
95131>>>        Set Label to "Trusted Connection"
95132>>>    End_Object
95133>>>    
95133>>>    Object oRemember is a CheckBox
95135>>>        Set Size to 10 50
95136>>>        Set Location to 79 14
95137>>>        Set Label to "Remember and don't ask again"
95138>>>        Set Checked_State to True
95139>>>    End_Object
95140>>>    
95140>>>    Object oLogin_btn is a Button
95142>>>        Set Label to "&Login"
95143>>>        Set Location to 92 102
95144>>>        Set peAnchors to anBottomRight
95145>>>        Set Default_State to True
95146>>>        
95146>>>        Procedure OnClick
95149>>>            Boolean bTrust
95149>>>            String sUser sPwd sConn sErr sId
95149>>>            Integer iError
95149>>>            Get psId to sId
95150>>>            Get Value of oUserIDForm to sUser
95151>>>            Get Value of oPwdForm to sPwd
95152>>>            Get Checked_State of oTrustedConnection to bTrust
95153>>>            
95153>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
95154>>>            If (iError=0) Begin
95156>>>                Set pbOk to True
95157>>>                Set pbChanged to True
95158>>>                Send Close_Panel
95159>>>            End
95159>>>>
95159>>>            Else Begin
95160>>>                Get psErrorText of ghoConnection to sErr
95161>>>                Send UserError sErr "Login Error"
95162>>>            End
95162>>>>
95162>>>        End_Procedure
95163>>>    End_Object
95164>>>    
95164>>>    Object oCancel_btn is a Button
95166>>>        Set Label to "&Cancel"
95167>>>        Set Location to 92 157
95168>>>        Set peAnchors to anBottomRight
95169>>>        
95169>>>        Procedure OnClick
95172>>>            Send Close_Panel
95173>>>        End_Procedure
95174>>>    End_Object
95175>>>    
95175>>>    Object oConnectionIdInfo is a TextBox
95177>>>        Set Size to 10 50
95178>>>        Set Location to 4 14
95179>>>        Set Label to 'Connection Id='
95180>>>    End_Object
95181>>>    
95181>>>    Object oConnectionServerInfo is a TextBox
95183>>>        Set Size to 10 50
95184>>>        Set Location to 16 14
95185>>>        Set Label to 'Server'
95186>>>    End_Object
95187>>>    
95187>>>    Object oLineControl1 is a LineControl
95189>>>        Set Size to 2 202
95190>>>        Set Location to 29 5
95191>>>    End_Object
95192>>>    
95192>>>    Function LoginConnectIdDialog String sId Returns Boolean
95195>>>        Boolean bOk bChanged bTrusted bAllowRemember bRemember
95195>>>        String sUser sPwd sDescription
95195>>>        tConnection Connect
95195>>>        tConnection Connect
95195>>>        
95195>>>        Get pbAllowRemember to bAllowRemember
95196>>>        
95196>>>        
95196>>>        If not bAllowRemember Begin
95198>>>            Set Enabled_State of oRemember to bRemember
95199>>>            Set Visible_State of oRemember to bRemember
95200>>>        End
95200>>>>
95200>>>        
95200>>>        Get ConnectionIdInfo of ghoConnection sId to Connect
95201>>>        Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
95202>>>        Set Value of oConnectionServerInfo to Connect.sString
95203>>>        
95203>>>        Set psId to sId
95204>>>        Set pbOk to False
95205>>>        Set pbChanged to False
95206>>>        Set Value of oUserIDForm to Connect.sUID
95207>>>        Set Value of oPwdForm to ""
95208>>>        
95208>>>        Send Popup
95209>>>        
95209>>>        Get pbOk to bOk
95210>>>        Get pbChanged to bChanged
95211>>>        If (bChanged and bOk) Begin
95213>>>            If bAllowRemember Begin
95215>>>                Get Checked_State of oRemember to bRemember
95216>>>                If bRemember Begin
95218>>>                    Get Checked_State of oTrustedConnection to bTrusted
95219>>>                    If not (bTrusted) Begin
95221>>>                        Get Value of oUserIDForm to sUser
95222>>>                        Get Value of oPwdForm to sPwd
95223>>>                    End
95223>>>>
95223>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
95224>>>                End
95224>>>>
95224>>>            End
95224>>>>
95224>>>        End
95224>>>>
95224>>>        Function_Return bOk
95225>>>    End_Function
95226>>>    
95226>>>    
95226>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
95227>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
95228>>>End_Object
95229>>>
95229>    End_Object
95230>
95230>End_Object   
95231>
95231>Object oDbUpdateHandler is a cDbUpdateHandler 
95233>    Set piDbVersionFileNumber to 255
95234>    Set piDbVersionFieldNumber to 1
95235>    
95235>End_Object
95236>
95236>Object oCJSkinFramework is a cCJSkinFramework
95238>    Set pbLoadPreference to True
95239>End_Object
95240>
95240>Object oToolTipController is a cToolTipController
95242>    Set piDurationPopup to 10000
95243>    Set piMaxWidth to 500
95244>    Move Self to ghoToolTipController
95245>End_Object
95246>
95246>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files\DataFlex 24.0\Pkg\oEditContextMenu.pkg)
95246>>>Use cCJStandardMenuItemClasses.pkg
95246>>>
95246>>>Object oEditContextMenu is a cCJContextMenu
95248>>>    
95248>>>    Move Self to Default_Form_Floating_Menu_ID
95249>>>    
95249>>>    Object oUndoMenuItem is a cCJUndoMenuItem
95251>>>    End_Object
95252>>>    
95252>>>    Object oCutMenuItem is a cCJCutMenuItem
95254>>>        Set pbControlBeginGroup to True
95255>>>    End_Object
95256>>>    
95256>>>    Object oCopyMenuItem is a cCJCopyMenuItem
95258>>>    End_Object
95259>>>
95259>>>    Object oPasteMenuItem is a cCJPasteMenuItem
95261>>>    End_Object
95262>>>
95262>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
95264>>>    End_Object
95265>>>
95265>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
95267>>>        Set pbControlBeginGroup to True
95268>>>    End_Object
95269>>>
95269>>>End_Object
95270>>>
95270>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files\DataFlex 24.0\Pkg\oDEOEditContextMenu17.pkg)
95270>>>Use Windows.pkg
95270>>>Use cCJStandardMenuItemClasses.pkg
95270>>>Use cCJDeoMenuItemClasses.pkg
95270>>>
95270>>>
95270>>>Object oDEOEditContextMenu17 is a cCJContextMenu
95272>>>    
95272>>>    Move Self to Default_dbFloating_Menu_ID
95273>>>    
95273>>>    Object oUndoMenuItem is a cCJUndoMenuItem
95275>>>    End_Object
95276>>>    
95276>>>    Object oCutMenuItem is a cCJCutMenuItem
95278>>>        Set pbControlBeginGroup to True
95279>>>    End_Object
95280>>>    
95280>>>    Object oCopyMenuItem is a cCJCopyMenuItem
95282>>>    End_Object
95283>>>
95283>>>    Object oPasteMenuItem is a cCJPasteMenuItem
95285>>>    End_Object
95286>>>
95286>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
95288>>>    End_Object
95289>>>
95289>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
95291>>>        Set pbControlBeginGroup to True
95292>>>    End_Object
95293>>>
95293>>>    Object oPromptMenuItem is a cCJPromptMenuItem
95295>>>        Set pbControlBeginGroup to True
95296>>>    End_Object
95297>>>
95297>>>    Object oFindNextMenu is a cCJFindNextMenuItem
95299>>>        Set pbControlBeginGroup to True
95300>>>    End_Object
95301>>>
95301>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
95303>>>    End_Object
95304>>>
95304>>>    Object oClearMenuItem is a cCJClearMenuItem
95306>>>        Set pbControlBeginGroup to True
95307>>>    End_Object
95308>>>
95308>>>    Object oClearAllMenu is a cCJClearAllMenuItem
95310>>>    End_Object
95311>>>
95311>>>    Object oSaveMenu is a cCJSaveMenuItem
95313>>>    End_Object
95314>>>    
95314>>>    Object oDeleteMenu is a cCJDeleteMenuItem
95316>>>    End_Object
95317>>>
95317>>>    Object oRememberitem is a cCJRememberFieldMenuItem
95319>>>        Set pbControlBeginGroup to True
95320>>>    End_Object
95321>>>
95321>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
95323>>>    End_Object
95324>>>
95324>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
95326>>>    End_Object
95327>>>
95327>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
95329>>>    End_Object
95330>>>
95330>>>End_Object
95331>Use cSkinComboBoxCJMenuItem.pkg
Including file: cSkinComboBoxCJMenuItem.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cSkinComboBoxCJMenuItem.pkg)
95331>>>Use cCJCommandBarSystem.pkg
95331>>>Use Wingdi.pkg
95331>>>Use LanguageText.pkg
95331>>>
95331>>>// User interface constant strings:
95331>>>Define CS_NoSkinShort For "-None"
95331>>>Define CS_NoSkinLong  For "Do not use a skin"
95331>>>
95331>>>
95331>>>
95331>>>
95331>>>
95331>>>
95331>>>
95331>>>
95331>>>
95331>>>
95331>>>Class cSkinComboBoxCJMenuItem is a cCJMenuItem
95332>>>
95332>>>    Procedure Construct_Object
95334>>>        Forward Send Construct_Object
95336>>>
95336>>>        Set peControlType to xtpControlComboBox
95337>>>
95337>>>        Property tSkinInformation[] pSkins
95338>>>
95338>>>    End_Procedure
95339>>>
95339>>>    Procedure End_Construct_Object
95341>>>        Forward Send End_Construct_Object
95343>>>    End_Procedure
95344>>>
95344>>>    // Custom array sort for the tSkinInformation struct array.
95344>>>    // Used by LoadSkins message to sort the skin array alphabetically after it has been loaded.
95344>>>    // Why?
95344>>>    // First of all, structs can't be used with the standard SortArray function, that is why we need to
95344>>>    // create a custom sort algorithm.
95344>>>    // Secondly the list of skins would else be sorted in the alphabetical order by the file names.
95344>>>    // However, it is not always the case that the skin description (sName) is the same as the file name.
95344>>>    // If it isn't (which is almost always the case if you have many skin files) the list will look
95344>>>    // randomly ordered. This custom sort method will take care of that.
95344>>>    Function SkinSort tSkinInformation sDescription tSkinInformation sSearchDescription Returns Integer
95346>>>        If ((sDescription.sName * sDescription.sSkinIni) > (sSearchDescription.sName * sSearchDescription.sSkinIni)) Begin
95348>>>            Function_Return (GT)
95349>>>        End
95349>>>>
95349>>>        If ((sDescription.sName * sDescription.sSkinIni) < (sSearchDescription.sName * sSearchDescription.sSkinIni)) Begin
95351>>>            Function_Return (LT)
95352>>>        End
95352>>>>
95352>>>        Function_Return (EQ)
95353>>>    End_Function
95354>>>
95354>>>    Procedure OnCreateControl Handle hoObj
95356>>>        Forward Send OnCreateControl hoObj
95358>>>
95358>>>        Send LoadSkins
95359>>>        Send FillComboList hoObj
95360>>>    End_Procedure
95361>>>
95361>>>    // Load all skins. We will only look for skins in expected
95361>>>    // directory which is the Programs folder.
95361>>>    // Important: When loading skins they will be sorted alphabetically. (See Skinsort function above).
95361>>>    // This is not the case with the 'standard' VDF behaviour.
95361>>>    Procedure LoadSkins
95363>>>        Integer iCount iItems iSize
95363>>>        Boolean bFound
95363>>>        String sFile sIni sSkin
95363>>>        tSkinInformation[] SkinsArray SkinsArrayNoLarge
95363>>>        tSkinInformation[] SkinsArray SkinsArrayNoLarge
95365>>>        tSkinInformation NoneRow
95365>>>        tSkinInformation NoneRow
95365>>>
95365>>>        If (ghoSkinFramework > 0) Begin
95367>>>            Get EnumerateSkins of ghoSkinFramework "" True   to SkinsArray
95368>>>
95368>>>            Move (SortArray(SkinsArray, Self, get_SkinSort)) to SkinsArray
95369>>>            Move CS_NoSkinShort to NoneRow.sName
95370>>>            Move CS_NoSkinLong  to NoneRow.sSkinfile
95371>>>            Move CS_NoSkinLong  to NoneRow.sSkinIni
95372>>>            Move (InsertInArray(SkinsArray, 0, NoneRow))     to SkinsArray
95373>>>
95373>>>            // Get the currently loaded skin.
95373>>>            Get psSkinFile of ghoSkinFramework to sFile
95374>>>            Get psSkinIni  of ghoSkinFramework to sIni
95375>>>
95375>>>            // Remove all Extra Large and Large skins from the array.
95375>>>            Move (SizeOfArray(SkinsArray)) to iItems
95376>>>            Decrement iItems
95377>>>            For iCount From 0 to iItems
95383>>>>
95383>>>                Move SkinsArray[iCount].sSkinIni to sSkin
95384>>>                Move (Uppercase(sSkin) contains " LARGE") to bFound
95385>>>                If (bFound = False) Begin
95387>>>                    Move (SizeOfArray(SkinsArrayNoLarge)) to iSize
95388>>>                    Move SkinsArray[iCount].sName         to SkinsArrayNoLarge[iSize].sName
95389>>>                    Move SkinsArray[iCount].sSkinfile     to SkinsArrayNoLarge[iSize].sSkinfile
95390>>>                    Move SkinsArray[iCount].sSkinIni      to SkinsArrayNoLarge[iSize].sSkinIni
95391>>>                End
95391>>>>
95391>>>            Loop
95392>>>>
95392>>>            Set pSkins to SkinsArrayNoLarge
95393>>>        End
95393>>>>
95393>>>    End_Procedure
95394>>>
95394>>>    // Fills the CodeJock combobox with all skins from the current Programs folder.
95394>>>    Procedure FillComboList Handle hoCombo
95396>>>        Integer iCount iItems iCurrent iTxtEntentSize
95396>>>        String  sFile sIni sCurrSkin
95396>>>        String  sSkin sSkinText
95396>>>        tSkinInformation[] SkinsArray
95396>>>        tSkinInformation[] SkinsArray
95397>>>        Integer iSize
95397>>>
95397>>>        If (ghoSkinFramework < 1) Begin
95399>>>            Procedure_Return
95400>>>        End
95400>>>>
95400>>>
95400>>>        // Get the currently loaded skin.
95400>>>        Get psSkinFile of ghoSkinFramework to sFile
95401>>>        Get psSkinIni  of ghoSkinFramework to sIni
95402>>>        Get pSkins to SkinsArray
95403>>>        Move (SizeOfArray(SkinsArray)) to iItems
95404>>>        Decrement iItems
95405>>>        Send ComClear of hoCombo
95406>>>
95406>>>        For iCount From 0 to iItems
95412>>>>
95412>>>            Move SkinsArray[iCount].sSkinIni  to sSkin
95413>>>            Move (Replace(".ini", sSkin, "")) to sSkin
95414>>>            Move (SkinsArray[iCount].sName * "-" * sSkin) to sSkinText
95415>>>            Send ComAddItem of hoCombo sSkinText (iCount +1)
95416>>>            Get Text_Extent sSkinText to iSize
95417>>>            If (iSize > iTxtEntentSize) Begin
95419>>>                Move iSize to iTxtEntentSize
95420>>>            End
95420>>>>
95420>>>            Move (SkinsArray[iCount].sSkinFile * "-" * SkinsArray[iCount].sSkinIni) to sCurrSkin
95421>>>            If (sCurrSkin = (sFile * "-" * sIni)) Begin
95423>>>                Move iCount to iCurrent
95424>>>            End
95424>>>>
95424>>>        Loop
95425>>>>
95425>>>
95425>>>        Move (Low(iTxtEntentSize) + 30)  to iSize
95426>>>        Set ComDropDownWidth of hoCombo  to iSize
95427>>>        Set ComWidth         of hoCombo  to (iSize + 100)
95428>>>        Set ComListIndex     of hoCombo  to (iCurrent +1)
95429>>>    End_Procedure
95430>>>
95430>>>    // Event for when an item is selected from the comboform
95430>>>    Procedure OnExecute Variant vCommandBarControl
95432>>>        Handle  hoCombo
95432>>>        Integer iSelection
95432>>>        String  sSkinFile sSkinIni
95432>>>        tSkinInformation[] SkinsArray
95432>>>        tSkinInformation[] SkinsArray
95433>>>
95433>>>        // Create and bind proxy control
95433>>>        Get CreateProxyControl vCommandBarControl to hoCombo
95434>>>        // Get the current selection
95434>>>        Get ComListIndex of hoCombo to iSelection
95435>>>        Decrement iSelection
95436>>>        Get pSkins to SkinsArray
95437>>>        Move SkinsArray[iSelection].sSkinfile to sSkinFile
95438>>>        Move SkinsArray[iSelection].sSkinIni  to sSkinIni
95439>>>
95439>>>        Send DoChangeSkin sSkinFile sSkinIni
95440>>>
95440>>>        // Dispose of the proxy control
95440>>>        Send Destroy of hoCombo
95441>>>    End_Procedure
95442>>>
95442>>>    // Send this message to change the current skin.
95442>>>    Procedure DoChangeSkin String sSkinFile String sSkinIni
95444>>>        Handle hoClient
95444>>>
95444>>>        Set psSkinFile of ghoSkinFramework to sSkinFile
95445>>>        Set psSkinIni  of ghoSkinFramework to sSkinIni
95446>>>        Send ApplySkin of ghoSkinFramework
95447>>>
95447>>>        // Note: The following line is essential for the resizing logic
95447>>>        // to function properly when changing a skin and a view is maximized.
95447>>>        Move (Client_Id(phoMainPanel(ghoApplication))) to hoClient
95448>>>        Set Size of hoClient to (Hi(Size(hoClient))) (Low(Size(hoClient) +2))
95449>>>        Set Size of hoClient to (Hi(Size(hoClient))) (Low(Size(hoClient) -2))
95450>>>    End_Procedure
95451>>>
95451>>>    // Returns: DPI setting as an integer.
95451>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
95451>>>    //                      iDPI=120 is "Medium setting" 125%
95451>>>    //                      iDPI= 144 is "Large setting" 150%
95451>>>    Function GetCurrentDPI Returns Integer
95453>>>        Handle hDC
95453>>>        Integer iPixelsX
95453>>>        Move (GetDC(0)) to hDC
95454>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
95455>>>        Move (ReleaseDC(0, hDC)) to hDC
95456>>>        Function_Return iPixelsX
95457>>>    End_Function
95458>>>
95458>>>End_Class
95459>
95459>Object oMain is a Panel
95461>    Set Label to "Test Program - The Database Update Framework"
95462>    Set Location to 2 2
95463>    Set Size to 309 493
95464>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
95465>    Set Icon to "TestTools.ico"
95466>
95466>    Property Handle phoViewMenu 0
95468>    Property Handle phoReportMenu 0
95470>
95470>    Object oCommandBarSystem is a cCJCommandBarSystem
95472>        Set pbTimerUpdate to True
95473>            Set pbAutoResizeIcons to True
95474>            Set pbTabbedWorkspaces to True // Switch on for DF 19 to see the new tabbed-view look.
95475>            Set peVisualTheme to xtpThemeOffice2013Publisher
95476>            Set pbLargeIcons to True
95477>
95477>        Procedure OnCreateCommandBars
95480>            Handle hoOptions
95480>            Forward Send OnCreateCommandBars
95482>                Get OptionsObject to hoOptions
95483>                Send ComSetIconSize of hoOptions False 32 32  // Set icon size for Toolbar buttons.
95484>        End_Procedure
95485>
95485>
95485>    Procedure OnCreateTabbedWorkspace Handle hoTabWorkspace Handle hoTabPaintManager
95488>        Set ComShowIcons of hoTabPaintManager to True
95489>
95489>        // This will truncate the middle part of long items
95489>        Set ComDrawTextPathEllipsis of hoTabPaintManager to True
95490>    End_Procedure
95491>
95491>        // This is needed to get the "Key_Shift+Key_Tab" key combination to activate
95491>        // the previous tab workspace view.
95491>        Object oPreviousTabAction is a cCJAction
95493>            Set piShortCutKey to (xtpKey_Shift + xtpKey_Ctrl) VK_TAB
95494>            Procedure OnExecute Variant vCommandBarControl
95497>                Handle hoCommandBars hoClientArea
95497>                Forward Send OnExecute vCommandBarControl
95499>                Get CommandBarSystemObject to hoCommandBars
95500>                Get ClientAreaObject of hoCommandBars to hoClientArea
95501>                If hoClientArea Begin
95503>                    Send Switch_Next_View of hoClientArea
95504>                End
95504>            End_Procedure
95505>        End_Object
95506>
95506>        Object oToolBar is a cCJToolbar
95508>            Set psTitle to "Edit Toolbar"
95509>            Set pbGripper to False
95510>            Set peStretched to stStretch
95511>
95511>            Object oCutToolbarItem is a cCJCutMenuItem  
95513>                Set psImage to "ActionCut1.ico"
95514>            End_Object
95515>
95515>            Object oCopyToolbarItem is a cCJCopyMenuItem
95517>                Set psImage to "ActionCopy1.ico"
95518>            End_Object
95519>
95519>            Object oPasteToolbarItem is a cCJPasteMenuItem
95521>                Set psImage to "ActionPaste1.ico"
95522>            End_Object
95523>
95523>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
95525>                Set psImage to "ActionDelete1.ico"
95526>                Set pbControlBeginGroup to True
95527>            End_Object
95528>
95528>            Object oTheme_tb is a cCJMenuItem
95530>                Set peControlType to xtpControlLabel
95531>                Set psCaption to "Theme:"
95532>                Set pbControlBeginGroup to True
95533>            End_Object
95534>
95534>            Object oThemeItem is a cCJMenuItem
95536>                Set peControlType to xtpControlComboBox
95537>                Set psToolTip to "Select a theme to change the appearance of menu- and toolbars."
95538>
95538>                Procedure OnCreateControl Handle hoObj
95541>                    Integer iItem eTheme
95541>                    Set ComWidth of hoObj to 250
95542>                    Send FillComboList hoObj
95543>                    Get peVisualTheme to eTheme
95544>                    Get FindDataItem hoObj eTheme to iItem
95545>                    Set ComListIndex of hoObj to (If(iItem,iItem,1))
95546>                End_Procedure
95547>
95547>                Function FindDataItem Handle hoCombo Integer eVal Returns Integer
95550>                    Integer iCount i eTheme
95550>                    Get ComListCount of hoCombo to iCount
95551>                    For i from 1 to iCount
95557>                        Get ComItemData of hoCombo i to eTheme
95558>                        If (eTheme=eVal) Begin
95560>                            Send SetTheTheme eTheme
95561>                            Function_Return i
95562>                        End
95562>                    Loop
95563>                    Function_Return 0
95564>                End_Function
95565>
95565>                Procedure AddTheme Handle hoCombo String sText Integer eTheme
95568>                    Integer iCount
95568>                    Get ComListCount of hoCombo to iCount
95569>                    Increment iCount
95570>                    Send ComAddItem  of hoCombo sText iCount
95571>                    Set ComItemData  of hoCombo iCount to  eTheme
95572>                End_Procedure
95573>
95573>                Procedure FillComboList Handle hoCombo
95576>                    Send ComClear     of hoCombo
95577>                        Send AddTheme hoCombo "xtpThemeOffice2013Word" xtpThemeOffice2013Word
95578>                        Send AddTheme hoCombo "xtpThemeOffice2013Outlook" xtpThemeOffice2013Outlook
95579>                        Send AddTheme hoCombo "xtpThemeOffice2013Excel" xtpThemeOffice2013Excel
95580>                        Send AddTheme hoCombo "xtpThemeOffice2013PowerPoint" xtpThemeOffice2013PowerPoint
95581>                        Send AddTheme hoCombo "xtpThemeOffice2013Publisher" xtpThemeOffice2013Publisher
95582>                        Send AddTheme hoCombo "xtpThemeOffice2013OneNote" xtpThemeOffice2013OneNote
95583>                        Send AddTheme hoCombo "xtpThemeOffice2013Access" xtpThemeOffice2013Access
95584>                        Send AddTheme hoCombo "xtpThemeOffice2003" xtpThemeOffice2003
95585>                        Send AddTheme hoCombo "xtpThemeOffice2000" xtpThemeOffice2000
95586>                        Send AddTheme hoCombo "xtpThemeOfficeXP" xtpThemeOfficeXP
95587>    
95587>                        Send AddTheme hoCombo "xtpThemeOffice2010Blue" xtpThemeOffice2010Blue
95588>                        Send AddTheme hoCombo "xtpThemeOffice2010Black" xtpThemeOffice2010Black
95589>                        Send AddTheme hoCombo "xtpThemeOffice2010Silver" xtpThemeOffice2010Silver
95590>    
95590>                        Send AddTheme hoCombo "xtpThemeOffice2007Aqua" xtpThemeOffice2007Aqua
95591>                        Send AddTheme hoCombo "xtpThemeOffice2007Black" xtpThemeOffice2007Black
95592>                        Send AddTheme hoCombo "xtpThemeOffice2007Blue" xtpThemeOffice2007Blue
95593>                        Send AddTheme hoCombo "xtpThemeOffice2007Silver" xtpThemeOffice2007Silver
95594>    
95594>                        Send AddTheme hoCombo "xtpThemeVisualStudio2015Blue" xtpThemeVisualStudio2015Blue
95595>                        Send AddTheme hoCombo "xtpThemeVisualStudio2015Light" xtpThemeVisualStudio2015Light
95596>                        Send AddTheme hoCombo "xtpThemeVisualStudio2015Dark" xtpThemeVisualStudio2015Dark
95597>    
95597>                        Send AddTheme hoCombo "xtpThemeVisualStudio2012Light" xtpThemeVisualStudio2012Light
95598>                        Send AddTheme hoCombo "xtpThemeVisualStudio2012Dark" xtpThemeVisualStudio2012Dark
95599>    
95599>                        Send AddTheme hoCombo "xtpThemeVisualStudio2008" xtpThemeVisualStudio2008
95600>                        Send AddTheme hoCombo "xtpThemeVisualStudio6" xtpThemeVisualStudio6
95601>    
95601>                        Send AddTheme hoCombo "xtpThemeWindows7" xtpThemeWindows7
95602>    
95602>                        Send AddTheme hoCombo "xtpThemeWhidbey" xtpThemeWhidbey
95603>    
95603>                        Send AddTheme hoCombo "xtpThemeNativeWinXP" xtpThemeNativeWinXP
95604>                End_Procedure
95605>
95605>                Function CurrentTheme Handle vCommandBarControl Returns Integer
95608>                    Handle hMessage hoCombo
95608>                    Integer iIndex
95608>                    // create and bind  proxy control
95608>                    Get CreateProxyControl vCommandBarControl to hoCombo
95609>                    // get the current selection
95609>                    Get ComListIndex of hoCombo to iIndex
95610>                    // note the index selections are 1 based
95610>                    If (iIndex > 0) Begin
95612>                        // get the ItemData for the selected item and send that message
95612>                        Get ComItemData of hoCombo iIndex to hMessage
95613>                        Function_Return hMessage
95614>                    End
95614>                    // dispose of the proxy control
95614>                    Send Destroy of hoCombo
95615>                    Function_Return 0
95616>                End_Function
95617>
95617>                Procedure OnExecute Variant vCommandBarControl
95620>                    Integer eTheme
95620>                    Integer iColor
95620>                    Get CurrentTheme vCommandBarControl to eTheme
95621>                    Set peVisualTheme of ghoCommandBars to eTheme
95622>                    Send ComRecalcLayout of ghoCommandBars
95623>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
95624>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
95626>                End_Procedure
95627>
95627>                Procedure SetTheTheme Integer eTheme
95630>                    Integer iColor
95630>                    Set peVisualTheme of ghoCommandBars to eTheme
95631>                    Send ComRecalcLayout of ghoCommandBars
95632>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
95633>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
95635>                End_Procedure
95636>
95636>                Function ConvertSystemColor Integer iColor Returns Integer
95639>                    Integer iSysColor
95639>                    If (iColor = clDefault or iColor = clNone) Begin    // If default color then use -1
95641>                        Move clNone to iColor
95642>                    End
95642>                    Else If (iColor < 0) Begin    // If it is a system color (<0) then convert this into an RGB value
95645>                        Move (iColor iand |CI$7FFFFFFF) to iSysColor    // extract the system color constant
95646>                        Move (GetSysColor(iSysColor)) to iColor
95647>                    End
95647>                    Function_Return iColor
95648>                End_Function
95649>
95649>            End_Object
95650>
95650>            Object oAbout_MenuItem is a cCJMenuItem
95652>                Set psCaption to "About"
95653>                Set psToolTip to "About Info"
95654>                Set psDescription to "About the program"
95655>                Set psImage to "ActionAbout1.ico"
95656>                Set pbControlBeginGroup to True
95657>                Procedure OnExecute Variant vCommandBarControl
95660>                    Forward Send OnExecute vCommandBarControl
95662>                    Send Activate_About of (Client_Id(ghoCommandBars))
95663>                End_Procedure
95664>            End_Object
95665>
95665>            Object oHelpMenuItem is a cCJHelpMenuItem
95667>                Set peControlType to xtpControlSplitButtonPopup
95668>                Set psImage to "ActionHelp1.ico"
95669>
95669>                Procedure OnExecute Variant vCommandBarControl
95672>                    Forward Send OnExecute vCommandBarControl
95674>                    Set psHelpFile of ghoApplication to "DataFlex.chm"
95675>                    Send ShowProgramHelp
95676>                End_Procedure
95677>
95677>                Object oHelpMenuItemLocal is a cCJMenuItem
95679>                    Set psCaption to "Local HTML Help"
95680>                    Set psImage to "ActionHelp1.ico"
95681>                    Procedure OnExecute Variant vCommandBarControl
95684>                        Set psHelpFile of ghoApplication to "DataFlex.chm"
95685>                        Send ShowProgramHelp
95686>                    End_Procedure
95687>                End_Object
95688>
95688>                Object oHelpMenuItemInternetBrowser is a cCJMenuItem
95690>                    Set psCaption to "Internet Online HTML Help"
95691>                    Set psImage to "ActionHelp1.ico"
95692>                    Procedure OnExecute Variant vCommandBarControl
95695>                        Send vShellExecute "open" "http://www.rdctools.com/HTMLHelp/Developer5.htm" "" ""
95696>                    End_Procedure
95697>
95697>                End_Object
95698>            End_Object
95699>
95699>            Object oExitMenuItem is a cCJExitMenuItem
95701>                Set psImage to "ActionExit1.ico"
95702>                Set psToolTip to "Exit application"
95703>                Set psDescription to "Exit the program (Alt+F4)"
95704>                Set pbControlBeginGroup to True
95705>            End_Object
95706>        End_Object
95707>
95707>//        Object oSpacerBar is a cCJToolbar
95707>//            Set pbDockNextTo to False
95707>//            Set pbShowExpandButton to False
95707>//            Set pbGripper to False
95707>//            Set peStretched to stStretch
95707>//            Set pbCustomizable to False
95707>//            Set pbCloseable to False
95707>//            Set pbEnableDocking to False
95707>//            Set pbHideWrap to True
95707>//
95707>//            Object oFiller is a cCJMenuItem
95707>//            End_Object
95707>//
95707>//        End_Object
95707>
95707>        Object oStatusBar is a cCJStatusBar
95709>
95709>            Object oStatusPane1 is a cCJStatusBarPane
95711>                Set piID to sbpIDIdlePane
95712>                Set pbStyleStretch to True
95713>            End_Object
95714>            Object oStatusPane2 is a cCJStatusBarPane
95716>                Set phoViewPane to Self
95717>                Set pbStyleStretch to True
95718>            End_Object
95719>
95719>        End_Object
95720>
95720>    End_Object
95721>
95721>    Object oClientArea is a ClientArea
95723>
95723>//        Use Dd_debug.dg // This Provides access to dd debugger by pressing ctrl+d within any view. Good for debugging
95723>
95723>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\StdAbout.pkg)
95723>>>//************************************************************************
95723>>>// Confidential Trade Secret.
95723>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
95723>>>// as an unpublished work.  All rights reserved.
95723>>>// DataFlex is a registered trademark of Data Access Corporation.
95723>>>//
95723>>>//************************************************************************
95723>>>//************************************************************************
95723>>>//
95723>>>// $File name  : StdAbout.pkg
95723>>>// $File title : Standard about object package for VDF
95723>>>// Notice      :
95723>>>// $Author(s)  : John Tuohy
95723>>>//
95723>>>// $Rev History
95723>>>//
95723>>>// JT 06/27/97   File created
95723>>>//************************************************************************
95723>>>
95723>>>// This provides a quick and simple way to create an about package for a program.
95723>>>// You need to create a message inside you client area called Activate_About.
95723>>>// Within this message you should send the message DoAbout passing needed
95723>>>// string information.
95723>>>//
95723>>>//       Procedure Activate_About
95723>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
95723>>>//       End_Procedure
95723>>>//    where: sTitle =     Name of application. If none provided, uses caption
95723>>>//                        bar title
95723>>>//           sVersion   = Version Line. If none provided, will be blank
95723>>>//           sCopyRight = Copyright Line. If none provided, will be blank
95723>>>//           sAuthor    = Author name, blank if none provided
95723>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
95723>>>//                        is used.
95723>>>// It is expected that you will place this in your own object package. For
95723>>>// example an order about package may look like this:
95723>>>//
95723>>>//   // OrderAbout.pkg
95723>>>//   Use StdAbout.pkg
95723>>>//   Procedure Activate_About
95723>>>//      String sTitle sCopyright sVersion sAuthor
95723>>>//      Move "My Order Entry System" to sTitle
95723>>>//      Move "Version 2.1" to sVersion
95723>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
95723>>>//      Move "John Smith"  to sAuthor
95723>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
95723>>>//   end_procedure
95723>>>//   // end of file.
95723>>>
95723>>>Use DfAbout.pkg
95723>>>
95723>>>// *************************************************************************
95723>>>//  Public message. This is the default message. It is expected that you will
95723>>>//   create your own message to override this
95723>>>// *************************************************************************
95723>>>
95723>>>Procedure Activate_About
95726>>>    Send DoAbout "" "" "" "" "" "" "" "" "" ""
95727>>>End_Procedure
95728>>>
95728>>>// *************************************************************************
95728>>>//  Public message. It is expected that you will send this message (most
95728>>>//  likely from Activate_About. This creates an about object, activates it
95728>>>//  and destroys it when done. It is not exepected that you will augment this.
95728>>>// *************************************************************************
95728>>>// Sample usage:
95728>>>//   The first two params will automatically be filled from the application settings if not provided.
95728>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
95728>>>
95728>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;    String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
95731>>>    Integer hoObj hoMain iArgs
95731>>>    String sValue
95731>>>
95731>>>    // Create object
95731>>>    Object About is an AboutDialog
95733>>>    // Uncomment these two lines if you would like to have a resizable About object.
95733>>>    //            Set Border_Style to Border_Thick
95733>>>    //            Set peAnchors to anAll
95733>>>
95733>>>    // Add checking for the number of arguments passed to avoid runtime errors
95733>>>    // if one of them is not passed. This makes the interface
95733>>>    // more flexible.
95733>>>        Move num_arguments to iArgs
95734>>>
95734>>>        // If no title is passed use the label of the main panel (if a main panel exists).
95734>>>        If (iArgs > 0 and sTitle = "") Begin
95736>>>            Get Main_Window of Desktop to hoMain
95737>>>            If hoMain Begin
95739>>>                Get Label of hoMain to sValue
95740>>>            End
95740>>>>
95740>>>        End
95740>>>>
95740>>>        Else If (iArgs > 0 and sTitle <> "") Begin
95743>>>            Move sTitle to sValue
95744>>>        End
95744>>>>
95744>>>        Else If (iArgs = 0) Begin
95747>>>            Get Main_Window of Desktop to hoMain
95748>>>            If hoMain Begin
95750>>>                Get Label of hoMain to sValue
95751>>>            End
95751>>>>
95751>>>        End
95751>>>>
95751>>>
95751>>>        If (sValue <> "") Begin
95753>>>            Send Add_LineLn sValue
95754>>>        End
95754>>>>
95754>>>        Move "" to sValue
95755>>>
95755>>>        // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
95755>>>        // For this to work the Project Properties Version must have been set in the Studio.
95755>>>        If (iArgs < 2) Begin
95757>>>            Move "" to sValue
95758>>>        End
95758>>>>
95758>>>        Else Begin
95759>>>            Move sVersion to sValue
95760>>>        End
95760>>>>
95760>>>        Set Version to sValue
95761>>>
95761>>>        If (iArgs > 2 and sCopyRight <> "") Begin
95763>>>            Send Add_LineLn sCopyRight
95764>>>        End
95764>>>>
95764>>>
95764>>>        // If only the five "standard" params were passed we don't add an extra linefeed;
95764>>>        // else we do.
95764>>>        If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
95766>>>            Send Add_Line sAuthor
95767>>>        End
95767>>>>
95767>>>        Else If (iArgs > 5 and sAuthor <> "") Begin
95770>>>            Send Add_LineLn sAuthor
95771>>>        End
95771>>>>
95771>>>
95771>>>        // Square bitmaps of 80x80 works best
95771>>>        If (iArgs > 4 and sBitmap <> "") Begin
95773>>>            Set Logo to sBitMap
95774>>>        End
95774>>>>
95774>>>
95774>>>        // Here starts handling of the five optional params:
95774>>>        If (iArgs = 6 and sParam6  <> "") Begin
95776>>>            Send Add_Line sParam6
95777>>>        End
95777>>>>
95777>>>        Else If (iArgs > 6 and sParam6  <> "") Begin
95780>>>            Send Add_LineLn sParam6
95781>>>        End
95781>>>>
95781>>>
95781>>>        If (iArgs = 7 and sParam7  <> "") Begin
95783>>>            Send Add_Line sParam7
95784>>>        End
95784>>>>
95784>>>        Else If (iArgs > 7 and sParam7  <> "") Begin
95787>>>            Send Add_LineLn sParam7
95788>>>        End
95788>>>>
95788>>>
95788>>>        If (iArgs = 8 and sParam8  <> "") Begin
95790>>>            Send Add_Line sParam8
95791>>>        End
95791>>>>
95791>>>        Else If (iArgs > 8 and sParam8  <> "") Begin
95794>>>            Send Add_LineLn sParam8
95795>>>        End
95795>>>>
95795>>>
95795>>>        If (iArgs = 9 and sParam9  <> "") Begin
95797>>>            Send Add_Line sParam9
95798>>>        End
95798>>>>
95798>>>        Else If (iArgs > 9 and sParam9  <> "") Begin
95801>>>            Send Add_LineLn sParam9
95802>>>        End
95802>>>>
95802>>>
95802>>>        If (iArgs = 10 and sParam10 <> "") Begin
95804>>>            Send Add_Line sParam10
95805>>>        End
95805>>>>
95805>>>
95805>>>        Move Self to hoObj
95806>>>    End_Object
95807>>>
95807>>>    Send Popup   of hoObj // Popup the about object
95808>>>    Send Destroy of hoObj // When done, it will be destroyed
95809>>>End_Procedure
95810>        Use DatabaseSelection.dg
Including file: DatabaseSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DatabaseSelection.dg)
95810>>>Use Windows.pkg
95810>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJGridPromptList.pkg)
95810>>>>>Use Windows.pkg
95810>>>>>Use cCJGrid.pkg
95810>>>>>Use umPromptRelational.pkg
95810>>>>>
95810>>>>>Class cCJGridPromptList is a cCJGrid
95811>>>>>    
95811>>>>>    Procedure Construct_Object
95813>>>>>        Forward Send Construct_Object
95815>>>>>        
95815>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
95816>>>>>        Property Boolean Private_pbAutoOrdering True
95817>>>>>        Property Boolean pbAutoSearch True  // pops up search window
95818>>>>>        Property Integer peUpdateMode umPromptValue
95819>>>>>        Property Integer piUpdateColumn 0
95820>>>>>        Property Integer piInitialColumn -1
95821>>>>>        Property String  psSeedValue ''
95822>>>>>        Property Handle phmPromptUpdateCallback 0
95823>>>>>        Property Integer phoInvokingObject
95824>>>>>        
95824>>>>>        Property Boolean pbStoredAutoSeed
95825>>>>>        Property Boolean pbStoredAutoOrdering
95826>>>>>        Property Boolean pbStoredAutoSearch
95827>>>>>        Property Integer peStoredUpdateMode
95828>>>>>        Property Integer piStoredUpdateColumn
95829>>>>>        Property Integer piStoredInitialColumn
95830>>>>>        Property Handle  phmStoredPromptUpdateCallback
95831>>>>>        Property Boolean pbStoredSelectionEnable
95832>>>>>        Property Boolean pbStoredMultipleSelection
95833>>>>>        
95833>>>>>        // internally set by list
95833>>>>>        // these must be set upon closing the list and can be used for manual list updates
95833>>>>>        Property Boolean pbCanceled
95834>>>>>        Property Integer[] pSelectedRows
95835>>>>>        
95835>>>>>        Property Boolean pbNeedsNewOrdering
95836>>>>>        Property Boolean pbRequestSearch
95837>>>>>        Property tGridKeyPair[] pSearchKeys
95838>>>>>        
95838>>>>>        // these properties makes a prompt list a prompt list
95838>>>>>        // and should not be changed.
95838>>>>>        Set pbEditOnKeyNavigation to False
95839>>>>>        Set pbEditOnClick to False
95840>>>>>        Set pbReadOnly to True
95841>>>>>        Set pbFocusSubItems to True
95842>>>>>        
95842>>>>>        // these could maybe be changed
95842>>>>>        Set pbShadeSortColumn to True
95843>>>>>        Set pbHeaderReorders to True
95844>>>>>        Set pbHeaderTogglesDirection to True
95845>>>>>        Set pbHeaderSelectsColumn to True
95846>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
95847>>>>>        Set piFocusCellBackColor to clNone
95848>>>>>        Set piFocusCellForeColor to clNone
95849>>>>>        Set piFocusCellRectangleColor to clBlack
95850>>>>>        Set pbUseFocusCellRectangle to False
95851>>>>>        Set pbSelectionEnable to True
95852>>>>>        
95852>>>>>        On_Key kEnter Send Ok
95853>>>>>        On_Key kCancel Send Cancel
95854>>>>>        
95854>>>>>    End_Procedure
95855>>>>>    
95855>>>>>    // reorder list automatically on column change
95855>>>>>    // this also set pbFocusSubItems which is required to make the two states work
95855>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
95857>>>>>        Set Private_pbAutoOrdering to bAutoOrder
95858>>>>>        Set pbFocusSubItems to bAutoOrder
95859>>>>>    End_Procedure
95860>>>>>    
95860>>>>>    Function pbAutoOrdering Returns Boolean
95862>>>>>        Boolean bAutoOrder
95862>>>>>        Get Private_pbAutoOrdering to bAutoOrder
95863>>>>>        Function_Return bAutoOrder
95864>>>>>    End_Function
95865>>>>>    
95865>>>>>    // augmented to handle auto-ordering and invoking the search popup list
95865>>>>>    Procedure OnIdle
95867>>>>>        Boolean bNeedsReorder bSearch bOldToggle
95867>>>>>        Handle hoCol
95867>>>>>        Integer iKy1 iKy2 iCol
95867>>>>>        
95867>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
95868>>>>>        If bNeedsReorder Begin
95870>>>>>            Get SelectedColumn to iCol
95871>>>>>            If (iCol<>-1) Begin
95873>>>>>                
95873>>>>>                Get pbHeaderTogglesDirection to bOldToggle
95874>>>>>                Set pbHeaderTogglesDirection to False
95875>>>>>                Send HeaderReorder iCol
95876>>>>>                Set pbHeaderTogglesDirection to bOldToggle
95877>>>>>                
95877>>>>>                Set pbNeedsNewOrdering to False
95878>>>>>            End
95878>>>>>>
95878>>>>>        End
95878>>>>>>
95878>>>>>        
95878>>>>>        Get pbRequestSearch to bSearch
95879>>>>>        If bSearch Begin
95881>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
95882>>>>>        End
95882>>>>>>
95882>>>>>        
95882>>>>>        Forward Send OnIdle
95884>>>>>    End_Procedure
95885>>>>>    
95885>>>>>    Procedure OnStoreDefaults
95887>>>>>        Integer iVal
95887>>>>>        Boolean bVal
95887>>>>>        
95887>>>>>        Get pbAutoSeed to bVal
95888>>>>>        Set pbStoredAutoSeed to bVal
95889>>>>>        
95889>>>>>        Get pbAutoOrdering to bVal
95890>>>>>        Set pbStoredAutoOrdering to bVal
95891>>>>>        
95891>>>>>        Get pbAutoSearch to bVal
95892>>>>>        Set pbStoredAutoSearch to bVal
95893>>>>>        
95893>>>>>        Get peUpdateMode to iVal
95894>>>>>        Set peStoredUpdateMode to iVal
95895>>>>>        
95895>>>>>        Get piUpdateColumn to iVal
95896>>>>>        Set piStoredUpdateColumn to iVal
95897>>>>>        
95897>>>>>        Get piInitialColumn to iVal
95898>>>>>        Set piStoredInitialColumn to iVal
95899>>>>>        
95899>>>>>        Get phmPromptUpdateCallback to iVal
95900>>>>>        Set phmStoredPromptUpdateCallback to iVal
95901>>>>>        
95901>>>>>        Get pbSelectionEnable to bVal
95902>>>>>        Set pbStoredSelectionEnable to bVal
95903>>>>>        
95903>>>>>        Get pbMultipleSelection to bVal
95904>>>>>        Set pbStoredMultipleSelection to bVal
95905>>>>>        
95905>>>>>    End_Procedure
95906>>>>>    
95906>>>>>    Procedure OnRestoreDefaults
95908>>>>>        Integer iVal
95908>>>>>        Boolean bVal
95908>>>>>        
95908>>>>>        Get pbStoredAutoSeed to bVal
95909>>>>>        Set pbAutoSeed to bVal
95910>>>>>        
95910>>>>>        Get pbStoredAutoOrdering to bVal
95911>>>>>        Set pbAutoOrdering to bVal
95912>>>>>        
95912>>>>>        Get pbStoredAutoSearch to bVal
95913>>>>>        Set pbAutoSearch to bVal
95914>>>>>        
95914>>>>>        Get peStoredUpdateMode to iVal
95915>>>>>        Set peUpdateMode to iVal
95916>>>>>        
95916>>>>>        Get piStoredUpdateColumn to iVal
95917>>>>>        Set piUpdateColumn to iVal
95918>>>>>        
95918>>>>>        Get piStoredInitialColumn to iVal
95919>>>>>        Set piInitialColumn to iVal
95920>>>>>        
95920>>>>>        Get phmStoredPromptUpdateCallback to iVal
95921>>>>>        Set phmPromptUpdateCallback to iVal
95922>>>>>        
95922>>>>>        Get pbStoredSelectionEnable to bVal
95923>>>>>        Set pbSelectionEnable to bVal
95924>>>>>        
95924>>>>>        Get pbStoredMultipleSelection to bVal
95925>>>>>        Set pbMultipleSelection to bVal
95926>>>>>        
95926>>>>>    End_Procedure
95927>>>>>    
95927>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
95927>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
95927>>>>>    // Suitable for augmentation
95927>>>>>    Procedure OnSeedData
95929>>>>>        Integer iUpdateColumn iSortColumn
95929>>>>>        Boolean bSeed bAuto
95929>>>>>        String sValue
95929>>>>>        Handle hoCol
95929>>>>>        
95929>>>>>        Get piUpdateColumn to iUpdateColumn
95930>>>>>        Get psSeedValue to sValue
95931>>>>>        Get pbAutoSeed to bSeed
95932>>>>>        Get piSortColumn to iSortColumn
95933>>>>>        Get pbAutoOrdering to bAuto
95934>>>>>        // if not yet sorted and this is auto ordering we will
95934>>>>>        // sort the data for the search column. We do this to make the
95934>>>>>        // column search GE logic work properly.
95934>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
95936>>>>>            Get ColumnObject iUpdateColumn to hoCol
95937>>>>>            Send SortGridByColumn hoCol False
95938>>>>>        End
95938>>>>>>
95938>>>>>        
95938>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
95940>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0
95941>>>>>        End
95941>>>>>>
95941>>>>>        Else Begin
95942>>>>>            Send MovetoFirstRow
95943>>>>>        End
95943>>>>>>
95943>>>>>        
95943>>>>>    End_Procedure
95944>>>>>    
95944>>>>>    Procedure OnMoveValueOutByValue
95946>>>>>        String sValue
95946>>>>>        Handle hoInvokingObject hoCol  hoDataSource
95946>>>>>        Integer iRow iCol
95946>>>>>        Integer[] SelRowsIndexes
95947>>>>>        
95947>>>>>        Get phoInvokingObject to hoInvokingObject
95948>>>>>        Get pSelectedRows to SelRowsIndexes
95949>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
95951>>>>>            Get piUpdateColumn to iCol
95952>>>>>            Get ColumnObject iCol to hoCol
95953>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
95954>>>>>            Set Value of hoInvokingObject to sValue
95955>>>>>            Set Item_Changed_State of hoInvokingObject to True
95956>>>>>        End
95956>>>>>>
95956>>>>>    End_Procedure
95957>>>>>    
95957>>>>>    Procedure OnMoveValueOutByCustom
95959>>>>>    End_Procedure
95960>>>>>    
95960>>>>>    // augment to popup a search window when allowed
95960>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
95962>>>>>        Boolean bSubFocus bAutoSearch bChar
95962>>>>>        Integer iVal
95962>>>>>        
95962>>>>>        Get pbFocusSubItems to bSubFocus
95963>>>>>        Get pbAutoSearch to bAutoSearch
95964>>>>>        Forward Send OnComKeyDown llKeyCode llShift
95966>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
95968>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
95970>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
95971>>>>>                Move (iVal<>0) to bChar
95972>>>>>            End
95972>>>>>>
95972>>>>>            If bChar Begin
95974>>>>>                // this can get called multiple times before a search dialog pops up
95974>>>>>                Send AddToSearchKeys llKeyCode llShift
95975>>>>>            End
95975>>>>>>
95975>>>>>        End
95975>>>>>>
95975>>>>>    End_Procedure
95976>>>>>    
95976>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
95978>>>>>        Boolean bAutoSearch
95978>>>>>        Integer iKeyCode iShiftCode
95978>>>>>        Get pbAutoSearch to bAutoSearch
95979>>>>>        If bAutoSearch Begin
95981>>>>>            // this can get called multiple times before a search dialog pops up
95981>>>>>            Get piLastKey to iKeyCode
95982>>>>>            Get piLastKey2 to iShiftCode
95983>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
95984>>>>>        End
95984>>>>>>
95984>>>>>        Move True to llCancel
95985>>>>>    End_Procedure
95986>>>>>    
95986>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
95988>>>>>        Send ClearSearchRequest // kill any deferred search popup
95989>>>>>        Forward Send OnComRowDblClick llRow llItem
95991>>>>>    End_Procedure
95992>>>>>    
95992>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
95994>>>>>        Send Ok
95995>>>>>    End_Procedure
95996>>>>>    
95996>>>>>    
95996>>>>>    // we don't want a menu for prompt lists
95996>>>>>    Function CreateContextMenu Returns Handle
95998>>>>>        Function_Return 0
95999>>>>>    End_Function
96000>>>>>    
96000>>>>>    // if we use auto-ordering, change the order when the column changes
96000>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
96002>>>>>        Boolean bAutoOrder
96002>>>>>        Forward Send ColumnChanged iOld iNew
96004>>>>>        Get pbAutoOrdering to bAutoOrder
96005>>>>>        If bAutoOrder Begin
96007>>>>>            // will be reordered in idle event
96007>>>>>            Set pbNeedsNewOrdering to True
96008>>>>>        End
96008>>>>>>
96008>>>>>    End_Procedure
96009>>>>>    
96009>>>>>    
96009>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
96011>>>>>        Integer eMode
96011>>>>>        Integer[] SelRowsIndexes
96012>>>>>        Set pbCanceled to True // assume cancel unless changed
96013>>>>>        Set pSelectedRows to SelRowsIndexes // empty
96014>>>>>        Get peUpdateMode to eMode
96015>>>>>        If (eMode<>umPromptNonInvoking) Begin
96017>>>>>            Send OnStoreDefaults
96018>>>>>        End
96018>>>>>>
96018>>>>>        Send InitializePromptList
96019>>>>>        Forward Send Add_Focus hoParent
96021>>>>>        Send LoadData
96022>>>>>        Set psSeedValue to ""
96023>>>>>    End_Procedure
96024>>>>>    
96024>>>>>    // called before the list is activated.
96024>>>>>    Procedure InitializePromptList
96026>>>>>        Integer hoInvokingObject
96026>>>>>        Boolean bAutoColumn bAutoSeed
96026>>>>>        Integer i iOldMode eUpdateMode
96026>>>>>        String sValue
96026>>>>>        
96026>>>>>        Get peUpdateMode to eUpdateMode
96027>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
96029>>>>>            Get Focus of Desktop to hoInvokingObject
96030>>>>>            If (hoInvokingObject<=Desktop) Begin
96032>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
96033>>>>>>
96033>>>>>                Procedure_Return
96034>>>>>            End
96034>>>>>>
96034>>>>>            
96034>>>>>            Set phoInvokingObject to hoInvokingObject
96035>>>>>            
96035>>>>>            Send Prompt_Callback to hoInvokingObject Self
96036>>>>>            Get peUpdateMode to eUpdateMode
96037>>>>>        End
96037>>>>>>
96037>>>>>        
96037>>>>>        Send ClearSearchRequest // clear the search keys
96038>>>>>        Set pbNeedsNewOrdering to False
96039>>>>>        
96039>>>>>        Get pbAutoSeed to bAutoSeed
96040>>>>>        
96040>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
96042>>>>>            Get Value of hoInvokingObject to sValue
96043>>>>>            Set psSeedValue to sValue
96044>>>>>        End
96044>>>>>>
96044>>>>>        
96044>>>>>    End_Procedure
96045>>>>>    
96045>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
96045>>>>>    Procedure LoadData
96047>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
96047>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
96047>>>>>        Integer eUpdateMode
96047>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder
96047>>>>>        
96047>>>>>        Get phoDataSource to hoDataSource
96048>>>>>        Get peUpdateMode to eUpdateMode
96049>>>>>        Get phoInvokingObject to hoInvokingObject
96050>>>>>        Get pbAutoSeed to bAutoSeed
96051>>>>>        Get piInitialColumn to iInitialColumn
96052>>>>>        Get piUpdateColumn to iUpdateColumn
96053>>>>>        Get RowCount of hoDataSource to iRows
96054>>>>>        
96054>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
96054>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
96054>>>>>        If (iInitialColumn=-1) Begin
96056>>>>>            Move iUpdateColumn to iInitialColumn
96057>>>>>        End
96057>>>>>>
96057>>>>>        If (iInitialColumn>=0) Begin
96059>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
96060>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
96061>>>>>        End
96061>>>>>>
96061>>>>>        Send OnSeedData // find a good starting place for the row
96062>>>>>        Get pbFocusSubItems to bSubFocus
96063>>>>>        If bSubFocus Begin
96065>>>>>            // if column focus, which is normal, go to initialcolumn
96065>>>>>            If hoInitialColumn Begin
96067>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
96068>>>>>            End
96068>>>>>>
96068>>>>>            Else Begin
96069>>>>>                Send MoveToFirstEnterableColumn
96070>>>>>            End
96070>>>>>>
96070>>>>>        End
96070>>>>>>
96070>>>>>        
96070>>>>>    End_Procedure
96071>>>>>    
96071>>>>>    // This is only called in a successful close
96071>>>>>    Procedure ClosePromptList
96073>>>>>        Handle hoDataSource hoInvokingObject
96073>>>>>        Handle hmCallBack
96073>>>>>        Integer iRow eUpdateMode
96073>>>>>        Integer[] SelRowsIndexes
96074>>>>>        
96074>>>>>        Get phoDataSource to hoDataSource
96075>>>>>        Get phoInvokingObject to hoInvokingObject
96076>>>>>        
96076>>>>>        If (pbMultipleSelection(Self)) Begin
96078>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
96079>>>>>        End
96079>>>>>>
96079>>>>>        Else Begin
96080>>>>>            Get SelectedRow of hoDataSource to iRow
96081>>>>>            If (iRow<>-1) Begin
96083>>>>>                Move iRow to SelRowsIndexes[0]
96084>>>>>            End
96084>>>>>>
96084>>>>>        End
96084>>>>>>
96084>>>>>        
96084>>>>>        Set pbCanceled to False
96085>>>>>        Set pSelectedRows to SelRowsIndexes
96086>>>>>        
96086>>>>>        Get peUpdateMode to eUpdateMode
96087>>>>>        // if non-invoking there is by definition, no move value out
96087>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
96089>>>>>            
96089>>>>>            If (eUpdateMode=umPromptValue) Begin
96091>>>>>                Send OnMoveValueOutByValue
96092>>>>>            End
96092>>>>>>
96092>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
96095>>>>>                Send OnMoveValueOutByCustom
96096>>>>>            End
96096>>>>>>
96096>>>>>            Get phmPromptUpdateCallback to hmCallBack
96097>>>>>            If hmCallBack Begin
96099>>>>>                Send hmCallBack of hoInvokingObject Self
96100>>>>>            End
96100>>>>>>
96100>>>>>        End
96100>>>>>>
96100>>>>>        
96100>>>>>        Send Close_Panel
96101>>>>>    End_Procedure
96102>>>>>    
96102>>>>>    // augment to send OnRestoreDefaults.
96102>>>>>    Procedure Release_Focus
96104>>>>>        Integer eUpdateMode
96104>>>>>        Get peUpdateMode to eUpdateMode
96105>>>>>        Forward Send Release_Focus
96107>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
96109>>>>>            Send OnRestoreDefaults
96110>>>>>        End
96110>>>>>>
96110>>>>>    End_Procedure
96111>>>>>    
96111>>>>>    Function SelectedRowIds Returns RowID[]
96113>>>>>        RowID[] SelectedRowids
96114>>>>>        Integer[] SelectedRows
96115>>>>>        Integer i iRows
96115>>>>>        Handle hoDataSource
96115>>>>>        Get phoDataSource to hoDataSource
96116>>>>>        Get pSelectedRows to SelectedRows
96117>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
96118>>>>>        For i from 0 to (iRows-1)
96124>>>>>>
96124>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
96125>>>>>        Loop
96126>>>>>>
96126>>>>>        Function_Return SelectedRowids
96127>>>>>    End_Function
96128>>>>>    
96128>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
96130>>>>>        String[] SelectedValues
96131>>>>>        Integer[] SelectedRows
96132>>>>>        Integer i iRows
96132>>>>>        Handle hoCol
96132>>>>>        Get ColumnObject iCol to hoCol
96133>>>>>        Get pSelectedRows to SelectedRows
96134>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
96135>>>>>        For i from 0 to (iRows-1)
96141>>>>>>
96141>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
96142>>>>>        Loop
96143>>>>>>
96143>>>>>        Function_Return SelectedValues
96144>>>>>    End_Function
96145>>>>>    
96145>>>>>    Procedure Ok Returns Integer
96147>>>>>        Send ClosePromptList
96148>>>>>    End_Procedure
96149>>>>>    
96149>>>>>    Procedure Cancel Returns Integer
96151>>>>>        Send Close_Panel
96152>>>>>    End_Procedure
96153>>>>>    
96153>>>>>    Procedure Search
96155>>>>>        Send Activate // give focus back to list so focus things are correct
96156>>>>>        Send Request_Search 0 0
96157>>>>>    End_Procedure
96158>>>>>    
96158>>>>>    // do a search using the current keys in the search key buffer for the sort column.
96158>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
96158>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
96158>>>>>    Procedure Request_SearchEx
96160>>>>>        tGridKeyPair[] Keys
96160>>>>>        tGridKeyPair[] Keys
96161>>>>>        Integer iCol
96161>>>>>        Handle hoCol hoSearchDialog
96161>>>>>        Boolean bOk
96161>>>>>        String sValue
96161>>>>>        
96161>>>>>        Get piSortColumn to iCol
96162>>>>>        If (iCol<>-1) Begin
96164>>>>>            Get ColumnObject iCol to hoCol
96165>>>>>            Get pSearchKeys to Keys
96166>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
96167>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
96168>>>>>            If bOk Begin
96170>>>>>                Send RequestFindColumnValue iCol sValue True 0
96171>>>>>            End
96171>>>>>>
96171>>>>>            Send Destroy of hoSearchDialog
96172>>>>>        End
96172>>>>>>
96172>>>>>        Send ClearSearchRequest // clear the search keys
96173>>>>>    End_Procedure
96174>>>>>    
96174>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
96174>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
96176>>>>>        tGridKeyPair[] Keys
96176>>>>>        tGridKeyPair[] Keys
96177>>>>>        tGridKeyPair KeyPair
96177>>>>>        tGridKeyPair KeyPair
96177>>>>>        Set pbRequestSearch to True
96178>>>>>        Move iKeyCode to KeyPair.KeyCode
96179>>>>>        Move iShiftCode to KeyPair.ShiftCode
96180>>>>>        Get pSearchKeys to Keys
96181>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
96182>>>>>        Set pSearchKeys to Keys
96183>>>>>    End_Procedure
96184>>>>>    
96184>>>>>    Procedure ClearSearchRequest
96186>>>>>        tGridKeyPair[] SearchKeys
96186>>>>>        tGridKeyPair[] SearchKeys
96187>>>>>        Set pSearchKeys to SearchKeys
96188>>>>>        Set pbRequestSearch to False
96189>>>>>    End_Procedure
96190>>>>>    
96190>>>>>End_Class
96191>>>>>
96191>>>Use cDbUpdateFunctionLibrary.pkg
96191>>>Use MSSqldrv.pkg
96191>>>Use db2_drv.pkg
96191>>>Use odbc_drv.pkg
96191>>>Use cRDCModalPanel.pkg
Including file: cRDCModalPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\cRDCModalPanel.pkg)
96191>>>>>//****************************************************************************
96191>>>>>// $Module type: Class
96191>>>>>// $Module name: cRDCModalPanel
96191>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
96191>>>>>// Created     : 2014-03-17 @ 12:33
96191>>>>>//
96191>>>>>// Description :
96191>>>>>//
96191>>>>>// $Rev History:
96191>>>>>//    2014-03-17  Module header created
96191>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
96191>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
96191>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
96191>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
96191>>>>>// in the help folder for more details.
96191>>>>>//
96191>>>>>//****************************************************************************
96191>>>>>Use Windows.pkg
96191>>>>>Use cCJCommandBarSystem.pkg   
96191>>>>>Use cCJSkinFramework.pkg
96191>>>>>
96191>>>>>Class cRDCModalPanel is a ModalPanel
96192>>>>>
96192>>>>>    Procedure Construct_Object
96194>>>>>        Forward Send Construct_Object
96196>>>>>
96196>>>>>        Set Maximize_Icon to True
96197>>>>>        Set Minimize_Icon to False
96198>>>>>        Set Border_Style to Border_Thick
96199>>>>>        Set Locate_Mode to Center_On_Parent
96200>>>>>
96200>>>>>        Property String Private_Icon
96201>>>>>        Property Handle phoDialogCommandbar
96202>>>>>    End_Procedure
96203>>>>>
96203>>>>>    Procedure Set Icon String sIcon
96205>>>>>        Forward Set Icon to sIcon
96207>>>>>        Set Private_Icon to sIcon
96208>>>>>    End_Procedure
96209>>>>>
96209>>>>>    Function Icon Returns String
96211>>>>>        String sIcon
96211>>>>>        Get Private_Icon to sIcon
96212>>>>>        Function_Return sIcon
96213>>>>>    End_Function
96214>>>>>
96214>>>>>    Procedure Page Integer iPageObject
96216>>>>>        String sIcon
96216>>>>>        Integer hWnd
96216>>>>>        
96216>>>>>        Forward Send Page iPageObject
96218>>>>>        Get Private_Icon to sIcon
96219>>>>>        If (sIcon <> "") Begin
96221>>>>>            Set Icon to sIcon
96222>>>>>        End
96222>>>>>>
96222>>>>>
96222>>>>>        Get Window_Handle to hWnd
96223>>>>>
96223>>>>>        If ((ghoSkinFramework <> 0) and (hWnd <> 0)) Begin
96225>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
96226>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
96227>>>>>        End
96227>>>>>>
96227>>>>>    End_Procedure
96228>>>>>
96228>>>>>    // Put a status bar at the bottom of the panel, which makes
96228>>>>>    // status_help work and puts a gripper in the lower right corner.
96228>>>>>    Procedure End_Construct_Object
96230>>>>>        Integer iStyle iSize iOffset
96230>>>>>
96230>>>>>        Forward Send End_Construct_Object
96232>>>>>
96232>>>>>        Get Border_Style to iStyle
96233>>>>>        Move 8 to iOffset
96234>>>>>        If (iStyle = Border_Thick) Begin
96236>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
96238>>>>>                Object oStatusBar is a cCJStatusBar
96240>>>>>                    Set phoDialogCommandbar to Self
96241>>>>>                    Object oStatusIdle is a cCJStatusBarPane
96243>>>>>                        Set piId to sbpIDIdlePane
96244>>>>>                        Set pbStyleStretch to True
96245>>>>>                    End_Object
96246>>>>>                End_Object
96247>>>>>            End_Object
96248>>>>>            Get Size to iSize
96249>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
96250>>>>>            Set piMinSize to (Hi(iSize) + iOffset) (Low(iSize))
96251>>>>>        End
96251>>>>>>
96251>>>>>
96251>>>>>    End_Procedure
96252>>>>>
96252>>>>>    Procedure Popup
96254>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
96255>>>>>        Forward Send Popup
96257>>>>>    End_Procedure
96258>>>>>
96258>>>>>End_Class
96259>>>
96259>>>Object oDatabaseSelection_sl is a cRDCModalPanel
96261>>>    Set Label to "SQL Database Selection"
96262>>>    Set Size to 119 183
96263>>>    Set piMinSize to 89 170
96264>>>    Set Location to 2 2
96265>>>    Set Border_Style to Border_Thick
96266>>>    Set Icon to "DatabaseLookup1.ico"
96267>>>
96267>>>    Property String[] psTheData
96269>>>
96269>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
96271>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
96273>>>        End_Object
96274>>>    End
96274>>>>
96274>>>
96274>>>    Object oSelList is a cCJGridPromptList
96276>>>        Set Size to 89 167
96277>>>        Set Location to 6 6
96278>>>        Set peAnchors to anAll
96279>>>        Set pbAllowColumnRemove to False
96280>>>        Set pbUseAlternateRowBackgroundColor to True
96281>>>        Set pbGrayIfDisable to False
96282>>>        Set pbHeaderReorders to False
96283>>>        Set pbHeaderSelectsColumn to False
96284>>>        Set pbHeaderTogglesDirection to False
96285>>>        Set pbShadeSortColumn to False
96286>>>        Set piFocusCellBackColor to clDkGray
96287>>>
96287>>>        Object oName is a cCJGridColumn
96289>>>            Set piWidth to 334
96290>>>            Set psCaption to "Database Name"
96291>>>        End_Object
96292>>>
96292>>>        Procedure Activating
96295>>>            tDataSourceRow[] MyData
96295>>>            tDataSourceRow[] MyData
96296>>>            Handle hoDataSource
96296>>>            String[] sTheData
96297>>>            Integer iCount iSize
96297>>>
96297>>>            Send Cursor_Wait of Cursor_Control
96298>>>            Forward Send Activating
96300>>>
96300>>>            Get psTheData to sTheData
96301>>>            Move (SizeOfArray(sTheData)) to iSize
96302>>>            Decrement iSize
96303>>>            For iCount from 0 to iSize
96309>>>>
96309>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
96310>>>            Loop
96311>>>>
96311>>>
96311>>>            Get phoDataSource to hoDataSource
96312>>>            Send InitializeData of hoDataSource MyData
96313>>>            Send Cursor_Ready of Cursor_Control
96314>>>        End_Procedure
96315>>>
96315>>>    End_Object
96316>>>
96316>>>    Object oOK_Btn is a Button
96318>>>        Set Size to 14 50
96319>>>        Set Label    to "&OK"
96320>>>        Set Location to 98 68
96321>>>        Set peAnchors To anBottomRight
96322>>>
96322>>>        Procedure OnClick
96325>>>            Send Ok of oSelList
96326>>>        End_Procedure
96327>>>
96327>>>    End_Object
96328>>>
96328>>>    Object oCancel_Btn is a Button
96330>>>        Set Size to 14 50
96331>>>        Set Label    to "&Cancel"
96332>>>        Set Location to 98 123
96333>>>        Set peAnchors to anBottomRight
96334>>>
96334>>>        Procedure OnClick
96337>>>            Send Close_Panel
96338>>>        End_Procedure
96339>>>
96339>>>    End_Object
96340>>>
96340>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96341>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96342>>>End_Object
96343>        Use SQLDatabaseBackup.dg
Including file: SQLDatabaseBackup.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLDatabaseBackup.dg)
96343>>>// Note: At the bottom of this package there's a general purpose access method for this dialog.
96343>>>Use Windows.pkg
96343>>>Use vWin32fh.pkg
96343>>>
96343>>>Object oSQLDatabaseBackup_dg is a ModalPanel
96345>>>    Set Size to 104 298
96346>>>    Set Label to "SQL Database Backup"
96347>>>    Set piMinSize to 89 211
96348>>>    Set Location to 2 4
96349>>>    Set Border_Style To Border_Thick
96350>>>
96350>>>    Property Boolean pbOK False
96352>>>    Property String  psDatabase
96354>>>    Property String  psPath
96356>>>    Property String  psBackupName
96358>>>
96358>>>    Object oDatabase_fm is a Form
96360>>>        Set Size to 13 204
96361>>>        Set Location to 14 71
96362>>>        Set Label_Justification_Mode to JMode_Right
96363>>>        Set Label_Col_Offset to 2
96364>>>        Set Label to "Database Name"
96365>>>        Set Enabled_State to False
96366>>>        Set peAnchors to anTopLeftRight
96367>>>
96367>>>        Procedure Page Integer iPageObject
96370>>>            String sValue
96370>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sValue
96371>>>            Set Value to sValue
96372>>>            Set psDatabase to sValue
96373>>>            Forward Send Page iPageObject
96375>>>        End_Procedure
96376>>>
96376>>>    End_Object
96377>>>
96377>>>    Object oBackupName_fm is a Form
96379>>>        Set Size to 13 204
96380>>>        Set Location to 29 71
96381>>>        Set Label_Justification_Mode to JMode_Right
96382>>>        Set Label_Col_Offset to 2
96383>>>        Set Label to "Backup Name"
96384>>>        Set peAnchors to anTopLeftRight
96385>>>
96385>>>        Procedure Page Integer iPageObject
96388>>>            String sValue
96388>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sValue
96389>>>            Set Value to sValue
96390>>>            Forward Send Page iPageObject
96392>>>        End_Procedure
96393>>>
96393>>>        Procedure OnChange
96396>>>            String sValue
96396>>>            Get Value to sValue
96397>>>            Set psBackupName to sValue
96398>>>        End_Procedure
96399>>>
96399>>>    End_Object
96400>>>
96400>>>    Object oUseDefaultBackupFolder_cb is a CheckBox
96402>>>        Set Size to 10 50
96403>>>        Set Location to 50 71
96404>>>        Set Label to "Use Default SQL Backup Folder"
96405>>>        Set Checked_State to True
96406>>>
96406>>>        Procedure OnChange
96409>>>            Boolean bChecked
96409>>>            Get Checked_State to bChecked
96410>>>            Set Enabled_State of oPath_fm to (bChecked = False)
96411>>>        End_Procedure
96412>>>
96412>>>    End_Object
96413>>>
96413>>>    Object oPath_fm is a Form
96415>>>        Set Size to 13 204
96416>>>        Set Location to 62 71
96417>>>        Set Label_Justification_Mode to JMode_Right
96418>>>        Set Label_Col_Offset to 2
96419>>>        Set Label to "Path"
96420>>>        Set Prompt_Button_Mode to PB_PromptOn
96421>>>        Set peAnchors to anTopLeftRight
96422>>>        Set Enabled_State to False
96423>>>
96423>>>        Procedure Page Integer iPageObject
96426>>>            String sValue
96426>>>            Get psDataPathFirstPart of ghoDbUpdateFunctionLibrary to sValue
96427>>>            Get vFolderFormat sValue to sValue
96428>>>            Move (sValue + "Backup") to sValue
96429>>>            Set Value to sValue
96430>>>            Forward Send Page iPageObject
96432>>>        End_Procedure
96433>>>
96433>>>        Procedure Prompt
96436>>>            String sPath sFileMask sRetval
96436>>>
96436>>>            Get Value to sPath
96437>>>            Move "Database Backup files (*.bak)|*.bak" to sFileMask
96438>>>            Get vSelect_File sFileMask "Please select a .bak file" sPath to sRetval
96439>>>            If (sRetval <> "") Begin
96441>>>                Get ParseFolderName sRetval to sPath
96442>>>                If (Right(sPath, 1) ="\") Begin
96444>>>                    Move (Left(sPath, Length(sPath) -1)) to sPath
96445>>>                End
96445>>>>
96445>>>                Set Value to sPath
96446>>>            End
96446>>>>
96446>>>        End_Procedure
96447>>>
96447>>>        Procedure OnChange
96450>>>            String sValue
96450>>>            Get Value to sValue
96451>>>            Set psPath to sValue
96452>>>        End_Procedure
96453>>>
96453>>>    End_Object
96454>>>
96454>>>    Object oOK_Btn is a Button
96456>>>        Set Label    to "&OK"
96457>>>        Set Location to 81 169
96458>>>        Set peAnchors to anBottomRight
96459>>>
96459>>>        Procedure OnClick
96462>>>            Set pbOK to True
96463>>>            Send Close_Panel
96464>>>        End_Procedure
96465>>>
96465>>>    End_Object
96466>>>
96466>>>    Object oCancel_Btn is a Button
96468>>>        Set Label    to "&Cancel"
96469>>>        Set Location to 81 224
96470>>>        Set peAnchors to anBottomRight
96471>>>
96471>>>        Procedure OnClick
96474>>>            Set pbOK to False
96475>>>            Send Close_Panel
96476>>>        End_Procedure
96477>>>
96477>>>    End_Object
96478>>>
96478>>>    Object oButton1 is a Button
96480>>>        Set Size to 14 96
96481>>>        Set Location to 80 32
96482>>>        Set Label to "Enum table types"
96483>>>
96483>>>        Procedure OnClick
96486>>>            String sDriverID
96486>>>            tSQLConnection SQLConnection
96486>>>            tSQLConnection SQLConnection
96486>>>            Get pSQLConnection of ghoDbUpdateFunctionLibrary to SQLConnection
96487>>>            Send ShowAllTablesAndColumns SQLConnection.sDriverID SQLConnection.sConnectionString
96488>>>        End_Procedure
96489>>>
96489>>>        Procedure ShowAllTablesAndColumns String sDriver String sLogin
96492>>>            Handle hoCLIHandler
96492>>>            Integer iNumTables iTableCount
96492>>>
96492>>>            Get Create U_cCLIHandler to hoCLIhandler
96493>>>            If (hoCLIHandler > 0) Begin
96495>>>                Set psDriverID of hoCLIHandler to sDriver
96496>>>                Get EnumerateTables of hoCLIHandler sLogin to iNumTables
96497>>>                For iTableCount from 1 to iNumTables
96503>>>>
96503>>>                    Show (TableName(hoCLIHandler, iTableCount)) "; "
96505>>>                    Show (SchemaName(hoCLIHandler, iTableCount)) "; "
96507>>>                    Show (TableType(hoCLIHandler, iTableCount)) "; "
96509>>>                    Showln (TableComment(hoCLIHandler, iTableCount))
96511>>>//                    Get EnumerateColumns of hoCLIHandler sLogin (TableName(hoCLIHandler, iTableCount)) to iNumColumns
96511>>>//                    For iColumnCount from 1 to iNumColumns
96511>>>//                        Showln " " (ColumnName(hoCLIHandler, iColumnCount))
96511>>>//                    Loop
96511>>>                    Showln
96512>>>                Loop
96513>>>>
96513>>>                Send Destroy of hoCLIHandler
96514>>>            End
96514>>>>
96514>>>        End_Procedure
96515>>>
96515>>>    End_Object
96516>>>
96516>>>    Procedure Page Integer iPageObject
96519>>>        Set Icon to "DbBackup1.ico"
96520>>>        Forward Send Page iPageObject
96522>>>    End_Procedure
96523>>>
96523>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96524>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96525>>>
96525>>>End_Object
96526>>>
96526>>>// *** General purpose access method for this dialog ***
96526>>>Function MakeSQLDatabaseBackup Returns Boolean
96529>>>    Handle ho
96529>>>    Boolean bOK bDefault
96529>>>    String sDatabase sPath sBackupName
96529>>>
96529>>>    Move (oSQLDatabaseBackup_dg(Self)) to ho
96530>>>    Set pbOK of ho to False
96531>>>    Send Popup of ho
96532>>>
96532>>>    Get pbOk of ho to bOK
96533>>>    If (bOK = True) Begin
96535>>>        Get Value of (oDatabase_fm(ho))   to sDatabase
96536>>>        Get Value of (oBackupName_fm(ho)) to sBackupName
96537>>>        Get Checked_State of (oUseDefaultBackupFolder_cb(ho)) to bDefault
96538>>>        If (bDefault = False) Begin
96540>>>            Get Value of (oPath_fm(ho)) to sPath
96541>>>        End
96541>>>>
96541>>>        Get SqlDatabaseBackupToDisk of ghoDbUpdateFunctionLibrary sDatabase sBackupName sPath True to bOK
96542>>>    End
96542>>>>
96542>>>
96542>>>    Function_Return bOK
96543>>>End_Function
96544>        Use SQLConnections.vw
Including file: SQLConnections.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLConnections.vw)
96544>>>Use Windows.pkg
96544>>>Use DFClient.pkg
96544>>>Use cDbScrollingContainer.pkg
Including file: cDbScrollingContainer.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cDbScrollingContainer.pkg)
96544>>>>>// Provides support for db aware scrolling containers.
96544>>>>>// Scrolling containers is provided by creating two objects,
96544>>>>>// a host (dbScrollingContainer) and a scrolling clientarea (dbScrollingClientArea)
96544>>>>>// The host has no public interface, you just drop the object. It should have only one child object
96544>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
96544>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
96544>>>>>
96544>>>>>Use DFClient.pkg
96544>>>>>Use cScrollingContainerMixin.pkg
Including file: cScrollingContainerMixin.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cScrollingContainerMixin.pkg)
96544>>>>>>>// Mixin classes for scrolling container support:
96544>>>>>>>// cScrollingContainerMixin & cScrollingClientAreaMixin
96544>>>>>>>// These are used by cSrollingContainer / cScrollingClientArea and
96544>>>>>>>// dbScrollingContainer / dbScrollingClientArea.
96544>>>>>>>// The scrolling container has no public interface, you just drop the object. It should have only one child object
96544>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
96544>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
96544>>>>>>>
96544>>>>>>>Use Windows.pkg
96544>>>>>>>Use Winuser.pkg
96544>>>>>>>Use tWinStructs.pkg
96544>>>>>>>
96544>>>>>>>Register_Function pbTabbedWorkspaces Returns Boolean
96544>>>>>>>Register_Function pbCenterTabbedViews Returns Boolean
96544>>>>>>>// support for the scrolling client area mixin object.
96544>>>>>>>
96544>>>>>>>Class cScrollingClientAreaMixin is a Mixin
96545>>>>>>>    
96545>>>>>>>    Procedure Define_cScrollingClientAreaMixin
96547>>>>>>>        
96547>>>>>>>        Set pbSizeToClientArea to False // should already be set to this, but just in case.
96548>>>>>>>        Set Border_Style to Border_None
96549>>>>>>>        
96549>>>>>>>        Property Boolean pbAutoScroll True
96550>>>>>>>        Property Boolean pbAutoScrollFocus True
96551>>>>>>>        Property Integer piAutoScrollMarginX 5
96552>>>>>>>        Property Integer piAutoScrollMarginY 5
96553>>>>>>>        Property Integer piAutoScrollMinX 0
96554>>>>>>>        Property Integer piAutoScrollMinY 0
96555>>>>>>>        Property Boolean pbShowDisabledScrollBar False
96556>>>>>>>        
96556>>>>>>>        
96556>>>>>>>        Property Integer piLineScrollUnit  5 // minimum scrolling unit for line up/down and mouse wheel
96557>>>>>>>        Property Integer piMinimumHeight 0 // the minimum height that doesn't need scrolling
96558>>>>>>>        Property Integer piMinimumWidth 0 //(the minimum width that doesn't need scrolling
96559>>>>>>>        // keeps track of scrolling
96559>>>>>>>        Property Integer piCurrentVertScrolled 0
96560>>>>>>>        Property Integer piCurrentHorzScrolled 0
96561>>>>>>>        Property Integer piWheelDelta 0               // internal, accumulates mouse wheel clicks
96562>>>>>>>        Delegate Set phoScrollingClientArea to Self
96564>>>>>>>        
96564>>>>>>>        // set this true to make this a tabbed workspace view (design time)
96564>>>>>>>        Property Boolean pbTabWorkspaceView False
96565>>>>>>>        // set this false to stop auto-determination of pbTabWorkspaceView (design time)
96565>>>>>>>        Property Boolean pbAutoSetTabWorkspaceView True
96566>>>>>>>    End_Procedure
96567>>>>>>>    
96567>>>>>>>    // low level event sent from windows.
96567>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
96569>>>>>>>        Integer iWheelDelta iKeys iDelta iClicks
96569>>>>>>>        Move (low(abs(wParam))) to iKeys           // any keys down when pressed
96570>>>>>>>        Move (hi(abs(wParam))) to iDelta           // number of click units
96571>>>>>>>        If (wParam<0) Begin
96573>>>>>>>            Move (-iDelta) to iDelta     // can be up or down
96574>>>>>>>        End
96574>>>>>>>>
96574>>>>>>>        Get  piWheelDelta to iWheelDelta           // Current accumulated micro clicks
96575>>>>>>>        Move (iWheelDelta+iDelta) to iWheelDelta
96576>>>>>>>        // C_WHEELDATA is 120 as defined by MS as the delta to react to. Once click is usually 120
96576>>>>>>>        Move (iWheelDelta/C_WHEELDELTA) to iClicks // Number of clicks to react to
96577>>>>>>>        Set  piWheelDelta to (mod(iWheelDelta,C_WHEELDELTA)) // remainder unused microclicks
96578>>>>>>>        // If we have enough Clicks send OnMouseWheel
96578>>>>>>>        If (iClicks<>0) Begin
96580>>>>>>>            Send OnMouseWheel iClicks iKeys
96581>>>>>>>        End
96581>>>>>>>>
96581>>>>>>>        // tell windows that we've handled the event.
96581>>>>>>>        Set Windows_Override_State to True
96582>>>>>>>    End_Procedure
96583>>>>>>>    
96583>>>>>>>    
96583>>>>>>>    // should be sent by DF message OnWMMouseWheel , which is sent by WM_MOUSEWHEEL
96583>>>>>>>    Procedure OnMouseWheel Integer iClicks Integer iKey
96585>>>>>>>        Integer iLineScrollUnit
96585>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96586>>>>>>>        Send VScroll (-iClicks*iLineScrollUnit*2) // (If(iClicks>0,False,True)) (abs(iClicks))
96587>>>>>>>    End_Procedure
96588>>>>>>>    
96588>>>>>>>    // should be sent by WM_VSCROLL
96588>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
96590>>>>>>>        Boolean bOk
96590>>>>>>>        tWinScrollInfo ScrollInfo
96590>>>>>>>        tWinScrollInfo ScrollInfo
96590>>>>>>>        Integer iLineScrollUnit
96590>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96591>>>>>>>        Get GetScrollBarInfo True (&ScrollInfo) to bOk
96592>>>>>>>        If bOk Begin
96594>>>>>>>            
96594>>>>>>>            Case Begin
96594>>>>>>>                Case (iType=SB_PAGEDOWN)
96596>>>>>>>                    Send VScroll ScrollInfo.nPage
96597>>>>>>>                    Case Break
96598>>>>>>>                
96598>>>>>>>                Case (iType=SB_PAGEUP)
96601>>>>>>>                    Send VScroll (-Integer(ScrollInfo.nPage))
96602>>>>>>>                    Case Break
96603>>>>>>>                
96603>>>>>>>                Case (iType=SB_LINEDOWN)
96606>>>>>>>                    Send VScroll iLineScrollUnit
96607>>>>>>>                    Case Break
96608>>>>>>>                
96608>>>>>>>                Case (iType=SB_LINEUP)
96611>>>>>>>                    Send VScroll (-iLineScrollUnit)
96612>>>>>>>                    Case Break
96613>>>>>>>                
96613>>>>>>>                Case (iType=SB_BOTTOM)
96616>>>>>>>                    Send VScroll (ScrollInfo.nMax-ScrollInfo.nPos)
96617>>>>>>>                    Case Break
96618>>>>>>>                
96618>>>>>>>                Case (iType=SB_Top)
96621>>>>>>>                    Send VScroll (-ScrollInfo.nPos)
96622>>>>>>>                    Case Break
96623>>>>>>>                
96623>>>>>>>                Case (iType=SB_THUMBPOSITION)
96626>>>>>>>                    Case Break
96627>>>>>>>                
96627>>>>>>>                Case (iType=SB_THUMBTRACK)
96630>>>>>>>                    Send VScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
96631>>>>>>>                    Case Break
96632>>>>>>>            Case End
96632>>>>>>>        End
96632>>>>>>>>
96632>>>>>>>    End_Procedure
96633>>>>>>>    
96633>>>>>>>    // should be sent by WM_HSCROLL
96633>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
96635>>>>>>>        Boolean bOk
96635>>>>>>>        tWinScrollInfo ScrollInfo
96635>>>>>>>        tWinScrollInfo ScrollInfo
96635>>>>>>>        Integer iLineScrollUnit
96635>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96636>>>>>>>        Get GetScrollBarInfo False (&ScrollInfo) to bOk
96637>>>>>>>        If bOk Begin
96639>>>>>>>            
96639>>>>>>>            Case Begin
96639>>>>>>>                Case (iType=SB_PAGEDOWN)
96641>>>>>>>                    Send hScroll ScrollInfo.nPage
96642>>>>>>>                    Case Break
96643>>>>>>>                
96643>>>>>>>                Case (iType=SB_PAGEUP)
96646>>>>>>>                    Send hScroll (-Integer(ScrollInfo.nPage))
96647>>>>>>>                    Case Break
96648>>>>>>>                
96648>>>>>>>                Case (iType=SB_LINEDOWN)
96651>>>>>>>                    Send hScroll iLineScrollUnit
96652>>>>>>>                    Case Break
96653>>>>>>>                
96653>>>>>>>                Case (iType=SB_LINEUP)
96656>>>>>>>                    Send hScroll (-iLineScrollUnit)
96657>>>>>>>                    Case Break
96658>>>>>>>                
96658>>>>>>>                Case (iType=SB_BOTTOM)
96661>>>>>>>                    Send hScroll (ScrollInfo.nMax-ScrollInfo.nPos)
96662>>>>>>>                    Case Break
96663>>>>>>>                
96663>>>>>>>                Case (iType=SB_Top)
96666>>>>>>>                    Send hScroll (-ScrollInfo.nPos)
96667>>>>>>>                    Case Break
96668>>>>>>>                
96668>>>>>>>                Case (iType=SB_THUMBPOSITION)
96671>>>>>>>                    Case Break
96672>>>>>>>                
96672>>>>>>>                Case (iType=SB_THUMBTRACK)
96675>>>>>>>                    Send hScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
96676>>>>>>>                    Case Break
96677>>>>>>>            Case End
96677>>>>>>>        End
96677>>>>>>>>
96677>>>>>>>    End_Procedure
96678>>>>>>>    
96678>>>>>>>    
96678>>>>>>>    // this calls SetScrollInfo with proper info
96678>>>>>>>    Procedure SetScrollBarInfo Boolean bVert Integer iRangeMin Integer iRangeMax Integer iPageSize
96680>>>>>>>        tWinScrollInfo ScrollInfo
96680>>>>>>>        tWinScrollInfo ScrollInfo
96680>>>>>>>        Integer iVoid
96680>>>>>>>        Handle hWnd
96680>>>>>>>        Boolean bShow
96680>>>>>>>        
96680>>>>>>>        Delegate Get Window_Handle to hWnd
96682>>>>>>>        If (hWnd <> 0) Begin
96684>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
96685>>>>>>>            
96685>>>>>>>            Move (SIF_RANGE ior SIF_POS ior SIF_PAGE ) to ScrollInfo.fMask
96686>>>>>>>            Get pbShowDisabledScrollBar to bShow
96687>>>>>>>            If bShow Begin
96689>>>>>>>                Move (ScrollInfo.fMask ior SIF_DISABLENOSCROLL) to ScrollInfo.fMask
96690>>>>>>>            End
96690>>>>>>>>
96690>>>>>>>            Move iRangeMin to ScrollInfo.nMin
96691>>>>>>>            Move iRangeMax to ScrollInfo.nMax
96692>>>>>>>            Move iPageSize to ScrollInfo.nPage
96693>>>>>>>            Move 0 to ScrollInfo.nPos
96694>>>>>>>            Move (SetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo), True)) to iVoid
96695>>>>>>>            
96695>>>>>>>        End
96695>>>>>>>>
96695>>>>>>>    End_Procedure
96696>>>>>>>    
96696>>>>>>>    // this wraps GetScrollInfo
96696>>>>>>>    Function GetScrollBarInfo Boolean bVert tWinScrollInfo ByRef ScrollInfo Returns Boolean
96698>>>>>>>        Boolean bOk
96698>>>>>>>        Handle hWnd
96698>>>>>>>        
96698>>>>>>>        Delegate Get Window_Handle to hWnd
96700>>>>>>>        If (hWnd <> 0) Begin
96702>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
96703>>>>>>>            Move (SIF_ALL) to ScrollInfo.fMask
96704>>>>>>>            Move (GetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo))) to bOk
96705>>>>>>>        End
96705>>>>>>>>
96705>>>>>>>        Function_Return bOk
96706>>>>>>>    End_Function
96707>>>>>>>    
96707>>>>>>>    // this wraps SetScrollPos
96707>>>>>>>    Procedure SetScrollBarPosInfo Boolean bVert Integer iPos
96709>>>>>>>        Integer iVoid
96709>>>>>>>        Handle hWnd
96709>>>>>>>        
96709>>>>>>>        Delegate Get Window_Handle to hWnd
96711>>>>>>>        If (hWnd <> 0) Begin
96713>>>>>>>            Move (SetScrollPos(hWnd, If(bVert,SB_VERT,SB_HORZ), iPos, True)) to iVoid
96714>>>>>>>        End
96714>>>>>>>>
96714>>>>>>>    End_Procedure
96715>>>>>>>    
96715>>>>>>>    // scrolling containers don't do anhcors. However, this gets called every time the parent's
96715>>>>>>>    // guiSize changes. We can use that to scroll or resize the scrolling client as needed.
96715>>>>>>>    Procedure DoapplyAnchors Integer Arg1 Integer Arg2
96717>>>>>>>        Send ScrollClientArea
96718>>>>>>>    End_Procedure
96719>>>>>>>    
96719>>>>>>>    // augment to handle the scrolling area initialization.
96719>>>>>>>    Procedure Add_Focus Handle hoParent
96721>>>>>>>        Forward Send Add_Focus hoParent
96723>>>>>>>        // at this the scrolling container and client area should both be paged.
96723>>>>>>>        // child objects ae also paged with initial anchors applied
96723>>>>>>>        Send CalculateAutoScrollMinimums
96724>>>>>>>    End_Procedure
96725>>>>>>>    
96725>>>>>>>    Procedure Page Integer iPage
96727>>>>>>>        Forward Send Page iPage
96729>>>>>>>        If iPage Begin
96731>>>>>>>            // at this the scrolling container and client area should both be paged
96731>>>>>>>            // but the child controls are not paged. We don't want scrollbars when
96731>>>>>>>            // the child items are paged (else they may get anchored oddly)
96731>>>>>>>            // Prior to 19.0 these were set in Add_focus which meant that the child objects were
96731>>>>>>>            // already paged with scrollbars present. This would result in scrollbars appearing
96731>>>>>>>            // before they were really needed. This should be more accurate
96731>>>>>>>            Send SetScrollBarInfo True 0 0 0
96732>>>>>>>            Send SetScrollBarInfo False 0 0 0
96733>>>>>>>        End
96733>>>>>>>>
96733>>>>>>>    End_Procedure
96734>>>>>>>    
96734>>>>>>>    // determine scrolling minimums and set the client area as required.
96734>>>>>>>    
96734>>>>>>>    Procedure CalculateAutoScrollMinimums
96736>>>>>>>        Integer iMinX iMinY iSiz iLoc iMargin
96736>>>>>>>        Integer iAutoMinX iAutoMinY
96736>>>>>>>        Boolean bAutoScroll
96736>>>>>>>        Handle hoNext hoFirst
96736>>>>>>>        
96736>>>>>>>        Get pbAutoScroll to bAutoScroll
96737>>>>>>>        Get piAutoScrollMinX to iAutoMinX
96738>>>>>>>        Get piAutoScrollMinY to iAutoMinY
96739>>>>>>>        Get DialogToGui iAutoMinY iAutoMinX to iSiz
96740>>>>>>>        Move (Hi(iSiz)) to iAutoMinY
96741>>>>>>>        Move (Low(iSiz)) to iAutoMinX
96742>>>>>>>        Set piMinimumHeight to iAutoMinY
96743>>>>>>>        Set piMinimumWidth to iAutoMinX
96744>>>>>>>        
96744>>>>>>>        If (bAutoScroll and (iAutoMinX=0 or iAutoMinY=0)) Begin
96746>>>>>>>            
96746>>>>>>>            Get Next_Level to hoFirst
96747>>>>>>>            Move hoFirst to hoNext
96748>>>>>>>            If (hoFirst) Begin
96750>>>>>>>                Repeat
96750>>>>>>>>
96750>>>>>>>                    Get GuiWindowSize of hoNext to iSiz
96751>>>>>>>                    Get GuiLocation of hoNext to iLoc
96752>>>>>>>                    Move (Hi(iLoc)+Hi(iSiz) max iMinY) to iMinY
96753>>>>>>>                    Move (Low(iLoc)+Low(iSiz) max iMinX) to iMinx
96754>>>>>>>                    Get Next_Focus of hoNext to hoNext
96755>>>>>>>                Until (hoNext=0 or hoNext=hoFirst)
96757>>>>>>>                
96757>>>>>>>                If (iAutoMinY=0) Begin
96759>>>>>>>                    Get piAutoScrollMarginY to iMargin
96760>>>>>>>                    Set piMinimumHeight to (iMinY+iMargin)
96761>>>>>>>                End
96761>>>>>>>>
96761>>>>>>>                
96761>>>>>>>                If (iAutoMinX=0) Begin
96763>>>>>>>                    Get piAutoScrollMarginX to iMargin
96764>>>>>>>                    Set piMinimumWidth to (iMinX+iMargin)
96765>>>>>>>                    
96765>>>>>>>                End
96765>>>>>>>>
96765>>>>>>>            End
96765>>>>>>>>
96765>>>>>>>        End
96765>>>>>>>>
96765>>>>>>>        
96765>>>>>>>        // before setting the client area, unset all anchors so DoApplyAnchors will not do anything
96765>>>>>>>        Broadcast Set pbAnchorCreated to False
96767>>>>>>>        Send ScrollClientArea
96768>>>>>>>        // after the scroll set up, reinitialize all anchors.
96768>>>>>>>        Broadcast Send DoCreateAnchors
96770>>>>>>>    End_Procedure
96771>>>>>>>    
96771>>>>>>>    // Scroll the client area and adjust the client area size as needed. This does all the
96771>>>>>>>    // work of scrolling.
96771>>>>>>>    
96771>>>>>>>    Procedure ScrollClientArea
96773>>>>>>>        Integer iSiz
96773>>>>>>>        Integer iHeight iHCur iHCuriDelta iOrig iRange bOk
96773>>>>>>>        Integer iWidth iWCur iWDelta iWOrig
96773>>>>>>>        Integer iSzY iSzX iLocX iLocY
96773>>>>>>>        
96773>>>>>>>        Delegate Get GuiClientSize to iSiz
96775>>>>>>>        Move (Hi(iSiz)) to iHeight
96776>>>>>>>        Move (Low(iSiz)) to iWidth
96777>>>>>>>        
96777>>>>>>>        // Vertical scrolling
96777>>>>>>>        
96777>>>>>>>        Get piMinimumHeight to iOrig
96778>>>>>>>        Get piMinimumWidth to iWOrig
96779>>>>>>>        
96779>>>>>>>        If (iOrig<>0 or iWOrig<>0) Begin
96781>>>>>>>            
96781>>>>>>>            If (iOrig<>0) Begin
96783>>>>>>>                Get piCurrentVertScrolled to iHCur
96784>>>>>>>                // If the size got bigger and we've scrolled, we want to scroll up
96784>>>>>>>                If (iHCur<>0 and (iHCur+iHeight>iOrig)) Begin
96786>>>>>>>                    Move (iOrig-iHeight max 0) to iHCur
96787>>>>>>>                    Set piCurrentVertScrolled to iHCur
96788>>>>>>>                End
96788>>>>>>>>
96788>>>>>>>                If (iHCur<>0 or iOrig>iHeight) Begin
96790>>>>>>>                    Send SetScrollBarInfo True 0 iOrig (iHeight min iOrig)
96791>>>>>>>                    Send SetScrollBarPosInfo True iHCur
96792>>>>>>>                End
96792>>>>>>>>
96792>>>>>>>                Else Begin
96793>>>>>>>                    Send SetScrollBarInfo True 0 0 0 //iOrig (iHeight min iOrig)
96794>>>>>>>                End
96794>>>>>>>>
96794>>>>>>>            End
96794>>>>>>>>
96794>>>>>>>            
96794>>>>>>>            // Horiz scrolling
96794>>>>>>>            
96794>>>>>>>            Get piCurrentHorzScrolled to iWCur
96795>>>>>>>            // If the size got bigger and we've scrolled, we want to scroll left
96795>>>>>>>            If (iWCur<>0 and (iWCur+iWidth>iWOrig)) Begin
96797>>>>>>>                Move (iWOrig-iWidth max 0) to iWCur
96798>>>>>>>                Set piCurrentHorzScrolled to iWCur
96799>>>>>>>            End
96799>>>>>>>>
96799>>>>>>>            If (iWCur<>0 or iWOrig>iWidth) Begin
96801>>>>>>>                Send SetScrollBarInfo False 0 iWOrig (iWidth min iWOrig)
96802>>>>>>>                Send SetScrollBarPosInfo False iWCur
96803>>>>>>>            End
96803>>>>>>>>
96803>>>>>>>            Else Begin
96804>>>>>>>                Send SetScrollBarInfo False 0 0 0
96805>>>>>>>            End
96805>>>>>>>>
96805>>>>>>>        End
96805>>>>>>>>
96805>>>>>>>        
96805>>>>>>>        // this could change depending on scrollbars appearing or not
96805>>>>>>>        Delegate Get GuiClientSize to iSiz
96807>>>>>>>        
96807>>>>>>>        // size of container is the the minimum allowed size (if scrolling is needed)
96807>>>>>>>        // or it is the actual size of the container (if scrolling not needed and it is bigger)
96807>>>>>>>        // This is required to make anchors work sensibly
96807>>>>>>>        Move (hi(iSiz) max iOrig) to iSzY
96808>>>>>>>        Move (low(iSiz) max iWOrig) to iSzX
96809>>>>>>>        Move (-iHCur) to iLocY
96810>>>>>>>        Move (-iWCur) to iLocX
96811>>>>>>>        
96811>>>>>>>        // Allow chance to make modifications
96811>>>>>>>        Send AdjustSizesLocs (&iSzY) (&iSzX) (&iLocY) (&iLocX)
96812>>>>>>>        
96812>>>>>>>        Set GuiSize to iSzY iSzX
96813>>>>>>>        // if we've scrolled, we need to reposition the container
96813>>>>>>>        Set GuiLocation to iLocY iLocX
96814>>>>>>>    End_Procedure
96815>>>>>>>    
96815>>>>>>>    // note that scrolling never changes the size of the scrolling client.
96815>>>>>>>    // this way, it does not interfere with anchors.
96815>>>>>>>    
96815>>>>>>>    Procedure VScroll Integer iDelta
96817>>>>>>>        Integer iHeight iCur iOrig iSiz
96817>>>>>>>        Delegate Get GuiClientSize to iSiz
96819>>>>>>>        Move (hi(iSiz)) to iHeight
96820>>>>>>>        Get piCurrentVertScrolled to iCur
96821>>>>>>>        Get piMinimumHeight to iOrig
96822>>>>>>>        If (iOrig=0 or  Hi(iSiz)>=iOrig) Begin
96824>>>>>>>            Procedure_Return
96825>>>>>>>        End
96825>>>>>>>>
96825>>>>>>>        // make sure delta is within range
96825>>>>>>>        If (iDelta+iCur<0) Begin
96827>>>>>>>            Move (-iCur) to iDelta
96828>>>>>>>        End
96828>>>>>>>>
96828>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
96831>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
96832>>>>>>>        End
96832>>>>>>>>
96832>>>>>>>        If (iDelta=0) ;            Procedure_Return
96835>>>>>>>        
96835>>>>>>>        Move (iCur + iDelta) to iCur
96836>>>>>>>        Set piCurrentVertScrolled to iCur
96837>>>>>>>        Send SetScrollBarPosInfo True iCur
96838>>>>>>>        Get GuiLocation to iSiz
96839>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Integer)-iDelta) (cast(low(iSiz),Integer))
96840>>>>>>>        Send ScrollClientArea
96841>>>>>>>    End_Procedure
96842>>>>>>>    
96842>>>>>>>    
96842>>>>>>>    Procedure HScroll Integer iDelta
96844>>>>>>>        Integer iHeight iCur iOrig iSiz
96844>>>>>>>        Delegate Get GuiClientSize to iSiz
96846>>>>>>>        Move (low(iSiz)) to iHeight
96847>>>>>>>        Get piCurrentHorzScrolled to iCur
96848>>>>>>>        Get piMinimumWidth to iOrig
96849>>>>>>>        If (iOrig=0 or  low(iSiz)>=iOrig) Begin
96851>>>>>>>            Procedure_Return
96852>>>>>>>        End
96852>>>>>>>>
96852>>>>>>>        If (iDelta+iCur<0) Begin
96854>>>>>>>            Move (-iCur) to iDelta
96855>>>>>>>        End
96855>>>>>>>>
96855>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
96858>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
96859>>>>>>>        End
96859>>>>>>>>
96859>>>>>>>        If (iDelta=0) ;            Procedure_Return
96862>>>>>>>        
96862>>>>>>>        Move (iCur + iDelta) to iCur
96863>>>>>>>        Set piCurrentHorzScrolled to iCur
96864>>>>>>>        Send SetScrollBarPosInfo False iCur
96865>>>>>>>        Get GuiLocation to iSiz
96866>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)) (cast(low(iSiz),Short) -iDelta)
96867>>>>>>>        Send ScrollClientArea
96868>>>>>>>    End_Procedure
96869>>>>>>>    
96869>>>>>>>    // make sure client is a 0,0
96869>>>>>>>    Procedure ScrollHome
96871>>>>>>>        Send SetVScrollbox SB_TOP 0
96872>>>>>>>        Send SetHScrollbox SB_TOP 0
96873>>>>>>>    End_Procedure
96874>>>>>>>    
96874>>>>>>>    // get relative GUI location of this object to the parent one passed.
96874>>>>>>>    Procedure LocationRelativeTo Handle hoContainer Handle hoControl Integer ByRef iLocY Integer ByRef iLocX
96876>>>>>>>        Integer ivoid
96876>>>>>>>        tWinRect Rect0 Rect1
96876>>>>>>>        tWinRect Rect0 Rect1
96876>>>>>>>        Move (GetWindowRect(window_handle(hoContainer),addressof(Rect0))) to ivoid
96877>>>>>>>        Move (GetWindowRect(window_handle(hoControl),addressof(Rect1))) to ivoid
96878>>>>>>>        Move ((Rect1.top) - (Rect0.top)) to iLocY
96879>>>>>>>        Move ((rect1.left) - (rect0.left)) to iLocX
96880>>>>>>>    End_Procedure
96881>>>>>>>    
96881>>>>>>>    // This scrolls this object into visual range.
96881>>>>>>>    Procedure ScrollObjectInRange Handle hoControl
96883>>>>>>>        Handle hoScrollingContainer
96883>>>>>>>        Integer iCurrentVertScrolled iCurrentHorzScrolled
96883>>>>>>>        Integer iViewHeight iViewWidth
96883>>>>>>>        Integer iRelLocHeight iRelLocWidth
96883>>>>>>>        Integer iSize iControlHeight iControlWidth
96883>>>>>>>        Integer iScroll
96883>>>>>>>        Integer iMarginX iMarginY
96883>>>>>>>        Integer iScrollingContainerWindowSize iScrollingContainerClientSize
96883>>>>>>>        
96883>>>>>>>        Get piAutoScrollMarginX to iMarginX
96884>>>>>>>        Get piAutoScrollMarginY to iMarginY
96885>>>>>>>        
96885>>>>>>>        // the scrolling container
96885>>>>>>>        Move Self to hoScrollingContainer
96886>>>>>>>        // the amount the SC is currently scrolled
96886>>>>>>>        Get piCurrentVertScrolled of hoScrollingContainer to iCurrentVertScrolled
96887>>>>>>>        Get piCurrentHorzScrolled of hoScrollingContainer to iCurrentHorzScrolled
96888>>>>>>>        
96888>>>>>>>        // size of view's client area (this is the viewport area)
96888>>>>>>>        Get GuiClientSize of (Parent(hoScrollingContainer)) to iSize
96889>>>>>>>        Move (hi(iSize)) to iViewHeight
96890>>>>>>>        Move (low(iSize)) to iViewWidth
96891>>>>>>>        
96891>>>>>>>        // get this object's location relative to the scrolling container
96891>>>>>>>        Send LocationRelativeTo hoScrollingContainer hoControl (&iRelLocHeight) (&iRelLocWidth)
96892>>>>>>>        
96892>>>>>>>        // we expect that the client size is the window size but just in case
96892>>>>>>>        Get GuiWindowSize of hoScrollingContainer to iScrollingContainerWindowSize
96893>>>>>>>        Get GuiClientSize of hoScrollingContainer to iScrollingContainerClientSize
96894>>>>>>>        Move (iRelLocHeight - (Hi(iScrollingContainerWindowSize)-Hi(iScrollingContainerClientSize))) to iRelLocHeight
96895>>>>>>>        Move (iRelLocWidth - (Low(iScrollingContainerWindowSize)-Low(iScrollingContainerClientSize))) to iRelLocWidth
96896>>>>>>>        
96896>>>>>>>        // the outer size of the control object
96896>>>>>>>        Get GUIWindowSize of hoControl to iSize
96897>>>>>>>        Move (hi(iSize)) to iControlHeight
96898>>>>>>>        Move (low(iSize)) to iControlWidth
96899>>>>>>>        
96899>>>>>>>        // the general idea is to make the control fully visible but to scroll as little as possible.
96899>>>>>>>        
96899>>>>>>>        // Vertical Scroll
96899>>>>>>>        
96899>>>>>>>        // Vertical Scroll down
96899>>>>>>>        // if the bottom of the control plus a bottom margin does not fit make it fit at the bottom
96899>>>>>>>        If (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled >iViewHeight) Begin
96901>>>>>>>            
96901>>>>>>>            // set scroll amount so that the bottom of the control is visible
96901>>>>>>>            Move (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled - iViewHeight ) to iScroll
96902>>>>>>>            
96902>>>>>>>            // See if this amount, scrolls the top out of range. If so just scroll enough so that the
96902>>>>>>>            // top of the object appears at the bottom
96902>>>>>>>            If (iRelLocHeight - iCurrentVertScrolled < iScroll) Begin
96904>>>>>>>                Move (iRelLocHeight + iMarginY  - iCurrentVertScrolled - iViewHeight  ) to iScroll
96905>>>>>>>            End
96905>>>>>>>>
96905>>>>>>>            // if the scroll amnt is negative it's best to just keep it where it is.
96905>>>>>>>            If (iScroll>0) Begin
96907>>>>>>>                Send VScroll of hoScrollingContainer iScroll
96908>>>>>>>            End
96908>>>>>>>>
96908>>>>>>>        End
96908>>>>>>>>
96908>>>>>>>        // else vertical scroll up
96908>>>>>>>        // We scroll if the top of the object is not visible.
96908>>>>>>>        Else If (iRelLocHeight + iMarginY < iCurrentVertScrolled) Begin
96911>>>>>>>            // if we scroll we will scroll enough to see the top of the object.
96911>>>>>>>            Move (iRelLocHeight -iMarginY - iCurrentVertScrolled ) to iScroll
96912>>>>>>>            If (iScroll<0) Begin
96914>>>>>>>                Send VScroll of hoScrollingContainer (iScroll max (-iCurrentVertScrolled))
96915>>>>>>>            End
96915>>>>>>>>
96915>>>>>>>        End
96915>>>>>>>>
96915>>>>>>>        
96915>>>>>>>        // Horizonal Scroll
96915>>>>>>>        
96915>>>>>>>        // if the right side of the control does not fit, scroll it so it fits
96915>>>>>>>        If (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled >iViewWidth) Begin
96917>>>>>>>            Move (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled - iViewWidth ) to iScroll
96918>>>>>>>            If (iRelLocWidth - iCurrentHorzScrolled - iScroll<0) Begin
96920>>>>>>>                Move (iRelLocWidth  - iCurrentHorzScrolled - iMarginX ) to iScroll
96921>>>>>>>            End
96921>>>>>>>>
96921>>>>>>>            If (iScroll>0) Begin
96923>>>>>>>                Send HScroll of hoScrollingContainer iScroll
96924>>>>>>>            End
96924>>>>>>>>
96924>>>>>>>        End
96924>>>>>>>>
96924>>>>>>>        If (iRelLocWidth - iMarginX  - iCurrentHorzScrolled <0) Begin
96926>>>>>>>            // if this can fit by moving all the way to left, do so.
96926>>>>>>>            If (iRelLocWidth + iControlWidth + iMarginX <= iViewWidth) Begin
96928>>>>>>>                Move (-iCurrentHorzScrolled) to iScroll
96929>>>>>>>            End
96929>>>>>>>>
96929>>>>>>>            Else Begin
96930>>>>>>>                Move (iRelLocWidth - iCurrentHorzScrolled - iMarginX) to iScroll
96931>>>>>>>            End
96931>>>>>>>>
96931>>>>>>>            If (iScroll<0) Begin
96933>>>>>>>                Send HScroll of hoScrollingContainer (iScroll max (-iCurrentHorzScrolled))
96934>>>>>>>            End
96934>>>>>>>>
96934>>>>>>>        End
96934>>>>>>>>
96934>>>>>>>        
96934>>>>>>>        
96934>>>>>>>    End_Procedure
96935>>>>>>>    
96935>>>>>>>    // when we receive this message, we might need to scroll to bring the new focus in to view.
96935>>>>>>>    Procedure NotifyFocusSetInContainer Handle hoControl
96937>>>>>>>        Boolean bScrollOnFocus
96937>>>>>>>        Get pbAutoScrollFocus to bScrollOnFocus
96938>>>>>>>        If bScrollOnFocus Begin
96940>>>>>>>            Send ScrollObjectInRange hoControl
96941>>>>>>>        End
96941>>>>>>>>
96941>>>>>>>        Delegate Send NotifyFocusSetInContainer hoControl
96943>>>>>>>    End_Procedure
96944>>>>>>>    
96944>>>>>>>    
96944>>>>>>>    Function CenterTabWorkspaceView Returns Boolean
96946>>>>>>>        Boolean bCenter
96946>>>>>>>        Get pbCenterTabbedViews of ghoCommandBars to bCenter
96947>>>>>>>        Function_Return bCenter
96948>>>>>>>    End_Function
96949>>>>>>>    
96949>>>>>>>    Procedure AdjustSizesLocs Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
96951>>>>>>>        Boolean bTabWorkspaceView
96951>>>>>>>        Get pbTabWorkspaceView to bTabWorkspaceView
96952>>>>>>>        If bTabWorkspaceView Begin
96954>>>>>>>            Send AdjustTabWorkspaceView (&iHeight) (&iWidth) (&iLocY) (&iLocX)
96955>>>>>>>        End
96955>>>>>>>>
96955>>>>>>>    End_Procedure
96956>>>>>>>    
96956>>>>>>>    Function ParentView Returns Handle
96958>>>>>>>        Function_Return (Parent(Parent(Self)))
96959>>>>>>>    End_Function
96960>>>>>>>    
96960>>>>>>>    Procedure AdjustTabWorkspaceView Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
96962>>>>>>>        Integer iSize iMax iDiff
96962>>>>>>>        Handle hoView
96962>>>>>>>        Boolean bCenter bModal
96962>>>>>>>        Get ParentView to hoView
96963>>>>>>>        Get Block_Mouse_State of hoView to bModal
96964>>>>>>>        If not bModal Begin
96966>>>>>>>            Get CenterTabWorkspaceView to bCenter
96967>>>>>>>            Get GuiSize of hoView to iSize
96968>>>>>>>            Get piMaxSize of hoView to iMax
96969>>>>>>>            Get DialogToGui (Hi(iMax)) (Low(iMax)) to iMax
96970>>>>>>>            If (Low(iMax) and Low(iMax)<=Low(isize)) Begin
96972>>>>>>>                If bCenter Begin
96974>>>>>>>                    Move ((Low(iSize)-Low(iMax))/2) to iLocX
96975>>>>>>>                End
96975>>>>>>>>
96975>>>>>>>                Move (Low(iMax)) to iWidth
96976>>>>>>>            End
96976>>>>>>>>
96976>>>>>>>            If (Hi(iMax) and Hi(iMax)<=Hi(iSize)) Begin
96978>>>>>>>                If bCenter Begin
96980>>>>>>>                    Move ((Hi(iSize)-Hi(iMax))/2) to iLocY
96981>>>>>>>                    Move (iLocy min 25) to  iLocY
96982>>>>>>>                End
96982>>>>>>>>
96982>>>>>>>                Move (Hi(imax)) to iHeight
96983>>>>>>>            End
96983>>>>>>>>
96983>>>>>>>        End
96983>>>>>>>>
96983>>>>>>>    End_Procedure
96984>>>>>>>    
96984>>>>>>>    // Automatically determine if this is a scrolling tabbed workspace view
96984>>>>>>>    // If determines this by checking pbAutoSetTabWorkspaceView is set (it can be
96984>>>>>>>    // set to stop this), if we have a global commandbar object and we are using tabbed
96984>>>>>>>    // workspaces. We also make sure that the expected view object is a framework view class
96984>>>>>>>    // This should almost always yield the right answer.
96984>>>>>>>    // This is called by the scrolling container's end_constructor
96984>>>>>>>    Procedure AutoSetTabWorkspaceView
96986>>>>>>>        Boolean bTabView bIsView bAutoSetTabWorkspaceView
96986>>>>>>>        Handle hoParent
96986>>>>>>>        Integer iSize
96986>>>>>>>        Get pbAutoSetTabWorkspaceView to bAutoSetTabWorkspaceView
96987>>>>>>>        If (ghoCommandBars and bAutoSetTabWorkspaceView) Begin
96989>>>>>>>            Get pbTabbedWorkspaces of ghoCommandBars to bTabView
96990>>>>>>>            // not that pbTabbedWorkspaces is a designtime only property. You can not
96990>>>>>>>            // change this after the commandbar is paged.
96990>>>>>>>            If (bTabView) Begin
96992>>>>>>>                Get ParentView to hoParent
96993>>>>>>>                Get IsObjectOfClass of hoParent (RefClass(MdiDialog)) to bIsView
96994>>>>>>>                If (bIsView) Begin
96996>>>>>>>                    // set this as a tab workspace view
96996>>>>>>>                    Set pbTabWorkspaceView to True
96997>>>>>>>                    // when tab workspaces are enabled we always enable auto-scrolling
96997>>>>>>>                    // when tab workspaces are not enabled, pbScroll is whatever it is
96997>>>>>>>                    Set pbAutoScroll to True
96998>>>>>>>                    
96998>>>>>>>                End
96998>>>>>>>>
96998>>>>>>>            End
96998>>>>>>>>
96998>>>>>>>        End
96998>>>>>>>>
96998>>>>>>>    End_Procedure
96999>>>>>>>    
96999>>>>>>>End_Class
97000>>>>>>>
97000>>>>>>>// Container scrolling class support. Nothing in here is public
97000>>>>>>>Class cScrollingContainerMixin is a Mixin
97001>>>>>>>    
97001>>>>>>>    Procedure Define_cScrollingContainerMixin
97003>>>>>>>        Forward Set Border_Style to Border_None
97005>>>>>>>        Set pbSizeToClientArea to False // scrollbars and clientsize do not mix
97006>>>>>>>        Forward Set peAnchors to anAll
97008>>>>>>>        
97008>>>>>>>        // forcing scrollbars right away seems to make painting better
97008>>>>>>>        Set Window_Style WS_HSCROLL to True
97009>>>>>>>        Set Window_Style WS_VSCROLL to True
97010>>>>>>>        
97010>>>>>>>        Property Handle phoScrollingClientArea 0
97011>>>>>>>    End_Procedure
97012>>>>>>>    
97012>>>>>>>    // if anchors are changed, it will not work. We won't let that happen
97012>>>>>>>    Procedure Set peAnchors Integer eAnchors
97014>>>>>>>    End_Procedure
97015>>>>>>>    
97015>>>>>>>    // if a border style is set, it will not work. We won't let that happen
97015>>>>>>>    Procedure Set Border_Style Integer eStyle
97017>>>>>>>    End_Procedure
97018>>>>>>>    
97018>>>>>>>    // redirect scrollbar events and wheel events to the scrolling client area
97018>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
97020>>>>>>>        Handle hoClient
97020>>>>>>>        Get phoScrollingClientArea to hoClient
97021>>>>>>>        If hoClient Begin
97023>>>>>>>            Send OnMouseWheel of hoClient wParam lParam
97024>>>>>>>        End
97024>>>>>>>>
97024>>>>>>>    End_Procedure
97025>>>>>>>    
97025>>>>>>>    // should be sent by WM_VSCROLL
97025>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
97027>>>>>>>        Handle hoClient
97027>>>>>>>        Get phoScrollingClientArea to hoClient
97028>>>>>>>        If hoClient Begin
97030>>>>>>>            Send SetVScrollbox of hoClient iType iNewPos
97031>>>>>>>        End
97031>>>>>>>>
97031>>>>>>>    End_Procedure
97032>>>>>>>    
97032>>>>>>>    // should be sent by WM_HSCROLL
97032>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
97034>>>>>>>        Handle hoClient
97034>>>>>>>        Get phoScrollingClientArea to hoClient
97035>>>>>>>        If hoClient Begin
97037>>>>>>>            Send SetHScrollbox of hoClient iType iNewPos
97038>>>>>>>        End
97038>>>>>>>>
97038>>>>>>>    End_Procedure
97039>>>>>>>    
97039>>>>>>>    // augmented to adjust its size to the size of the parent client area.
97039>>>>>>>    // After this is set, anchors will handle any further resizing.
97039>>>>>>>    Procedure Page Integer iState
97041>>>>>>>        Integer iSiz iHeight iWidth
97041>>>>>>>        Integer iTop iBottom iLeft iRight iFontSize
97041>>>>>>>        Boolean bGroup
97041>>>>>>>        Handle hoClient
97041>>>>>>>        If (iState =1) Begin
97043>>>>>>>            Delegate Get Window_Style BS_GROUPBOX to bGroup
97045>>>>>>>            // We have special code to support groups because they
97045>>>>>>>            // draw a border inside of the client rectangle
97045>>>>>>>            If bGroup Begin
97047>>>>>>>                Get Physical_FontSize to iFontSize
97048>>>>>>>                Move (Hi(iFontSize)) to iTop
97049>>>>>>>                Move 2 to iLeft
97050>>>>>>>                Move 2 to iRight
97051>>>>>>>                Move 2 to iBottom
97052>>>>>>>            End
97052>>>>>>>>
97052>>>>>>>            // We use GetContainerClientSize instead of GuiClientSize because
97052>>>>>>>            // GetContainerClientSize has a special augmentation in tab pages that
97052>>>>>>>            // makes anchors work properly with unpaged tab-pages
97052>>>>>>>            Delegate Get GetContainerClientSize to iSiz
97054>>>>>>>            Set GuiSize to (Hi(iSiz)-(iTop+iBottom)) (Low(iSiz)-(iLeft+iRight))
97055>>>>>>>            Set GuiLocation to iTop iLeft
97056>>>>>>>            Send Adjust_Logicals
97057>>>>>>>        End
97057>>>>>>>>
97057>>>>>>>        Forward Send Page iState
97059>>>>>>>    End_Procedure
97060>>>>>>>    
97060>>>>>>>    Procedure End_Construct_Object
97062>>>>>>>        Handle hoClient
97062>>>>>>>        Forward Send End_Construct_Object
97064>>>>>>>        Get phoScrollingClientArea to hoClient
97065>>>>>>>        If (hoClient) Begin
97067>>>>>>>            Send AutoSetTabWorkspaceView of hoClient
97068>>>>>>>        End
97068>>>>>>>>
97068>>>>>>>    End_Procedure
97069>>>>>>>    
97069>>>>>>>End_Class
97070>>>>>
97070>>>>>Class cDbScrollingClientArea is a dbContainer3d
97071>>>>>    Import_Class_Protocol cScrollingClientAreaMixin
97072>>>>>    Procedure Construct_Object
97074>>>>>        Forward Send Construct_Object
97076>>>>>        Send Define_cScrollingClientAreaMixin
97077>>>>>    End_Procedure
97078>>>>>End_Class
97079>>>>>
97079>>>>>
97079>>>>>
97079>>>>>Class cDbScrollingContainer is a dbContainer3d
97080>>>>>    Import_Class_Protocol cScrollingContainerMixin
97081>>>>>    Procedure Construct_Object
97083>>>>>        Forward Send Construct_Object
97085>>>>>        Send Define_cScrollingContainerMixin
97086>>>>>    End_Procedure
97087>>>>>End_Class
97088>>>Use cDbUpdateFunctionLibrary.pkg
97088>>>Use cRDCButtonDPI.pkg
Including file: cRDCButtonDPI.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButtonDPI.pkg)
97088>>>>>//****************************************************************************
97088>>>>>// $Module type: Package
97088>>>>>// $Module name: cRDCButtonDPI.pkg
97088>>>>>//
97088>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
97088>>>>>// Copyright (c) 2013 RDC Tools International
97088>>>>>// E-mail      : support@rdctools.com
97088>>>>>// Web-site    : http://www.rdctools.com
97088>>>>>//
97088>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
97088>>>>>//
97088>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
97088>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
97088>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
97088>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
97088>>>>>// in the help folder for more details.
97088>>>>>//
97088>>>>>//****************************************************************************
97088>>>>>Use cRDCButton.pkg
Including file: cRDCButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButton.pkg)
97088>>>>>>>//****************************************************************************
97088>>>>>>>// $Module type: Package
97088>>>>>>>// $Module name: cRDCButton.pkg
97088>>>>>>>//
97088>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
97088>>>>>>>// Copyright (c) 2013 RDC Tools International
97088>>>>>>>// E-mail      : support@rdctools.com
97088>>>>>>>// Web-site    : http://www.rdctools.com
97088>>>>>>>//
97088>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
97088>>>>>>>//
97088>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
97088>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
97088>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
97088>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
97088>>>>>>>// in the help folder for more details.
97088>>>>>>>//
97088>>>>>>>//****************************************************************************
97088>>>>>>>Use Windows.pkg
97088>>>>>>>Use Enclient.pkg
97088>>>>>>>Use errornum.inc
97088>>>>>>>
97088>>>>>>>Class cButtonIdleHandler is a cIdleHandler
97089>>>>>>>    Procedure Construct_Object
97091>>>>>>>        Forward Send Construct_Object
97093>>>>>>>
97093>>>>>>>    End_Procedure
97094>>>>>>>
97094>>>>>>>    Procedure OnIdle
97096>>>>>>>        Delegate Send DoUpdate
97098>>>>>>>    End_Procedure
97099>>>>>>>
97099>>>>>>>End_Class
97100>>>>>>>
97100>>>>>>>Class cRDCButton is a Button
97101>>>>>>>
97101>>>>>>>    Procedure Construct_Object
97103>>>>>>>        Forward Send Construct_Object
97105>>>>>>>
97105>>>>>>>        Property Boolean pbAutoEnable True
97106>>>>>>>
97106>>>>>>>        Property Boolean pbEnabled True
97107>>>>>>>
97107>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cButtonIdleHandler)))
97108>>>>>>>
97108>>>>>>>        On_Key kCancel Send CancelIfPopupObject
97109>>>>>>>    End_Procedure
97110>>>>>>>
97110>>>>>>>    Procedure CancelIfPopupObject
97112>>>>>>>        Boolean bIsInPopupObject
97112>>>>>>>        Delegate Get Popup_State to bIsInPopupObject
97114>>>>>>>        If (bIsInPopupObject = True) Begin
97116>>>>>>>            Send Close_Panel
97117>>>>>>>        End
97117>>>>>>>>
97117>>>>>>>    End_Procedure
97118>>>>>>>
97118>>>>>>>    Procedure End_Construct_Object
97120>>>>>>>        String sTooltip sStatus_Help
97120>>>>>>>
97120>>>>>>>        Forward Send End_Construct_Object
97122>>>>>>>
97122>>>>>>>        Get psToolTip   to sTooltip
97123>>>>>>>        Get Status_Help to sStatus_Help
97124>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
97126>>>>>>>            Set psToolTip to sStatus_Help
97127>>>>>>>        End
97127>>>>>>>>
97127>>>>>>>        If (sTooltip <> "" and sStatus_Help = "") Begin
97129>>>>>>>            Set Status_Help to sToolTip
97130>>>>>>>        End
97130>>>>>>>>
97130>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
97131>>>>>>>    End_Procedure
97132>>>>>>>
97132>>>>>>>    Procedure DoUpdate
97134>>>>>>>        If (pbAutoEnable(Self) = False) Begin
97136>>>>>>>            Procedure_Return
97137>>>>>>>        End
97137>>>>>>>>
97137>>>>>>>        Set Enabled_State to (IsEnabled(Self))
97138>>>>>>>    End_Procedure
97139>>>>>>>
97139>>>>>>>    Function IsEnabled Returns Boolean
97141>>>>>>>        Boolean bEnabled
97141>>>>>>>        Get pbEnabled to bEnabled
97142>>>>>>>        Function_Return bEnabled
97143>>>>>>>    End_Function
97144>>>>>>>
97144>>>>>>>    // Enable the idle handler timer when the button is activated
97144>>>>>>>    Procedure Activating
97146>>>>>>>        Forward Send Activating
97148>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
97149>>>>>>>    End_Procedure
97150>>>>>>>
97150>>>>>>>    // Disable the idle handler when the button is deactivated
97150>>>>>>>    Procedure Deactivating
97152>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
97153>>>>>>>        Forward Send Deactivating
97155>>>>>>>    End_Procedure
97156>>>>>>>
97156>>>>>>>End_Class
97157>>>>>
97157>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
97157>>>>>Class cRDCButtonDPI is a cRDCButton
97158>>>>>    Procedure Construct_Object
97160>>>>>        Integer iIconSize
97160>>>>>        Forward Send Construct_Object
97162>>>>>        Set piImageMarginLeft to 10
97163>>>>>    End_Procedure
97164>>>>>
97164>>>>>    // Returns: DPI setting as an integer.
97164>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
97164>>>>>    //                      iDPI=120 is "Medium setting" 125%
97164>>>>>    //                      iDPI= 144 is "Large setting" 150%
97164>>>>>    Function GetCurrentDPI Returns Integer
97166>>>>>        Handle hDC
97166>>>>>        Integer iPixelsX
97166>>>>>        Move (GetDC(0)) to hDC
97167>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
97168>>>>>        Move (ReleaseDC(0, hDC)) to hDC
97169>>>>>        Function_Return iPixelsX
97170>>>>>    End_Function
97171>>>>>
97171>>>>>    Function GetCorrectIconSize Returns Integer
97173>>>>>        Integer iPixelsX iIndex iSize
97173>>>>>        Integer[] iaSizes
97174>>>>>
97174>>>>>        Move 16 to iaSizes[0]
97175>>>>>        Move 24 to iaSizes[1]
97176>>>>>        Move 32 to iaSizes[2]
97177>>>>>        Move 48 to iaSizes[3]
97178>>>>>        Move 64 to iaSizes[4]
97179>>>>>
97179>>>>>        Get piImageSize to iSize  // the "100%" size
97180>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
97181>>>>>        Move (0 max iIndex) to iIndex
97182>>>>>        Get GetCurrentDPI to iPixelsX
97183>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
97183>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
97183>>>>>        // will increment iIndex as many times as we need here.
97183>>>>>        Case Begin
97183>>>>>            Case (iPixelsX > 144)
97185>>>>>                Increment iIndex
97186>>>>>            Case (iPixelsX = 144)
97189>>>>>                Increment iIndex
97190>>>>>            Case (iPixelsX = 120)
97193>>>>>                Increment iIndex
97194>>>>>        Case End
97194>>>>>        Move (iIndex min 4) to iIndex
97195>>>>>        Function_Return iaSizes[iIndex]
97196>>>>>    End_Function
97197>>>>>
97197>>>>>    Procedure Set psToolTip String sToolTip
97199>>>>>        String sStatusHelp
97199>>>>>
97199>>>>>        Get Status_Help to sStatusHelp
97200>>>>>        If (sStatusHelp = "") Begin
97202>>>>>            Set Status_Help to sToolTip
97203>>>>>        End
97203>>>>>>
97203>>>>>
97203>>>>>        Forward Set psToolTip to sToolTip
97205>>>>>    End_Procedure
97206>>>>>
97206>>>>>End_Class
97207>>>Use DatabaseSelection.dg
97207>>>Use ServerSelection.dg
Including file: ServerSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ServerSelection.dg)
97207>>>>>Use Windows.pkg
97207>>>>>Use cCJGridPromptList.pkg
97207>>>>>Use MSSqldrv.pkg
97207>>>>>Use db2_drv.pkg
97207>>>>>Use odbc_drv.pkg    
97207>>>>>Use cRDCModalPanel.pkg
97207>>>>>Use cDbUpdateFunctionLibrary.pkg
97207>>>>>
97207>>>>>Object oServerSelection_sl is a cRDCModalPanel
97209>>>>>    Set Size to 105 225
97210>>>>>    Set Label to "Database Server/DSN Selection"
97211>>>>>    Set piMinSize to 89 211
97212>>>>>    Set Location to 2 2
97213>>>>>    Set Icon to "ServerLookup1.ico"
97214>>>>>
97214>>>>>    Property String[] psTheData
97216>>>>>
97216>>>>>    Object oSelList is a cCJGridPromptList
97218>>>>>        Set Size to 72 215
97219>>>>>        Set Location to 6 6
97220>>>>>        Set peAnchors to anAll
97221>>>>>        Set pbAllowColumnRemove to False
97222>>>>>        Set pbUseAlternateRowBackgroundColor to True
97223>>>>>        Set pbGrayIfDisable to False
97224>>>>>        Set pbHeaderReorders to False
97225>>>>>        Set pbHeaderSelectsColumn to False
97226>>>>>        Set pbHeaderTogglesDirection to False
97227>>>>>        Set pbShadeSortColumn to False
97228>>>>>        Set piFocusCellBackColor to clDkGray
97229>>>>>
97229>>>>>        Object oName is a cCJGridColumn
97231>>>>>            Set piWidth to 358
97232>>>>>            Set psCaption to "Name"
97233>>>>>        End_Object
97234>>>>>
97234>>>>>        Procedure Activating
97237>>>>>            tDataSourceRow[] MyData
97237>>>>>            tDataSourceRow[] MyData
97238>>>>>            Handle hoDataSource
97238>>>>>            String[] sTheData
97239>>>>>            Integer iCount iSize
97239>>>>>
97239>>>>>            Send Cursor_Wait of Cursor_Control
97240>>>>>            Get psTheData to sTheData
97241>>>>>            Move (SizeOfArray(sTheData)) to iSize
97242>>>>>            Decrement iSize
97243>>>>>            For iCount from 0 to iSize
97249>>>>>>
97249>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
97250>>>>>            Loop
97251>>>>>>
97251>>>>>
97251>>>>>            Forward Send Activating
97253>>>>>
97253>>>>>            Get phoDataSource to hoDataSource
97254>>>>>            Send InitializeData of hoDataSource MyData
97255>>>>>            Send Cursor_Ready of Cursor_Control
97256>>>>>        End_Procedure
97257>>>>>
97257>>>>>    End_Object
97258>>>>>
97258>>>>>    Object oOK_Btn is a Button
97260>>>>>        Set Size to 14 50
97261>>>>>        Set Label    to "&OK"
97262>>>>>        Set Location to 85 116
97263>>>>>        Set peAnchors To anBottomRight
97264>>>>>
97264>>>>>        Procedure OnClick
97267>>>>>            Send Ok of oSelList
97268>>>>>        End_Procedure
97269>>>>>
97269>>>>>    End_Object
97270>>>>>
97270>>>>>    Object oCancel_Btn is a Button
97272>>>>>        Set Size to 14 50
97273>>>>>        Set Label    to "&Cancel"
97274>>>>>        Set Location to 85 171
97275>>>>>        Set peAnchors to anBottomRight
97276>>>>>
97276>>>>>        Procedure OnClick
97279>>>>>            Send Close_Panel
97280>>>>>        End_Procedure
97281>>>>>
97281>>>>>    End_Object
97282>>>>>
97282>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
97283>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
97284>>>>>End_Object
97285>>>Use SQLConnections.dg
Including file: SQLConnections.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLConnections.dg)
97285>>>>>Use Windows.pkg
97285>>>>>Use cCJGridPromptList.pkg
97285>>>>>Use cDbUpdateFunctionLibrary.pkg
97285>>>>>Use MSSqldrv.pkg
97285>>>>>Use db2_drv.pkg
97285>>>>>Use odbc_drv.pkg
97285>>>>>Use cCJGridColumn.pkg
97285>>>>>
97285>>>>>Object oSQLConnections is a ModalPanel
97287>>>>>    Set Label to "SQL Connections"
97288>>>>>    Set Size to 121 397
97289>>>>>    Set piMinSize to 89 185
97290>>>>>    Set Location to 2 2
97291>>>>>    Set Border_Style to Border_Thick
97292>>>>>
97292>>>>>    Property tSQLConnection[] psTheData
97294>>>>>
97294>>>>>//    If (ghoDbUpdateFunctionLibrary = 0) Begin
97294>>>>>//        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
97294>>>>>//        End_Object
97294>>>>>//    End
97294>>>>>
97294>>>>>    Object oSelListSQLConnections is a cCJGridPromptList
97296>>>>>        Set Size to 90 377
97297>>>>>        Set Location to 6 6
97298>>>>>        Set peAnchors to anAll
97299>>>>>        Set pbAllowColumnRemove to False
97300>>>>>        Set pbUseAlternateRowBackgroundColor to True
97301>>>>>        Set pbGrayIfDisable to False
97302>>>>>        Set pbHeaderReorders to False
97303>>>>>        Set pbHeaderSelectsColumn to False
97304>>>>>        Set pbHeaderTogglesDirection to False
97305>>>>>        Set pbShadeSortColumn to False
97306>>>>>        Set piFocusCellBackColor to clDkGray  
97307>>>>>        Set pbRestoreLayout to True
97308>>>>>        Set psLayoutSection to "oSQLConnections_oSelListSQLConnections"
97309>>>>>
97309>>>>>        Object oID_Col is a cCJGridColumn
97311>>>>>            Set piWidth to 132
97312>>>>>            Set psCaption to "ID"
97313>>>>>        End_Object
97314>>>>>
97314>>>>>        Object oDbType_Col is a cCJGridColumn
97316>>>>>            Set piWidth to 182
97317>>>>>            Set psCaption to "Database Type"
97318>>>>>        End_Object
97319>>>>>
97319>>>>>        Object oServer_Col is a cCJGridColumn
97321>>>>>            Set piWidth to 296
97322>>>>>            Set psCaption to "Server/DSN"
97323>>>>>        End_Object
97324>>>>>
97324>>>>>        Object oDatabase_Col is a cCJGridColumn
97326>>>>>            Set piWidth to 211
97327>>>>>            Set psCaption to "Database"
97328>>>>>        End_Object
97329>>>>>
97329>>>>>        Object oDriverID_Col is a cCJGridColumn
97331>>>>>            Set piWidth to 121
97332>>>>>            Set psCaption to "Driver ID"
97333>>>>>        End_Object
97334>>>>>
97334>>>>>        Procedure Activating
97337>>>>>            tDataSourceRow[] MyData
97337>>>>>            tDataSourceRow[] MyData
97338>>>>>            Handle hoDataSource
97338>>>>>            Integer iCount iSize iPos
97338>>>>>            String sDriverID sConnectionID sValue
97338>>>>>            tSQLConnection[] sTheData
97338>>>>>            tSQLConnection[] sTheData
97339>>>>>
97339>>>>>            Send Cursor_Wait of Cursor_Control
97340>>>>>            Forward Send Activating
97342>>>>>
97342>>>>>            Get psTheData to sTheData
97343>>>>>            Move (SizeOfArray(sTheData)) to iSize
97344>>>>>            Decrement iSize
97345>>>>>            For iCount from 0 to iSize
97351>>>>>>
97351>>>>>                Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary sTheData[iCount].iDbType to sValue
97352>>>>>                Move sTheData[iCount].sConnectionID to MyData[iCount].sValue[0]
97353>>>>>                Move sValue                         to MyData[iCount].sValue[1]
97354>>>>>                Move sTheData[iCount].sServer       to MyData[iCount].sValue[2]
97355>>>>>                Move sTheData[iCount].sDatabase     to MyData[iCount].sValue[3]
97356>>>>>                Move sTheData[iCount].sDriverID     to MyData[iCount].sValue[4]
97357>>>>>            Loop
97358>>>>>>
97358>>>>>
97358>>>>>            Get phoDataSource to hoDataSource
97359>>>>>            Send InitializeData of hoDataSource MyData
97360>>>>>            Send Cursor_Ready of Cursor_Control
97361>>>>>        End_Procedure
97362>>>>>
97362>>>>>    End_Object
97363>>>>>
97363>>>>>    Object oOK_Btn is a Button
97365>>>>>        Set Label    to "&OK"
97366>>>>>        Set Location to 101 280
97367>>>>>        Set peAnchors to anBottomRight
97368>>>>>
97368>>>>>        Procedure OnClick
97371>>>>>            Send Ok of oSelListSQLConnections
97372>>>>>        End_Procedure
97373>>>>>
97373>>>>>    End_Object
97374>>>>>
97374>>>>>    Object oCancel_Btn is a Button
97376>>>>>        Set Label    to "&Cancel"
97377>>>>>        Set Location to 101 335
97378>>>>>        Set peAnchors to anBottomRight
97379>>>>>
97379>>>>>        Procedure OnClick
97382>>>>>            Send Close_Panel
97383>>>>>        End_Procedure
97384>>>>>
97384>>>>>    End_Object
97385>>>>>
97385>>>>>    Procedure Page Integer iPageObject
97388>>>>>        Set Icon to "SQLConnections1.ico"
97389>>>>>        Forward Send Page iPageObject
97391>>>>>    End_Procedure
97392>>>>>
97392>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
97393>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
97394>>>>>End_Object
97395>>>
97395>>>Activate_View Activate_oSQLConnections_vw for oSQLConnections_vw
97405>>>>
97405>>>Object oSQLConnections_vw is a dbView
97407>>>    Set Border_Style to Border_Thick
97408>>>    Set Size to 251 427
97409>>>    Set Location to 2 2
97410>>>    Set Label to "SQL Connections"
97411>>>    Set pbAutoActivate to True
97412>>>    Set Icon to "SQLConnections1.ico"
97413>>>
97413>>>    Object oScrollingContainer1 is a cDbScrollingContainer
97415>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
97417>>>
97417>>>            Object oCurrentSettings_grp is a Group
97419>>>                Set Size to 232 402
97420>>>                Set Location to 6 12
97421>>>                Set Label to "Current Connection Settings"
97422>>>                Set peAnchors to anAll
97423>>>
97423>>>                Object oConnectionID_fm is a Form
97425>>>                    Set Size to 12 100
97426>>>                    Set Location to 12 68
97427>>>                    Set Label to "Connection ID"
97428>>>                    Set Label_Col_Offset to 2
97429>>>                    Set Label_Justification_Mode to JMode_Right
97430>>>                    Set Prompt_Button_Mode to PB_PromptOn
97431>>>                    Set Prompt_Object to (oSQLConnections(Self))
97432>>>
97432>>>                    Procedure Prompt
97435>>>                        String[] sTheData
97436>>>                        String sCurrentVal sNewVal
97436>>>                        Handle hoIniFile ho
97436>>>                        Integer iSize iCount
97436>>>                        tSQLConnection[] SQLConnectionArray
97436>>>                        tSQLConnection[] SQLConnectionArray
97437>>>
97437>>>                        Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to hoIniFile
97438>>>                        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
97439>>>                        Get Value to sCurrentVal
97440>>>                        Get Prompt_Object to ho
97441>>>                        Set psTheData of ho to SQLConnectionArray
97442>>>
97442>>>                        Forward Send Prompt
97444>>>                        Get Value to sNewVal
97445>>>                        If (sCurrentVal <> sNewVal) Begin
97447>>>                            Send Cursor_Wait of Cursor_Control
97448>>>                            Set psConnectionID of ghoSQLConnectionHandler to sNewVal
97449>>>                            Broadcast Recursive Send Refresh of (phoMainPanel(ghoApplication))
97451>>>                            Send Cursor_Ready of Cursor_Control
97452>>>                            Send KeyAction of oTestLogin_btn
97453>>>                        End
97453>>>>
97453>>>                    End_Procedure   
97454>>>                    
97454>>>                    Procedure PromptUpdate Handle hoPrompt
97457>>>                        String[] sSelectedNames                    
97458>>>                
97458>>>                        Get SelectedColumnValues of hoPrompt 2 to sSelectedNames // Col 2 = Server column
97459>>>                        If (SizeOfArray(sSelectedNames)) Begin
97461>>>                            Set psServer of ghoSQLConnectionHandler to sSelectedNames[0] 
97462>>>                            Delegate Send Page True // Broadcast sends refresh
97464>>>                        End
97464>>>>
97464>>>                    End_Procedure   
97465>>>
97465>>>                    Procedure Prompt_Callback Handle hoPrompt
97468>>>                        String sServer
97468>>>                        Set peUpdateMode of hoPrompt to umPromptCustom
97469>>>                        Set piUpdateColumn of hoPrompt to 2 // The server column
97470>>>                        Get Value of oServer_fm to sServer
97471>>>                        Set psSeedValue of hoPrompt to sServer
97472>>>                        Set phmPromptUpdateCallback of hoPrompt to (RefProc(PromptUpdate))
97473>>>                    End_Procedure
97474>>>
97474>>>                    Procedure Refresh
97477>>>                        String sValue
97477>>>                        Get psConnectionID of ghoSQLConnectionHandler to sValue
97478>>>                        Set Value to sValue
97479>>>                    End_Procedure
97480>>>
97480>>>                End_Object
97481>>>
97481>>>                Object oDriverID_cf is a ComboForm
97483>>>                    Set Size to 12 91
97484>>>                    Set Location to 12 222
97485>>>                    Set Label_Col_Offset to 2
97486>>>                    Set Label_Justification_Mode to JMode_Right
97487>>>                    Set Label to "Driver ID"
97488>>>                    Set Entry_State to False
97489>>>                    Set Enabled_State to False
97490>>>
97490>>>                    Procedure Combo_Fill_List
97493>>>                        Send Combo_Add_Item MSSQLDRV_ID
97494>>>                        Send Combo_Add_Item DB2_DRV_ID
97495>>>                        Send Combo_Add_Item ODBC_DRV_ID
97496>>>                    End_Procedure
97497>>>
97497>>>                    Procedure OnChange
97500>>>                        String sValue sOrgValue
97500>>>                        Boolean bEnabled bChecked
97500>>>
97500>>>                        Get Value to sValue
97501>>>                        Get psDriverID of ghoSQLConnectionHandler to sOrgValue
97502>>>                        If (sValue <> "" and sValue <> sOrgValue and sValue <> "None") Begin
97504>>>                            Set psDriverID of ghoSQLConnectionHandler to sValue
97505>>>                        End
97505>>>>
97505>>>                        Move (sValue <> "None") to bEnabled
97506>>>                        Broadcast Set Enabled_State of (Parent(Self)) to bEnabled
97508>>>                        Set Enabled_State to False
97509>>>                        Set Enabled_State of oConnectionString_fm to False
97510>>>                        Set Enabled_State of oDatabase_fm to (sValue <> DB2_DRV_ID)
97511>>>
97511>>>                        Get Checked_State of oTrusted_cb  to bChecked
97512>>>                        Set Enabled_State of oUserID_fm   to (bChecked = False)
97513>>>                        Set Enabled_State of oPassword_fm to (bChecked = False)
97514>>>                    End_Procedure
97515>>>
97515>>>                    Procedure Refresh
97518>>>                        String sValue
97518>>>
97518>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
97519>>>                        Set Value to sValue
97520>>>                    End_Procedure
97521>>>
97521>>>                End_Object
97522>>>
97522>>>                Object oServer_fm is a Form
97524>>>                    Set Size to 12 100
97525>>>                    Set Location to 26 68
97526>>>                    Set Label to "Server"
97527>>>                    Set Label_Col_Offset to 2
97528>>>                    Set Label_Justification_Mode to JMode_Right
97529>>>                    Set Prompt_Button_Mode to PB_PromptOn
97530>>>                    Set Prompt_Object to (oServerSelection_sl(Self))
97531>>>
97531>>>                    Procedure Refresh
97534>>>                        String sValue
97534>>>                        Get psServer of ghoSQLConnectionHandler to sValue
97535>>>                        Set Value to sValue
97536>>>                    End_Procedure
97537>>>
97537>>>                    Procedure Prompt
97540>>>                        String[] sTheData
97541>>>                        String sDriverID
97541>>>                        Handle ho
97541>>>
97541>>>                        Send Cursor_Wait of Cursor_Control
97542>>>                        Get Prompt_Object to ho
97543>>>                        Get Value of oDriverID_cf to sDriverID
97544>>>                        Get SqlUtilEnumerateServers of ghoDbUpdateFunctionLibrary sDriverID 2 to sTheData
97545>>>                        Set psTheData of ho to sTheData
97546>>>                        Send Cursor_Ready of Cursor_Control
97547>>>
97547>>>                        Forward Send Prompt
97549>>>                    End_Procedure
97550>>>
97550>>>                End_Object
97551>>>
97551>>>                Object oDatabase_fm is a Form
97553>>>                    Set Size to 12 91
97554>>>                    Set Location to 26 222
97555>>>                    Set Label to "Database"
97556>>>                    Set Label_Col_Offset to 2
97557>>>                    Set Label_Justification_Mode to JMode_Right
97558>>>                    Set Prompt_Button_Mode to PB_PromptOn
97559>>>                    Set Prompt_Object to (oDatabaseSelection_sl(Self))
97560>>>                    Set peAnchors to anNone
97561>>>                    Set Entry_State to False
97562>>>
97562>>>                    Procedure Refresh
97565>>>                        String sDatabase
97565>>>
97565>>>                        Get psDatabase of ghoSQLConnectionHandler to sDatabase
97566>>>                        Set Value to sDatabase
97567>>>                    End_Procedure
97568>>>
97568>>>                    Procedure Prompt
97571>>>                        String[] sTheData
97572>>>                        Handle ho
97572>>>                        String sDriverID
97572>>>
97572>>>                        Get Value of oDriverID_cf to sDriverID
97573>>>                        Get SqlUtilEnumerateDatabases of ghoDbUpdateFunctionLibrary sDriverID to sTheData
97574>>>
97574>>>                        Get Prompt_Object to ho
97575>>>                        Set psTheData of ho to sTheData
97576>>>
97576>>>                        Forward Send Prompt
97578>>>                    End_Procedure
97579>>>
97579>>>                    Procedure OnChange
97582>>>                        String sValue sOrgValue
97582>>>                        Get Value to sValue
97583>>>                        Get psDatabase of ghoSQLConnectionHandler to sOrgValue
97584>>>                        If (Uppercase(Trim(sValue)) <> Uppercase(Trim(sOrgValue))) Begin
97586>>>                            Set psDatabase of ghoSQLConnectionHandler to sValue
97587>>>                            Get psConnectionString of ghoSQLConnectionHandler to sValue
97588>>>                            Set Value of oConnectionString_fm to sValue
97589>>>                        End
97589>>>>
97589>>>                    End_Procedure
97590>>>
97590>>>                End_Object
97591>>>
97591>>>                Object oTrusted_cb is a CheckBox
97593>>>                    Set Size to 10 50
97594>>>                    Set Location to 45 68
97595>>>                    Set Label to "Use Trusted Connection"
97596>>>
97596>>>                    Procedure Refresh
97599>>>                        Boolean bValue
97599>>>                        Get pbTrusted of ghoSQLConnectionHandler to bValue
97600>>>                        Set Checked_State to bValue
97601>>>                    End_Procedure
97602>>>
97602>>>                    Procedure OnChange
97605>>>                        Boolean bChecked
97605>>>
97605>>>                        Get Checked_State to bChecked
97606>>>                        Set Enabled_State of oUserID_fm   to (bChecked = False)
97607>>>                        Set Enabled_State of oPassword_fm to (bChecked = False)
97608>>>                    End_Procedure
97609>>>
97609>>>                End_Object
97610>>>
97610>>>                Object oUserID_fm is a Form
97612>>>                    Set Size to 12 100
97613>>>                    Set Location to 57 68
97614>>>                    Set Label to "UserID"
97615>>>                    Set Label_Col_Offset to 2
97616>>>                    Set Label_Justification_Mode to JMode_Right
97617>>>
97617>>>                    Procedure Refresh
97620>>>                        String sValue
97620>>>                        Get psUserID of ghoSQLConnectionHandler to sValue
97621>>>                        Set Value to sValue
97622>>>                    End_Procedure
97623>>>
97623>>>                End_Object
97624>>>
97624>>>                Object oPassword_fm is a Form
97626>>>                    Set Size to 12 91
97627>>>                    Set Location to 57 222
97628>>>                    Set Label to "Password"
97629>>>                    Set Label_Col_Offset to 2
97630>>>                    Set Label_Justification_Mode to JMode_Right
97631>>>                    // Set psToolTip to "Note: The password form does _not_ have it's password state set to True because the view is for testing purposes only. And we can see the password - if set - from the connection string as well."
97631>>>                    Set psToolTip to "Press the 'Toggle Password' button to reveal the password"
97632>>>                    Set Password_State to True
97633>>>
97633>>>                    Procedure Refresh
97636>>>                        String sValue
97636>>>                        Get psPassword of ghoSQLConnectionHandler to sValue
97637>>>                        Set Value to sValue
97638>>>                    End_Procedure
97639>>>
97639>>>                End_Object
97640>>>
97640>>>                Object oViewPassword_btn is a cRDCButtonDPI
97642>>>                    Set Size to 12 19
97643>>>                    Set Location to 57 317
97644>>>                    Set psToolTip to "Toggle password"
97645>>>                    Set psImage to "ViewPassword1.ico"
97646>>>                    Set piImageMarginLeft to 0
97647>>>
97647>>>                    Procedure OnClick
97650>>>                        Boolean bState
97650>>>                        Get Password_State of oPassword_fm to bState
97651>>>                        Send Page_Object   of oPassword_fm False
97652>>>                        Set Password_State of oPassword_fm to (not(bState))
97653>>>                        Send Page_Object   of oPassword_fm True
97654>>>                    End_Procedure
97655>>>
97655>>>                End_Object
97656>>>
97656>>>                Object oTestLogin_btn is a cRDCButtonDPI
97658>>>                    Set Size to 12 56
97659>>>                    Set Location to 57 340
97660>>>                    Set Label to "Test Login"
97661>>>                    Set peAnchors to anNone
97662>>>                    Set psToolTip to "Changes the connection string with any changes made and tries to login to the server with the connection string."
97663>>>                    Set FontWeight to fw_Bold
97664>>>                    Set psImage to "ActionLogin1.ico"
97665>>>                    Set piImageMarginLeft to 0
97666>>>
97666>>>                    Procedure OnClick
97669>>>                        tSQLConnection SQLConnection
97669>>>                        tSQLConnection SQLConnection
97669>>>                        String sServer sDatabase sDriverID sUserID sPassword sConnectionID sConnectionString
97669>>>                        Boolean bTrusted bLoginSuccessful
97669>>>                        Integer iDriverID
97669>>>                        Handle hoDriver
97669>>>
97669>>>                        Get Value of oDriverID_cf        to SQLConnection.sDriverID
97670>>>                        Get Value of oConnectionID_fm    to SQLConnection.sConnectionID
97671>>>                        Get Value of oServer_fm          to SQLConnection.sServer
97672>>>                        Get Value of oDatabase_fm        to SQLConnection.sDatabase
97673>>>                        Get Checked_State of oTrusted_cb to SQLConnection.bTrusted
97674>>>                        Get Value of oUserID_fm          to SQLConnection.sUserID
97675>>>                        Get Value of oPassword_fm        to SQLConnection.sPassword
97676>>>
97676>>>                        Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
97677>>>
97677>>>                        Get DriverIndex of ghoSQLConnectionHandler SQLConnection.sDriverID to iDriverID
97678>>>                        If (iDriverID = 0) Begin
97680>>>                            Send Info_Box ("The driver" * SQLConnection.sDriverID * "could not be loaded. Is the driver installed? And equally imporant; Is the corresponding database server or client software installed?")
97681>>>                            Procedure_Return
97682>>>                        End
97682>>>>
97682>>>
97682>>>                        Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to True
97685>>>                        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
97686>>>                        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
97687>>>                        Set psDriverID of hoDriver to SQLConnection.sDriverID
97688>>>                        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bLoginSuccessful
97689>>>                        Send Destroy   of hoDriver
97690>>>
97690>>>                        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
97691>>>                        If (LastErr <> CLIERR_LOGIN_UNSUCCESSFUL) Begin
97693>>>                            Move (Replace(("PWD=" + SQLConnection.sPassword), sConnectionString, "PWD=***")) to sConnectionString
97694>>>                            Set Value of oConnectionString_fm to sConnectionString
97695>>>                            Send Info_Box "Login Successful!"
97696>>>                        End
97696>>>>
97696>>>                        Else Begin
97697>>>                            Send Info_Box "Nope, that didn't work. Login failed."
97698>>>                        End
97698>>>>
97698>>>                        Broadcast Recursive Send Combo_Fill_List of (Client_Id(phoMainPanel(ghoApplication)))
97700>>>                        Move 0 to LastErr
97701>>>                    End_Procedure
97702>>>
97702>>>                End_Object
97703>>>
97703>>>                Object oConnectionString_fm is a Form
97705>>>                    Set Size to 12 328
97706>>>                    Set Location to 82 68
97707>>>                    Set Label to "Connection String"    
97708>>>                    Set Label_Col_Offset to 2
97709>>>                    Set Label_Justification_Mode to JMode_Right
97710>>>                    Set peAnchors to anTopLeftRight
97711>>>                    Set Enabled_State to False
97712>>>
97712>>>                    Procedure Refresh
97715>>>                        String sValue
97715>>>                        tSQLConnection SQLConnection
97715>>>                        tSQLConnection SQLConnection
97715>>>
97715>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97716>>>                        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
97717>>>                        Set Value to sValue
97718>>>                    End_Procedure
97719>>>
97719>>>                End_Object
97720>>>
97720>>>                Object oInfo_tb is a TextBox
97722>>>                    Set Auto_Size_State to False
97723>>>                    Set Size to 18 303
97724>>>                    Set Location to 106 8
97725>>>                    Set Label to "Note: The above settings was read from the SQLConnections.ini file when the object was created and are properties of the 'ghoSQLConnectionHandler' object."
97726>>>                    Set Justification_Mode to JMode_Left
97727>>>                    Set FontItalics to True
97728>>>                End_Object
97729>>>
97729>>>                Object oRunSQLConnectionsProgram_btn is a cRDCButtonDPI
97731>>>                    Set Size to 21 83
97732>>>                    Set Location to 106 315
97733>>>                    Set Label to "SQL Connections"
97734>>>                    Set peAnchors to anNone
97735>>>                    Set psImage to "SQLConnections1.ico"
97736>>>
97736>>>                    Procedure OnClick 
97739>>>                        Runprogram Background "DUFSQLConnections.exe"
97740>>>                    End_Procedure
97741>>>
97741>>>                End_Object
97742>>>
97742>>>                Object oGetCollation_btn is a Button
97744>>>                    Set Size to 27 91
97745>>>                    Set Location to 154 38
97746>>>                    Set Label to 'Get Database Collation'
97747>>>                
97747>>>                    Procedure OnClick
97750>>>                        String sCollation sDatabase
97750>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase 
97751>>>                        Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary sDatabase False to sCollation 
97752>>>                        Set Value of oGetCollation_fm to sCollation
97753>>>                    End_Procedure
97754>>>                
97754>>>                End_Object
97755>>>
97755>>>                Object oGetCollation_fm is a Form
97757>>>                    Set Size to 12 148
97758>>>                    Set Location to 162 143
97759>>>                    Set Label to "Current SQL Collation Name"
97760>>>                    Set Label_Col_Offset to 0
97761>>>                    Set Label_Row_Offset to 1
97762>>>                    Set Label_Justification_Mode to JMode_Top
97763>>>                End_Object
97764>>>        
97764>>>                Object oSetCollation_btn is a Button
97766>>>                    Set Size to 27 91
97767>>>                    Set Location to 188 38
97768>>>                    Set Label to "Set Database Collation"
97769>>>                
97769>>>                    Procedure OnClick
97772>>>                        String sCollation sDatabase sErrorText
97772>>>                        Boolean bOK
97772>>>                        Integer iRetval  
97772>>>                        tSqlErrorArray aSqlErrorArray
97772>>>                        tSqlErrorArray aSqlErrorArray
97772>>>                        
97772>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase  
97773>>>                        Get Value of oSetCollation_fm to sCollation
97774>>>                        Get YesNo_Box ("This will permanently change SQL collation for the selected database:" * String(sDatabase) * "Are you sure you want to do this?") to iRetval
97775>>>                        If (iRetval <> MBR_Yes) Begin
97777>>>                            Procedure_Return
97778>>>                        End
97778>>>>
97778>>>                        Get SqlDatabaseCollationChange of ghoDbUpdateFunctionLibrary sDatabase sCollation to bOK
97779>>>                        If (bOK = True) Begin
97781>>>                            Send Info_Box ("Changing the collation for database:" * String(sDatabase) * "was successful.")
97782>>>                        End
97782>>>>
97782>>>                        Else Begin                   
97783>>>                            Get paSqlErrorArray of ghoDbUpdateFunctionLibrary to aSqlErrorArray
97784>>>                            Move ("Embedded SQL Statement:" * String(aSqlErrorArray.sSqlStatementArray[0])) to sErrorText
97785>>>                            Move (sErrorText + "\n")                  to sErrorText
97786>>>                            Move (sErrorText + "\n" + "SQL Error:" * String(aSqlErrorArray.sSqlErrorArray[0])) to sErrorText
97787>>>                            Send Info_Box ("Changing the collation for database:" * String(sDatabase) * "failed." + "\n" + sErrorText)
97788>>>                        End
97788>>>>
97788>>>
97788>>>                    End_Procedure
97789>>>                
97789>>>                End_Object
97790>>>
97790>>>                Object oSetCollation_fm is a Form
97792>>>                    Set Size to 12 148
97793>>>                    Set Location to 197 143
97794>>>                    Set Label to "New SQL Collation Name"
97795>>>                    Set Label_Col_Offset to 0
97796>>>                    Set Label_Row_Offset to 1
97797>>>                    Set Label_Justification_Mode to JMode_Top
97798>>>                End_Object
97799>>>
97799>>>                Procedure Page Integer iPageObject
97802>>>                    Broadcast Recursive Send Refresh of (phoMainPanel(ghoApplication))
97804>>>                    Forward Send Page iPageObject
97806>>>                End_Procedure
97807>>>
97807>>>            End_Object
97808>>>
97808>>>        End_Object
97809>>>        
97809>>>    End_Object
97810>>>
97810>>>End_Object
97811>        Use SQLFunctions.vw
Including file: SQLFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLFunctions.vw)
97811>>>Use Windows.pkg
97811>>>Use DFClient.pkg
97811>>>Use Dfspnfrm.pkg
97811>>>Use cDbScrollingContainer.pkg
97811>>>Use cRDCButtonDPI.pkg
97811>>>Use cDbUpdateFunctionLibrary.pkg
97811>>>Use SQLDatabaseBackup.dg
97811>>>
97811>>>Activate_View Activate_oSQLFunctions_vw for oSQLFunctions_vw
97821>>>>
97821>>>Object oSQLFunctions_vw is a dbView
97823>>>    Set Border_Style to Border_Thick
97824>>>    Set Size to 260 426
97825>>>    Set Location to -4 2
97826>>>    Set Label to "Functions"
97827>>>    Set pbAutoActivate to True
97828>>>    Set Icon to "Sql1.ico"
97829>>>
97829>>>    Procedure OnSetFocus
97832>>>        String sValue
97832>>>        tSQLConnection SQLConnection
97832>>>        tSQLConnection SQLConnection
97832>>>
97832>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97833>>>        Set Value of oSQLDatabase_fm to SQLConnection.sDatabase
97834>>>        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
97835>>>        Set Value of oSQLConnectionString_fm to sValue
97836>>>    End_Procedure
97837>>>
97837>>>    Object oScrollingContainer1 is a cDbScrollingContainer
97839>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
97841>>>
97841>>>            Object oSQLFunctionTests_grp is a Group
97843>>>                Set Size to 243 402
97844>>>                Set Location to 7 12
97845>>>                Set Label to "Tests: Change SQL Database with Specialized SQL Functions"
97846>>>                Set peAnchors to anAll
97847>>>
97847>>>                Object oSQLConnectionString_fm is a Form
97849>>>                    Set Size to 12 375
97850>>>                    Set Location to 23 14
97851>>>                    Set Label to "Current Connection String Settings:"
97852>>>                    Set Label_Col_Offset to 0
97853>>>                    Set Label_Justification_Mode to JMode_Top
97854>>>                    Set peAnchors to anTopLeftRight
97855>>>                    Set Enabled_State to False
97856>>>                    Set Label_Row_Offset to 1
97857>>>                End_Object
97858>>>
97858>>>                Object oSQLDatabase_fm is a Form
97860>>>                    Set Size to 12 86
97861>>>                    Set Location to 50 14
97862>>>                    Set Label to "Database:"
97863>>>                    Set Label_Col_Offset to 0
97864>>>                    Set Label_Justification_Mode to JMode_Top
97865>>>                    Set Label_Row_Offset to 1
97866>>>                    Set FontWeight to fw_Bold
97867>>>                    Set Enabled_State to False
97868>>>                End_Object
97869>>>
97869>>>                Object oDriverID2_cf is a ComboForm
97871>>>                    Set Size to 12 91
97872>>>                    Set Location to 50 121
97873>>>                    Set Label_Col_Offset to 0
97874>>>                    Set Label_Justification_Mode to JMode_Top
97875>>>                    Set Label to "Driver ID:"
97876>>>                    Set Entry_State to False
97877>>>                    Set Enabled_State to False
97878>>>                    Set Label_Row_Offset to 1
97879>>>
97879>>>                    Procedure Combo_Fill_List
97882>>>                        Send Combo_Add_Item MSSQLDRV_ID
97883>>>                        Send Combo_Add_Item DB2_DRV_ID
97884>>>                        Send Combo_Add_Item ODBC_DRV_ID
97885>>>                    End_Procedure
97886>>>
97886>>>                    Procedure Refresh
97889>>>                        String sValue
97889>>>
97889>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
97890>>>                        Set Value to sValue
97891>>>                    End_Procedure
97892>>>
97892>>>                End_Object
97893>>>
97893>>>                Object oBackupSQLDatabase_btn is a cRDCButtonDPI
97895>>>                    Set Size to 12 109
97896>>>                    Set Location to 50 220
97897>>>                    Set Label to "Backup MS-SQL Database"
97898>>>                    Set psImage to "DbBackup1.ico"
97899>>>
97899>>>                    Procedure OnClick
97902>>>                        Boolean bOK
97902>>>
97902>>>                        // SQLDatabaseBackup dialog:
97902>>>                        Get MakeSQLDatabaseBackup to bOK
97903>>>
97903>>>                        If (bOK = True) Begin
97905>>>                            Send Info_Box "The backup of the database was successful!"
97906>>>                        End
97906>>>>
97906>>>                        Else Begin
97907>>>                            Send Info_Box "The database was not backup up"
97908>>>                        End
97908>>>>
97908>>>                    End_Procedure
97909>>>
97909>>>                End_Object
97910>>>
97910>>>                Object oDatabaseInfo_tb is a TextBox
97912>>>                    Set Auto_Size_State to False
97913>>>                    Set Size to 25 96
97914>>>                    Set Location to 64 14
97915>>>                    Set Label to "(Change database on the SQL Connections tabpage)"
97916>>>                    Set Justification_Mode to JMode_Left
97917>>>                End_Object
97918>>>
97918>>>                Object oSQLInfo_tb is a TextBox
97920>>>                    Set Auto_Size_State to False
97921>>>                    Set Size to 37 270
97922>>>                    Set Location to 76 118
97923>>>                    Set Label to "Note: The DataFlex database API is NOT used here. Instead all is done with specialized embedded SQL (ESQL) funtions from the cDbUpdateFunctionLibrary. This is because an API 'Structure_End' command could drop and rebuild the whole table (!). That can take a long time..."
97924>>>                    Set Justification_Mode to JMode_Left
97925>>>                End_Object
97926>>>
97926>>>                Object oSQLTableName_cf is a ComboForm
97928>>>                    Set Size to 12 96
97929>>>                    Set Location to 106 14
97930>>>                    Set Label_Col_Offset to 0
97931>>>                    Set Label_Justification_Mode to JMode_Top
97932>>>                    Set Label to "Select Table:"
97933>>>                    Set Label_Row_Offset to 1
97934>>>                    Set Entry_State to False
97935>>>
97935>>>                    Procedure OnDropDown
97938>>>                        Send DoCombo_Fill_List
97939>>>                    End_Procedure
97940>>>
97940>>>                    Procedure OnCloseUp
97943>>>                        Send Delete_Data of oSQLColumnName_cf
97944>>>                    End_Procedure
97945>>>
97945>>>                    Procedure DoCombo_Fill_List
97948>>>                        String[] sTablesArray
97949>>>                        String sDriverID
97949>>>                        Integer iCount iSize
97949>>>
97949>>>                        Send Delete_Data
97950>>>                        Get Value of oDriverID2_cf to sDriverID
97951>>>                        Get _SqlUtilEnumerateTables of ghoDbUpdateFunctionLibrary sDriverID to sTablesArray
97952>>>                        Move (SizeOfArray(sTablesArray)) to iSize
97953>>>                        Decrement iSize
97954>>>                        For iCount from 0 to iSize
97960>>>>
97960>>>                            Send Combo_Add_Item sTablesArray[iCount]
97961>>>                        Loop
97962>>>>
97962>>>                    End_Procedure
97963>>>
97963>>>                    // DataFlex bug. It has been here as long as I can remember and _never_ seems to be fixed :-(
97963>>>                    // Augmented Value function.
97963>>>                    // We need to use Wincombo_x messages. Probably due to sync reasons.
97963>>>                    // When e.g. OnCloseUp is fired the data_value still holds the old value.
97963>>>                    Function Value Integer iItem Returns String
97966>>>                        String sValue
97966>>>                        Get WinCombo_Current_Item to iItem
97967>>>                        Get WinCombo_Value iItem  to sValue
97968>>>                        Function_Return sValue
97969>>>                    End_Function
97970>>>
97970>>>                End_Object
97971>>>
97971>>>                Object oSQLColumnName_cf is a ComboForm
97973>>>                    Set Size to 12 96
97974>>>                    Set Location to 134 14
97975>>>                    Set Label_Col_Offset to 0
97976>>>                    Set Label_Justification_Mode to JMode_Top
97977>>>                    Set Label to "Select Column:"
97978>>>                    Set Label_Row_Offset to 1
97979>>>                    Set Entry_State to False
97980>>>
97980>>>                    Procedure DoCombo_Fill_List
97983>>>                        String[] sColumnsArray
97984>>>                        String sTableName sDriverID
97984>>>                        Integer iCount iSize
97984>>>
97984>>>                        Send Delete_Data
97985>>>                        Get Value of oDriverID2_cf    to sDriverID
97986>>>                        Get Value of oSQLTableName_cf to sTableName
97987>>>                        Get _SqlUtilEnumerateColumns of ghoDbUpdateFunctionLibrary sDriverID sTableName to sColumnsArray
97988>>>                        Move (SizeOfArray(sColumnsArray)) to iSize
97989>>>                        Decrement iSize
97990>>>                        For iCount from 0 to iSize
97996>>>>
97996>>>                            Send Combo_Add_Item sColumnsArray[iCount]
97997>>>                        Loop
97998>>>>
97998>>>                        If (iSize > 1) Begin
98000>>>                            Set Current_Item to 1
98001>>>                        End
98001>>>>
98001>>>                    End_Procedure
98002>>>
98002>>>                    Procedure OnDropDown
98005>>>                        Send DoCombo_Fill_List
98006>>>                    End_Procedure
98007>>>                End_Object
98008>>>
98008>>>                Object oSQLRenameColumnTo_fm is a Form
98010>>>                    Set Size to 12 96
98011>>>                    Set Location to 134 116
98012>>>                    Set Label_Col_Offset to 0
98013>>>                    Set Label_Justification_Mode to JMode_Top
98014>>>                    Set Label to "Rename Column To:"
98015>>>                    Set Label_Row_Offset to 1
98016>>>                    Set Value to "NewColumnName"
98017>>>                End_Object
98018>>>
98018>>>                Object oSQLRenameColumn_btn is a cRDCButtonDPI
98020>>>                    Set Size to 12 69
98021>>>                    Set Location to 134 220
98022>>>                    Set Label to "Rename Column"
98023>>>                    Set psToolTip to "Test of SQLColumnRename function"
98024>>>                    Set MultiLineState to True
98025>>>
98025>>>                    Procedure OnClick
98028>>>                        Boolean bOk
98028>>>                        Handle hTable
98028>>>                        String sTableName sColumnName sNewColumnName sDriverID
98028>>>
98028>>>                        Get Value of oSQLTableName_cf to sTableName
98029>>>                        If (sTableName = "") Begin
98031>>>                            Send Info_Box "You need to select a table first..."
98032>>>                            Procedure_Return
98033>>>                        End
98033>>>>
98033>>>                        Get Value of oSQLColumnName_cf to sColumnName
98034>>>                        If (Uppercase(sColumnName) = "RECNUM" or sColumnName = "") Begin
98036>>>                            Send Info_Box "You need to select a column (and 'RECNUM' cannot be used)"
98037>>>                            Procedure_Return
98038>>>                        End
98038>>>>
98038>>>                        Get Value of oSQLRenameColumnTo_fm to sNewColumnName
98039>>>                        If (Trim(sNewColumnName) = "") Begin
98041>>>                            Send Info_Box "You need to enter a column name to rename to..."
98042>>>                            Procedure_Return
98043>>>                        End
98043>>>>
98043>>>
98043>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98044>>>                        If (hTable = 0) Begin
98046>>>                            Send Info_Box "Sorry, no free fileslot in filelist.cfg could be found. Cannot continue changing table."
98047>>>                            Procedure_Return
98048>>>                        End
98048>>>>
98048>>>
98048>>>                        Get Value of oDriverID2_cf to sDriverID
98049>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98050>>>                        Get SqlColumnRenameByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName sNewColumnName to bOk
98051>>>                        If (bOk = True) Begin
98053>>>                            // Better delete the combo values after a successful rename as it looks odd to show the old column name...
98053>>>                            Send Delete_Data of oSQLColumnName_cf
98054>>>                            Send Info_Box ("Column" * sColumnName + ", was successfully renamed to" * sNewColumnName * "for table:" * sTableName)
98055>>>                        End
98055>>>>
98055>>>                        Else Begin
98056>>>                            Send Info_Box "Nope, that didn't work..."
98057>>>                        End
98057>>>>
98057>>>
98057>>>                    End_Procedure
98058>>>
98058>>>                End_Object
98059>>>
98059>>>                Object oSQLRemoveColumn_btn is a cRDCButtonDPI
98061>>>                    Set Size to 12 91
98062>>>                    Set Location to 134 297
98063>>>                    Set Label to "Drop Column"
98064>>>                    Set psToolTip to "Test of SQLColumnRemove function"
98065>>>                    Set psImage to "DeleteColumn1.ico"
98066>>>
98066>>>                    Procedure OnClick
98069>>>                        Boolean bOk
98069>>>                        String sTableName sColumnName sDriverID
98069>>>                        Integer iRetval
98069>>>
98069>>>                        Get Value of oDriverID2_cf              to sDriverID
98070>>>                        Get Value of oSQLTableName_cf           to sTableName
98071>>>                        Get Value of oSQLColumnName_cf          to sColumnName
98072>>>
98072>>>                        If (sTableName = "" or sColumnName = "") Begin
98074>>>                            Send Info_Box "You first need to select a table and a column."
98075>>>                            Procedure_Return
98076>>>                        End
98076>>>>
98076>>>
98076>>>                        Get YesNo_Box ("This will remove (drop) the column named:" * sColumnName * "from table:" * sTableName + ". Are you sure?") to iRetval
98077>>>                        If (iRetval <> MBR_Yes) Begin
98079>>>                            Procedure_Return
98080>>>                        End
98080>>>>
98080>>>
98080>>>                        Get SqlColumnRemoveByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName to bOk
98081>>>
98081>>>                        If (bOk = True) Begin
98083>>>                            // Better delete the combo values after a successful operation as it looks odd to show the old column name...
98083>>>                            Send Delete_Data of oSQLColumnName_cf
98084>>>                            Send Info_Box ("Column" * sColumnName + ", was successfully removed")
98085>>>                        End
98085>>>>
98085>>>                        Else Begin
98086>>>                            Send Info_Box ("The column could NOT be removed. Either the column" * sColumnName * "doesn't exists or the current Database is incorrect?")
98087>>>                            Procedure_Return
98088>>>                        End
98088>>>>
98088>>>
98088>>>                    End_Procedure
98089>>>
98089>>>                End_Object
98090>>>
98090>>>                Object oSQLAddColumnName_fm is a Form
98092>>>                    Set Size to 12 96
98093>>>                    Set Location to 177 14
98094>>>                    Set Label_Col_Offset to 0
98095>>>                    Set Label_Justification_Mode to JMode_Top
98096>>>                    Set Label to "Column Name:"
98097>>>                    Set Label_Row_Offset to 1
98098>>>                    Set Value to "NewColumn"
98099>>>                End_Object
98100>>>
98100>>>                Object oSQLColumnType_cf is a ComboForm
98102>>>                    Set Size to 12 96
98103>>>                    Set Location to 177 116
98104>>>                    Set Label_Col_Offset to 0
98105>>>                    Set Label_Justification_Mode to JMode_Top
98106>>>                    Set Label_Row_Offset to 1
98107>>>                    Set Label to "Type:"
98108>>>                    Set Entry_State to False
98109>>>
98109>>>                    Procedure Combo_Fill_List
98112>>>                        tColumnType[] ColumnTypeArray
98112>>>                        tColumnType[] ColumnTypeArray
98113>>>                        Integer iSize iCount iDbType
98113>>>                        String sDriverID
98113>>>
98113>>>                        Send Delete_Data
98114>>>                        Get Value of oDriverID2_cf to sDriverID
98115>>>                        Get piDbType of ghoDbUpdateFunctionLibrary to iDbType
98116>>>                        Get _UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary sDriverID iDbType to ColumnTypeArray
98117>>>                        Move (SizeOfArray(ColumnTypeArray)) to iSize
98118>>>                        Decrement iSize
98119>>>                        For iCount from 0 to iSize
98125>>>>
98125>>>                            Send Combo_Add_Item ColumnTypeArray[iCount].sSQLType
98126>>>                        Loop
98127>>>>
98127>>>                        If (iSize > 0) Begin
98129>>>                            Set Value to ColumnTypeArray[0].sSQLType
98130>>>                        End
98130>>>>
98130>>>                    End_Procedure
98131>>>
98131>>>                    Procedure OnChange
98134>>>                        Integer iType iSize iDec
98134>>>                        tSQLConnection SQLConnection
98134>>>                        tSQLConnection SQLConnection
98134>>>                        Boolean bFixed
98134>>>
98134>>>                        Get SelectedType to iType
98135>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98136>>>                        Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to iSize
98137>>>                        Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to iDec
98138>>>                        Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to bFixed
98139>>>
98139>>>                        Set Enabled_State of oSQLLength_sf   to (bFixed = False)
98140>>>                        Set Enabled_State of oSQLDecimals_sf to (bFixed = False)
98141>>>                        Set Value         of oSQLLength_sf   to iSize
98142>>>                        If (iDec = 0) Begin
98144>>>                            Set Value     of oSQLDecimals_sf to ""
98145>>>                        End
98145>>>>
98145>>>                        Else Begin
98146>>>                            Set Value     of oSQLDecimals_sf to iDec
98147>>>                        End
98147>>>>
98147>>>                        If (bFixed = False) Begin
98149>>>                            Set Enabled_State of oSQLDecimals_sf to (iDec <> 0)
98150>>>                        End
98150>>>>
98150>>>                    End_Procedure
98151>>>
98151>>>                    Function SelectedType Returns Integer
98154>>>                        String sValue sDriverID
98154>>>                        Integer iType iDbType
98154>>>
98154>>>                        Get Value to sValue
98155>>>                        Get psDriverID of ghoSQLConnectionHandler to sDriverID
98156>>>                        Get piDbType   of ghoSQLConnectionHandler to iDbType
98157>>>                        Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary sDriverID iDbType sValue to iType
98158>>>
98158>>>                        Function_Return iType
98159>>>                    End_Function
98160>>>
98160>>>                End_Object
98161>>>
98161>>>                Object oSQLAddColumn_btn is a cRDCButtonDPI
98163>>>                    Set Size to 12 69
98164>>>                    Set Location to 177 220
98165>>>                    Set Label to "Add Column"
98166>>>                    Set psToolTip to "Test of SQLColumnAdd function"
98167>>>                    Set psImage to "AddColumn1.ico"
98168>>>
98168>>>                    Procedure OnClick
98171>>>                        Boolean bOk bInitialize
98171>>>                        Handle hTable
98171>>>                        String sTableName sColumnName sType sColumnValue sDriverID
98171>>>                        Integer iType iLength iDecimals
98171>>>
98171>>>                        Get Value of oDriverID2_cf              to sDriverID
98172>>>                        Get Value of oSQLTableName_cf           to sTableName
98173>>>                        Get Value of oSQLAddColumnName_fm       to sColumnName
98174>>>                        Get SelectedType  of oSQLColumnType_cf  to iType
98175>>>                        Get Value         of oSQLColumnType_cf  to sType
98176>>>                        Get Checked_State of oSQLInitializeColumnValue_cb to bInitialize
98177>>>                        Get Value         of oSQLColumnValue_fm to sColumnValue
98178>>>                        Get Value         of oSQLLength_sf      to iLength
98179>>>                        Get Value         of oSQLDecimals_sf    to iDecimals
98180>>>
98180>>>                        If (sTableName <> "") Begin
98182>>>                            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98183>>>                            If (hTable = 0) Begin
98185>>>                                Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98186>>>                            End
98186>>>>
98186>>>                        End
98186>>>>
98186>>>                        If (hTable = 0) Begin
98188>>>                            Send Info_Box "You first need to select a table before you can add a column to it."
98189>>>                            Procedure_Return
98190>>>                        End
98190>>>>
98190>>>                        If (sColumnName = "") Begin
98192>>>                            Send Info_Box "You need to enter a column name"
98193>>>                            Procedure_Return
98194>>>                        End
98194>>>>
98194>>>
98194>>>                        Get SqlColumnAddByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName iType iLength iDecimals bInitialize sColumnValue to bOk
98195>>>
98195>>>                        If (bOk = True) Begin
98197>>>                            Send Info_Box ("New column" * sColumnName * sType * String(iLength) + ", was successfully added to" * sTableName)
98198>>>                        End
98198>>>>
98198>>>                        Else Begin
98199>>>                            Send Info_Box ("The column could NOT be added. Either column" * sColumnName * "already exists or the current Database is incorrect?")
98200>>>                            Procedure_Return
98201>>>                        End
98201>>>>
98201>>>
98201>>>                    End_Procedure
98202>>>
98202>>>                End_Object
98203>>>
98203>>>//                Object oTest_btn is a cRDCButtonDPI
98203>>>//                    Set Size to 13 92
98203>>>//                    Set Location to 177 298
98203>>>//                    Set Label to "Test SQL script button"
98203>>>//
98203>>>//                    Procedure OnClick
98203>>>//                        Boolean bOK
98203>>>//                        String sTableName sColumnName
98203>>>//
98203>>>//                        Get Value of oSQLTableName_cf      to sTableName
98203>>>//                        Get Value of oSQLAddColumnName_fm  to sColumnName
98203>>>////                        Get SqlUtilDefaultConstraintsMSSQL of ghoDbUpdateFunctionLibrary sTableName sColumnName to bOK
98203>>>//
98203>>>//                    End_Procedure
98203>>>//
98203>>>//                End_Object
98203>>>
98203>>>                Object oSQLLength_sf is a SpinForm
98205>>>                    Set Label to "Length:"
98206>>>                    Set Size to 12 40
98207>>>                    Set Location to 202 16
98208>>>                    Set Label_Col_Offset to 0
98209>>>                    Set Label_Justification_Mode to JMode_Top
98210>>>                    Set Label_Row_Offset to 1
98211>>>                    Set Value to "10"
98212>>>                    Set Maximum_Position to 500
98213>>>                    Set Minimum_Position to 1
98214>>>                End_Object
98215>>>
98215>>>                Object oSQLDecimals_sf is a SpinForm
98217>>>                    Set Label to "Decimals:"
98218>>>                    Set Size to 12 33
98219>>>                    Set Location to 202 60
98220>>>                    Set Label_Col_Offset to 0
98221>>>                    Set Label_Justification_Mode to JMode_Top
98222>>>                    Set Label_Row_Offset to 1
98223>>>                    Set Value to "0"
98224>>>                    Set Maximum_Position to 16
98225>>>                    Set Minimum_Position to 1
98226>>>                End_Object
98227>>>
98227>>>                Object oSQLInitializeColumnValue_cb is a CheckBox
98229>>>                    Set Size to 12 85
98230>>>                    Set Location to 202 116
98231>>>                    Set Label to "Initialize Column Value"
98232>>>
98232>>>                    Procedure OnChange
98235>>>                        Boolean bChecked
98235>>>
98235>>>                        Get Checked_State to bChecked
98236>>>                        Set Enabled_State of oSQLColumnValue_fm to bChecked
98237>>>                    End_Procedure
98238>>>
98238>>>                End_Object
98239>>>
98239>>>                Object oSQLColumnValue_fm is a Form
98241>>>                    Set Size to 12 96
98242>>>                    Set Location to 218 116
98243>>>                    Set Label_Col_Offset to 2
98244>>>                    Set Label_Justification_Mode to JMode_Right
98245>>>                    Set Label to "Column Value"
98246>>>                    Set psToolTip to "When a new column is added the new column can be initialized with a value for all existing records."
98247>>>                    Set Enabled_State to False
98248>>>                End_Object
98249>>>
98249>>>                Object oEnumRelations_btn is a cRDCButtonDPI
98251>>>                    Set Size to 12 91
98252>>>                    Set Location to 116 297
98253>>>                    Set Label to "Test Enum SQL Relations"
98254>>>
98254>>>                    Procedure OnClick
98257>>>                        tSQLRelation[] SQLRelationArray
98257>>>                        tSQLRelation[] SQLRelationArray
98258>>>                        String sTableName sDriverID
98258>>>                        Integer iSize iCount
98258>>>
98258>>>                        Get Value of oDriverID2_cf to sDriverID
98259>>>                        Get Value of oSQLTableName_cf to sTableName
98260>>>                        Get _SqlUtilEnumerateRelations of ghoDbUpdateFunctionLibrary sTableName sDriverID to SQLRelationArray
98261>>>                        Move (SizeOfArray(SQLRelationArray)) to iSize
98262>>>                        Decrement iSize
98263>>>                        For iCount from 0 to iSize
98269>>>>
98269>>>                            Showln "Tablename.FieldName = " SQLRelationArray[iCount].sFileName "." SQLRelationArray[iCount].sFieldName " Number: " SQLRelationArray[iCount].iFileNumber "." SQLRelationArray[iCount].iFieldNumber
98278>>>                        Loop
98279>>>>
98279>>>                        If (iSize < 1) Begin
98281>>>                            Send Info_Box ("No SQL Foreign keys found for table:" * sTableName)
98282>>>                        End
98282>>>>
98282>>>
98282>>>                    End_Procedure
98283>>>
98283>>>                End_Object
98284>>>
98284>>>                Object oEnumerateLoggedInUsers is a cRDCButtonDPI
98286>>>                    Set Size to 12 101
98287>>>                    Set Location to 177 297
98288>>>                    Set Label to "Enumerate Logged In Users"
98289>>>
98289>>>                    Procedure OnClick
98292>>>                        tSQLLoggedInUser[] SQLLoggedInUser
98292>>>                        tSQLLoggedInUser[] SQLLoggedInUser
98293>>>                        String sDriverID sDatabase
98293>>>                        Integer iSize iCount
98293>>>
98293>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98294>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase
98295>>>                        Get SqlUtilEnumerateLoggedInUsers of ghoDbUpdateFunctionLibrary sDriverID sDatabase to SQLLoggedInUser
98296>>>                        Move (SizeOfArray(SQLLoggedInUser)) to iSize
98297>>>                        Decrement iSize
98298>>>
98298>>>                        Showln "SQL User Name" " and Program:"
98301>>>                        For iCount from 0 to iSize
98307>>>>
98307>>>                            Showln SQLLoggedInUser[iCount].sUser " " SQLLoggedInUser[iCount].sProgram
98311>>>                        Loop
98312>>>>
98312>>>                    End_Procedure
98313>>>
98313>>>                End_Object
98314>>>
98314>>>                Object oEnumerateTablesAndViews is a cRDCButtonDPI
98316>>>                    Set Size to 12 101
98317>>>                    Set Location to 193 297
98318>>>                    Set Label to "Is Table or View?"
98319>>>
98319>>>                    Procedure OnClick
98322>>>                        String sDriverID sTableName
98322>>>                        Handle hTable
98322>>>                        Boolean bViewTableType
98322>>>
98322>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98323>>>                        Get Value of oSQLTableName_cf to sTableName
98324>>>                        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98325>>>                        If (hTable = 0) Begin
98327>>>                            Procedure_Return
98328>>>                        End
98328>>>>
98328>>>                        Get SQLUtilTableIsViewType of ghoDbUpdateFunctionLibrary sDriverID hTable to bViewTableType
98329>>>                        Send Info_Box ("The table" * sTableName * "is a" * If(bViewTableType = True, "View Table Type", "Standard Table (not view)"))
98330>>>                    End_Procedure
98331>>>
98331>>>                End_Object
98332>>>
98332>>>            End_Object
98333>>>
98333>>>        End_Object
98334>>>
98334>>>    End_Object
98335>>>
98335>>>End_Object
98336>        Use APIFunctions.vw
Including file: APIFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\APIFunctions.vw)
98336>>>Use Windows.pkg
98336>>>Use DFClient.pkg
98336>>>Use Dfspnfrm.pkg
98336>>>Use Dfline.pkg
98336>>>Use cDbScrollingContainer.pkg
98336>>>Use cRDCButtonDPI.pkg
98336>>>Use cDbUpdateFunctionLibrary.pkg
98336>>>
98336>>>Define CI_Table1_FileNo for 401
98336>>>Define CI_View1_FileNo  for 402
98336>>>
98336>>>Activate_View Activate_oAPIFunctions_vw for oAPIFunctions_vw
98346>>>>
98346>>>Object oAPIFunctions_vw is a dbView
98348>>>    Set Border_Style to Border_Thick
98349>>>    Set Size to 237 424
98350>>>    Set Location to 17 2
98351>>>    Set Label to "API Functions"
98352>>>    Set pbAutoActivate to True
98353>>>    Set Icon to "APIFunctions1.ico"
98354>>>
98354>>>    Property String psTableName ""
98356>>>
98356>>>    Procedure OnSetFocus
98359>>>        String sValue
98359>>>        tSQLConnection SQLConnection
98359>>>        tSQLConnection SQLConnection
98359>>>
98359>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98360>>>        Set Value of oApiDatabase_fm to SQLConnection.sDatabase
98361>>>        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
98362>>>        Set Value of oApiConnectionString_fm to sValue
98363>>>    End_Procedure
98364>>>
98364>>>    Object oScrollingContainer1 is a cDbScrollingContainer
98366>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
98368>>>
98368>>>            Object oApiFunctions_grp is a Group
98370>>>                Set Size to 222 402
98371>>>                Set Location to 6 12
98372>>>                Set Label to "Tests: Change MS-SQL Database with Database API Functions"
98373>>>                Set peAnchors to anAll
98374>>>
98374>>>                Object oApiConnectionString_fm is a Form
98376>>>                    Set Size to 12 368
98377>>>                    Set Location to 23 14
98378>>>                    Set Label to "Current Connection String Settings:"
98379>>>                    Set Label_Col_Offset to 0
98380>>>                    Set Label_Justification_Mode to JMode_Top
98381>>>                    Set peAnchors to anTopLeftRight
98382>>>                    Set Enabled_State to False
98383>>>                    Set Label_Row_Offset to 1
98384>>>                End_Object
98385>>>
98385>>>                Object oApiDatabase_fm is a Form
98387>>>                    Set Size to 12 86
98388>>>                    Set Location to 50 14
98389>>>                    Set Label to "Database:"
98390>>>                    Set Label_Col_Offset to 0
98391>>>                    Set Label_Justification_Mode to JMode_Top
98392>>>                    Set Label_Row_Offset to 1
98393>>>                    Set Enabled_State to False
98394>>>                    Set FontWeight to fw_Bold
98395>>>//                    Set Label_FontWeight to fw_Bold
98395>>>
98395>>>                    Procedure Page Integer iPageObject
98398>>>                        String sValue
98398>>>                        Get psDatabase of ghoSQLConnectionHandler to sValue
98399>>>                        Set Value to sValue
98400>>>
98400>>>                        Forward Send Page iPageObject
98402>>>                    End_Procedure
98403>>>
98403>>>                End_Object
98404>>>
98404>>>                Object oDriverID3_cf is a ComboForm
98406>>>                    Set Size to 12 91
98407>>>                    Set Location to 51 121
98408>>>                    Set Label_Col_Offset to 0
98409>>>                    Set Label_Justification_Mode to JMode_Top
98410>>>                    Set Label to "Driver ID:"
98411>>>                    Set Entry_State to False
98412>>>                    Set Enabled_State to False
98413>>>                    Set Label_Row_Offset to 1
98414>>>                    Set Enabled_State to False
98415>>>
98415>>>                    Procedure Combo_Fill_List
98418>>>                        Send Combo_Add_Item MSSQLDRV_ID
98419>>>                        Send Combo_Add_Item DB2_DRV_ID
98420>>>                        Send Combo_Add_Item ODBC_DRV_ID
98421>>>                    End_Procedure
98422>>>
98422>>>                    Procedure Refresh
98425>>>                        String sValue
98425>>>
98425>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
98426>>>                        Set Value to sValue
98427>>>                    End_Procedure
98428>>>
98428>>>                End_Object
98429>>>
98429>>>                Object oDatabaseInfo_tb is a TextBox
98431>>>                    Set Auto_Size_State to False
98432>>>                    Set Size to 25 96
98433>>>                    Set Location to 64 14
98434>>>                    Set Label to "(Change database on the SQL Connections tabpage)"
98435>>>                    Set Justification_Mode to JMode_Left
98436>>>                End_Object
98437>>>
98437>>>                Object oApiTableName_fm is a Form
98439>>>                    Set Size to 12 77
98440>>>                    Set Location to 114 14
98441>>>                    Set Label_Col_Offset to 0
98442>>>                    Set Label_Justification_Mode to JMode_Top
98443>>>                    Set Label to "Table Name:"
98444>>>                    Set Label_Row_Offset to 1
98445>>>                    Set Value to "NewTable"
98446>>>                    Procedure OnChange
98449>>>                        String sValue
98449>>>                        Get Value to sValue
98450>>>                        Set psTableName to sValue
98451>>>                    End_Procedure
98452>>>                    Send OnChange
98453>>>                End_Object
98454>>>
98454>>>                Object oApiAddNewTable_btn is a cRDCButtonDPI
98456>>>                    Set Size to 12 69
98457>>>                    Set Location to 114 271
98458>>>                    Set Label to "Add Table"
98459>>>                    Set psImage to "ActionAddTable1.ico"
98460>>>
98460>>>                    Procedure OnClick
98463>>>                        Boolean bOk
98463>>>                        Handle hTable
98463>>>                        String sTableName sDriverID
98463>>>
98463>>>                        Get Value of oDriverID3_cf to sDriverID
98464>>>                        Get Value of oApiTableName_fm to sTableName
98465>>>                        Move (Trim(sTableName)) to sTableName
98466>>>                        If (sTableName = "") Begin
98468>>>                            Send Info_Box "You first need to enter a table name."
98469>>>                            Procedure_Return
98470>>>                        End
98470>>>>
98470>>>
98470>>>                        Send Cursor_Wait of Cursor_Control
98471>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98472>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98473>>>                        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True to bOk
98474>>>                        If (bOk = True) Begin
98476>>>                            Send Info_Box ("Test table" * sTableName * "was successfully created and put in filelist slot:" * String(hTable))
98477>>>                        End
98477>>>>
98477>>>                        Else Begin
98478>>>                            Send Cursor_Ready of Cursor_Control
98479>>>                            Send Info_Box ("Nope, the test table" * sTableName * "could not be created, or does it already exist?") "Error"
98480>>>                            Procedure_Return
98481>>>                        End
98481>>>>
98481>>>
98481>>>                    End_Procedure
98482>>>
98482>>>                End_Object
98483>>>
98483>>>                Object oApiAddColumn_fm is a Form
98485>>>                    Set Size to 12 77
98486>>>                    Set Location to 141 14
98487>>>                    Set Label_Col_Offset to 0
98488>>>                    Set Label_Justification_Mode to JMode_Top
98489>>>                    Set Label to "Column Name:"
98490>>>                    Set Label_Row_Offset to 1
98491>>>                    Set Value to "NewColumn"
98492>>>                End_Object
98493>>>
98493>>>                Object oApiColumnType_cf is a ComboForm
98495>>>                    Set Size to 12 85
98496>>>                    Set Location to 141 96
98497>>>                    Set Label_Col_Offset to 0
98498>>>                    Set Label_Justification_Mode to JMode_Top
98499>>>                    Set Label_Row_Offset to 1
98500>>>                    Set Label to "Type:"
98501>>>                    Set Entry_State to False
98502>>>
98502>>>                    Procedure Combo_Fill_List
98505>>>                        tColumnType[] ColumnTypeArray
98505>>>                        tColumnType[] ColumnTypeArray
98506>>>                        Integer iSize iCount
98506>>>
98506>>>                        Send Delete_Data
98507>>>                        Get _UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex to ColumnTypeArray
98508>>>                        Move (SizeOfArray(ColumnTypeArray)) to iSize
98509>>>                        Decrement iSize
98510>>>                        For iCount from 0 to iSize
98516>>>>
98516>>>                            Send Combo_Add_Item ColumnTypeArray[iCount].sSQLType
98517>>>                        Loop
98518>>>>
98518>>>                        Set Value to ColumnTypeArray[0].sSQLType
98519>>>                    End_Procedure
98520>>>
98520>>>                    Procedure OnChange
98523>>>                        Integer iType iSize iDec
98523>>>                        tSQLConnection SQLConnection
98523>>>                        tSQLConnection SQLConnection
98523>>>                        Boolean bFixed
98523>>>
98523>>>                        Get SelectedType to iType
98524>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98525>>>                        Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to iSize
98526>>>                        Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to iDec
98527>>>                        Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to bFixed
98528>>>
98528>>>                        Set Enabled_State of oApiLength_sf   to (bFixed = False)
98529>>>                        Set Enabled_State of oApiDecimals_sf to (bFixed = False)
98530>>>                        Set Value         of oApiLength_sf   to iSize
98531>>>                        If (iDec = 0) Begin
98533>>>                            Set Value     of oApiDecimals_sf to ""
98534>>>                        End
98534>>>>
98534>>>                        Else Begin
98535>>>                            Set Value     of oApiDecimals_sf to iDec
98536>>>                        End
98536>>>>
98536>>>                        If (bFixed = False) Begin
98538>>>                            Set Enabled_State of oApiDecimals_sf to (iDec <> 0)
98539>>>                        End
98539>>>>
98539>>>                    End_Procedure
98540>>>
98540>>>                    Function SelectedType Returns Integer
98543>>>                        String sValue
98543>>>                        Integer iType
98543>>>
98543>>>                        Get Value to sValue
98544>>>                        Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex sValue to iType
98545>>>
98545>>>                        Function_Return iType
98546>>>                    End_Function
98547>>>
98547>>>                End_Object
98548>>>
98548>>>                Object oApiLength_sf is a SpinForm
98550>>>                    Set Label to "Length:"
98551>>>                    Set Size to 12 35
98552>>>                    Set Location to 141 186
98553>>>                    Set Label_Col_Offset to 0
98554>>>                    Set Label_Justification_Mode to JMode_Top
98555>>>                    Set Label_Row_Offset to 1
98556>>>                    Set Value to "10"
98557>>>                    Set Maximum_Position to 500
98558>>>                    Set Minimum_Position to 1
98559>>>                End_Object
98560>>>
98560>>>                Object oApiDecimals_sf is a SpinForm
98562>>>                    Set Label to "Decimals:"
98563>>>                    Set Size to 12 33
98564>>>                    Set Location to 141 225
98565>>>                    Set Label_Col_Offset to 0
98566>>>                    Set Label_Justification_Mode to JMode_Top
98567>>>                    Set Label_Row_Offset to 1
98568>>>                    Set Value to "0"
98569>>>                    Set Maximum_Position to 16
98570>>>                    Set Minimum_Position to 1
98571>>>                End_Object
98572>>>
98572>>>                Object oApiAddColumn_btn is a cRDCButtonDPI
98574>>>                    Set Size to 12 69
98575>>>                    Set Location to 141 271
98576>>>                    Set Label to "Add Column"
98577>>>                    Set psToolTip to "ApiColumnAdd function"
98578>>>                    Set psImage to "ActionAddColumn1.ico"
98579>>>
98579>>>                    Procedure OnClick
98582>>>                        Boolean bOk
98582>>>                        Handle hTable
98582>>>                        String sTableName sColumnName sType sDriverID
98582>>>                        Integer iType iLength iDecimals
98582>>>
98582>>>                        Get Value of oDriverID3_cf            to sDriverID
98583>>>                        Get Value of oApiTableName_fm         to sTableName
98584>>>                        Get Value of oApiAddColumn_fm         to sColumnName
98585>>>                        Get SelectedType of oApiColumnType_cf to iType
98586>>>                        Get Value        of oApiLength_sf     to iLength
98587>>>                        Get Value        of oApiDecimals_sf   to iDecimals
98588>>>
98588>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98589>>>                        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98590>>>                        If (hTable = 0) Begin
98592>>>                            Send Info_Box "You first need to create the new table by pressing the 'Create New Table...' button, before you can add a column to it."
98593>>>                            Procedure_Return
98594>>>                        End
98594>>>>
98594>>>                        If (sColumnName = "") Begin
98596>>>                            Send Info_Box "You need to enter a column name"
98597>>>                            Procedure_Return
98598>>>                        End
98598>>>>
98598>>>
98598>>>                        Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable sColumnName iType iLength iDecimals to bOk
98599>>>                        If (bOk = True) Begin
98601>>>                            Send Info_Box ("Column" * sColumnName * sType * String(iLength) + ", was successfully added to" * sTableName * "(at filelist slot:" * String(hTable) + ")")
98602>>>                        End
98602>>>>
98602>>>                        Else Begin
98603>>>                            Send Info_Box ("The column could NOT be added. Either column" * sColumnName * "already exists or the current Database is incorrect?")
98604>>>                            Procedure_Return
98605>>>                        End
98605>>>>
98605>>>
98605>>>                    End_Procedure
98606>>>
98606>>>                End_Object
98607>>>
98607>>>                Object oApiAddTableAndColumns_btn is a cRDCButtonDPI
98609>>>                    Set Size to 26 77
98610>>>                    Set Location to 184 14
98611>>>                    Set Label to "Create 'New' Table with Three Columns"
98612>>>                    Set MultiLineState to True
98613>>>                    Set psImage to "ActionAddTable1.ico"
98614>>>
98614>>>                    Procedure OnClick
98617>>>                        Boolean bOk
98617>>>                        Handle hTable
98617>>>                        String sTableName sDriverID
98617>>>
98617>>>                        Get Value of oDriverID3_cf to sDriverID
98618>>>                        Get Value of oApiTableName_fm to sTableName
98619>>>                        Move (Trim(sTableName)) to sTableName
98620>>>                        If (sTableName = "") Begin
98622>>>                            Send Info_Box "You first need to enter a table name."
98623>>>                            Procedure_Return
98624>>>                        End
98624>>>>
98624>>>
98624>>>                        Send Cursor_Wait of Cursor_Control
98625>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98626>>>
98626>>>                        Set psDriverID       of ghoDbUpdateFunctionLibrary to sDriverID
98627>>>                        Get ApiTableCreate   of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True to bOk
98628>>>                        If (bOk = True) Begin
98630>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col1Ascii"   DF_ASCII 10 0 to bOk
98631>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col2Date"    DF_DATE   6 0 to bOk
98632>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col3Numeric" DF_BCD    6 2 to bOk
98633>>>                        End
98633>>>>
98633>>>                        Send Cursor_Ready of Cursor_Control
98634>>>
98634>>>                        If (bOk = True) Begin
98636>>>                            Send Info_Box ("Test table" * sTableName * "with Columns: 'Col1 ASCII 10', 'Col2 Date' and 'Col3 Numeric 6,2' was successfully created and put in filelist slot:" * String(CI_Table1_FileNo))
98637>>>                        End
98637>>>>
98637>>>                        Else Begin
98638>>>                            Send Cursor_Ready of Cursor_Control
98639>>>                            Send Info_Box ("Nope, the test table" * sTableName * "could not be created") "Error"
98640>>>                            Procedure_Return
98641>>>                        End
98641>>>>
98641>>>
98641>>>                    End_Procedure
98642>>>
98642>>>                End_Object
98643>>>
98643>>>                Object oApiRemoveTable_btn is a cRDCButtonDPI
98645>>>                    Set Size to 26 77
98646>>>                    Set Location to 184 96
98647>>>                    Set Label to "Remove 'New' Table"
98648>>>                    Set psImage to "ActionDeleteTable1.ico"
98649>>>                    Set MultiLineState to True
98650>>>
98650>>>                    Procedure OnClick
98653>>>                        Boolean bOk
98653>>>                        Integer iRetval
98653>>>                        Handle hTable
98653>>>                        String sTableName sDriverID
98653>>>
98653>>>                        Get Value of oDriverID3_cf to sDriverID
98654>>>                        Get Value of oApiTableName_fm to sTableName
98655>>>                        Get YesNo_Box ("Are you sure you want to PERMANENTLY DELETE the table named:" * String(sTableName) + "?") to iRetval
98656>>>                        If (iRetval = MBR_Yes) Begin
98658>>>                            Send Cursor_Wait of Cursor_Control
98659>>>                            Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98660>>>                            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98661>>>                            Get ApiTableRemove of ghoDbUpdateFunctionLibrary hTable to bOk
98662>>>                            Send Cursor_Ready of Cursor_Control
98663>>>                            If (bOk = True) Begin
98665>>>                                Send Info_Box "Table removed"
98666>>>                            End
98666>>>>
98666>>>                            Else Begin
98667>>>                                Send Info_Box "Nope, that didnt' work. Either the table doesn't exist or your rights aren't sufficient."
98668>>>                            End
98668>>>>
98668>>>                        End
98668>>>>
98668>>>                    End_Procedure
98669>>>
98669>>>                End_Object
98670>>>
98670>>>                Object oLineControl1 is a LineControl
98672>>>                    Set Size to 2 387
98673>>>                    Set Location to 96 6
98674>>>                    Set peAnchors to anTopLeftRight
98675>>>                End_Object
98676>>>
98676>>>                Object oLineControl2 is a LineControl
98678>>>                    Set Size to 3 248
98679>>>                    Set Location to 171 9
98680>>>                End_Object
98681>>>
98681>>>                Object oTestError_fm is a Form
98683>>>                    Set Size to 13 64
98684>>>                    Set Location to 186 180
98685>>>                    Set Form_Datatype to 0 
98686>>>                    On_Key kEnter send KeyAction of oFindErrorText_Btn
98687>>>                End_Object
98688>>>
98688>>>Register_Function FetchErrorDescription Integer iError Returns String
98688>>>                Object oFindErrorText_Btn is a Button
98690>>>                    Set Size to 13 70
98691>>>                    Set Location to 186 248
98692>>>                    Set Label to "Find Error Text"
98693>>>                
98693>>>                    Procedure OnClick
98696>>>                        String sRetval
98696>>>                        Integer iError 
98696>>>                        Handle hoLogFile
98696>>>                        
98696>>>                        Get phoLogFile of ghoDbUpdateFunctionLibrary to hoLogFile
98697>>>                        Get Value of oTestError_fm to iError
98698>>>                        Get FetchErrorDescription of hoLogFile iError to sRetval 
98699>>>                        Set Value of oErrorText_fm to sRetval    
98700>>>                    End_Procedure
98701>>>                
98701>>>                End_Object
98702>>>
98702>>>                Object oErrorText_fm is a Form
98704>>>                    Set Size to 13 213
98705>>>                    Set Location to 202 180
98706>>>                End_Object
98707>>>
98707>>>            End_Object
98708>>>
98708>>>        End_Object
98709>>>
98709>>>    End_Object
98710>>>
98710>>>End_Object
98711>        Use UtilFunctions.vw
Including file: UtilFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\UtilFunctions.vw)
98711>>>
98711>>>Use Windows.pkg
98711>>>Use DFClient.pkg
98711>>>Use Dfline.pkg
98711>>>Use cDbScrollingContainer.pkg
98711>>>Use cRDCButtonDPI.pkg
98711>>>Use cDbUpdateFunctionLibrary.pkg
98711>>>Use Dftreevw.pkg
98711>>>Use Working.pkg
Including file: Working.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Working.pkg)
98711>>>>>// COPYRIGHT (c) 2003-2017 RDC Tools International
98711>>>>>//
98711>>>>>// This program is free software; you can redistribute it and/or
98711>>>>>// modify it under the terms of the GNU General Public License
98711>>>>>// as published by the Free Software Foundation; version 2
98711>>>>>// of the License.
98711>>>>>
98711>>>>>// This program is distributed in the hope that it will be useful,
98711>>>>>// but WITHOUT ANY WARRANTY; without even the implied warranty of
98711>>>>>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
98711>>>>>// GNU General Public License for more details.
98711>>>>>
98711>>>>>// You should have received a copy of the GNU General Public License
98711>>>>>// along with this program; (See the GPL.txt file in the Help directory) if not, write to the Free Software
98711>>>>>// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
98711>>>>>Use Windows.pkg
98711>>>>>
98711>>>>>Object oWorkingMessagePanel is a ToolPanel
98713>>>>>    Set Label    to "Working"
98714>>>>>    Set Size to 48 150
98715>>>>>    Set Locate_Mode to CENTER_ON_PARENT
98716>>>>>    Set Popup_State to True
98717>>>>>
98717>>>>>    Object oWorkingMessage is a Textbox
98719>>>>>        Set Label to "Working message..."
98720>>>>>        Set Location to 15 5
98721>>>>>        Set Size to 27 123
98722>>>>>        Set Auto_Size_State to False
98723>>>>>        Set Justification_Mode to JMode_Center
98724>>>>>        Set FontWeight to fw_Bold
98725>>>>>    End_Object
98726>>>>>
98726>>>>>End_Object
98727>>>>>
98727>>>>>Procedure StartWorkingMessage Global String sText
98729>>>>>    Send Close_Panel of (oWorkingMessagePanel(Self))
98730>>>>>    Set Label  of (oWorkingMessage(oWorkingMessagePanel(Self))) to sText
98731>>>>>    Send Popup of (oWorkingMessagePanel(Self))
98732>>>>>End_Procedure
98733>>>>>
98733>>>>>Procedure StopWorkingMessage Global
98735>>>>>    Send Close_Panel of (oWorkingMessagePanel(Self))
98736>>>>>End_Procedure
98737>>>Use DUFStatusPanel.pkg
98737>>>Use cCharTranslate.pkg
98737>>>
98737>>>Struct tFilelistDUF
98737>>>    Integer iFileNumber
98737>>>    String sLogicalName
98737>>>    String sRootName
98737>>>    String sDisplayName
98737>>>End_Struct
98737>>>
98737>>>Activate_View Activate_oUtilFunctions_vw for oUtilFunctions_vw
98747>>>>
98747>>>Object oUtilFunctions_vw is a dbView
98749>>>    Set Border_Style to Border_Thick
98750>>>    Set Size to 291 428
98751>>>    Set Location to 2 1
98752>>>    Set Label to "Utility Functions"
98753>>>    Set pbAutoActivate to True
98754>>>    Set Icon to "TestTools1.ico"
98755>>>    Set pbAcceptDropFiles to True
98756>>>
98756>>>    Object oScrollingContainer1 is a cDbScrollingContainer
98758>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
98760>>>
98760>>>            Object oSQL_grp is a Group
98762>>>                Set Size to 88 402
98763>>>                Set Location to 7 12
98764>>>                Set Label to "Run SQL Database Scripts Embedded as Resources"
98765>>>                Set peAnchors to anTopLeftRight
98766>>>
98766>>>                Object oCreateOrderEntry_btn is a cRDCButtonDPI
98768>>>                    Set Size to 14 219
98769>>>                    Set Location to 13 13
98770>>>                    Set Label to "Create New SQL Database [OrderEntry] Complete with Data"
98771>>>                    Set psToolTip to "Creates the full Order Entry Sample database from the DataFlex samples complete with data with the name: [OrderEntry]"
98772>>>                    Set psImage to "ActionCreateDatabase1.ico"
98773>>>
98773>>>                    Procedure OnClick
98776>>>                        String sInfoText sDriverID
98776>>>                        Boolean bOK
98776>>>                        TimeSpan tsTotalQueryTime
98776>>>                        Integer iRetval
98776>>>
98776>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98776>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98776>>>                        SQLIncludeScriptFile ..\Scripts\CreateOrderEntry.sql as CreateOrderEntry.sql
98776>>>                        Get YesNo_Box "This will run the 'CreateOrderEntry.sql' script from the 'Script' workspace folder which will create the [OrderEntry] database from the DataFlex samples for Microsoft SQL Server, complete with data. If it exists it will first be dropped, then re-created and populated with new data. Continue?" to iRetval
98777>>>                        If (iRetval <> MBR_Yes) Begin
98779>>>                            Procedure_Return
98780>>>                        End
98780>>>>
98780>>>
98780>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98781>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
98783>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
98784>>>                            Procedure_Return
98785>>>                        End
98785>>>>
98785>>>
98785>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
98786>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateOrderEntry.sql" MSSQLDRV_ID False to bOK
98787>>>                        Send StopWorkingMessage
98788>>>
98788>>>                        If (bOK = True) Begin
98790>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98791>>>                            Move ("Success! DataFlex Order Entry Sample Database was created as [OrderEntry]. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98792>>>                        End
98792>>>>
98792>>>
98792>>>                        Else Begin
98793>>>                            Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98794>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98795>>>                        End
98795>>>>
98795>>>
98795>>>                        Send Info_Box sInfoText
98796>>>                    End_Procedure
98797>>>
98797>>>                End_Object
98798>>>
98798>>>                Object oCreateNorthWind_btn is a cRDCButtonDPI
98800>>>                    Set Size to 14 219
98801>>>                    Set Location to 33 13
98802>>>                    Set Label to "Create New SQL Database [NorthWind] Complete with Data"
98803>>>                    Set psToolTip to "Creates the full NorthWind Sample database from the DataFlex samples complete with data with the name: [NorthWind]"
98804>>>                    Set psImage to "ActionCreateDatabase1.ico"
98805>>>
98805>>>                    Procedure OnClick
98808>>>                        String sInfoText sDriverID
98808>>>                        Boolean bOK
98808>>>                        TimeSpan tsTotalQueryTime
98808>>>                        Integer iRetval
98808>>>
98808>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98808>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98808>>>                        SQLIncludeScriptFile ..\Scripts\CreateNorthWindDatabase.sql as CreateNorthWindDatabase.sql
98808>>>
98808>>>                        Get YesNo_Box "This will run the 'CreateNorthWindDatabase.sql' script from the 'Script' workspace folder and it will create the [NorthWind] sample database in Microsoft SQL Server, complete with data. If it exists it will first be dropped, then re-created and populated with new data. Continue?" to iRetval
98809>>>                        If (iRetval <> MBR_Yes) Begin
98811>>>                            Procedure_Return
98812>>>                        End
98812>>>>
98812>>>
98812>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98813>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
98815>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
98816>>>                            Procedure_Return
98817>>>                        End
98817>>>>
98817>>>
98817>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
98818>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateNorthWindDatabase.sql" MSSQLDRV_ID False to bOK
98819>>>                        Send StopWorkingMessage
98820>>>
98820>>>                        If (bOK = True) Begin
98822>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98823>>>                            Move ("Success! The Northwind Sample Database was created as [NorthWind]. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98824>>>                        End
98824>>>>
98824>>>
98824>>>                        Else Begin
98825>>>                            Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98826>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98827>>>                        End
98827>>>>
98827>>>
98827>>>                        Send Info_Box sInfoText
98828>>>                    End_Procedure
98829>>>
98829>>>                End_Object
98830>>>
98830>>>                Object oCreateFullChinookDatabase_btn is a cRDCButtonDPI
98832>>>                    Set Size to 14 219
98833>>>                    Set Location to 53 13
98834>>>                    Set Label to "Create New SQL Database [Chinook] Complete with Data"
98835>>>                    Set psToolTip to "Creates the Chinook demo database complete with data in Microsoft SQL Server. Note: If it exists it will first be dropped then recreated. Note: These scripts were part of Data Access Europe's '' training class."
98836>>>                    Set psImage to "ActionCreateDatabase1.ico"
98837>>>
98837>>>                    Procedure OnClick
98840>>>                        String sInfoText sDriverID
98840>>>                        Boolean bOK
98840>>>                        TimeSpan tsTotalQueryTime
98840>>>                        Integer iRetval
98840>>>
98840>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98840>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98840>>>                        SQLIncludeScriptFile ..\Scripts\CreateChinookDatabase.sql as CreateChinookDatabase.sql
98840>>>
98840>>>                        Get YesNo_Box "This will run the 'CreateChinookDatabase.sql' script from the 'Script' workspace folder which will create the [Chinook] sample database complete with data. If it exists it will first be dropped, then re-created and populated with new data.\n\nContinue?" to iRetval
98841>>>                        If (iRetval <> MBR_Yes) Begin
98843>>>                            Procedure_Return
98844>>>                        End
98844>>>>
98844>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98845>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
98847>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
98848>>>                            Procedure_Return
98849>>>                        End
98849>>>>
98849>>>
98849>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
98850>>>
98850>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateChinookDatabase.sql" MSSQLDRV_ID False to bOK
98851>>>
98851>>>                        Send StopWorkingMessage
98852>>>                        If (bOK = True) Begin
98854>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98855>>>                            Move ("Success! The script was run OK. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98856>>>                        End
98856>>>>
98856>>>
98856>>>                        Else Begin
98857>>>                            Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98858>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98859>>>                        End
98859>>>>
98859>>>
98859>>>                        Send Info_Box sInfoText
98860>>>                    End_Procedure
98861>>>
98861>>>                End_Object
98862>>>
98862>>>                Object oInfo_tb is a TextBox
98864>>>                    Set Auto_Size_State to False
98865>>>                    Set Size to 25 158
98866>>>                    Set Location to 53 238
98867>>>                    Set Label to "Note: The Chinook script was provided by Data Access Europe as part of their 'Web Touch Training' course."
98868>>>                    Set Justification_Mode to JMode_Left
98869>>>                    Set peAnchors to anTopLeftRight
98870>>>                End_Object
98871>>>
98871>>>        //  This will choke the computer so don't try it!
98871>>>        //        Object oCreateAdventureWorksDatabase_btn is a cRDCButtonDPI
98871>>>        //            Set Size to 14 312
98871>>>        //            Set Location to 97 45
98871>>>        //            Set Label to "Create [AdventureWorks] Database and Populate with Data"
98871>>>        //            Set psToolTip to "Creates the Adenture Works database complete with data in Microsoft SQL Server. Note: If it exists it will first be dropped then recreated."
98871>>>        //
98871>>>        //            Procedure OnClick
98871>>>        //                String sInfoText
98871>>>        //                Boolean bOK
98871>>>        //                TimeSpan tsTotalQueryTime
98871>>>        //                Integer iRetval
98871>>>        //
98871>>>        //                // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98871>>>        //                // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98871>>>        ////                SQLIncludeScriptFile ..\Scripts\CreateAdventureWorks.sql as CreateAdventureWorks.sql
98871>>>        //Procedure_Return
98871>>>        //                Get YesNo_Box "This will create the [AdventurWorks] sample database complete with data. If it exists it will first be dropped, then re-created and populated with new data.\n\nContinue?" to iRetval
98871>>>        //                If (iRetval <> MBR_Yes) Begin
98871>>>        //                    Procedure_Return
98871>>>        //                End
98871>>>        //
98871>>>        //                Send StartWorkingMessage "Executing SQL Script. Please wait..."
98871>>>        //                Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateAdventureWorks.sql" MSSQLDRV_ID False to bOK
98871>>>        //                Send StopWorkingMessage
98871>>>        //
98871>>>        //                If (bOK = True) Begin
98871>>>        //                    Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98871>>>        //                    Move ("Success! The script was run OK. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98871>>>        //                End
98871>>>        //
98871>>>        //                Else Begin
98871>>>        //                    Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98871>>>        //                    Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98871>>>        //                End
98871>>>        //
98871>>>        //                Send Info_Box sInfoText
98871>>>        //            End_Procedure
98871>>>        //
98871>>>        //        End_Object
98871>>>
98871>>>            End_Object
98872>>>
98872>>>            Object oChangeIntFiles_grp is a Group
98874>>>                Set Size to 65 402
98875>>>                Set Location to 102 12
98876>>>                Set Label to "Change Old .int files to use Connection ID's"
98877>>>                Set peAnchors to anTopLeftRight
98878>>>
98878>>>                Object oSelectDataPath_fm is a Form
98880>>>                    Set Size to 12 300
98881>>>                    Set Location to 22 13
98882>>>                    Set Label to "Select path to a Data folder with .int files (Select one '.int' file):"
98883>>>                    Set Label_Col_Offset to 0
98884>>>                    Set Label_Row_Offset to 1
98885>>>                    Set Label_Justification_Mode to JMode_Top
98886>>>
98886>>>                    // This is very strange but for some reason the tooltip is _not_ displayed if PB_PromptOn is set...
98886>>>        //            Set Prompt_Button_Mode to PB_PromptOn
98886>>>                    Set psToolTip to "You can use this if you have .int files that currently have content like; 'SERVER=xxx; DATABASE=yyy' et.al. and you need to change them to use a connection ID like; 'SERVER_NAME DFCONNID=MyConnID'"
98887>>>                    Set peAnchors to anTopLeftRight
98888>>>
98888>>>                    Procedure Prompt
98891>>>                        String sPath sFileMask sRetval
98891>>>
98891>>>                        Get psDataPathFirstPart to sPath
98892>>>                        Move "Database intermediate files (*.int)|*.int" to sFileMask
98893>>>                        Get vSelect_File sFileMask "Please select an .int file from the data folder" sPath to sRetval
98894>>>                        If (sRetval <> "") Begin
98896>>>                            Get ParseFolderName sRetval to sPath
98897>>>                            If (Right(sPath, 1) ="\") Begin
98899>>>                                Move (Left(sPath, Length(sPath) -1)) to sPath
98900>>>                            End
98900>>>>
98900>>>                            Set Value to sPath
98901>>>                        End
98901>>>>
98901>>>                    End_Procedure
98902>>>
98902>>>                    // Returns the first datapath found in the psDataPath property.
98902>>>                    // The returned path always ends with a "\"
98902>>>                    Function psDataPathFirstPart Returns String
98905>>>                        String sDataPath
98905>>>                        Integer iCount
98905>>>
98905>>>                        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
98906>>>                        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
98907>>>                        If (iCount > 1) Begin
98909>>>                            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
98910>>>                        End
98910>>>>
98910>>>                        If (sDataPath <> "") Begin
98912>>>                            Get vFolderFormat sDataPath to sDataPath
98913>>>                        End
98913>>>>
98913>>>
98913>>>                        Function_Return sDataPath
98914>>>                    End_Function
98915>>>
98915>>>                End_Object
98916>>>
98916>>>                Object oSelectFolder_btn is a cRDCButtonDPI
98918>>>                    Set Size to 13 73
98919>>>                    Set Location to 22 320
98920>>>                    Set Label to "Select Folder"
98921>>>                    Set psToolTip to "Please select an .int file from the data folder"
98922>>>                    Set peAnchors to anTopRight
98923>>>                    Set psImage to "ActionOpen1.ico"
98924>>>
98924>>>                    Procedure OnClick
98927>>>                        Send Prompt to oSelectDataPath_fm
98928>>>                    End_Procedure
98929>>>
98929>>>                End_Object
98930>>>
98930>>>                Object oConnectionID_fm is a Form
98932>>>                    Set Size to 13 111
98933>>>                    Set Location to 38 202
98934>>>                    Set Label_Col_Offset to 2
98935>>>                    Set Label_Justification_Mode to JMode_Right
98936>>>                    Set Label to "Change to DFConnID:"
98937>>>                    Set psToolTip to "Please enter your Connection ID (DFCONNID=) that should replace the SERVER_NAME settings for all .int files in the selected folder."
98938>>>                    Set peAnchors to anTopRight
98939>>>                End_Object
98940>>>
98940>>>                Object oChangeAllIntFiles_btn is a cRDCButtonDPI
98942>>>                    Set Size to 13 68
98943>>>                    Set Location to 38 320
98944>>>                    Set Label to "GO !"
98945>>>                    Set psToolTip to "Changes or updates all .int files in the selected folder - except for DAW driver .int files (MSSQL_DRV.int, DB2_DRV.int & ODBC_DRV.int) - to use 'SERVER_NAME DFCONNID=xxx'"
98946>>>                    Set FontWeight to fw_Bold
98947>>>                    Set peAnchors to anTopRight
98948>>>
98948>>>                    Procedure OnClick
98951>>>                        String sDataPath sConnectionID
98951>>>                        Boolean bExists bActive
98951>>>                        Integer iRetval iChangedFiles
98951>>>
98951>>>                        Get Value of oSelectDataPath_fm to sDataPath
98952>>>                        Get vFolderExists sDataPath to bExists
98953>>>                        If (bExists = False) Begin
98955>>>                            Send Info_Box ("The data folder doesn't exist!\n" + sDataPath)
98956>>>                            Procedure_Return
98957>>>                        End
98957>>>>
98957>>>                        Get Value of oConnectionID_fm to sConnectionID
98958>>>                        Move (Trim(sConnectionID)) to sConnectionID
98959>>>                        If (sConnectionID = "") Begin
98961>>>                            Send Info_Box "You need to specify a Connection_ID to use for the .int files."
98962>>>                            Procedure_Return
98963>>>                        End
98963>>>>
98963>>>
98963>>>                        Get YesNo_Box ("Do you want to change all .int files in folder:\n" + sDataPath + "\n\nTo use 'DFCONNID=" + sConnectionID +"' ?") to iRetval
98964>>>                        If (iRetval <> MBR_Yes) Begin
98966>>>                            Procedure_Return
98967>>>                        End
98967>>>>
98967>>>                        Get YesNo_Box "All '.CCH' files will first be deleted. Continue?" to iRetval
98968>>>                        If (iRetval <> MBR_Yes) Begin
98970>>>                            Procedure_Return
98971>>>                        End
98971>>>>
98971>>>
98971>>>                        Get vDeleteFile (sDataPath + "\*.cch") to iRetval
98972>>>                        If (iRetval <> 0) Begin
98974>>>                            Send Info_Box "Could not delete .cch files!"
98975>>>                            Procedure_Return
98976>>>                        End
98976>>>>
98976>>>
98976>>>                        Send Initialize_StatusPanel of ghoStatusPanel "The Database Update Framework" "Changing Connection ID's in .int files" ""
98977>>>                        Send Start_StatusPanel of ghoStatusPanel
98978>>>                        Get SqlUtilChangeIntFilesToConnectionIDs of ghoDbUpdateFunctionLibrary sDataPath sConnectionID True to iChangedFiles
98979>>>
98979>>>                        Get Active_State of ghoStatusPanel to bActive
98980>>>                        If (bActive = False) Begin
98982>>>                            Send Info_Box "Process interupted..."
98983>>>                        End
98983>>>>
98983>>>                        Else Begin
98984>>>                            Send Stop_StatusPanel of ghoStatusPanel
98985>>>                            Send Info_Box ("Ready!" * String(iChangedFiles) * String(".int files changed."))
98986>>>                        End
98986>>>>
98986>>>                    End_Procedure
98987>>>
98987>>>                End_Object
98988>>>
98988>>>            End_Object
98989>>>
98989>>>            Object oRemoveFilelistDriverIDs_grp is a Group
98991>>>                Set Size to 59 402
98992>>>                Set Location to 171 12
98993>>>                Set Label to "Remove Database Identifications from Filelist.cfg"
98994>>>                Set peAnchors to anTopLeftRight
98995>>>//                Set TextColor to clGreen
98995>>>//
98995>>>//                Procedure Page Integer iPage
98995>>>//                    Integer ia iz
98995>>>//                    Forward Send Page iPage
98995>>>//                    Move 0 to iz
98995>>>//                    Move (AddressOf(iz)) to ia
98995>>>//                    Move (SetWindowTheme(Window_Handle(Self),ia,ia)) to iPage
98995>>>//                End_Procedure
98995>>>
98995>>>                Object oFilelistPath_fm is a Form
98997>>>                    Set Size to 13 299
98998>>>                    Set Location to 22 13
98999>>>                    Set Label to "Path and Filelist.cfg Name:"
99000>>>                    Set Label_Col_Offset to 0
99001>>>                    Set Label_Row_Offset to 1
99002>>>                    Set Label_Justification_Mode to JMode_Top
99003>>>
99003>>>                    // This is very strange but for some reason the tooltip is _not_ displayed if PB_PromptOn is set...
99003>>>        //            Set Prompt_Button_Mode to PB_PromptOn
99003>>>                    Set psToolTip to "You can use this if you have entries in a Filelist.cfg with driver prefixes like 'MSSQLDRV;Customer' and you need to remove them all."
99004>>>                    Set peAnchors to anTopLeftRight
99005>>>
99005>>>                    Procedure Prompt
99008>>>                        String sFileName sPath sFileMask sRetval
99008>>>
99008>>>                        Get Value to sFileName
99009>>>                        Get ParseFolderName sFileName to sPath
99010>>>                        Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
99011>>>                        Get vSelect_File sFileMask "Please select a Filelist.cft file" sPath to sRetval
99012>>>                        If (sRetval <> "") Begin
99014>>>                            Set Value to sRetval
99015>>>                            Set_Attribute DF_FILELIST_NAME to sRetval
99018>>>                        End
99018>>>>
99018>>>                    End_Procedure
99019>>>
99019>>>                    Procedure OnCreate
99022>>>                        String sFilelist
99022>>>                        Get_Attribute DF_FILELIST_NAME to sFilelist
99025>>>                        Set Value to sFilelist
99026>>>                    End_Procedure
99027>>>                    Send OnCreate
99028>>>
99028>>>                End_Object
99029>>>
99029>>>                Object oSelectFilelist_btn is a cRDCButtonDPI
99031>>>                    Set Size to 13 73
99032>>>                    Set Location to 22 319
99033>>>                    Set Label to "Select Filelist.cfg"
99034>>>                    Set psToolTip to "Please select a Filelist.cfg file to be changed"
99035>>>                    Set peAnchors to anTopRight
99036>>>
99036>>>                    Procedure OnClick
99039>>>                        Send Prompt to oFilelistPath_fm
99040>>>                    End_Procedure
99041>>>
99041>>>                End_Object
99042>>>
99042>>>                Object oInfo_tb is a TextBox
99044>>>                    Set Size to 9 207
99045>>>                    Set Location to 40 138
99046>>>                    Set Label to "Remove database driver identifications from Filelist.cfg:"
99047>>>                    Set peAnchors to anTopRight
99048>>>                End_Object
99049>>>
99049>>>                Object oChangeFilelist_btn is a cRDCButtonDPI
99051>>>                    Set Size to 13 68
99052>>>                    Set Location to 38 319
99053>>>                    Set Label to "GO !"
99054>>>                    Set FontWeight to fw_Bold
99055>>>                    Set peAnchors to anTopRight
99056>>>                    Set psToolTip to 'Removes all database driver identificatins from Filelist.cfg, such as: "MSSQLDRV:MyTable"'
99057>>>
99057>>>                    Procedure OnClick
99060>>>                        String sFileList
99060>>>                        Integer iRetval iCount
99060>>>                        Boolean bExits
99060>>>
99060>>>                        Get Value of oFilelistPath_fm to sFileList
99061>>>                        Get vFilePathExists sFileList to bExits
99062>>>                        If (bExits = False) Begin
99064>>>                            Send Info_Box ("Sorry, the Filelist.cfg does not exist;\n" + sFileList)
99065>>>                            Procedure_Return
99066>>>                        End
99066>>>>
99066>>>
99066>>>                        Get YesNo_Box ("Are you sure you want to remove all driver identifications for the following Filelist.cfg?\n" + sFileList) to iRetval
99067>>>                        If (iRetval <> MBR_Yes) Begin
99069>>>                            Procedure_Return
99070>>>                        End
99070>>>>
99070>>>                        Send Cursor_Wait of Cursor_Control
99071>>>
99071>>>                        Get SqlUtilFilelistRemoveDriverInfo of ghoDbUpdateFunctionLibrary sFileList to iCount
99072>>>
99072>>>                        Send Cursor_Ready of Cursor_Control
99073>>>                        If (iCount <> 0) Begin
99075>>>                            Send Info_Box ("Ready!" * String(iCount) * "Filelist.cfg entries adjusted.")
99076>>>                        End
99076>>>>
99076>>>                        Else Begin
99077>>>                            Send Info_Box "Ready. No driver based Filelist entries found."
99078>>>                        End
99078>>>>
99078>>>
99078>>>                    End_Procedure
99079>>>
99079>>>                End_Object
99080>>>
99080>>>            End_Object
99081>>>
99081>>>            Object oOutput_grp is a Group
99083>>>                Set Size to 47 402
99084>>>                Set Location to 234 12
99085>>>                Set Label to "Print sekected Filelist.cfg as a Text file"
99086>>>                Set peAnchors to anTopLeftRight
99087>>>
99087>>>                Object oOutput_rg is a RadioGroup
99089>>>                    Set Location to 18 13
99090>>>                    Set Size to 25 288
99091>>>                    Set Label to "Filelist Output Order"
99092>>>
99092>>>                    Object oRadio1 is a Radio
99094>>>                        Set Label to "Filelist Number"
99095>>>                        Set Size to 10 61
99096>>>                        Set Location to 10 7
99097>>>                    End_Object
99098>>>
99098>>>                    Object oRadio2 is a Radio
99100>>>                        Set Label to "Logical Name"
99101>>>                        Set Size to 10 61
99102>>>                        Set Location to 10 77
99103>>>                    End_Object
99104>>>
99104>>>                    Object oRadio3 is a Radio
99106>>>                        Set Label to "Root Name"
99107>>>                        Set Size to 10 61
99108>>>                        Set Location to 10 147
99109>>>                    End_Object
99110>>>
99110>>>                    Object oRadio4 is a Radio
99112>>>                        Set Label to "Display Name"
99113>>>                        Set Size to 10 62
99114>>>                        Set Location to 10 213
99115>>>                    End_Object
99116>>>
99116>>>                    Procedure Notify_Select_State Integer iToItem Integer iFromItem
99119>>>                        Forward Send Notify_Select_State iToItem iFromItem
99121>>>                        Set piSortOrder of oPrintFilelist_btn to iToItem
99122>>>                    End_Procedure
99123>>>
99123>>>                End_Object
99124>>>                
99124>>>                Object oPrintFilelist_btn is a cRDCButtonDPI
99126>>>                    Set Size to 13 78
99127>>>                    Set Location to 26 315
99128>>>                    Set Label to "Print to Filelist.txt"
99129>>>                    Set psToolTip to "Writes the content of Filelist.cfg to a textfile and shows the textfile in the editor program asociated with *.txt files."
99130>>>                    Set psImage to "ActionDocument1.ico"
99131>>>
99131>>>                    Property Integer piSortOrder 0 // Property gets set by the radio group object.
99133>>>
99133>>>                    // Custom array sort function.
99133>>>                    // iSortOrder = 0 -> Filelist number order
99133>>>                    // iSortOrder = 1 -> Logical name order
99133>>>                    // iSortOrder = 2 -> Root name order
99133>>>                    // iSortOrder = 3 -> Display name order
99133>>>                    Function CompareSortFilelist tFilelistDUF FilelistDUF1 tFilelistDUF FilelistDUF2 Returns Integer
99136>>>                        Integer iSortOrder
99136>>>
99136>>>                        Get piSortOrder to iSortOrder
99137>>>
99137>>>                        Case Begin
99137>>>                            Case (iSortOrder = 0)
99139>>>                                If (FilelistDUF1.iFileNumber  > FilelistDUF2.iFileNumber) Begin
99141>>>                                    Function_Return (GT)
99142>>>                                End
99142>>>>
99142>>>                                If (FilelistDUF1.iFileNumber  < FilelistDUF2.iFileNumber) Begin
99144>>>                                    Function_Return (LT)
99145>>>                                End
99145>>>>
99145>>>                                Function_Return (EQ)
99146>>>                            Case (iSortOrder = 1)
99149>>>                                If (Uppercase(FilelistDUF1.sLogicalName) > Uppercase(FilelistDUF2.sLogicalName)) Begin
99151>>>                                    Function_Return (GT)
99152>>>                                End
99152>>>>
99152>>>                                If (Uppercase(FilelistDUF1.sLogicalName) < Uppercase(FilelistDUF2.sLogicalName)) Begin
99154>>>                                    Function_Return (LT)
99155>>>                                End
99155>>>>
99155>>>                                Function_Return (EQ)
99156>>>                            Case (iSortOrder = 2)
99159>>>                                If (Uppercase(FilelistDUF1.sRootName)    > Uppercase(FilelistDUF2.sRootName)) Begin
99161>>>                                    Function_Return (GT)
99162>>>                                End
99162>>>>
99162>>>                                If (Uppercase(FilelistDUF1.sRootName)    < Uppercase(FilelistDUF2.sRootName)) Begin
99164>>>                                    Function_Return (LT)
99165>>>                                End
99165>>>>
99165>>>                                Function_Return (EQ)
99166>>>                            Case (iSortOrder = 3)
99169>>>                                If (Uppercase(FilelistDUF1.sDisplayName) > Uppercase(FilelistDUF2.sDisplayName)) Begin
99171>>>                                    Function_Return (GT)
99172>>>                                End
99172>>>>
99172>>>                                If (Uppercase(FilelistDUF1.sDisplayName) < Uppercase(FilelistDUF2.sDisplayName)) Begin
99174>>>                                    Function_Return (LT)
99175>>>                                End
99175>>>>
99175>>>                                Function_Return (EQ)
99176>>>                        Case End
99176>>>
99176>>>                    End_Function
99177>>>
99177>>>                    Procedure OnClick
99180>>>                        String sFileList sRootName sLogicalName sDisplayName sPath sOutputName sTable sExt
99180>>>                        Integer iCh iCount iSize
99180>>>                        Handle hTable
99180>>>                        tFilelistDUF[] FilelistDUFArray FilelistDUFSorted
99180>>>                        tFilelistDUF[] FilelistDUFArray FilelistDUFSorted
99182>>>
99182>>>                        Get Value of oFilelistPath_fm to sFileList
99183>>>                        Move (Trim(sFileList)) to sFileList
99184>>>                        If (sFileList = "") Begin
99186>>>                            Send Info_Box "You need to select a Filelist.cfg file first"
99187>>>                            Procedure_Return
99188>>>                        End
99188>>>>
99188>>>
99188>>>                        Get ParseFolderName sFileList to sPath
99189>>>                        Get vFolderFormat sPath to sPath
99190>>>                        Get ParseFileName sFileList to sOutputName
99191>>>                        Get ParseFileExtension sFileList to sExt
99192>>>                        Move (Replace(sExt, sOutputName, "")) to sOutputName
99193>>>                        Move (sOutputName + "txt")           to sOutputName
99194>>>                        Get Seq_Open_Output_Channel (sPath + sOutputName) to iCh
99195>>>                        If (iCh < 0) Begin
99197>>>                            Procedure_Return
99198>>>                        End
99198>>>>
99198>>>
99198>>>                        Move 0 to hTable
99199>>>                        Writeln channel iCh sFileList
99202>>>                        Writeln channel iCh "[Table No:]            [LogicalName:]        [RootName:]                             [DisplayName:]"
99205>>>                        Writeln channel iCh "==================================================================================================="
99208>>>                        Writeln channel iCh
99210>>>
99210>>>                        Move 0 to iCount
99211>>>                        Repeat
99211>>>>
99211>>>                            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
99214>>>                            If (hTable > 0) Begin
99216>>>                                Move hTable                                  to FilelistDUFArray[iCount].iFileNumber
99217>>>                                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to FilelistDUFArray[iCount].sLogicalName
99220>>>                                Get_Attribute DF_FILE_ROOT_NAME    of hTable to FilelistDUFArray[iCount].sRootName
99223>>>                                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to FilelistDUFArray[iCount].sDisplayName
99226>>>                                Increment iCount
99227>>>                            End
99227>>>>
99227>>>                        Until (hTable = 0)
99229>>>
99229>>>                        Move (SortArray(FilelistDUFArray, Self, (RefFunc(CompareSortFilelist)))) to FilelistDUFSorted
99230>>>                        Move (SizeOfArray(FilelistDUFSorted)) to iSize
99231>>>                        Decrement iSize
99232>>>
99232>>>                        For iCount from 0 to iSize
99238>>>>
99238>>>                            Move FilelistDUFSorted[iCount].iFileNumber  to hTable
99239>>>                            Move FilelistDUFSorted[iCount].sLogicalName to sLogicalName
99240>>>                            Move FilelistDUFSorted[iCount].sRootName    to sRootName
99241>>>                            Move FilelistDUFSorted[iCount].sDisplayName to sDisplayName
99242>>>
99242>>>                            Get PadLeft (String(hTable))        09 to sTable
99243>>>                            Get PadLeft (String(sLogicalName)) (27 - Length(sTable))       to sLogicalName
99244>>>                            Get PadLeft (String(sRootName))    (46 - Length(sLogicalName)) to sRootName
99245>>>                            Get PadLeft (String(sDisplayName)) (72 - Length(sRootName))    to sDisplayName
99246>>>
99246>>>                            Writeln channel iCh sTable (Utf8ToAnsi(sRootName)) (Utf8ToAnsi(sLogicalName)) (Utf8ToAnsi(sDisplayName))
99252>>>                        Loop
99253>>>>
99253>>>
99253>>>                        Writeln channel iCh "==================================================================================================="
99256>>>                        Writeln channel iCh "Total Number of Tables in Filelist.cfg: " (iSize + 1)
99260>>>                        Close_Output
99261>>>
99261>>>                        Send vShellExecute "open" sOutputName "" sPath
99262>>>                    End_Procedure
99263>>>
99263>>>                    Function PadLeft String sString Integer iLength String sOptChar Returns String
99266>>>                        String sChar
99266>>>
99266>>>                        If (Num_Arguments >= 3) Begin
99268>>>                            Move sOptChar to sChar
99269>>>                        End
99269>>>>
99269>>>                        Else Begin
99270>>>                            Move " " to sChar
99271>>>                        End
99271>>>>
99271>>>
99271>>>                        While (Length(sString) < iLength)
99275>>>                            Move (sChar + sString) to sString
99276>>>                        Loop
99277>>>>
99277>>>
99277>>>                        Function_Return sString
99278>>>                    End_Function
99279>>>
99279>>>                End_Object
99280>>>            End_Object
99281>>>
99281>>>        End_Object
99282>>>
99282>>>    End_Object
99283>>>
99283>>>    Procedure OnFileDropped String sFilename Boolean bLast
99286>>>        String sTest
99286>>>        Forward Send OnFileDropped sFilename bLast
99288>>>        If (bLast = True) Begin
99290>>>            Get ParseFileName sFilename to sTest
99291>>>            If (Uppercase(sTest) <> "FILELIST.CFG") Begin
99293>>>                Send Info_Box "Sorry, only Filist.cfg files can be dropped here..."
99294>>>                Procedure_Return
99295>>>            End
99295>>>>
99295>>>            Set Value of oFilelistPath_fm to sFilename
99296>>>        End
99296>>>>
99296>>>    End_Procedure
99297>>>
99297>>>End_Object
99298>
99298>        Procedure Activate_About
99301>            Send DoAbout "" "" ("Copyright 2016-2023" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "TestTools.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com" ("This tool was created with DataFlex" * String(C_DFVersion) * "from Data Access Worldwide. Please visit http://www.dataaccess.com for a free personal copy of DataFlex.")
99302>        End_Procedure
99303>
99303>        On_Key Key_Ctrl+Key_Tab           Send Switch_Prior_View
99304>        On_Key Key_Ctrl+Key_Shift+Key_Tab Send Switch_Next_View
99305>        On_Key Key_Ctrl+Key_W             Send Close_Panel
99306>    End_Object
99307>
99307>    // Note that we have overriden the cHtmlHelp "GetHelpFile" function
99307>    // in the oHtmlHelp object, so we need to explitetly send the message
99307>    // to that object.
99307>    Procedure ShowProgramHelp
99310>        Send DoDisplayKeyword of oHtmlHelp "DbUpdateFrameworkTests" //"cDbUpdateFunctionLibrary"
99311>    End_Procedure
99312>
99312>    On_Key Key_F1 Send ShowProgramHelp
99313>End_Object
99314>
99314>// We do this to activate the first view:
99314>//Send Activate_oSQLConnections_vw of (Client_Id(phoMainPanel(ghoApplication)))
99314>Start_UI
99315>
Including Resources...
Summary
Memory Available: 61047488512
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 52805
Total Resources: 10
Total Commands : 99314
Total Windows  : 0
Total Pages    : 0
Static Data    : 849031
Message area   : 638825
Total Blocks   : 80746
