Compiling Program: C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFTestProgram.src
Memory Available: 102313660416
1>    CompilerLevelWarning All On
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.x64.pkd    (C:\Program Files\DataFlex 20.1\Pkg\dfallent.x64.pkd)
73081>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJStandardCommandBarSystem.pkg)
73081>>>// these are all the packages used in a standard MDI menubar/toolbar system
73081>>>
73081>>>Use cCJCommandBarSystem.pkg
73081>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJStandardMenuItemClasses.pkg)
73081>>>>>Use Dfpanel.pkg
73081>>>>>Use cCJCommandBarSystem.pkg
73081>>>>>Use LanguageText.pkg
73081>>>>>
73081>>>>>
73081>>>>>Class cCJUndoMenuItem is a cCJMenuItem
73082>>>>>    
73082>>>>>    Procedure Construct_Object
73084>>>>>        Forward Send Construct_Object
73086>>>>>        Set psCaption   to C_$CaptionUndo
73087>>>>>        Set psToolTip to C_$ToolTipUndo
73088>>>>>        Set psDescription to C_$DescUndo
73089>>>>>        Set psImage to "ActionUndo.ico"
73090>>>>>        Set pbActiveUpdate to True
73091>>>>>        Set psCategory to C_$CategoryEdit
73092>>>>>        Set psShortcut to C_$Key_Ctrl_Z
73093>>>>>    End_Procedure
73094>>>>>    
73094>>>>>    Procedure OnExecute Variant vCommandBarControl
73096>>>>>        Send Undo of (focus(Self))
73097>>>>>    End_Procedure
73098>>>>>    
73098>>>>>    Function IsEnabled Returns Boolean
73100>>>>>        Boolean bEnabled
73100>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
73101>>>>>        Function_Return bEnabled
73102>>>>>    End_Function
73103>>>>>    
73103>>>>>End_Class
73104>>>>>
73104>>>>>
73104>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
73105>>>>>    
73105>>>>>    Procedure Construct_Object
73107>>>>>        Forward Send Construct_Object
73109>>>>>        Set psCaption   to C_$CaptionDelete
73110>>>>>        Set psToolTip to C_$ToolTipDelete
73111>>>>>        Set psDescription to C_$DescDelete
73112>>>>>        Set psImage to "actionDelete.ico"
73113>>>>>        Set psShortcut to C_$Key_Delete
73114>>>>>        Set pbActiveUpdate to True
73115>>>>>        Set psCategory to C_$CategoryEdit
73116>>>>>    End_Procedure
73117>>>>>    
73117>>>>>    
73117>>>>>    Procedure OnExecute Variant vCommandBarControl
73119>>>>>        Send Delete of (focus(Self))
73120>>>>>    End_Procedure
73121>>>>>    
73121>>>>>    Function IsEnabled Returns Boolean
73123>>>>>        Boolean bEnabled
73123>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
73124>>>>>        Function_Return bEnabled
73125>>>>>    End_Function
73126>>>>>    
73126>>>>>End_Class
73127>>>>>
73127>>>>>
73127>>>>>Class cCJCutMenuItem is a cCJMenuItem
73128>>>>>    
73128>>>>>    Procedure Construct_Object
73130>>>>>        Forward Send Construct_Object
73132>>>>>        Set psCaption   to C_$CaptionCut
73133>>>>>        Set psToolTip to C_$TooltipCut
73134>>>>>        Set psDescription to C_$DescCut
73135>>>>>        Set psImage to "actionCut.ico"
73136>>>>>        Set psShortcut to C_$Key_Ctrl_X
73137>>>>>        Set pbActiveUpdate to True
73138>>>>>        Set psCategory to C_$CategoryEdit
73139>>>>>    End_Procedure
73140>>>>>    
73140>>>>>    
73140>>>>>    Procedure OnExecute Variant vCommandBarControl
73142>>>>>        Send Cut of (focus(Self))
73143>>>>>    End_Procedure
73144>>>>>    
73144>>>>>    Function IsEnabled Returns Boolean
73146>>>>>        Boolean bEnabled
73146>>>>>        Get CanCut of (Focus(Self)) to bEnabled
73147>>>>>        Function_Return bEnabled
73148>>>>>    End_Function
73149>>>>>    
73149>>>>>End_Class
73150>>>>>
73150>>>>>
73150>>>>>Class cCJCopyMenuItem is a cCJMenuItem
73151>>>>>    
73151>>>>>    Procedure Construct_Object
73153>>>>>        Forward Send Construct_Object
73155>>>>>        Set psCaption   to C_$CaptionCopy
73156>>>>>        Set psToolTip to C_$ToolTipCopy
73157>>>>>        Set psDescription to C_$DescCopy
73158>>>>>        Set psImage to "actionCopy.ico"
73159>>>>>        Set psShortcut to C_$Key_Ctrl_C
73160>>>>>        Set pbActiveUpdate to True
73161>>>>>        Set psCategory to C_$CategoryEdit
73162>>>>>    End_Procedure
73163>>>>>    
73163>>>>>    
73163>>>>>    Procedure OnExecute Variant vCommandBarControl
73165>>>>>        Send Copy of (focus(Self))
73166>>>>>    End_Procedure
73167>>>>>    
73167>>>>>    Function IsEnabled Returns Boolean
73169>>>>>        Boolean bEnabled
73169>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
73170>>>>>        Function_Return bEnabled
73171>>>>>    End_Function
73172>>>>>    
73172>>>>>End_Class
73173>>>>>
73173>>>>>
73173>>>>>Class cCJPasteMenuItem is a cCJMenuItem
73174>>>>>    
73174>>>>>    Procedure Construct_Object
73176>>>>>        Forward Send Construct_Object
73178>>>>>        Set psCaption   to C_$CaptionPaste
73179>>>>>        Set psToolTip to C_$ToolTipPaste
73180>>>>>        Set psDescription to C_$DescPaste
73181>>>>>        Set psImage to "actionPaste.ico"
73182>>>>>        Set pbActiveUpdate to True
73183>>>>>        Set psShortcut to C_$Key_Ctrl_V
73184>>>>>        Set psCategory to C_$CategoryEdit
73185>>>>>    End_Procedure
73186>>>>>    
73186>>>>>    
73186>>>>>    Procedure OnExecute Variant vCommandBarControl
73188>>>>>        Send Paste of (focus(Self))
73189>>>>>    End_Procedure
73190>>>>>    
73190>>>>>    Function IsEnabled Returns Boolean
73192>>>>>        Boolean bEnabled
73192>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
73193>>>>>        Function_Return bEnabled
73194>>>>>    End_Function
73195>>>>>    
73195>>>>>End_Class
73196>>>>>
73196>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
73197>>>>>    
73197>>>>>    Procedure Construct_Object
73199>>>>>        Forward Send Construct_Object
73201>>>>>        Set psCaption   to C_$CaptionSelectAll
73202>>>>>        Set psToolTip to C_$ToolTipSelectAll
73203>>>>>        Set psDescription to C_$DescSelectAll
73204>>>>>        Set pbActiveUpdate to True
73205>>>>>        Set psShortcut to C_$Key_Ctrl_A
73206>>>>>        Set psCategory to C_$CategoryEdit
73207>>>>>    End_Procedure
73208>>>>>    
73208>>>>>    
73208>>>>>    Procedure OnExecute Variant vCommandBarControl
73210>>>>>        Send Select_All of (focus(Self))
73211>>>>>    End_Procedure
73212>>>>>    
73212>>>>>    Function IsEnabled Returns Boolean
73214>>>>>        Boolean bEnabled
73214>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
73215>>>>>        Function_Return bEnabled
73216>>>>>    End_Function
73217>>>>>    
73217>>>>>End_Class
73218>>>>>
73218>>>>>
73218>>>>>Class cCJExitMenuItem is a cCJMenuItem
73219>>>>>    
73219>>>>>    Procedure Construct_Object
73221>>>>>        Forward Send Construct_Object
73223>>>>>        Set psCaption to C_$CaptionExit
73224>>>>>        Set psToolTip to C_$ToolTipExit
73225>>>>>        Set psDescription to C_$ToolTipExit
73226>>>>>        Set psShortcut to C_$Key_Alt_F4
73227>>>>>        Set psCategory to C_$CategoryFile
73228>>>>>    End_Procedure
73229>>>>>    
73229>>>>>    Procedure OnExecute Variant vCommandBarControl
73231>>>>>        Send Exit_Application of Desktop
73232>>>>>    End_Procedure
73233>>>>>    
73233>>>>>End_Class
73234>>>>>
73234>>>>>Class cCJHelpMenuItem is a cCJMenuItem
73235>>>>>    
73235>>>>>    Procedure Construct_Object
73237>>>>>        Forward Send Construct_Object
73239>>>>>        Set psCaption to C_$CaptionHelp
73240>>>>>        Set psDescription to C_$ToolTipHelp
73241>>>>>        Set psToolTip to C_$DescHelp
73242>>>>>        Set psImage to "ActionHelp.ico"
73243>>>>>        Set psShortcut to "F1"
73244>>>>>        Set psCategory to C_$CategoryHelp
73245>>>>>    End_Procedure
73246>>>>>    
73246>>>>>    Procedure OnExecute Variant vCommandBarControl
73248>>>>>        Send Help of (Focus(Self))
73249>>>>>    End_Procedure
73250>>>>>    
73250>>>>>End_Class
73251>>>>>
73251>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
73252>>>>>    
73252>>>>>    Procedure Construct_Object
73254>>>>>        Forward Send Construct_Object
73256>>>>>        Set psCaption to C_$CaptionAddStatusbar
73257>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
73258>>>>>        Set psDescription to  C_$DescAddStatusbar
73259>>>>>        Set psCategory to C_$CategoryWindow
73260>>>>>    End_Procedure
73261>>>>>    
73261>>>>>    Procedure OnExecute Variant vCommandBarControl
73263>>>>>        Handle hoCommandBars hoClientArea
73263>>>>>        Get CommandBarSystemObject to hoCommandBars
73264>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73265>>>>>        If hoClientArea Begin
73267>>>>>            // the clientarea's parent panel has message
73267>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
73268>>>>>        End
73268>>>>>>
73268>>>>>    End_Procedure
73269>>>>>    
73269>>>>>    Function IsChecked Returns Boolean
73271>>>>>        Boolean bOn
73271>>>>>        Handle hoCommandBars hoClientArea
73271>>>>>        Get CommandBarSystemObject to hoCommandBars
73272>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73273>>>>>        If hoClientArea Begin
73275>>>>>            // the clientarea's parent panel has message
73275>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
73276>>>>>        End
73276>>>>>>
73276>>>>>        Function_Return bOn
73277>>>>>    End_Function
73278>>>>>End_Class
73279>>>>>
73279>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
73280>>>>>    
73280>>>>>    Procedure Construct_Object
73282>>>>>        Forward Send Construct_Object
73284>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
73285>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
73286>>>>>        Set psDescription to C_$DescAutoArrangeIcons
73287>>>>>        Set psCategory to C_$CategoryWindow
73288>>>>>    End_Procedure
73289>>>>>    
73289>>>>>    Procedure OnExecute Variant vCommandBarControl
73291>>>>>        Handle hoCommandBars hoClientArea
73291>>>>>        Get CommandBarSystemObject to hoCommandBars
73292>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73293>>>>>        If hoClientArea Begin
73295>>>>>            // the clientarea's parent panel has message
73295>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
73296>>>>>        End
73296>>>>>>
73296>>>>>    End_Procedure
73297>>>>>    
73297>>>>>    Function IsChecked Returns Boolean
73299>>>>>        Boolean bOn
73299>>>>>        Handle hoCommandBars hoClientArea
73299>>>>>        Get CommandBarSystemObject to hoCommandBars
73300>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73301>>>>>        If hoClientArea Begin
73303>>>>>            // the clientarea's parent panel has message
73303>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
73304>>>>>        End
73304>>>>>>
73304>>>>>        Function_Return bOn
73305>>>>>    End_Function
73306>>>>>End_Class
73307>>>>>
73307>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
73308>>>>>    
73308>>>>>    Procedure Construct_Object
73310>>>>>        Forward Send Construct_Object
73312>>>>>        Set psCaption to C_$CaptionRestoreMenus
73313>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
73314>>>>>        Set psDescription to C_$DescRestoreMenus
73315>>>>>        Set psCategory to C_$CategoryWindow
73316>>>>>    End_Procedure
73317>>>>>    
73317>>>>>    Procedure OnExecute Variant vCommandBarControl
73319>>>>>        Handle hoCommandBars
73319>>>>>        Get CommandBarSystemObject to hoCommandBars
73320>>>>>        Send RestoreLayout of hoCommandBars
73321>>>>>    End_Procedure
73322>>>>>    
73322>>>>>End_Class
73323>>>>>
73323>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
73324>>>>>    
73324>>>>>    Procedure Construct_Object
73326>>>>>        Forward Send Construct_Object
73328>>>>>        Set psCaption to C_$CaptionCascade
73329>>>>>        Set psToolTip to C_$ToolTipCascade
73330>>>>>        Set psDescription to  C_$DescCascade
73331>>>>>        Set psImage to "ActionCascade.ico"
73332>>>>>        Set psCategory to C_$CategoryWindow
73333>>>>>    End_Procedure
73334>>>>>    
73334>>>>>    Procedure OnExecute Variant vCommandBarControl
73336>>>>>        Handle hoCommandBars hoClientArea
73336>>>>>        Get CommandBarSystemObject to hoCommandBars
73337>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73338>>>>>        If hoClientArea Begin
73340>>>>>            Send Cascade_Windows of hoClientArea
73341>>>>>        End
73341>>>>>>
73341>>>>>    End_Procedure
73342>>>>>End_Class
73343>>>>>
73343>>>>>Class cCJTileHorizontally is a cCJMenuItem
73344>>>>>    
73344>>>>>    Procedure Construct_Object
73346>>>>>        Forward Send Construct_Object
73348>>>>>        Set psCaption to C_$CaptionTileHorizontally
73349>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
73350>>>>>        Set psDescription to  C_$DescTileHorizontally
73351>>>>>        Set psImage to "ActionTileHorizontally.ico"
73352>>>>>        Set psCategory to C_$CategoryWindow
73353>>>>>    End_Procedure
73354>>>>>    
73354>>>>>    Procedure OnExecute Variant vCommandBarControl
73356>>>>>        Handle hoCommandBars hoClientArea
73356>>>>>        Get CommandBarSystemObject to hoCommandBars
73357>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73358>>>>>        If hoClientArea Begin
73360>>>>>            Send Tile_Windows_Horizontal of hoClientArea
73361>>>>>        End
73361>>>>>>
73361>>>>>    End_Procedure
73362>>>>>End_Class
73363>>>>>
73363>>>>>Class cCJTileVertically is a cCJMenuItem
73364>>>>>    
73364>>>>>    Procedure Construct_Object
73366>>>>>        Forward Send Construct_Object
73368>>>>>        Set psCaption to C_$CaptionTileVertically
73369>>>>>        Set psToolTip to C_$ToolTipTileVertically
73370>>>>>        Set psDescription to  C_$DescTileVertically
73371>>>>>        Set psImage to "ActionTileVertically.ico"
73372>>>>>        Set psCategory to C_$CategoryWindow
73373>>>>>    End_Procedure
73374>>>>>    
73374>>>>>    Procedure OnExecute Variant vCommandBarControl
73376>>>>>        Handle hoCommandBars hoClientArea
73376>>>>>        Get CommandBarSystemObject to hoCommandBars
73377>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73378>>>>>        If hoClientArea Begin
73380>>>>>            Send Tile_Windows_Vertical of hoClientArea
73381>>>>>        End
73381>>>>>>
73381>>>>>    End_Procedure
73382>>>>>End_Class
73383>>>>>
73383>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
73384>>>>>    
73384>>>>>    Procedure Construct_Object
73386>>>>>        Forward Send Construct_Object
73388>>>>>        Set psCaption to C_$CaptionMinimizeWindows
73389>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
73390>>>>>        Set psDescription to  C_$DescMinimizeWindows
73391>>>>>        Set psCategory to C_$CategoryWindow
73392>>>>>    End_Procedure
73393>>>>>    
73393>>>>>    Procedure OnExecute Variant vCommandBarControl
73395>>>>>        Handle hoCommandBars hoClientArea
73395>>>>>        Get CommandBarSystemObject to hoCommandBars
73396>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73397>>>>>        If hoClientArea Begin
73399>>>>>            // the clientarea's parent panel has message
73399>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
73400>>>>>        End
73400>>>>>>
73400>>>>>    End_Procedure
73401>>>>>End_Class
73402>>>>>
73402>>>>>
73402>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
73403>>>>>    
73403>>>>>    Procedure Construct_Object
73405>>>>>        Forward Send Construct_Object
73407>>>>>        Set psCaption to C_$CaptionRestoreWindows
73408>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
73409>>>>>        Set psDescription to  C_$DescRestoreWindows
73410>>>>>        Set psCategory to C_$CategoryWindow
73411>>>>>    End_Procedure
73412>>>>>    
73412>>>>>    Procedure OnExecute Variant vCommandBarControl
73414>>>>>        Handle hoCommandBars hoClientArea
73414>>>>>        Get CommandBarSystemObject to hoCommandBars
73415>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73416>>>>>        If hoClientArea Begin
73418>>>>>            // the clientarea's parent panel has message
73418>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
73419>>>>>        End
73419>>>>>>
73419>>>>>    End_Procedure
73420>>>>>End_Class
73421>>>>>
73421>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
73422>>>>>    
73422>>>>>    Procedure Construct_Object
73424>>>>>        Forward Send Construct_Object
73426>>>>>        Set psCaption to C_$CaptionArrangeIcons
73427>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
73428>>>>>        Set psDescription to  C_$DescArrangeIcons
73429>>>>>        Set psCategory to C_$CategoryWindow
73430>>>>>    End_Procedure
73431>>>>>    
73431>>>>>    Procedure OnExecute Variant vCommandBarControl
73433>>>>>        Handle hoCommandBars hoClientArea
73433>>>>>        Get CommandBarSystemObject to hoCommandBars
73434>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73435>>>>>        If hoClientArea Begin
73437>>>>>            Send Arrange_Icons of hoClientArea
73438>>>>>        End
73438>>>>>>
73438>>>>>    End_Procedure
73439>>>>>    
73439>>>>>End_Class
73440>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJAboutMenuItem.pkg)
73440>>>>>Use cCJCommandBarSystem.pkg
73440>>>>>Use LanguageText.pkg
73440>>>>>
73440>>>>>// It is expected that if you use this class that you provide an about object that is
73440>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
73440>>>>>// because you may wish to create your own custom about package.
73440>>>>>
73440>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
73441>>>>>
73441>>>>>    Procedure Construct_Object
73443>>>>>        Forward Send Construct_Object
73445>>>>>        Set psCaption to C_$CaptionAbout
73446>>>>>        Set psDescription to C_$ToolTipAbout
73447>>>>>        Set psToolTip to C_$DescAbout
73448>>>>>        Set psImage to "ActionAbout.ico"
73449>>>>>        Set psCategory to C_$CategoryHelp
73450>>>>>    End_Procedure
73451>>>>>    
73451>>>>>    Procedure OnExecute Variant vCommandBarControl
73453>>>>>        Handle hoCommandBars hoClientArea
73453>>>>>        Get CommandBarSystemObject to hoCommandBars
73454>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73455>>>>>        If hoClientArea Begin
73457>>>>>            Send Activate_About of hoClientArea
73458>>>>>        End
73458>>>>>>
73458>>>>>    End_Procedure
73459>>>>>
73459>>>>>End_Class
73460>>>>>
73460>>>>>
73460>>>Use cCJDeoMenuItemClasses.pkg
73460>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJMDIWindowsMenuItem.pkg)
73460>>>>>Use cCJCommandBarSystem.pkg
73460>>>>>
73460>>>>>Register_Function Client_ID Returns Integer
73460>>>>>
73460>>>>>// only used by cCJMDIWIndowsMenuItem
73460>>>>>Class cCJMDIWindowItem is a cCJMenuItem
73461>>>>>    
73461>>>>>    Procedure Construct_Object
73463>>>>>        Forward Send Construct_Object
73465>>>>>        Property Handle phWindow 0 // object id of view
73466>>>>>        Set pbControlFlagNoMovable to True
73467>>>>>        Set pbActiveUpdate to True
73468>>>>>    End_Procedure
73469>>>>>    
73469>>>>>    Procedure OnExecute Variant vCommandBarControl
73471>>>>>        Handle hWindow
73471>>>>>        Get phWindow to hWindow
73472>>>>>        Send Activate_View of hWindow
73473>>>>>    End_Procedure
73474>>>>>    
73474>>>>>End_Class
73475>>>>>
73475>>>>>
73475>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
73476>>>>>    
73476>>>>>    Procedure Construct_Object
73478>>>>>        Forward Send Construct_Object
73480>>>>>        Property Handle[] phArrayOfWindows
73481>>>>>        Set peControlType to xtpControlPopup
73482>>>>>        Set psCategory to C_$CategoryWindow
73483>>>>>    End_Procedure
73484>>>>>    
73484>>>>>    // This adds MDI windows to the existing menu items.
73484>>>>>    // This removes any existing windows menus and always adds a new set to the end
73484>>>>>    
73484>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
73486>>>>>        Handle  hClientArea hView
73486>>>>>        String  sLabel
73486>>>>>        Integer i iWindows
73486>>>>>        Handle[] hArrayOfWindows
73487>>>>>        Variant vItem
73487>>>>>        
73487>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
73487>>>>>        // also assume that destroying an action removes all menu instances of that action
73487>>>>>        Get phArrayOfWindows to hArrayOfWindows
73488>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
73489>>>>>        For i from 0 to (iWindows-1)
73495>>>>>>
73495>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
73496>>>>>        Loop
73497>>>>>>
73497>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
73498>>>>>        
73498>>>>>        // Add all views to this menu. Create the action and add the item
73498>>>>>        Move 0 to i
73499>>>>>        Get Client_Id to hClientArea // object id of client area
73500>>>>>        If (hClientArea > 0) Begin
73502>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
73503>>>>>            While (hView <> 0)
73507>>>>>                If (Active_State(hView)) Begin
73509>>>>>                    // create the action
73509>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
73510>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
73511>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
73512>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
73513>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
73515>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
73516>>>>>                    End
73516>>>>>>
73516>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
73517>>>>>                    If (i=0) Begin
73519>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
73520>>>>>                    End
73520>>>>>>
73520>>>>>                    // Create a menu item for this action
73520>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
73521>>>>>                    Increment i
73522>>>>>                End
73522>>>>>>
73522>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
73523>>>>>            Loop
73524>>>>>>
73524>>>>>        End
73524>>>>>>
73524>>>>>        
73524>>>>>        Set phArrayOfWindows to hArrayOfWindows
73525>>>>>        
73525>>>>>    End_Procedure
73526>>>>>    
73526>>>>>End_Class
73527>Use cCJCommandBarSystem.pkg
73527>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJSkinFramework.pkg)
73527>>>Use windows.pkg
73527>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJComSkinFramework.pkg)
73527>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v20.0.0\Bin\Codejock.SkinFramework.Unicode.x64.v20.0.0.ocx
73527>>>>>Use FlexCom20.pkg
73527>>>>>
73527>>>>>// Changes to Imported package
73527>>>>>//     OLEXTPxx to XTPxx
73527>>>>>//     OLExtpxx to xtpxx
73527>>>>>//     OLESkinFramework to SkinFramework
73527>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
73527>>>>>//     cCom classes to cCJ
73527>>>>>//     cCJAutomationObject back to cComAutomationObject
73527>>>>>//     cCJActiveXControl back to cComActiveXControl
73527>>>>>//     cCJSkinFramework to cCJComSkinFramework
73527>>>>>//     Use statements as noted below (classes moved to these files)
73527>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
73527>>>>>
73527>>>>>// These have been extracted from this class and moved into seperate packages
73527>>>>>// because other Codejock classes use these.
73527>>>>>Use cCJColorManager.pkg     // cCJColorManager
73527>>>>>
73527>>>>>
73527>>>>>Define SkinFrameworkApplyOptions for Integer
73527>>>>>    Define xtpSkinApplyMetrics for 1
73527>>>>>    Define xtpSkinApplyFrame for 2
73527>>>>>    Define xtpSkinApplyColors for 4
73527>>>>>    Define xtpSkinApplyMenus for 8
73527>>>>>
73527>>>>>// CLSID: {C0DE2000-28D7-4F2C-87A7-7266367B4655}
73527>>>>>// Dispatch interface for SkinFramework Control
73527>>>>>Class cCJ_DSkinFramework is a Mixin
73528>>>>>
73528>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
73530>>>>>        SkinFrameworkApplyOptions retVal
73530>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
73531>>>>>        Function_Return retVal
73532>>>>>    End_Function
73533>>>>>
73533>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
73535>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
73536>>>>>    End_Procedure
73537>>>>>
73537>>>>>    Function ComAutoApplyNewWindows Returns Boolean
73539>>>>>        Boolean retVal
73539>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
73540>>>>>        Function_Return retVal
73541>>>>>    End_Function
73542>>>>>
73542>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
73544>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
73545>>>>>    End_Procedure
73546>>>>>
73546>>>>>    Function ComAutoApplyNewThreads Returns Boolean
73548>>>>>        Boolean retVal
73548>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
73549>>>>>        Function_Return retVal
73550>>>>>    End_Function
73551>>>>>
73551>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
73553>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
73554>>>>>    End_Procedure
73555>>>>>
73555>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
73557>>>>>        Handle hDispatchDriver
73557>>>>>        Boolean retVal
73557>>>>>        Get phDispatchDriver to hDispatchDriver
73558>>>>>        Send PrepareParams to hDispatchDriver 2
73559>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
73560>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
73561>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
73562>>>>>        Function_Return retVal
73563>>>>>    End_Function
73564>>>>>
73564>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
73566>>>>>        Handle hDispatchDriver
73566>>>>>        Get phDispatchDriver to hDispatchDriver
73567>>>>>        Send PrepareParams to hDispatchDriver 1
73568>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73569>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
73570>>>>>    End_Procedure
73571>>>>>
73571>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
73573>>>>>        Handle hDispatchDriver
73573>>>>>        Get phDispatchDriver to hDispatchDriver
73574>>>>>        Send PrepareParams to hDispatchDriver 2
73575>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73576>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
73577>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
73578>>>>>    End_Procedure
73579>>>>>
73579>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
73581>>>>>        Handle hDispatchDriver
73581>>>>>        Get phDispatchDriver to hDispatchDriver
73582>>>>>        Send PrepareParams to hDispatchDriver 1
73583>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73584>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
73585>>>>>    End_Procedure
73586>>>>>
73586>>>>>    Procedure ComRemoveAllWindows
73588>>>>>        Handle hDispatchDriver
73588>>>>>        Get phDispatchDriver to hDispatchDriver
73589>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
73590>>>>>    End_Procedure
73591>>>>>
73591>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
73593>>>>>        Handle hDispatchDriver
73593>>>>>        Get phDispatchDriver to hDispatchDriver
73594>>>>>        Send PrepareParams to hDispatchDriver 2
73595>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
73596>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
73597>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
73598>>>>>    End_Procedure
73599>>>>>
73599>>>>>    Procedure ComRemoveWindowClass String llClassName
73601>>>>>        Handle hDispatchDriver
73601>>>>>        Get phDispatchDriver to hDispatchDriver
73602>>>>>        Send PrepareParams to hDispatchDriver 1
73603>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
73604>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
73605>>>>>    End_Procedure
73606>>>>>
73606>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
73608>>>>>        Handle hDispatchDriver
73608>>>>>        Variant retVal
73608>>>>>        Get phDispatchDriver to hDispatchDriver
73609>>>>>        Send PrepareParams to hDispatchDriver 2
73610>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
73611>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
73612>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
73613>>>>>        Function_Return retVal
73614>>>>>    End_Function
73615>>>>>
73615>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
73617>>>>>        Handle hDispatchDriver
73617>>>>>        Variant retVal
73617>>>>>        Get phDispatchDriver to hDispatchDriver
73618>>>>>        Send PrepareParams to hDispatchDriver 1
73619>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
73620>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
73621>>>>>        Function_Return retVal
73622>>>>>    End_Function
73623>>>>>
73623>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
73625>>>>>        Handle hDispatchDriver
73625>>>>>        OLE_COLOR retVal
73625>>>>>        Get phDispatchDriver to hDispatchDriver
73626>>>>>        Send PrepareParams to hDispatchDriver 1
73627>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
73628>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
73629>>>>>        Function_Return retVal
73630>>>>>    End_Function
73631>>>>>
73631>>>>>    Procedure ComExcludeModule String llModuleName
73633>>>>>        Handle hDispatchDriver
73633>>>>>        Get phDispatchDriver to hDispatchDriver
73634>>>>>        Send PrepareParams to hDispatchDriver 1
73635>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
73636>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
73637>>>>>    End_Procedure
73638>>>>>
73638>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
73640>>>>>        Handle hDispatchDriver
73640>>>>>        Variant retVal
73640>>>>>        Get phDispatchDriver to hDispatchDriver
73641>>>>>        Send PrepareParams to hDispatchDriver 2
73642>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
73643>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
73644>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
73645>>>>>        Function_Return retVal
73646>>>>>    End_Function
73647>>>>>
73647>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
73649>>>>>        Handle hDispatchDriver
73649>>>>>        Get phDispatchDriver to hDispatchDriver
73650>>>>>        Send PrepareParams to hDispatchDriver 2
73651>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73652>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
73653>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
73654>>>>>    End_Procedure
73655>>>>>
73655>>>>>    Procedure ComAboutBox
73657>>>>>        Handle hDispatchDriver
73657>>>>>        Get phDispatchDriver to hDispatchDriver
73658>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
73659>>>>>    End_Procedure
73660>>>>>End_Class
73661>>>>>
73661>>>>>// CLSID: {C0DE2000-4463-4030-B324-AC6A8075FEC8}
73661>>>>>// Event interface for SkinFramework Control
73661>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
73662>>>>>
73662>>>>>    Procedure RegisterComEvents
73664>>>>>    End_Procedure
73665>>>>>End_Class
73666>>>>>
73666>>>>>// CoClass
73666>>>>>// ProgID: Codejock.SkinFramework.20.0.0
73666>>>>>// CLSID: {C0DE2000-2217-42EE-B1B0-82C890431F17}
73666>>>>>// SkinFramework Control
73666>>>>>Class cCJComSkinFramework is a cComActiveXControl
73667>>>>>    Import_Class_Protocol cCJ_DSkinFramework
73668>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
73669>>>>>
73669>>>>>    Procedure Construct_Object
73671>>>>>        Forward Send Construct_Object
73673>>>>>        Set psProgID to "{C0DE2000-2217-42EE-B1B0-82C890431F17}"
73674>>>>>        Set psEventId to "{C0DE2000-4463-4030-B324-AC6A8075FEC8}"
73675>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2021 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v20.0"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
73676>>>>>        Set peAutoCreate to acAutoCreate
73677>>>>>    End_Procedure
73678>>>>>End_Class
73679>>>>>
73679>>>>>// CLSID: {C0DE2000-CA9A-4AA9-8601-0AB7F551AA3D}
73679>>>>>// SkinFramework Global Settings
73679>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
73680>>>>>
73680>>>>>    Function ComLicense Returns String
73682>>>>>        String retVal
73682>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
73683>>>>>        Function_Return retVal
73684>>>>>    End_Function
73685>>>>>
73685>>>>>    Procedure Set ComLicense String value
73687>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
73688>>>>>    End_Procedure
73689>>>>>
73689>>>>>    Function ComTitle Returns String
73691>>>>>        String retVal
73691>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
73692>>>>>        Function_Return retVal
73693>>>>>    End_Function
73694>>>>>
73694>>>>>    Procedure Set ComTitle String value
73696>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
73697>>>>>    End_Procedure
73698>>>>>
73698>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
73698>>>>>    Function ComUseLegacyCore Returns Boolean
73700>>>>>        Boolean retVal
73700>>>>>        Get ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to retVal
73701>>>>>        Function_Return retVal
73702>>>>>    End_Function
73703>>>>>
73703>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
73703>>>>>    Procedure Set ComUseLegacyCore Boolean value
73705>>>>>        Set ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to value
73706>>>>>    End_Procedure
73707>>>>>
73707>>>>>    Function ComVersion Returns String
73709>>>>>        Handle hDispatchDriver
73709>>>>>        String retVal
73709>>>>>        Get phDispatchDriver to hDispatchDriver
73710>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
73711>>>>>        Function_Return retVal
73712>>>>>    End_Function
73713>>>>>
73713>>>>>    Function ComUnicode Returns Boolean
73715>>>>>        Handle hDispatchDriver
73715>>>>>        Boolean retVal
73715>>>>>        Get phDispatchDriver to hDispatchDriver
73716>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
73717>>>>>        Function_Return retVal
73718>>>>>    End_Function
73719>>>>>
73719>>>>>    Function ComOcxPath Returns String
73721>>>>>        Handle hDispatchDriver
73721>>>>>        String retVal
73721>>>>>        Get phDispatchDriver to hDispatchDriver
73722>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
73723>>>>>        Function_Return retVal
73724>>>>>    End_Function
73725>>>>>End_Class
73726>>>>>
73726>>>>>// CoClass
73726>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.20.0.0
73726>>>>>// CLSID: {C0DE2000-F744-4373-B38D-29CE83EF0EE5}
73726>>>>>// SkinFramework Global Settings
73726>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
73727>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
73728>>>>>
73728>>>>>    Procedure Construct_Object
73730>>>>>        Forward Send Construct_Object
73732>>>>>        Set psProgID to "{C0DE2000-F744-4373-B38D-29CE83EF0EE5}"
73733>>>>>        Set peAutoCreate to acNoAutoCreate
73734>>>>>    End_Procedure
73735>>>>>End_Class
73736>>>>>
73736>>>>>// CLSID: {C0DE2000-1038-498E-A936-361F08B4C4AA}
73736>>>>>Class cCJSkinIniFile is a cComAutomationObject
73737>>>>>
73737>>>>>    Function ComColorScheme Returns String
73739>>>>>        String retVal
73739>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
73740>>>>>        Function_Return retVal
73741>>>>>    End_Function
73742>>>>>
73742>>>>>    Procedure Set ComColorScheme String value
73744>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
73745>>>>>    End_Procedure
73746>>>>>
73746>>>>>    Function ComFontSize Returns String
73748>>>>>        String retVal
73748>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
73749>>>>>        Function_Return retVal
73750>>>>>    End_Function
73751>>>>>
73751>>>>>    Procedure Set ComFontSize String value
73753>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
73754>>>>>    End_Procedure
73755>>>>>
73755>>>>>    Function ComIniFileName Returns String
73757>>>>>        String retVal
73757>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
73758>>>>>        Function_Return retVal
73759>>>>>    End_Function
73760>>>>>
73760>>>>>    Procedure Set ComIniFileName String value
73762>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
73763>>>>>    End_Procedure
73764>>>>>End_Class
73765>>>>>
73765>>>>>// CLSID: {C0DE2000-4834-499E-95B4-30E0C3F43A10}
73765>>>>>Class cCJSkinDescription is a cComAutomationObject
73766>>>>>
73766>>>>>    Function ComName Returns String
73768>>>>>        String retVal
73768>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
73769>>>>>        Function_Return retVal
73770>>>>>    End_Function
73771>>>>>
73771>>>>>    Procedure Set ComName String value
73773>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
73774>>>>>    End_Procedure
73775>>>>>
73775>>>>>    Function ComPath Returns String
73777>>>>>        String retVal
73777>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
73778>>>>>        Function_Return retVal
73779>>>>>    End_Function
73780>>>>>
73780>>>>>    Procedure Set ComPath String value
73782>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
73783>>>>>    End_Procedure
73784>>>>>
73784>>>>>    Function ComCount Returns Integer
73786>>>>>        Handle hDispatchDriver
73786>>>>>        Integer retVal
73786>>>>>        Get phDispatchDriver to hDispatchDriver
73787>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
73788>>>>>        Function_Return retVal
73789>>>>>    End_Function
73790>>>>>
73790>>>>>    Function ComIniFile Integer llIndex Returns Variant
73792>>>>>        Handle hDispatchDriver
73792>>>>>        Variant retVal
73792>>>>>        Get phDispatchDriver to hDispatchDriver
73793>>>>>        Send PrepareParams to hDispatchDriver 1
73794>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
73795>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
73796>>>>>        Function_Return retVal
73797>>>>>    End_Function
73798>>>>>
73798>>>>>    Function Com_NewEnum Returns Variant
73800>>>>>        Handle hDispatchDriver
73800>>>>>        Variant retVal
73800>>>>>        Get phDispatchDriver to hDispatchDriver
73801>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
73802>>>>>        Function_Return retVal
73803>>>>>    End_Function
73804>>>>>End_Class
73805>>>>>
73805>>>>>// CLSID: {C0DE2000-FB37-4B08-A2B9-F6F8B253D697}
73805>>>>>Class cCJSkinDescriptions is a cComAutomationObject
73806>>>>>
73806>>>>>    Function ComCount Returns Integer
73808>>>>>        Handle hDispatchDriver
73808>>>>>        Integer retVal
73808>>>>>        Get phDispatchDriver to hDispatchDriver
73809>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
73810>>>>>        Function_Return retVal
73811>>>>>    End_Function
73812>>>>>
73812>>>>>    Function ComSkin Integer llIndex Returns Variant
73814>>>>>        Handle hDispatchDriver
73814>>>>>        Variant retVal
73814>>>>>        Get phDispatchDriver to hDispatchDriver
73815>>>>>        Send PrepareParams to hDispatchDriver 1
73816>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
73817>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
73818>>>>>        Function_Return retVal
73819>>>>>    End_Function
73820>>>>>
73820>>>>>    Function Com_NewEnum Returns Variant
73822>>>>>        Handle hDispatchDriver
73822>>>>>        Variant retVal
73822>>>>>        Get phDispatchDriver to hDispatchDriver
73823>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
73824>>>>>        Function_Return retVal
73825>>>>>    End_Function
73826>>>>>End_Class
73827>>>>>
73827>>>>>// CLSID: {C0DE2000-C56F-43C0-BCF1-8193B35FE4C4}
73827>>>>>Class cCJSkinSchema is a cComAutomationObject
73828>>>>>
73828>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
73830>>>>>        Handle hDispatchDriver
73830>>>>>        OLE_COLOR retVal
73830>>>>>        Get phDispatchDriver to hDispatchDriver
73831>>>>>        Send PrepareParams to hDispatchDriver 1
73832>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
73833>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
73834>>>>>        Function_Return retVal
73835>>>>>    End_Function
73836>>>>>End_Class
73837>>>Use cApplication.pkg
73837>>>
73837>>>Struct tSkinInformation
73837>>>    String sName     // description of the skin
73837>>>    String sSkinfile // file path. Can be relative or full
73837>>>    String sSkinIni  // section name
73837>>>End_Struct
73837>>>
73837>>>
73837>>>Class cCJSkinFramework is a cCJComSkinFramework
73838>>>    
73838>>>    Procedure Construct_Object
73840>>>        Forward Send Construct_Object
73842>>>        
73842>>>        Property String psSkinFile ""
73843>>>        Property String psSkinIni ""
73844>>>        Property Boolean pbLoadPreference False
73845>>>        
73845>>>        Set peAutoCreate to acAutoCreate
73846>>>        
73846>>>        Move Self to ghoSkinFramework
73847>>>    End_Procedure
73848>>>    
73848>>>    // return the default skin path, which is the programs directory.
73848>>>    // This requires an application object.
73848>>>    // If you want to different skin path, override this.
73848>>>    Function SkinPath Returns String
73850>>>        String sPath sPaths
73850>>>        Handle hoWorkspace
73850>>>        If ghoApplication Begin
73852>>>            Get phoWorkspace of ghoApplication to hoWorkspace
73853>>>            Get psProgramPath of hoWorkspace to sPaths
73854>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
73855>>>        End
73855>>>>
73855>>>        Else Begin
73856>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
73857>>>>
73857>>>        End
73857>>>>
73857>>>        Function_Return sPath
73858>>>    End_Function
73859>>>    
73859>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
73859>>>    // returns itself. If it is not, it uses SkinPath to get the path.
73859>>>    Function SkinQFile Returns String
73861>>>        String sFile sPath sSep
73861>>>        Boolean bQualified
73861>>>        Get psSkinFile to sFile
73862>>>        If not (IsFileNameQualified(sFile)) Begin
73864>>>            Get SkinPath to sPath
73865>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
73866>>>            Move (sPath - sSep - sFile) to sFile
73867>>>        End
73867>>>>
73867>>>        Function_Return sFile
73868>>>    End_Function
73869>>>    
73869>>>    // defines the default VDF window class mapping.
73869>>>    Procedure OnAddVDFWindowClasses
73871>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
73872>>>        Send ComAddWindowClass "DFentry"                 "Edit"
73873>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
73874>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
73875>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
73876>>>        Send ComAddWindowClass "DFformlist"              "Edit"
73877>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
73878>>>        Send ComAddWindowClass "DFbutton"                "Button"
73879>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
73880>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
73881>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
73882>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
73883>>>        Send ComAddWindowClass "DFedit"                  "edit"
73884>>>        Send ComAddWindowClass "DFlistedit"              "edit"
73885>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
73886>>>        Send ComAddWindowClass "DFgroup"                 "Button"
73887>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
73888>>>        // External class
73888>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
73889>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
73890>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
73891>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
73892>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
73893>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
73894>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
73895>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
73896>>>    End_Procedure
73897>>>    
73897>>>    // Used to support developer designed class mappings (e.g. COM controls)
73897>>>    Procedure OnAddCustomWindowClasses
73899>>>    End_Procedure
73900>>>    
73900>>>    // called when object is created during end_construct_object.
73900>>>    Procedure OnCreate
73902>>>        Integer iOpts
73902>>>        Boolean bUseWindowsFont
73902>>>        Forward Send OnCreate
73904>>>        
73904>>>        // if we are using the windows fonts we will disable the apply metrics which
73904>>>        // never really looked good anyway. This test only exists or legacy purposes
73904>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
73905>>>        If bUseWindowsFont Begin
73907>>>            Get ComApplyOptions to iOpts
73908>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
73909>>>        End
73909>>>>
73909>>>        
73909>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
73909>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
73909>>>        // and this was the suggested workaround.
73909>>>        Set ComAutoApplyNewThreads to False
73910>>>        
73910>>>        Send OnAddVDFWindowClasses
73911>>>        Send OnAddCustomWindowClasses
73912>>>        
73912>>>        // if preferences are used, it will set psSkinFile and psSkinIni
73912>>>        If (pbLoadPreference(Self)) Begin
73914>>>            Send LoadSkinPreference
73915>>>        End
73915>>>>
73915>>>        // if a skin file name exists, we apply the skin.
73915>>>        If (psSkinFile(Self)<>"") Begin
73917>>>            Send ApplySkin
73918>>>        End
73918>>>>
73918>>>    End_Procedure
73919>>>    
73919>>>    // called by framework as part of application exit.
73919>>>    Procedure Broadcast_Notify_Exit_Application
73921>>>        Send Notify_Exit_Application
73922>>>    End_Procedure
73923>>>    
73923>>>    Procedure Notify_Exit_Application
73925>>>        If (pbLoadPreference(Self)) Begin
73927>>>            Send SaveSkinPreference
73928>>>        End
73928>>>>
73928>>>    End_Procedure
73929>>>    
73929>>>    Procedure NotifyPreApplySkin
73931>>>        Broadcast Send OnPreApplySkin of Desktop True
73933>>>    End_Procedure
73934>>>    
73934>>>    Procedure NotifyPostApplySkin
73936>>>        Broadcast Send OnPostApplySkin of Desktop True
73938>>>    End_Procedure
73939>>>    
73939>>>    // returns an array of all skins in the path. If path is "", use the default path.
73939>>>    // If the default path is used, returns the file names as relative names, else use full path.
73939>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
73941>>>        tSkinInformation[] Skins
73941>>>        tSkinInformation[] Skins
73942>>>        String sSkinName sSkinFile sDefaultPath sSep
73942>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
73942>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
73942>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
73942>>>        Integer iPos iDfltLen
73942>>>        Boolean bUseRelativePath
73942>>>        
73942>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
73943>>>        
73943>>>        Get SkinPath to sDefaultPath
73944>>>        If (sPath="") Begin
73946>>>            Move sDefaultPath to sPath
73947>>>        End
73947>>>>
73947>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
73948>>>        Move (Length(sDefaultPath)) to iDfltLen
73949>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
73950>>>        
73950>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
73951>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
73953>>>            
73953>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
73954>>>            Get Create U_cCJSkinDescription to hSkinDescription
73955>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
73956>>>            
73956>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
73957>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
73958>>>            
73958>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
73964>>>>
73964>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
73965>>>                Set pvComObject of hSkinDescription to vSkinDescription
73966>>>                
73966>>>                Get ComCount of hSkinDescription to iNumSkins
73967>>>                
73967>>>                For iSkinsCount from 0 to (iNumSkins-1)
73973>>>>
73973>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
73974>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
73975>>>                    
73975>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
73976>>>                    Get ComPath of hSkinDescription to sSkinFile
73977>>>                    If bUseRelativePath Begin
73979>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
73980>>>                        If iPos Begin
73982>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
73983>>>                            While (Left(sSkinFile,1)=sSep)
73987>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
73988>>>                            Loop
73989>>>>
73989>>>                        End
73989>>>>
73989>>>                    End
73989>>>>
73989>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
73990>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
73991>>>                    
73991>>>                    Increment iArrayItem
73992>>>                Loop
73993>>>>
73993>>>            Loop
73994>>>>
73994>>>            
73994>>>            Send Destroy of hSkinDescriptions
73995>>>            Send Destroy of hSkinDescription
73996>>>            Send Destroy of hSkinIniFile
73997>>>            
73997>>>        End
73997>>>>
73997>>>        Function_Return Skins
73998>>>    End_Function
73999>>>    
73999>>>    // Save the skin preference. This requires an application object.
73999>>>    // Only do this if the application object allows it.
73999>>>    // This is called during startup if pbLoadPreference is True
73999>>>    // Suitable for override
73999>>>    Procedure SaveSkinPreference
74001>>>        String sSkin sIni
74001>>>        If ghoApplication Begin
74003>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74005>>>                Get psSkinFile to sSkin
74006>>>                Get psSkinIni to sIni
74007>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
74008>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
74009>>>            End
74009>>>>
74009>>>        End
74009>>>>
74009>>>        Else Begin
74010>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74011>>>>
74011>>>        End
74011>>>>
74011>>>    End_Procedure
74012>>>    
74012>>>    // Load the skin preference. This requires an application object.
74012>>>    // Only do this if the application object allows it.
74012>>>    // This is called during startup if pbLoadPreference is True
74012>>>    // Suitable for override
74012>>>    Procedure LoadSkinPreference
74014>>>        String sSkin sIni
74014>>>        Boolean bExists
74014>>>        If ghoApplication Begin
74016>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74018>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
74019>>>                If bExists Begin
74021>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
74022>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
74023>>>                    Set psSkinFile to sSkin
74024>>>                    Set psSkinIni to sIni
74025>>>                End
74025>>>>
74025>>>            End
74025>>>>
74025>>>        End
74025>>>>
74025>>>        Else Begin
74026>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74027>>>>
74027>>>        End
74027>>>>
74027>>>    End_Procedure
74028>>>    
74028>>>    // Can be called to apply the current skin.
74028>>>    Procedure ApplySkin
74030>>>        Boolean bOk
74030>>>        String sSkin sIni
74030>>>        If (IsComObjectCreated(Self)) Begin
74032>>>            Get SkinQFile to sSkin
74033>>>            Get psSkinIni to sIni
74034>>>            
74034>>>            Send NotifyPreApplySkin
74035>>>            // when skins are used we don't want to use built in Visual Styles
74035>>>            Send EnableVisualStyles of Desktop (sSkin="")
74036>>>            Get ComLoadSkin sSkin sIni to bOK
74037>>>            If (sSkin<>"" and not(bOk)) Begin
74039>>>                // if not ok, no skin was appied. Enable visual styles
74039>>>                Send EnableVisualStyles of Desktop True
74040>>>            End
74040>>>>
74040>>>            Send NotifyPostApplySkin
74041>>>        End
74041>>>>
74041>>>    End_Procedure
74042>>>    
74042>>>    
74042>>>End_Class
74043>Use cDbUpdateHandler.pkg
Including file: cDbUpdateHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.pkg)
74043>>>//****************************************************************************
74043>>>// $Module type: Class
74043>>>// $Module name: cDbUpdateHandler
74043>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
74043>>>// Web-site    : http://www.rdctools.com
74043>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
74043>>>//
74043>>>// Purpose     : A framework for doing automated code based updates of a database from within
74043>>>//               a program, when it is started.
74043>>>//
74043>>>// Description : Place _one_ object of this class right after the cApplication object.
74043>>>//               Then inside this object place a series of cDbUpdateVersion objects
74043>>>//               as childs. One child object for each new database update.
74043>>>//
74043>>>//               - OnPreUpdate is a pre-processing event called
74043>>>//               before any database changes are started.
74043>>>//               - OnPostUpdate is a post-processing event called after all
74043>>>//               database changes have taken place.
74043>>>//
74043>>>// Note        : If tables have been opened prior to an object of this class
74043>>>//               (e.g. in the cApplication object), those tables will be closed.
74043>>>//               In that case you need to use the OnPostUpdate hook event to re-open
74043>>>//               tables after the last update has finished.
74043>>>//
74043>>>// Security    : Before an update is attempted; three things are checked to ensure the
74043>>>//               database is not in use. Aka nobody else is running the application.
74043>>>//               - All tables are tested for "Open in Exclusive_Mode"
74043>>>//               - The DataFlex license User Count is checked - cannot be more than 1, unless the
74043>>>//                 pbCheckDataFlexUserCount is set to False (Default = True)
74043>>>//               - A special user count file ("DbUpdateUserCount.ucf") is created in the Programs
74043>>>//                 folder and a bit-lock is performed for each start of the application and this
74043>>>//                 user counter is checked before an update is attempted.
74043>>>//                 Important: Even if it seems like both garters & suspenders are used to guard
74043>>>//                            against the database being "in use", there is no such guarantee! The
74043>>>//                            database could e.g. be open in "Microsoft SQL Server Management Studio"
74043>>>//                            and there is no way of telling. SO BE CAUTIOUS before attempting an update!
74043>>>//                 A second "user count file" is also used - "DbUpdateLock.ucf". It is used to
74043>>>//                 lock everybody else out (with a Stop box) while the database is being updated. The lock will
74043>>>//                 automatically be released after the update is completed.
74043>>>//
74043>>>//
74043>>>// Usage       :  Use cDbUpdateHandler.pkg
74043>>>//                Object oDatabaseUpdateHandler is a cDbUpdateHandler
74043>>>//                    // Declare the table that contains a "database version" field.
74043>>>//                    Declare_Datafile Sys
74043>>>//                    // Either one of these syntaxes is fine:
74043>>>//                    Set Data_File_Field to File_Field Sys.DbUpdateVersion
74043>>>//                    Set Data_File_Field to (RefTable(Sys)) (RefTable(Sys.DbUpdateVersion))
74043>>>//
74043>>>//                    // Don't forget to increase the pnVersionNumber property for each
74043>>>//                    // cDbUpdateVersion object!
74043>>>//                    // The VersionTableColumn field/column specified above will be updated automatically
74043>>>//                    // with the value of pnVersionNumber after each update has been finished.
74043>>>//                    Object oVersionUpdate1.1 is a cDbUpdateVersion
74043>>>//                        Set pnVersionNumber to 1.1
74043>>>//                        Use VersionUpdate1_1.pkg
74043>>>//                    End_Object
74043>>>//
74043>>>//                    Object oVersionUpdate1.2 is a cDbUpdateVersion
74043>>>//                        Set pnVersionNumber to 1.2
74043>>>//                        Use VersionUpdate1_2.pkg
74043>>>//                    End_Object
74043>>>//
74043>>>//                End_Object
74043>>>//
74043>>>//
74043>>>// $Rev History:
74043>>>//    2016-09-27  Module header created
74043>>>//    2016-09-28  Removed the Master/Alias logic. All update code must
74043>>>//                take place before any tables have been opened, or errors
74043>>>//                could occur if the client database is out of sync with the
74043>>>//                compiled program.
74043>>>//                Added user counting checks + lockout while database is being
74043>>>//                updated.
74043>>>//    2016-10-03  Changed the class name from cDatabaseUpdateHandler to cDbUpdateHandler,
74043>>>//                as it is more in line with the child class cDbUpdateVersion name.
74043>>>//    2016-10-06  Moved constant declarations, structs etc. to separate cDbUpdateHandler.inc file
74043>>>//****************************************************************************
74043>>>Use VdfBase.pkg
74043>>>Use Dferror.pkg
74043>>>Use seq_chnl.pkg
74043>>>Use Datadict.pkg
74043>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
74043>>>>>// *** The Database Update Framework Include file for Languages ***
74043>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
74043>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
74043>>>>>//
74043>>>>>Use LanguageText.Pkg
74043>>>>>
74043>>>>>    // *** cSQLConnectionsIniFile.pkg Class Language Constants ***
74043>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
74043>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
74043>>>>>    // *** cSQLConnectionsHandler.pkg Class Language Constants ***
74043>>>>>    Define CS_DUF_SetupErrorcConnection     for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
74043>>>>>    Define CS_DUF_CannotLoginToServer       for "Could not login to the database server. Can't continue. Program will now exit."
74043>>>>>    Define CS_DUF_ErrorText                 for "\n\nError Text:"
74043>>>>>    // *** cDbUpdateFunctionLibrary.pkg Class Language Constants ***
74043>>>>>    Define CS_DUF_ConnectError              for "SQL error. Could not connect to the SQL database manager"
74043>>>>>    Define CS_DUF_AttachError               for "Could not attach to the database:"
74043>>>>>    Define CS_DUF_DeletingIndex             for "Deleting index"
74043>>>>>    Define CS_DUF_CopyingData               for "Copying data"
74043>>>>>    Define CS_DUF_CreatingIndex             for "Creating index"
74043>>>>>    Define CS_DUF_LoginToDbServerFailed     for  "Login failed to the database server. The following connect string was used:\n"
74043>>>>>    Define CS_DUF_DoYouWantToExit           for "Do you want to stop the database update and exit?"  
74043>>>>>    Define CS_DUF_NoIntFilesFound           for "No .int files found! Nothing was changed."
74043>>>>>    // *** cDbUpdateVersion.pkg Class Language Constants ***
74043>>>>>    Define CS_DUF_UpdateVersion             for "Updating database"
74043>>>>>    Define CS_DUF_UpdateFromVersion         for "from version"
74043>>>>>    Define CS_DUF_UpdateToVersion           for "to version:"
74043>>>>>    Define CS_DUF_DbUpdateTableMissing      for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
74043>>>>>    // *** cDbUpdateHandler.inc Language Constants ***
74043>>>>>    Define CS_DUF_DatabaseInUseShort        for "There are others using the application/database. Are you sure you still want to update the database?"
74043>>>>>    Define CS_DUF_DatabaseNeedsUpdate       for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
74043>>>>>    Define CS_DUF_HeaderUpdateText          for "Important!"
74043>>>>>    Define CS_DUF_DatabaseInUseText         for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
74043>>>>>    Define CS_DUF_WorkingHeaderText         for "Working!"
74043>>>>>    Define CS_DUF_WorkingUpdateText         for "The database is being updated. Please wait..."
74043>>>>>    Define CS_DUF_DatabaseUpdatedText       for "Ready! The database was updated."
74043>>>>>    Define CS_DUF_DatabaseCheckedText       for "Ready! The database was checked but no updates was needed."
74043>>>>>    Define CS_DUF_DbUpdatedErrorText        for "One or more errors occured while the database was updated. Please check the logfile.\n\nThe program will now close."
74043>>>>>    Define CS_DUF_UpdateInProgressTxt       for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
74043>>>>>    // *** cDbUpdateHandler.pkg Class Language Constants ***
74043>>>>>    Define CS_DUF_DatabaseConnStringSpec    for "The database specified in the connection string: '"
74043>>>>>    Define CS_DUF_DatabaseDoesntExist       for "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit."
74043>>>>>    // *** cDbUpdateLogFile.pkg Class Language Constants ***   
74043>>>>>    Define CS_DUF_LogFileNotFound           for "Could not locate the log file:\n\n"
74043>>>>>
74043>>>>>
74043>>>>>
74043>>>>>
74043>>>>>
74043>>>>>
74043>>>>>
74043>>>>>
74043>>>>>
74043>>>>>
74043>>>>>
74043>>>>>
74043>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
74043>>>>>// StatPnl.pkg - creates the standard status_panel object.
74043>>>>>//
74043>>>>>//
74043>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
74043>>>>>// invoke the standard status panel. The standard has always been that the package name
74043>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
74043>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
74043>>>>>// prior revisions has been replace with status panel that is part of the application.
74043>>>>>// This should work much better and faster than the old sentinel based solution.
74043>>>>>// While the way this operates has changed, the interface has not and therefore this should work
74043>>>>>// with most applications.
74043>>>>>//
74043>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
74043>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
74043>>>>>// a cleaner more robust interface.
74043>>>>>//
74043>>>>>//
74043>>>>>// Compatibility Note:
74043>>>>>//
74043>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
74043>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
74043>>>>>//
74043>>>>>// If for some reason you application will not work using this as a replacement for the old status
74043>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
74043>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
74043>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
74043>>>>>//
74043>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
74043>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
74043>>>>>//
74043>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
74043>>>>>// can still access the new object via the ghoStatusPanel handle.
74043>>>>>//
74043>>>>>//
74043>>>>>// Creating your own Status Panel objects
74043>>>>>//
74043>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
74043>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
74043>>>>>// with a different file and object name and direct your status panel request to the new object.
74043>>>>>//
74043>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
74043>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
74043>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
74043>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
74043>>>>>// e.g.
74043>>>>>//       Procedure UpdateStatusBar
74043>>>>>//           Send DoAdvance of oProgressBar
74043>>>>>//           Send ProcessEvents
74043>>>>>//       End_Procedure
74043>>>>>//
74043>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
74043>>>>>// messages this will be done for you.
74043>>>>>//
74043>>>>>// the standard Interface for status panels are:
74043>>>>>//
74043>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
74043>>>>>// Send Start_StatusPanel      - start the status panel
74043>>>>>// Send Stop_StatusPanel       - stop the status panel
74043>>>>>// Send Update_StatusPanel     - update the status panel's action area
74043>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
74043>>>>>//
74043>>>>>// Get/Set Caption_Text - updates the caption bar
74043>>>>>// Get/Set Title_Text   - updates the title area
74043>>>>>// Get/Set Message_Text - updates the Message area
74043>>>>>// Get/Set Action_Text  - updates the action area
74043>>>>>// Get/Set Button_Text  - updates the button area
74043>>>>>//
74043>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
74043>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
74043>>>>>//
74043>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
74043>>>>>Use cProcessStatusPanel.pkg
74043>>>>>Use cCJSkinFramework.pkg
74043>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cProgressBar.pkg)
74043>>>>>>>Use Windows.pkg
74043>>>>>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cWinControl.pkg)
74043>>>>>>>>>Use Windows.pkg
74043>>>>>>>>>
74043>>>>>>>>>// Key State Masks for Mouse Messages
74043>>>>>>>>>
74043>>>>>>>>>Define MK_LBUTTON  for |CI$0001
74043>>>>>>>>>Define MK_RBUTTON  for |CI$0002
74043>>>>>>>>>Define MK_SHIFT    for |CI$0004
74043>>>>>>>>>Define MK_CONTROL  for |CI$0008
74043>>>>>>>>>Define MK_MBUTTON  for |CI$0010
74043>>>>>>>>>Define MK_XBUTTON1 for |CI$0020
74043>>>>>>>>>Define MK_XBUTTON2 for |CI$0040
74043>>>>>>>>>
74043>>>>>>>>>Enum_List // Mouse Key Flags
74043>>>>>>>>>    Define mkLeft    for MK_LBUTTON
74043>>>>>>>>>    Define mkMiddle  for MK_MBUTTON
74043>>>>>>>>>    Define mkRight   for MK_RBUTTON
74043>>>>>>>>>    Define mkX1      for MK_XBUTTON1
74043>>>>>>>>>    Define mkX2      for MK_XBUTTON2
74043>>>>>>>>>    Define mkShift   for MK_SHIFT
74043>>>>>>>>>    Define mkControl for MK_CONTROL
74043>>>>>>>>>End_Enum_List
74043>>>>>>>>>
74043>>>>>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
74043>>>>>>>>>    Define mbLeft
74043>>>>>>>>>    Define mbMiddle
74043>>>>>>>>>    Define mbRight
74043>>>>>>>>>    Define mbX1
74043>>>>>>>>>    Define mbX2
74043>>>>>>>>>End_Enum_List
74043>>>>>>>>>
74043>>>>>>>>>Class cWinControl is a DfBaseControl
74044>>>>>>>>>    Procedure Construct_Object
74046>>>>>>>>>        Forward Send Construct_Object
74048>>>>>>>>>        Property Integer private_pbEnabled True
74049>>>>>>>>>        Property Integer private_pbVisible True
74050>>>>>>>>>    End_Procedure
74051>>>>>>>>>    
74051>>>>>>>>>    Procedure End_Construct_Object
74053>>>>>>>>>        Forward Send End_Construct_Object
74055>>>>>>>>>        
74055>>>>>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
74056>>>>>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
74057>>>>>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
74058>>>>>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
74059>>>>>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
74060>>>>>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
74061>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
74062>>>>>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
74063>>>>>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
74064>>>>>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
74065>>>>>>>>>    End_Procedure
74066>>>>>>>>>    
74066>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
74068>>>>>>>>>        //Intentionally cancelled
74068>>>>>>>>>    End_Procedure
74069>>>>>>>>>    
74069>>>>>>>>>    Procedure Command Longptr wParam Longptr lParam
74071>>>>>>>>>        //Intentionally cancelled
74071>>>>>>>>>    End_Procedure
74072>>>>>>>>>    
74072>>>>>>>>>    Procedure DoRecreateWindow
74074>>>>>>>>>        // Recreates the window
74074>>>>>>>>>        If (Window_Handle(Self)) Begin
74076>>>>>>>>>            // attempt to do this without disturbing the focus tree.
74076>>>>>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
74077>>>>>>>>>            Send Page 1      //                       Send Page_Object 1
74078>>>>>>>>>        End
74078>>>>>>>>>>
74078>>>>>>>>>    End_Procedure
74079>>>>>>>>>    
74079>>>>>>>>>    Procedure DoUpdateWindow
74081>>>>>>>>>        // Forces windows to update the window by bypassing WM_PAINT
74081>>>>>>>>>        Handle hWnd
74081>>>>>>>>>        
74081>>>>>>>>>        Get Window_Handle to hWnd
74082>>>>>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
74085>>>>>>>>>    End_Procedure
74086>>>>>>>>>    
74086>>>>>>>>>    Procedure Page Integer iState
74088>>>>>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
74089>>>>>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
74090>>>>>>>>>        Forward Send Page iState
74092>>>>>>>>>    End_Procedure
74093>>>>>>>>>    
74093>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
74095>>>>>>>>>        Integer x y eButton
74095>>>>>>>>>        
74095>>>>>>>>>        Move (Hi(lParam))  to y
74096>>>>>>>>>        Move (Low(lParam)) to x
74097>>>>>>>>>        
74097>>>>>>>>>        Send OnMouseUp mbLeft x y wParam
74098>>>>>>>>>    End_Procedure
74099>>>>>>>>>    
74099>>>>>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
74101>>>>>>>>>        Integer x y eButton
74101>>>>>>>>>        
74101>>>>>>>>>        Move (Hi(lParam))  to y
74102>>>>>>>>>        Move (Low(lParam)) to x
74103>>>>>>>>>        
74103>>>>>>>>>        Send OnMouseUp mbMiddle x y wParam
74104>>>>>>>>>    End_Procedure
74105>>>>>>>>>    
74105>>>>>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
74107>>>>>>>>>        Integer x y eButton
74107>>>>>>>>>        
74107>>>>>>>>>        Move (Hi(lParam))  to y
74108>>>>>>>>>        Move (Low(lParam)) to x
74109>>>>>>>>>        
74109>>>>>>>>>        Send OnMouseUp mbRight x y wParam
74110>>>>>>>>>    End_Procedure
74111>>>>>>>>>    
74111>>>>>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
74113>>>>>>>>>        Integer x y eButton fKeys
74113>>>>>>>>>        
74113>>>>>>>>>        Move (Hi(lParam))  to y
74114>>>>>>>>>        Move (Low(lParam)) to x
74115>>>>>>>>>        
74115>>>>>>>>>        Send OnMouseDown mbLeft x y wParam
74116>>>>>>>>>    End_Procedure
74117>>>>>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
74119>>>>>>>>>        Integer x y eButton
74119>>>>>>>>>        
74119>>>>>>>>>        Move (Hi(lParam))  to y
74120>>>>>>>>>        Move (Low(lParam)) to x
74121>>>>>>>>>        
74121>>>>>>>>>        Send OnMouseDown mbMiddle x y wParam
74122>>>>>>>>>    End_Procedure
74123>>>>>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
74125>>>>>>>>>        Integer x y eButton
74125>>>>>>>>>        
74125>>>>>>>>>        Move (Hi(lParam))  to y
74126>>>>>>>>>        Move (Low(lParam)) to x
74127>>>>>>>>>        
74127>>>>>>>>>        Send OnMouseDown mbRight x y wParam
74128>>>>>>>>>    End_Procedure
74129>>>>>>>>>    
74129>>>>>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
74131>>>>>>>>>        Integer x y eButton
74131>>>>>>>>>        
74131>>>>>>>>>        Move (Hi(lParam))  to y
74132>>>>>>>>>        Move (Low(lParam)) to x
74133>>>>>>>>>        
74133>>>>>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
74134>>>>>>>>>    End_Procedure
74135>>>>>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
74137>>>>>>>>>        Integer x y eButton
74137>>>>>>>>>        
74137>>>>>>>>>        Move (Hi(lParam))  to y
74138>>>>>>>>>        Move (Low(lParam)) to x
74139>>>>>>>>>        
74139>>>>>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
74140>>>>>>>>>    End_Procedure
74141>>>>>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
74143>>>>>>>>>        Integer x y eButton
74143>>>>>>>>>        
74143>>>>>>>>>        Move (Hi(lParam))  to y
74144>>>>>>>>>        Move (Low(lParam)) to x
74145>>>>>>>>>        
74145>>>>>>>>>        Send OnMouseDoubleClick mbRight x y wParam
74146>>>>>>>>>    End_Procedure
74147>>>>>>>>>    
74147>>>>>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
74149>>>>>>>>>        Integer x y eButton
74149>>>>>>>>>        
74149>>>>>>>>>        Move (Hi(lParam))  to y
74150>>>>>>>>>        Move (Low(lParam)) to x
74151>>>>>>>>>        
74151>>>>>>>>>        Send OnMouseMove x y wParam
74152>>>>>>>>>    End_Procedure
74153>>>>>>>>>    
74153>>>>>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
74155>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74155>>>>>>>>>        //String sButton
74155>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74155>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74155>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74155>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74155>>>>>>>>>        
74155>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74155>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74155>>>>>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74155>>>>>>>>>    End_Procedure
74156>>>>>>>>>    
74156>>>>>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
74158>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74158>>>>>>>>>        //String sButton
74158>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74158>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74158>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74158>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74158>>>>>>>>>        
74158>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74158>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74158>>>>>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74158>>>>>>>>>    End_Procedure
74159>>>>>>>>>    
74159>>>>>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
74161>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74161>>>>>>>>>        //String sButton
74161>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74161>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74161>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74161>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74161>>>>>>>>>        
74161>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74161>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74161>>>>>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74161>>>>>>>>>    End_Procedure
74162>>>>>>>>>    
74162>>>>>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
74164>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74164>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74164>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74164>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74164>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74164>>>>>>>>>        
74164>>>>>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74164>>>>>>>>>    End_Procedure
74165>>>>>>>>>    
74165>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
74167>>>>>>>>>        Handle hWnd
74167>>>>>>>>>        
74167>>>>>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
74169>>>>>>>>>            Set private_pbEnabled to bEnabled
74170>>>>>>>>>            Get Window_Handle to hWnd
74171>>>>>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
74174>>>>>>>>>        End
74174>>>>>>>>>>
74174>>>>>>>>>    End_Procedure
74175>>>>>>>>>    Function pbEnabled Returns Boolean
74177>>>>>>>>>        Function_Return (private_pbEnabled(Self))
74178>>>>>>>>>    End_Function
74179>>>>>>>>>    
74179>>>>>>>>>    Procedure Set pbVisible Boolean bVisible
74181>>>>>>>>>        Handle  hWnd
74181>>>>>>>>>        Integer iVoid
74181>>>>>>>>>        
74181>>>>>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
74183>>>>>>>>>            Set private_pbVisible to bVisible
74184>>>>>>>>>            Get Window_Handle to hWnd
74185>>>>>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
74188>>>>>>>>>        End
74188>>>>>>>>>>
74188>>>>>>>>>    End_Procedure
74189>>>>>>>>>    Function pbVisible Returns Boolean
74191>>>>>>>>>        Function_Return (private_pbVisible(Self))
74192>>>>>>>>>    End_Function
74193>>>>>>>>>    
74193>>>>>>>>>End_Class
74194>>>>>>>Use CommCtrl.pkg
74194>>>>>>>
74194>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
74194>>>>>>>Class cProgressBar is a cWinControl
74195>>>>>>>    
74195>>>>>>>    Procedure Construct_Object
74197>>>>>>>        Forward Send Construct_Object
74199>>>>>>>        Property Integer private_piMinimum
74200>>>>>>>        Property Integer private_piMaximum   100
74201>>>>>>>        Property Integer private_piAdvanceBy 10
74202>>>>>>>        Property Integer private_piPosition
74203>>>>>>>        Property Integer private_pbVertical  False
74204>>>>>>>        Property Integer private_pbSmooth    False
74205>>>>>>>        Property Integer private_piBackColor clDefault
74206>>>>>>>        Property Integer private_piBarColor  clDefault
74207>>>>>>>        
74207>>>>>>>        Send Define_ToolTip_Support_Mixin
74208>>>>>>>        
74208>>>>>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
74209>>>>>>>        Set Focus_Mode to NonFocusable
74210>>>>>>>        Set Skip_State to True
74211>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
74212>>>>>>>    End_Procedure
74213>>>>>>>    
74213>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
74214>>>>>>>    
74214>>>>>>>    Procedure Set piMinimum Integer iMin
74216>>>>>>>        Integer iMax
74216>>>>>>>        
74216>>>>>>>        Set private_piMinimum to iMin
74217>>>>>>>        Get private_piMaximum to iMax
74218>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74219>>>>>>>    End_Procedure
74220>>>>>>>    Function piMinimum Returns Integer
74222>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
74225>>>>>>>        Else;            Function_Return (private_piMinimum(Self))
74227>>>>>>>    End_Function
74228>>>>>>>    
74228>>>>>>>    Procedure Set piMaximum Integer iMax
74230>>>>>>>        Integer iMin
74230>>>>>>>        
74230>>>>>>>        Set private_piMaximum to iMax
74231>>>>>>>        Get private_piMinimum to iMin
74232>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74233>>>>>>>    End_Procedure
74234>>>>>>>    Function piMaximum Returns Integer
74236>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
74239>>>>>>>        Else;            Function_Return (private_piMaximum(Self))
74241>>>>>>>    End_Function
74242>>>>>>>    
74242>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
74244>>>>>>>        Set private_piAdvanceBy to iAdvanceBy
74245>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
74246>>>>>>>    End_Procedure
74247>>>>>>>    Function piAdvanceBy Returns Integer
74249>>>>>>>        Function_Return (private_piAdvanceBy(Self))
74250>>>>>>>    End_Function
74251>>>>>>>    
74251>>>>>>>    Procedure Set piPosition Integer iPos
74253>>>>>>>        Set private_piPosition to iPos
74254>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
74255>>>>>>>    End_Procedure
74256>>>>>>>    
74256>>>>>>>    Function piPosition Returns Integer
74258>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
74261>>>>>>>        Else;            Function_Return (private_piPosition(Self))
74263>>>>>>>    End_Function
74264>>>>>>>    
74264>>>>>>>    Procedure Set pbVertical Boolean bVertical
74266>>>>>>>        If (private_pbVertical(Self) <> bVertical) Begin
74268>>>>>>>            Set private_pbVertical to bVertical
74269>>>>>>>            Send DoRecreateWindow
74270>>>>>>>        End
74270>>>>>>>>
74270>>>>>>>    End_Procedure
74271>>>>>>>    
74271>>>>>>>    Function pbVertical Returns Boolean
74273>>>>>>>        Function_Return (private_pbVertical(Self))
74274>>>>>>>    End_Function
74275>>>>>>>    
74275>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
74277>>>>>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
74279>>>>>>>            Set private_pbSmooth to bSmooth
74280>>>>>>>            Send DoRecreateWindow
74281>>>>>>>        End
74281>>>>>>>>
74281>>>>>>>    End_Procedure
74282>>>>>>>    Function pbSmooth Returns Boolean
74284>>>>>>>        Function_Return (private_pbSmooth(Self))
74285>>>>>>>    End_Function
74286>>>>>>>    
74286>>>>>>>    Procedure Set piBackColor Integer rgbColor
74288>>>>>>>        Set private_piBackColor to rgbColor
74289>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
74290>>>>>>>    End_Procedure
74291>>>>>>>    Function piBackColor Returns Integer
74293>>>>>>>        Function_Return (private_piBackColor(Self))
74294>>>>>>>    End_Function
74295>>>>>>>    
74295>>>>>>>    Procedure Set piBarColor Integer rgbColor
74297>>>>>>>        Set private_piBarColor to rgbColor
74298>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
74299>>>>>>>    End_Procedure
74300>>>>>>>    Function piBarColor Returns Integer
74302>>>>>>>        Function_Return (private_piBarColor(Self))
74303>>>>>>>    End_Function
74304>>>>>>>    
74304>>>>>>>    Procedure DoAdvance
74306>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
74307>>>>>>>    End_Procedure
74308>>>>>>>    
74308>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
74310>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
74311>>>>>>>    End_Procedure
74312>>>>>>>    
74312>>>>>>>    Procedure private_DoInitWindow
74314>>>>>>>        Set piBarColor  to (private_piBarColor(Self))
74315>>>>>>>        Set piBackColor to (private_piBackColor(Self))
74316>>>>>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
74317>>>>>>>        Set piMinimum   to (private_piMinimum(Self))
74318>>>>>>>        Set piMaximum   to (private_piMaximum(Self))
74319>>>>>>>        Set piPosition  to (private_piPosition(Self))
74320>>>>>>>    End_Procedure
74321>>>>>>>    
74321>>>>>>>    Procedure Page_Object Integer iState
74323>>>>>>>        Handle hWnd
74323>>>>>>>        
74323>>>>>>>        Get Window_Handle to hWnd
74324>>>>>>>        If (hWnd=0 and iState) Begin
74326>>>>>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
74327>>>>>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
74328>>>>>>>            Forward Send Page_Object True
74330>>>>>>>        End
74330>>>>>>>>
74330>>>>>>>        Else ;            Forward Send Page_Object iState
74333>>>>>>>        
74333>>>>>>>        // Handle tooltip support....
74333>>>>>>>        If (iState = 0) Begin
74335>>>>>>>            Send RequestDeleteToolTip
74336>>>>>>>        End
74336>>>>>>>>
74336>>>>>>>        Else Begin
74337>>>>>>>            Send RequestAddToolTip
74338>>>>>>>        End
74338>>>>>>>>
74338>>>>>>>    End_Procedure
74339>>>>>>>    
74339>>>>>>>    Procedure Page Integer iState
74341>>>>>>>        Forward Send Page iState
74343>>>>>>>        If (iState =1);            Send private_DoInitWindow
74346>>>>>>>    End_Procedure
74347>>>>>>>    
74347>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
74347>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
74347>>>>>>>    // is implemented in a mixin class.
74347>>>>>>>    Procedure RequestAddToolTip
74349>>>>>>>        Send AddToolTip
74350>>>>>>>    End_Procedure
74351>>>>>>>    
74351>>>>>>>    
74351>>>>>>>    // Called by Page_Object. Handles tooltip removal.
74351>>>>>>>    Procedure RequestDeleteToolTip
74353>>>>>>>        Send DeleteToolTip
74354>>>>>>>    End_Procedure
74355>>>>>>>End_Class
74356>>>>>Use Windows.pkg
74356>>>>>Use DUFLanguageConstants.inc
74356>>>>>Use Statpnl.pkg
74356>>>>>
74356>>>>>
74356>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
74356>>>>>
74356>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
74356>>>>>
74356>>>>>Object Status_Panel is a cProcessStatusPanel
74358>>>>>    Set Size to 152 222
74359>>>>>    Set Border_Style to Border_Dialog
74360>>>>>    Set Icon to "Default.ico"
74361>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
74362>>>>>
74362>>>>>    Property Boolean Cancel_Button_Visible_State True
74364>>>>>
74364>>>>>    Procedure Activate
74367>>>>>        Integer iSizeBefore
74367>>>>>        Get GuiSize to iSizeBefore
74368>>>>>        Forward Send Activate
74370>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
74371>>>>>    End_Procedure
74372>>>>>
74372>>>>>    Procedure End_Construct_Object
74375>>>>>        Forward Send End_Construct_Object
74377>>>>>        Set Label of oTitleTxt      to ""
74378>>>>>        Set Label of oTableNameTxt  to ""
74379>>>>>        Set Label of oMessageTxt    to ""
74380>>>>>        Set Label of oActionTxt     to ""
74381>>>>>    End_Procedure
74382>>>>>
74382>>>>>    Object oTitleTxt is a TextBox
74384>>>>>        Set Location to 5 21
74385>>>>>        Set Size to 8 179
74386>>>>>        Set Auto_Size_State to False
74387>>>>>        Set Justification_Mode  to jMode_Center
74388>>>>>        Set Label to "This is the Title Text"
74389>>>>>    End_Object
74390>>>>>
74390>>>>>    Object oTableNameTxt is a TextBox
74392>>>>>        Set Size to 19 204
74393>>>>>        Set Location to 18 9
74394>>>>>        Set Auto_Size_State to False
74395>>>>>        Set Justification_Mode to JMode_Left
74396>>>>>        Set Label to "This is the TableName Text"
74397>>>>>    End_Object
74398>>>>>
74398>>>>>    Object oMessageTxt is a TextBox
74400>>>>>        Set Location to 39 9
74401>>>>>        Set Size to 19 204
74402>>>>>        Set Auto_Size_State to False
74403>>>>>        Set Justification_Mode to JMode_Left
74404>>>>>        Set Label to "This is the Message text"
74405>>>>>    End_Object
74406>>>>>
74406>>>>>    Object oActionTxt is a TextBox
74408>>>>>        Set Size to 16 204
74409>>>>>        Set Location to 60 9
74410>>>>>        Set Auto_Size_State to False
74411>>>>>        Set Justification_Mode to JMode_Left
74412>>>>>        Set Label to "This is the Action Text"
74413>>>>>    End_Object
74414>>>>>
74414>>>>>    Object oStopButton is a Button
74416>>>>>        Set Location to 123 82
74417>>>>>        Set Label to C_$Cancel
74418>>>>>
74418>>>>>        Procedure OnClick 
74421>>>>>            Integer iRetval
74421>>>>>            Get YesNo_Box CS_DUF_DoYouWantToExit to iRetval
74422>>>>>            If (iRetval = MBR_Yes) Begin
74424>>>>>                Send Exit_Application
74425>>>>>            End
74425>>>>>>
74425>>>>>        End_Procedure
74426>>>>>
74426>>>>>    End_Object
74427>>>>>
74427>>>>>    Object oPercentage_tb is a TextBox
74429>>>>>        Set Location to 74 196
74430>>>>>        Set Size to 10 25
74431>>>>>//        Set Label to "% Done"
74431>>>>>    End_Object
74432>>>>>
74432>>>>>    Object oCopyRight is a TextBox
74434>>>>>        Set Location to 140 21
74435>>>>>        Set Size to 9 197
74436>>>>>        Set FontPointHeight to 8
74437>>>>>        Set Auto_Size_State to False
74438>>>>>        Set Justification_Mode  to jMode_Center
74439>>>>>        Set Label to "Copyright 2001-2020 RDC Tools International"
74440>>>>>    End_Object
74441>>>>>
74441>>>>>    Object oProgressBar is a cProgressBar
74443>>>>>        Set Size to 10 179
74444>>>>>        Set Location to 83 22
74445>>>>>        Set pbVisible to True // default
74446>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
74447>>>>>    End_Object
74448>>>>>
74448>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
74451>>>>>        Set pbVisible of ghoProgressBar to bVisible
74452>>>>>    End_Procedure
74453>>>>>
74453>>>>>    Function Progress_Bar_Visible_State Returns Boolean
74456>>>>>        Boolean bVisible
74456>>>>>        Get pbVisible of ghoProgressBar to bVisible
74457>>>>>        Function_Return (bVisible)
74458>>>>>    End_Function
74459>>>>>
74459>>>>>    Object oProgressBarOverall is a cProgressBar
74461>>>>>        Set Size to 10 179
74462>>>>>        Set Location to 107 22
74463>>>>>        Set pbVisible to True // default
74464>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
74465>>>>>    End_Object
74466>>>>>
74466>>>>>    Object oOverallProgress_tb is a TextBox
74468>>>>>        Set Size to 10 65
74469>>>>>        Set Location to 95 24
74470>>>>>        Set Label to "Overall Progress"
74471>>>>>    End_Object
74472>>>>>
74472>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
74475>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
74476>>>>>    End_Procedure
74477>>>>>
74477>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
74480>>>>>        Boolean bVisible
74480>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
74481>>>>>        Function_Return (bVisible)
74482>>>>>    End_Function
74483>>>>>
74483>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
74483>>>>>    // objects defined within this instance of the status panel.
74483>>>>>
74483>>>>>    // note: all of the messages that change text should be forwarded
74483>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
74483>>>>>
74483>>>>>    Procedure Set Message_Text String sText
74486>>>>>        Set Label of oMessageTxt to sText
74487>>>>>        Forward Set Message_Text to sText
74489>>>>>    End_Procedure
74490>>>>>
74490>>>>>    Function Message_Text Returns String
74493>>>>>        Function_Return (Label(oMessageTxt))
74494>>>>>    End_Function
74495>>>>>
74495>>>>>    Procedure Set Action_Text String sText
74498>>>>>        Set Label of oActionTxt to sText
74499>>>>>        Forward Set Action_Text to sText
74501>>>>>    End_Procedure
74502>>>>>
74502>>>>>    Function Action_Text Returns String
74505>>>>>        Function_Return (Label(oActionTxt))
74506>>>>>    End_Function
74507>>>>>
74507>>>>>    Procedure Set Button_Text String sText
74510>>>>>        Set Label of oStopButton to sText
74511>>>>>        Forward Set Button_Text to sText
74513>>>>>    End_Procedure
74514>>>>>
74514>>>>>    Function Button_Text Returns String
74517>>>>>        Function_Return (Label(oStopButton))
74518>>>>>    End_Function
74519>>>>>
74519>>>>>    Procedure Set Title_Text String sText
74522>>>>>        Set Label of oTitleTxt to sText
74523>>>>>        Forward Set Title_Text to sText
74525>>>>>    End_Procedure
74526>>>>>
74526>>>>>    Function Title_Text Returns String
74529>>>>>        Function_Return (Label(oTitleTxt))
74530>>>>>    End_Function
74531>>>>>
74531>>>>>    Procedure Set TableName_Text String sText
74534>>>>>        Set Label of oTableNameTxt to sText
74535>>>>>    End_Procedure
74536>>>>>
74536>>>>>    Function TableName_Text Returns String
74539>>>>>        Function_Return (Label(oTableNameTxt))
74540>>>>>    End_Function
74541>>>>>
74541>>>>>    Procedure Set License_Text String sText
74544>>>>>//        Set Label of oLicense_txt to sText
74544>>>>>    End_Procedure
74545>>>>>
74545>>>>>    // gets called when status panel is activated passing whether a button
74545>>>>>    // should appear
74545>>>>>    Procedure EnableCancelButton Boolean bEnable
74548>>>>>        Boolean bVisible
74548>>>>>        Get Cancel_Button_Visible_State to bVisible
74549>>>>>        If (bEnable = False) Begin
74551>>>>>            Set Visible_State of oStopButton to bVisible
74552>>>>>        End
74552>>>>>>
74552>>>>>        Set Enabled_State of oStopButton to bEnable
74553>>>>>    End_Procedure
74554>>>>>
74554>>>>>    Procedure Reset_StatusPanel
74557>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
74558>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
74559>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
74560>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
74561>>>>>    End_Procedure
74562>>>>>
74562>>>>>//    Object oProgressBar is a cProgressBar
74562>>>>>//        Move Self to ghoProgressBar
74562>>>>>//        Set Location to 1 25
74562>>>>>//        Set Size to 9 173
74562>>>>>//        Set piMinimum        to 0
74562>>>>>//        Set piMaximum        to 2000
74562>>>>>//        Set piAdvanceBy      to 100
74562>>>>>//        Set pbSmooth to True
74562>>>>>//
74562>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
74562>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
74562>>>>>//        // color will show correctly.
74562>>>>>//        Procedure Page Integer iPageObject
74562>>>>>//            Handle hWin
74562>>>>>//            Forward Send Page iPageObject
74562>>>>>//            If (ghoSkinFramework <> 0) Begin
74562>>>>>//                Get Window_Handle to hWin
74562>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
74562>>>>>//            End
74562>>>>>//        End_Procedure
74562>>>>>//    End_Object
74562>>>>>
74562>>>>>End_Object
74563>>>>>
74563>>>Use cDbUpdateHandler.inc // Contains cDbUpdateHandler class constants, structs etc.
Including file: cDbUpdateHandler.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.inc)
74563>>>>>// Constant declarations, structs etc. for the cDbUdpateHandler class.
74563>>>>>//
74563>>>>>Use VdfBase.pkg
74563>>>>>Use cApplication.pkg
74563>>>>>Use seq_chnl.pkg
74563>>>>>Use vWin32fh.pkg
Including file: vWin32fh.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vWin32fh.pkg)
74563>>>>>>>// This code is part of VDF GUIdance
74563>>>>>>>// Visit us @ http://www.vdf-guidance.com
74563>>>>>>>// e-Mail us @ info@vdf-guidance.com
74563>>>>>>>// VDF GUIdance is a mutual project of
74563>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
74563>>>>>>>// Wil van Antwerpen  - Antwise Solutions
74563>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
74563>>>>>>>//
74563>>>>>>>//
74563>>>>>>>// *** Windows 32bit file handling wrapper class ***
74563>>>>>>>//
74563>>>>>>>
74563>>>>>>>// 05-09-2000 **WvA: Changed namingconvention of all classes and methods to new standard
74563>>>>>>>//                   This may be painfull for some of you, but it was really needed as it was
74563>>>>>>>//                   getting messy. The "vs" -prefix we used before was confusing and could
74563>>>>>>>//                   unintentionally have been interpreted as "Vdf-GUIdance String".
74563>>>>>>>//
74563>>>>>>>// The used naming-convention is:
74563>>>>>>>//     - a prefix of "vWin32_" for every external function declaration
74563>>>>>>>//     - a prefix of the letter "v" for the full API name for the vdf-wrapper function.
74563>>>>>>>//
74563>>>>>>>// By using this we are guarding ourselves for conflicts with variable declarations
74563>>>>>>>// of DataAccess in the future.
74563>>>>>>>// Or at least almost as the letter "v" is now also synonym for variant (duh~!)
74563>>>>>>>//
74563>>>>>>>// mm-dd-yyyy Author Description
74563>>>>>>>//
74563>>>>>>>//                   vSHGetFolderPath added to retrieve the new shell folders
74563>>>>>>>//                   vGetWindowsDirectory
74563>>>>>>>//
74563>>>>>>>//                   vGetTempFileName
74563>>>>>>>//                   vGetTempPath
74563>>>>>>>// 11-17-2001 **WvA: Removed User Interface Error popups such as Error handling.
74563>>>>>>>//                   This is an absolute need for WebApp. We expect you to handle the
74563>>>>>>>//                   error in your application anyways. Changed this for:
74563>>>>>>>//                   vDeleteFile, vCopyFile, vMoveFile and vRenameFile
74563>>>>>>>// 03-02-2002 **WvA: vRemoveDirectory added
74563>>>>>>>// 03-11-2002 **WvA: The parameter lpdword in the external function declaration for
74563>>>>>>>//                   vWin32_SHBrowsForFolder can cause compiler errors.
74563>>>>>>>//                   It is renamed too avoid this.
74563>>>>>>>// 11-11-2002 **WvA: Codecleanup, vcSelectFile_Dialog is now cvSelectFile_Dialog, its
74563>>>>>>>//                   function vSelectedFileName is now just SelectedFileName
74563>>>>>>>//                   Removed the local keyword in the variable declarations
74563>>>>>>>// 10-17-2003 **WvA: Cleaned up function vSelect_File and added code to destroy the dynamically
74563>>>>>>>//                   created file-open dialog
74563>>>>>>>// 02-12-2004 **WvA: Allan Ankerstjeme pointed me into a bug for the vCreateTempFileInPath
74563>>>>>>>//                   in that it didn't exactly return the correct filename of the file created.
74563>>>>>>>//                   This has now been taken care of.
74563>>>>>>>// 02-19-2004 **WvA: Removed all API declarations from the package itself to improve readability
74563>>>>>>>//                   These declarations are now included from the vWin32fh header file.
74563>>>>>>>// 02-19-2004 **WvA: Changed the default way in which the standard file handling works
74563>>>>>>>//                   Before today one could always undo the operation, as of now you cannot as
74563>>>>>>>//                   the default was a silly one using unnecessary resources (mainly diskspace)
74563>>>>>>>//                   Since i don't really expect someone to use that feature it has been removed.
74563>>>>>>>//                   One can however restore to the old way of handling by simply calling the
74563>>>>>>>//                   vWin32fhCompatibilityMode procedure ONE time before accessing any of the
74563>>>>>>>//                   filehandling operations
74563>>>>>>>// 02-19-2004 **WvA: The functions ParseFolderName, ParseFileName and ParseFileExtenstion added
74563>>>>>>>//                   as well as the StringFromRightOfChar function.
74563>>>>>>>// 02-19-2004 **WvA: sfoFormatDisk function added which can use to format a floppydisk
74563>>>>>>>//                   DISABLED now as testing shows that it does not work as advertised...
74563>>>>>>>// 02-20-2004 **WvA: The function vDDE_Error_Handler didn't pass the errornumber on to the DDE_Error_To_String function
74563>>>>>>>//                   Moved the hardcoded strings from vDDE_Error_Handler to define declarations for easier translation later on.
74563>>>>>>>// 09-10-2004 **WvA: Added the ToAnsi function to the fileoperations method so that
74563>>>>>>>//                   extended characters are treated ok too.
74563>>>>>>>//                   Reported by Flemming from
74563>>>>>>>// 12-17-2004 **WvA: Changed vFilePathExists to be global, reported by Peter van Mil
74563>>>>>>>// 12-28-2004 **WvA: WebApp compatibility added by introducing compiler directives
74563>>>>>>>// 03-10-2006 **WvA: Added more CSIDL types to our header file for use with the vSHGetFolderPath function
74563>>>>>>>// 01-02-2007 **WvA: Set NoChangeDir_State on vSelect_File and vSelectSaveFile to True but changed it back due to side effects.
74563>>>>>>>//                   Added vSelectSavefile function to create a file save dialog
74563>>>>>>>//                   Fixed ParseFolderName which was horribly broken (thanks for the reports)
74563>>>>>>>//                   Added vParentPath function to retrieve the parent "node" of a path
74563>>>>>>>// 01-04-2008 **WvA: Fixed vCreateTempFileInPath as the function wasn't working
74563>>>>>>>// 10-04-2009 **WvA: Added vshCreateDirectoryEx from Micheal Mullan, moved filedialogs to cvFileDialogs.pkg
74563>>>>>>>// 01-11-2010 **WvA: Added vWin32_APIFilesize as supplied by Renato Villa, to get the filesize of the specified file. See http://support.dataaccess.com/forums/showthread.php?t=41982
74563>>>>>>>// 10-02-2011 **WvA: Added vCSIDL_SYSTEMX86, courtesy of Ola Eldoy for pointing this out and providing the define statement.
74563>>>>>>>// 20-12-2012 **WvA: Default behavior on copy/move is now to autocreate subfolders, tip by Frank Cheng
74563>>>>>>>// 29-09-2014 **WvA: Added function vFolderFileCount to count the number of files in a folder, add vCSIDL_PROGRAM_FILESx86
74563>>>>>>>// 04-10-2014 **WvA: Added extra checks on vFilePathExists and vFolderExists courtesy of Nils Svedmyr
74563>>>>>>>
74563>>>>>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
74563>>>>>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\cvFileDialogs.pkg)
74563>>>>>>>>>//***************************************************************************
74563>>>>>>>>>//*
74563>>>>>>>>>//* Class:        cvSaveAsDialog
74563>>>>>>>>>//* Package Name: cvFileDialogs.pkg
74563>>>>>>>>>//*
74563>>>>>>>>>//***************************************************************************
74563>>>>>>>>>
74563>>>>>>>>>Use File_dlg.pkg
74563>>>>>>>>>
74563>>>>>>>>>// *WvA: 13-01-1999 Created
74563>>>>>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
74563>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
74563>>>>>>>>>// file_name.
74563>>>>>>>>>Class cvSelectFile_Dialog is an OpenDialog
74564>>>>>>>>>
74564>>>>>>>>>    Procedure Construct_Object Integer iImage_Id
74566>>>>>>>>>        Forward Send Construct_Object iImage_Id
74568>>>>>>>>>        Set HideReadOnly_State to True
74569>>>>>>>>>    End_Procedure
74570>>>>>>>>>
74570>>>>>>>>>    Function SelectedFileName Returns String
74572>>>>>>>>>        String sFileName
74572>>>>>>>>>        Move "" to sFileName
74573>>>>>>>>>        If (Show_Dialog(Self)) Begin
74575>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
74576>>>>>>>>>        End
74576>>>>>>>>>>
74576>>>>>>>>>        Function_Return sFileName
74577>>>>>>>>>    End_Function
74578>>>>>>>>>End_Class
74579>>>>>>>>>
74579>>>>>>>>>// *WvA: 13-01-1999 Created
74579>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
74579>>>>>>>>>// file_name. Returns '' if the user didn't make a selection.
74579>>>>>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
74579>>>>>>>>>//                   file-open dialog
74579>>>>>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
74581>>>>>>>>>    String sSelectedFile
74581>>>>>>>>>    Integer hoOpenFileDialog
74581>>>>>>>>>
74581>>>>>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
74583>>>>>>>>>
74583>>>>>>>>>        Set Dialog_Caption    to sCaptionText
74584>>>>>>>>>        Set Filter_String     to sSupportedFileTypes
74585>>>>>>>>>        Set Initial_Folder    to sInitialFolder
74586>>>>>>>>>
74586>>>>>>>>>        Move Self       to hoOpenFileDialog
74587>>>>>>>>>    End_Object
74588>>>>>>>>>
74588>>>>>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
74589>>>>>>>>>    Send Destroy_Object to hoOpenFileDialog
74590>>>>>>>>>    Function_Return sSelectedFile
74591>>>>>>>>>End_Function
74592>>>>>>>>>
74592>>>>>>>>>Class cvSaveAsDialog is a SaveAsDialog
74593>>>>>>>>>
74593>>>>>>>>>    Procedure Construct_Object
74595>>>>>>>>>        Forward Send Construct_Object
74597>>>>>>>>>        Set HideReadOnly_State to True
74598>>>>>>>>>    End_Procedure
74599>>>>>>>>>
74599>>>>>>>>>    Function SelectedFileName Returns String
74601>>>>>>>>>        String sFileName
74601>>>>>>>>>        Move "" to sFileName
74602>>>>>>>>>        If (Show_Dialog(Self)) Begin
74604>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
74605>>>>>>>>>        End
74605>>>>>>>>>>
74605>>>>>>>>>        Function_Return sFileName
74606>>>>>>>>>    End_Function
74607>>>>>>>>>
74607>>>>>>>>>End_Class
74608>>>>>>>>>
74608>>>>>>>>>// Added optional default filename as suggested by Nils
74608>>>>>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
74610>>>>>>>>>    String sSelectedFile
74610>>>>>>>>>    Integer hoDialog
74610>>>>>>>>>
74610>>>>>>>>>    Move "" to sSelectedFile
74611>>>>>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
74612>>>>>>>>>    If (hoDialog) Begin
74614>>>>>>>>>    //Set NoChangeDir_State Of hoDialog To True
74614>>>>>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
74615>>>>>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
74616>>>>>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
74617>>>>>>>>>        If (Num_Arguments = 4) Begin
74619>>>>>>>>>            Set File_Title        of hoDialog to sDefaultFileName
74620>>>>>>>>>        End
74620>>>>>>>>>>
74620>>>>>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
74621>>>>>>>>>        Send Destroy of hoDialog
74622>>>>>>>>>    End
74622>>>>>>>>>>
74622>>>>>>>>>    Function_Return sSelectedFile
74623>>>>>>>>>End_Function
74624>>>>>>>Use Seq_chnl.pkg
74624>>>>>>>
74624>>>>>>>Use windows.pkg
74624>>>>>>>Use Dll.pkg
74624>>>>>>>Use vWin32fh.h       // Header file with WinAPI declarations
Including file: vwin32fh.h    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fh.h)
74624>>>>>>>>>//TH-Header
74624>>>>>>>>>//*****************************************************************************************
74624>>>>>>>>>// Copyright (c)  2004 KURANT Project
74624>>>>>>>>>// All rights reserved.
74624>>>>>>>>>//
74624>>>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
74624>>>>>>>>>// $ProjectName : Windows 32 bits file handling
74624>>>>>>>>>// $Authors     : Wil van Antwerpen
74624>>>>>>>>>// $Created     : 19.02.2004  19:25
74624>>>>>>>>>// $Type        : BSD (as in do with it whatever you like)
74624>>>>>>>>>//
74624>>>>>>>>>// Contents:
74624>>>>>>>>>//  This file contains the Windows API external function call definitions and
74624>>>>>>>>>//  constants as they are used in the vWin32fh package.
74624>>>>>>>>>//*****************************************************************************************
74624>>>>>>>>>//TH-RevisionStart
74624>>>>>>>>>//TH-RevisionEnd
74624>>>>>>>>>
74624>>>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
74624>>>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
74624>>>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
74624>>>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
74624>>>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
74624>>>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
74624>>>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
74624>>>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
74624>>>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
74624>>>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
74624>>>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
74624>>>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
74624>>>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
74624>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
74624>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
74624>>>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
74624>>>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
74624>>>>>>>>>
74624>>>>>>>>>
74624>>>>>>>>>Define vMax_Path     For |CI260
74624>>>>>>>>>Define vMinChar      For |CI$80
74624>>>>>>>>>Define vMaxChar      For |CI$7F
74624>>>>>>>>>Define vMinShort     For |CI$8000
74624>>>>>>>>>Define vMaxShort     For |CI$7FFF
74624>>>>>>>>>Define vMinLong      For |CI$80000000
74624>>>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
74624>>>>>>>>>Define vMaxByte      For |CI$FF
74624>>>>>>>>>Define vMaxWord      For |CI$FFFF
74624>>>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
74624>>>>>>>>>
74624>>>>>>>>>
74624>>>>>>>>>
74624>>>>>>>>>// For FindFirstFile
74624>>>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
74624>>>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
74624>>>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
74624>>>>>>>>>
74624>>>>>>>>>// The defines below can be used to find out what kind of error has occurred if
74624>>>>>>>>>// the API-call ShellExecute is used.
74624>>>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
74624>>>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
74624>>>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
74624>>>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
74624>>>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
74624>>>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
74624>>>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
74624>>>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
74624>>>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
74624>>>>>>>>>Define vSE_ERR_FNF             For |CI0002
74624>>>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
74624>>>>>>>>>Define vSE_ERR_OOM             For |CI0008
74624>>>>>>>>>Define vSE_ERR_PNF             For |CI0003
74624>>>>>>>>>Define vSE_ERR_SHARE           For |CI0026
74624>>>>>>>>>
74624>>>>>>>>>
74624>>>>>>>>>// C-Structure
74624>>>>>>>>>//typedef struct _browseinfo {
74624>>>>>>>>>//    HWND hwndOwner;
74624>>>>>>>>>//    LPCITEMIDLIST pidlRoot;
74624>>>>>>>>>//    LPSTR pszDisplayName;
74624>>>>>>>>>//    LPCSTR lpszTitle;
74624>>>>>>>>>//    UINT ulFlags;
74624>>>>>>>>>//    BFFCALLBACK lpfn;
74624>>>>>>>>>//    LPARAM lParam;
74624>>>>>>>>>//    int iImage;
74624>>>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
74624>>>>>>>>>
74624>>>>>>>>>//declare C structure struct_browseinfo
74624>>>>>>>>>//as documented in MSDN under Windows Shell API
74624>>>>>>>>>Struct tvBrowseInfo
74624>>>>>>>>>  Handle    hWndOwner
74624>>>>>>>>>  Pointer   pIDLRoot
74624>>>>>>>>>  Pointer   pszDisplayName
74624>>>>>>>>>  Pointer   lpszTitle
74624>>>>>>>>>  dWord     ulFlags
74624>>>>>>>>>  Pointer   lpfnCallback
74624>>>>>>>>>  dWord     lParam
74624>>>>>>>>>  DWord     iImage
74624>>>>>>>>>End_Struct // tvBrowseInfo
74624>>>>>>>>>
74624>>>>>>>>>// Browsing for directory.
74624>>>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
74624>>>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
74624>>>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
74624>>>>>>>>>                                            // The callback function can set the status text by
74624>>>>>>>>>                                            // sending messages to the dialog box.
74624>>>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
74624>>>>>>>>>
74624>>>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
74624>>>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
74624>>>>>>>>>
74624>>>>>>>>>// message from browser
74624>>>>>>>>>//Define BFFM_INITIALIZED        1
74624>>>>>>>>>//Define BFFM_SELCHANGED         2
74624>>>>>>>>>
74624>>>>>>>>>// messages to browser
74624>>>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
74624>>>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
74624>>>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
74624>>>>>>>>>
74624>>>>>>>>>
74624>>>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolder" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
74625>>>>>>>>>
74625>>>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDList" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
74626>>>>>>>>>
74626>>>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
74627>>>>>>>>>
74627>>>>>>>>>
74627>>>>>>>>>
74627>>>>>>>>>
74627>>>>>>>>>Struct tvSecurity_attributes
74627>>>>>>>>>  DWord   nLength
74627>>>>>>>>>  Pointer lpDescriptor
74627>>>>>>>>>  Integer bInheritHandle
74627>>>>>>>>>End_Struct // tvSecurity_attributes
74627>>>>>>>>>
74627>>>>>>>>>//nLength:
74627>>>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
74627>>>>>>>>>// SECURITY_ATTRIBUTES structure.
74627>>>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
74627>>>>>>>>>// value of the nLength member. However, an application should still set it properly.
74627>>>>>>>>>// That ensures current, future, and cross-platform compatibility.
74627>>>>>>>>>//
74627>>>>>>>>>//lpSecurityDescriptor:
74627>>>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
74627>>>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
74627>>>>>>>>>// descriptor of the calling process.
74627>>>>>>>>>//
74627>>>>>>>>>//bInheritHandle:
74627>>>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
74627>>>>>>>>>// If this member is TRUE, the new process inherits the handle.
74627>>>>>>>>>
74627>>>>>>>>>
74627>>>>>>>>>// BOOL CreateDirectory(
74627>>>>>>>>>//    LPCTSTR lpPathName,
74627>>>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
74627>>>>>>>>>//   );
74627>>>>>>>>>//
74627>>>>>>>>>// lpPathName
74627>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
74627>>>>>>>>>//  to be created.
74627>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
74627>>>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
74627>>>>>>>>>// lpSecurityAttributes
74627>>>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
74627>>>>>>>>>//  determines whether the returned handle can be inherited by child processes.
74627>>>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
74627>>>>>>>>>// Returns:
74627>>>>>>>>>//  If the function succeeds, the return value is nonzero.
74627>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
74627>>>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryA" kernel32.dll ;  Pointer lpPathName Pointer lpSecurity_Attributes Returns Integer
74628>>>>>>>>>
74628>>>>>>>>>
74628>>>>>>>>>// lpPathName
74628>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
74628>>>>>>>>>//  to be removed.
74628>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
74628>>>>>>>>>// Returns:
74628>>>>>>>>>//  If the function succeeds, the return value is nonzero.
74628>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
74628>>>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryA" kernel32.dll ;  Pointer lpPathName Returns Integer
74629>>>>>>>>>
74629>>>>>>>>>
74629>>>>>>>>>
74629>>>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
74629>>>>>>>>>// executable file or a document file.
74629>>>>>>>>>//
74629>>>>>>>>>// Operation can be one of the following:
74629>>>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
74629>>>>>>>>>//            The file can be an executable file or a document file.
74629>>>>>>>>>//            The file can be a folder to open.
74629>>>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
74629>>>>>>>>>//            The file should be a document file. If the file is an executable file,
74629>>>>>>>>>//            the function opens the file, as if "open" had been specified.
74629>>>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
74629>>>>>>>>>//
74629>>>>>>>>>// Return Values:
74629>>>>>>>>>//
74629>>>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
74629>>>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
74629>>>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
74629>>>>>>>>>//
74629>>>>>>>>>// The following table lists these error values:
74629>>>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
74629>>>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
74629>>>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
74629>>>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
74629>>>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
74629>>>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
74629>>>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
74629>>>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
74629>>>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
74629>>>>>>>>>// Public Const SE_ERR_FNF = 2
74629>>>>>>>>>// Public Const SE_ERR_NOASSOC = 31
74629>>>>>>>>>// Public Const SE_ERR_OOM = 8
74629>>>>>>>>>// Public Const SE_ERR_PNF = 3
74629>>>>>>>>>// Public Const SE_ERR_SHARE = 26
74629>>>>>>>>>
74629>>>>>>>>>
74629>>>>>>>>>
74629>>>>>>>>>// Code to open the program that is associated with the selected file.
74629>>>>>>>>>//
74629>>>>>>>>>// External function call used in Procedure DoStartDocument
74629>>>>>>>>>External_function vWin32_ShellExecute "ShellExecuteA" shell32.dll ;  Handle hWnd ;  Pointer lpOperation ;  Pointer lpFile ;  Pointer lpParameters ;  Pointer lpDirectory ;  Dword iShowCmd Returns Handle
74630>>>>>>>>>
74630>>>>>>>>>
74630>>>>>>>>>
74630>>>>>>>>>
74630>>>>>>>>>Define vFO_MOVE                For |CI$0001
74630>>>>>>>>>Define vFO_COPY                For |CI$0002
74630>>>>>>>>>Define vFO_DELETE              For |CI$0003
74630>>>>>>>>>Define vFO_RENAME              For |CI$0004
74630>>>>>>>>>
74630>>>>>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
74630>>>>>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
74630>>>>>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
74630>>>>>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
74630>>>>>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
74630>>>>>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
74630>>>>>>>>>                                          // Must be freed using SHFreeNameMappings
74630>>>>>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
74630>>>>>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
74630>>>>>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
74630>>>>>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
74630>>>>>>>>>
74630>>>>>>>>>Struct tvShFileOpStruct
74630>>>>>>>>>  Handle  hWnd
74630>>>>>>>>>  Integer wFunc
74630>>>>>>>>>  Pointer pFrom
74630>>>>>>>>>  Pointer pTo
74630>>>>>>>>>  Short   fFlags
74630>>>>>>>>>  Short   fAnyOperationsAborted
74630>>>>>>>>>  Pointer hNameMappings
74630>>>>>>>>>  Pointer lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
74630>>>>>>>>>End_Struct // tvShFileOpStruct
74630>>>>>>>>>
74630>>>>>>>>>// hwnd
74630>>>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
74630>>>>>>>>>
74630>>>>>>>>>// wFunc
74630>>>>>>>>>//   Operation to perform. This member can be one of the following values:
74630>>>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
74630>>>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
74630>>>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
74630>>>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
74630>>>>>>>>>
74630>>>>>>>>>// pFrom
74630>>>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
74630>>>>>>>>>//   be null-separated. The list of names must be double null-terminated.
74630>>>>>>>>>
74630>>>>>>>>>// pTo
74630>>>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
74630>>>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
74630>>>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
74630>>>>>>>>>//   double null-terminated.
74630>>>>>>>>>
74630>>>>>>>>>// fAnyOperationsAborted
74630>>>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
74630>>>>>>>>>//   were completed or FALSE otherwise.
74630>>>>>>>>>
74630>>>>>>>>>
74630>>>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
74630>>>>>>>>>// This can be a file or a folder.
74630>>>>>>>>>// With thanks to Andrew S Kaplan
74630>>>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationA" Shell32.dll ;        Pointer lpFileOp Returns Integer
74631>>>>>>>>>
74631>>>>>>>>>
74631>>>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
74631>>>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryA" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
74632>>>>>>>>>
74632>>>>>>>>>
74632>>>>>>>>>
74632>>>>>>>>>// Courtesy Of Vincent Oorsprong
74632>>>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
74632>>>>>>>>>//   Pointer lpPathName ;
74632>>>>>>>>>//   Pointer lpPrefixString ;
74632>>>>>>>>>//   Integer uUnique ;
74632>>>>>>>>>//   Pointer lpTempFileName ;
74632>>>>>>>>>//   Returns Integer
74632>>>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
74632>>>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameA" kernel32.dll Pointer lpsPath ;        Pointer lpsPrefix Integer iUnique Pointer pLoad Returns Integer
74633>>>>>>>>>
74633>>>>>>>>>External_function vWin32_GetTempPath "GetTempPathA" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
74634>>>>>>>>>
74634>>>>>>>>>External_function vWin32_DeleteFile "DeleteFileA" Kernel32.Dll ;   Pointer lpFileName ;   Returns Integer
74635>>>>>>>>>
74635>>>>>>>>>// from:
74635>>>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
74635>>>>>>>>>//
74635>>>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
74635>>>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
74635>>>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
74635>>>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
74635>>>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
74635>>>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
74635>>>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
74635>>>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
74635>>>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
74635>>>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
74635>>>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
74635>>>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
74635>>>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
74635>>>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
74635>>>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
74635>>>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
74635>>>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
74635>>>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
74635>>>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
74635>>>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
74635>>>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
74635>>>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
74635>>>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
74635>>>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
74635>>>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
74635>>>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
74635>>>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
74635>>>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
74635>>>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
74635>>>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
74635>>>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
74635>>>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
74635>>>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
74635>>>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
74635>>>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
74635>>>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
74635>>>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
74635>>>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
74635>>>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
74635>>>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
74635>>>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
74635>>>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
74635>>>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
74635>>>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
74635>>>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
74635>>>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
74635>>>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
74635>>>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
74635>>>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
74635>>>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
74635>>>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
74635>>>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
74635>>>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
74635>>>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
74635>>>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
74635>>>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
74635>>>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
74635>>>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
74635>>>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
74635>>>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
74635>>>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
74635>>>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
74635>>>>>>>>>
74635>>>>>>>>>
74635>>>>>>>>>//HRESULT SHGetFolderPath(
74635>>>>>>>>>//    HWND hwndOwner,
74635>>>>>>>>>//    int nFolder,
74635>>>>>>>>>//    HANDLE hToken,
74635>>>>>>>>>//    DWORD dwFlags,
74635>>>>>>>>>//    LPTSTR pszPath
74635>>>>>>>>>//);
74635>>>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
74635>>>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
74635>>>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
74635>>>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
74635>>>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
74635>>>>>>>>>//
74635>>>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathA" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
74636>>>>>>>>>
74636>>>>>>>>>
74636>>>>>>>>>
74636>>>>>>>>>Struct tvWin32FindData
74636>>>>>>>>> Dword            dwFileAttributes
74636>>>>>>>>> Dword            ftCreationLowDateTime
74636>>>>>>>>> Dword            ftCreationHighDateTime
74636>>>>>>>>> dword            ftLastAccessLowDateTime
74636>>>>>>>>> Dword            ftLastAccessHighDateTime
74636>>>>>>>>> Dword            ftLastWriteLowDateTime
74636>>>>>>>>> Dword            ftLastWriteHighDateTime
74636>>>>>>>>> Dword            nFileSizeHigh
74636>>>>>>>>> Dword            nFileSizeLow
74636>>>>>>>>> Dword            dwReserved0
74636>>>>>>>>> Dword            dwReserved1
74636>>>>>>>>> UChar[vMax_Path] cFileName
74636>>>>>>>>> UChar[14]        cAlternateFileName
74636>>>>>>>>>End_Struct
74636>>>>>>>>>
74636>>>>>>>>>// Courtesy Of Vincent Oorsprong
74636>>>>>>>>>// lpFileName      : address of name of file to search for
74636>>>>>>>>>// lpFindFileData  : address of returned information
74636>>>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileA"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
74637>>>>>>>>>
74637>>>>>>>>>// Courtesy Of Vincent Oorsprong
74637>>>>>>>>>// hFindFile       : handle of search
74637>>>>>>>>>// lpFindFileData  : address of structure for data on found file
74637>>>>>>>>>External_function vWin32_FindNextFile "FindNextFileA" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
74638>>>>>>>>>
74638>>>>>>>>>//
74638>>>>>>>>>// Unicode equivalents
74638>>>>>>>>>//
74638>>>>>>>>>// lpFileName      : address of name of file to search for
74638>>>>>>>>>// lpFindFileData  : address of returned information
74638>>>>>>>>>External_function vWin32W_FindFirstFile "FindFirstFileW"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
74639>>>>>>>>>
74639>>>>>>>>>// hFindFile       : handle of search
74639>>>>>>>>>// lpFindFileData  : address of structure for data on found file
74639>>>>>>>>>External_function vWin32W_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
74640>>>>>>>>>
74640>>>>>>>>>
74640>>>>>>>>>// Courtesy Of Vincent Oorsprong
74640>>>>>>>>>//  hFindFile      : file search handle
74640>>>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
74641>>>>>>>>>
74641>>>>>>>>>
74641>>>>>>>>>
74641>>>>>>>>>Struct tvFileTime
74641>>>>>>>>>  DWord dwLowDateTime
74641>>>>>>>>>  DWord dwHighDateTime
74641>>>>>>>>>End_Struct
74641>>>>>>>>>
74641>>>>>>>>>
74641>>>>>>>>>Struct tvSystemTime
74641>>>>>>>>>  UShort wYear
74641>>>>>>>>>  UShort wMonth
74641>>>>>>>>>  UShort wDayOfWeek
74641>>>>>>>>>  UShort wDay
74641>>>>>>>>>  UShort wHour
74641>>>>>>>>>  UShort wMinute
74641>>>>>>>>>  UShort wSecond
74641>>>>>>>>>  UShort wMilliSeconds
74641>>>>>>>>>End_Struct
74641>>>>>>>>>
74641>>>>>>>>>
74641>>>>>>>>>// Courtesy Of Vincent Oorsprong
74641>>>>>>>>>//  lpFileTime     : pointer to file time to convert
74641>>>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
74641>>>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
74642>>>>>>>>>
74642>>>>>>>>>// Courtesy Of Vincent Oorsprong
74642>>>>>>>>>// This function formats the time in a picture-string passed
74642>>>>>>>>>//
74642>>>>>>>>>// Picture      Meaning
74642>>>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
74642>>>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
74642>>>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
74642>>>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
74642>>>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
74642>>>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
74642>>>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
74642>>>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
74642>>>>>>>>>//    t         One character time marker string, such as A or P
74642>>>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
74642>>>>>>>>>//
74642>>>>>>>>>// For example, to get the time string  "11:29:40 PM"
74642>>>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
74642>>>>>>>>>
74642>>>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
74643>>>>>>>>>
74643>>>>>>>>>
74643>>>>>>>>>// Courtesy Of Vincent Oorsprong
74643>>>>>>>>>// This function formats the date in a picture-string passed
74643>>>>>>>>>//
74643>>>>>>>>>// Picture      Meaning
74643>>>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
74643>>>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
74643>>>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
74643>>>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
74643>>>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
74643>>>>>>>>>//              value associated with the specified locale.
74643>>>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
74643>>>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
74643>>>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
74643>>>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
74643>>>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
74643>>>>>>>>>//              associated with the specified locale.
74643>>>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
74643>>>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
74643>>>>>>>>>//    yyyy      Year represented hy full four digits.
74643>>>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
74643>>>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
74643>>>>>>>>>//              does not have an associated era or period string.
74643>>>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
74643>>>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
74643>>>>>>>>>
74643>>>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
74644>>>>>>>>>
74644>>>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
74644>>>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
74644>>>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
74644>>>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
74644>>>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
74644>>>>>>>>>
74644>>>>>>>>>//  Date Flags for GetDateFormatW.
74644>>>>>>>>>//
74644>>>>>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
74644>>>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
74644>>>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
74644>>>>>>>>>
74644>>>>>>>>>
74644>>>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
74645>>>>>>>>>
74645>>>>>>>>>
74645>>>>>>>>>// **WvA: 20-02-2004
74645>>>>>>>>>// While i was testing the format capabilities i stumbled over a very
74645>>>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
74645>>>>>>>>>// incorrectly into an unsigned integer.
74645>>>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
74645>>>>>>>>>// It does smell a bit fishy though
74645>>>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
74645>>>>>>>>>
74645>>>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
74645>>>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
74645>>>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
74645>>>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
74645>>>>>>>>>
74645>>>>>>>>>// Possible errors that can be returned by the shellformat function
74645>>>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
74645>>>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
74645>>>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
74645>>>>>>>>>
74645>>>>>>>>>
74645>>>>>>>>> // Courtesy Of Steve Walter,
74645>>>>>>>>> // USA Software, Inc
74645>>>>>>>>> // Format a disk
74645>>>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
74645>>>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
74646>>>>>>>>>
74646>>>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
74646>>>>>>>>>
74646>>>>>>>>>// SHCreateDirectoryEx
74646>>>>>>>>>
74646>>>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
74646>>>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
74646>>>>>>>>>//
74646>>>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
74646>>>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
74646>>>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
74646>>>>>>>>>//
74646>>>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
74646>>>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
74646>>>>>>>>>//        ERROR_CANCELLED.
74646>>>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
74646>>>>>>>>>
74646>>>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
74646>>>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
74646>>>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
74646>>>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
74646>>>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
74646>>>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
74646>>>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
74646>>>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
74646>>>>>>>>>
74646>>>>>>>>>//        int SHCreateDirectoryEx(
74646>>>>>>>>>//            HWND hwnd,
74646>>>>>>>>>//            LPCTSTR pszPath,
74646>>>>>>>>>//            const SECURITY_ATTRIBUTES *psa
74646>>>>>>>>>//        );
74646>>>>>>>>>
74646>>>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExA" shell32.dll Handle hWnd;                  pointer pszPath  Pointer lpSecurity_Attributes Returns Integer
74647>>>>>>>>>
74647>>>>>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryA" SHLWAPI.DLL Pointer lpszPath Returns Integer
74648>>>>>>>
74648>>>>>>>
74648>>>>>>>//
74648>>>>>>>// Gets the string from the right of the last sStopChar in sFrom
74648>>>>>>>// If sStopChar has no occurences in the string an empty string is
74648>>>>>>>// returned.
74648>>>>>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
74650>>>>>>>    String  sRetVal
74650>>>>>>>    String  sChar
74650>>>>>>>    Integer iLength
74650>>>>>>>    Integer iPos
74650>>>>>>>    Boolean bStopChar
74650>>>>>>>    Move "" to sRetval
74651>>>>>>>    Move (Length(sFrom)) to iLength
74652>>>>>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
74654>>>>>>>        Move iLength   to iPos
74655>>>>>>>        Move (False)   to bStopChar
74656>>>>>>>        While Not bStopChar
74660>>>>>>>            Move (Mid(sFrom,1,iPos)) to sChar
74661>>>>>>>            Decrement iPos
74662>>>>>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
74664>>>>>>>                Move (True) to bStopChar
74665>>>>>>>            End
74665>>>>>>>>
74665>>>>>>>            Else Begin
74666>>>>>>>                Move (sChar+sRetVal) to sRetVal
74667>>>>>>>            End
74667>>>>>>>>
74667>>>>>>>        Loop
74668>>>>>>>>
74668>>>>>>>    End
74668>>>>>>>>
74668>>>>>>>    Function_Return sRetVal
74669>>>>>>>End_Function
74670>>>>>>>
74670>>>>>>>// Pre:  sFileName contains the complete path of the file.
74670>>>>>>>// Post: returns the complete path of the file.
74670>>>>>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
74670>>>>>>>Function ParseFolderName Global String sFileName Returns String
74672>>>>>>>    String sFile
74672>>>>>>>    String sFolderName
74672>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
74672>>>>>>>
74672>>>>>>>    Move "" to sFolderName
74673>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
74674>>>>>>>    If sDirSep In sFileName Begin
74676>>>>>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
74677>>>>>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
74678>>>>>>>    End
74678>>>>>>>>
74678>>>>>>>    Else If ":" In sFileName Begin
74681>>>>>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
74682>>>>>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
74683>>>>>>>    End
74683>>>>>>>>
74683>>>>>>>    Function_Return sFolderName
74684>>>>>>>End_Function
74685>>>>>>>
74685>>>>>>>// Pre:  sFileName contains the complete path of the file.
74685>>>>>>>// post: The returned filename has it's path removed, but will have a extension
74685>>>>>>>Function ParseFileName Global String sFileName Returns String
74687>>>>>>>    String sFolderName
74687>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
74687>>>>>>>
74687>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
74688>>>>>>>    Get ParseFolderName sFileName to sFolderName
74689>>>>>>>    If (sFolderName <> "") Begin
74691>>>>>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
74692>>>>>>>    End
74692>>>>>>>>
74692>>>>>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
74693>>>>>>>    Function_Return sFilename
74694>>>>>>>End_Function
74695>>>>>>>
74695>>>>>>>// Pre:  sFileName may contain the complete path of the file.
74695>>>>>>>//       or contain multiple dots in the filename, so temp.gif.bak will
74695>>>>>>>//       return "bak" as the extension and not "gif"
74695>>>>>>>// Post: returns the extension only, this extension can be a valid unixlike extension
74695>>>>>>>//       such as "html" or "java"
74695>>>>>>>Function ParseFileExtension Global String sFileName Returns String
74697>>>>>>>    String  sFileExtension
74697>>>>>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
74698>>>>>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
74699>>>>>>>    Function_Return sFileExtension
74700>>>>>>>End_Function
74701>>>>>>>
74701>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
74701>>>>>>>
74701>>>>>>>Function DDE_Error_To_String Integer iErrorID Returns String
74703>>>>>>>    String sMessage
74703>>>>>>>    Case Begin
74703>>>>>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
74705>>>>>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
74706>>>>>>>            Case Break
74707>>>>>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
74710>>>>>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
74711>>>>>>>            Case Break
74712>>>>>>>        Case (iErrorID = vERROR_BAD_FORMAT)
74715>>>>>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
74716>>>>>>>            Case Break
74717>>>>>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
74720>>>>>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
74721>>>>>>>            Case Break
74722>>>>>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
74725>>>>>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
74726>>>>>>>            Case Break
74727>>>>>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
74730>>>>>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
74731>>>>>>>            Case Break
74732>>>>>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
74735>>>>>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
74736>>>>>>>            Case Break
74737>>>>>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
74740>>>>>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
74741>>>>>>>            Case Break
74742>>>>>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
74745>>>>>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
74746>>>>>>>            Case Break
74747>>>>>>>        Case (iErrorID = vSE_ERR_NOASSOC)
74750>>>>>>>            Move CS_DDE_ERR_NOASSOC to sMessage
74751>>>>>>>            Case Break
74752>>>>>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
74755>>>>>>>            Move CS_DDE_ERR_OOM to sMessage
74756>>>>>>>            Case Break
74757>>>>>>>        Case (iErrorID = vSE_ERR_PNF)
74760>>>>>>>            Move CS_DDE_ERR_PNF to sMessage
74761>>>>>>>            Case Break
74762>>>>>>>        Case (iErrorID = vSE_ERR_SHARE)
74765>>>>>>>            Move CS_DDE_ERR_SHARE to sMessage
74766>>>>>>>            Case Break
74767>>>>>>>        Case Else
74767>>>>>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
74768>>>>>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
74769>>>>>>>            Case Break
74770>>>>>>>    Case End
74770>>>>>>>    Function_Return sMessage
74771>>>>>>>End_Function
74772>>>>>>>
74772>>>>>>>Procedure vDDE_Error_Handler Integer iErrorID
74774>>>>>>>    String sMessage
74774>>>>>>>    Get DDE_Error_To_String iErrorID to sMessage
74775>>>>>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
74776>>>>>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
74777>>>>>>>End_Procedure
74778>>>>>>>
74778>>>>>>>// Does the directory exist? - No = false, Yes = True
74778>>>>>>>// This also works with UNC path encoding and wildcards
74778>>>>>>>Function vFolderExists Global String sFolderName Returns Boolean
74780>>>>>>>    Boolean bFolderExists
74780>>>>>>>    Boolean bStop
74780>>>>>>>    String  sFolder sTmp
74780>>>>>>>    Integer iCh
74780>>>>>>>
74780>>>>>>>    // 2013-09-29 NGS Check for empty folder name and convert to ANSI
74780>>>>>>>    Move (Utf8ToAnsi(Trim(sFolderName))) to sFolderName
74781>>>>>>>    If (sFolderName = "") Begin
74783>>>>>>>        Function_Return False
74784>>>>>>>    End
74784>>>>>>>>
74784>>>>>>>
74784>>>>>>>    Move True  to bFolderExists
74785>>>>>>>    Move False to bStop
74786>>>>>>>    Move "dir:" to sFolder
74787>>>>>>>    Append sFolder sFolderName
74788>>>>>>>    Get Seq_New_Channel to iCh  // get free channel for input
74789>>>>>>>    Direct_Input channel iCh sFolder
74791>>>>>>>    Repeat
74791>>>>>>>>
74791>>>>>>>        Readln channel iCh sTmp
74793>>>>>>>        Move (SeqEof) to bStop
74794>>>>>>>        If (Trim(sTmp)="") Begin
74796>>>>>>>            Move False to bFolderExists
74797>>>>>>>        End
74797>>>>>>>>
74797>>>>>>>        Else Begin
74798>>>>>>>            Move True to bFolderExists
74799>>>>>>>            Move True to bStop
74800>>>>>>>        End
74800>>>>>>>>
74800>>>>>>>    Until (bStop)
74802>>>>>>>    Close_Input channel iCh
74804>>>>>>>    Send Seq_Release_Channel iCh
74805>>>>>>>    Function_Return bFolderExists
74806>>>>>>>End_Function
74807>>>>>>>
74807>>>>>>>// returns folder name if a folder was selected, otherwise returns ""
74807>>>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
74809>>>>>>>    String sFolder sTitle sPath
74809>>>>>>>    Pointer lpItemIdList
74809>>>>>>>    Integer iFolderSelected iRetval
74809>>>>>>>    tvBrowseInfo BrowseInfo
74809>>>>>>>    tvBrowseInfo BrowseInfo
74809>>>>>>>
74809>>>>>>>    Move "" to sPath
74810>>>>>>>    If (sDialogTitle<>"") Begin
74812>>>>>>>        Move sDialogTitle to sTitle
74813>>>>>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
74813>>>>>>>        // disables showing some commonly used ascii characters like ascii 137 ()
74813>>>>>>>        // These chars are correctly shown if no toansi is used.
74813>>>>>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
74813>>>>>>>        // selected it will always be valid.
74813>>>>>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
74814>>>>>>>    End
74814>>>>>>>>
74814>>>>>>>
74814>>>>>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
74815>>>>>>>
74815>>>>>>>    // Torben Lund added line below. Move handle of focus object to structure before
74815>>>>>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
74815>>>>>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
74816>>>>>>>
74816>>>>>>>    // null 128 chars into var (make space)
74816>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
74817>>>>>>>
74817>>>>>>>    // select folder
74817>>>>>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
74818>>>>>>>    // get selected folder name
74818>>>>>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
74819>>>>>>>
74819>>>>>>>    // release memory resources that are used by the ItemIdList
74819>>>>>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
74820>>>>>>>
74820>>>>>>>    If (iFolderSelected<>0) Begin
74822>>>>>>>        Move (CString(sFolder)) to sPath
74823>>>>>>>    End
74823>>>>>>>>
74823>>>>>>>    Function_Return  sPath
74824>>>>>>>End_Function
74825>>>>>>>
74825>>>>>>>// returns 0 if the folder is created.
74825>>>>>>>//         1 if the API-call returned an error.
74825>>>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
74827>>>>>>>    String  sFolder
74827>>>>>>>    Integer iRetval bFolderCreated
74827>>>>>>>    tvSecurity_attributes SA
74827>>>>>>>    tvSecurity_attributes SA
74827>>>>>>>
74827>>>>>>>    Move False to bFolderCreated
74828>>>>>>>
74828>>>>>>>    // null MAX_PATH chars into var (make space)
74828>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
74829>>>>>>>
74829>>>>>>>    If (sNewFolder <> "") Begin
74831>>>>>>>
74831>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
74832>>>>>>>        Move  0  to SA.lpDescriptor
74833>>>>>>>        Move  1  to SA.bInheritHandle
74834>>>>>>>
74834>>>>>>>        //
74834>>>>>>>        Move (sNewFolder+"") to sFolder
74835>>>>>>>        Move (vWin32_CreateDirectory(AddressOf(sFolder), AddressOf(SA))) to bFolderCreated
74836>>>>>>>    End
74836>>>>>>>>
74836>>>>>>>
74836>>>>>>>    If (bFolderCreated=false) Begin
74838>>>>>>>        Move 1 to iRetVal
74839>>>>>>>    End
74839>>>>>>>>
74839>>>>>>>    Function_Return iRetVal
74840>>>>>>>End_Function
74841>>>>>>>
74841>>>>>>>// **WvA: 03-02-2002 Function created.
74841>>>>>>>// With this function one can remove a directory.
74841>>>>>>>// returns 0 if the folder is removed.
74841>>>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
74841>>>>>>>//         2 if the folder did not exist
74841>>>>>>>//         3 if the sFolder parameter passed is equal to ""
74841>>>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
74843>>>>>>>    Boolean bRemoved
74843>>>>>>>    String  sPath
74843>>>>>>>    Integer iRetval
74843>>>>>>>
74843>>>>>>>    Move 0     to iRetVal
74844>>>>>>>    Move False to bRemoved
74845>>>>>>>    Move (Trim(sFolder)) to sFolder
74846>>>>>>>    If (sFolder="") Begin
74848>>>>>>>        Move 3 to iRetVal
74849>>>>>>>    End
74849>>>>>>>>
74849>>>>>>>    If (vFolderExists(sFolder)=False) Begin
74851>>>>>>>        Move 2 to iRetVal
74852>>>>>>>    End
74852>>>>>>>>
74852>>>>>>>    If (iRetVal=0) Begin
74854>>>>>>>    // null MAX_PATH chars into var (make space)
74854>>>>>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
74855>>>>>>>        //
74855>>>>>>>        Move (Insert(sFolder,sPath,1)) to sPath
74856>>>>>>>        Move (vWin32_RemoveDirectory(AddressOf(sPath))) to bRemoved
74857>>>>>>>    End
74857>>>>>>>>
74857>>>>>>>
74857>>>>>>>    If (iRetVal=0 And bRemoved=False) Begin
74859>>>>>>>        Move 1 to iRetVal
74860>>>>>>>    End
74860>>>>>>>>
74860>>>>>>>    Function_Return iRetVal
74861>>>>>>>End_Function
74862>>>>>>>
74862>>>>>>>// This function informs the user that he entered a yet unknown folder and
74862>>>>>>>// asks if he/she wants to create the folder (Yes/No)
74862>>>>>>>// Choice: "Yes" - this creates the folder
74862>>>>>>>//                 if successful, the function returns false
74862>>>>>>>//                 else it will be true.
74862>>>>>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
74862>>>>>>>//                 For example: to stop a save
74862>>>>>>>// Precondition: A foldername must be entered. We do not check for empty paths
74862>>>>>>>// This function returns a non-zero value if the folder isn't created afterwards
74862>>>>>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
74864>>>>>>>    Integer bIsNotValid
74864>>>>>>>    Integer iUsers_Choice
74864>>>>>>>    String  sMessage
74864>>>>>>>
74864>>>>>>>    If (vFolderExists(sFolderName) Eq 0) Begin
74866>>>>>>>        Move "The folder '" to sMessage
74867>>>>>>>        Append sMessage sFolderName
74868>>>>>>>        Append sMessage "' does not yet exist,\n"
74869>>>>>>>        Append sMessage "Do you want to create it now?"
74870>>>>>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
74871>>>>>>>        Case Begin
74871>>>>>>>            Case (iUsers_Choice = MBR_Yes)
74873>>>>>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
74874>>>>>>>                If bIsNotValid Begin
74876>>>>>>>                    Move "An error occurred while trying to create folder '" to sMessage
74877>>>>>>>                    Append sMessage sFolderName "'.\n\n"
74879>>>>>>>                    Send Info_Box sMessage "Info"
74880>>>>>>>                End
74880>>>>>>>>
74880>>>>>>>                Case Break
74881>>>>>>>            Case (iUsers_Choice = MBR_No)
74884>>>>>>>                Move dfTrue to bIsNotValid // Cancel the save
74885>>>>>>>                Case Break
74886>>>>>>>        Case End
74886>>>>>>>    End
74886>>>>>>>>
74886>>>>>>>    Function_Return bIsNotValid
74887>>>>>>>End_Function
74888>>>>>>>
74888>>>>>>>// This will perform an operation on a file (e.g. open) with the application
74888>>>>>>>// registered in the Windows Registry to open that type of file (via its extension)
74888>>>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
74888>>>>>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
74890>>>>>>>    Handle  hInstance hWnd
74890>>>>>>>    // remove any leading/trailing spaces in the string
74890>>>>>>>    Move (Trim(sDocument)) to sDocument
74891>>>>>>>    Move (Trim(sPath))     to sPath
74892>>>>>>>    // Make the strings readable for windows API, by converting them to null-terminated
74892>>>>>>>    Append sOperation   (Character(0))
74893>>>>>>>    Append sDocument    (Character(0))
74894>>>>>>>    Append sParameters  (Character(0))
74895>>>>>>>    Append sPath        (Character(0))
74896>>>>>>>
74896>>>>>>>    Get Window_Handle to hWnd
74897>>>>>>>    Move (vWin32_ShellExecute (hWnd, AddressOf(sOperation), AddressOf(sDocument), AddressOf(sParameters), AddressOf(sPath), 1)) to hInstance
74898>>>>>>>    If (hInstance <= 32) Begin
74900>>>>>>>        Send vDDE_Error_Handler hInstance
74901>>>>>>>    End
74901>>>>>>>>
74901>>>>>>>End_Procedure
74902>>>>>>>
74902>>>>>>>Class cShellFileOperations is a Array
74903>>>>>>>
74903>>>>>>>    Procedure Construct_Object
74905>>>>>>>        Forward Send Construct_Object
74907>>>>>>>        Property Integer piDeleteFlags        0
74908>>>>>>>        Property Integer piCopyFlags          0
74909>>>>>>>        Property Integer piMoveFlags          0
74910>>>>>>>        Property Integer piRenameFlags        0
74911>>>>>>>
74911>>>>>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
74912>>>>>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
74913>>>>>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
74914>>>>>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
74915>>>>>>>    End_Procedure
74916>>>>>>>
74916>>>>>>>    // This function uses the shell API to perform a file operation on the
74916>>>>>>>    // files supplied.
74916>>>>>>>    //
74916>>>>>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
74918>>>>>>>        Integer  iRetVal
74918>>>>>>>        Integer  iUserAbort
74918>>>>>>>        tvShFileOpStruct FOS
74918>>>>>>>        tvShFileOpStruct FOS
74918>>>>>>>
74918>>>>>>>        Move (Utf8ToAnsi(sSource)+Character(0)+Character(0))      to sSource
74919>>>>>>>        Move (Utf8ToAnsi(sDestination)+Character(0)+Character(0)) to sDestination
74920>>>>>>>        If (eOperation <> vFO_DELETE) Begin
74922>>>>>>>            Move (AddressOf(sDestination)) to FOS.pTo
74923>>>>>>>        End
74923>>>>>>>>
74923>>>>>>>
74923>>>>>>>        Move eOperation           to FOS.wFunc
74924>>>>>>>        Move (AddressOf(sSource)) to FOS.pFrom
74925>>>>>>>        Move iFlags               to FOS.fFlags
74926>>>>>>>
74926>>>>>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
74927>>>>>>>        Move FOS.fAnyOperationsAborted to iUserAbort
74928>>>>>>>        If (iUserAbort <> 0) Begin
74930>>>>>>>            Move 80 to iRetVal  // file Operation Aborted by USER
74931>>>>>>>        End
74931>>>>>>>>
74931>>>>>>>        Function_Return (iRetVal)
74932>>>>>>>    End_Function
74933>>>>>>>
74933>>>>>>>    Function sfoDeleteFile String sFileName Returns Integer
74935>>>>>>>        Integer  iRetVal
74935>>>>>>>        Integer  iFlags
74935>>>>>>>
74935>>>>>>>        Get piDeleteFlags to iFlags
74936>>>>>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
74937>>>>>>>        Function_Return iRetVal
74938>>>>>>>    End_Function
74939>>>>>>>
74939>>>>>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
74941>>>>>>>        Integer  iRetVal
74941>>>>>>>        Integer  iFlags
74941>>>>>>>
74941>>>>>>>        Get piCopyFlags to iFlags
74942>>>>>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
74943>>>>>>>        Function_Return iRetVal
74944>>>>>>>    End_Function
74945>>>>>>>
74945>>>>>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
74947>>>>>>>        Integer  iRetVal
74947>>>>>>>        Integer  iFlags
74947>>>>>>>
74947>>>>>>>        Get piMoveFlags to iFlags
74948>>>>>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
74949>>>>>>>        Function_Return iRetVal
74950>>>>>>>    End_Function
74951>>>>>>>
74951>>>>>>>    // Rename a file or folder
74951>>>>>>>    // Returns a nonzero value if the operation failed.
74951>>>>>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
74953>>>>>>>        Integer  iRetVal
74953>>>>>>>        Integer  iFlags
74953>>>>>>>
74953>>>>>>>        Get piRenameFlags to iFlags
74954>>>>>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
74955>>>>>>>        Function_Return iRetVal
74956>>>>>>>    End_Function
74957>>>>>>>
74957>>>>>>>    // Courtesy Of Steve Walter
74957>>>>>>>    // Requires Windows 2000 and up according to msdn but it was
74957>>>>>>>    //  in fact available before that as an unpublished API call
74957>>>>>>>    //  a little google search shows that this was already available
74957>>>>>>>    //  in windows 95 and NT
74957>>>>>>>    //
74957>>>>>>>    // The format is controlled by the dialog interface.
74957>>>>>>>    // That is, the user must click the OK button To actually Begin the format
74957>>>>>>>    // the format cannot be started programmatically.
74957>>>>>>>    // An alternative to this functionality would be to use a controlpanel
74957>>>>>>>    //  http://www.vdf-guidance.com/ContribPage.asp?Page=PKGCLSDFCPLAPP&ContribRecId=93
74957>>>>>>>    //
74957>>>>>>>    // hWnd = The windows handle of the object from which the format Function
74957>>>>>>>    //        is called.
74957>>>>>>>    // To Get this,
74957>>>>>>>    //          use:  Get Window_Handle Of <object>
74957>>>>>>>    //          For instance, in this app, we're going to use the Report_Panel:
74957>>>>>>>    //                  Get Window_Handle Of (Report_Panel(Main(Self))) To hWind
74957>>>>>>>    //
74957>>>>>>>    // sDrive = The drive letter. At this moment only A and B are valid
74957>>>>>>>    //
74957>>>>>>>    // iOptions = Format options.
74957>>>>>>>    //  SHFMT_OPT_DEFAULT = Quick format
74957>>>>>>>    //  SHFMT_OPT_FULL    = Full Format
74957>>>>>>>    //  SHFMT_OPT_SYSONLY = System only
74957>>>>>>>    //  3                 = Full format with system. (unsupported)
74957>>>>>>>    //
74957>>>>>>>    // Return Values:
74957>>>>>>>    //  SHFMT_ERROR    = Error on format or no drive specified.
74957>>>>>>>    //  SHFMT_CANCEL   = Format cancelled by user.
74957>>>>>>>    //  SHFMT_NOFORMAT = Drive is not formatable.
74957>>>>>>>    //
74957>>>>>>>    //
74957>>>>>>>    // *** ATTENTION: This function has been disabled as it doesn't
74957>>>>>>>    //                seem to work, i must have made a silly mistake
74957>>>>>>>    //                somewhere.
74957>>>>>>>    //
74957>>>>>>>    Function sfoFormatDisk String sDrive Integer iOptions Returns DWord
74959>>>>>>>        Handle   hWnd
74959>>>>>>>        Integer  iObj
74959>>>>>>>        DWord    dwReturnVal
74959>>>>>>>        Integer iDrive
74959>>>>>>>
74959>>>>>>>        Function_Return 1 // STOP HERE
74960>>>>>>>
74960>>>>>>>        Move (Trim(sDrive)) to sDrive
74961>>>>>>>        If ( sDrive <> '' ) Begin
74963>>>>>>>            If ( sDrive Contains ':' ) Begin
74965>>>>>>>                Move (Replace(':',sDrive,'')) to sDrive
74966>>>>>>>            End
74966>>>>>>>>
74966>>>>>>>            If (Not( 'AB' Contains sDrive )) Begin
74968>>>>>>>                Function_Return (SHFMT_NOFORMAT)
74969>>>>>>>            End
74969>>>>>>>>
74969>>>>>>>            If ( sDrive = 'A' ) Begin
74971>>>>>>>                Move 0 to iDrive
74972>>>>>>>            End
74972>>>>>>>>
74972>>>>>>>            Else If ( sDrive = 'B' ) Begin
74975>>>>>>>                Move 1 to iDrive
74976>>>>>>>            End
74976>>>>>>>>
74976>>>>>>>            // Window_Handle Of Desktop equals to 0
74976>>>>>>>
74976>>>>>>>            Get focus of desktop to iObj
74977>>>>>>>            If (iObj>desktop) Begin
74979>>>>>>>                Get Container_Handle of iObj to hWnd
74980>>>>>>>            End
74980>>>>>>>>
74980>>>>>>>            While (hWnd=0 And iObj<>Desktop)
74984>>>>>>>                Get Parent of iObj to iObj
74985>>>>>>>                Get Container_Handle of iObj to hWnd
74986>>>>>>>            Loop
74987>>>>>>>>
74987>>>>>>>
74987>>>>>>>            //Showln "hWnd = " hWnd " iDrive " iDrive " iOptions " iOptions
74987>>>>>>>            Move (vWin32_ShFormatDrive(hWnd, iDrive, SHFMT_ID_DEFAULT, iOptions)) to dwReturnVal
74988>>>>>>>        End
74988>>>>>>>>
74988>>>>>>>        Else Begin
74989>>>>>>>            Move (SHFMT_ERROR) to dwReturnVal
74990>>>>>>>        End
74990>>>>>>>>
74990>>>>>>>        Function_Return dwReturnVal
74991>>>>>>>    End_Function
74992>>>>>>>
74992>>>>>>>    //Example:
74992>>>>>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
74992>>>>>>>    //                                          mode.
74992>>>>>>>
74992>>>>>>>End_Class
74993>>>>>>>
74993>>>>>>>Object oShellFileOperations is a cShellFileOperations
74995>>>>>>>End_Object
74996>>>>>>>
74996>>>>>>>// Restore to the old way of working with the shell file operations.
74996>>>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
74996>>>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
74996>>>>>>>Procedure vWin32fhCompatibilityMode
74998>>>>>>>    Integer hoSFO
74998>>>>>>>    Integer iFlags
74998>>>>>>>
74998>>>>>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
74999>>>>>>>    Move (oShellFileOperations(Self)) to hoSFO
75000>>>>>>>
75000>>>>>>>    Set piDeleteFlags of hoSFO to iFlags
75001>>>>>>>    Set piCopyFlags   of hoSFO to iFlags
75002>>>>>>>    Set piMoveFlags   of hoSFO to iFlags
75003>>>>>>>    Set piRenameFlags of hoSFO to iFlags
75004>>>>>>>End_Procedure
75005>>>>>>>
75005>>>>>>>// Delete a file or folder
75005>>>>>>>// Returns a nonzero value if the operation failed.
75005>>>>>>>Function vDeleteFile Global String sFileName Returns Integer
75007>>>>>>>    Integer  iRetVal
75007>>>>>>>
75007>>>>>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
75008>>>>>>>    Function_Return iRetVal
75009>>>>>>>End_Function
75010>>>>>>>
75010>>>>>>>// Copy a file or folder
75010>>>>>>>// Returns a nonzero value if the operation failed.
75010>>>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
75012>>>>>>>    Integer  iRetVal
75012>>>>>>>
75012>>>>>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75013>>>>>>>    Function_Return iRetVal
75014>>>>>>>End_Function
75015>>>>>>>
75015>>>>>>>// Move a file or folder
75015>>>>>>>// Returns a nonzero value if the operation failed.
75015>>>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
75017>>>>>>>    Integer  iRetVal
75017>>>>>>>
75017>>>>>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75018>>>>>>>    Function_Return iRetVal
75019>>>>>>>End_Function
75020>>>>>>>
75020>>>>>>>// Rename a file or folder
75020>>>>>>>// Returns a nonzero value if the operation failed.
75020>>>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
75022>>>>>>>    Integer  iRetVal
75022>>>>>>>
75022>>>>>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75023>>>>>>>    Function_Return iRetVal
75024>>>>>>>End_Function
75025>>>>>>>
75025>>>>>>>Function vGetWindowsDirectory Returns String
75027>>>>>>>    String  sDirectory
75027>>>>>>>    Integer iVoid
75027>>>>>>>
75027>>>>>>>    Move (ZeroString(vMAX_PATH)) to sDirectory
75028>>>>>>>    Move (vWin32_GetWindowsDirectory(AddressOf(sDirectory), vMAX_PATH)) to iVoid
75029>>>>>>>    Function_Return (CString(sDirectory))
75030>>>>>>>End_Function
75031>>>>>>>
75031>>>>>>>Function vGetTempPath Returns String
75033>>>>>>>    Integer iRetval
75033>>>>>>>    String  sTempPath
75033>>>>>>>
75033>>>>>>>    Move (ZeroString(vMAX_PATH)) to sTempPath
75034>>>>>>>    Move (vWin32_GetTempPath (vMAX_PATH, AddressOf(sTempPath))) to iRetVal
75035>>>>>>>    Function_Return (Cstring(sTempPath))
75036>>>>>>>End_Function
75037>>>>>>>
75037>>>>>>>// Courtesy of Marco Kuipers
75037>>>>>>>Function vMakeTempFile Returns String
75039>>>>>>>    Integer iRetval
75039>>>>>>>    String  sTempPath
75039>>>>>>>    String  sTempFileName
75039>>>>>>>    String  sPrefixString
75039>>>>>>>
75039>>>>>>>    Get vGetTempPath to sTempPath
75040>>>>>>>    If (sTempPath = "") Begin
75042>>>>>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
75043>>>>>>>        If (sTempPath<>"") Begin
75045>>>>>>>            Move (sTempPath+"\Temp\") to sTempPath
75046>>>>>>>        End
75046>>>>>>>>
75046>>>>>>>    End
75046>>>>>>>>
75046>>>>>>>
75046>>>>>>>    If (sTempPath = "") Begin
75048>>>>>>>    // second fallback we really do not want to get here as to be fair using current folder as temp
75048>>>>>>>    // makes little sense. Leaving this in as it was old behavior.
75048>>>>>>>        Get_Current_Directory to sTempPath
75049>>>>>>>    End
75049>>>>>>>>
75049>>>>>>>
75049>>>>>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
75050>>>>>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
75052>>>>>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
75053>>>>>>>>
75053>>>>>>>    End
75053>>>>>>>>
75053>>>>>>>
75053>>>>>>>    Move (ZeroString(vMax_Path)) to sTempFileName
75054>>>>>>>    Move ("tmp"+Character(0)) to sPrefixString // **WvA: 28-04-2005 Added a null
75055>>>>>>>    Move (vWin32_GetTempFileName (AddressOf(sTempPath), AddressOf(sPrefixString), 0, AddressOf(sTempFileName))) to iRetval
75056>>>>>>>    If (iRetval = 0) Begin  // **WvA: 28-04-2005 Changed condition, the api call returns 0 if an error occurs
75058>>>>>>>    //Get ShowLastError to iRetval
75058>>>>>>>        Move "" to sTempFileName
75059>>>>>>>    End
75059>>>>>>>>
75059>>>>>>>
75059>>>>>>>    Function_Return (Cstring(sTempFileName)) // **WvA: 28-04-2005 Cstring added
75060>>>>>>>End_Function
75061>>>>>>>
75061>>>>>>>// This function creates a uniquely named temporary file in folder sPath
75061>>>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
75061>>>>>>>// Note that you will have to cleanup the tempfile yourself as the function
75061>>>>>>>// does not take care of that.
75061>>>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
75063>>>>>>>    Integer iRetVal
75063>>>>>>>    String sTempFileName
75063>>>>>>>
75063>>>>>>>    Move (Utf8ToAnsi(sPath)+Character(0))   to sPath
75064>>>>>>>    Move (Utf8ToAnsi(sPrefix)+Character(0)) to sPrefix
75065>>>>>>>    Move (Pad("", vMAX_PATH)) to sTempFileName
75066>>>>>>>
75066>>>>>>>    Move (vWin32_GetTempFileName(AddressOf(sPath), AddressOf(sPrefix), 0, AddressOf(sTempFileName))) to iRetVal
75067>>>>>>>    Move (Trim(Cstring(sTempFileName))) to sTempFileName
75068>>>>>>>    Function_Return sTempFileName
75069>>>>>>>End_Function
75070>>>>>>>
75070>>>>>>>//
75070>>>>>>>// Get a specific shell folder for example to get the desktop folder
75070>>>>>>>// simply call this function and pass it vCSIDL_DESKTOP
75070>>>>>>>//
75070>>>>>>>Function vSHGetFolderPath Integer eFolder Returns String
75072>>>>>>>    String  sFolder
75072>>>>>>>    Integer iVoid
75072>>>>>>>    Handle  hWnd
75072>>>>>>>
75072>>>>>>>    Move (Window_Handle(focus(desktop))) to hWnd
75073>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
75074>>>>>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(sFolder))) to iVoid
75075>>>>>>>    Function_Return (CString(sFolder))
75076>>>>>>>End_Function
75077>>>>>>>
75077>>>>>>>// Courtesy Of Vincent Oorsprong
75077>>>>>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
75079>>>>>>>    String  sFormattedTime sFormattedDate
75079>>>>>>>    String  sFileDateTime
75079>>>>>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
75079>>>>>>>    tvFileTime   FileTime
75079>>>>>>>    tvFileTime   FileTime
75079>>>>>>>    tvSystemTime SystemTime
75079>>>>>>>    tvSystemTime SystemTime
75079>>>>>>>
75079>>>>>>>    Move "" to sFileDateTime
75080>>>>>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
75081>>>>>>>    Move dwHighDateTime to FileTime.dwHighDateTime
75082>>>>>>>
75082>>>>>>>    Move 0 to SystemTime.wYear
75083>>>>>>>
75083>>>>>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
75084>>>>>>>    If (iSuccess = 1) Begin
75086>>>>>>>        Move (ZeroString(255))        to sFormattedTime
75087>>>>>>>        Move (Length(sFormattedTime)) to iLenCcTime
75088>>>>>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(sFormattedTime), iLenCcTime)) to iDataLength
75089>>>>>>>        Move (ZeroString(255))        to sFormattedDate
75090>>>>>>>        Move (Length(sFormattedDate)) to iLenCcDate
75091>>>>>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(sFormattedDate), iLenCcDate)) to iDataLength
75092>>>>>>>        Move (Cstring (sFormattedDate)  * Cstring (sFormattedTime)) to sFileDateTime
75093>>>>>>>    End
75093>>>>>>>>
75093>>>>>>>    Function_Return sFileDateTime
75094>>>>>>>End_Function
75095>>>>>>>
75095>>>>>>>// **WvA:
75095>>>>>>>// A windows replacement for the standard function FileExists.
75095>>>>>>>// This version will also return (true) for a file when it is open by an application.
75095>>>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
75095>>>>>>>// Example: Get vFilePathExists "C:\config.sy?"
75095>>>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
75095>>>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
75097>>>>>>>    String  sDirSep
75097>>>>>>>    Handle  hFindFile
75097>>>>>>>    Integer iVoid
75097>>>>>>>    tvWin32FindData FindData
75097>>>>>>>    tvWin32FindData FindData
75097>>>>>>>
75097>>>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
75098>>>>>>>    Move (Utf8ToANSI(Trim(sFilePathMask))) to sFilePathMask
75099>>>>>>>    If (Length(sFilePathMask)>0) Begin
75101>>>>>>>    // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
75101>>>>>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75102>>>>>>>        While (Right(sFilePathMask, 1) = sDirSep)
75106>>>>>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
75107>>>>>>>        Loop
75108>>>>>>>>
75108>>>>>>>
75108>>>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75109>>>>>>>        Move (vWin32_FindFirstFile (AddressOf(sFilePathMask), AddressOf(FindData))) to hFindFile
75110>>>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
75111>>>>>>>    End
75111>>>>>>>>
75111>>>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
75112>>>>>>>End_Function
75113>>>>>>>
75113>>>>>>>//
75113>>>>>>>// WideChar version of the function, do not use, it's an experiment
75113>>>>>>>//
75113>>>>>>>Function vWFilePathExists Global String sFilePathMask Returns Integer
75115>>>>>>>    Handle  hFindFile
75115>>>>>>>    Integer iVoid
75115>>>>>>>    tvWin32FindData FindData
75115>>>>>>>    tvWin32FindData FindData
75115>>>>>>>
75115>>>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
75116>>>>>>>
75116>>>>>>>    If (Length(sFilePathMask)>0) Begin
75118>>>>>>>
75118>>>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75119>>>>>>>        Move (vWin32W_FindFirstFile (AddressOf(sFilePathMask), AddressOf(FindData))) to hFindFile
75120>>>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
75121>>>>>>>    End
75121>>>>>>>>
75121>>>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
75122>>>>>>>End_Function
75123>>>>>>>
75123>>>>>>>// **WvA
75123>>>>>>>// Formats a foldername by first trimming it and after that by sticking a
75123>>>>>>>// directory separator (/\) to the end if it doesn't have one there already.
75123>>>>>>>// The folder may contain a drive letter or UNC encoding.
75123>>>>>>>Function vFolderFormat Global String sFolderName Returns String
75125>>>>>>>    String sDirSep
75125>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
75126>>>>>>>    Move (Trim(sFolderName)) to sFolderName
75127>>>>>>>    If (Right(sFolderName,1)<>sDirSep) Begin
75129>>>>>>>        Move (sFolderName+sDirSep) to sFolderName
75130>>>>>>>    End
75130>>>>>>>>
75130>>>>>>>    Function_Return sFolderName
75131>>>>>>>End_Function
75132>>>>>>>
75132>>>>>>>//
75132>>>>>>>// Returns the amount of files in the folder (if it exists)
75132>>>>>>>// Returns -1 if folder doesn't exist.
75132>>>>>>>// The files "." and ".." are not counted.
75132>>>>>>>//
75132>>>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
75134>>>>>>>    Boolean bFound
75134>>>>>>>    Handle  hFindFile
75134>>>>>>>    Integer iCount  iVoid
75134>>>>>>>    Integer iSuccess
75134>>>>>>>    String  sFileName
75134>>>>>>>    tvWin32FindData FindData
75134>>>>>>>    tvWin32FindData FindData
75134>>>>>>>
75134>>>>>>>    Move -1 to iCount
75135>>>>>>>    Get vFolderFormat sFolderName to sFolderName
75136>>>>>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
75137>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75138>>>>>>>    Move (vWin32_FindFirstFile (AddressOf(sFolderName), AddressOf(FindData))) to hFindFile
75139>>>>>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
75140>>>>>>>    If (bFound) Begin
75142>>>>>>>        Move 0 to iCount
75143>>>>>>>    End
75143>>>>>>>>
75143>>>>>>>    While (bFound)
75147>>>>>>>        Increment iCount
75148>>>>>>>        Move (UCharArrayToString(FindData.cFileName)) to sFileName
75149>>>>>>>        If (sFileName="." or sFileName="..") Begin
75151>>>>>>>            Decrement iCount
75152>>>>>>>        End
75152>>>>>>>>
75152>>>>>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
75153>>>>>>>        Move (iSuccess<>0) to bFound
75154>>>>>>>    Loop
75155>>>>>>>>
75155>>>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
75156>>>>>>>    Function_Return iCount
75157>>>>>>>End_Function
75158>>>>>>>
75158>>>>>>>//
75158>>>>>>>// Gets the parent path of the currently supplied path
75158>>>>>>>// Returns "" when we are at the root folder.
75158>>>>>>>//
75158>>>>>>>Function vParentPath Global String sPath Returns String
75160>>>>>>>    String sStrip sDirSep
75160>>>>>>>
75160>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75161>>>>>>>    Move (Trim(sPath)) to sPath
75162>>>>>>>    If (Right(sPath,1) = sDirSep) Begin
75164>>>>>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
75165>>>>>>>    End
75165>>>>>>>>
75165>>>>>>>    If (Pos(sDirSep, sPath)) Begin
75167>>>>>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
75168>>>>>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
75169>>>>>>>    End
75169>>>>>>>>
75169>>>>>>>    Else Begin
75170>>>>>>>        Move "" to sPath
75171>>>>>>>    End
75171>>>>>>>>
75171>>>>>>>    Function_Return sPath
75172>>>>>>>End_Function
75173>>>>>>>
75173>>>>>>>// Create the folder, including intermediate directories.
75173>>>>>>>// Don't panic if the folder already exists.
75173>>>>>>>// Michael Mullan June 2009.
75173>>>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
75175>>>>>>>    String  sFolder
75175>>>>>>>    Integer iRetval iFolderCreated
75175>>>>>>>    tvSecurity_attributes SA
75175>>>>>>>    tvSecurity_attributes SA
75175>>>>>>>
75175>>>>>>>    Move 0 to iFolderCreated
75176>>>>>>>
75176>>>>>>>    // null MAX_PATH chars into var (make space)
75176>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
75177>>>>>>>    If (sNewFolder <> "") Begin
75179>>>>>>>
75179>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
75180>>>>>>>        Move  0  to SA.lpDescriptor
75181>>>>>>>        Move  1  to SA.bInheritHandle
75182>>>>>>>
75182>>>>>>>        //
75182>>>>>>>        Move (sNewFolder+"") to sFolder
75183>>>>>>>        Move (vWin32_SHCreateDirectoryEx(0,AddressOf(sFolder), AddressOf(SA))) to iFolderCreated
75184>>>>>>>    End
75184>>>>>>>>
75184>>>>>>>
75184>>>>>>>    If (iFolderCreated <> 0) Begin
75186>>>>>>>        Move 1 to iRetVal
75187>>>>>>>        Case Begin
75187>>>>>>>            Case (iFolderCreated = 161)
75189>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
75190>>>>>>>>
75190>>>>>>>                Case Break
75191>>>>>>>            Case (iFolderCreated = 206)
75194>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
75195>>>>>>>>
75195>>>>>>>                Case Break
75196>>>>>>>            Case (iFolderCreated = 3)
75199>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
75200>>>>>>>>
75200>>>>>>>                Case Break
75201>>>>>>>            Case (iFolderCreated = 80)
75204>>>>>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
75205>>>>>>>                Case Break
75206>>>>>>>            Case (iFolderCreated = 183)
75209>>>>>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
75210>>>>>>>                Case Break
75211>>>>>>>            Case (iFolderCreated = 1223)
75214>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
75215>>>>>>>>
75215>>>>>>>                Case Break
75216>>>>>>>            Case Else
75216>>>>>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
75217>>>>>>>>
75217>>>>>>>        Case End
75217>>>>>>>    End
75217>>>>>>>>
75217>>>>>>>    Function_Return iRetVal
75218>>>>>>>End_Function
75219>>>>>>>
75219>>>>>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
75221>>>>>>>    DWord   dwFileSizeHigh dwFileSizeLow
75221>>>>>>>    Integer iFileSize iVoid
75221>>>>>>>    Handle  hFindFile
75221>>>>>>>    tvWin32FindData FindData
75221>>>>>>>    tvWin32FindData FindData
75221>>>>>>>
75221>>>>>>>    Move (sFileName+"") to sFileName
75222>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75223>>>>>>>    Move (vWin32_FindFirstFile (AddressOf(sFileName), AddressOf(FindData))) to hFindFile
75224>>>>>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
75226>>>>>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
75227>>>>>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
75228>>>>>>>    End
75228>>>>>>>>
75228>>>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
75229>>>>>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
75230>>>>>>>
75230>>>>>>>    Function_Return iFileSize
75231>>>>>>>End_Function
75232>>>>>>>
75232>>>>>>>//
75232>>>>>>>// Based on code in Peter Crook's Browse folder workspace
75232>>>>>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
75232>>>>>>>//
75232>>>>>>>//=============================================================================
75232>>>>>>>// Verifies that a path is a valid directory.
75232>>>>>>>//
75232>>>>>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
75232>>>>>>>//
75232>>>>>>>// Parameters:
75232>>>>>>>//      sPath - Address of the path to verify.
75232>>>>>>>//=============================================================================
75232>>>>>>>Function vPathIsDirectory Global String sPath Returns Boolean
75234>>>>>>>    Integer iResult
75234>>>>>>>    Boolean bRetVal
75234>>>>>>>
75234>>>>>>>    Move false to bRetVal
75235>>>>>>>    Move (Utf8ToAnsi(sPath) - Character (0)) to sPath
75236>>>>>>>    Move (vWin32_PathIsDirectory (AddressOf (sPath))) to iResult
75237>>>>>>>    If (iResult<>0) Begin
75239>>>>>>>        Move True to bRetVal
75240>>>>>>>    End
75240>>>>>>>>
75240>>>>>>>
75240>>>>>>>    Function_Return bRetVal
75241>>>>>>>End_Function
75242>>>>>>>
75242>>>>>Use DUFLanguageConstants.inc
75242>>>>>
75242>>>>>Define CS_IntFilesTableRootName for "IntFilesTable"
75242>>>>>Define CS_FilelistZipFile       for "FilelistBackupFile.zip"
75242>>>>>Define CS_FilelistBackupFile    for "FilelistBackupFile.cfg"
75242>>>>>
75242>>>>>Struct tDUFIntFile
75242>>>>>    Integer iID
75242>>>>>    String sIntFileName
75242>>>>>    String sIntLineText
75242>>>>>End_Struct
75242>>>>>
75242>>>>>Struct tDbVersionInfo
75242>>>>>    Number nVersionNumber
75242>>>>>    Handle hObject
75242>>>>>End_Struct
75242>>>>>
75242>>>>>Struct tDbUpdateError
75242>>>>>    Number nUpdateVersion
75242>>>>>    Integer iError
75242>>>>>    String  sOrgErrorText
75242>>>>>    String  sErrorText
75242>>>>>    Integer iErrorLine
75242>>>>>    Boolean bError  
75242>>>>>    Handle  hTable 
75242>>>>>    String  sTableRootName
75242>>>>>    Integer iField
75242>>>>>    Boolean bShortFormat
75242>>>>>End_Struct
75242>>>>>
75242>>>>>//  DF_FILE_ALIAS_DEFAULT if no master or alias
75242>>>>>//  DF_FILE_IS_MASTER if master
75242>>>>>//  DF_FILE_IS_ALIAS if alias
75242>>>>>Struct tDbUpdateHandlerMasterAlias
75242>>>>>    Handle hTable
75242>>>>>    Integer iMode
75242>>>>>End_Struct
75242>>>>>
75242>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
75242>>>>>Enumeration_List
75242>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
75242>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
75242>>>>>End_Enumeration_List
75242>>>>>
75242>>>>>    Define DATAFLEX_ID for "DATAFLEX"
75242>>>>>
75242>>>>>// Global handle to a cDatabaseUpdateHandler object that can be used to
75242>>>>>// communicate with the object from anywhere in a program.
75242>>>>>    Global_Variable Handle ghoDbUpdateHandler
75242>>>>>    Move 0 to ghoDbUpdateHandler
75243>>>>>
75243>>>>>// NOTE: If the DbVersion table should _not_ be used and you
75243>>>>>// instead set the "Set Data_File_Field to (RefTable(MyTable)) (RefTable(MyTable.DbUpdateVersion))"
75243>>>>>// in the cDbUpdateHandler object; Add a "Define DUF_Use_DbVersion" to your code,
75243>>>>>// _before_ the "Use cDbUpdateHandler.pkg" line.
75243>>>>>//#IFNDEF DUF_Use_Custom_DbVersion
75243>>>>>//    Declare_Datafile DbVersion
75243>>>>>//#ENDIF
75243>>>Use cDbUpdateLogFile.pkg
Including file: cDbUpdateLogFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateLogFile.pkg)
75243>>>>>//****************************************************************************
75243>>>>>// $Module type: Class
75243>>>>>// $Module name: cDbUpdateLogFile
75243>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75243>>>>>// Web-site    : http://www.rdctools.com
75243>>>>>// Created     : 2016-10-05 @ 18:58 (Military date format: YY-MM-DD)
75243>>>>>//
75243>>>>>// Description : This logic was moved from the cDbUpdateHandler class so that it would
75243>>>>>//               be easier to change to where errors/status messages are written/saved. As it is less likely
75243>>>>>//               that this class is to change; each developer can decide if the errors instead
75243>>>>>//               should be saved to a database table, or something entirely different.
75243>>>>>//               The default is to write the errors to a Ascii-file in the Data folder.
75243>>>>>//
75243>>>>>// $Rev History:
75243>>>>>//    2016-10-05  Module header created
75243>>>>>//****************************************************************************
75243>>>>>Use UI
75243>>>>>Use vWin32fh.pkg
75243>>>>>
75243>>>>>
75243>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
75243>>>>>
75243>>>>>Define CS_SuccessfulUpdate for "The database was updated successfully!"
75243>>>>>
75243>>>>>Class cDbUpdateLogFile is a cObject
75244>>>>>
75244>>>>>    Procedure Construct_Object
75246>>>>>        Forward Send Construct_Object
75248>>>>>
75248>>>>>        // Error handling:
75248>>>>>        Property tDbUpdateError[] paDbUpdateErrorArray
75249>>>>>        Property Integer piChannel -1
75250>>>>>
75250>>>>>        // This property is set by the cDbUpdateHandler object,
75250>>>>>        // when the update process starts.
75250>>>>>        Property DateTime pdtUpdateStart
75251>>>>>
75251>>>>>        // Gets set to False if the log contains data
75251>>>>>        Property Boolean pbEmptyLogFile True
75252>>>>>
75252>>>>>        // Gets set to True after the error log header text
75252>>>>>        // has been written.
75252>>>>>        Property Boolean pbHeaderWritten False
75253>>>>>
75253>>>>>        // If all activities should be logged- not just errors.
75253>>>>>        Property Boolean pbVerboseState False
75254>>>>>
75254>>>>>        // File name for the error log where all errors
75254>>>>>        // after a run is written to (appended).
75254>>>>>        // It is saved in the Data folder.
75254>>>>>        Property String psLogTextFile   "DUFUpdateLog.txt"
75255>>>>>        // If this property is set to "" in object code, the
75255>>>>>        // "shell" command parameter will be used to let Windows decide
75255>>>>>        // with which program to open the logfile.
75255>>>>>        Property String psEditorProgram ""
75256>>>>>
75256>>>>>        Property Boolean pbUseDataTableLog False
75257>>>>>
75257>>>>>        // If true an error will be written to file immediately when
75257>>>>>        // it occurs. This can be handy if a large update generates a lots
75257>>>>>        // of errors and the application crasches before finished, thus
75257>>>>>        // the errors will not be written.
75257>>>>>        Property Boolean pbQuickWrite True
75258>>>>>    End_Procedure
75259>>>>>
75259>>>>>    Procedure End_Construct_Object
75261>>>>>        Forward Send End_Construct_Object
75263>>>>>
75263>>>>>    End_Procedure
75264>>>>>
75264>>>>>    Procedure LogError Number nVersion Integer iError String sErrorText Integer iErrorLine Boolean bError Boolean bShortFormatIn
75266>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
75266>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
75268>>>>>        Boolean bShortFormat
75268>>>>>        Integer iSize
75268>>>>>        Handle hCurrentTable
75268>>>>>        Integer iCurrentField           
75268>>>>>        String sOrgErrorText sTableRootName
75268>>>>>        
75268>>>>>        Move False to bShortFormat
75269>>>>>        If (num_arguments > 5) Begin
75271>>>>>            Move bShortFormatIn to bShortFormat
75272>>>>>        End
75272>>>>>>
75272>>>>>        // Only do once.
75272>>>>>        If (pbHeaderWritten(Self) = False) Begin
75274>>>>>            Send WriteHeaderData
75275>>>>>            Set pbHeaderWritten to True
75276>>>>>        End
75276>>>>>>
75276>>>>>
75276>>>>>        Get Private.phCurrentTable to hCurrentTable  
75277>>>>>        Get Private.piCurrentField to iCurrentField  
75278>>>>>        If (iError > 0) Begin
75280>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hCurrentTable to sTableRootName
75283>>>>>            Get FetchErrorDescription iError to sOrgErrorText 
75284>>>>>        End
75284>>>>>>
75284>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
75285>>>>>        Move (SizeOfArray(DbUpdateErrorArray)) to iSize
75286>>>>>        Move nVersion       to DbUpdateErrorArray[iSize].nUpdateVersion
75287>>>>>        Move iError         to DbUpdateErrorArray[iSize].iError
75288>>>>>        Move iErrorLine     to DbUpdateErrorArray[iSize].iErrorLine
75289>>>>>        Move True           to DbUpdateErrorArray[iSize].bError  
75290>>>>>        Move sOrgErrorText  to DbUpdateErrorArray[iSize].sOrgErrorText
75291>>>>>        Move sErrorText     to DbUpdateErrorArray[iSize].sErrorText
75292>>>>>        Move hCurrentTable  to DbUpdateErrorArray[iSize].hTable            
75293>>>>>        Move sTableRootName to DbUpdateErrorArray[iSize].sTableRootName
75294>>>>>        Move iCurrentField  to DbUpdateErrorArray[iSize].iField  
75295>>>>>        Move bShortFormat   to DbUpdateErrorArray[iSize].bShortFormat
75296>>>>>
75296>>>>>        If (bError = False) Begin
75298>>>>>            Move False to DbUpdateErrorArray[iSize].bError
75299>>>>>        End
75299>>>>>>
75299>>>>>        Set paDbUpdateErrorArray to DbUpdateErrorArray
75300>>>>>
75300>>>>>        If (pbUseDataTableLog(Self) = True) Begin
75302>>>>>            If (pbQuickWrite(Self) = True) Begin
75304>>>>>                Send OnWriteRow_DataTable
75305>>>>>                // If we are writing error for error flush the
75305>>>>>                // error array when latest error has been written.
75305>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
75306>>>>>            End
75306>>>>>>
75306>>>>>            Procedure_Return
75307>>>>>        End
75307>>>>>>
75307>>>>>        Else Begin
75308>>>>>            If (pbQuickWrite(Self) = True) Begin
75310>>>>>                Send WriteErrorLog
75311>>>>>                // Flush the error log array
75311>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
75312>>>>>            End
75312>>>>>>
75312>>>>>        End
75312>>>>>>
75312>>>>>    End_Procedure   
75313>>>>>    
75313>>>>>    Function FetchErrorDescription Integer iError Returns String
75315>>>>>        String sErrorText         
75315>>>>>        Move "" to sErrorText
75316>>>>>        If (iError > 0) Begin
75318>>>>>            Move (Error_Text(Desktop, iError)) to sErrorText 
75319>>>>>        End
75319>>>>>>
75319>>>>>        Function_Return sErrorText
75320>>>>>    End_Function
75321>>>>>
75321>>>>>    // Hook procedure for writing header text prior starting the update work to
75321>>>>>    // a database table. This does nothing by default.
75321>>>>>    // Don't forget to Open your "error log table" first (!) as all
75321>>>>>    // tables have been closed at this stage. Put anything
75321>>>>>    // you want to indicate that the update process is just started.
75321>>>>>    Procedure OnWriteHeader_DataTable DateTime dtUpdateStart
75323>>>>>        Delegate Send OnErrorWriteHeader_DataTable dtUpdateStart
75325>>>>>    End_Procedure
75326>>>>>
75326>>>>>    Procedure OnWriteRow_DataTable
75328>>>>>        tDbUpdateError[] DbUpdateErrorArray
75328>>>>>        tDbUpdateError[] DbUpdateErrorArray
75329>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
75330>>>>>        If (SizeOfArray(DbUpdateErrorArray) > 0) Begin
75332>>>>>            Delegate Send OnErrorWriteRow_DataTable DbUpdateErrorArray
75334>>>>>        End
75334>>>>>>
75334>>>>>    End_Procedure
75335>>>>>
75335>>>>>    Function psLogTextFileWithPath Returns String
75337>>>>>        String sPath sFileName sFullFileName
75337>>>>>        
75337>>>>>        Get psDataPathFirstPart to sPath
75338>>>>>        Get psLogTextFile to sFileName
75339>>>>>        Move (sPath + sFileName) to sFullFileName
75340>>>>>        Function_Return sFullFileName
75341>>>>>    End_Function                     
75342>>>>>    
75342>>>>>    Procedure WriteHeaderData
75344>>>>>        String sFileName
75344>>>>>        Integer iCh iSize
75344>>>>>        Boolean bQuickWrite
75344>>>>>        DateTime dtUpdateStart
75344>>>>>
75344>>>>>        Move (CurrentDateTime()) to dtUpdateStart
75345>>>>>        If (pbUseDataTableLog(Self) = True) Begin
75347>>>>>            Send OnWriteHeader_DataTable dtUpdateStart
75348>>>>>            Procedure_Return
75349>>>>>        End
75349>>>>>>
75349>>>>>
75349>>>>>        Get piChannel to iCh
75350>>>>>        If (iCh < 0) Begin
75352>>>>>            Get Seq_New_Channel to iCh
75353>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75355>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
75356>>>>>>
75356>>>>>                Procedure_Return
75357>>>>>            End
75357>>>>>>
75357>>>>>            Set piChannel to iCh
75358>>>>>        End
75358>>>>>>
75358>>>>>
75358>>>>>        Get psLogTextFileWithPath to sFileName
75359>>>>>        Get vWin32_APIFileSize sFileName to iSize
75360>>>>>        Get pbQuickWrite to bQuickWrite
75361>>>>>        
75361>>>>>        If (bQuickWrite = True) Begin
75363>>>>>            Append_Output channel iCh sFileName
75365>>>>>                If (bQuickWrite = True) Begin
75367>>>>>                    If (iSize = 0) Begin
75369>>>>>                        Writeln channel iCh CS_DatabaseUpdateFramework
75372>>>>>                        Set pbEmptyLogFile to False
75373>>>>>                    End
75373>>>>>>
75373>>>>>                    Writeln channel iCh
75375>>>>>                    Writeln channel iCh ("Database Update Started:      " + String(dtUpdateStart))
75378>>>>>                End
75378>>>>>>
75378>>>>>            Close_Output channel iCh
75380>>>>>        End
75380>>>>>>
75380>>>>>    End_Procedure
75381>>>>>
75381>>>>>    // Returns the first datapath found in the psDataPath property.
75381>>>>>    // The returned path always ends with a "\"
75381>>>>>    Function psDataPathFirstPart Returns String
75383>>>>>        String sDataPath
75383>>>>>        Integer iCount
75383>>>>>
75383>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
75384>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
75385>>>>>        If (iCount > 1) Begin
75387>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
75388>>>>>        End
75388>>>>>>
75388>>>>>        If (sDataPath <> "") Begin
75390>>>>>            Get vFolderFormat sDataPath to sDataPath
75391>>>>>        End
75391>>>>>>
75391>>>>>
75391>>>>>        Function_Return sDataPath
75392>>>>>    End_Function
75393>>>>>
75393>>>>>    // Called from the cDbUpdateHandler object after all updates have been done.
75393>>>>>    Procedure WriteErrorLog
75395>>>>>        tDbUpdateError[] aDbUpdateErrorArray
75395>>>>>        tDbUpdateError[] aDbUpdateErrorArray
75396>>>>>        String sFileName sErrorNo sVersion sErrorText sText sRootName sOrgErrorText
75396>>>>>        Integer iCount iSize iCh iError iErrorLine iField
75396>>>>>        Boolean bUseDataTable bQuickWrite
75396>>>>>        DateTime dtUpdateStart dtUpdateEnd
75396>>>>>        TimeSpan tsElapsed
75396>>>>>        Number nVersion                                  
75396>>>>>        Handle hTable
75396>>>>>
75396>>>>>        If (pbHeaderWritten(Self) = False) Begin
75398>>>>>            Send WriteHeaderData
75399>>>>>            Set pbHeaderWritten to True
75400>>>>>        End
75400>>>>>>
75400>>>>>
75400>>>>>        Get pbUseDataTableLog to bUseDataTable
75401>>>>>        If (bUseDataTable = True) Begin
75403>>>>>            Send OnWriteRow_DataTable
75404>>>>>            Procedure_Return
75405>>>>>        End
75405>>>>>>
75405>>>>>
75405>>>>>        Get piChannel to iCh
75406>>>>>        If (iCh < 0) Begin
75408>>>>>            Get Seq_New_Channel to iCh
75409>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75411>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
75412>>>>>>
75412>>>>>                Procedure_Return
75413>>>>>            End
75413>>>>>>
75413>>>>>            Set piChannel to iCh
75414>>>>>        End
75414>>>>>>
75414>>>>>
75414>>>>>        Get psLogTextFileWithPath to sFileName
75415>>>>>
75415>>>>>        Get paDbUpdateErrorArray to aDbUpdateErrorArray
75416>>>>>        Move (SizeOfArray(aDbUpdateErrorArray)) to iSize
75417>>>>>        Decrement iSize
75418>>>>>
75418>>>>>        Get pdtUpdateStart to dtUpdateStart
75419>>>>>        If (IsNullDateTime(dtUpdateStart) = False) Begin
75421>>>>>            Move (CurrentDateTime()) to dtUpdateEnd
75422>>>>>            Move (dtUpdateEnd - dtUpdateStart) to tsElapsed
75423>>>>>        End
75423>>>>>>
75423>>>>>        Get pbQuickWrite to bQuickWrite
75424>>>>>
75424>>>>>        Append_Output channel iCh sFileName
75426>>>>>        If (bQuickWrite = True and iSize < 0) Begin
75428>>>>>            Writeln channel iCh ("Database Update Finished:  " + String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
75431>>>>>        End
75431>>>>>>
75431>>>>>        Else If (bQuickWrite = False) Begin
75434>>>>>            Writeln channel iCh
75436>>>>>            Writeln channel iCh ("Database Update Started:" * String(dtUpdateStart) * "and finished at:" * String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
75439>>>>>        End   
75439>>>>>>
75439>>>>>        If (iSize >= 0) Begin
75441>>>>>            If (aDbUpdateErrorArray[0].bShortFormat = False) Begin
75443>>>>>                Writeln channel iCh "[Err No:] [pnVersionNumber:] [Status Text:]"
75446>>>>>            End
75446>>>>>>
75446>>>>>        End
75446>>>>>>
75446>>>>>
75446>>>>>        For iCount from 0 to iSize  
75452>>>>>>
75452>>>>>            Move aDbUpdateErrorArray[iCount].iError         to iError
75453>>>>>            Move aDbUpdateErrorArray[iCount].nUpdateVersion to nVersion
75454>>>>>            Move aDbUpdateErrorArray[iCount].sErrorText     to sErrorText
75455>>>>>            Move aDbUpdateErrorArray[iCount].iErrorLine     to iErrorLine  
75456>>>>>            Move aDbUpdateErrorArray[iCount].hTable         to hTable
75457>>>>>            Move aDbUpdateErrorArray[iCount].sTableRootName to sRootName
75458>>>>>            Move aDbUpdateErrorArray[iCount].iField         to iField
75459>>>>>            
75459>>>>>            Get PadLeft (String(iError)) 8 to sErrorNo
75460>>>>>            If (aDbUpdateErrorArray[iCount].bError = True) Begin
75462>>>>>                Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
75463>>>>>                Move (sErrorNo + sVersion + "   " + sErrorText * "[ErrLine:" * String(iErrorLine) + "]" + "    (Table:" * sRootName * String(hTable) + "." + String(iField) + ")") to sText
75464>>>>>            End
75464>>>>>>
75464>>>>>            Else Begin
75465>>>>>                Get PadLeft (String(nVersion)) 27 to sVersion
75466>>>>>                Move (sVersion + "   " + sErrorText) to sText
75467>>>>>            End
75467>>>>>>
75467>>>>>            Writeln channel iCh sText
75470>>>>>            If (aDbUpdateErrorArray[iCount].sOrgErrorText <> "") Begin
75472>>>>>                Move ("   (" + aDbUpdateErrorArray[iCount].sOrgErrorText + ")") to sOrgErrorText
75473>>>>>                Move (Utf8ToAnsi(sOrgErrorText)) to sOrgErrorText       
75474>>>>>                Writeln channel iCh sOrgErrorText
75477>>>>>            End
75477>>>>>>
75477>>>>>            If (sText contains CS_SuccessfulUpdate) Begin
75479>>>>>                Writeln channel iCh
75481>>>>>            End
75481>>>>>>
75481>>>>>        Loop
75482>>>>>>
75482>>>>>        Close_Output channel iCh
75484>>>>>
75484>>>>>        Send Seq_Release_Channel iCh
75485>>>>>        Set piChannel to -1
75486>>>>>
75486>>>>>    End_Procedure
75487>>>>>
75487>>>>>    // The character to pad is optional. If nothing, spaces are used.
75487>>>>>    // Example:
75487>>>>>    // Move (PadLeft(45672,10,"0")) to sString -> "0000045672"
75487>>>>>    //  or:
75487>>>>>    // Move (PadLeft("Test",10)) to sString -> " Test"
75487>>>>>    // Courtesy of Pieter van Dieren. Collected from DAWs' Newsgroups.
75487>>>>>    Function PadLeft String sString Integer iLength String sOptChar Returns String
75489>>>>>        String sChar
75489>>>>>
75489>>>>>        If (Num_Arguments >= 3) Begin
75491>>>>>            Move sOptChar to sChar
75492>>>>>        End
75492>>>>>>
75492>>>>>        Else Begin
75493>>>>>            Move " " to sChar
75494>>>>>        End
75494>>>>>>
75494>>>>>
75494>>>>>        While (Length(sString) < iLength)
75498>>>>>            Move (sChar + sString) to sString
75499>>>>>        Loop
75500>>>>>>
75500>>>>>
75500>>>>>        Function_Return sString
75501>>>>>    End_Function
75502>>>>>
75502>>>>>    Procedure ShowErrorLog
75504>>>>>        String sPath sFileName sEditorProgram
75504>>>>>        Boolean bExists
75504>>>>>
75504>>>>>        Get psLogTextFileWithPath to sFileName
75505>>>>>        Get vFilePathExists sFileName to bExists
75506>>>>>        If (bExists = True) Begin
75508>>>>>            Get psEditorProgram to sEditorProgram
75509>>>>>            If (sEditorProgram <> "") Begin
75511>>>>>                Runprogram Background (psEditorProgram(Self)) (sPath + sFileName)
75512>>>>>            End
75512>>>>>>
75512>>>>>            Else Begin
75513>>>>>                Runprogram Shell Background sFileName
75514>>>>>            End
75514>>>>>>
75514>>>>>        End
75514>>>>>>
75514>>>>>        Else Begin
75515>>>>>            Send Info_Box (CS_DUF_LogFileNotFound + String(sFileName))
75516>>>>>        End
75516>>>>>>
75516>>>>>    End_Procedure
75517>>>>>
75517>>>>>End_Class
75518>>>Use cDbUpdateVersion.pkg
Including file: cDbUpdateVersion.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateVersion.pkg)
75518>>>>>//****************************************************************************
75518>>>>>// $Module type: Class
75518>>>>>// $Module name: cDbUpdateVersion
75518>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75518>>>>>// Web-site    : http://www.rdctools.com
75518>>>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
75518>>>>>//
75518>>>>>// Description : Child class to cDbUpdateHandler.
75518>>>>>//               Put an object of this class inside the global ghoDbUpdateHandler object.
75518>>>>>//               Set the pnVersionNumber to a version number.
75518>>>>>//               Inside the cDbUpdateVersion object put a "Use MyNewDbUpdatePackage.pkg"
75518>>>>>//               Add one cVersion object for each update of the database to the ghoDbUpdateHandler object.
75518>>>>>//               Place your code in the "OnUpdate" event that alters the database.
75518>>>>>//
75518>>>>>// $Rev History:
75518>>>>>//    2016-09-27  Module header created
75518>>>>>//****************************************************************************
75518>>>>>Use UI
75518>>>>>Use DUFLanguageConstants.inc
75518>>>>>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
75518>>>>>>>//****************************************************************************
75518>>>>>>>// $Module type: Class
75518>>>>>>>// $Module name: cDbUpdateFunctionLibrary
75518>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75518>>>>>>>// Web-site    : http://www.rdctools.com
75518>>>>>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
75518>>>>>>>//
75518>>>>>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
75518>>>>>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
75518>>>>>>>//               functions to make db changes to Sql databases with the DAW & Mertech drivers,
75518>>>>>>>//               with the help of Sql-scripts.
75518>>>>>>>//
75518>>>>>>>// $Rev History:
75518>>>>>>>//    2014-09-05  Module header created
75518>>>>>>>//
75518>>>>>>>//****************************************************************************
75518>>>>>>>Use cApplication.pkg
75518>>>>>>>Use seq_chnl.pkg
75518>>>>>>>Use GlobalFunctionsProcedures.pkg
75518>>>>>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
75518>>>>>>>Use Dfcursor.pkg
75518>>>>>>>Use DUFStatusPanel.pkg
75518>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
75518>>>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
75518>>>>>>>>>//
75518>>>>>>>>>// We need to create a mixin class for the library.
75518>>>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
75518>>>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
75518>>>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
75518>>>>>>>>>// Note: This class should _not_ have a construct_object defined.
75518>>>>>>>>>//
75518>>>>>>>>>Use VdfBase.pkg
75518>>>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files\DataFlex 20.1\Pkg\WinUuid.pkg)
75518>>>>>>>>>>>Use Unicode.Pkg
75518>>>>>>>>>>>
75518>>>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll ;    Pointer Uuid ;    Returns Integer
75519>>>>>>>>>>>
75519>>>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringW" Rpcrt4.dll ;    Pointer pUuid ;    Pointer lpUUIDString ;    Returns Integer
75520>>>>>>>>>>>
75520>>>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll ;    Pointer pUuid ;    Returns Integer
75521>>>>>>>>>>>
75521>>>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeW" Rpcrt4.dll ;    Pointer pStr ;    Returns Integer
75522>>>>>>>>>>>
75522>>>>>>>>>>>
75522>>>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
75522>>>>>>>>>>>Function RandomHexUUID Global Returns String
75524>>>>>>>>>>>    Pointer pUUID pUUIDStr
75524>>>>>>>>>>>    Integer iRetval iOffset iChar
75524>>>>>>>>>>>    String sUUID
75524>>>>>>>>>>>    
75524>>>>>>>>>>>    Move (Alloc(16)) to pUUID
75525>>>>>>>>>>>    
75525>>>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
75526>>>>>>>>>>>    
75526>>>>>>>>>>>    If (iRetval = 0) Begin
75528>>>>>>>>>>>        Move 0 to pUUIDStr
75529>>>>>>>>>>>        
75529>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75530>>>>>>>>>>>        If (iRetval = 0) Begin
75532>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75533>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75534>>>>>>>>>>>            
75534>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75535>>>>>>>>>>>        End
75535>>>>>>>>>>>>
75535>>>>>>>>>>>    End
75535>>>>>>>>>>>>
75535>>>>>>>>>>>    
75535>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
75536>>>>>>>>>>>    
75536>>>>>>>>>>>    Function_Return sUUID
75537>>>>>>>>>>>End_Function
75538>>>>>>>>>>>
75538>>>>>>>>>>>
75538>>>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
75538>>>>>>>>>>>Function SeqHexUUID Global Returns String
75540>>>>>>>>>>>    Pointer pUUID pUUIDStr
75540>>>>>>>>>>>    Integer iRetval iOffset iChar
75540>>>>>>>>>>>    String sUUID
75540>>>>>>>>>>>    
75540>>>>>>>>>>>    Move (Alloc(16)) to pUUID
75541>>>>>>>>>>>    
75541>>>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
75542>>>>>>>>>>>    
75542>>>>>>>>>>>    If (iRetval = 0) Begin
75544>>>>>>>>>>>        Move 0 to pUUIDStr
75545>>>>>>>>>>>        
75545>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75546>>>>>>>>>>>        If (iRetval = 0) Begin
75548>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75549>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75550>>>>>>>>>>>            
75550>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75551>>>>>>>>>>>        End
75551>>>>>>>>>>>>
75551>>>>>>>>>>>    End
75551>>>>>>>>>>>>
75551>>>>>>>>>>>    
75551>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
75552>>>>>>>>>>>    
75552>>>>>>>>>>>    Function_Return sUUID
75553>>>>>>>>>>>End_Function
75554>>>>>>>>>Use cli.pkg
75554>>>>>>>>>Use sql.pkg
75554>>>>>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files\DataFlex 20.1\Pkg\MSSqldrv.pkg)
75554>>>>>>>>>>>//     Package that declares MS SQL driver constants and functions.
75554>>>>>>>>>>>//     This package can be used by developers who want to add Data Access
75554>>>>>>>>>>>//     MS SQL Client specific code to a DataFlex application.
75554>>>>>>>>>>>
75554>>>>>>>>>>>Use Cli.pkg
75554>>>>>>>>>>>Use SQL.pkg
75554>>>>>>>>>>>
75554>>>>>>>>>>>//   Driver Indentification
75554>>>>>>>>>>>
75554>>>>>>>>>>>//   Error number constants
75554>>>>>>>>>>>
75554>>>>>>>>>>>
75554>>>>>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
75554>>>>>>>>>>>
75554>>>>>>>>>>>
75554>>>>>>>>>>>
75554>>>>>>>>>>>
75554>>>>>>>>>>>
75554>>>>>>>>>>>
75554>>>>>>>>>>>// SQL Server spcific types.
75554>>>>>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
75554>>>>>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
75554>>>>>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
75554>>>>>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
75554>>>>>>>>>>>
75554>>>>>>>>>>>// SQL Server spcific types.
75554>>>>>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
75554>>>>>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
75554>>>>>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
75554>>>>>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
75554>>>>>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
75554>>>>>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
75554>>>>>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
75554>>>>>>>>>>>
75554>>>>>>>>>>>
75554>>>>>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
75554>>>>>>>>>>>//
75554>>>>>>>>>>>//     Setup a constraint for a file.
75554>>>>>>>>>>>
75554>>>>>>>>>>>
75554>>>>>>>>>>>Class cMSSQLHandler is a cCLIHandler
75555>>>>>>>>>>>    
75555>>>>>>>>>>>    Procedure Construct_Object
75557>>>>>>>>>>>        Forward Send Construct_Object
75559>>>>>>>>>>>        
75559>>>>>>>>>>>        Set psDriverID to MSSQLDRV_ID
75560>>>>>>>>>>>    End_Procedure
75561>>>>>>>>>>>    
75561>>>>>>>>>>>    
75561>>>>>>>>>>>    
75561>>>>>>>>>>>    //   Extract the list from the out connect string.
75561>>>>>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
75563>>>>>>>>>>>        String  sItem
75563>>>>>>>>>>>        Integer iStart
75563>>>>>>>>>>>        Integer iEnd
75563>>>>>>>>>>>        
75563>>>>>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
75566>>>>>>>>>>>        
75566>>>>>>>>>>>        Send Delete_Data to hoStore
75567>>>>>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
75568>>>>>>>>>>>        While (iStart > 0)
75572>>>>>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
75573>>>>>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
75576>>>>>>>>>>>            Else Begin
75577>>>>>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
75578>>>>>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
75579>>>>>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
75582>>>>>>>>>>>                
75582>>>>>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
75585>>>>>>>>>>>                
75585>>>>>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
75588>>>>>>>>>>>            End
75588>>>>>>>>>>>>
75588>>>>>>>>>>>        Loop
75589>>>>>>>>>>>>
75589>>>>>>>>>>>        
75589>>>>>>>>>>>        Function_Return (Item_Count(hoStore))
75590>>>>>>>>>>>    End_Procedure
75591>>>>>>>>>>>    
75591>>>>>>>>>>>    
75591>>>>>>>>>>>    
75591>>>>>>>>>>>    //   Call the driver's browse connect function
75591>>>>>>>>>>>    Function BrowseConnect String sInConnStr Returns String
75593>>>>>>>>>>>        String  sDriver
75593>>>>>>>>>>>        String  sOutConnStr
75593>>>>>>>>>>>        Integer iArg
75593>>>>>>>>>>>        Integer iRetval
75593>>>>>>>>>>>        
75593>>>>>>>>>>>        Get psDriverID to sDriver
75594>>>>>>>>>>>        If (sDriver <> "") Begin
75596>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75597>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75602>>>>>>>>>>>        End
75602>>>>>>>>>>>>
75602>>>>>>>>>>>        
75602>>>>>>>>>>>        Function_Return sOutConnStr
75603>>>>>>>>>>>    End_Function// BrowseConnect
75604>>>>>>>>>>>    
75604>>>>>>>>>>>    
75604>>>>>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
75606>>>>>>>>>>>        String  sDriver
75606>>>>>>>>>>>        String  sOutConnStr
75606>>>>>>>>>>>        Integer iArg
75606>>>>>>>>>>>        Integer iRetval
75606>>>>>>>>>>>        
75606>>>>>>>>>>>        Move 1 to iArg // Browses only local
75607>>>>>>>>>>>        
75607>>>>>>>>>>>        Get psDriverID to sDriver
75608>>>>>>>>>>>        If (sDriver <> "") Begin
75610>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75611>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75616>>>>>>>>>>>        End
75616>>>>>>>>>>>>
75616>>>>>>>>>>>        
75616>>>>>>>>>>>        Function_Return sOutConnStr
75617>>>>>>>>>>>    End_Function// BrowseConnect
75618>>>>>>>>>>>    
75618>>>>>>>>>>>    
75618>>>>>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
75620>>>>>>>>>>>        
75620>>>>>>>>>>>        String  sServerList
75620>>>>>>>>>>>        Integer iNumServers
75620>>>>>>>>>>>        Integer iDriver
75620>>>>>>>>>>>        Integer iClientVersion
75620>>>>>>>>>>>        String  sDriver
75620>>>>>>>>>>>        
75620>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
75621>>>>>>>>>>>        
75621>>>>>>>>>>>        If (iDriver) Begin
75623>>>>>>>>>>>            
75623>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
75626>>>>>>>>>>>            
75626>>>>>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
75627>>>>>>>>>>>            
75627>>>>>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
75628>>>>>>>>>>>            If (iNetworkLocal = 0) Begin
75630>>>>>>>>>>>                Get BrowseConnect sDriver to sServerList
75631>>>>>>>>>>>            End
75631>>>>>>>>>>>>
75631>>>>>>>>>>>            Else Begin
75632>>>>>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
75633>>>>>>>>>>>            End
75633>>>>>>>>>>>>
75633>>>>>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
75634>>>>>>>>>>>        End
75634>>>>>>>>>>>>
75634>>>>>>>>>>>        
75634>>>>>>>>>>>        Function_Return iNumServers
75635>>>>>>>>>>>        
75635>>>>>>>>>>>    End_Function
75636>>>>>>>>>>>    
75636>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
75636>>>>>>>>>>>    //   This function will return all SQL Server instances on the network.
75636>>>>>>>>>>>    //   This may take a long time.
75636>>>>>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
75636>>>>>>>>>>>    Function EnumerateServers Returns Integer
75638>>>>>>>>>>>        
75638>>>>>>>>>>>        Integer iNumServers
75638>>>>>>>>>>>        Integer iNetworkLocal
75638>>>>>>>>>>>        
75638>>>>>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
75639>>>>>>>>>>>        
75639>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75640>>>>>>>>>>>        
75640>>>>>>>>>>>        Function_Return iNumServers
75641>>>>>>>>>>>        
75641>>>>>>>>>>>    End_Function
75642>>>>>>>>>>>    
75642>>>>>>>>>>>    
75642>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
75642>>>>>>>>>>>    //   This function will return only return SQL Server instance on the local machine
75642>>>>>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
75642>>>>>>>>>>>    Function EnumerateServersLocal Returns Integer
75644>>>>>>>>>>>        
75644>>>>>>>>>>>        Integer iNumServers
75644>>>>>>>>>>>        Integer iNetworkLocal
75644>>>>>>>>>>>        
75644>>>>>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
75645>>>>>>>>>>>        
75645>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75646>>>>>>>>>>>        
75646>>>>>>>>>>>        Function_Return iNumServers
75647>>>>>>>>>>>        
75647>>>>>>>>>>>    End_Function
75648>>>>>>>>>>>    
75648>>>>>>>>>>>    
75648>>>>>>>>>>>    
75648>>>>>>>>>>>    //   Enumerate database in a given server.
75648>>>>>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
75650>>>>>>>>>>>        Integer hoSQL
75650>>>>>>>>>>>        String  sConnect
75650>>>>>>>>>>>        String  sDatabase
75650>>>>>>>>>>>        Integer hdbc
75650>>>>>>>>>>>        Integer hstmt
75650>>>>>>>>>>>        Integer iFetchResult
75650>>>>>>>>>>>        
75650>>>>>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
75653>>>>>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
75656>>>>>>>>>>>        
75656>>>>>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
75659>>>>>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
75661>>>>>>>>>>>        
75661>>>>>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
75663>>>>>>>>>>>            Move Current_Object to hoSQL
75664>>>>>>>>>>>        End_Object
75665>>>>>>>>>>>        
75665>>>>>>>>>>>        If (hoSQL <> 0) Begin
75667>>>>>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
75668>>>>>>>>>>>            If (hdbc <> 0) Begin
75670>>>>>>>>>>>                Get SQLOpen of hdbc to hstmt
75671>>>>>>>>>>>                If (hstmt <> 0) Begin
75673>>>>>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
75673>>>>>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
75673>>>>>>>>>>>                    //   approach in case meta data might change, the stored procedure will
75673>>>>>>>>>>>                    //   stay the same.
75673>>>>>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
75674>>>>>>>>>>>                    Send SQLCall to hstmt
75675>>>>>>>>>>>                    Repeat
75675>>>>>>>>>>>>
75675>>>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
75676>>>>>>>>>>>                        If (iFetchResult <> 0) Begin
75678>>>>>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
75679>>>>>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
75680>>>>>>>>>>>                        End
75680>>>>>>>>>>>>
75680>>>>>>>>>>>                    Until (iFetchResult = 0)
75682>>>>>>>>>>>                    
75682>>>>>>>>>>>                    Send SQLClose to hstmt
75683>>>>>>>>>>>                End
75683>>>>>>>>>>>>
75683>>>>>>>>>>>                Send SQLDisconnect to hdbc
75684>>>>>>>>>>>            End
75684>>>>>>>>>>>>
75684>>>>>>>>>>>        End
75684>>>>>>>>>>>>
75684>>>>>>>>>>>        Send Destroy_Object to hoSQL
75685>>>>>>>>>>>        
75685>>>>>>>>>>>        Function_Return (Item_Count(Current_Object))
75686>>>>>>>>>>>    End_Function
75687>>>>>>>>>>>    
75687>>>>>>>>>>>    
75687>>>>>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
75689>>>>>>>>>>>        
75689>>>>>>>>>>>        String  sSqlServerClientVersionName
75689>>>>>>>>>>>        
75689>>>>>>>>>>>        
75689>>>>>>>>>>>        Case Begin
75689>>>>>>>>>>>            
75689>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
75691>>>>>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
75692>>>>>>>>>>>                Case Break
75693>>>>>>>>>>>                
75693>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
75696>>>>>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
75697>>>>>>>>>>>                Case Break
75698>>>>>>>>>>>            
75698>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
75701>>>>>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
75702>>>>>>>>>>>                Case Break
75703>>>>>>>>>>>            
75703>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
75706>>>>>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
75707>>>>>>>>>>>                Case Break
75708>>>>>>>>>>>            
75708>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
75711>>>>>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
75712>>>>>>>>>>>                Case Break
75713>>>>>>>>>>>            
75713>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
75716>>>>>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
75717>>>>>>>>>>>                Case Break
75718>>>>>>>>>>>            
75718>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
75721>>>>>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
75722>>>>>>>>>>>                Case Break
75723>>>>>>>>>>>            
75723>>>>>>>>>>>            Case Else
75723>>>>>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
75724>>>>>>>>>>>                
75724>>>>>>>>>>>        Case End
75724>>>>>>>>>>>        
75724>>>>>>>>>>>        
75724>>>>>>>>>>>        Function_Return sSqlServerClientVersionName
75725>>>>>>>>>>>        
75725>>>>>>>>>>>    End_Function
75726>>>>>>>>>>>
75726>>>>>>>>>>>
75726>>>>>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
75728>>>>>>>>>>>        
75728>>>>>>>>>>>        String  sSqlServerClientDriverName
75728>>>>>>>>>>>        
75728>>>>>>>>>>>        Case Begin
75728>>>>>>>>>>>            
75728>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
75730>>>>>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
75731>>>>>>>>>>>                Case Break
75732>>>>>>>>>>>                
75732>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
75735>>>>>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
75736>>>>>>>>>>>                Case Break
75737>>>>>>>>>>>            
75737>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
75740>>>>>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
75741>>>>>>>>>>>                Case Break
75742>>>>>>>>>>>            
75742>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
75745>>>>>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
75746>>>>>>>>>>>                Case Break
75747>>>>>>>>>>>            
75747>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
75750>>>>>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
75751>>>>>>>>>>>                Case Break
75752>>>>>>>>>>>            
75752>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
75755>>>>>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
75756>>>>>>>>>>>                Case Break
75757>>>>>>>>>>>            
75757>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
75760>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
75761>>>>>>>>>>>                Case Break
75762>>>>>>>>>>>            
75762>>>>>>>>>>>            Case Else
75762>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
75763>>>>>>>>>>>                
75763>>>>>>>>>>>        Case End
75763>>>>>>>>>>>        
75763>>>>>>>>>>>        
75763>>>>>>>>>>>        Function_Return sSqlServerClientDriverName
75764>>>>>>>>>>>        
75764>>>>>>>>>>>    End_Function
75765>>>>>>>>>>>    
75765>>>>>>>>>>>    
75765>>>>>>>>>>>End_Class
75766>>>>>>>>>>>
75766>>>>>>>>>>>
75766>>>>>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files\DataFlex 20.1\Pkg\db2_drv.pkg)
75766>>>>>>>>>>>// DB2_DRV.PKG                                                          
75766>>>>>>>>>>>//   Package that declares DB2 driver constants and functions.          
75766>>>>>>>>>>>//   This package can be used by developers who want to add DB2 driver  
75766>>>>>>>>>>>//   specific code to a DataFlex application.                           
75766>>>>>>>>>>>
75766>>>>>>>>>>>Use Cli.pkg
75766>>>>>>>>>>>
75766>>>>>>>>>>>// Driver attributes
75766>>>>>>>>>>>
75766>>>>>>>>>>>
75766>>>>>>>>>>>// Driver Indentification
75766>>>>>>>>>>>
75766>>>>>>>>>>>// Error number constants
75766>>>>>>>>>>>
75766>>>>>>>>>>>// Call driver function identifiers
75766>>>>>>>>>>>
75766>>>>>>>>>>>// DB2 specific data types
75766>>>>>>>>>>>Define SQL_CLOB           for   (-99)
75766>>>>>>>>>>>Define SQL_BLOB           for   (-98)
75766>>>>>>>>>>>Define SQL_XML            for   (-370)
75766>>>>>>>>>>>// DB2 Graphic types are Unicode types
75766>>>>>>>>>>>Define SQL_GRAPHIC        for   (-95)
75766>>>>>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
75766>>>>>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
75766>>>>>>>>>>>Define SQL_DBCLOB         for   (-350)
75766>>>>>>>>>>>
75766>>>>>>>>>>>
75766>>>>>>>>>>>// Extra DB2 commands
75766>>>>>>>>>>>
75766>>>>>>>>>>>
75766>>>>>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
75766>>>>>>>>>>>//   Setup a constraint for a file.                                     
75766>>>>>>>>>>>
75766>>>>>>>>>>>
75766>>>>>>>>>>>
75766>>>>>>>>>>>Class cDB2Handler is a cCLIHandler
75767>>>>>>>>>>>    
75767>>>>>>>>>>>    Procedure Construct_Object
75769>>>>>>>>>>>        Forward Send Construct_Object
75771>>>>>>>>>>>        
75771>>>>>>>>>>>        Set psDriverID to DB2_DRV_ID
75772>>>>>>>>>>>    End_Procedure
75773>>>>>>>>>>>    
75773>>>>>>>>>>>    
75773>>>>>>>>>>>    
75773>>>>>>>>>>>    // Reset the datasource list to the beginning
75773>>>>>>>>>>>    Procedure SeedDataSources
75775>>>>>>>>>>>        String  sDriver
75775>>>>>>>>>>>        String  sVoid
75775>>>>>>>>>>>        Integer iRetval
75775>>>>>>>>>>>        
75775>>>>>>>>>>>        Get psDriverID to sDriver
75776>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
75783>>>>>>>>>>>    End_Procedure
75784>>>>>>>>>>>    
75784>>>>>>>>>>>    
75784>>>>>>>>>>>    
75784>>>>>>>>>>>    // Call the driver's data sources function
75784>>>>>>>>>>>    Function DataSources Returns String
75786>>>>>>>>>>>        String  sDriver
75786>>>>>>>>>>>        String  sDataSource
75786>>>>>>>>>>>        String  sDescription
75786>>>>>>>>>>>        Integer iLength
75786>>>>>>>>>>>        Integer iRetval
75786>>>>>>>>>>>        
75786>>>>>>>>>>>        Get psDriverID to sDriver
75787>>>>>>>>>>>        If (sDriver <> "") Begin
75789>>>>>>>>>>>            Move 8192 to iLength
75790>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
75791>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
75792>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
75797>>>>>>>>>>>        End
75797>>>>>>>>>>>>
75797>>>>>>>>>>>        
75797>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," *  sDescription, "")))
75800>>>>>>>>>>>        Else ;            Function_Return ""
75802>>>>>>>>>>>    End_Function
75803>>>>>>>>>>>    
75803>>>>>>>>>>>End_Class
75804>>>>>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files\DataFlex 20.1\Pkg\odbc_drv.pkg)
75804>>>>>>>>>>>//   Package that declares ODBC driver constants and functions.         
75804>>>>>>>>>>>//   This package can be used by developers who want to add Data Access 
75804>>>>>>>>>>>//   ODBC Client specific code to a DataFlex application.               
75804>>>>>>>>>>>
75804>>>>>>>>>>>Use Cli.pkg
75804>>>>>>>>>>>
75804>>>>>>>>>>>// Driver Indentification
75804>>>>>>>>>>>
75804>>>>>>>>>>>// Error number constants
75804>>>>>>>>>>>
75804>>>>>>>>>>>// Call driver function identifiers
75804>>>>>>>>>>>
75804>>>>>>>>>>>Class cODBCHandler is a cCLIHandler
75805>>>>>>>>>>>    
75805>>>>>>>>>>>    Procedure Construct_Object
75807>>>>>>>>>>>        Forward Send Construct_Object
75809>>>>>>>>>>>        
75809>>>>>>>>>>>        Set psDriverID to ODBC_DRV_ID
75810>>>>>>>>>>>    End_Procedure
75811>>>>>>>>>>>    
75811>>>>>>>>>>>    
75811>>>>>>>>>>>    
75811>>>>>>>>>>>    // Setup the type of data sources returned by the datasources function
75811>>>>>>>>>>>    Procedure Set DataSourceType Integer iNewType
75813>>>>>>>>>>>        String  sDriver
75813>>>>>>>>>>>        String  sVoid
75813>>>>>>>>>>>        Integer iRetval
75813>>>>>>>>>>>        
75813>>>>>>>>>>>        Get psDriverID to sDriver
75814>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
75821>>>>>>>>>>>    End_Procedure
75822>>>>>>>>>>>    
75822>>>>>>>>>>>    
75822>>>>>>>>>>>    // Call the driver's data sources function
75822>>>>>>>>>>>    Function DataSources Returns String
75824>>>>>>>>>>>        String  sDriver
75824>>>>>>>>>>>        String  sDataSource
75824>>>>>>>>>>>        String  sDescription
75824>>>>>>>>>>>        Integer iLength
75824>>>>>>>>>>>        Integer iRetval
75824>>>>>>>>>>>        
75824>>>>>>>>>>>        Get psDriverID to sDriver
75825>>>>>>>>>>>        If (sDriver <> "") Begin
75827>>>>>>>>>>>            Move 8192 to iLength
75828>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
75829>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
75830>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
75835>>>>>>>>>>>        End
75835>>>>>>>>>>>>
75835>>>>>>>>>>>        
75835>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," * sDescription, "")))
75838>>>>>>>>>>>        Else ;            Function_Return ""
75840>>>>>>>>>>>    End_Function
75841>>>>>>>>>>>    
75841>>>>>>>>>>>End_Class
75842>>>>>>>>>>>
75842>>>>>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files\DataFlex 20.1\Pkg\DFBTRDRV.PKG)
75842>>>>>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
75842>>>>>>>>>>>// Notice      : This package contains constants and commands, used to call
75842>>>>>>>>>>>//               specific functions in the DFBTRDRV.
75842>>>>>>>>>>>Use Ui
75842>>>>>>>>>>>//
75842>>>>>>>>>>>// Driver Indentification
75842>>>>>>>>>>>//
75842>>>>>>>>>>>
75842>>>>>>>>>>>// Driver attributes
75842>>>>>>>>>>>//
75842>>>>>>>>>>>// Call_Driver functions ID's
75842>>>>>>>>>>>//
75842>>>>>>>>>>>//
75842>>>>>>>>>>>// DFBTRFN_CONVERT_FILE options
75842>>>>>>>>>>>//
75842>>>>>>>>>>>
75842>>>>>>>>>>>//
75842>>>>>>>>>>>// DFBTRFN_SET_OWNER options
75842>>>>>>>>>>>//
75842>>>>>>>>>>>
75842>>>>>>>>>>>//
75842>>>>>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
75842>>>>>>>>>>>//
75842>>>>>>>>>>>
75842>>>>>>>>>>>
75842>>>>>>>>>>>//
75842>>>>>>>>>>>// Command to create all vars which may be needed
75842>>>>>>>>>>>// in other commands.
75842>>>>>>>>>>>//
75842>>>>>>>>>>>
75842>>>>>>>>>>>
75842>>>>>>>>>>>
75842>>>>>>>>>>>//
75842>>>>>>>>>>>// Command to set the owner of a Btrieve file.
75842>>>>>>>>>>>// File must have been opened.
75842>>>>>>>>>>>// Filenumber needs to be passed.
75842>>>>>>>>>>>// To clear set the owner to "".
75842>>>>>>>>>>>// Examples:
75842>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
75842>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
75842>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
75842>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
75842>>>>>>>>>>>// To clear:
75842>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
75842>>>>>>>>>>>//
75842>>>>>>>>>>>
75842>>>>>>>>>>>
75842>>>>>>>>>>>
75842>>>>>>>>>>>//
75842>>>>>>>>>>>// Command to parse DFBTR_SET_OWNVER
75842>>>>>>>>>>>// options.
75842>>>>>>>>>>>//
75842>>>>>>>>>>>
75842>>>>>>>>>>>
75842>>>>>>>>>>>
75842>>>>>>>>>>>//
75842>>>>>>>>>>>// Command to parse for Callback
75842>>>>>>>>>>>//
75842>>>>>>>>>>>
75842>>>>>>>>>>>
75842>>>>>>>>>>>
75842>>>>>>>>>>>//
75842>>>>>>>>>>>// Command to clear the owner of a Btrieve file.
75842>>>>>>>>>>>// File must have been opened.
75842>>>>>>>>>>>// Filenumber needs to be passed.
75842>>>>>>>>>>>// Examples:
75842>>>>>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
75842>>>>>>>>>>>//
75842>>>>>>>>>>>
75842>>>>>>>>>>>
75842>>>>>>>>>>>
75842>>>>>>>>>>>//
75842>>>>>>>>>>>// Command to add a owner name to the internal list of ownernames
75842>>>>>>>>>>>// which will be tries when opening files.
75842>>>>>>>>>>>//
75842>>>>>>>>>>>
75842>>>>>>>>>>>
75842>>>>>>>>>>>
75842>>>>>>>>>>>//
75842>>>>>>>>>>>// Command to remove all owners from the internal list of ownernames
75842>>>>>>>>>>>//
75842>>>>>>>>>>>
75842>>>>>>>>>>>
75842>>>>>>>>>>>//
75842>>>>>>>>>>>// Command to set the owner name to be used when opening the DDF files.
75842>>>>>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
75842>>>>>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
75842>>>>>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
75842>>>>>>>>>>>//
75842>>>>>>>>>>>
75842>>>>>>>>>>>//
75842>>>>>>>>>>>// Command to change the transaction type.
75842>>>>>>>>>>>// Valid types are:
75842>>>>>>>>>>>//     DFBTRTT_NONE
75842>>>>>>>>>>>//     DFBTRTT_EXCLUSIVE
75842>>>>>>>>>>>//     DFBTRTT_CONCURRENT
75842>>>>>>>>>>>//
75842>>>>>>>>>>>//
75842>>>>>>>>>>>
75842>>>>>>>>>>>
75842>>>>>>>>>>>
75842>>>>>>>>>>>//
75842>>>>>>>>>>>// Command to get the current transaction type.
75842>>>>>>>>>>>//
75842>>>>>>>>>>>
75842>>>>>>>>>>>//
75842>>>>>>>>>>>// Command to set explicit_locking
75842>>>>>>>>>>>//
75842>>>>>>>>>>>
75842>>>>>>>>>>>//
75842>>>>>>>>>>>// Command to get explicit locking
75842>>>>>>>>>>>//
75842>>>>>>>>>>>
75842>>>>>>>>>>>//
75842>>>>>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
75842>>>>>>>>>>>//
75842>>>>>>>>>>>
75842>>>>>>>>>>>//
75842>>>>>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
75842>>>>>>>>>>>//
75842>>>>>>>>>>>
75842>>>>>>>>>>>// Purpose: An instance of this class can be used as a broker object to
75842>>>>>>>>>>>//          call several Dfbtrdrv releated methods.
75842>>>>>>>>>>>
75842>>>>>>>>>>>Class cDFBtrDrvHandler is an Array
75843>>>>>>>>>>>    
75843>>>>>>>>>>>    Procedure Construct_Object Integer iImage
75845>>>>>>>>>>>        Forward Send Construct_object iImage
75847>>>>>>>>>>>        
75847>>>>>>>>>>>        Property String  psDriverID "DFBTRDRV"
75848>>>>>>>>>>>    End_Procedure
75849>>>>>>>>>>>    
75849>>>>>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
75849>>>>>>>>>>>    //
75849>>>>>>>>>>>    
75849>>>>>>>>>>>    Function CKRevision Returns String
75851>>>>>>>>>>>        String  sDriverID
75851>>>>>>>>>>>        String  sRevision
75851>>>>>>>>>>>        String  sVoid
75851>>>>>>>>>>>        Integer iRetval
75851>>>>>>>>>>>        
75851>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75851>>>>>>>>>>>        // This error would otherwise be raised when we have an older
75851>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
75851>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
75852>>>>>>>>>>>        Get psDriverID to sDriverID
75853>>>>>>>>>>>        Move (Repeat(" ", 255)) to sRevision
75854>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
75859>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
75860>>>>>>>>>>>        If (Trim(sRevision) = "") Begin
75862>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
75862>>>>>>>>>>>            Move "0.0.0.0" to sRevision
75863>>>>>>>>>>>        End
75863>>>>>>>>>>>>
75863>>>>>>>>>>>        Function_Return sRevision
75864>>>>>>>>>>>    End_Function
75865>>>>>>>>>>>    
75865>>>>>>>>>>>    Function CkUsesUri Returns Integer
75867>>>>>>>>>>>        String  sDriverID
75867>>>>>>>>>>>        String  sVoid1
75867>>>>>>>>>>>        String  sVoid2
75867>>>>>>>>>>>        Integer iRetval
75867>>>>>>>>>>>        
75867>>>>>>>>>>>        Get psDriverID to sDriverID
75868>>>>>>>>>>>        
75868>>>>>>>>>>>        Move 0 to iRetval
75869>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75869>>>>>>>>>>>        // This error would otherwise be raised when we have an older
75869>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
75869>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
75870>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
75875>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
75876>>>>>>>>>>>        
75876>>>>>>>>>>>        Function_Return iRetval
75877>>>>>>>>>>>    End_Function
75878>>>>>>>>>>>    
75878>>>>>>>>>>>    
75878>>>>>>>>>>>    
75878>>>>>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
75878>>>>>>>>>>>    //
75878>>>>>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
75878>>>>>>>>>>>    //
75878>>>>>>>>>>>    
75878>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
75880>>>>>>>>>>>        Integer iPartRev
75880>>>>>>>>>>>        Integer iCurrentPart
75880>>>>>>>>>>>        Integer iSeparatorPos
75880>>>>>>>>>>>        
75880>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
75883>>>>>>>>>>>        
75883>>>>>>>>>>>        Move 0 to iCurrentPart
75884>>>>>>>>>>>        Repeat
75884>>>>>>>>>>>>
75884>>>>>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
75885>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
75887>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
75888>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
75889>>>>>>>>>>>                Increment iCurrentPart
75890>>>>>>>>>>>            End
75890>>>>>>>>>>>>
75890>>>>>>>>>>>            Else If (sRevision <> "") Begin
75893>>>>>>>>>>>                Move sRevision to iPartRev
75894>>>>>>>>>>>                Move "" to sRevision
75895>>>>>>>>>>>                Increment iCurrentPart
75896>>>>>>>>>>>            End
75896>>>>>>>>>>>>
75896>>>>>>>>>>>            Else ;                Move -1 to iPartRev
75898>>>>>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
75900>>>>>>>>>>>        
75900>>>>>>>>>>>        Function_Return iPartRev
75901>>>>>>>>>>>    End_Function
75902>>>>>>>>>>>    
75902>>>>>>>>>>>    
75902>>>>>>>>>>>    
75902>>>>>>>>>>>    //
75902>>>>>>>>>>>    //  Returns the major revision of the CK
75902>>>>>>>>>>>    //
75902>>>>>>>>>>>    
75902>>>>>>>>>>>    Function CKMajorRevision Returns Integer
75904>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
75905>>>>>>>>>>>    End_Function
75906>>>>>>>>>>>    
75906>>>>>>>>>>>    
75906>>>>>>>>>>>    
75906>>>>>>>>>>>    //  Returns the minor revision of the CK
75906>>>>>>>>>>>    //
75906>>>>>>>>>>>    
75906>>>>>>>>>>>    Function CKMinorRevision Returns Integer
75908>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
75909>>>>>>>>>>>    End_Function
75910>>>>>>>>>>>    
75910>>>>>>>>>>>    
75910>>>>>>>>>>>    //  Returns the release revision of the CK
75910>>>>>>>>>>>    //
75910>>>>>>>>>>>    
75910>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
75912>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
75913>>>>>>>>>>>    End_Function
75914>>>>>>>>>>>    
75914>>>>>>>>>>>    
75914>>>>>>>>>>>    //  Returns the major revision of the CK
75914>>>>>>>>>>>    //
75914>>>>>>>>>>>    
75914>>>>>>>>>>>    Function CKBuildRevision Returns Integer
75916>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
75917>>>>>>>>>>>    End_Function
75918>>>>>>>>>>>    
75918>>>>>>>>>>>    
75918>>>>>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
75918>>>>>>>>>>>    //
75918>>>>>>>>>>>    
75918>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
75920>>>>>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
75923>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
75926>>>>>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
75929>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
75932>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
75935>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
75939>>>>>>>>>>>            End
75939>>>>>>>>>>>>
75939>>>>>>>>>>>        End
75939>>>>>>>>>>>>
75939>>>>>>>>>>>        
75939>>>>>>>>>>>        Function_Return (False)
75940>>>>>>>>>>>    End_Function
75941>>>>>>>>>>>    
75941>>>>>>>>>>>    //   Functions to query the Pervasive.SQL version:
75941>>>>>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
75941>>>>>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
75941>>>>>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
75941>>>>>>>>>>>    //
75941>>>>>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
75941>>>>>>>>>>>    //   in the following format:
75941>>>>>>>>>>>    //       <version>.<revision>.<type>
75941>>>>>>>>>>>    //   possible values for <type>:
75941>>>>>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
75941>>>>>>>>>>>    //         server using Workgroup authentication mode
75941>>>>>>>>>>>    //       C for client cache engine
75941>>>>>>>>>>>    //       D for DOS workstation
75941>>>>>>>>>>>    //       N for client Requester
75941>>>>>>>>>>>    //       S for NetWare server
75941>>>>>>>>>>>    //       T for 32-bit Windows server engine
75941>>>>>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
75941>>>>>>>>>>>    //
75941>>>>>>>>>>>    //   example:
75941>>>>>>>>>>>    //       8.50.T
75941>>>>>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
75941>>>>>>>>>>>    //   32-bits Windows server.
75941>>>>>>>>>>>    //
75941>>>>>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
75941>>>>>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
75941>>>>>>>>>>>    //
75941>>>>>>>>>>>    //   If the version information is not available or can not be obtained
75941>>>>>>>>>>>    //   the functions will return "0.0.0"
75941>>>>>>>>>>>    
75941>>>>>>>>>>>    //  Returns the version information of the
75941>>>>>>>>>>>    //           Pervasive.SQL Client requester.
75941>>>>>>>>>>>    
75941>>>>>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
75943>>>>>>>>>>>        
75943>>>>>>>>>>>        String  sDriverID
75943>>>>>>>>>>>        String  sVersion
75943>>>>>>>>>>>        String  sVoid
75943>>>>>>>>>>>        Integer iRetval
75943>>>>>>>>>>>        
75943>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75943>>>>>>>>>>>        // This error would otherwise be raised when we have an older
75943>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
75943>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
75944>>>>>>>>>>>        Get psDriverID to sDriverID
75945>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
75946>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
75951>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
75952>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
75954>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
75954>>>>>>>>>>>            Move "0.0.0" to sVersion
75955>>>>>>>>>>>        End
75955>>>>>>>>>>>>
75955>>>>>>>>>>>        Function_Return sVersion
75956>>>>>>>>>>>    End_Function
75957>>>>>>>>>>>    
75957>>>>>>>>>>>    //           Pervasive.SQL Engine
75957>>>>>>>>>>>    
75957>>>>>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
75959>>>>>>>>>>>        
75959>>>>>>>>>>>        String  sDriverID
75959>>>>>>>>>>>        String  sVersion
75959>>>>>>>>>>>        String  sVoid
75959>>>>>>>>>>>        Integer iRetval
75959>>>>>>>>>>>        
75959>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75959>>>>>>>>>>>        // This error would otherwise be raised when we have an older
75959>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
75959>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
75960>>>>>>>>>>>        Get psDriverID to sDriverID
75961>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
75962>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
75967>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
75968>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
75970>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
75970>>>>>>>>>>>            Move "0.0.0" to sVersion
75971>>>>>>>>>>>        End
75971>>>>>>>>>>>>
75971>>>>>>>>>>>        Function_Return sVersion
75972>>>>>>>>>>>    End_Function
75973>>>>>>>>>>>    
75973>>>>>>>>>>>    //  Returns the version information of the
75973>>>>>>>>>>>    //           Pervasive.SQL Server Engine
75973>>>>>>>>>>>    
75973>>>>>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
75975>>>>>>>>>>>        
75975>>>>>>>>>>>        String  sDriverID
75975>>>>>>>>>>>        String  sVersion
75975>>>>>>>>>>>        String  sVoid
75975>>>>>>>>>>>        Integer iRetval
75975>>>>>>>>>>>        
75975>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75975>>>>>>>>>>>        // This error would otherwise be raised when we have an older
75975>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
75975>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
75976>>>>>>>>>>>        Get psDriverID to sDriverID
75977>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
75978>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
75983>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
75984>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
75986>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
75986>>>>>>>>>>>            Move "0.0.0" to sVersion
75987>>>>>>>>>>>        End
75987>>>>>>>>>>>>
75987>>>>>>>>>>>        Function_Return sVersion
75988>>>>>>>>>>>    End_Function
75989>>>>>>>>>>>    
75989>>>>>>>>>>>End_Class
75990>>>>>>>>>>>
75990>>>>>>>>>>>
75990>>>>>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
75990>>>>>>>>>>>//****************************************************************************
75990>>>>>>>>>>>// $Module type: Include file
75990>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.inc
75990>>>>>>>>>>>//
75990>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
75990>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
75990>>>>>>>>>>>// E-mail      : support@rdctools.com
75990>>>>>>>>>>>// Web-site    : http://www.rdctools.com
75990>>>>>>>>>>>//
75990>>>>>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
75990>>>>>>>>>>>//
75990>>>>>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
75990>>>>>>>>>>>//
75990>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
75990>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
75990>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
75990>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
75990>>>>>>>>>>>// in the help folder for more details.
75990>>>>>>>>>>>//
75990>>>>>>>>>>>Use Winkern.pkg
75990>>>>>>>>>>>Use cIniFile.pkg
75990>>>>>>>>>>>    Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCryptographerEx.pkg)
75990>>>>>>>>>>>>>Use VdfBase.pkg
75990>>>>>>>>>>>>>
75990>>>>>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 20.1\Pkg\CryptographerConstants.pkg)
75990>>>>>>>>>>>>>>>//   Author  : Ulbe Stellema
75990>>>>>>>>>>>>>>>// Algorithm classes
75990>>>>>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
75990>>>>>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
75990>>>>>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
75990>>>>>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
75990>>>>>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
75990>>>>>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
75990>>>>>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>// Algorithm types
75990>>>>>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
75990>>>>>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
75990>>>>>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
75990>>>>>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
75990>>>>>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
75990>>>>>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
75990>>>>>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>// Generic sub-ids
75990>>>>>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>// RSA sub-ids
75990>>>>>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
75990>>>>>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
75990>>>>>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
75990>>>>>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
75990>>>>>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>// DSS sub-ids
75990>>>>>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
75990>>>>>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
75990>>>>>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>// DES sub_ids
75990>>>>>>>>>>>>>>>Define ALG_SID_DES                      for 1
75990>>>>>>>>>>>>>>>Define ALG_SID_3DES                     for 3
75990>>>>>>>>>>>>>>>Define ALG_SID_DESX                     for 4
75990>>>>>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
75990>>>>>>>>>>>>>>>Define ALG_SID_CAST                     for 6
75990>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
75990>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
75990>>>>>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
75990>>>>>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
75990>>>>>>>>>>>>>>>Define ALG_SID_RC5                      for 13
75990>>>>>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
75990>>>>>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
75990>>>>>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
75990>>>>>>>>>>>>>>>Define ALG_SID_AES                      for 17
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>// Fortezza sub-ids
75990>>>>>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
75990>>>>>>>>>>>>>>>Define ALG_SID_TEK                      for 11
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>// RC2 sub-ids
75990>>>>>>>>>>>>>>>Define ALG_SID_RC2                      for 2
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>// Stream cipher sub-ids
75990>>>>>>>>>>>>>>>Define ALG_SID_RC4                      for 1
75990>>>>>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>// Diffie-Hellman sub-ids
75990>>>>>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
75990>>>>>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
75990>>>>>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
75990>>>>>>>>>>>>>>>Define ALG_SID_KEA                      for 4
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>// Hash sub ids
75990>>>>>>>>>>>>>>>Define ALG_SID_MD2                      for 1
75990>>>>>>>>>>>>>>>Define ALG_SID_MD4                      for 2
75990>>>>>>>>>>>>>>>Define ALG_SID_MD5                      for 3
75990>>>>>>>>>>>>>>>Define ALG_SID_SHA                      for 4
75990>>>>>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
75990>>>>>>>>>>>>>>>Define ALG_SID_MAC                      for 5
75990>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
75990>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
75990>>>>>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
75990>>>>>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
75990>>>>>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
75990>>>>>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
75990>>>>>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
75990>>>>>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
75990>>>>>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>// secure channel sub ids
75990>>>>>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
75990>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
75990>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
75990>>>>>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
75990>>>>>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
75990>>>>>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
75990>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>// algorithm identifier definitions
75990>>>>>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
75990>>>>>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
75990>>>>>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
75990>>>>>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
75990>>>>>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
75990>>>>>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
75990>>>>>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
75990>>>>>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
75990>>>>>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
75990>>>>>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
75990>>>>>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
75990>>>>>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
75990>>>>>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
75990>>>>>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
75990>>>>>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
75990>>>>>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
75990>>>>>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
75990>>>>>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
75990>>>>>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
75990>>>>>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
75990>>>>>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
75990>>>>>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
75990>>>>>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
75990>>>>>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
75990>>>>>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
75990>>>>>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
75990>>>>>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
75990>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
75990>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
75990>>>>>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
75990>>>>>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
75990>>>>>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
75990>>>>>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
75990>>>>>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
75990>>>>>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
75990>>>>>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
75990>>>>>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
75990>>>>>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
75990>>>>>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
75990>>>>>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
75990>>>>>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
75990>>>>>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
75990>>>>>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
75990>>>>>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>// Providers
75990>>>>>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
75990>>>>>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
75990>>>>>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
75990>>>>>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
75990>>>>>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
75990>>>>>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
75990>>>>>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
75990>>>>>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
75990>>>>>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
75990>>>>>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
75990>>>>>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
75990>>>>>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
75990>>>>>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
75990>>>>>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
75990>>>>>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
75990>>>>>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>// dwFlag definitions for CryptGenKey
75990>>>>>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
75990>>>>>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
75990>>>>>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
75990>>>>>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
75990>>>>>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
75990>>>>>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
75990>>>>>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
75990>>>>>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
75990>>>>>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
75990>>>>>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
75990>>>>>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
75990>>>>>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
75990>>>>>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
75990>>>>>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
75990>>>>>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
75990>>>>>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>// Provider types
75990>>>>>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
75990>>>>>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
75990>>>>>>>>>>>>>>>Define PROV_DSS                         for 3
75990>>>>>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
75990>>>>>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
75990>>>>>>>>>>>>>>>Define PROV_SSL                         for 6
75990>>>>>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
75990>>>>>>>>>>>>>>>Define PROV_DSS_DH                      for 13
75990>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
75990>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
75990>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
75990>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
75990>>>>>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
75990>>>>>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
75990>>>>>>>>>>>>>>>Define PROV_RNG                         for 21
75990>>>>>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
75990>>>>>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
75990>>>>>>>>>>>>>>>Define PROV_RSA_AES                     for 24
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>// KP_MODE
75990>>>>>>>>>>>>>>>// KP_MODE
75990>>>>>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
75990>>>>>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
75990>>>>>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
75990>>>>>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
75990>>>>>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
75990>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
75990>>>>>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
75990>>>>>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
75990>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
75990>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
75990>>>>>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
75990>>>>>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
75990>>>>>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
75990>>>>>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
75990>>>>>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
75990>>>>>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
75990>>>>>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
75990>>>>>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
75990>>>>>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
75990>>>>>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
75990>>>>>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
75990>>>>>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
75990>>>>>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
75990>>>>>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
75990>>>>>>>>>>>>>>>Define KP_Y                             for 15      // Y value
75990>>>>>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
75990>>>>>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
75990>>>>>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
75990>>>>>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
75990>>>>>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
75990>>>>>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
75990>>>>>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
75990>>>>>>>>>>>>>>>Define KP_RP                            for 23
75990>>>>>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
75990>>>>>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
75990>>>>>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
75990>>>>>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
75990>>>>>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
75990>>>>>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
75990>>>>>>>>>>>>>>>Define KP_KEYVAL                        for 30
75990>>>>>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
75990>>>>>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
75990>>>>>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
75990>>>>>>>>>>>>>>>Define KP_PREHASH                       for 34
75990>>>>>>>>>>>>>>>Define KP_ROUNDS                        for 35
75990>>>>>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
75990>>>>>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
75990>>>>>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
75990>>>>>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
75990>>>>>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
75990>>>>>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
75990>>>>>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
75990>>>>>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
75990>>>>>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
75990>>>>>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
75990>>>>>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>// key BLOB types
75990>>>>>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
75990>>>>>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
75990>>>>>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
75990>>>>>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
75990>>>>>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
75990>>>>>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
75990>>>>>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
75990>>>>>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>// KP_PADDING
75990>>>>>>>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
75990>>>>>>>>>>>>>>>Define RANDOM_PADDING                   for 2
75990>>>>>>>>>>>>>>>Define ZERO_PADDING                     for 3
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>//  Structure cryptimportkey
75990>>>>>>>>>>>>>>>Struct PUBLICKEYSTRUC
75990>>>>>>>>>>>>>>>    UChar    bType
75990>>>>>>>>>>>>>>>    UChar    bVersion
75990>>>>>>>>>>>>>>>    UShort   reserved
75990>>>>>>>>>>>>>>>    UInteger aiKeyAlg
75990>>>>>>>>>>>>>>>End_Struct
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
75990>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
75990>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
75990>>>>>>>>>>>>>>>    UInteger       dwKeySize
75990>>>>>>>>>>>>>>>//    UChar[]        rgbKeyData
75990>>>>>>>>>>>>>>>End_Struct
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
75990>>>>>>>>>>>>>>>Struct HMAC_INFO
75990>>>>>>>>>>>>>>>    UInteger HashAlgid
75990>>>>>>>>>>>>>>>    Pointer pbInnerString
75990>>>>>>>>>>>>>>>    DWord cbInnerString
75990>>>>>>>>>>>>>>>    Pointer pbOuterString
75990>>>>>>>>>>>>>>>    DWord cbOuterString
75990>>>>>>>>>>>>>>>End_Struct
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>Struct BLOBHEADER
75990>>>>>>>>>>>>>>>    UChar   bType
75990>>>>>>>>>>>>>>>    UChar   bVersion
75990>>>>>>>>>>>>>>>    Short   reserved
75990>>>>>>>>>>>>>>>    Integer aiKeyAlg
75990>>>>>>>>>>>>>>>End_Struct
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>Struct CryptoBlob
75990>>>>>>>>>>>>>>>    BLOBHEADER  header
75990>>>>>>>>>>>>>>>    BLOBHEADER  header
75990>>>>>>>>>>>>>>>    Integer     cbKeySize
75990>>>>>>>>>>>>>>>    UChar[32]   rgbKeyData
75990>>>>>>>>>>>>>>>End_Struct
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>
75990>>>>>>>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
75990>>>>>>>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
75991>>>>>>>>>>>>>>>
75991>>>>>>>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
75991>>>>>>>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
75993>>>>>>>>>>>>>>>    
75993>>>>>>>>>>>>>>>    Boolean bResult
75993>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
75993>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
75993>>>>>>>>>>>>>>>
75993>>>>>>>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
75994>>>>>>>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
75995>>>>>>>>>>>>>>>    
75995>>>>>>>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
75996>>>>>>>>>>>>>>>
75996>>>>>>>>>>>>>>>    Function_Return bResult
75997>>>>>>>>>>>>>>>End_Function
75998>>>>>>>>>>>>>>>
75998>>>>>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
75999>>>>>>>>>>>>>>>
75999>>>>>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
76000>>>>>>>>>>>>>>>
76000>>>>>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
76001>>>>>>>>>>>>>>>
76001>>>>>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
76002>>>>>>>>>>>>>>>
76002>>>>>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76003>>>>>>>>>>>>>>>
76003>>>>>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
76004>>>>>>>>>>>>>>>
76004>>>>>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
76005>>>>>>>>>>>>>>>
76005>>>>>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76006>>>>>>>>>>>>>>>
76006>>>>>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
76007>>>>>>>>>>>>>>>    
76007>>>>>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
76008>>>>>>>>>>>>>>>
76008>>>>>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
76009>>>>>>>>>>>>>>>
76009>>>>>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
76010>>>>>>>>>>>>>>>
76010>>>>>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
76011>>>>>>>>>>>>>>>    
76011>>>>>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
76012>>>>>>>>>>>>>>>    
76012>>>>>>>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76013>>>>>>>>>>>>>>>    
76013>>>>>>>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
76014>>>>>>>>>>>>>
76014>>>>>>>>>>>>>Class cCryptographerEx is a cObject
76015>>>>>>>>>>>>>    
76015>>>>>>>>>>>>>    Procedure Construct_Object
76017>>>>>>>>>>>>>        Forward Send Construct_Object
76019>>>>>>>>>>>>>        
76019>>>>>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
76020>>>>>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
76021>>>>>>>>>>>>>        Property Integer    piCipher    CALG_RC4
76022>>>>>>>>>>>>>        Property Integer    piHash      CALG_MD5
76023>>>>>>>>>>>>>        
76023>>>>>>>>>>>>>        // Private properties
76023>>>>>>>>>>>>>        Property Handle     Private_phProv
76024>>>>>>>>>>>>>        
76024>>>>>>>>>>>>>        // Block cipher properties
76024>>>>>>>>>>>>>        Property UChar[]    paKey
76025>>>>>>>>>>>>>        Property UChar[]    paIV
76026>>>>>>>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
76027>>>>>>>>>>>>>        Property Integer    piKeyType       CALG_AES_256
76028>>>>>>>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
76029>>>>>>>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
76030>>>>>>>>>>>>>        Property Integer    piBlockSize     16
76031>>>>>>>>>>>>>    End_Procedure
76032>>>>>>>>>>>>>    
76032>>>>>>>>>>>>>    
76032>>>>>>>>>>>>>    // Acquire key container handle
76032>>>>>>>>>>>>>    Function AcquireContext Returns Handle
76034>>>>>>>>>>>>>        Integer iProvider
76034>>>>>>>>>>>>>        WString wProvider
76034>>>>>>>>>>>>>        Handle hProv
76034>>>>>>>>>>>>>        Boolean bOk
76034>>>>>>>>>>>>>        Pointer pProv
76034>>>>>>>>>>>>>        
76034>>>>>>>>>>>>>        Move 0 to hProv
76035>>>>>>>>>>>>>        Get piProvider to iProvider
76036>>>>>>>>>>>>>        Get psProvider to wProvider
76037>>>>>>>>>>>>>        
76037>>>>>>>>>>>>>        //  Determine address to be passed as provider
76037>>>>>>>>>>>>>        If (Trim(wProvider) <> "") Begin
76039>>>>>>>>>>>>>            Move (AddressOf(wProvider)) to pProv
76040>>>>>>>>>>>>>        End
76040>>>>>>>>>>>>>>
76040>>>>>>>>>>>>>        Else Begin
76041>>>>>>>>>>>>>            Move 0 to pProv
76042>>>>>>>>>>>>>        End
76042>>>>>>>>>>>>>>
76042>>>>>>>>>>>>>        
76042>>>>>>>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
76042>>>>>>>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
76043>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
76045>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
76046>>>>>>>>>>>>>        End
76046>>>>>>>>>>>>>>
76046>>>>>>>>>>>>>        
76046>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
76048>>>>>>>>>>>>>            // Fallback to original
76048>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
76049>>>>>>>>>>>>>            
76049>>>>>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
76051>>>>>>>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
76052>>>>>>>>>>>>>            End
76052>>>>>>>>>>>>>>
76052>>>>>>>>>>>>>        End
76052>>>>>>>>>>>>>>
76052>>>>>>>>>>>>>        Set Private_phProv to hProv
76053>>>>>>>>>>>>>        
76053>>>>>>>>>>>>>        Function_Return hProv
76054>>>>>>>>>>>>>    End_Function
76055>>>>>>>>>>>>>    
76055>>>>>>>>>>>>>    // Releases key container handle
76055>>>>>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
76057>>>>>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
76058>>>>>>>>>>>>>    End_Function
76059>>>>>>>>>>>>>    
76059>>>>>>>>>>>>>    // Creates hash object
76059>>>>>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
76061>>>>>>>>>>>>>        Integer iAlgorithm
76061>>>>>>>>>>>>>        Handle hHash
76061>>>>>>>>>>>>>        Boolean bOk
76061>>>>>>>>>>>>>        
76061>>>>>>>>>>>>>        Move 0 to hHash
76062>>>>>>>>>>>>>        Get piHash to iAlgorithm
76063>>>>>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
76064>>>>>>>>>>>>>        
76064>>>>>>>>>>>>>        Function_Return hHash
76065>>>>>>>>>>>>>    End_Function
76066>>>>>>>>>>>>>    
76066>>>>>>>>>>>>>    // Destroys the hash object
76066>>>>>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
76068>>>>>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
76069>>>>>>>>>>>>>    End_Function
76070>>>>>>>>>>>>>    
76070>>>>>>>>>>>>>    // Adds data to hash object
76070>>>>>>>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
76072>>>>>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
76073>>>>>>>>>>>>>    End_Function
76074>>>>>>>>>>>>>    
76074>>>>>>>>>>>>>    // Generates session key
76074>>>>>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
76076>>>>>>>>>>>>>        Integer iAlgorithm
76076>>>>>>>>>>>>>        Handle hKey
76076>>>>>>>>>>>>>        Boolean bOk
76076>>>>>>>>>>>>>        
76076>>>>>>>>>>>>>        Move 0 to hKey
76077>>>>>>>>>>>>>        Get piCipher to iAlgorithm
76078>>>>>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
76079>>>>>>>>>>>>>        
76079>>>>>>>>>>>>>        Function_Return hKey
76080>>>>>>>>>>>>>    End_Function
76081>>>>>>>>>>>>>    
76081>>>>>>>>>>>>>    // Imports a plain text key
76081>>>>>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
76083>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
76083>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
76083>>>>>>>>>>>>>        Boolean   bSuccess
76083>>>>>>>>>>>>>        Handle    hKey
76083>>>>>>>>>>>>>        Integer   iHeadSize iKeySize
76083>>>>>>>>>>>>>        UChar[]   ucaKeyblob
76084>>>>>>>>>>>>>        Integer iVoid
76084>>>>>>>>>>>>>        
76084>>>>>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
76085>>>>>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
76086>>>>>>>>>>>>>        
76086>>>>>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
76087>>>>>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
76088>>>>>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
76089>>>>>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
76090>>>>>>>>>>>>>        
76090>>>>>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
76091>>>>>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
76092>>>>>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
76093>>>>>>>>>>>>>        
76093>>>>>>>>>>>>>        Move 0 to hKey
76094>>>>>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
76095>>>>>>>>>>>>>        If (not(bSuccess)) Begin
76097>>>>>>>>>>>>>            Move (ShowLastError()) to iVoid
76098>>>>>>>>>>>>>        End
76098>>>>>>>>>>>>>>
76098>>>>>>>>>>>>>        
76098>>>>>>>>>>>>>        Function_Return hKey
76099>>>>>>>>>>>>>    End_Function
76100>>>>>>>>>>>>>    
76100>>>>>>>>>>>>>    // Destroys the key
76100>>>>>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
76102>>>>>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
76103>>>>>>>>>>>>>    End_Function
76104>>>>>>>>>>>>>    
76104>>>>>>>>>>>>>    // Retrieves key data
76104>>>>>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
76106>>>>>>>>>>>>>        Integer iBuffer iLen
76106>>>>>>>>>>>>>        Boolean bOk
76106>>>>>>>>>>>>>        
76106>>>>>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
76107>>>>>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
76108>>>>>>>>>>>>>        Function_Return iBuffer
76109>>>>>>>>>>>>>    End_Function
76110>>>>>>>>>>>>>    
76110>>>>>>>>>>>>>    // Retrieves a hash value
76110>>>>>>>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
76112>>>>>>>>>>>>>        UChar[] ucHash
76113>>>>>>>>>>>>>        Integer liResult
76113>>>>>>>>>>>>>        DWord   dwDataLen
76113>>>>>>>>>>>>>        
76113>>>>>>>>>>>>>        Move 0 to dwDataLen
76114>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
76115>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
76118>>>>>>>>>>>>>        
76118>>>>>>>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
76119>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
76120>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
76123>>>>>>>>>>>>>        
76123>>>>>>>>>>>>>        Function_Return ucHash
76124>>>>>>>>>>>>>    End_Function
76125>>>>>>>>>>>>>
76125>>>>>>>>>>>>>    // Encrypts data
76125>>>>>>>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
76127>>>>>>>>>>>>>        Handle hProv hHash hKey
76127>>>>>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
76127>>>>>>>>>>>>>        Boolean bOk
76127>>>>>>>>>>>>>        
76127>>>>>>>>>>>>>        Get AcquireContext to hProv
76128>>>>>>>>>>>>>        If (hProv) Begin
76130>>>>>>>>>>>>>            Get CreateHash hProv to hHash
76131>>>>>>>>>>>>>            If (hHash) Begin
76133>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
76134>>>>>>>>>>>>>                If (bOk) Begin
76136>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
76137>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
76138>>>>>>>>>>>>>                End
76138>>>>>>>>>>>>>>
76138>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
76139>>>>>>>>>>>>>            End
76139>>>>>>>>>>>>>>
76139>>>>>>>>>>>>>            
76139>>>>>>>>>>>>>            If (hKey) Begin
76141>>>>>>>>>>>>>                //  First call to determine resulting data size
76141>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
76142>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
76143>>>>>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
76144>>>>>>>>>>>>>                
76144>>>>>>>>>>>>>                //  Reserve space in string
76144>>>>>>>>>>>>>                If (iDataLen < iCipherLen) Begin
76146>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
76147>>>>>>>>>>>>>                End
76147>>>>>>>>>>>>>>
76147>>>>>>>>>>>>>                
76147>>>>>>>>>>>>>                //  Call to really decrypt
76147>>>>>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
76148>>>>>>>>>>>>>                //If (not(bOk)) Begin
76148>>>>>>>>>>>>>                //Move "" to sData
76148>>>>>>>>>>>>>                //Move (GetLastError()) to iErr
76148>>>>>>>>>>>>>                //End
76148>>>>>>>>>>>>>                
76148>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76149>>>>>>>>>>>>>            End 
76149>>>>>>>>>>>>>>
76149>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76150>>>>>>>>>>>>>        End 
76150>>>>>>>>>>>>>>
76150>>>>>>>>>>>>>        Function_Return ucData
76151>>>>>>>>>>>>>    End_Function
76152>>>>>>>>>>>>>    
76152>>>>>>>>>>>>>    // Decrypts data
76152>>>>>>>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
76154>>>>>>>>>>>>>        Handle hProv hHash hKey
76154>>>>>>>>>>>>>        Integer iAlgorithm iDataLen
76154>>>>>>>>>>>>>        Boolean bOk
76154>>>>>>>>>>>>>        
76154>>>>>>>>>>>>>        Get AcquireContext to hProv
76155>>>>>>>>>>>>>        If (hProv) Begin
76157>>>>>>>>>>>>>            Get CreateHash hProv to hHash
76158>>>>>>>>>>>>>            If (hHash) Begin
76160>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
76161>>>>>>>>>>>>>                If (bOk) Begin
76163>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
76164>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
76165>>>>>>>>>>>>>                End
76165>>>>>>>>>>>>>>
76165>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
76166>>>>>>>>>>>>>            End
76166>>>>>>>>>>>>>>
76166>>>>>>>>>>>>>            
76166>>>>>>>>>>>>>            If (hKey) Begin
76168>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
76169>>>>>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
76170>>>>>>>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
76170>>>>>>>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
76172>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
76173>>>>>>>>>>>>>                End
76173>>>>>>>>>>>>>>
76173>>>>>>>>>>>>>                
76173>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76174>>>>>>>>>>>>>            End
76174>>>>>>>>>>>>>>
76174>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76175>>>>>>>>>>>>>        End
76175>>>>>>>>>>>>>>
76175>>>>>>>>>>>>>        Function_Return ucData
76176>>>>>>>>>>>>>    End_Function
76177>>>>>>>>>>>>>    
76177>>>>>>>>>>>>>    // Creates a key
76177>>>>>>>>>>>>>    Function CreateKey Handle hProv Returns Handle
76179>>>>>>>>>>>>>        Integer iAlg iType iByte iLength iSize
76179>>>>>>>>>>>>>        CryptoBlob keyBlob
76179>>>>>>>>>>>>>        CryptoBlob keyBlob
76179>>>>>>>>>>>>>        Boolean bOk
76179>>>>>>>>>>>>>        Handle hKey
76179>>>>>>>>>>>>>        UChar[] aKey
76180>>>>>>>>>>>>>
76180>>>>>>>>>>>>>        Get paKey to aKey
76181>>>>>>>>>>>>>        Get piKeyAlg to iAlg
76182>>>>>>>>>>>>>        Get piKeyType to iType
76183>>>>>>>>>>>>>        Move iAlg                   to keyBlob.header.bType
76184>>>>>>>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
76185>>>>>>>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
76186>>>>>>>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
76187>>>>>>>>>>>>>        
76187>>>>>>>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
76188>>>>>>>>>>>>>        For iByte from 0 to iLength
76194>>>>>>>>>>>>>>
76194>>>>>>>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
76195>>>>>>>>>>>>>        Loop
76196>>>>>>>>>>>>>>
76196>>>>>>>>>>>>>        
76196>>>>>>>>>>>>>        Move 0 to hKey
76197>>>>>>>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
76198>>>>>>>>>>>>>        Function_Return hKey
76199>>>>>>>>>>>>>    End_Function
76200>>>>>>>>>>>>>    
76200>>>>>>>>>>>>>    // Sets the key parameters
76200>>>>>>>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
76202>>>>>>>>>>>>>        Integer iPadding iMode
76202>>>>>>>>>>>>>        Boolean bOk
76202>>>>>>>>>>>>>        UChar[] aIV
76203>>>>>>>>>>>>>        
76203>>>>>>>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
76203>>>>>>>>>>>>>        //For iByte from 0 to iLength
76203>>>>>>>>>>>>>        //    Move iByte to aIV[iByte]
76203>>>>>>>>>>>>>        //Loop
76203>>>>>>>>>>>>>
76203>>>>>>>>>>>>>        // Set initialization vector
76203>>>>>>>>>>>>>        Get paIV to aIV
76204>>>>>>>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
76205>>>>>>>>>>>>>        If (bOk) Begin
76207>>>>>>>>>>>>>            // Set padding
76207>>>>>>>>>>>>>            Get piKeyPadding to iPadding
76208>>>>>>>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
76209>>>>>>>>>>>>>            If (bOk) Begin
76211>>>>>>>>>>>>>                // Set move
76211>>>>>>>>>>>>>                Get piKeyMode to iMode
76212>>>>>>>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
76213>>>>>>>>>>>>>            End
76213>>>>>>>>>>>>>>
76213>>>>>>>>>>>>>        End
76213>>>>>>>>>>>>>>
76213>>>>>>>>>>>>>        Function_Return bOk        
76214>>>>>>>>>>>>>    End_Function
76215>>>>>>>>>>>>>    
76215>>>>>>>>>>>>>    // Encrypts using block cipher
76215>>>>>>>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
76217>>>>>>>>>>>>>        Handle hProv hKey
76217>>>>>>>>>>>>>        Integer iLen iSize iBlocks
76217>>>>>>>>>>>>>        Boolean bOk
76217>>>>>>>>>>>>>        
76217>>>>>>>>>>>>>        Get AcquireContext to hProv
76218>>>>>>>>>>>>>        If (hProv) Begin
76220>>>>>>>>>>>>>            // Create key
76220>>>>>>>>>>>>>            Get CreateKey hProv to hKey
76221>>>>>>>>>>>>>            If (hKey) Begin
76223>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
76224>>>>>>>>>>>>>                If (bOk) Begin
76226>>>>>>>>>>>>>                    // Buffer for block ciphers can be up to block length larger
76226>>>>>>>>>>>>>                    Get piBlockSize to iSize
76227>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76228>>>>>>>>>>>>>                    
76228>>>>>>>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
76229>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
76230>>>>>>>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
76231>>>>>>>>>>>>>                End
76231>>>>>>>>>>>>>>
76231>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76232>>>>>>>>>>>>>            End
76232>>>>>>>>>>>>>>
76232>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76233>>>>>>>>>>>>>        End
76233>>>>>>>>>>>>>>
76233>>>>>>>>>>>>>        Function_Return ucData
76234>>>>>>>>>>>>>    End_Function
76235>>>>>>>>>>>>>    
76235>>>>>>>>>>>>>    // Decrypts using block cipher
76235>>>>>>>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
76237>>>>>>>>>>>>>        Handle hProv hKey
76237>>>>>>>>>>>>>        Integer iLen
76237>>>>>>>>>>>>>        Boolean bOk
76237>>>>>>>>>>>>>        
76237>>>>>>>>>>>>>        Get AcquireContext to hProv
76238>>>>>>>>>>>>>        If (hProv) Begin
76240>>>>>>>>>>>>>            // Create key
76240>>>>>>>>>>>>>            Get CreateKey hProv to hKey
76241>>>>>>>>>>>>>            If (hKey) Begin
76243>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
76244>>>>>>>>>>>>>                If (bOk) Begin
76246>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76247>>>>>>>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
76248>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
76249>>>>>>>>>>>>>                End
76249>>>>>>>>>>>>>>
76249>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76250>>>>>>>>>>>>>            End
76250>>>>>>>>>>>>>>
76250>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76251>>>>>>>>>>>>>        End
76251>>>>>>>>>>>>>>
76251>>>>>>>>>>>>>        Function_Return ucData
76252>>>>>>>>>>>>>    End_Function
76253>>>>>>>>>>>>>    
76253>>>>>>>>>>>>>    
76253>>>>>>>>>>>>>    //  Generates random data.
76253>>>>>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
76255>>>>>>>>>>>>>        Handle hProv
76255>>>>>>>>>>>>>        UChar[] uaResult
76256>>>>>>>>>>>>>        Boolean bRes
76256>>>>>>>>>>>>>        
76256>>>>>>>>>>>>>        Get AcquireContext to hProv
76257>>>>>>>>>>>>>        
76257>>>>>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
76258>>>>>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
76259>>>>>>>>>>>>>        
76259>>>>>>>>>>>>>        Get ReleaseContext hProv to bRes
76260>>>>>>>>>>>>>        
76260>>>>>>>>>>>>>        Function_Return uaResult
76261>>>>>>>>>>>>>    End_Function
76262>>>>>>>>>>>>>    
76262>>>>>>>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
76262>>>>>>>>>>>>>    Function GenerateRandomString Integer iLength Returns String
76264>>>>>>>>>>>>>        String sResult
76264>>>>>>>>>>>>>        UChar[] ucData
76265>>>>>>>>>>>>>        Pointer pBase64
76265>>>>>>>>>>>>>        Integer iVoid
76265>>>>>>>>>>>>>        
76265>>>>>>>>>>>>>        Get GenerateRandom iLength to ucData
76266>>>>>>>>>>>>>        
76266>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
76267>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76268>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76269>>>>>>>>>>>>>        
76269>>>>>>>>>>>>>        Function_Return (Left(sResult, iLength))
76270>>>>>>>>>>>>>    End_Function
76271>>>>>>>>>>>>>    
76271>>>>>>>>>>>>>End_Class
76272>>>>>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Base64Functions.pkg)
76272>>>>>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
76272>>>>>>>>>>>>>//>
76272>>>>>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
76272>>>>>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
76272>>>>>>>>>>>>>//>
76272>>>>>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
76272>>>>>>>>>>>>>//> strings.
76272>>>>>>>>>>>>>//>
76272>>>>>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
76272>>>>>>>>>>>>>//> Base64Decode) that are built into the runtime.
76272>>>>>>>>>>>>>//>
76272>>>>>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
76272>>>>>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
76272>>>>>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
76272>>>>>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
76272>>>>>>>>>>>>>
76272>>>>>>>>>>>>>Use VdfBase.pkg
76272>>>>>>>>>>>>>
76272>>>>>>>>>>>>>// Functions in vdfBase64.dll
76272>>>>>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
76273>>>>>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
76274>>>>>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
76275>>>>>>>>>>>>>
76275>>>>>>>>>>>>>// Structure
76275>>>>>>>>>>>>>Struct txxfBase64Buffer
76275>>>>>>>>>>>>>    Pointer pData
76275>>>>>>>>>>>>>    Integer iLength
76275>>>>>>>>>>>>>End_Struct 
76275>>>>>>>>>>>>>
76275>>>>>>>>>>>>>Global_Variable Integer oBase64Functions
76275>>>>>>>>>>>>>
76275>>>>>>>>>>>>>Object _oBase64Functions is a cObject
76277>>>>>>>>>>>>>    Move Self to oBase64Functions
76278>>>>>>>>>>>>>
76278>>>>>>>>>>>>>
76278>>>>>>>>>>>>>    Function EncodeString String sValue Returns String
76281>>>>>>>>>>>>>        Address pBase64
76281>>>>>>>>>>>>>        String sResult
76281>>>>>>>>>>>>>        Integer iVoid
76281>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
76282>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76283>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76284>>>>>>>>>>>>>        Function_Return sResult
76285>>>>>>>>>>>>>    End_Function
76286>>>>>>>>>>>>>
76286>>>>>>>>>>>>>    Function DecodeString String sValue Returns String
76289>>>>>>>>>>>>>        Address pBinary
76289>>>>>>>>>>>>>        String sBinary
76289>>>>>>>>>>>>>        Integer iVoid iLen
76289>>>>>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
76290>>>>>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
76291>>>>>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
76292>>>>>>>>>>>>>        Move (Free(pBinary)) to iVoid
76293>>>>>>>>>>>>>        Function_Return sBinary
76294>>>>>>>>>>>>>    End_Function
76295>>>>>>>>>>>>>
76295>>>>>>>>>>>>>End_Object
76296>>>>>>>>>>>Use MSSqldrv.pkg
76296>>>>>>>>>>>Use db2_drv.pkg
76296>>>>>>>>>>>Use odbc_drv.pkg
76296>>>>>>>>>>>Use DFBtrDrv.pkg
76296>>>>>>>>>>>Use vWin32fh.pkg
76296>>>>>>>>>>>
76296>>>>>>>>>>>Use DUFLanguageConstants.inc
76296>>>>>>>>>>>Use MertechDUF.pkg
Including file: MertechDUF.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MertechDUF.pkg)
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>// Use of Mertech drivers:
76296>>>>>>>>>>>>>// Put the line "Define DUF_Use_Mertech_Drivers in YOUR code prior the "Use" statement for this package if using Mertech drivers!
76296>>>>>>>>>>>>>// And put the line right before the "Use cDbUpdateHandler.pkg" line.
76296>>>>>>>>>>>>>//Define DUF_Use_Mertech_Drivers
76296>>>>>>>>>>>>>//
#REM DO ~ USE MERTECH.INC
76296>>>>>>>>>>>>>// MySQL Data Types
76296>>>>>>>>>>>>>Define eMySQL_DECIMAL                               for 0
76296>>>>>>>>>>>>>Define eMySQL_TINY                                  for 1
76296>>>>>>>>>>>>>Define eMySQL_SHORT                                 for 2
76296>>>>>>>>>>>>>Define eMySQL_LONG                                  for 3
76296>>>>>>>>>>>>>Define eMySQL_FLOAT                                 for 4
76296>>>>>>>>>>>>>Define eMySQL_DOUBLE                                for 5
76296>>>>>>>>>>>>>Define eMySQL_NULL                                  for 6
76296>>>>>>>>>>>>>Define eMySQL_TIMESTAMP                             for 7
76296>>>>>>>>>>>>>Define eMySQL_LONGLONG                              for 8
76296>>>>>>>>>>>>>Define eMySQL_INT24                                 for 9
76296>>>>>>>>>>>>>Define eMySQL_DATE                                  for 10
76296>>>>>>>>>>>>>Define eMySQL_TIME                                  for 11
76296>>>>>>>>>>>>>Define eMySQL_DATETIME                              for 12
76296>>>>>>>>>>>>>Define eMySQL_YEAR                                  for 13
76296>>>>>>>>>>>>>Define eMySQL_NEWDATE                               for 14
76296>>>>>>>>>>>>>Define eMySQL_BIT                                   for 16
76296>>>>>>>>>>>>>Define eMySQL_NEWDECIMAL                            for 246
76296>>>>>>>>>>>>>Define eMySQL_ENUM                                  for 247
76296>>>>>>>>>>>>>Define eMySQL_SET                                   for 248
76296>>>>>>>>>>>>>Define eMySQL_TINY_BLOB                             for 249
76296>>>>>>>>>>>>>Define eMySQL_MEDIUM_BLOB                           for 250
76296>>>>>>>>>>>>>Define eMySQL_LONG_BLOB                             for 251
76296>>>>>>>>>>>>>Define eMySQL_BLOB                                  for 252
76296>>>>>>>>>>>>>Define eMySQL_VAR_STRING                            for 253
76296>>>>>>>>>>>>>Define eMySQL_STRING                                for 254
76296>>>>>>>>>>>>>Define eMySQL_TINY_TEXT                             for -249
76296>>>>>>>>>>>>>Define eMySQL_MEDIUM_TEXT                           for -250
76296>>>>>>>>>>>>>Define eMySQL_LONG_TEXT                             for -251
76296>>>>>>>>>>>>>Define eMySQL_TEXT                                  for -252
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>// Oracle Data Types
76296>>>>>>>>>>>>>Define eOracle_VARCHAR2                             for   1
76296>>>>>>>>>>>>>Define eOracle_NUMBER                               for   2
76296>>>>>>>>>>>>>Define eOracle_INT                                  for   3
76296>>>>>>>>>>>>>Define eOracle_FLOAT                                for   4
76296>>>>>>>>>>>>>Define eOracle_STRING                               for   5
76296>>>>>>>>>>>>>Define eOracle_LONG                                 for   8
76296>>>>>>>>>>>>>Define eOracle_ROWID                                for  11
76296>>>>>>>>>>>>>Define eOracle_DATE                                 for  12
76296>>>>>>>>>>>>>Define eOracle_RAW                                  for  23
76296>>>>>>>>>>>>>Define eOracle_LONGRAW                              for  24
76296>>>>>>>>>>>>>Define eOracle_CHAR                                 for  96
76296>>>>>>>>>>>>>Define eOracle_MSLABEL                              for 106
76296>>>>>>>>>>>>>Define eOracle_CLOB                                 for 112
76296>>>>>>>>>>>>>Define eOracle_BLOB                                 for 113
76296>>>>>>>>>>>>>Define eOracle_TIMESTAMP                            for 187
76296>>>>>>>>>>>>>Define eOracle_TIMESTAMPTZ                          for 188
76296>>>>>>>>>>>>>Define eOracle_INTERVALYM                           for 189
76296>>>>>>>>>>>>>Define eOracle_INTERVALDS                           for 190
76296>>>>>>>>>>>>>Define eOracle_TIMESTAMPLTZ                         for 232
76296>>>>>>>>>>>>>Define eOracle_NCHAR                                for 286
76296>>>>>>>>>>>>>Define eOracle_NVARCHAR2                            for 287
76296>>>>>>>>>>>>>Define eOracle_NCLOB                                for 288
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>// PostgreSQL Data Types
76296>>>>>>>>>>>>>Define ePgSQL_CIRCLE                                for  718
76296>>>>>>>>>>>>>Define ePgSQL_MONEY                                 for  790
76296>>>>>>>>>>>>>Define ePgSQL_BOOL                                  for   16
76296>>>>>>>>>>>>>Define ePgSQL_BYTEA                                 for   17
76296>>>>>>>>>>>>>Define ePgSQL_CHAR                                  for   18
76296>>>>>>>>>>>>>Define ePgSQL_INT2                                  for   21
76296>>>>>>>>>>>>>Define ePgSQL_INT4                                  for   23
76296>>>>>>>>>>>>>Define ePgSQL_REGPROC                               for   24
76296>>>>>>>>>>>>>Define ePgSQL_REGPROCEDURE                          for 2202
76296>>>>>>>>>>>>>Define ePgSQL_REGOPER                               for 2203
76296>>>>>>>>>>>>>Define ePgSQL_REGOPERATOR                           for 2204
76296>>>>>>>>>>>>>Define ePgSQL_REGCLASS                              for 2205
76296>>>>>>>>>>>>>Define ePgSQL_REGTYPE                               for 2206
76296>>>>>>>>>>>>>Define ePgSQL_TEXT                                  for   25
76296>>>>>>>>>>>>>Define ePgSQL_CITEXT                                for  -25
76296>>>>>>>>>>>>>Define ePgSQL_OID                                   for   26
76296>>>>>>>>>>>>>Define ePgSQL_TID                                   for   27
76296>>>>>>>>>>>>>Define ePgSQL_XID                                   for   28
76296>>>>>>>>>>>>>Define ePgSQL_CID                                   for   29
76296>>>>>>>>>>>>>Define ePgSQL_XML                                   for  142
76296>>>>>>>>>>>>>Define ePgSQL_BPCHAR                                for 1042
76296>>>>>>>>>>>>>Define ePgSQL_VARCHAR                               for 1043
76296>>>>>>>>>>>>>Define ePgSQL_INT8                                  for   20
76296>>>>>>>>>>>>>Define ePgSQL_PATH                                  for  602
76296>>>>>>>>>>>>>Define ePgSQL_FLOAT4                                for  700
76296>>>>>>>>>>>>>Define ePgSQL_FLOAT8                                for  701
76296>>>>>>>>>>>>>Define ePgSQL_ABSTIME                               for  702
76296>>>>>>>>>>>>>Define ePgSQL_RELTIME                               for  703
76296>>>>>>>>>>>>>Define ePgSQL_TINTERVAL                             for  704
76296>>>>>>>>>>>>>Define ePgSQL_POINT                                 for  600
76296>>>>>>>>>>>>>Define ePgSQL_LINE                                  for  628
76296>>>>>>>>>>>>>Define ePgSQL_LSEG                                  for  601
76296>>>>>>>>>>>>>Define ePgSQL_BOX                                   for  603
76296>>>>>>>>>>>>>Define ePgSQL_POLYGON                               for  604
76296>>>>>>>>>>>>>Define ePgSQL_ACLITEM                               for 1033
76296>>>>>>>>>>>>>Define ePgSQL_MACADDR                               for  829
76296>>>>>>>>>>>>>Define ePgSQL_INET                                  for  869
76296>>>>>>>>>>>>>Define ePgSQL_CIDR                                  for  650
76296>>>>>>>>>>>>>Define ePgSQL_TIMESTAMP                             for 1114
76296>>>>>>>>>>>>>Define ePgSQL_DATE                                  for 1082
76296>>>>>>>>>>>>>Define ePgSQL_TIME                                  for 1083
76296>>>>>>>>>>>>>Define ePgSQL_TIMESTAMPTZ                           for 1184
76296>>>>>>>>>>>>>Define ePgSQL_INTERVAL                              for 1186
76296>>>>>>>>>>>>>Define ePgSQL_NUMERIC                               for 1700
76296>>>>>>>>>>>>>Define ePgSQL_TIMETZ                                for 1266
76296>>>>>>>>>>>>>Define ePgSQL_BIT                                   for 1560
76296>>>>>>>>>>>>>Define ePgSQL_VARBIT                                for 1562
76296>>>>>>>>>>>>>Define ePgSQL_UUID                                  for 2950
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>// SQL Server Data Types
76296>>>>>>>>>>>>>Define eSQLServer_NA                                for    0
76296>>>>>>>>>>>>>Define eSQLServer_CHAR                              for    1
76296>>>>>>>>>>>>>Define eSQLServer_NUMERIC                           for    2
76296>>>>>>>>>>>>>Define eSQLServer_DECIMAL                           for    3
76296>>>>>>>>>>>>>Define eSQLServer_INT                               for    4
76296>>>>>>>>>>>>>Define eSQLServer_SMALLINT                          for    5
76296>>>>>>>>>>>>>Define eSQLServer_FLOAT                             for    6
76296>>>>>>>>>>>>>Define eSQLServer_REAL                              for    7
76296>>>>>>>>>>>>>Define eSQLServer_DOUBLE                            for    8
76296>>>>>>>>>>>>>Define eSQLServer_DATETIME                          for   11
76296>>>>>>>>>>>>>Define eSQLServer_VARCHAR                           for   12
76296>>>>>>>>>>>>>Define eSQLServer_DATE                              for   40
76296>>>>>>>>>>>>>Define eSQLServer_TIME                              for   41
76296>>>>>>>>>>>>>Define eSQLServer_DATETIME2                         for   42
76296>>>>>>>>>>>>>Define eSQLServer_DATETIMEOFFSET                    for   43
76296>>>>>>>>>>>>>Define eSQLServer_SMALLDATETIME                     for   58
76296>>>>>>>>>>>>>Define eSQLServer_TIMESTAMP                         for   93
76296>>>>>>>>>>>>>Define eSQLServer_HIERARCHYID                       for  128
76296>>>>>>>>>>>>>Define eSQLServer_GEOMETRY                          for  129
76296>>>>>>>>>>>>>Define eSQLServer_GEOGRAPHY                         for  130
76296>>>>>>>>>>>>>Define eSQLServer_TEXT                              for   -1
76296>>>>>>>>>>>>>Define eSQLServer_BINARY                            for   -2
76296>>>>>>>>>>>>>Define eSQLServer_VARBINARY                         for   -3
76296>>>>>>>>>>>>>Define eSQLServer_IMAGE                             for   -4
76296>>>>>>>>>>>>>Define eSQLServer_BIGINT                            for   -5
76296>>>>>>>>>>>>>Define eSQLServer_TINYINT                           for   -6
76296>>>>>>>>>>>>>Define eSQLServer_BIT                               for   -7
76296>>>>>>>>>>>>>Define eSQLServer_NCHAR                             for   -8
76296>>>>>>>>>>>>>Define eSQLServer_NVARCHAR                          for   -9
76296>>>>>>>>>>>>>Define eSQLServer_NTEXT                             for  -10
76296>>>>>>>>>>>>>Define eSQLServer_GUID                              for  -11
76296>>>>>>>>>>>>>Define eSQLServer_VARBINARYMAX                      for  -98
76296>>>>>>>>>>>>>Define eSQLServer_VARCHARMAX                        for  -99
76296>>>>>>>>>>>>>Define eSQLServer_NVARCHARMAX                       for -100
76296>>>>>>>>>>>>>Define eSQLServer_SQLVARIANT                        for -150
76296>>>>>>>>>>>>>Define eSQLServer_XML                               for -370
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
76296>>>>>>>>>>>>>>>Use DUFLanguageConstants.inc
76296>>>>>>>>>>>>>>>
76296>>>>>>>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
76296>>>>>>>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
76296>>>>>>>>>>>>>>>
76296>>>>>>>>>>>>>>>
76296>>>>>>>>>>>>>>>
76296>>>>>>>>>>>>>>>    Define CS_OEM_Txt for "OEM"
76296>>>>>>>>>>>>>>>
76296>>>>>>>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
76296>>>>>>>>>>>>>>>
76296>>>>>>>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
76296>>>>>>>>>>>>>>>
76296>>>>>>>>>>>>>>>    Define CS_SERVER for "SERVER"
76296>>>>>>>>>>>>>>>
76296>>>>>>>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
76296>>>>>>>>>>>>>>>
76296>>>>>>>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
76296>>>>>>>>>>>>>>>
76296>>>>>>>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
76296>>>>>>>>>>>>>>>
76296>>>>>>>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
76296>>>>>>>>>>>>>>>
76296>>>>>>>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
76296>>>>>>>>>>>>>>>
76296>>>>>>>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
76296>>>>>>>>>>>>>>>
76296>>>>>>>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
76296>>>>>>>>>>>>>>>
76296>>>>>>>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
76296>>>>>>>>>>>>>>>
76296>>>>>>>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
76296>>>>>>>>>>>>>>>
76296>>>>>>>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
76296>>>>>>>>>>>>>>>
76296>>>>>>>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
76296>>>>>>>>>>>>>>>
76296>>>>>>>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
76296>>>>>>>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
76296>>>>>>>>>>>>>>>
76296>>>>>>>>>>>>>>>    Define CS_DUFBackupDataFolder for "BackupData"
76296>>>>>>>>>>>>>>>
76296>>>>>>>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
76296>>>>>>>>>>>>>>>
76296>>>>>>>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary  
76296>>>>>>>>>>>>>>>    Move 0 to ghoDbUpdateFunctionLibrary
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>Struct tSQLScriptArray
76297>>>>>>>>>>>>>>>    Boolean bError
76297>>>>>>>>>>>>>>>    Boolean bArgumentSizeChanged
76297>>>>>>>>>>>>>>>    Integer iOrgArgumentSize
76297>>>>>>>>>>>>>>>    String[] sSQLScriptArray
76297>>>>>>>>>>>>>>>End_Struct
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>Struct tSqlErrorArray
76297>>>>>>>>>>>>>>>    String[]  sSqlErrorArray
76297>>>>>>>>>>>>>>>    String[]  sSqlStatementArray
76297>>>>>>>>>>>>>>>    Integer[] iSqlErrorArray
76297>>>>>>>>>>>>>>>End_Struct
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>Struct tSqlColumnNew
76297>>>>>>>>>>>>>>>    String  sBaseColumnName
76297>>>>>>>>>>>>>>>    String  sBaseTableName
76297>>>>>>>>>>>>>>>    String  sLabel
76297>>>>>>>>>>>>>>>    Integer iSqlType
76297>>>>>>>>>>>>>>>    Integer iSize
76297>>>>>>>>>>>>>>>    Integer iPrecision
76297>>>>>>>>>>>>>>>    Integer iDFType
76297>>>>>>>>>>>>>>>    Integer iDFNativeType
76297>>>>>>>>>>>>>>>End_Struct
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>Struct tColumnType
76297>>>>>>>>>>>>>>>    String  sSQLType
76297>>>>>>>>>>>>>>>    Integer iSQLType
76297>>>>>>>>>>>>>>>    Boolean bCanEditSize
76297>>>>>>>>>>>>>>>    Integer iDefaultSize
76297>>>>>>>>>>>>>>>    Integer iMinSize
76297>>>>>>>>>>>>>>>    Number  nMaxSize
76297>>>>>>>>>>>>>>>    String  sDataFlexType
76297>>>>>>>>>>>>>>>    Integer iDataFlexType
76297>>>>>>>>>>>>>>>    Boolean bNativeDataType
76297>>>>>>>>>>>>>>>    String  sPrecision
76297>>>>>>>>>>>>>>>End_Struct
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
76297>>>>>>>>>>>>>>>// Various SQL back-ends can have slightly different
76297>>>>>>>>>>>>>>>// keywords.
76297>>>>>>>>>>>>>>>Struct tSQLKeyWords
76297>>>>>>>>>>>>>>>    Integer iSQLWord
76297>>>>>>>>>>>>>>>    Integer iSQLDbType
76297>>>>>>>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
76297>>>>>>>>>>>>>>>End_Struct
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>Struct tSQLRelation
76297>>>>>>>>>>>>>>>    Integer iFileNumber
76297>>>>>>>>>>>>>>>    Integer iFieldNumber
76297>>>>>>>>>>>>>>>    String  sFileName
76297>>>>>>>>>>>>>>>    String  sFieldName
76297>>>>>>>>>>>>>>>End_Struct
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>Struct tSQLLoggedInUser
76297>>>>>>>>>>>>>>>    String sUser
76297>>>>>>>>>>>>>>>    String sProgram
76297>>>>>>>>>>>>>>>End_Struct
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
76297>>>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
76297>>>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
76297>>>>>>>>>>>>>>>// They can have slightly different SQL keywords.
76297>>>>>>>>>>>>>>>// Note: If a new type is added to the list,
76297>>>>>>>>>>>>>>>//       the struct array xxx must be adjusted
76297>>>>>>>>>>>>>>>//       so that it is filled with all SQL
76297>>>>>>>>>>>>>>>//       keywords for that new type.
76297>>>>>>>>>>>>>>>Enum_List
76297>>>>>>>>>>>>>>>    Define EN_DbTypeDataFlex   for 0
76297>>>>>>>>>>>>>>>    Define EN_DbTypeMSSQL      for 1
76297>>>>>>>>>>>>>>>    Define EN_DbTypeMySQL      for 2
76297>>>>>>>>>>>>>>>    Define EN_DbTypeOracle     for 3
76297>>>>>>>>>>>>>>>    Define EN_DbTypeDB2        for 4
76297>>>>>>>>>>>>>>>    Define EN_DbTypePostgre    for 5
76297>>>>>>>>>>>>>>>    Define EN_DbTypePervasive  for 6
76297>>>>>>>>>>>>>>>//    Define EN_DbTypeMSSQL
76297>>>>>>>>>>>>>>>//    Define EN_DbTypeMySQL
76297>>>>>>>>>>>>>>>//    Define EN_DbTypeOracle
76297>>>>>>>>>>>>>>>//    Define EN_DbTypeDB2
76297>>>>>>>>>>>>>>>//    Define EN_DbTypePostgre
76297>>>>>>>>>>>>>>>//    Define EN_DbTypeDataFlex // Embedded database.
76297>>>>>>>>>>>>>>>End_Enum_List
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
76297>>>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
76297>>>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
76297>>>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
76297>>>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
76297>>>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
76297>>>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
76297>>>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
76297>>>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
76297>>>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
76297>>>>>>>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
76297>>>>>>>>>>>>>>>Enum_List
76297>>>>>>>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
76297>>>>>>>>>>>>>>>    Define DF_BCD_DUF       for -1499
76297>>>>>>>>>>>>>>>    Define DF_DATE_DUF      for -1498
76297>>>>>>>>>>>>>>>    Define DF_TEXT_DUF      for -1495
76297>>>>>>>>>>>>>>>    Define DF_BINARY_DUF    for -1494
76297>>>>>>>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
76297>>>>>>>>>>>>>>>End_Enum_List
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
76297>>>>>>>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
76297>>>>>>>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>// These are not defined pre DF 18:
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>Struct tSQLIntTableInfo
76297>>>>>>>>>>>>>>>    String sDriverName
76297>>>>>>>>>>>>>>>    String sServerName
76297>>>>>>>>>>>>>>>    String sDatabaseName
76297>>>>>>>>>>>>>>>    String sSchemaName
76297>>>>>>>>>>>>>>>    Boolean bRecnumTable
76297>>>>>>>>>>>>>>>    Integer iPrimaryIndex
76297>>>>>>>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
76297>>>>>>>>>>>>>>>    String sTableCharacterFormat
76297>>>>>>>>>>>>>>>    Boolean bUseDummyZeroDate
76297>>>>>>>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
76297>>>>>>>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
76297>>>>>>>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
76297>>>>>>>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
76297>>>>>>>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
76297>>>>>>>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
76297>>>>>>>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
76297>>>>>>>>>>>>>>>    String sFileIndexTablespace
76297>>>>>>>>>>>>>>>    String sFileLongTablespace
76297>>>>>>>>>>>>>>>    String sTableTablespace
76297>>>>>>>>>>>>>>>End_Struct
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>Struct tSQLIntColumnInfo
76297>>>>>>>>>>>>>>>    Integer iFieldNumber
76297>>>>>>>>>>>>>>>    Integer iFieldIndex
76297>>>>>>>>>>>>>>>    Integer iFieldRelatedFile
76297>>>>>>>>>>>>>>>    Integer iFieldRelatedField
76297>>>>>>>>>>>>>>>    Integer iIndexNumber
76297>>>>>>>>>>>>>>>    Integer iIndexNumberSegments
76297>>>>>>>>>>>>>>>    Integer iIndexSegmentField1
76297>>>>>>>>>>>>>>>    Integer iIndexSegmentField2
76297>>>>>>>>>>>>>>>    Integer iIndexSegmentFieldn
76297>>>>>>>>>>>>>>>    String  sIndexName
76297>>>>>>>>>>>>>>>End_Struct
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>Struct tAPIColumn
76297>>>>>>>>>>>>>>>    Integer iFieldNumber
76297>>>>>>>>>>>>>>>    String  sFieldName
76297>>>>>>>>>>>>>>>    Integer iType
76297>>>>>>>>>>>>>>>    String  sType
76297>>>>>>>>>>>>>>>    Integer iLength
76297>>>>>>>>>>>>>>>    Integer iPrecision
76297>>>>>>>>>>>>>>>    Integer iOptions
76297>>>>>>>>>>>>>>>    Boolean bIsSQLType
76297>>>>>>>>>>>>>>>    Boolean bAllowNULL
76297>>>>>>>>>>>>>>>    String  sDefaultValue
76297>>>>>>>>>>>>>>>    Boolean bShouldChange
76297>>>>>>>>>>>>>>>    Boolean bCancel
76297>>>>>>>>>>>>>>>    Boolean bError
76297>>>>>>>>>>>>>>>End_Struct
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>Struct tAPIColumnCompare
76297>>>>>>>>>>>>>>>    Integer iFieldNumber
76297>>>>>>>>>>>>>>>    // FROM database:
76297>>>>>>>>>>>>>>>    Boolean bExistsFrom
76297>>>>>>>>>>>>>>>    String  sFieldNameFrom
76297>>>>>>>>>>>>>>>    Integer iTypeFrom
76297>>>>>>>>>>>>>>>    String  sTypeFrom
76297>>>>>>>>>>>>>>>    Integer iLengthFrom
76297>>>>>>>>>>>>>>>    Integer iPrecisionFrom
76297>>>>>>>>>>>>>>>    Integer iOptionsFrom
76297>>>>>>>>>>>>>>>    Boolean bIsSQLTypeFrom
76297>>>>>>>>>>>>>>>    Boolean bAllowNULLFrom
76297>>>>>>>>>>>>>>>    String  sDefaultValueFrom
76297>>>>>>>>>>>>>>>    Boolean bShouldChangeFrom
76297>>>>>>>>>>>>>>>    Boolean bCancelFrom
76297>>>>>>>>>>>>>>>    Boolean bErrorFrom
76297>>>>>>>>>>>>>>>    // TO database:
76297>>>>>>>>>>>>>>>    Boolean bExistsTo
76297>>>>>>>>>>>>>>>    Integer iFieldNumberTo
76297>>>>>>>>>>>>>>>    String  sFieldNameTo
76297>>>>>>>>>>>>>>>    Integer iTypeTo
76297>>>>>>>>>>>>>>>    String  sTypeTo
76297>>>>>>>>>>>>>>>    Integer iLengthTo
76297>>>>>>>>>>>>>>>    Integer iPrecisionTo
76297>>>>>>>>>>>>>>>    Integer iOptionsTo
76297>>>>>>>>>>>>>>>    Boolean bIsSQLTypeTo
76297>>>>>>>>>>>>>>>    Boolean bAllowNULLTo
76297>>>>>>>>>>>>>>>    String  sDefaultValueTo
76297>>>>>>>>>>>>>>>    Boolean bShouldChangeTo
76297>>>>>>>>>>>>>>>    Boolean bCancelTo
76297>>>>>>>>>>>>>>>    Boolean bErrorTo
76297>>>>>>>>>>>>>>>End_Struct
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>Struct tAPIRelation
76297>>>>>>>>>>>>>>>    Handle  hTableFrom
76297>>>>>>>>>>>>>>>    Integer iColumnFrom
76297>>>>>>>>>>>>>>>    Handle  hTableTo
76297>>>>>>>>>>>>>>>    Integer iColumnTo
76297>>>>>>>>>>>>>>>    String  sLogicalNameFrom
76297>>>>>>>>>>>>>>>    String  sLogicalNameTo
76297>>>>>>>>>>>>>>>    String  sFieldNameFrom
76297>>>>>>>>>>>>>>>    String  sFieldNameTo
76297>>>>>>>>>>>>>>>    Boolean bShouldChange
76297>>>>>>>>>>>>>>>    Boolean bCancel
76297>>>>>>>>>>>>>>>    Boolean bError
76297>>>>>>>>>>>>>>>End_Struct
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>Struct tAPIRelationCompare
76297>>>>>>>>>>>>>>>    // Common:
76297>>>>>>>>>>>>>>>    Handle  hTableFrom
76297>>>>>>>>>>>>>>>    Integer iColumnFrom
76297>>>>>>>>>>>>>>>    Handle  hTableTo
76297>>>>>>>>>>>>>>>    Integer iColumnTo
76297>>>>>>>>>>>>>>>    // FROM database:
76297>>>>>>>>>>>>>>>    Boolean bExistsFrom
76297>>>>>>>>>>>>>>>    String  sLogicalNameFrom_From
76297>>>>>>>>>>>>>>>    String  sLogicalNameTo_From
76297>>>>>>>>>>>>>>>    String  sFieldNameFrom_From
76297>>>>>>>>>>>>>>>    String  sFieldNameTo_From
76297>>>>>>>>>>>>>>>    Boolean bShouldChange_From
76297>>>>>>>>>>>>>>>    Boolean bCancel_From
76297>>>>>>>>>>>>>>>    Boolean bError_From
76297>>>>>>>>>>>>>>>    // TO database:
76297>>>>>>>>>>>>>>>    Boolean bExistsTo
76297>>>>>>>>>>>>>>>    String  sLogicalNameFrom_To
76297>>>>>>>>>>>>>>>    String  sLogicalNameTo_To
76297>>>>>>>>>>>>>>>    String  sFieldNameFrom_To
76297>>>>>>>>>>>>>>>    String  sFieldNameTo_To
76297>>>>>>>>>>>>>>>    Boolean bShouldChange_To
76297>>>>>>>>>>>>>>>    Boolean bCancel_To
76297>>>>>>>>>>>>>>>    Boolean bError_To
76297>>>>>>>>>>>>>>>End_Struct
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>Struct tAPIIndexSegment
76297>>>>>>>>>>>>>>>    Integer iFieldNumber
76297>>>>>>>>>>>>>>>    String  sFieldName
76297>>>>>>>>>>>>>>>    Boolean bUppercase
76297>>>>>>>>>>>>>>>    Boolean bAscending
76297>>>>>>>>>>>>>>>    Boolean bShouldChange
76297>>>>>>>>>>>>>>>    Boolean bCancel
76297>>>>>>>>>>>>>>>    Boolean bError
76297>>>>>>>>>>>>>>>End_Struct
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>Struct tAPIIndex
76297>>>>>>>>>>>>>>>    Integer iIndexNumber
76297>>>>>>>>>>>>>>>    Integer iPrimaryIndex
76297>>>>>>>>>>>>>>>    String  sSQLIndexName
76297>>>>>>>>>>>>>>>    Integer iSQLIndexType
76297>>>>>>>>>>>>>>>    Boolean bIsSQLClustered
76297>>>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKey
76297>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
76297>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
76297>>>>>>>>>>>>>>>    Boolean bShouldChange
76297>>>>>>>>>>>>>>>    Boolean bCancel
76297>>>>>>>>>>>>>>>    Boolean bError
76297>>>>>>>>>>>>>>>End_Struct
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>Struct tAPIIndexCompare
76297>>>>>>>>>>>>>>>    // Common:
76297>>>>>>>>>>>>>>>    Integer iIndexNumber
76297>>>>>>>>>>>>>>>    // FROM database:
76297>>>>>>>>>>>>>>>    Boolean bExistsFrom
76297>>>>>>>>>>>>>>>    Integer iPrimaryIndexFrom
76297>>>>>>>>>>>>>>>    String  sSQLIndexNameFrom
76297>>>>>>>>>>>>>>>    Integer iSQLIndexTypeFrom
76297>>>>>>>>>>>>>>>    Boolean bIsSQLClusteredFrom
76297>>>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
76297>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
76297>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
76297>>>>>>>>>>>>>>>    Boolean bShouldChangeFrom
76297>>>>>>>>>>>>>>>    Boolean bCancelFrom
76297>>>>>>>>>>>>>>>    Boolean bErrorFrom
76297>>>>>>>>>>>>>>>    // TO database:
76297>>>>>>>>>>>>>>>    Boolean bExistsTo
76297>>>>>>>>>>>>>>>    Integer iPrimaryIndexTo
76297>>>>>>>>>>>>>>>    String  sSQLIndexNameTo
76297>>>>>>>>>>>>>>>    Integer iSQLIndexTypeTo
76297>>>>>>>>>>>>>>>    Boolean bIsSQLClusteredTo
76297>>>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
76297>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
76297>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
76297>>>>>>>>>>>>>>>    Boolean bShouldChangeTo
76297>>>>>>>>>>>>>>>    Boolean bCancelTo
76297>>>>>>>>>>>>>>>    Boolean bErrorTo
76297>>>>>>>>>>>>>>>End_Struct
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>Struct tAPITableNameInfo
76297>>>>>>>>>>>>>>>    Integer iTableNumber
76297>>>>>>>>>>>>>>>    String  sRootName
76297>>>>>>>>>>>>>>>    String  sLogicalName
76297>>>>>>>>>>>>>>>    String  sDisplayName
76297>>>>>>>>>>>>>>>    String  sDriverID
76297>>>>>>>>>>>>>>>    Boolean bIsAlias
76297>>>>>>>>>>>>>>>    Boolean bIsSQL
76297>>>>>>>>>>>>>>>    Boolean bIsSystemFile
76297>>>>>>>>>>>>>>>    Boolean bShouldChange
76297>>>>>>>>>>>>>>>    Boolean bCancel
76297>>>>>>>>>>>>>>>    Boolean bError
76297>>>>>>>>>>>>>>>End_Struct
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>Struct tAPITableNameInfoCompare
76297>>>>>>>>>>>>>>>    Integer iTableNumber
76297>>>>>>>>>>>>>>>    // FROM
76297>>>>>>>>>>>>>>>    Boolean bExistsFrom
76297>>>>>>>>>>>>>>>    String  sRootNameFrom
76297>>>>>>>>>>>>>>>    String  sLogicalNameFrom
76297>>>>>>>>>>>>>>>    String  sDisplayNameFrom
76297>>>>>>>>>>>>>>>    String  sDriverIDFrom
76297>>>>>>>>>>>>>>>    Boolean bIsAliasFrom
76297>>>>>>>>>>>>>>>    Boolean bIsSQLFrom
76297>>>>>>>>>>>>>>>    Boolean bIsSystemFileFrom
76297>>>>>>>>>>>>>>>    // TO database:
76297>>>>>>>>>>>>>>>    Boolean bExistsTo
76297>>>>>>>>>>>>>>>    String  sRootNameTo
76297>>>>>>>>>>>>>>>    String  sLogicalNameTo
76297>>>>>>>>>>>>>>>    String  sDisplayNameTo
76297>>>>>>>>>>>>>>>    String  sDriverIDTo
76297>>>>>>>>>>>>>>>    Boolean bIsAliasTo
76297>>>>>>>>>>>>>>>    Boolean bIsSQLTo
76297>>>>>>>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
76297>>>>>>>>>>>>>>>    Boolean bShouldChange
76297>>>>>>>>>>>>>>>    Boolean bCancel
76297>>>>>>>>>>>>>>>    Boolean bError
76297>>>>>>>>>>>>>>>End_Struct
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>Struct tAPITable
76297>>>>>>>>>>>>>>>    Handle hTable
76297>>>>>>>>>>>>>>>    Boolean bFromTable
76297>>>>>>>>>>>>>>>    Boolean bToTable
76297>>>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
76297>>>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
76297>>>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
76297>>>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
76297>>>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
76297>>>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
76297>>>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
76297>>>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
76297>>>>>>>>>>>>>>>    Boolean bShouldChange
76297>>>>>>>>>>>>>>>    Boolean bCancel
76297>>>>>>>>>>>>>>>    Boolean bError
76297>>>>>>>>>>>>>>>End_Struct
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>Struct tAPITableCompare
76297>>>>>>>>>>>>>>>    Handle hTable
76297>>>>>>>>>>>>>>>    // FROM database:
76297>>>>>>>>>>>>>>>    Boolean bExistsFrom
76297>>>>>>>>>>>>>>>    // TO database:
76297>>>>>>>>>>>>>>>    Boolean bExistsTo
76297>>>>>>>>>>>>>>>    // Both:
76297>>>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
76297>>>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
76297>>>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
76297>>>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
76297>>>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
76297>>>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
76297>>>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
76297>>>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
76297>>>>>>>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
76297>>>>>>>>>>>>>>>    Boolean bCancel         // User cancel
76297>>>>>>>>>>>>>>>    Boolean bError          // Error occured while collecting data
76297>>>>>>>>>>>>>>>End_Struct
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>Struct tAPITableBooleans
76297>>>>>>>>>>>>>>>    Boolean bApiTableUpdateAuto
76297>>>>>>>>>>>>>>>    Boolean bCompareDate_DateTime
76297>>>>>>>>>>>>>>>    Boolean bCompareIndexAscending
76297>>>>>>>>>>>>>>>    Boolean bCompareIndexUppercase
76297>>>>>>>>>>>>>>>    Boolean bCompareFilelistUppercase
76297>>>>>>>>>>>>>>>End_Struct
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>Define C_tAPIColumn_None for 0
76297>>>>>>>>>>>>>>>Define C_tAPIColumn_Identity for 1
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>// SQL Key-Word Constants:  CI_SQLSelect CI_SQLName CI_SQLFrom  CI_SQLSys
76297>>>>>>>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
76297>>>>>>>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
76297>>>>>>>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
76297>>>>>>>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
76297>>>>>>>>>>>>>>>Enum_List
76297>>>>>>>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"
76297>>>>>>>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
76297>>>>>>>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
76297>>>>>>>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
76297>>>>>>>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
76297>>>>>>>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
76297>>>>>>>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
76297>>>>>>>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
76297>>>>>>>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
76297>>>>>>>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
76297>>>>>>>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
76297>>>>>>>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
76297>>>>>>>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
76297>>>>>>>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
76297>>>>>>>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
76297>>>>>>>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
76297>>>>>>>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
76297>>>>>>>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
76297>>>>>>>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
76297>>>>>>>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
76297>>>>>>>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
76297>>>>>>>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
76297>>>>>>>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
76297>>>>>>>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
76297>>>>>>>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
76297>>>>>>>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
76297>>>>>>>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
76297>>>>>>>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
76297>>>>>>>>>>>>>>>    Define CI_SQLTo                    //for "TO"
76297>>>>>>>>>>>>>>>    Define CI_SQLGO                    //for "GO"
76297>>>>>>>>>>>>>>>    Define CI_SQLUse                   //for "USE"
76297>>>>>>>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>    Define CI_SQLName                  //for "NAME"
76297>>>>>>>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
76297>>>>>>>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
76297>>>>>>>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
76297>>>>>>>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
76297>>>>>>>>>>>>>>>    Define CI_SQLID                    //for "ID"
76297>>>>>>>>>>>>>>>    Define CI_SQLAND                   //for "AND"
76297>>>>>>>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
76297>>>>>>>>>>>>>>>    Define CI_SQLSet                   //for "SET"
76297>>>>>>>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
76297>>>>>>>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
76297>>>>>>>>>>>>>>>    Define CI_SQL_SAFE_UPDATES         //for "SQL_SAFE_UPDATES"  
76297>>>>>>>>>>>>>>>    Define CI_SQLDescription          //for "SELECT name, description from sys.fn_helpcollations()" (Enumerates all collates)
76297>>>>>>>>>>>>>>>End_Enum_List
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>>>>>
76297>>>>>>>>>>>
76297>>>>>>>>>>>// This needs to be after Mertech drivers are defined.
76297>>>>>>>>>>>//Use cDbUpdateFunctionLibrary_Mixin.pkg
76297>>>>>>>>>>>
76297>>>>>>>>>>>
76297>>>>>>>>>>>// Create a new PSQL identifier for the Btrieve driver.
76297>>>>>>>>>>>    Define PSQLDRV_ID for "DFBTRDRV"
76297>>>>>>>>>>>
76297>>>>>>>>>>>    Define SQLFLEX   for "SQL_DRV"
76297>>>>>>>>>>>
76297>>>>>>>>>>>    Define MDSPgSQL  for "MDSPGSQL"
76297>>>>>>>>>>>
76297>>>>>>>>>>>    Define MDSMySQL  for "MDSMYSQL"
76297>>>>>>>>>>>
76297>>>>>>>>>>>    Define MDSDB2    for "MDS_DB2"
76297>>>>>>>>>>>
76297>>>>>>>>>>>    Define ORAFLEX   for "ORA_DRV"
76297>>>>>>>>>>>
76297>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
76297>>>>>>>>>>>// They can have slightly different SQL keywords.
76297>>>>>>>>>>>// Note: If a new type is added to the list,
76297>>>>>>>>>>>//       the struct array xxx must be adjusted
76297>>>>>>>>>>>//       so that it is filled with all SQL
76297>>>>>>>>>>>//       keywords for that new type.
76297>>>>>>>>>>>Enum_List  
76297>>>>>>>>>>>End_Enum_List
76297>>>>>>>>>>>
76297>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
76297>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
76297>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
76297>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
76297>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
76297>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
76297>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
76297>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
76297>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
76297>>>>>>>>>>>Define CS_DbTypePervasive   for "Pervasive.SQL (Btrieve)"
76297>>>>>>>>>>>
76297>>>>>>>>>>>
76297>>>>>>>>>>>// SQLConnection.ini constants:
76297>>>>>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
76297>>>>>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
76297>>>>>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
76297>>>>>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
76297>>>>>>>>>>>Define CS_SQLIniSectionName             for "Connection"
76297>>>>>>>>>>>Define CS_SQLODBCIniSectionName         for "ODBC"
76297>>>>>>>>>>>
76297>>>>>>>>>>>// DF 19 ini-file settings:
76297>>>>>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
76297>>>>>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
76297>>>>>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
76297>>>>>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
76297>>>>>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
76297>>>>>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
76297>>>>>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
76297>>>>>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
76297>>>>>>>>>>>Define CS_SQLIniFileDSNKeyword          for "FILEDSN"
76297>>>>>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
76297>>>>>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection" 
76297>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"
76297>>>>>>>>>>>
76297>>>>>>>>>>>// Database Update Framework extended settings:
76297>>>>>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
76297>>>>>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
76297>>>>>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
76297>>>>>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
76297>>>>>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
76297>>>>>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
76297>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
76297>>>>>>>>>>>
76297>>>>>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
76297>>>>>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
76297>>>>>>>>>>>Define CS_SQLIniConnectionNo            for "No"
76297>>>>>>>>>>>
76297>>>>>>>>>>>Struct tSQLConnection
76297>>>>>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
76297>>>>>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
76297>>>>>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
76297>>>>>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. MSSQLDRV, DB2_DRV, ODBC_DRV or PSQLDRV_ID.
76297>>>>>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
76297>>>>>>>>>>>    String sDatabase                // 6. SQL Database
76297>>>>>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
76297>>>>>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
76297>>>>>>>>>>>    String sUserID                  // 9. User ID
76297>>>>>>>>>>>    String sPassword                // 10. Password
76297>>>>>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
76297>>>>>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
76297>>>>>>>>>>>    String sLongTableSpace          // 13. DB2 specific
76297>>>>>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
76297>>>>>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
76297>>>>>>>>>>>    Boolean bError                  // 16. Set to true on error.
76297>>>>>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
76297>>>>>>>>>>>//    Boolean bDisabled               // 17. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
76297>>>>>>>>>>>//    Integer iDriverIndex            // 18. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
76297>>>>>>>>>>>End_Struct
76297>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
76297>>>>>>>>>
76297>>>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
76298>>>>>>>>>    Procedure CreateDbUpdateLibraryProperties
76300>>>>>>>>>        Handle hoSQLManagerMT
76300>>>>>>>>>
76300>>>>>>>>>        Property String private.psUseDatabase ""
76301>>>>>>>>>
76301>>>>>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
76301>>>>>>>>>        Property Handle  private.phCurrentTable 0
76302>>>>>>>>>        Property Integer private.piCurrentField 0
76303>>>>>>>>>
76303>>>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
76304>>>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
76305>>>>>>>>>
76305>>>>>>>>>        Property Handle phoSQLManagerMT
76306>>>>>>>>>
76306>>>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
76307>>>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
76308>>>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
76309>>>>>>>>>        Property Handle phoSQLConnectionHandler 0
76310>>>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
76311>>>>>>>>>
76311>>>>>>>>>        Property Boolean pbHandleQueryErrors True
76312>>>>>>>>>
76312>>>>>>>>>        Property tSqlColumnNew[] paQueryColumns
76313>>>>>>>>>        Property String[] paSQLFetchResults
76314>>>>>>>>>
76314>>>>>>>>>        // Error handling
76314>>>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
76315>>>>>>>>>        Property Boolean pbSqlError False
76316>>>>>>>>>        Property tSqlErrorArray paSqlErrorArray
76317>>>>>>>>>        Property Boolean pbProcessingError False
76318>>>>>>>>>
76318>>>>>>>>>        // Statistics on query
76318>>>>>>>>>        Property TimeSpan ptsTotalQueryTime
76319>>>>>>>>>        Property TimeSpan ptsQueryExec
76320>>>>>>>>>        Property TimeSpan ptsFetchResults
76321>>>>>>>>>        Property Integer piColumns 0
76322>>>>>>>>>        Property Integer piRows 0
76323>>>>>>>>>        Property Integer piRowType 0
76324>>>>>>>>>        Property String[] paQueryMessages
76325>>>>>>>>>        Property String psSQLStatementString
76326>>>>>>>>>
76326>>>>>>>>>        Property Integer[] paTableConvertExceptions
76327>>>>>>>>>
76327>>>>>>>>>        Property Integer[] paTableDateCorrectionExceptions
76328>>>>>>>>>
76328>>>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
76328>>>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
76328>>>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
76328>>>>>>>>>        Property Integer piChunkMax 500
76329>>>>>>>>>
76329>>>>>>>>>        // Fill the paSQLKeywordArray array with values;
76329>>>>>>>>>        Send SetupSQLKeywordArray
76330>>>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
76331>>>>>>>>>    End_Procedure
76332>>>>>>>>>
76332>>>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
76332>>>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
76334>>>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
76336>>>>>>>>>            Function_Return (EQ)
76337>>>>>>>>>        End
76337>>>>>>>>>>
76337>>>>>>>>>        Function_Return (GT)
76338>>>>>>>>>    End_Function
76339>>>>>>>>>
76339>>>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
76339>>>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
76341>>>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) ;            Function_Return (LT)
76344>>>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) ;            Function_Return (GT)
76347>>>>>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
76350>>>>>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
76353>>>>>>>>>
76353>>>>>>>>>        Function_Return (EQ)
76354>>>>>>>>>    End_Function
76355>>>>>>>>>
76355>>>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
76357>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
76357>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
76358>>>>>>>>>        Integer iSize
76358>>>>>>>>>
76358>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
76359>>>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
76360>>>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
76361>>>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
76362>>>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
76363>>>>>>>>>
76363>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
76364>>>>>>>>>    End_Procedure
76365>>>>>>>>>
76365>>>>>>>>>    // Creates a struct array with all SQL keywords
76365>>>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
76365>>>>>>>>>    // have slightly different wording.
76365>>>>>>>>>    // If a new EN_dbTypexxx type is added; additions
76365>>>>>>>>>    // needs to be done for every keyword group below.
76365>>>>>>>>>    Procedure SetupSQLKeywordArray
76367>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
76367>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
76369>>>>>>>>>
76369>>>>>>>>>        // This should only be called once; but in case it is
76369>>>>>>>>>        // we delete the array first.
76369>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
76370>>>>>>>>>
76370>>>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
76370>>>>>>>>>        //
76370>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
76371>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
76372>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
76373>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
76374>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"
76375>>>>>>>>>
76375>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
76376>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
76377>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
76378>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
76379>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"
76380>>>>>>>>>
76380>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
76381>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
76382>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
76383>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
76384>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"
76385>>>>>>>>>
76385>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
76386>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
76387>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
76388>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
76389>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"
76390>>>>>>>>>
76390>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
76391>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
76392>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
76393>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
76394>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"
76395>>>>>>>>>
76395>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
76396>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
76397>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
76398>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
76399>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
76400>>>>>>>>>
76400>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
76401>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
76402>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
76403>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
76404>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
76405>>>>>>>>>
76405>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
76406>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
76407>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
76408>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
76409>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
76410>>>>>>>>>
76410>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
76411>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
76412>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
76413>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
76414>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
76415>>>>>>>>>
76415>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_DbTypeMSSQL   ""
76416>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeMySQL   "SQL_SAFE_UPDATES"
76417>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeOracle  ""
76418>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeDB2     ""
76419>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypePostgre ""
76420>>>>>>>>>
76420>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
76421>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
76422>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
76423>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
76424>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
76425>>>>>>>>>
76425>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
76426>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
76427>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
76428>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
76429>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
76430>>>>>>>>>
76430>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
76431>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
76432>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
76433>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
76434>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
76435>>>>>>>>>
76435>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
76436>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
76437>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
76438>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
76439>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
76440>>>>>>>>>
76440>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
76441>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
76442>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
76443>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
76444>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
76445>>>>>>>>>
76445>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
76446>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
76447>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
76448>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
76449>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
76450>>>>>>>>>
76450>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
76451>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
76452>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
76453>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
76454>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
76455>>>>>>>>>
76455>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
76456>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
76457>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
76458>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
76459>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
76460>>>>>>>>>
76460>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
76461>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
76462>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
76463>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
76464>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
76465>>>>>>>>>
76465>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
76466>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
76467>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
76468>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
76469>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
76470>>>>>>>>>
76470>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
76471>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
76472>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
76473>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
76474>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
76475>>>>>>>>>
76475>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
76476>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
76477>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
76478>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
76479>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
76480>>>>>>>>>
76480>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
76481>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
76482>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
76483>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
76484>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
76485>>>>>>>>>
76485>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
76486>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
76487>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
76488>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
76489>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
76490>>>>>>>>>
76490>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
76491>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
76492>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
76493>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
76494>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
76495>>>>>>>>>
76495>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
76496>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
76497>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
76498>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
76499>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
76500>>>>>>>>>
76500>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
76501>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
76502>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
76503>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
76504>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
76505>>>>>>>>>
76505>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
76506>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
76507>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
76508>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
76509>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
76510>>>>>>>>>
76510>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
76511>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
76512>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
76513>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
76514>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
76515>>>>>>>>>
76515>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
76516>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
76517>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
76518>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
76519>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
76520>>>>>>>>>
76520>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
76521>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
76522>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
76523>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
76524>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
76525>>>>>>>>>
76525>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
76526>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
76527>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
76528>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
76529>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
76530>>>>>>>>>
76530>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
76531>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
76532>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
76533>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
76534>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
76535>>>>>>>>>
76535>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
76536>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
76537>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
76538>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
76539>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
76540>>>>>>>>>
76540>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
76541>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
76542>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
76543>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
76544>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
76545>>>>>>>>>
76545>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
76546>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
76547>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
76548>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
76549>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
76550>>>>>>>>>
76550>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
76551>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
76552>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
76553>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
76554>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
76555>>>>>>>>>
76555>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
76556>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
76557>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
76558>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
76559>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
76560>>>>>>>>>
76560>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
76561>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
76562>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
76563>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
76564>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
76565>>>>>>>>>
76565>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
76566>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
76567>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
76568>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
76569>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
76570>>>>>>>>>
76570>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
76571>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
76572>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
76573>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
76574>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
76575>>>>>>>>>
76575>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
76576>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
76577>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
76578>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
76579>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
76580>>>>>>>>>
76580>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
76581>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
76582>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
76583>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
76584>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
76585>>>>>>>>>
76585>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMSSQL   "DESCRIPTION"
76586>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMySQL   "DESCRIPTION"
76587>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeOracle  "DESCRIPTION"
76588>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeDB2     "DESCRIPTION"
76589>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypePostgre "DESCRIPTION"
76590>>>>>>>>>
76590>>>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
76590>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
76591>>>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
76592>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
76593>>>>>>>>>
76593>>>>>>>>>    End_Procedure
76594>>>>>>>>>
76594>>>>>>>>>End_Class
76595>>>>>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
76595>>>>>>>>>//****************************************************************************
76595>>>>>>>>>// $Module type: Class
76595>>>>>>>>>// $Module name: cSQLConnectionHandler.pkg
76595>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
76595>>>>>>>>>// Web-site    : http://www.rdctools.com
76595>>>>>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
76595>>>>>>>>>//
76595>>>>>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
76595>>>>>>>>>//
76595>>>>>>>>>// $Rev History:
76595>>>>>>>>>//    2015-08-11  Module header created
76595>>>>>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
76595>>>>>>>>>//                Added a new structure for passing connection data back & forth.
76595>>>>>>>>>//                Added better error handling.
76595>>>>>>>>>//                Added a decompose message for the connection string.
76595>>>>>>>>>//    2017-01-09  Added support for Mertech drivers
76595>>>>>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
76595>>>>>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
76595>>>>>>>>>//    2017-02-12  Reworked the whole connection property interface.
76595>>>>>>>>>//                Now there is one struct property that is the at cencter of a connection.
76595>>>>>>>>>//****************************************************************************
76595>>>>>>>>>Use cli.pkg
76595>>>>>>>>>Use MSSqldrv.pkg
76595>>>>>>>>>Use db2_drv.pkg
76595>>>>>>>>>Use odbc_drv.pkg
76595>>>>>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
76595>>>>>>>>>>>//****************************************************************************
76595>>>>>>>>>>>// $Module type: Class
76595>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
76595>>>>>>>>>>>//
76595>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
76595>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
76595>>>>>>>>>>>// E-mail      : support@rdctools.com
76595>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76595>>>>>>>>>>>//
76595>>>>>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
76595>>>>>>>>>>>//
76595>>>>>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
76595>>>>>>>>>>>//               properties of that object.
76595>>>>>>>>>>>//
76595>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
76595>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
76595>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
76595>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
76595>>>>>>>>>>>// in the help folder for more details.
76595>>>>>>>>>>>//
76595>>>>>>>>>>>Use cSQLConnectionIniFile.inc
76595>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
76595>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
76595>>>>>>>>>>>>>
76595>>>>>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
76596>>>>>>>>>>>>>    Procedure Construct_Object
76598>>>>>>>>>>>>>        Forward Send Construct_Object
76600>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
76601>>>>>>>>>>>>>    End_Procedure
76602>>>>>>>>>>>>>
76602>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
76604>>>>>>>>>>>>>        String sRetval
76604>>>>>>>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
76606>>>>>>>>>>>>>            Move CS_SQLIniFileDSNKeyword to sRetval    
76607>>>>>>>>>>>>>        End                                        
76607>>>>>>>>>>>>>>
76607>>>>>>>>>>>>>        Else Begin
76608>>>>>>>>>>>>>            Move CS_SQLIniDSNKeyword to sRetval
76609>>>>>>>>>>>>>        End
76609>>>>>>>>>>>>>>
76609>>>>>>>>>>>>>            
76609>>>>>>>>>>>>>        Function_Return sRetval
76610>>>>>>>>>>>>>    End_Function
76611>>>>>>>>>>>>>
76611>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
76613>>>>>>>>>>>>>        String sConnect sServerKeyWord sDriverID
76613>>>>>>>>>>>>>
76613>>>>>>>>>>>>>        Get psDriverID to sDriverID
76614>>>>>>>>>>>>>        Get ServerKeyword sServer to sServerKeyWord
76615>>>>>>>>>>>>>        Move (sConnect + sServerKeyWord + "=" + sServer) to sConnect
76616>>>>>>>>>>>>>        If (sServerKeyWord = CS_SQLIniDSNKeyword or sServerKeyWord = CS_SQLIniFileDSNKeyword) Begin
76618>>>>>>>>>>>>>            Move "" to sDatabase
76619>>>>>>>>>>>>>        End
76619>>>>>>>>>>>>>>
76619>>>>>>>>>>>>>        
76619>>>>>>>>>>>>>        // 2019-10-20 I think this was plain wrong for the DAW ODBC_DRV driver. At least it didn't work for login to an MS-SQL db.
76619>>>>>>>>>>>>>//        If (bTrusted = False and (sDriverID = ODBC_DRV_ID and sServerKeyWord = CS_SQLIniDSNKeyword)) Begin
76619>>>>>>>>>>>>>//            Function_Return sConnect
76619>>>>>>>>>>>>>//        End
76619>>>>>>>>>>>>>
76619>>>>>>>>>>>>>        If (sDatabase <> "") Begin
76621>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
76622>>>>>>>>>>>>>        End
76622>>>>>>>>>>>>>>
76622>>>>>>>>>>>>>        If (bTrusted = True) Begin
76624>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
76625>>>>>>>>>>>>>        End
76625>>>>>>>>>>>>>>
76625>>>>>>>>>>>>>        Else Begin
76626>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniUIDKeyword + "=" + sUserID + ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
76627>>>>>>>>>>>>>        End
76627>>>>>>>>>>>>>>
76627>>>>>>>>>>>>>        Function_Return sConnect
76628>>>>>>>>>>>>>    End_Function
76629>>>>>>>>>>>>>
76629>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
76631>>>>>>>>>>>>>        Boolean bLoginSuccessful
76631>>>>>>>>>>>>>        String sDriverID
76631>>>>>>>>>>>>>
76631>>>>>>>>>>>>>        Get psDriverID to sDriverID
76632>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
76634>>>>>>>>>>>>>            Function_Return True
76635>>>>>>>>>>>>>        End
76635>>>>>>>>>>>>>>
76635>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
76636>>>>>>>>>>>>>        If (bTrusted = False and sDatabase <> "") Begin
76638>>>>>>>>>>>>>            Move (SFormat("SERVER=%1;DATABASE=%2", sServer, sDatabase)) to sServer
76639>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
76641>>>>>>>>>>>>>        End
76641>>>>>>>>>>>>>>
76641>>>>>>>>>>>>>        Else Begin
76642>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
76644>>>>>>>>>>>>>        End
76644>>>>>>>>>>>>>>
76644>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
76645>>>>>>>>>>>>>        Function_Return bLoginSuccessful
76646>>>>>>>>>>>>>    End_Function
76647>>>>>>>>>>>>>End_Class
76648>>>>>>>>>>>>>
76648>>>>>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
76649>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
76651>>>>>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
76652>>>>>>>>>>>>>    End_Function
76653>>>>>>>>>>>>>End_Class
76654>>>>>>>>>>>>>
76654>>>>>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
76655>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
76657>>>>>>>>>>>>>        Boolean bLoginSuccessful
76657>>>>>>>>>>>>>        String sDriverID
76657>>>>>>>>>>>>>
76657>>>>>>>>>>>>>        Get psDriverID to sDriverID
76658>>>>>>>>>>>>>        Move (Trim(sDriverID)) to sDriverID
76659>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
76661>>>>>>>>>>>>>            Function_Return True
76662>>>>>>>>>>>>>        End
76662>>>>>>>>>>>>>>
76662>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
76663>>>>>>>>>>>>>        If (bTrusted = False) Begin
76665>>>>>>>>>>>>>            If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
76667>>>>>>>>>>>>>                Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sServer
76668>>>>>>>>>>>>>            End
76668>>>>>>>>>>>>>>
76668>>>>>>>>>>>>>            Else If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
76671>>>>>>>>>>>>>                Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
76672>>>>>>>>>>>>>            End
76672>>>>>>>>>>>>>>
76672>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
76674>>>>>>>>>>>>>        End
76674>>>>>>>>>>>>>>
76674>>>>>>>>>>>>>        Else Begin
76675>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
76677>>>>>>>>>>>>>        End
76677>>>>>>>>>>>>>>
76677>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
76678>>>>>>>>>>>>>
76678>>>>>>>>>>>>>        Function_Return bLoginSuccessful
76679>>>>>>>>>>>>>    End_Function
76680>>>>>>>>>>>>>End_Class
76681>>>>>>>>>>>>>
76681>>>>>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
76682>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
76684>>>>>>>>>>>>>        Boolean bLoginSuccessful
76684>>>>>>>>>>>>>        String sDriverID
76684>>>>>>>>>>>>>
76684>>>>>>>>>>>>>        Move False to Err
76685>>>>>>>>>>>>>        Get psDriverID to sDriverID
76686>>>>>>>>>>>>>        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
76688>>>>>>>>>>>>>            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
76689>>>>>>>>>>>>>        End
76689>>>>>>>>>>>>>>
76689>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
76691>>>>>>>>>>>>>
76691>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
76692>>>>>>>>>>>>>        Function_Return bLoginSuccessful
76693>>>>>>>>>>>>>    End_Function
76694>>>>>>>>>>>>>End_Class
76695>>>>>>>>>>>>>
76695>>>>>>>>>>>>>Class cDbUpdatePSQLDriver is a cDbUpdateGenericDatabaseDriver
76696>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
76698>>>>>>>>>>>>>        Boolean bLoginSuccessful
76698>>>>>>>>>>>>>        String sDriverID
76698>>>>>>>>>>>>>
76698>>>>>>>>>>>>>        Move False to Err
76699>>>>>>>>>>>>>        Get psDriverID to sDriverID
76700>>>>>>>>>>>>>//        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
76700>>>>>>>>>>>>>//            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
76700>>>>>>>>>>>>>//        End
76700>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
76702>>>>>>>>>>>>>
76702>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
76703>>>>>>>>>>>>>        Function_Return bLoginSuccessful
76704>>>>>>>>>>>>>    End_Function
76705>>>>>>>>>>>>>End_Class
76706>>>>>>>>>>>>>
76706>>>>>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
76707>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
76709>>>>>>>>>>>>>        Function_Return ""
76710>>>>>>>>>>>>>    End_Function
76711>>>>>>>>>>>>>End_Class
76712>>>>>>>>>>>>>
76712>>>>>>>>>>>>>Class cDbUpdateSQLFLEXDriver is a cDbUpdateGenericDatabaseDriver
76713>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
76715>>>>>>>>>>>>>        Boolean bLoginSuccessful
76715>>>>>>>>>>>>>        String sDriverID
76715>>>>>>>>>>>>>
76715>>>>>>>>>>>>>        Get psDriverID to sDriverID
76716>>>>>>>>>>>>>        //For the Mertech driver, using the Err indicator is the sanctioned way
76716>>>>>>>>>>>>>        Move False to Err
76717>>>>>>>>>>>>>        If (bTrusted = False) Begin
76719>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
76721>>>>>>>>>>>>>        End
76721>>>>>>>>>>>>>>
76721>>>>>>>>>>>>>        Else Begin
76722>>>>>>>>>>>>>            Login sServer "" "" sDriverID
76724>>>>>>>>>>>>>        End
76724>>>>>>>>>>>>>>
76724>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
76725>>>>>>>>>>>>>
76725>>>>>>>>>>>>>        Function_Return bLoginSuccessful
76726>>>>>>>>>>>>>    End_Function
76727>>>>>>>>>>>>>End_Class
76728>>>>>>>>>>>>>
76728>>>>>>>>>>>>>Class cDbUpdateORAFLEXDriver is a cDbUpdateGenericDatabaseDriver
76729>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
76731>>>>>>>>>>>>>        Boolean bLoginSuccessful
76731>>>>>>>>>>>>>        String sDriverID
76731>>>>>>>>>>>>>        Integer iPos
76731>>>>>>>>>>>>>
76731>>>>>>>>>>>>>        Get psDriverID to sDriverID
76732>>>>>>>>>>>>>        Move (Pos("/", sServer)) to iPos
76733>>>>>>>>>>>>>        If (iPos = 0) Begin
76735>>>>>>>>>>>>>            If (sDatabase <> "") Begin
76737>>>>>>>>>>>>>                Move (sServer + "/" + sDatabase) to sServer
76738>>>>>>>>>>>>>            End
76738>>>>>>>>>>>>>>
76738>>>>>>>>>>>>>        End
76738>>>>>>>>>>>>>>
76738>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
76738>>>>>>>>>>>>>        Move False to Err
76739>>>>>>>>>>>>>        // For Oracle I don't believe "Trusted" doesn't exist.
76739>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
76741>>>>>>>>>>>>>
76741>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
76742>>>>>>>>>>>>>        Function_Return bLoginSuccessful
76743>>>>>>>>>>>>>    End_Function
76744>>>>>>>>>>>>>End_Class
76745>>>>>>>>>>>>>
76745>>>>>>>>>>>>>Class cDbUpdateMDSMySQLDriver is a cDbUpdateGenericDatabaseDriver
76746>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
76748>>>>>>>>>>>>>        Boolean bLoginSuccessful
76748>>>>>>>>>>>>>        String sDriverID
76748>>>>>>>>>>>>>
76748>>>>>>>>>>>>>        Get psDriverID to sDriverID
76749>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
76749>>>>>>>>>>>>>        Move False to Err
76750>>>>>>>>>>>>>        If (bTrusted = False) Begin
76752>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
76754>>>>>>>>>>>>>        End
76754>>>>>>>>>>>>>>
76754>>>>>>>>>>>>>        Else Begin
76755>>>>>>>>>>>>>            Login sServer "" "" sDriverID
76757>>>>>>>>>>>>>        End
76757>>>>>>>>>>>>>>
76757>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
76758>>>>>>>>>>>>>        Function_Return bLoginSuccessful
76759>>>>>>>>>>>>>    End_Function
76760>>>>>>>>>>>>>End_Class
76761>>>>>>>>>>>>>
76761>>>>>>>>>>>>>Class cDbUpdateMDSPgSQLDriver is a cDbUpdateGenericDatabaseDriver
76762>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
76764>>>>>>>>>>>>>        Boolean bLoginSuccessful
76764>>>>>>>>>>>>>        String sDriverID
76764>>>>>>>>>>>>>
76764>>>>>>>>>>>>>        Get psDriverID to sDriverID
76765>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
76765>>>>>>>>>>>>>        Move False to Err
76766>>>>>>>>>>>>>        If (bTrusted = False) Begin
76768>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
76770>>>>>>>>>>>>>        End
76770>>>>>>>>>>>>>>
76770>>>>>>>>>>>>>        Else Begin
76771>>>>>>>>>>>>>            Login sServer "" "" sDriverID
76773>>>>>>>>>>>>>        End
76773>>>>>>>>>>>>>>
76773>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
76774>>>>>>>>>>>>>        Function_Return bLoginSuccessful
76775>>>>>>>>>>>>>    End_Function
76776>>>>>>>>>>>>>End_Class
76777>>>>>>>>>>>>>
76777>>>>>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
76778>>>>>>>>>>>>>    Procedure Construct_Object
76780>>>>>>>>>>>>>        Forward Send Construct_Object
76782>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
76783>>>>>>>>>>>>>        Property Handle phoDriverSpecificObject
76784>>>>>>>>>>>>>    End_Procedure
76785>>>>>>>>>>>>>
76785>>>>>>>>>>>>>    Function CreateDriver Returns Handle
76787>>>>>>>>>>>>>        String sDriverID
76787>>>>>>>>>>>>>        Handle hoDriver hcDriverClass
76787>>>>>>>>>>>>>
76787>>>>>>>>>>>>>        Get psDriverID to sDriverID
76788>>>>>>>>>>>>>        Case Begin
76788>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
76790>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
76791>>>>>>>>>>>>>                Case Break
76792>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
76795>>>>>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
76796>>>>>>>>>>>>>                Case Break
76797>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
76800>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
76801>>>>>>>>>>>>>                Case Break               
76802>>>>>>>>>>>>>//            Case (sDriverID = DFBTRDRV_ID)
76802>>>>>>>>>>>>>//                Move (RefClass(cDbUpdateDatabaseDriver)) to hcDriverClass
76802>>>>>>>>>>>>>//                Case Break
76802>>>>>>>>>>>>>            Case (sDriverID = SQLFLEX)
76805>>>>>>>>>>>>>                Move (RefClass(cDbUpdateSQLFLEXDriver))  to hcDriverClass
76806>>>>>>>>>>>>>                Case Break
76807>>>>>>>>>>>>>            Case (sDriverID = ORAFLEX)
76810>>>>>>>>>>>>>                Move (RefClass(cDbUpdateORAFLEXDriver))  to hcDriverClass
76811>>>>>>>>>>>>>                Case Break
76812>>>>>>>>>>>>>            Case (sDriverID = MDSPgSQL)
76815>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMDSPgSQLDriver)) to hcDriverClass
76816>>>>>>>>>>>>>                Case Break
76817>>>>>>>>>>>>>            Case (sDriverID = MDSMySQL)
76820>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMDSMySQLDriver)) to hcDriverClass
76821>>>>>>>>>>>>>                Case Break
76822>>>>>>>>>>>>>            // DATAFLEX_ID = Default driver
76822>>>>>>>>>>>>>            Case Else
76822>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
76823>>>>>>>>>>>>>                Move DATAFLEX_ID to sDriverID
76824>>>>>>>>>>>>>        Case End
76824>>>>>>>>>>>>>
76824>>>>>>>>>>>>>        Get Create hcDriverClass to hoDriver
76825>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
76826>>>>>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
76827>>>>>>>>>>>>>
76827>>>>>>>>>>>>>        Function_Return hoDriver
76828>>>>>>>>>>>>>    End_Function
76829>>>>>>>>>>>>>
76829>>>>>>>>>>>>>    Procedure DestroyDriver
76831>>>>>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
76833>>>>>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
76834>>>>>>>>>>>>>        End
76834>>>>>>>>>>>>>>
76834>>>>>>>>>>>>>    End_Procedure
76835>>>>>>>>>>>>>
76835>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
76837>>>>>>>>>>>>>        String sConnect
76837>>>>>>>>>>>>>        Handle hoDriver
76837>>>>>>>>>>>>>
76837>>>>>>>>>>>>>        Get CreateDriver to hoDriver
76838>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
76839>>>>>>>>>>>>>        Send DestroyDriver
76840>>>>>>>>>>>>>        Function_Return sConnect
76841>>>>>>>>>>>>>    End_Function
76842>>>>>>>>>>>>>
76842>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
76844>>>>>>>>>>>>>        Boolean bLoginSuccessful
76844>>>>>>>>>>>>>        Handle hoDriver
76844>>>>>>>>>>>>>
76844>>>>>>>>>>>>>        Get CreateDriver to hoDriver
76845>>>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
76846>>>>>>>>>>>>>        Send DestroyDriver
76847>>>>>>>>>>>>>        Function_Return bLoginSuccessful
76848>>>>>>>>>>>>>    End_Function
76849>>>>>>>>>>>>>
76849>>>>>>>>>>>>>End_Class
76850>>>>>>>>>>>
76850>>>>>>>>>>>    Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cLoginEncryption.pkg)
76850>>>>>>>>>>>>>Use cCryptographerEx.pkg
76850>>>>>>>>>>>>>
76850>>>>>>>>>>>>>Class cLoginEncryption is a cObject
76851>>>>>>>>>>>>>    
76851>>>>>>>>>>>>>    Procedure Construct_Object
76853>>>>>>>>>>>>>        Forward Send Construct_Object
76855>>>>>>>>>>>>>        // this must be set to a multi (40ish) character random key
76855>>>>>>>>>>>>>        Property String psEncryptPassword ""
76856>>>>>>>>>>>>>        
76856>>>>>>>>>>>>>        Object oDataCrypter is a cCryptographerEx
76858>>>>>>>>>>>>>            Set piHash to CALG_SHA_256
76859>>>>>>>>>>>>>            Set piCipher to CALG_AES_256
76860>>>>>>>>>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
76861>>>>>>>>>>>>>            Set piProvider to PROV_RSA_AES
76862>>>>>>>>>>>>>        End_Object
76863>>>>>>>>>>>>>    End_Procedure
76864>>>>>>>>>>>>>    
76864>>>>>>>>>>>>>    // This can be augmented to return a password encryption key using any
76864>>>>>>>>>>>>>    // hidden mechanism desired.
76864>>>>>>>>>>>>>    Function GetEncryptionPassword Returns String
76866>>>>>>>>>>>>>        String sPassword
76866>>>>>>>>>>>>>        Get psEncryptPassword to sPassword
76867>>>>>>>>>>>>>        Function_Return sPassword
76868>>>>>>>>>>>>>    End_Function
76869>>>>>>>>>>>>>    
76869>>>>>>>>>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
76869>>>>>>>>>>>>>    //
76869>>>>>>>>>>>>>    // Params:
76869>>>>>>>>>>>>>    //   sPlainText     String to encrypt.
76869>>>>>>>>>>>>>    // Returns:
76869>>>>>>>>>>>>>    //   Base64 encoded hash.
76869>>>>>>>>>>>>>    Function EncryptPassword String sPlainText Returns String
76871>>>>>>>>>>>>>        String sEncryptPassword sBase64
76871>>>>>>>>>>>>>        UChar[] ucBinary
76872>>>>>>>>>>>>>        Pointer pBase64
76872>>>>>>>>>>>>>        Integer iVoid
76872>>>>>>>>>>>>>        
76872>>>>>>>>>>>>>        //  Encrypt Key
76872>>>>>>>>>>>>>        Get GetEncryptionPassword to sEncryptPassword
76873>>>>>>>>>>>>>        If (sEncryptPassword = "") Begin
76875>>>>>>>>>>>>>            Error DFERR_PROGRAM "No encryption password set"
76876>>>>>>>>>>>>>>
76876>>>>>>>>>>>>>        End
76876>>>>>>>>>>>>>>
76876>>>>>>>>>>>>>        
76876>>>>>>>>>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
76877>>>>>>>>>>>>>        
76877>>>>>>>>>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
76879>>>>>>>>>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
76880>>>>>>>>>>>>>>
76880>>>>>>>>>>>>>            Function_Return ""
76881>>>>>>>>>>>>>        End
76881>>>>>>>>>>>>>>
76881>>>>>>>>>>>>>        
76881>>>>>>>>>>>>>        //  Encode binary hash to Base64
76881>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
76882>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sBase64
76883>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76884>>>>>>>>>>>>>        
76884>>>>>>>>>>>>>        Function_Return sBase64
76885>>>>>>>>>>>>>    End_Function
76886>>>>>>>>>>>>>    
76886>>>>>>>>>>>>>    
76886>>>>>>>>>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
76886>>>>>>>>>>>>>    //
76886>>>>>>>>>>>>>    // Params:
76886>>>>>>>>>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
76886>>>>>>>>>>>>>    // Returns:
76886>>>>>>>>>>>>>    //   Readable plain text password
76886>>>>>>>>>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
76888>>>>>>>>>>>>>        String sEncryptPassword
76888>>>>>>>>>>>>>        UChar[] ucBinary ucPlain
76890>>>>>>>>>>>>>        Boolean bIsHex
76890>>>>>>>>>>>>>        Integer iLen iVoid
76890>>>>>>>>>>>>>        Pointer pBinary
76890>>>>>>>>>>>>>        
76890>>>>>>>>>>>>>        If (sBase64EncryptedPassword <> "") Begin
76892>>>>>>>>>>>>>            //  Decode from Base64
76892>>>>>>>>>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
76893>>>>>>>>>>>>>            
76893>>>>>>>>>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
76894>>>>>>>>>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
76895>>>>>>>>>>>>>                        
76895>>>>>>>>>>>>>            Move (Free(pBinary)) to iVoid
76896>>>>>>>>>>>>>            
76896>>>>>>>>>>>>>            //  Encrypted binary hash to string
76896>>>>>>>>>>>>>            Get GetEncryptionPassword to sEncryptPassword
76897>>>>>>>>>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
76898>>>>>>>>>>>>>        End
76898>>>>>>>>>>>>>>
76898>>>>>>>>>>>>>        
76898>>>>>>>>>>>>>        Function_Return (UCharArrayToString(ucPlain))
76899>>>>>>>>>>>>>    End_Function
76900>>>>>>>>>>>>>End_Class
76901>>>>>>>>>>>
76901>>>>>>>>>>>Class cSQLConnectionIniFile is a cIniFile
76902>>>>>>>>>>>    Procedure Construct_Object
76904>>>>>>>>>>>        Forward Send Construct_Object
76906>>>>>>>>>>>
76906>>>>>>>>>>>        Property String Private_psIniFilePath
76907>>>>>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
76908>>>>>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
76909>>>>>>>>>>>
76909>>>>>>>>>>>        Property Boolean pbDFConnId False
76910>>>>>>>>>>>
76910>>>>>>>>>>>        // *** You really want to change this value! ***
76910>>>>>>>>>>>        // It is used when encrypting/decrypting passwords.
76910>>>>>>>>>>>        Property String psHashString "zx!2139(LI0+?ips7433"
76911>>>>>>>>>>>
76911>>>>>>>>>>>    End_Procedure
76912>>>>>>>>>>>
76912>>>>>>>>>>>    Procedure End_Construct_Object
76914>>>>>>>>>>>        Forward Send End_Construct_Object
76916>>>>>>>>>>>    End_Procedure
76917>>>>>>>>>>>
76917>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
76919>>>>>>>>>>>        String sIniFile
76919>>>>>>>>>>>        Get vFolderFormat sPath to sPath
76920>>>>>>>>>>>        Set private_psIniFilePath to sPath
76921>>>>>>>>>>>        Get psIniFileName to sIniFile
76922>>>>>>>>>>>        Set psFileName to (sPath + sIniFile)
76923>>>>>>>>>>>    End_Procedure
76924>>>>>>>>>>>
76924>>>>>>>>>>>    Function psIniFilePath Returns String
76926>>>>>>>>>>>        Function_Return (private_psIniFilePath(Self))
76927>>>>>>>>>>>    End_Function
76928>>>>>>>>>>>
76928>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
76930>>>>>>>>>>>        String sPath
76930>>>>>>>>>>>        Get psIniFilePath to sPath
76931>>>>>>>>>>>        Set psFileName to (sPath + sFileName)
76932>>>>>>>>>>>        Set private_psIniFileName to sFileName
76933>>>>>>>>>>>    End_Procedure
76934>>>>>>>>>>>
76934>>>>>>>>>>>    Function psIniFileName Returns String
76936>>>>>>>>>>>        Function_Return (private_psIniFileName(Self))
76937>>>>>>>>>>>    End_Function
76938>>>>>>>>>>>
76938>>>>>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
76938>>>>>>>>>>>    // Sets a value in the program's ini file (write)
76938>>>>>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
76938>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
76940>>>>>>>>>>>        String sIniFile sPath
76940>>>>>>>>>>>
76940>>>>>>>>>>>        Get psIniFilePath to sPath
76941>>>>>>>>>>>        Get psIniFileName to sIniFile
76942>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
76943>>>>>>>>>>>        Set psFileName to sIniFile
76944>>>>>>>>>>>        Send WriteString sSection sValueName sValue
76945>>>>>>>>>>>    End_Procedure
76946>>>>>>>>>>>
76946>>>>>>>>>>>    // Get a value from program's ini-file (read)
76946>>>>>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
76946>>>>>>>>>>>    // Returns the value
76946>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
76948>>>>>>>>>>>        String sValue sIniFile sPath
76948>>>>>>>>>>>
76948>>>>>>>>>>>        Get psIniFilePath to sPath
76949>>>>>>>>>>>        Get psIniFileName to sIniFile
76950>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
76951>>>>>>>>>>>        Set psFileName to sIniFile
76952>>>>>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
76953>>>>>>>>>>>
76953>>>>>>>>>>>        Function_Return sValue
76954>>>>>>>>>>>    End_Function
76955>>>>>>>>>>>
76955>>>>>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
76955>>>>>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
76957>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
76960>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
76963>>>>>>>>>>>
76963>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
76966>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
76969>>>>>>>>>>>
76969>>>>>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
76972>>>>>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
76975>>>>>>>>>>>
76975>>>>>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
76978>>>>>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
76981>>>>>>>>>>>
76981>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
76984>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
76987>>>>>>>>>>>
76987>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
76990>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
76993>>>>>>>>>>>
76993>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
76996>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
76999>>>>>>>>>>>
76999>>>>>>>>>>>        Function_Return (EQ)
77000>>>>>>>>>>>    End_Function
77001>>>>>>>>>>>
77001>>>>>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
77003>>>>>>>>>>>        Handle hoSections
77003>>>>>>>>>>>        Integer iItems
77003>>>>>>>>>>>
77003>>>>>>>>>>>        Send ReadSections hoSections
77004>>>>>>>>>>>        Move (Item_Count(hoSections)) to iItems
77005>>>>>>>>>>>        Function_Return iItems
77006>>>>>>>>>>>    End_Function
77007>>>>>>>>>>>
77007>>>>>>>>>>>    // The normal connection string looks something like this;
77007>>>>>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
77007>>>>>>>>>>>    // ...but the full connection string looks like this;
77007>>>>>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
77007>>>>>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
77007>>>>>>>>>>>//        String sSection
77007>>>>>>>>>>>//        Integer iCount
77007>>>>>>>>>>>//
77007>>>>>>>>>>>//        Move False to Err
77007>>>>>>>>>>>//        Get psIniSectionName to sSection
77007>>>>>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
77007>>>>>>>>>>>//        Increment iCount
77007>>>>>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
77007>>>>>>>>>>>//
77007>>>>>>>>>>>//        Function_Return (Err = False)
77007>>>>>>>>>>>//    End_Function
77007>>>>>>>>>>>
77007>>>>>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
77009>>>>>>>>>>>        Integer iCount
77009>>>>>>>>>>>        Boolean bExists
77009>>>>>>>>>>>        String sSection
77009>>>>>>>>>>>
77009>>>>>>>>>>>        Move False to Err
77010>>>>>>>>>>>        Move 1 to iCount
77011>>>>>>>>>>>        Get psIniSectionName to sSection
77012>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77013>>>>>>>>>>>        While (bExists = True)
77017>>>>>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
77018>>>>>>>>>>>            Increment iCount
77019>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77020>>>>>>>>>>>        Loop
77021>>>>>>>>>>>>
77021>>>>>>>>>>>        Function_Return (Err = False)
77022>>>>>>>>>>>    End_Function
77023>>>>>>>>>>>
77023>>>>>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
77025>>>>>>>>>>>        Integer iCount
77025>>>>>>>>>>>        String sSection
77025>>>>>>>>>>>        Boolean bExists
77025>>>>>>>>>>>
77025>>>>>>>>>>>        Move False to Err
77026>>>>>>>>>>>        Move 1 to iCount
77027>>>>>>>>>>>        Get psIniSectionName to sSection
77028>>>>>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
77029>>>>>>>>>>>        While (bExists = True)
77033>>>>>>>>>>>            If (iCount = iItem) Begin
77035>>>>>>>>>>>                Send DeleteSection sSection
77036>>>>>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
77036>>>>>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
77037>>>>>>>>>>>            End
77037>>>>>>>>>>>>
77037>>>>>>>>>>>            Increment iCount
77038>>>>>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
77039>>>>>>>>>>>        Loop
77040>>>>>>>>>>>>
77040>>>>>>>>>>>
77040>>>>>>>>>>>        Function_Return (Err = False)
77041>>>>>>>>>>>    End_Function
77042>>>>>>>>>>>
77042>>>>>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
77042>>>>>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
77042>>>>>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
77044>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77044>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77045>>>>>>>>>>>        tSQLConnection   SQLConnection
77045>>>>>>>>>>>        tSQLConnection   SQLConnection
77045>>>>>>>>>>>        Integer iIndex
77045>>>>>>>>>>>
77045>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
77046>>>>>>>>>>>        If (iIndex = -1) Begin
77048>>>>>>>>>>>            Move True to SQLConnection.bError
77049>>>>>>>>>>>            Function_Return SQLConnection
77050>>>>>>>>>>>        End
77050>>>>>>>>>>>>
77050>>>>>>>>>>>
77050>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77051>>>>>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
77052>>>>>>>>>>>
77052>>>>>>>>>>>        Function_Return SQLConnection
77053>>>>>>>>>>>    End_Function
77054>>>>>>>>>>>
77054>>>>>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
77054>>>>>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
77056>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77056>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77057>>>>>>>>>>>        Integer iRetval iCount iSize
77057>>>>>>>>>>>        String sValue
77057>>>>>>>>>>>        Boolean bExists
77057>>>>>>>>>>>
77057>>>>>>>>>>>        Move -1 to iRetval
77058>>>>>>>>>>>
77058>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77059>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77060>>>>>>>>>>>        Decrement iSize
77061>>>>>>>>>>>        For iCount from 0 to iSize
77067>>>>>>>>>>>>
77067>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
77068>>>>>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
77069>>>>>>>>>>>            If (bExists) Begin
77071>>>>>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
77072>>>>>>>>>>>                Move iSize to iCount         // We're done!
77073>>>>>>>>>>>            End
77073>>>>>>>>>>>>
77073>>>>>>>>>>>        Loop
77074>>>>>>>>>>>>
77074>>>>>>>>>>>
77074>>>>>>>>>>>        Function_Return iRetval
77075>>>>>>>>>>>    End_Function
77076>>>>>>>>>>>
77076>>>>>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
77076>>>>>>>>>>>    // Used to check that ConnectionID's are unique.
77076>>>>>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
77078>>>>>>>>>>>        Integer iCount iSize iItems
77078>>>>>>>>>>>        String sValue
77078>>>>>>>>>>>        Boolean bExists
77078>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77078>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77079>>>>>>>>>>>
77079>>>>>>>>>>>        Move 0 to iItems
77080>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77081>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77082>>>>>>>>>>>        Decrement iSize
77083>>>>>>>>>>>        For iCount from 0 to iSize
77089>>>>>>>>>>>>
77089>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
77090>>>>>>>>>>>            Move (sValue = sConnectionID) to bExists
77091>>>>>>>>>>>            If (bExists) Begin
77093>>>>>>>>>>>                Increment iItems
77094>>>>>>>>>>>            End
77094>>>>>>>>>>>>
77094>>>>>>>>>>>        Loop
77095>>>>>>>>>>>>
77095>>>>>>>>>>>
77095>>>>>>>>>>>        Function_Return (iItems > 1)
77096>>>>>>>>>>>    End_Function
77097>>>>>>>>>>>
77097>>>>>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
77097>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
77099>>>>>>>>>>>        Boolean bOK
77099>>>>>>>>>>>        Integer iSize iCount
77099>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77099>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77100>>>>>>>>>>>        tSQLConnection SQLConnection
77100>>>>>>>>>>>        tSQLConnection SQLConnection
77100>>>>>>>>>>>        String sConnectionString
77100>>>>>>>>>>>
77100>>>>>>>>>>>        Move False to Err
77101>>>>>>>>>>>        Get psConnectionString to sConnectionString
77102>>>>>>>>>>>
77102>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77103>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77104>>>>>>>>>>>        Decrement iSize
77105>>>>>>>>>>>        // Set all current connection to inactive.
77105>>>>>>>>>>>        For iCount from 0 to iSize
77111>>>>>>>>>>>>
77111>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
77112>>>>>>>>>>>        Loop
77113>>>>>>>>>>>>
77113>>>>>>>>>>>
77113>>>>>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
77114>>>>>>>>>>>        Move True              to SQLConnection.bEnabled
77115>>>>>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
77116>>>>>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
77117>>>>>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
77118>>>>>>>>>>>
77118>>>>>>>>>>>        Function_Return (bOK = True)
77119>>>>>>>>>>>    End_Function
77120>>>>>>>>>>>
77120>>>>>>>>>>>    // Used for updating an existing connection with new data.
77120>>>>>>>>>>>    // Returns True if successful.
77120>>>>>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
77122>>>>>>>>>>>        Boolean bOK
77122>>>>>>>>>>>        Integer iItem iSize iCount
77122>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77122>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77123>>>>>>>>>>>
77123>>>>>>>>>>>        Move False to Err
77124>>>>>>>>>>>        Move -1 to iItem
77125>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77126>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77127>>>>>>>>>>>        Decrement iSize
77128>>>>>>>>>>>        // Set all current connection to inactive.
77128>>>>>>>>>>>        For iCount from 0 to iSize
77134>>>>>>>>>>>>
77134>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
77135>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
77137>>>>>>>>>>>                Move iCount to iItem
77138>>>>>>>>>>>            End
77138>>>>>>>>>>>>
77138>>>>>>>>>>>        Loop
77139>>>>>>>>>>>>
77139>>>>>>>>>>>
77139>>>>>>>>>>>        If (iItem <> -1) Begin
77141>>>>>>>>>>>            Move True to SQLConnection.bEnabled
77142>>>>>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
77143>>>>>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
77144>>>>>>>>>>>        End
77144>>>>>>>>>>>>
77144>>>>>>>>>>>
77144>>>>>>>>>>>        Function_Return (bOK = True)
77145>>>>>>>>>>>    End_Function
77146>>>>>>>>>>>
77146>>>>>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
77148>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77148>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77149>>>>>>>>>>>        String sSection sValue
77149>>>>>>>>>>>        Integer iCount
77149>>>>>>>>>>>        Boolean bExists
77149>>>>>>>>>>>
77149>>>>>>>>>>>        Get psIniSectionName to sSection
77150>>>>>>>>>>>        Get SectionExists sSection to bExists
77151>>>>>>>>>>>        If (bExists = False) Begin
77153>>>>>>>>>>>            Function_Return SQLConnectionsArray
77154>>>>>>>>>>>        End
77154>>>>>>>>>>>>
77154>>>>>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
77155>>>>>>>>>>>        If (bExists = True) Begin
77157>>>>>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
77158>>>>>>>>>>>>
77158>>>>>>>>>>>        End
77158>>>>>>>>>>>>
77158>>>>>>>>>>>
77158>>>>>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
77159>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77160>>>>>>>>>>>
77160>>>>>>>>>>>        While (bExists = True)                 
77164>>>>>>>>>>>            // 2018-07-14 Change to allow disabling all connections in test environment.
77164>>>>>>>>>>>            // We always put the enabled/active connection at the top
77164>>>>>>>>>>>//            Move (iCount = 1) to bEnabled
77164>>>>>>>>>>>//            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
77164>>>>>>>>>>>
77164>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
77165>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
77166>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword     ""        to sValue
77167>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", False, True))                                               to SQLConnectionsArray[iCount].bEnabled
77168>>>>>>>>>>>
77168>>>>>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
77168>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
77169>>>>>>>>>>>            If (sValue = "99") Begin
77171>>>>>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
77172>>>>>>>>>>>            End
77172>>>>>>>>>>>>
77172>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
77173>>>>>>>>>>>
77173>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
77174>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
77175>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
77177>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniFileDSNKeyword +"=") to SQLConnectionsArray[iCount].sServer
77178>>>>>>>>>>>            End
77178>>>>>>>>>>>>
77178>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
77180>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
77181>>>>>>>>>>>            End
77181>>>>>>>>>>>>
77181>>>>>>>>>>>
77181>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
77182>>>>>>>>>>>
77182>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
77183>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
77184>>>>>>>>>>>
77184>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
77185>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
77186>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
77188>>>>>>>>>>>                Get DecryptPassword sValue to sValue
77189>>>>>>>>>>>            End
77189>>>>>>>>>>>>
77189>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
77190>>>>>>>>>>>
77190>>>>>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
77190>>>>>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
77191>>>>>>>>>>>
77191>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
77192>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
77193>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
77194>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
77195>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to sValue
77196>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bSilentLogin
77197>>>>>>>>>>>
77197>>>>>>>>>>>            Increment iCount
77198>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77199>>>>>>>>>>>        Loop
77200>>>>>>>>>>>>
77200>>>>>>>>>>>
77200>>>>>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
77200>>>>>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
77202>>>>>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
77203>>>>>>>>>>>        End
77203>>>>>>>>>>>>
77203>>>>>>>>>>>
77203>>>>>>>>>>>        Function_Return SQLConnectionsArray
77204>>>>>>>>>>>    End_Function
77205>>>>>>>>>>>
77205>>>>>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
77207>>>>>>>>>>>        Integer iCount iSize
77207>>>>>>>>>>>        Boolean bOK
77207>>>>>>>>>>>        String sSection sValue
77207>>>>>>>>>>>
77207>>>>>>>>>>>        // First we need to _remove_ all current connections from the ini-file.
77207>>>>>>>>>>>        Move 0 to iCount
77208>>>>>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
77209>>>>>>>>>>>        If (bOK = False) Begin
77211>>>>>>>>>>>            Function_Return False
77212>>>>>>>>>>>        End
77212>>>>>>>>>>>>
77212>>>>>>>>>>>
77212>>>>>>>>>>>        Move False to Err
77213>>>>>>>>>>>        Get psIniSectionName to sSection
77214>>>>>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
77214>>>>>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
77215>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77216>>>>>>>>>>>        Decrement iSize
77217>>>>>>>>>>>
77217>>>>>>>>>>>        For iCount from 0 to iSize
77223>>>>>>>>>>>>
77223>>>>>>>>>>>            // DF 19 compatible settings:
77223>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
77224>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
77225>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDisabledKeyword       to (If(SQLConnectionsArray[iCount].bEnabled = 0, "Yes", "No"))
77226>>>>>>>>>>>            
77226>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
77227>>>>>>>>>>>
77227>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
77228>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
77230>>>>>>>>>>>                Get EncryptPassword sValue to sValue
77231>>>>>>>>>>>            End
77231>>>>>>>>>>>>
77231>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
77232>>>>>>>>>>>
77232>>>>>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
77234>>>>>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
77235>>>>>>>>>>>            End
77235>>>>>>>>>>>>
77235>>>>>>>>>>>
77235>>>>>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
77236>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
77237>>>>>>>>>>>
77237>>>>>>>>>>>            // The Database Update Framework extended settings:
77237>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
77238>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
77239>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
77240>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
77241>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
77242>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to (If(SQLConnectionsArray[iCount].bSilentLogin = 1, "Yes", "No"))
77243>>>>>>>>>>>        Loop
77244>>>>>>>>>>>>
77244>>>>>>>>>>>
77244>>>>>>>>>>>        Function_Return (bOK and Err = False)
77245>>>>>>>>>>>    End_Function
77246>>>>>>>>>>>
77246>>>>>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
77246>>>>>>>>>>>    //
77246>>>>>>>>>>>    // SQL utility function that returns a database type (string) constant
77246>>>>>>>>>>>    // corresponding to the passed iDbType.
77246>>>>>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
77248>>>>>>>>>>>        String sRetval
77248>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
77250>>>>>>>>>>>            Move CS_dbTypeMSSQL to sRetval
77251>>>>>>>>>>>        End
77251>>>>>>>>>>>>
77251>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
77253>>>>>>>>>>>            Move CS_dbTypeMySQL to sRetval
77254>>>>>>>>>>>        End
77254>>>>>>>>>>>>
77254>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
77256>>>>>>>>>>>            Move CS_dbTypeOracle to sRetval
77257>>>>>>>>>>>        End
77257>>>>>>>>>>>>
77257>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
77259>>>>>>>>>>>            Move CS_dbTypeDB2 to sRetval
77260>>>>>>>>>>>        End
77260>>>>>>>>>>>>
77260>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
77262>>>>>>>>>>>            Move CS_dbTypePostgre to sRetval
77263>>>>>>>>>>>        End
77263>>>>>>>>>>>>
77263>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
77265>>>>>>>>>>>            Move CS_DbTypePervasive to sRetval
77266>>>>>>>>>>>        End
77266>>>>>>>>>>>>
77266>>>>>>>>>>>        Function_Return sRetval
77267>>>>>>>>>>>    End_Function
77268>>>>>>>>>>>
77268>>>>>>>>>>>    // SQL utility function that returns a database type constant (integer)
77268>>>>>>>>>>>    // corresponding to the passed sDbType string constant.
77268>>>>>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
77270>>>>>>>>>>>        Integer iRetval
77270>>>>>>>>>>>        If (sDbType = CS_dbTypeMSSQL) Begin
77272>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77273>>>>>>>>>>>        End
77273>>>>>>>>>>>>
77273>>>>>>>>>>>        If (sDbType = CS_dbTypeMySQL) Begin
77275>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
77276>>>>>>>>>>>        End
77276>>>>>>>>>>>>
77276>>>>>>>>>>>        If (sDbType = CS_dbTypeOracle) Begin
77278>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
77279>>>>>>>>>>>        End
77279>>>>>>>>>>>>
77279>>>>>>>>>>>        If (sDbType = CS_dbTypeDB2) Begin
77281>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
77282>>>>>>>>>>>        End
77282>>>>>>>>>>>>
77282>>>>>>>>>>>        If (sDbType = CS_dbTypePostgre) Begin
77284>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
77285>>>>>>>>>>>        End
77285>>>>>>>>>>>>
77285>>>>>>>>>>>        If (sDbType = CS_DbTypePervasive) Begin
77287>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
77288>>>>>>>>>>>        End
77288>>>>>>>>>>>>
77288>>>>>>>>>>>        Function_Return iRetval
77289>>>>>>>>>>>    End_Function
77290>>>>>>>>>>>
77290>>>>>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
77290>>>>>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
77290>>>>>>>>>>>    // the SQL Connection program's grid.
77290>>>>>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
77292>>>>>>>>>>>        String sRetval
77292>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
77294>>>>>>>>>>>            Move "EN_dbTypeMSSQL" to sRetval
77295>>>>>>>>>>>        End
77295>>>>>>>>>>>>
77295>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
77297>>>>>>>>>>>            Move "EN_dbTypeMySQL" to sRetval
77298>>>>>>>>>>>        End
77298>>>>>>>>>>>>
77298>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
77300>>>>>>>>>>>            Move "EN_dbTypeOracle" to sRetval
77301>>>>>>>>>>>        End
77301>>>>>>>>>>>>
77301>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
77303>>>>>>>>>>>            Move "EN_dbTypeDB2" to sRetval
77304>>>>>>>>>>>        End
77304>>>>>>>>>>>>
77304>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
77306>>>>>>>>>>>            Move "EN_dbTypePostgre" to sRetval
77307>>>>>>>>>>>        End
77307>>>>>>>>>>>>
77307>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
77309>>>>>>>>>>>            Move "EN_dbTypePervasive" to sRetval
77310>>>>>>>>>>>        End
77310>>>>>>>>>>>>
77310>>>>>>>>>>>        Function_Return sRetval
77311>>>>>>>>>>>    End_Function
77312>>>>>>>>>>>
77312>>>>>>>>>>>    // Pass a driver id and the function will return
77312>>>>>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
77312>>>>>>>>>>>    // quite work and always returns "MS SQL Server"
77312>>>>>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
77314>>>>>>>>>>>        Integer iRetval
77314>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
77316>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77317>>>>>>>>>>>        End
77317>>>>>>>>>>>>
77317>>>>>>>>>>>        If (sDriverID = SQLFLEX) Begin
77319>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77320>>>>>>>>>>>        End
77320>>>>>>>>>>>>
77320>>>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
77322>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77323>>>>>>>>>>>        End
77323>>>>>>>>>>>>
77323>>>>>>>>>>>        If (sDriverID = MDSMySQL) Begin
77325>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
77326>>>>>>>>>>>        End
77326>>>>>>>>>>>>
77326>>>>>>>>>>>        If (sDriverID = ORAFLEX) Begin
77328>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
77329>>>>>>>>>>>        End
77329>>>>>>>>>>>>
77329>>>>>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
77331>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
77332>>>>>>>>>>>        End
77332>>>>>>>>>>>>
77332>>>>>>>>>>>        If (sDriverID = MDSPgSQL) Begin
77334>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
77335>>>>>>>>>>>        End
77335>>>>>>>>>>>>
77335>>>>>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
77337>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
77338>>>>>>>>>>>        End
77338>>>>>>>>>>>>
77338>>>>>>>>>>>        Function_Return iRetval
77339>>>>>>>>>>>    End_Function
77340>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
77340>>>>>>>>>>>>
77340>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
77342>>>>>>>>>>>>    Integer iStart iEnd
77342>>>>>>>>>>>>    String sRetval
77342>>>>>>>>>>>>
77342>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
77343>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
77344>>>>>>>>>>>>    If (iStart = 0) Begin
77346>>>>>>>>>>>>        Function_Return ""
77347>>>>>>>>>>>>    End
77347>>>>>>>>>>>>>
77347>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
77348>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
77349>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
77351>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77352>>>>>>>>>>>>    End
77352>>>>>>>>>>>>>
77352>>>>>>>>>>>>    Else Begin
77353>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
77354>>>>>>>>>>>>    End
77354>>>>>>>>>>>>>
77354>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
77356>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77357>>>>>>>>>>>>        Decrement iEnd
77358>>>>>>>>>>>>    End
77358>>>>>>>>>>>>>
77358>>>>>>>>>>>>    If (iEnd <> 0) Begin
77360>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
77361>>>>>>>>>>>>    End
77361>>>>>>>>>>>>>
77361>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
77362>>>>>>>>>>>>
77362>>>>>>>>>>>>    Function_Return (Trim(sRetval))
77363>>>>>>>>>>>>End_Function
77364>>>>>>>>>>>>
77364>>>>>>>>>>>>
77364>>>>>>>>>>>
77364>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77366>>>>>>>>>>>        String sConnect
77366>>>>>>>>>>>        Handle hoDriver
77366>>>>>>>>>>>
77366>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
77367>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
77368>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
77369>>>>>>>>>>>        Send Destroy of hoDriver
77370>>>>>>>>>>>
77370>>>>>>>>>>>        Function_Return sConnect
77371>>>>>>>>>>>    End_Function
77372>>>>>>>>>>>
77372>>>>>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
77372>>>>>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
77374>>>>>>>>>>>        String sConnect
77374>>>>>>>>>>>
77374>>>>>>>>>>>        Case Begin
77374>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX)
77376>>>>>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
77377>>>>>>>>>>>                If (sDatabase <> "") Begin
77379>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77380>>>>>>>>>>>                End
77380>>>>>>>>>>>>
77380>>>>>>>>>>>                Case Break
77381>>>>>>>>>>>
77381>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
77384>>>>>>>>>>>                If (Uppercase(sServer) contains ".DSN") Begin
77386>>>>>>>>>>>                    Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sConnect
77387>>>>>>>>>>>                End
77387>>>>>>>>>>>>
77387>>>>>>>>>>>                Else If (not(Uppercase(sServer) contains "DSN")) Begin
77390>>>>>>>>>>>                    Move (CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77391>>>>>>>>>>>                End
77391>>>>>>>>>>>>
77391>>>>>>>>>>>
77391>>>>>>>>>>>                If (sDatabase <> "") Begin
77393>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77394>>>>>>>>>>>                End
77394>>>>>>>>>>>>
77394>>>>>>>>>>>                Case Break
77395>>>>>>>>>>>
77395>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
77398>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77399>>>>>>>>>>>                If (sDatabase <> "") Begin
77401>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77402>>>>>>>>>>>                End
77402>>>>>>>>>>>>
77402>>>>>>>>>>>                Case Break
77403>>>>>>>>>>>
77403>>>>>>>>>>>            Case (sDriverID = ORAFLEX)
77406>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77407>>>>>>>>>>>                If (sDatabase <> "") Begin
77409>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77410>>>>>>>>>>>                End
77410>>>>>>>>>>>>
77410>>>>>>>>>>>                Case Break
77411>>>>>>>>>>>
77411>>>>>>>>>>>            Case (sDriverID = MDSPgSQL)
77414>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77415>>>>>>>>>>>                If (sDatabase <> "") Begin
77417>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77418>>>>>>>>>>>                End
77418>>>>>>>>>>>>
77418>>>>>>>>>>>                Case Break
77419>>>>>>>>>>>
77419>>>>>>>>>>>            Case (sDriverID = MDSMySQL)
77422>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77423>>>>>>>>>>>                If (sDatabase <> "") Begin
77425>>>>>>>>>>>                    Move (sConnect * ";" +CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77426>>>>>>>>>>>                End
77426>>>>>>>>>>>>
77426>>>>>>>>>>>                Case Break
77427>>>>>>>>>>>
77427>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
77430>>>>>>>>>>>                Break
77431>>>>>>>>>>>
77431>>>>>>>>>>>            Case Else
77431>>>>>>>>>>>                Move "" to sConnect
77432>>>>>>>>>>>        Case End
77432>>>>>>>>>>>
77432>>>>>>>>>>>        Function_Return sConnect
77433>>>>>>>>>>>    End_Function
77434>>>>>>>>>>>
77434>>>>>>>>>>>    // Use Base64
77434>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
77436>>>>>>>>>>>        String sRetval
77436>>>>>>>>>>>        Handle hoLoginEncryption
77436>>>>>>>>>>>
77436>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
77437>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
77438>>>>>>>>>>>        Get EncryptPassword of hoLoginEncryption sPassword to sRetval
77439>>>>>>>>>>>        Send Destroy of hoLoginEncryption
77440>>>>>>>>>>>          
77440>>>>>>>>>>>        Function_Return sRetval
77441>>>>>>>>>>>    End_Function
77442>>>>>>>>>>>
77442>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
77444>>>>>>>>>>>        String sRetval
77444>>>>>>>>>>>        Handle hoLoginEncryption
77444>>>>>>>>>>>
77444>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
77445>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
77446>>>>>>>>>>>        Get DecryptPassword of hoLoginEncryption sPassword to sRetval
77447>>>>>>>>>>>        Send Destroy of hoLoginEncryption
77448>>>>>>>>>>>
77448>>>>>>>>>>>        Function_Return sRetval
77449>>>>>>>>>>>    End_Function
77450>>>>>>>>>>>
77450>>>>>>>>>>>    // Returns the full path of the Application (no trailing "\")
77450>>>>>>>>>>>    Function ApplicationPath Returns String
77452>>>>>>>>>>>        String sApplicationFileName sPath
77452>>>>>>>>>>>        Integer iNumChars iRetval
77452>>>>>>>>>>>
77452>>>>>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
77453>>>>>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
77454>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
77455>>>>>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
77456>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sPath
77457>>>>>>>>>>>
77457>>>>>>>>>>>        Function_Return sPath
77458>>>>>>>>>>>    End_Function
77459>>>>>>>>>>>
77459>>>>>>>>>>>    // Pass a filename including the extension. The return value
77459>>>>>>>>>>>    // will be the path of of the first found "sSearchFileName in the workspace.
77459>>>>>>>>>>>    // If not found in the workspace it will be search "globally" by the Get_File_Path command.
77459>>>>>>>>>>>    Function SearchLocallyThenGloballyForFile String sSearchFileName Returns String
77461>>>>>>>>>>>        Boolean bExists
77461>>>>>>>>>>>        Handle hoPaths hoIniFile
77461>>>>>>>>>>>        String[] asWorkSpaceFiles
77462>>>>>>>>>>>        String sProgramsPath sSection sFileName sRelativePath sRelativePaths sPath sDirSep sProgramsDir
77462>>>>>>>>>>>        Integer iSize iCount iPath iNoOfPaths iCountPath
77462>>>>>>>>>>>        
77462>>>>>>>>>>>        Get psIniFilePath to sProgramsPath
77463>>>>>>>>>>>        Get vFolderFormat sProgramsPath to sProgramsPath 
77464>>>>>>>>>>>        Move (Lowercase(sSearchFileName)) to sSearchFileName
77465>>>>>>>>>>>        Get vFilePathExists (sProgramsPath + sSearchFileName) to bExists   
77466>>>>>>>>>>>        If (bExists = True) Begin
77468>>>>>>>>>>>            Function_Return sProgramsPath
77469>>>>>>>>>>>        End                      
77469>>>>>>>>>>>>
77469>>>>>>>>>>>    
77469>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
77470>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
77472>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
77473>>>>>>>>>>>        End                                              
77473>>>>>>>>>>>>
77473>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sProgramsDir
77474>>>>>>>>>>>        
77474>>>>>>>>>>>        Move False to bExists
77475>>>>>>>>>>>        Get Create (RefClass(Array)) to hoPaths
77476>>>>>>>>>>>        Get WorkspaceIniFiles sProgramsPath to asWorkspaceFiles
77477>>>>>>>>>>>        Move (SizeOfArray(asWorkspaceFiles)) to iSize
77478>>>>>>>>>>>        Decrement iSize       
77479>>>>>>>>>>>        
77479>>>>>>>>>>>        For iCount from 0 to iSize
77485>>>>>>>>>>>>
77485>>>>>>>>>>>            Move asWorkspaceFiles[iCount] to sFileName
77486>>>>>>>>>>>            Get Create (Refclass(cIniFile)) to hoIniFile
77487>>>>>>>>>>>            Set psFileName of hoIniFile to sFileName
77488>>>>>>>>>>>            Send ReadSection of hoIniFile "Workspace" hoPaths
77489>>>>>>>>>>>            For iPath from 0 to (Item_Count(hoPaths) -1)
77495>>>>>>>>>>>>
77495>>>>>>>>>>>                Get Value of hoPaths iPath to sSection    
77496>>>>>>>>>>>                Get ReadString of hoIniFile "Workspace" sSection "" to sRelativePath 
77497>>>>>>>>>>>                // Check if there are more than one path specified;
77497>>>>>>>>>>>                Get CountOfPaths of (phoWorkspace(ghoApplication)) sRelativePath to iNoOfPaths
77498>>>>>>>>>>>                If (iNoOfPaths > 1) Begin         
77500>>>>>>>>>>>                    Move sRelativePath to sRelativePaths
77501>>>>>>>>>>>                    For iCountPath from 1 to iNoOfPaths
77507>>>>>>>>>>>>
77507>>>>>>>>>>>                        Get PathAtIndex of (phoWorkspace(ghoApplication)) sRelativePaths iCountPath to sRelativePath
77508>>>>>>>>>>>                        Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
77509>>>>>>>>>>>                        Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
77510>>>>>>>>>>>                        Get vFolderFormat sPath to sPath
77511>>>>>>>>>>>                        Get vFilePathExists (sPath + sSearchFileName) to bExists
77512>>>>>>>>>>>                        If (bExists = True) Begin
77514>>>>>>>>>>>                            Move iNoOfPaths to iCountPath
77515>>>>>>>>>>>                            Move (Item_Count(hoPaths)) to iPath // We're done.
77516>>>>>>>>>>>                            Move iSize to iCount
77517>>>>>>>>>>>                        End                                                    
77517>>>>>>>>>>>>
77517>>>>>>>>>>>                    Loop
77518>>>>>>>>>>>>
77518>>>>>>>>>>>                End
77518>>>>>>>>>>>>
77518>>>>>>>>>>>                Else Begin
77519>>>>>>>>>>>                    Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
77520>>>>>>>>>>>                    Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
77521>>>>>>>>>>>                    Get vFolderFormat sPath to sPath
77522>>>>>>>>>>>                    Get vFilePathExists (sPath + sSearchFileName) to bExists
77523>>>>>>>>>>>                    If (bExists = True) Begin
77525>>>>>>>>>>>                        Move (Item_Count(hoPaths)) to iPath // We're done.
77526>>>>>>>>>>>                        Move iSize to iCount
77527>>>>>>>>>>>                    End                                                    
77527>>>>>>>>>>>>
77527>>>>>>>>>>>                End
77527>>>>>>>>>>>>
77527>>>>>>>>>>>            Loop
77528>>>>>>>>>>>>
77528>>>>>>>>>>>            If (bExists = False) Begin
77530>>>>>>>>>>>                Move "" to sPath    
77531>>>>>>>>>>>            End
77531>>>>>>>>>>>>
77531>>>>>>>>>>>            Send Destroy of hoIniFile          
77532>>>>>>>>>>>        Loop        
77533>>>>>>>>>>>>
77533>>>>>>>>>>>        Send Destroy of hoPaths
77534>>>>>>>>>>>        
77534>>>>>>>>>>>        // Then not found in workspace, look for the file in DFSysPath;
77534>>>>>>>>>>>        If (sPath = "") Begin
77536>>>>>>>>>>>            Get_File_Path sSearchFileName to sFileName   
77537>>>>>>>>>>>            Get ParseFolderName sFileName to sPath
77538>>>>>>>>>>>        End                  
77538>>>>>>>>>>>>
77538>>>>>>>>>>>        
77538>>>>>>>>>>>        Function_Return sPath    
77539>>>>>>>>>>>    End_Function
77540>>>>>>>>>>>    
77540>>>>>>>>>>>    // Pass the path to the workspace Programs folder - returns a string array
77540>>>>>>>>>>>    // with one or more .ws file names.
77540>>>>>>>>>>>    // First checks if there is a .sws file - and if so reads the name of the
77540>>>>>>>>>>>    // workspace file (.ws) and returns it as a string array.
77540>>>>>>>>>>>    // If _no_ .sws file is found, enumerates the passed sProgramsPath variable
77540>>>>>>>>>>>    Function WorkspaceIniFiles String sProgramsPath Returns String[]
77542>>>>>>>>>>>        String[] asSWSFiles asWorkspaceFiles   
77544>>>>>>>>>>>        String sFile sHomePath sDirSep
77544>>>>>>>>>>>        Integer iCh iSize
77544>>>>>>>>>>>        Boolean bExists      
77544>>>>>>>>>>>        Handle hoIniFile 
77544>>>>>>>>>>>        
77544>>>>>>>>>>>        Move (ResizeArray(asSWSFiles, 0)) to asSWSFiles
77545>>>>>>>>>>>        Move (ResizeArray(asWorkspaceFiles, 0)) to asWorkspaceFiles
77546>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
77548>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
77549>>>>>>>>>>>        End                                              
77549>>>>>>>>>>>>
77549>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
77550>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sHomePath
77551>>>>>>>>>>>        Move (Replace(sHomePath, sProgramsPath, "")) to sHomePath
77552>>>>>>>>>>>        Get vFolderFormat sHomePath to sHomePath 
77553>>>>>>>>>>>        
77553>>>>>>>>>>>        // First check if theres an .sws file. If there is we will open it and
77553>>>>>>>>>>>        // read the name of the .ws file name.
77553>>>>>>>>>>>        File_Exist (sHomePath + "*.sws") bExists
77554>>>>>>>>>>>        If (bExists = True) Begin
77556>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sHomePath + "*.sws") to iCh
77557>>>>>>>>>>>            If (iCh < 0) Begin
77559>>>>>>>>>>>                Function_Return asSWSFiles
77560>>>>>>>>>>>            End                                 
77560>>>>>>>>>>>>
77560>>>>>>>>>>>            
77560>>>>>>>>>>>            Repeat
77560>>>>>>>>>>>>
77560>>>>>>>>>>>                Readln channel iCh sFile
77562>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
77564>>>>>>>>>>>                    Move sFile to asSWSFiles[SizeOfArray(asSWSFiles)]
77565>>>>>>>>>>>                End
77565>>>>>>>>>>>>
77565>>>>>>>>>>>            Until (SeqEof = True)
77567>>>>>>>>>>>            Send Seq_Close_Channel iCh    
77568>>>>>>>>>>>            
77568>>>>>>>>>>>            Move (SizeOfArray(asSWSFiles)) to iSize
77569>>>>>>>>>>>            If (iSize <> 0) Begin
77571>>>>>>>>>>>                Get Create (RefClass(cIniFile)) to hoIniFile  
77572>>>>>>>>>>>                // Use the file with that is last as it might have the DataFlex version in it,
77572>>>>>>>>>>>                // and thus is the latest one and it is more likely it is accurate (?)...
77572>>>>>>>>>>>                Move asSWSFiles[SizeOfArray(asSWSFiles) -1] to sFile
77573>>>>>>>>>>>                Set psFileName of hoIniFile to (sHomePath + sFile)
77574>>>>>>>>>>>                Get ReadString of hoIniFile "WorkspacePaths" "ConfigFile" "" to sFile
77575>>>>>>>>>>>                If (sFile <> "") Begin
77577>>>>>>>>>>>                    Move (Replace(".", sFile, sHomePath)) to sFile
77578>>>>>>>>>>>                    Move (Replace((sDirSep + String(sDirSep)), sFile, sDirSep)) to sFile
77579>>>>>>>>>>>                    File_Exist sFile bExists
77580>>>>>>>>>>>                    If (bExists = True) Begin
77582>>>>>>>>>>>                        Move sFile to asWorkspaceFiles[0] 
77583>>>>>>>>>>>                    End
77583>>>>>>>>>>>>
77583>>>>>>>>>>>                End
77583>>>>>>>>>>>>
77583>>>>>>>>>>>                Send Destroy of hoIniFile
77584>>>>>>>>>>>            End
77584>>>>>>>>>>>>
77584>>>>>>>>>>>        End
77584>>>>>>>>>>>>
77584>>>>>>>>>>>        
77584>>>>>>>>>>>        // If no .sws file exists, enumerate the .ws files from the Programs folder:    
77584>>>>>>>>>>>        If (SizeOfArray(asWorkspaceFiles) = 0) Begin
77586>>>>>>>>>>>            Get vFolderFormat sProgramsPath to sProgramsPath 
77587>>>>>>>>>>>            File_Exist (sProgramsPath + "*.ws") bExists
77588>>>>>>>>>>>            If (bExists = False) Begin
77590>>>>>>>>>>>                Function_Return asWorkspaceFiles
77591>>>>>>>>>>>            End
77591>>>>>>>>>>>>
77591>>>>>>>>>>>        
77591>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sProgramsPath + "*.ws") to iCh
77592>>>>>>>>>>>            If (iCh < 0) Begin
77594>>>>>>>>>>>                Function_Return asWorkspaceFiles
77595>>>>>>>>>>>            End                                 
77595>>>>>>>>>>>>
77595>>>>>>>>>>>            
77595>>>>>>>>>>>            Repeat
77595>>>>>>>>>>>>
77595>>>>>>>>>>>                Readln channel iCh sFile
77597>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
77599>>>>>>>>>>>                    Move sFile to asWorkspaceFiles[SizeOfArray(asWorkspaceFiles)]
77600>>>>>>>>>>>                End
77600>>>>>>>>>>>>
77600>>>>>>>>>>>            Until (SeqEof = True)
77602>>>>>>>>>>>            Send Seq_Close_Channel iCh
77603>>>>>>>>>>>        End
77603>>>>>>>>>>>>
77603>>>>>>>>>>>        
77603>>>>>>>>>>>        Function_Return asWorkspaceFiles
77604>>>>>>>>>>>    End_Function
77605>>>>>>>>>>>
77605>>>>>>>>>>>End_Class
77606>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
77606>>>>>>>>>Use vWin32fh.pkg
77606>>>>>>>>>
77606>>>>>>>>>// The cConnection class is the new SQL connections class for DF 19.
77606>>>>>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
77606>>>>>>>>>
77606>>>>>>>>>// We're making references to this object handle so we need it defined
77606>>>>>>>>>// here as well as for the cDbUpdateHandler class
77606>>>>>>>>>
77606>>>>>>>>>    Global_Variable Handle ghoSQLConnectionHandler
77606>>>>>>>>>    Move 0 to ghoSQLConnectionHandler
77607>>>>>>>>>
77607>>>>>>>>>Class cSQLConnectionHandler is a cObject
77608>>>>>>>>>
77608>>>>>>>>>    Procedure Construct_Object
77610>>>>>>>>>        Forward Send Construct_Object
77612>>>>>>>>>        Move Self to ghoSQLConnectionHandler
77613>>>>>>>>>
77613>>>>>>>>>        Property Handle phoSQLConnectionIniFile (Create(Self,RefClass(cSQLConnectionIniFile)))
77614>>>>>>>>>
77614>>>>>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
77614>>>>>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
77614>>>>>>>>>        // methods to this class.
77614>>>>>>>>>        Property Boolean pbUseConnectionID True
77615>>>>>>>>>        Property Boolean pbToANSI          True
77616>>>>>>>>>        Property Boolean pbRecnum          True
77617>>>>>>>>>        Property Boolean pbCopyData        True
77618>>>>>>>>>        Property Boolean pbApiTableUpdateAuto    False
77619>>>>>>>>>        Property Boolean pbCompareDate_DateTime  False
77620>>>>>>>>>        Property Boolean pbCompareIndexAscending False
77621>>>>>>>>>        Property Boolean pbCompareIndexUppercase False
77622>>>>>>>>>
77622>>>>>>>>>        // Driver default value settings:
77622>>>>>>>>>        // Note: When the object is created the corresponding values
77622>>>>>>>>>        // from the driver .int files are read.
77622>>>>>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
77622>>>>>>>>>        Property String psDriverDefaultValueASCII    ""
77623>>>>>>>>>        Property String psDriverDefaultValueBinary   ""
77624>>>>>>>>>        Property String psDriverDefaultValueDate     ""
77625>>>>>>>>>        Property String psDriverDefaultValueDateTime ""
77626>>>>>>>>>        Property String psDriverDefaultValueNumeric  ""
77627>>>>>>>>>        Property String psDriverDefaultValueText     ""
77628>>>>>>>>>
77628>>>>>>>>>        // Driver "nullability" settings:
77628>>>>>>>>>        // Note: When the object is created the corresponding values
77628>>>>>>>>>        // from the driver .int files are read.
77628>>>>>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
77628>>>>>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
77629>>>>>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
77630>>>>>>>>>        Property Boolean pbDriverDefaultNullableDate     False
77631>>>>>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
77632>>>>>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
77633>>>>>>>>>        Property Boolean pbDriverDefaultNullableText     False
77634>>>>>>>>>
77634>>>>>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
77634>>>>>>>>>        //     It is private because the get/set version also updates the DAW/Mertech
77634>>>>>>>>>        //     driver interfaces.
77634>>>>>>>>>        //     There are also procedure/function pairs to set/get individual data members
77634>>>>>>>>>        //     of the struct they are all routed throu this struct property.
77634>>>>>>>>>        Property tSQLConnection Private.pSQLConnection
77635>>>>>>>>>
77635>>>>>>>>>    End_Procedure
77636>>>>>>>>>
77636>>>>>>>>>    Procedure End_Construct_Object
77638>>>>>>>>>        tSQLConnection SQLConnection
77638>>>>>>>>>        tSQLConnection SQLConnection
77638>>>>>>>>>
77638>>>>>>>>>        Forward Send End_Construct_Object
77640>>>>>>>>>
77640>>>>>>>>>        // Now is the time to read and apply SQL connection settings.
77640>>>>>>>>>        Get SetupSQLConnection True True to SQLConnection
77641>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
77642>>>>>>>>>    End_Procedure
77643>>>>>>>>>
77643>>>>>>>>>    // *** Properties ***
77643>>>>>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
77643>>>>>>>>>    // private.pSQLConnection struct connection property. These "properties" are
77643>>>>>>>>>    // merely here for conveniance.
77643>>>>>>>>>    //
77643>>>>>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
77643>>>>>>>>>    // where we update data to/from the DAW & Mertech driver interfaces and this framework.
77643>>>>>>>>>    // This struct property contains all the connection data.
77643>>>>>>>>>    //
77643>>>>>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
77645>>>>>>>>>        Boolean bOK
77645>>>>>>>>>
77645>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
77646>>>>>>>>>
77646>>>>>>>>>        // When starting a program we might not have a connection id yet:
77646>>>>>>>>>        If (SQLConnection.sDriverID = DATAFLEX_ID) Begin
77648>>>>>>>>>//        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
77648>>>>>>>>>            Procedure_Return
77649>>>>>>>>>        End
77649>>>>>>>>>>
77649>>>>>>>>>
77649>>>>>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
77649>>>>>>>>>        // be logged in already and don't want to do it again.
77649>>>>>>>>>        If (SQLConnection.bDAWConnection = False) Begin
77651>>>>>>>>>            // After we have set the class property we need to tell the DAW/Mertech
77651>>>>>>>>>            // driver interfaces about the change & make a new login.
77651>>>>>>>>>            Get SQLLogin SQLConnection to bOK
77652>>>>>>>>>            If (bOK = False) Begin
77654>>>>>>>>>                Error DFERR_PROGRAM "Login error."
77655>>>>>>>>>>
77655>>>>>>>>>            End
77655>>>>>>>>>>
77655>>>>>>>>>        End
77655>>>>>>>>>>
77655>>>>>>>>>
77655>>>>>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
77655>>>>>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
77656>>>>>>>>>
77656>>>>>>>>>    End_Procedure
77657>>>>>>>>>
77657>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
77657>>>>>>>>>    // attempt to load the driver.
77657>>>>>>>>>    // Returns true if the passed driver is SQL based.
77657>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
77659>>>>>>>>>        Boolean bOK
77659>>>>>>>>>
77659>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
77660>>>>>>>>>        If (bOK = False) Begin
77662>>>>>>>>>            Get IsMertechDriver sDriverID to bOK
77663>>>>>>>>>        End
77663>>>>>>>>>>
77663>>>>>>>>>
77663>>>>>>>>>        Function_Return bOK
77664>>>>>>>>>    End_Function
77665>>>>>>>>>
77665>>>>>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
77665>>>>>>>>>    Procedure SetupDriverDefaults String sDriverID
77667>>>>>>>>>        String sAttributeValue
77667>>>>>>>>>        Integer iDriverID
77667>>>>>>>>>        Boolean bNULL bSQLDriver bIsMertechDriver
77667>>>>>>>>>
77667>>>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
77668>>>>>>>>>        If (bSQLDriver = False) Begin
77670>>>>>>>>>            Procedure_Return
77671>>>>>>>>>        End                                      
77671>>>>>>>>>>
77671>>>>>>>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
77672>>>>>>>>>        If (bIsMertechDriver = True) Begin
77674>>>>>>>>>            Procedure_Return
77675>>>>>>>>>        End
77675>>>>>>>>>>
77675>>>>>>>>>        
77675>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
77676>>>>>>>>>
77676>>>>>>>>>        // Driver default values for various data types:
77676>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
77679>>>>>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
77680>>>>>>>>>
77680>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
77683>>>>>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
77684>>>>>>>>>
77684>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
77687>>>>>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
77688>>>>>>>>>
77688>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
77691>>>>>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
77692>>>>>>>>>
77692>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
77695>>>>>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
77696>>>>>>>>>
77696>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
77699>>>>>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
77700>>>>>>>>>
77700>>>>>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
77700>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
77703>>>>>>>>>        Set pbDriverDefaultNullableASCII to bNULL
77704>>>>>>>>>
77704>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
77707>>>>>>>>>        Set pbDriverDefaultNullableBinary to bNULL
77708>>>>>>>>>
77708>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
77711>>>>>>>>>        Set pbDriverDefaultNullableDate to bNULL
77712>>>>>>>>>
77712>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
77715>>>>>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
77716>>>>>>>>>
77716>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
77719>>>>>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
77720>>>>>>>>>
77720>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
77723>>>>>>>>>        Set pbDriverDefaultNullableText to bNULL
77724>>>>>>>>>
77724>>>>>>>>>    End_Procedure
77725>>>>>>>>>
77725>>>>>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
77727>>>>>>>>>        Boolean bOK bIsDaw bIsMertech
77727>>>>>>>>>        String sConnectionString
77727>>>>>>>>>        Handle hoErrorObj hoDriver hoIniFile
77727>>>>>>>>>        Integer iDriverID
77727>>>>>>>>>
77727>>>>>>>>>        Move False to bOK
77728>>>>>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
77729>>>>>>>>>        If (bIsDaw = False) Begin
77731>>>>>>>>>            Get IsMertechDriver SQLConnection.sDriverID to bIsMertech
77732>>>>>>>>>            If (bIsMertech = False) Begin
77734>>>>>>>>>                Function_Return False
77735>>>>>>>>>            End
77735>>>>>>>>>>
77735>>>>>>>>>        End
77735>>>>>>>>>>
77735>>>>>>>>>
77735>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
77736>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
77737>>>>>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
77738>>>>>>>>>        If (iDriverID = 0) Begin
77740>>>>>>>>>            Move hoErrorObj to Error_Object_Id
77741>>>>>>>>>            Function_Return False
77742>>>>>>>>>        End
77742>>>>>>>>>>
77742>>>>>>>>>
77742>>>>>>>>>        // There's a bug in Mertech drivers creating "an Exception error" in the debugger (probably will crash an application too.)
77742>>>>>>>>>        If (bIsMertech = False) Begin
77744>>>>>>>>>            Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
77747>>>>>>>>>        End
77747>>>>>>>>>>
77747>>>>>>>>>
77747>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
77748>>>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
77749>>>>>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
77750>>>>>>>>>        Send Destroy   of hoDriver
77751>>>>>>>>>
77751>>>>>>>>>        Function_Return bOK
77752>>>>>>>>>    End_Function
77753>>>>>>>>>
77753>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
77755>>>>>>>>>        tSQLConnection SQLConnection
77755>>>>>>>>>        tSQLConnection SQLConnection
77755>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77756>>>>>>>>>        Function_Return SQLConnection
77757>>>>>>>>>    End_Function
77758>>>>>>>>>
77758>>>>>>>>>    Procedure Set psConnectionID String sValue
77760>>>>>>>>>        tSQLConnection SQLConnection
77760>>>>>>>>>        tSQLConnection SQLConnection
77760>>>>>>>>>
77760>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77761>>>>>>>>>        If (SQLConnection.sConnectionID = "") Begin
77763>>>>>>>>>            Move sValue to SQLConnection.sConnectionID
77764>>>>>>>>>        End
77764>>>>>>>>>>
77764>>>>>>>>>
77764>>>>>>>>>        // Else we might want to change the current connection ID
77764>>>>>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
77767>>>>>>>>>            Move False to Err
77768>>>>>>>>>            Logout SQLConnection.sDriverID
77769>>>>>>>>>            // This will also make a login to the new server.
77769>>>>>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
77770>>>>>>>>>        End
77770>>>>>>>>>>
77770>>>>>>>>>        Set pSQLConnection to SQLConnection
77771>>>>>>>>>    End_Procedure
77772>>>>>>>>>
77772>>>>>>>>>    Function psConnectionID Returns String
77774>>>>>>>>>        tSQLConnection SQLConnection
77774>>>>>>>>>        tSQLConnection SQLConnection
77774>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77775>>>>>>>>>        Function_Return SQLConnection.sConnectionID
77776>>>>>>>>>    End_Function
77777>>>>>>>>>
77777>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
77777>>>>>>>>>    //       the psDriverID *must* be the first property that is changed!
77777>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
77777>>>>>>>>>    //       for a connection string has the wrong format for that driver.
77777>>>>>>>>>    Procedure Set psDriverID String sValue
77779>>>>>>>>>        tSQLConnection SQLConnection
77779>>>>>>>>>        tSQLConnection SQLConnection
77779>>>>>>>>>        Get pSQLConnection to SQLConnection
77780>>>>>>>>>        Move sValue        to SQLConnection.sDriverID
77781>>>>>>>>>        Set pSQLConnection to SQLConnection
77782>>>>>>>>>        If (sValue <> DATAFLEX_ID) Begin
77784>>>>>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77785>>>>>>>>>        End
77785>>>>>>>>>>
77785>>>>>>>>>    End_Procedure
77786>>>>>>>>>
77786>>>>>>>>>    Function psDriverID Returns String
77788>>>>>>>>>        tSQLConnection SQLConnection
77788>>>>>>>>>        tSQLConnection SQLConnection
77788>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77789>>>>>>>>>        If (SQLConnection.sDriverID = "") Begin
77791>>>>>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
77792>>>>>>>>>        End
77792>>>>>>>>>>
77792>>>>>>>>>        Function_Return SQLConnection.sDriverID
77793>>>>>>>>>    End_Function
77794>>>>>>>>>
77794>>>>>>>>>    Procedure Set psConnectionString String sValue
77796>>>>>>>>>        tSQLConnection SQLConnection
77796>>>>>>>>>        tSQLConnection SQLConnection
77796>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77797>>>>>>>>>        Move sValue        to SQLConnection.sConnectionString
77798>>>>>>>>>        Set pSQLConnection to SQLConnection
77799>>>>>>>>>    End_Procedure
77800>>>>>>>>>
77800>>>>>>>>>    Function psConnectionString Returns String
77802>>>>>>>>>        tSQLConnection SQLConnection
77802>>>>>>>>>        tSQLConnection SQLConnection
77802>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77803>>>>>>>>>        Function_Return SQLConnection.sConnectionString
77804>>>>>>>>>    End_Function
77805>>>>>>>>>
77805>>>>>>>>>    Procedure Set psServer String sValue
77807>>>>>>>>>        tSQLConnection SQLConnection
77807>>>>>>>>>        tSQLConnection SQLConnection
77807>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77808>>>>>>>>>        Move sValue        to SQLConnection.sServer
77809>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77810>>>>>>>>>        Set pSQLConnection to SQLConnection
77811>>>>>>>>>    End_Procedure
77812>>>>>>>>>
77812>>>>>>>>>    Function psServer Returns String
77814>>>>>>>>>        tSQLConnection SQLConnection
77814>>>>>>>>>        tSQLConnection SQLConnection
77814>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77815>>>>>>>>>        Function_Return SQLConnection.sServer
77816>>>>>>>>>    End_Function
77817>>>>>>>>>
77817>>>>>>>>>    Procedure Set psDatabase String sValue
77819>>>>>>>>>        tSQLConnection SQLConnection
77819>>>>>>>>>        tSQLConnection SQLConnection
77819>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77820>>>>>>>>>        Move sValue        to SQLConnection.sDatabase
77821>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77822>>>>>>>>>        Set pSQLConnection to SQLConnection
77823>>>>>>>>>    End_Procedure
77824>>>>>>>>>
77824>>>>>>>>>    Function psDatabase Returns String
77826>>>>>>>>>        tSQLConnection SQLConnection
77826>>>>>>>>>        tSQLConnection SQLConnection
77826>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77827>>>>>>>>>        Function_Return SQLConnection.sDatabase
77828>>>>>>>>>    End_Function
77829>>>>>>>>>
77829>>>>>>>>>    Procedure Set psUserID String sValue
77831>>>>>>>>>        tSQLConnection SQLConnection
77831>>>>>>>>>        tSQLConnection SQLConnection
77831>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77832>>>>>>>>>        Move sValue        to SQLConnection.sUserID
77833>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77834>>>>>>>>>        Set pSQLConnection to SQLConnection
77835>>>>>>>>>    End_Procedure
77836>>>>>>>>>
77836>>>>>>>>>    Function psUserID Returns String
77838>>>>>>>>>        tSQLConnection SQLConnection
77838>>>>>>>>>        tSQLConnection SQLConnection
77838>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77839>>>>>>>>>        Function_Return SQLConnection.sUserID
77840>>>>>>>>>    End_Function
77841>>>>>>>>>
77841>>>>>>>>>    // This is the uncrypted password
77841>>>>>>>>>    Procedure Set psPassword String sValue
77843>>>>>>>>>        tSQLConnection SQLConnection
77843>>>>>>>>>        tSQLConnection SQLConnection
77843>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77844>>>>>>>>>        Move sValue        to SQLConnection.sPassword
77845>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77846>>>>>>>>>        Set pSQLConnection to SQLConnection
77847>>>>>>>>>    End_Procedure
77848>>>>>>>>>
77848>>>>>>>>>    Function psPassword Returns String
77850>>>>>>>>>        tSQLConnection SQLConnection
77850>>>>>>>>>        tSQLConnection SQLConnection
77850>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77851>>>>>>>>>        Function_Return SQLConnection.sPassword
77852>>>>>>>>>    End_Function
77853>>>>>>>>>
77853>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
77855>>>>>>>>>        tSQLConnection SQLConnection
77855>>>>>>>>>        tSQLConnection SQLConnection
77855>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77856>>>>>>>>>        Move bValue        to SQLConnection.bTrusted
77857>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
77858>>>>>>>>>        Set pSQLConnection to SQLConnection
77859>>>>>>>>>    End_Procedure
77860>>>>>>>>>
77860>>>>>>>>>    Function pbTrusted Returns Boolean
77862>>>>>>>>>        tSQLConnection SQLConnection
77862>>>>>>>>>        tSQLConnection SQLConnection
77862>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77863>>>>>>>>>        Function_Return SQLConnection.bTrusted
77864>>>>>>>>>    End_Function
77865>>>>>>>>>
77865>>>>>>>>>    // *** All of these properties are special to the Database Update Framework ***
77865>>>>>>>>>    //     Thus they are not propagated to the DAW/Mertech classes and that is why
77865>>>>>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
77865>>>>>>>>>    //     the central pSQLConnection "hub".
77865>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
77867>>>>>>>>>        tSQLConnection SQLConnection
77867>>>>>>>>>        tSQLConnection SQLConnection
77867>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77868>>>>>>>>>        Move bValue to SQLConnection.bTrusted
77869>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
77870>>>>>>>>>    End_Procedure
77871>>>>>>>>>
77871>>>>>>>>>    Function pbSilentLogin Returns Boolean
77873>>>>>>>>>        tSQLConnection SQLConnection
77873>>>>>>>>>        tSQLConnection SQLConnection
77873>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77874>>>>>>>>>        Function_Return SQLConnection.bSilentLogin
77875>>>>>>>>>    End_Function
77876>>>>>>>>>
77876>>>>>>>>>    Procedure Set piDbType Integer iValue
77878>>>>>>>>>        tSQLConnection SQLConnection
77878>>>>>>>>>        tSQLConnection SQLConnection
77878>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77879>>>>>>>>>        Move iValue to SQLConnection.iDbType
77880>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
77881>>>>>>>>>    End_Procedure
77882>>>>>>>>>
77882>>>>>>>>>    Function piDbType Returns Integer
77884>>>>>>>>>        tSQLConnection SQLConnection
77884>>>>>>>>>        tSQLConnection SQLConnection
77884>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77885>>>>>>>>>        Function_Return SQLConnection.iDbType
77886>>>>>>>>>    End_Function
77887>>>>>>>>>
77887>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
77889>>>>>>>>>        tSQLConnection SQLConnection
77889>>>>>>>>>        tSQLConnection SQLConnection
77889>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77890>>>>>>>>>        Move sValue to SQLConnection.sBaseTableSpace
77891>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
77892>>>>>>>>>    End_Procedure
77893>>>>>>>>>
77893>>>>>>>>>    Function psBaseTableSpace Returns String
77895>>>>>>>>>        tSQLConnection SQLConnection
77895>>>>>>>>>        tSQLConnection SQLConnection
77895>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77896>>>>>>>>>        Function_Return SQLConnection.sBaseTableSpace
77897>>>>>>>>>    End_Function
77898>>>>>>>>>
77898>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
77900>>>>>>>>>        tSQLConnection SQLConnection
77900>>>>>>>>>        tSQLConnection SQLConnection
77900>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77901>>>>>>>>>        Move sValue to SQLConnection.sIndexTableSpace
77902>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
77903>>>>>>>>>    End_Procedure
77904>>>>>>>>>
77904>>>>>>>>>    Function psIndexTableSpace Returns String
77906>>>>>>>>>        tSQLConnection SQLConnection
77906>>>>>>>>>        tSQLConnection SQLConnection
77906>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77907>>>>>>>>>        Function_Return SQLConnection.sIndexTableSpace
77908>>>>>>>>>    End_Function
77909>>>>>>>>>
77909>>>>>>>>>    Procedure Set psLongTableSpace String sValue
77911>>>>>>>>>        tSQLConnection SQLConnection
77911>>>>>>>>>        tSQLConnection SQLConnection
77911>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77912>>>>>>>>>        Move sValue to SQLConnection.sLongTableSpace
77913>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
77914>>>>>>>>>    End_Procedure
77915>>>>>>>>>
77915>>>>>>>>>    Function psLongTableSpace Returns String
77917>>>>>>>>>        tSQLConnection SQLConnection
77917>>>>>>>>>        tSQLConnection SQLConnection
77917>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77918>>>>>>>>>        Function_Return SQLConnection.sLongTableSpace
77919>>>>>>>>>    End_Function
77920>>>>>>>>>
77920>>>>>>>>>    Procedure Set psSchema String sValue
77922>>>>>>>>>        tSQLConnection SQLConnection
77922>>>>>>>>>        tSQLConnection SQLConnection
77922>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77923>>>>>>>>>        Move sValue to SQLConnection.sSchema
77924>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
77925>>>>>>>>>    End_Procedure
77926>>>>>>>>>
77926>>>>>>>>>    Function psSchema Returns String
77928>>>>>>>>>        tSQLConnection SQLConnection
77928>>>>>>>>>        tSQLConnection SQLConnection
77928>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77929>>>>>>>>>        Function_Return SQLConnection.sSchema
77930>>>>>>>>>    End_Function
77931>>>>>>>>>
77931>>>>>>>>>    Procedure Set pbEnabled Boolean bValue
77933>>>>>>>>>        tSQLConnection SQLConnection
77933>>>>>>>>>        tSQLConnection SQLConnection
77933>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77934>>>>>>>>>        Move bValue to SQLConnection.bEnabled
77935>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
77936>>>>>>>>>    End_Procedure
77937>>>>>>>>>
77937>>>>>>>>>    Function pbEnabled Returns Boolean
77939>>>>>>>>>        tSQLConnection SQLConnection
77939>>>>>>>>>        tSQLConnection SQLConnection
77939>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
77940>>>>>>>>>        Function_Return SQLConnection.bEnabled
77941>>>>>>>>>    End_Function
77942>>>>>>>>>
77942>>>>>>>>>
77942>>>>>>>>>    // ************************************
77942>>>>>>>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
77944>>>>>>>>>        tSQLConnection SQLConnection
77944>>>>>>>>>        tSQLConnection SQLConnection
77944>>>>>>>>>
77944>>>>>>>>>        // If this object was created by the cDbUpdateHandler class we will
77944>>>>>>>>>        // deferr reading SQL connection values until later.
77944>>>>>>>>>        If (bReadDFConnSettings = True) Begin
77946>>>>>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
77946>>>>>>>>>            If (ghoConnection > 0) Begin
77948>>>>>>>>>                Get ReadcConnections to SQLConnection
77949>>>>>>>>>            End
77949>>>>>>>>>>
77949>>>>>>>>>
77949>>>>>>>>>            // In addition to the above; there might be other values set even if a cConnection
77949>>>>>>>>>            // object is used.
77949>>>>>>>>>            If (bReadSQLConnections = True) Begin
77951>>>>>>>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
77952>>>>>>>>>            End
77952>>>>>>>>>>
77952>>>>>>>>>        End
77952>>>>>>>>>>
77952>>>>>>>>>
77952>>>>>>>>>        Function_Return SQLConnection
77953>>>>>>>>>    End_Function
77954>>>>>>>>>
77954>>>>>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
77954>>>>>>>>>    Function ReadcConnections Returns tSQLConnection
77956>>>>>>>>>        tConnection Connection
77956>>>>>>>>>        tConnection Connection
77956>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
77956>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
77956>>>>>>>>>        Integer iRetval iDbType
77956>>>>>>>>>        Boolean bOK bConnected
77956>>>>>>>>>        String sConnectionID
77956>>>>>>>>>
77956>>>>>>>>>            tConnection[] Connections
77956>>>>>>>>>            tConnection[] Connections
77957>>>>>>>>>            // - If the DF 19 cConnection class has been used in the cApplication object
77957>>>>>>>>>            // - and there are multiple connection id's defined for the same driver. This is
77957>>>>>>>>>            //   because otherwise we can't possibly know which connection id to use... So
77957>>>>>>>>>            //   we then generate an error and abort the program...
77957>>>>>>>>>            Get IsSinglecConnection (&sConnectionID) to bOK
77958>>>>>>>>>            If (bOK = False) Begin
77960>>>>>>>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
77961>>>>>>>>>>
77961>>>>>>>>>                Abort
77962>>>>>>>>>>
77962>>>>>>>>>            End
77962>>>>>>>>>>
77962>>>>>>>>>            If (sConnectionID = "") Begin
77964>>>>>>>>>                Get ConnectionIDs of ghoConnection to Connections
77965>>>>>>>>>                If (SizeOfArray(Connections) > 0) Begin
77967>>>>>>>>>                    Move Connections[0].sId to sConnectionID
77968>>>>>>>>>                End
77968>>>>>>>>>>
77968>>>>>>>>>            End
77968>>>>>>>>>>
77968>>>>>>>>>
77968>>>>>>>>>            Move 0 to iRetval
77969>>>>>>>>>            // DAW DF19 connection info:
77969>>>>>>>>>            // We first check that the connection is OK:
77969>>>>>>>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
77970>>>>>>>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
77970>>>>>>>>>            If (iRetval = -1) Begin
77972>>>>>>>>>                Function_Return SQLConnectionEmpty
77973>>>>>>>>>            End
77973>>>>>>>>>>
77973>>>>>>>>>
77973>>>>>>>>>            If (sConnectionID <> "") Begin
77975>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
77976>>>>>>>>>            End
77976>>>>>>>>>>
77976>>>>>>>>>            If (Connection.sId = "") Begin
77978>>>>>>>>>                Move True to SQLConnectionEmpty.bError
77979>>>>>>>>>                Function_Return SQLConnectionEmpty
77980>>>>>>>>>            End
77980>>>>>>>>>>
77980>>>>>>>>>
77980>>>>>>>>>            // DUF connection info struct property:
77980>>>>>>>>>            Get Private.pSQLConnection                       to SQLConnection
77981>>>>>>>>>
77981>>>>>>>>>            Move Connection.sId to sConnectionID
77982>>>>>>>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
77983>>>>>>>>>
77983>>>>>>>>>            If (bConnected = False) Begin
77985>>>>>>>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
77986>>>>>>>>>                If (iRetval <> 0) Begin
77988>>>>>>>>>                    Send UserError CS_DUF_CannotLoginToServer
77989>>>>>>>>>                    Send Exit_Application
77990>>>>>>>>>                End
77990>>>>>>>>>>
77990>>>>>>>>>                Move True                                   to SQLConnection.bDAWConnection
77991>>>>>>>>>                // We need to get the DAW connection info again as it might have
77991>>>>>>>>>                // been changed in the DAW db login dialog.
77991>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
77992>>>>>>>>>            End
77992>>>>>>>>>>
77992>>>>>>>>>
77992>>>>>>>>>            Move True                                        to SQLConnection.bEnabled
77993>>>>>>>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
77994>>>>>>>>>
77994>>>>>>>>>            // Not used in DUF:
77994>>>>>>>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
77994>>>>>>>>>
77994>>>>>>>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
77995>>>>>>>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
77996>>>>>>>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
77997>>>>>>>>>            Move Connection.sId                              to SQLConnection.sConnectionID
77998>>>>>>>>>            Move Connection.sUID                             to SQLConnection.sUserID
77999>>>>>>>>>            Move Connection.sPWD                             to SQLConnection.sPassword
78000>>>>>>>>>
78000>>>>>>>>>            // Not used in DUF:
78000>>>>>>>>>            // Move Connection.sSection to SQLConnection.xxx
78000>>>>>>>>>
78000>>>>>>>>>            // The rest of the properties of the SQLConnection struct should have been
78000>>>>>>>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
78000>>>>>>>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
78002>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniServerKeyword + "=")       to SQLConnection.sServer
78003>>>>>>>>>            End
78003>>>>>>>>>>
78003>>>>>>>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
78005>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniDSNKeyword + "=")          to SQLConnection.sServer
78006>>>>>>>>>                If (SQLConnection.sServer = "") Begin
78008>>>>>>>>>                    Get ParseKeyWord Connection.sString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78009>>>>>>>>>                End
78009>>>>>>>>>>
78009>>>>>>>>>            End
78009>>>>>>>>>>
78009>>>>>>>>>
78009>>>>>>>>>            Get ParseKeyWord Connection.sString (CS_SQLIniDatabaseKeyword  + "=")        to SQLConnection.sDatabase
78010>>>>>>>>>
78010>>>>>>>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
78010>>>>>>>>>            // the value from the driver id:
78010>>>>>>>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
78011>>>>>>>>>            // ...but in case it has been explicitly set in the object we use that value.
78011>>>>>>>>>            Get piDbType                                     to iDbType
78012>>>>>>>>>            If (iDbType <> SQLConnection.iDbType) Begin
78014>>>>>>>>>                Move iDbType to SQLConnection.iDbType
78015>>>>>>>>>            End
78015>>>>>>>>>>
78015>>>>>>>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
78016>>>>>>>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
78017>>>>>>>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
78018>>>>>>>>>            Get psSchema                                     to SQLConnection.sSchema
78019>>>>>>>>>
78019>>>>>>>>>            // We finally set the struct property to the newly fetched values.
78019>>>>>>>>>            Set pSQLConnection to SQLConnection
78020>>>>>>>>>
78020>>>>>>>>>        Function_Return SQLConnection
78021>>>>>>>>>    End_Function
78022>>>>>>>>>
78022>>>>>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
78022>>>>>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
78022>>>>>>>>>    // connection id for a particular driver.
78022>>>>>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
78022>>>>>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
78022>>>>>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
78022>>>>>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
78022>>>>>>>>>    // connections of the DAW cConnect class.
78022>>>>>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
78024>>>>>>>>>        tConnection[] ConnIdArray
78024>>>>>>>>>        tConnection[] ConnIdArray
78025>>>>>>>>>        Integer iCount iSize iConnectionIDCounter
78025>>>>>>>>>        Boolean bEnabled bFound
78025>>>>>>>>>        String sConnectionID2 sDriverID sDriverConn
78025>>>>>>>>>
78025>>>>>>>>>        Move False to bFound
78026>>>>>>>>>        If (ghoConnection > 0) Begin
78028>>>>>>>>>
78028>>>>>>>>>            // The property of the cDbUpdateHandler container object
78028>>>>>>>>>            Get psDriverID to sDriverID
78029>>>>>>>>>
78029>>>>>>>>>            Move 0 to iConnectionIDCounter
78030>>>>>>>>>            // This is the the DAW cConnect array with all registered connection id's.
78030>>>>>>>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
78031>>>>>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
78032>>>>>>>>>            Decrement iSize
78033>>>>>>>>>            For iCount from 0 to iSize
78039>>>>>>>>>>
78039>>>>>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
78040>>>>>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
78041>>>>>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
78042>>>>>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
78042>>>>>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
78042>>>>>>>>>                If (sConnectionID = "") Begin
78044>>>>>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
78045>>>>>>>>>                End
78045>>>>>>>>>>
78045>>>>>>>>>                Else Begin
78046>>>>>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
78048>>>>>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
78049>>>>>>>>>                    End
78049>>>>>>>>>>
78049>>>>>>>>>                End
78049>>>>>>>>>>
78049>>>>>>>>>
78049>>>>>>>>>                If (bFound = True) Begin
78051>>>>>>>>>                    Increment iConnectionIDCounter
78052>>>>>>>>>                End
78052>>>>>>>>>>
78052>>>>>>>>>            Loop
78053>>>>>>>>>>
78053>>>>>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
78054>>>>>>>>>            If (bFound = True) Begin
78056>>>>>>>>>                Move sConnectionID2 to sConnectionID
78057>>>>>>>>>            End
78057>>>>>>>>>>
78057>>>>>>>>>        End
78057>>>>>>>>>>
78057>>>>>>>>>
78057>>>>>>>>>        // Special case; a cConnection object has been setup in the cApplication,
78057>>>>>>>>>        // but no DFConn.ini record has been created.
78057>>>>>>>>>        If (iSize = -1) Begin
78059>>>>>>>>>            Move True to bFound
78060>>>>>>>>>        End
78060>>>>>>>>>>
78060>>>>>>>>>
78060>>>>>>>>>        Function_Return bFound
78061>>>>>>>>>    End_Function
78062>>>>>>>>>
78062>>>>>>>>>    // Send on object creation to read the default connection string settings, and
78062>>>>>>>>>    // create a connection to the server.
78062>>>>>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
78064>>>>>>>>>        String sPath sFileName
78064>>>>>>>>>        Boolean bExists bActive
78064>>>>>>>>>        tSQLConnection[] SQLConnectionArray
78064>>>>>>>>>        tSQLConnection[] SQLConnectionArray
78065>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78065>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78065>>>>>>>>>        Handle hoIniFile
78065>>>>>>>>>        Integer iSize iCount iRetval
78065>>>>>>>>>
78065>>>>>>>>>        Get psIniFilePath to sPath
78066>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78067>>>>>>>>>        If (sPath = "") Begin
78069>>>>>>>>>            Get ApplicationPath of hoIniFile to sPath
78070>>>>>>>>>            Set psIniFilePath   of hoIniFile to sPath
78071>>>>>>>>>        End
78071>>>>>>>>>>
78071>>>>>>>>>        Get vFolderFormat sPath to sPath
78072>>>>>>>>>        Get psIniFileName to sFileName
78073>>>>>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
78074>>>>>>>>>
78074>>>>>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
78075>>>>>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
78076>>>>>>>>>        If (iSize = 0) Begin
78078>>>>>>>>>            // This may have been set by the "ReadcConnections" function,
78078>>>>>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
78078>>>>>>>>>            // in the cApplication object.
78078>>>>>>>>>            Get pSQLConnection to SQLConnection
78079>>>>>>>>>            If (SQLConnection.sConnectionID = "") Begin
78081>>>>>>>>>                Function_Return SQLConnectionEmpty
78082>>>>>>>>>            End
78082>>>>>>>>>>
78082>>>>>>>>>            Move SQLConnection to SQLConnectionArray[0] 
78083>>>>>>>>>            Move 1 to iSize
78084>>>>>>>>>        End
78084>>>>>>>>>>
78084>>>>>>>>>
78084>>>>>>>>>        Move False to bActive
78085>>>>>>>>>        // The first connection should be the one that is active, but all connections might have been disabled.
78085>>>>>>>>>        Decrement iSize
78086>>>>>>>>>        For iCount from 0 to iSize
78092>>>>>>>>>>
78092>>>>>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
78093>>>>>>>>>            If (SQLConnection.bEnabled = True) Begin
78095>>>>>>>>>                Move True to bActive
78096>>>>>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
78097>>>>>>>>>            End
78097>>>>>>>>>>
78097>>>>>>>>>        Loop
78098>>>>>>>>>>
78098>>>>>>>>>
78098>>>>>>>>>        // In case all connections have been disabled, we're out of here.
78098>>>>>>>>>        If (bActive = False) Begin
78100>>>>>>>>>            Function_Return SQLConnectionEmpty
78101>>>>>>>>>        End
78101>>>>>>>>>>
78101>>>>>>>>>
78101>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin False
78102>>>>>>>>>
78102>>>>>>>>>        Set pSQLConnection to SQLConnection
78103>>>>>>>>>        Get AutoSetConnectionID to iRetval
78104>>>>>>>>>
78104>>>>>>>>>        Function_Return SQLConnection
78105>>>>>>>>>    End_Function
78106>>>>>>>>>
78106>>>>>>>>>    Procedure Set psIniFilePath String sPath
78108>>>>>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
78109>>>>>>>>>    End_Procedure
78110>>>>>>>>>
78110>>>>>>>>>    Function psIniFilePath Returns String
78112>>>>>>>>>        String sRetval
78112>>>>>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
78113>>>>>>>>>        Function_Return sRetval
78114>>>>>>>>>    End_Function
78115>>>>>>>>>
78115>>>>>>>>>    Procedure Set psIniFileName String sFileName
78117>>>>>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
78118>>>>>>>>>    End_Procedure
78119>>>>>>>>>
78119>>>>>>>>>    Function psIniFileName Returns String
78121>>>>>>>>>        String sRetval
78121>>>>>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
78122>>>>>>>>>        Function_Return sRetval
78123>>>>>>>>>    End_Function
78124>>>>>>>>>
78124>>>>>>>>>    Procedure Set psIniSectionName String sSection
78126>>>>>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
78127>>>>>>>>>    End_Procedure
78128>>>>>>>>>
78128>>>>>>>>>    Function psIniSectionName Returns String
78130>>>>>>>>>        String sRetval
78130>>>>>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
78131>>>>>>>>>        Function_Return sRetval
78132>>>>>>>>>    End_Function
78133>>>>>>>>>
78133>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
78135>>>>>>>>>        Handle ho
78135>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78136>>>>>>>>>        Set IniFileValue of ho to sSection sValueName sValue
78137>>>>>>>>>    End_Procedure
78138>>>>>>>>>
78138>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
78140>>>>>>>>>        Handle ho
78140>>>>>>>>>        String sRetval
78140>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78141>>>>>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
78142>>>>>>>>>        Function_Return sRetval
78143>>>>>>>>>    End_Function
78144>>>>>>>>>
78144>>>>>>>>>    Function SectionExists String sSection Returns Boolean
78146>>>>>>>>>        Handle ho
78146>>>>>>>>>        Boolean bRetval
78146>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78147>>>>>>>>>        Get SectionExists of ho sSection to bRetval
78148>>>>>>>>>        Function_Return bRetval
78149>>>>>>>>>    End_Function
78150>>>>>>>>>
78150>>>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
78152>>>>>>>>>        Handle ho
78152>>>>>>>>>        Boolean bRetval
78152>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78153>>>>>>>>>        Get KeyExists of ho sSection sKey to bRetval
78154>>>>>>>>>        Function_Return bRetval
78155>>>>>>>>>    End_Function
78156>>>>>>>>>
78156>>>>>>>>>    Function EncryptPassword String sPassword Returns String
78158>>>>>>>>>        Handle ho
78158>>>>>>>>>        String sRetval
78158>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78159>>>>>>>>>        Get EncryptPassword of ho sPassword to sRetval
78160>>>>>>>>>        Function_Return sRetval
78161>>>>>>>>>    End_Function
78162>>>>>>>>>
78162>>>>>>>>>    Function DecryptPassword String sPassword Returns String
78164>>>>>>>>>        Handle ho
78164>>>>>>>>>        String sRetval
78164>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78165>>>>>>>>>        Get DecryptPassword of ho sPassword to sRetval
78166>>>>>>>>>        Function_Return sRetval
78167>>>>>>>>>    End_Function
78168>>>>>>>>>
78168>>>>>>>>>    // *** Main Connection Message ***
78168>>>>>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent Boolean bExitProgram
78170>>>>>>>>>        Handle hoDriver
78170>>>>>>>>>        String sConnectionString sError
78170>>>>>>>>>        Boolean bLoginSuccessful
78170>>>>>>>>>
78170>>>>>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
78171>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
78172>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
78173>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
78174>>>>>>>>>        If (bLoginSuccessful = False) Begin
78176>>>>>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)   
78177>>>>>>>>>>
78177>>>>>>>>>            If (bExitProgram = True) Begin
78179>>>>>>>>>                Send Exit_Application
78180>>>>>>>>>            End
78180>>>>>>>>>>
78180>>>>>>>>>        End
78180>>>>>>>>>>
78180>>>>>>>>>        Send Destroy of hoDriver
78181>>>>>>>>>    End_Procedure
78182>>>>>>>>>
78182>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
78184>>>>>>>>>        Integer iRetval
78184>>>>>>>>>        Handle hoCLI
78184>>>>>>>>>        String sDriverID
78184>>>>>>>>>
78184>>>>>>>>>        Get psDriverID to sDriverID
78185>>>>>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
78186>>>>>>>>>        If (hoCLI <> 0) Begin
78188>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78189>>>>>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
78190>>>>>>>>>            Send Destroy of hoCLI
78191>>>>>>>>>        End
78191>>>>>>>>>>
78191>>>>>>>>>
78191>>>>>>>>>        Function_Return iRetval
78192>>>>>>>>>    End_Function
78193>>>>>>>>>
78193>>>>>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
78195>>>>>>>>>        tSQLConnection SQLConnection
78195>>>>>>>>>        tSQLConnection SQLConnection
78195>>>>>>>>>
78195>>>>>>>>>        Set psDriverID to sDriverID
78196>>>>>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
78197>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted False
78198>>>>>>>>>    End_Procedure
78199>>>>>>>>>
78199>>>>>>>>>    // This is needed when e.g. the connection id we have specified in the program code
78199>>>>>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
78199>>>>>>>>>    // or the one in the DataFlex Bin folder.)
78199>>>>>>>>>    // We then need to delete the current one before creating a new one.
78199>>>>>>>>>    // This is because the parameters may differ between the program code and the
78199>>>>>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
78199>>>>>>>>>    // when one tries to create a Connection ID that already exists.
78199>>>>>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
78201>>>>>>>>>        Integer iResult iDriver iNumConn iConn
78201>>>>>>>>>        Handle hoCLI
78201>>>>>>>>>        String sID
78201>>>>>>>>>
78201>>>>>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
78203>>>>>>>>>            Procedure_Return
78204>>>>>>>>>        End
78204>>>>>>>>>>
78204>>>>>>>>>
78204>>>>>>>>>        Move 0 to iResult
78205>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78206>>>>>>>>>        If (hoCLI <> 0) Begin
78208>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78209>>>>>>>>>            Get DriverIndex sDriverID to iDriver
78210>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78213>>>>>>>>>            Decrement iNumConn
78214>>>>>>>>>            For iConn from 0 to iNumConn
78220>>>>>>>>>>
78220>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78223>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78225>>>>>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
78226>>>>>>>>>                End
78226>>>>>>>>>>
78226>>>>>>>>>            Loop
78227>>>>>>>>>>
78227>>>>>>>>>            Send Destroy of hoCLI
78228>>>>>>>>>        End
78228>>>>>>>>>>
78228>>>>>>>>>
78228>>>>>>>>>    End_Procedure
78229>>>>>>>>>
78229>>>>>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
78231>>>>>>>>>        Integer iResult iDriver iNumConn iConn
78231>>>>>>>>>        Handle hoCLI
78231>>>>>>>>>        String sID sConnectionString sVal sDatabase
78231>>>>>>>>>        tSQLConnection SQLConnection
78231>>>>>>>>>        tSQLConnection SQLConnection
78231>>>>>>>>>        Boolean bTrusted
78231>>>>>>>>>
78231>>>>>>>>>        Move 0 to iResult
78232>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78233>>>>>>>>>        If (hoCLI <> 0) Begin
78235>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78236>>>>>>>>>            Get DriverIndex sDriverID to iDriver
78237>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78240>>>>>>>>>            Decrement iNumConn
78241>>>>>>>>>            For iConn from 0 to iNumConn
78247>>>>>>>>>>
78247>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78250>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78252>>>>>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
78253>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
78256>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
78259>>>>>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
78260>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
78263>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
78264>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
78265>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
78266>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
78267>>>>>>>>>
78267>>>>>>>>>                    Case Begin
78267>>>>>>>>>                        Case (sDriverID = MSSQLDRV_ID)
78269>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
78270>>>>>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
78271>>>>>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
78272>>>>>>>>>                            Case Break
78273>>>>>>>>>                        Case (sDriverID = DB2_DRV_ID)
78276>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78277>>>>>>>>>                            Case Break
78278>>>>>>>>>                        Case (sDriverID = ODBC_DRV_ID)
78281>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78282>>>>>>>>>                            If (SQLConnection.sServer = "") Begin
78284>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78285>>>>>>>>>                            End
78285>>>>>>>>>>
78285>>>>>>>>>                            Case Break
78286>>>>>>>>>                        Case (sDriverID = SQLFLEX)
78289>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78290>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
78291>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
78293>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
78294>>>>>>>>>                            End
78294>>>>>>>>>>
78294>>>>>>>>>                            Else Begin
78295>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
78296>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
78297>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
78298>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
78299>>>>>>>>>                            End
78299>>>>>>>>>>
78299>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
78300>>>>>>>>>                            Case Break
78301>>>>>>>>>                        Case (sDriverID = MDSMySQL)
78304>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78305>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
78306>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
78308>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
78309>>>>>>>>>                            End
78309>>>>>>>>>>
78309>>>>>>>>>                            Else Begin
78310>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
78311>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
78312>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
78313>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
78314>>>>>>>>>                            End
78314>>>>>>>>>>
78314>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
78315>>>>>>>>>                            Case Break
78316>>>>>>>>>                        Case (sDriverID = MDSPgSQL)
78319>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78320>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
78321>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
78323>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
78324>>>>>>>>>                            End
78324>>>>>>>>>>
78324>>>>>>>>>                            Else Begin
78325>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
78326>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
78327>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
78328>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
78329>>>>>>>>>                            End
78329>>>>>>>>>>
78329>>>>>>>>>                            Move sConnectionString                                                to SQLConnection.sConnectionString
78330>>>>>>>>>                            Case Break
78331>>>>>>>>>
78331>>>>>>>>>                        Case (sDriverID = ORAFLEX)
78334>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to SQLConnection.sServer
78335>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)         to sConnectionString
78336>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
78337>>>>>>>>>                            If (sDatabase <> "" and (not(SQLConnection.sServer contains "/"))) Begin
78339>>>>>>>>>                                Move (SQLConnection.sServer + "/" + sDatabase)                  to SQLConnection.sServer
78340>>>>>>>>>                            End
78340>>>>>>>>>>
78340>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
78342>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
78343>>>>>>>>>                            End
78343>>>>>>>>>>
78343>>>>>>>>>                            Else Begin
78344>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
78345>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
78346>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
78347>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
78348>>>>>>>>>                            End
78348>>>>>>>>>>
78348>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
78349>>>>>>>>>                            Case Break
78350>>>>>>>>>                        Case Else
78350>>>>>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
78351>>>>>>>>>>
78351>>>>>>>>>                            Case Break
78352>>>>>>>>>                    Case End
78352>>>>>>>>>                End
78352>>>>>>>>>>
78352>>>>>>>>>            Loop
78353>>>>>>>>>>
78353>>>>>>>>>            Send Destroy of hoCLI
78354>>>>>>>>>        End
78354>>>>>>>>>>
78354>>>>>>>>>
78354>>>>>>>>>        Function_Return SQLConnection
78355>>>>>>>>>    End_Function
78356>>>>>>>>>
78356>>>>>>>>>    Function DriverIndex String sDriverID Returns Integer
78358>>>>>>>>>        String  sCurrentDriver
78358>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
78358>>>>>>>>>
78358>>>>>>>>>        Move 0 to iDriver
78359>>>>>>>>>        Move 0 to iCount
78360>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
78363>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
78369>>>>>>>>>>
78369>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
78372>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
78374>>>>>>>>>                Function_Return iCount
78375>>>>>>>>>            End
78375>>>>>>>>>>
78375>>>>>>>>>        Loop
78376>>>>>>>>>>
78376>>>>>>>>>
78376>>>>>>>>>        // If driver not previously loaded; attempt to do so now.
78376>>>>>>>>>        If (iDriver = 0) Begin
78378>>>>>>>>>            Move 0 to LastErr
78379>>>>>>>>>            Load_Driver sDriverID
78380>>>>>>>>>            // If driver could not be loaded.
78380>>>>>>>>>            If (LastErr = DFERR_CANT_LOAD_DLL) Begin
78382>>>>>>>>>                Move -1 to iCount
78383>>>>>>>>>            End
78383>>>>>>>>>>
78383>>>>>>>>>        End
78383>>>>>>>>>>
78383>>>>>>>>>        Function_Return iCount
78384>>>>>>>>>    End_Function
78385>>>>>>>>>
78385>>>>>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
78385>>>>>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
78387>>>>>>>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
78387>>>>>>>>>        Boolean bTrusted bSilent
78387>>>>>>>>>        Integer iRetval
78387>>>>>>>>>
78387>>>>>>>>>        Move SQLConnection.sDriverID     to sDriverID
78388>>>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
78389>>>>>>>>>        Move SQLConnection.sServer       to sServer
78390>>>>>>>>>        Move SQLConnection.sDatabase     to sDatabase
78391>>>>>>>>>        Move SQLConnection.bTrusted      to bTrusted
78392>>>>>>>>>        Move SQLConnection.sUserID       to sUserID
78393>>>>>>>>>        Move SQLConnection.sPassword     to sPassword
78394>>>>>>>>>        Move SQLConnection.bSilentLogin  to bSilent
78395>>>>>>>>>
78395>>>>>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent False
78396>>>>>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
78396>>>>>>>>>        Get AutoSetConnectionID to iRetval
78397>>>>>>>>>    End_Procedure
78398>>>>>>>>>
78398>>>>>>>>>    // Called when the object is constructed.
78398>>>>>>>>>    // It will check the psDriverID for a ConnectionID and save it
78398>>>>>>>>>    // as psConnectionID property. It is later used whenever a login to
78398>>>>>>>>>    // the database is needed.
78398>>>>>>>>>    Function AutoSetConnectionID Returns Boolean
78400>>>>>>>>>        String sConnectionID sDriverID sConnectionString
78400>>>>>>>>>        Integer iDriver iRetval
78400>>>>>>>>>        Handle hoCLI
78400>>>>>>>>>        Boolean bOK bSilent bMertechDriver
78400>>>>>>>>>
78400>>>>>>>>>        Get pbSilentLogin      to bSilent
78401>>>>>>>>>        Get psConnectionID     to sConnectionID
78402>>>>>>>>>        Get psConnectionString to sConnectionString
78403>>>>>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
78403>>>>>>>>>        Get psDriverID to sDriverID
78404>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78405>>>>>>>>>        If (bOK = False) Begin
78407>>>>>>>>>            Function_Return False
78408>>>>>>>>>        End
78408>>>>>>>>>>
78408>>>>>>>>>
78408>>>>>>>>>        // Mertech drivers can't use connection ID's.
78408>>>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
78409>>>>>>>>>        If (bMertechDriver = True) Begin
78411>>>>>>>>>            // This ensures that the correct Server & Database attributes are set both for
78411>>>>>>>>>            // embedded SQL calls and "normal" database commands like e.g. "Open".
78411>>>>>>>>>            Get _MertechSQLManagerHandle to hoCLI
78412>>>>>>>>>            Function_Return (hoCLI <> 0)
78413>>>>>>>>>        End
78413>>>>>>>>>>
78413>>>>>>>>>
78413>>>>>>>>>        Get DriverIndex sDriverID          to iDriver
78414>>>>>>>>>        // If driver not loaded; load it.
78414>>>>>>>>>        If (iDriver = 0) Begin
78416>>>>>>>>>            Load_Driver sDriverID
78417>>>>>>>>>            Get DriverIndex sDriverID      to iDriver
78418>>>>>>>>>        End
78418>>>>>>>>>>
78418>>>>>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
78418>>>>>>>>>        If (iDriver = 0) Begin
78420>>>>>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
78421>>>>>>>>>>
78421>>>>>>>>>            Function_Return False
78422>>>>>>>>>        End           
78422>>>>>>>>>>
78422>>>>>>>>>        Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to True
78425>>>>>>>>>        
78425>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78426>>>>>>>>>        Set psDriverID of hoCLI            to sDriverID
78427>>>>>>>>>        // Delete the connection first; in case it exists
78427>>>>>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
78428>>>>>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval 
78429>>>>>>>>>        Send Destroy of hoCLI
78430>>>>>>>>>
78430>>>>>>>>>        Function_Return (iRetval = 0)
78431>>>>>>>>>    End_Function
78432>>>>>>>>>
78432>>>>>>>>>    // Returns the handle of the Mertech SQL handler.
78432>>>>>>>>>    // It also ensures that the correct Server & Database attributes are set both for
78432>>>>>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
78432>>>>>>>>>    // Note: This does _not_ return a proper CLI handler handle as it is not in this class.
78432>>>>>>>>>    //       So the return value is of no use! But we don't need the handle for this class.
78432>>>>>>>>>    Function _MertechSQLManagerHandle Returns Handle
78434>>>>>>>>>        Handle hoSQLHandler
78434>>>>>>>>>        String sDriverID sServer sDatabase
78434>>>>>>>>>
78434>>>>>>>>>        Move 0 to hoSQLHandler
78435>>>>>>>>>        Get psDriverID to sDriverID
78436>>>>>>>>>        Get psServer   to sServer
78437>>>>>>>>>        Get psDatabase to sDatabase
78438>>>>>>>>>
78438>>>>>>>>>        Function_Return hoSQLHandler
78439>>>>>>>>>    End_Function
78440>>>>>>>>>
78440>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
78442>>>>>>>>>        Boolean bOK bMertechDriver
78442>>>>>>>>>
78442>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
78443>>>>>>>>>
78443>>>>>>>>>        If (bOK = False) Begin
78445>>>>>>>>>            Get IsMertechDriver sDriverID to bOK
78446>>>>>>>>>        End
78446>>>>>>>>>>
78446>>>>>>>>>
78446>>>>>>>>>        If (bOK = False) Begin
78448>>>>>>>>>            Get IsMertechDriver sDriverID to bMertechDriver
78449>>>>>>>>>            If (bMertechDriver = True) Begin
78451>>>>>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID, ODBC_DRV_ID, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMYSQL"
78452>>>>>>>>>>
78452>>>>>>>>>            End
78452>>>>>>>>>>
78452>>>>>>>>>            Else Begin
78453>>>>>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
78454>>>>>>>>>>
78454>>>>>>>>>            End
78454>>>>>>>>>>
78454>>>>>>>>>            Function_Return False
78455>>>>>>>>>        End
78455>>>>>>>>>>
78455>>>>>>>>>
78455>>>>>>>>>        Function_Return True
78456>>>>>>>>>    End_Function
78457>>>>>>>>>
78457>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
78459>>>>>>>>>        Boolean bOK
78459>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
78460>>>>>>>>>        Function_Return bOK
78461>>>>>>>>>    End_Function
78462>>>>>>>>>
78462>>>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
78464>>>>>>>>>        Boolean bOK
78464>>>>>>>>>        Move False to bOK
78465>>>>>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
78465>>>>>>>>>            Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMYSQL) to bOK
78466>>>>>>>>>//        #ENDIF
78466>>>>>>>>>        Function_Return bOK
78467>>>>>>>>>    End_Function
78468>>>>>>>>>
78468>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
78470>>>>>>>>>        Handle hoIniFile
78470>>>>>>>>>        String sConnect
78470>>>>>>>>>
78470>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78471>>>>>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
78472>>>>>>>>>
78472>>>>>>>>>        Function_Return sConnect
78473>>>>>>>>>    End_Function
78474>>>>>>>>>
78474>>>>>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
78474>>>>>>>>>    // Pass a complete driver connection string
78474>>>>>>>>>    // Returns the following as a struct:
78474>>>>>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
78474>>>>>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
78474>>>>>>>>>    //
78474>>>>>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
78476>>>>>>>>>        tSQLConnection SQLConnection
78476>>>>>>>>>        tSQLConnection SQLConnection
78476>>>>>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
78476>>>>>>>>>        Boolean bTrusted bSilent bOK
78476>>>>>>>>>        Integer iPos
78476>>>>>>>>>
78476>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78477>>>>>>>>>        If (bOK = False) Begin
78479>>>>>>>>>            Function_Return SQLConnection
78480>>>>>>>>>        End
78480>>>>>>>>>>
78480>>>>>>>>>
78480>>>>>>>>>        Move False to bTrusted
78481>>>>>>>>>        Move False to bSilent
78482>>>>>>>>>
78482>>>>>>>>>        Case Begin
78482>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
78484>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
78485>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
78486>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78487>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78488>>>>>>>>>                If (bTrusted = False) Begin
78490>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78491>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78492>>>>>>>>>                End
78492>>>>>>>>>>
78492>>>>>>>>>                Case Break
78493>>>>>>>>>
78493>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
78496>>>>>>>>>                If (uppercase(sConnectionString) contains ("." + CS_SQLIniDSNKeyword)) Begin
78498>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword + "=")  to sServer
78499>>>>>>>>>                End
78499>>>>>>>>>>
78499>>>>>>>>>                Else Begin
78500>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78501>>>>>>>>>                End
78501>>>>>>>>>>
78501>>>>>>>>>
78501>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78502>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78503>>>>>>>>>                If (bTrusted = False) Begin
78505>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78506>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78507>>>>>>>>>                End
78507>>>>>>>>>>
78507>>>>>>>>>                Case Break
78508>>>>>>>>>
78508>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
78511>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78512>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
78513>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
78514>>>>>>>>>                Case Break
78515>>>>>>>>>
78515>>>>>>>>>            Case (sDriverID = SQLFLEX)
78518>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
78519>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78520>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78521>>>>>>>>>                If (bTrusted = False) Begin
78523>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78524>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78525>>>>>>>>>                End
78525>>>>>>>>>>
78525>>>>>>>>>                Case Break
78526>>>>>>>>>
78526>>>>>>>>>            Case (sDriverID = ORAFLEX)
78529>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78530>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
78531>>>>>>>>>                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
78533>>>>>>>>>                    Move (sServer + "/" + sDatabase)                                to sServer
78534>>>>>>>>>                End
78534>>>>>>>>>>
78534>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
78535>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
78536>>>>>>>>>                Case Break
78537>>>>>>>>>
78537>>>>>>>>>            Case (sDriverID = MDSPgSQL)
78540>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78541>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
78542>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
78543>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
78544>>>>>>>>>                Case Break
78545>>>>>>>>>
78545>>>>>>>>>            Case (sDriverID = MDSMySQL)
78548>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78549>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
78550>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
78551>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
78552>>>>>>>>>                Case Break
78553>>>>>>>>>
78553>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
78556>>>>>>>>>                Break
78557>>>>>>>>>        Case End
78557>>>>>>>>>
78557>>>>>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
78558>>>>>>>>>
78558>>>>>>>>>        // bSilent?
78558>>>>>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
78559>>>>>>>>>        If (iPos = 0) Begin
78561>>>>>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
78562>>>>>>>>>        End
78562>>>>>>>>>>
78562>>>>>>>>>        If (iPos = 0) Begin
78564>>>>>>>>>            Move "0"                                                            to sValue
78565>>>>>>>>>        End
78565>>>>>>>>>>
78565>>>>>>>>>        Else Begin
78566>>>>>>>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
78567>>>>>>>>>        End
78567>>>>>>>>>>
78567>>>>>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
78568>>>>>>>>>
78568>>>>>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
78569>>>>>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
78570>>>>>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
78571>>>>>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
78572>>>>>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
78573>>>>>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
78574>>>>>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
78575>>>>>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
78576>>>>>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
78577>>>>>>>>>
78577>>>>>>>>>        Function_Return SQLConnection
78578>>>>>>>>>    End_Function
78579>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
78579>>>>>>>>>>
78579>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
78581>>>>>>>>>>    Integer iStart iEnd
78581>>>>>>>>>>    String sRetval
78581>>>>>>>>>>
78581>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
78582>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
78583>>>>>>>>>>    If (iStart = 0) Begin
78585>>>>>>>>>>        Function_Return ""
78586>>>>>>>>>>    End
78586>>>>>>>>>>>
78586>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
78587>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
78588>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
78590>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78591>>>>>>>>>>    End
78591>>>>>>>>>>>
78591>>>>>>>>>>    Else Begin
78592>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
78593>>>>>>>>>>    End
78593>>>>>>>>>>>
78593>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
78595>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78596>>>>>>>>>>        Decrement iEnd
78597>>>>>>>>>>    End
78597>>>>>>>>>>>
78597>>>>>>>>>>    If (iEnd <> 0) Begin
78599>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
78600>>>>>>>>>>    End
78600>>>>>>>>>>>
78600>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
78601>>>>>>>>>>
78601>>>>>>>>>>    Function_Return (Trim(sRetval))
78602>>>>>>>>>>End_Function
78603>>>>>>>>>>
78603>>>>>>>>>>
78603>>>>>>>>>
78603>>>>>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
78603>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
78605>>>>>>>>>        Handle ho
78605>>>>>>>>>        Integer iIndex
78605>>>>>>>>>        Boolean bRetval bOK
78605>>>>>>>>>        tSQLConnection SQLConnection
78605>>>>>>>>>        tSQLConnection SQLConnection
78605>>>>>>>>>
78605>>>>>>>>>        Get pSQLConnection to SQLConnection
78606>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78607>>>>>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
78608>>>>>>>>>        If (iIndex = -1) Begin
78610>>>>>>>>>            Function_Return False
78611>>>>>>>>>        End
78611>>>>>>>>>>
78611>>>>>>>>>
78611>>>>>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
78612>>>>>>>>>        Send UpdateConnectionString SQLConnection
78613>>>>>>>>>        If (ghoConnection > 0) Begin
78615>>>>>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
78616>>>>>>>>>            If (iIndex <> -1) Begin
78618>>>>>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
78619>>>>>>>>>            End
78619>>>>>>>>>>
78619>>>>>>>>>        End
78619>>>>>>>>>>
78619>>>>>>>>>
78619>>>>>>>>>        Function_Return bRetval
78620>>>>>>>>>    End_Function
78621>>>>>>>>>
78621>>>>>>>>>End_Class
78622>>>>>>>Use vWin32fh.pkg
78622>>>>>>>Use Dfabout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\DfAbout.pkg)
78622>>>>>>>>>Use LanguageText.pkg
78622>>>>>>>>>Use Windows.pkg
78622>>>>>>>>>Use Dfclient.pkg
78622>>>>>>>>>Use DFbitmap.pkg
78622>>>>>>>>>Use GlobalFunctionsProcedures.pkg
78622>>>>>>>>>Use cRichEdit.pkg
78622>>>>>>>>>Use cTextEdit.pkg
78622>>>>>>>>>Use cRichEdit.pkg
78622>>>>>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files\DataFlex 20.1\Pkg\gFormatNumbers.pkg)
78622>>>>>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cFormatter.pkg)
78622>>>>>>>>>>>>>Use VDFBase.pkg
78622>>>>>>>>>>>>>
78622>>>>>>>>>>>>>Class cFormatter is an cObject
78623>>>>>>>>>>>>>    
78623>>>>>>>>>>>>>    Procedure Construct_object
78625>>>>>>>>>>>>>        Integer iCh
78625>>>>>>>>>>>>>        Forward Send construct_object
78627>>>>>>>>>>>>>        Property String  psCurrencySymbol
78628>>>>>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
78629>>>>>>>>>>>>>        
78629>>>>>>>>>>>>>        Property String  psLeft
78630>>>>>>>>>>>>>        Property String  psright
78631>>>>>>>>>>>>>        Property Integer pbThousandsSep
78632>>>>>>>>>>>>>        Property Integer piPoints
78633>>>>>>>>>>>>>        
78633>>>>>>>>>>>>>        Property String  psCurPosLeft
78634>>>>>>>>>>>>>        Property String  psCurPosright
78635>>>>>>>>>>>>>        Property Integer pbCurPosThousandsSep
78636>>>>>>>>>>>>>        Property Integer piCurPosPoints
78637>>>>>>>>>>>>>        
78637>>>>>>>>>>>>>        Property String  psCurNegLeft
78638>>>>>>>>>>>>>        Property String  psCurNegright
78639>>>>>>>>>>>>>        Property Integer pbCurNegThousandsSep
78640>>>>>>>>>>>>>        Property Integer piCurNegPoints
78641>>>>>>>>>>>>>        
78641>>>>>>>>>>>>>        Property String  psNumPosLeft
78642>>>>>>>>>>>>>        Property String  psNumPosright
78643>>>>>>>>>>>>>        Property Integer pbNumPosThousandsSep
78644>>>>>>>>>>>>>        Property Integer piNumPosPoints
78645>>>>>>>>>>>>>        
78645>>>>>>>>>>>>>        Property String  psNumNegLeft
78646>>>>>>>>>>>>>        Property String  psNumNegright
78647>>>>>>>>>>>>>        Property Integer pbNumNegThousandsSep
78648>>>>>>>>>>>>>        Property Integer piNumNegPoints
78649>>>>>>>>>>>>>        
78649>>>>>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
78650>>>>>>>>>>>>>        Send SetFormat  ",#.*"           False // numeric
78651>>>>>>>>>>>>>        
78651>>>>>>>>>>>>>    End_Procedure
78652>>>>>>>>>>>>>    
78652>>>>>>>>>>>>>    // internal
78652>>>>>>>>>>>>>    // parse passed format string and set temporary properties with result
78652>>>>>>>>>>>>>    Procedure ParseFormat String sFmt
78654>>>>>>>>>>>>>        
78654>>>>>>>>>>>>>        String sLeft sRight sDigit
78654>>>>>>>>>>>>>        Integer bSep iPos i iDigits
78654>>>>>>>>>>>>>        
78654>>>>>>>>>>>>>        // replace any literals. A "/" followed by anything.
78654>>>>>>>>>>>>>        // some literals are special. $ . , / #
78654>>>>>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
78655>>>>>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
78656>>>>>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
78657>>>>>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
78658>>>>>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
78659>>>>>>>>>>>>>        Move (Character(9)) to sDigit
78660>>>>>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
78661>>>>>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
78662>>>>>>>>>>>>>        
78662>>>>>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
78663>>>>>>>>>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
78666>>>>>>>>>>>>>        
78666>>>>>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
78667>>>>>>>>>>>>>        
78667>>>>>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
78668>>>>>>>>>>>>>        
78668>>>>>>>>>>>>>        // Move all the special literals back into place before parsing
78668>>>>>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
78669>>>>>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
78670>>>>>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
78671>>>>>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
78672>>>>>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
78673>>>>>>>>>>>>>        
78673>>>>>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
78675>>>>>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
78676>>>>>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
78678>>>>>>>>>>>>>                Move -2 to iDigits
78679>>>>>>>>>>>>>                Increment i
78680>>>>>>>>>>>>>            End
78680>>>>>>>>>>>>>>
78680>>>>>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
78684>>>>>>>>>>>>>                Increment i
78685>>>>>>>>>>>>>            Loop
78686>>>>>>>>>>>>>>
78686>>>>>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
78687>>>>>>>>>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
78690>>>>>>>>>>>>>            //
78690>>>>>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
78691>>>>>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
78695>>>>>>>>>>>>>                Increment i
78696>>>>>>>>>>>>>            Loop
78697>>>>>>>>>>>>>>
78697>>>>>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
78698>>>>>>>>>>>>>        End
78698>>>>>>>>>>>>>>
78698>>>>>>>>>>>>>        Else Begin                             // we have no decinal
78699>>>>>>>>>>>>>            Move 0 to iDigits                  // so points is none
78700>>>>>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
78701>>>>>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
78703>>>>>>>>>>>>>                Move sFmt to sLeft
78704>>>>>>>>>>>>>                Move ""   to sRight
78705>>>>>>>>>>>>>            End
78705>>>>>>>>>>>>>>
78705>>>>>>>>>>>>>            Else Begin
78706>>>>>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
78707>>>>>>>>>>>>>                Move 1 to i
78708>>>>>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
78712>>>>>>>>>>>>>                    Increment i
78713>>>>>>>>>>>>>                Loop
78714>>>>>>>>>>>>>>
78714>>>>>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
78715>>>>>>>>>>>>>            End
78715>>>>>>>>>>>>>>
78715>>>>>>>>>>>>>        End
78715>>>>>>>>>>>>>>
78715>>>>>>>>>>>>>        // set temporary format properties and exit
78715>>>>>>>>>>>>>        Set pbThousandsSep to bSep
78716>>>>>>>>>>>>>        Set psLeft         to sLeft
78717>>>>>>>>>>>>>        Set psRight        to sRight
78718>>>>>>>>>>>>>        Set piPoints       to iDigits
78719>>>>>>>>>>>>>    End_Procedure
78720>>>>>>>>>>>>>    
78720>>>>>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
78720>>>>>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
78720>>>>>>>>>>>>>    //
78720>>>>>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
78720>>>>>>>>>>>>>    Procedure SetFormat String sFmt Integer bCurrency
78722>>>>>>>>>>>>>        String sPos sNeg
78722>>>>>>>>>>>>>        Integer iPos
78722>>>>>>>>>>>>>        
78722>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
78723>>>>>>>>>>>>>        If iPos Begin
78725>>>>>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
78726>>>>>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
78727>>>>>>>>>>>>>        End
78727>>>>>>>>>>>>>>
78727>>>>>>>>>>>>>        Else Begin
78728>>>>>>>>>>>>>            Move sFmt         to sPos
78729>>>>>>>>>>>>>            Move ("-" + sFmt) to sNeg
78730>>>>>>>>>>>>>        End
78730>>>>>>>>>>>>>>
78730>>>>>>>>>>>>>        Send ParseFormat sPos
78731>>>>>>>>>>>>>        If bCurrency Begin
78733>>>>>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
78734>>>>>>>>>>>>>            Set psCurPosLeft         to (psLeft(Self))
78735>>>>>>>>>>>>>            Set psCurPosRight        to (psRight(Self))
78736>>>>>>>>>>>>>            Set piCurPosPoints       to (piPoints(Self))
78737>>>>>>>>>>>>>        End
78737>>>>>>>>>>>>>>
78737>>>>>>>>>>>>>        Else Begin
78738>>>>>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
78739>>>>>>>>>>>>>            Set psNumPosLeft         to (psLeft(Self))
78740>>>>>>>>>>>>>            Set psNumPosRight        to (psRight(Self))
78741>>>>>>>>>>>>>            Set piNumPosPoints       to (piPoints(Self))
78742>>>>>>>>>>>>>        End
78742>>>>>>>>>>>>>>
78742>>>>>>>>>>>>>        
78742>>>>>>>>>>>>>        Send ParseFormat sNeg
78743>>>>>>>>>>>>>        If bCurrency Begin
78745>>>>>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
78746>>>>>>>>>>>>>            Set psCurNegLeft         to (psLeft(Self))
78747>>>>>>>>>>>>>            Set psCurNegRight        to (psRight(Self))
78748>>>>>>>>>>>>>            Set piCurNegPoints       to (piPoints(Self))
78749>>>>>>>>>>>>>        End
78749>>>>>>>>>>>>>>
78749>>>>>>>>>>>>>        Else Begin
78750>>>>>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
78751>>>>>>>>>>>>>            Set psNumNegLeft         to (psLeft(Self))
78752>>>>>>>>>>>>>            Set psNumNegRight        to (psRight(Self))
78753>>>>>>>>>>>>>            Set piNumNegPoints       to (piPoints(Self))
78754>>>>>>>>>>>>>        End
78754>>>>>>>>>>>>>>
78754>>>>>>>>>>>>>    End_Procedure
78755>>>>>>>>>>>>>    
78755>>>>>>>>>>>>>    // low level formatting. Pass parameters
78755>>>>>>>>>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
78757>>>>>>>>>>>>>        String  sLeft sRight sNumber sSep sDec
78757>>>>>>>>>>>>>        Integer bIsNegative iDec iLen iCh
78757>>>>>>>>>>>>>        
78757>>>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
78760>>>>>>>>>>>>>        Move (Character(iCh)) to sDec
78761>>>>>>>>>>>>>        
78761>>>>>>>>>>>>>        Move (abs(nNumber)) to sNumber
78762>>>>>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
78763>>>>>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
78764>>>>>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
78765>>>>>>>>>>>>>        // format for decimal separator
78765>>>>>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
78768>>>>>>>>>>>>>        
78768>>>>>>>>>>>>>        // format for thousand sep.
78768>>>>>>>>>>>>>        If bSep Begin
78770>>>>>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
78773>>>>>>>>>>>>>            Move (Character(iCh)) to sSep
78774>>>>>>>>>>>>>            Move (Length(sLeft)) to iLen
78775>>>>>>>>>>>>>            While (iLen>3)
78779>>>>>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
78780>>>>>>>>>>>>>                Move (iLen-3) to iLen
78781>>>>>>>>>>>>>            Loop
78782>>>>>>>>>>>>>>
78782>>>>>>>>>>>>>        End
78782>>>>>>>>>>>>>>
78782>>>>>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
78782>>>>>>>>>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
78785>>>>>>>>>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
78786>>>>>>>>>>>>>    End_Function
78787>>>>>>>>>>>>>    
78787>>>>>>>>>>>>>    // Public: Format for currency
78787>>>>>>>>>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
78789>>>>>>>>>>>>>        String  sLeft sRight
78789>>>>>>>>>>>>>        Integer bSep
78789>>>>>>>>>>>>>        If (nNumber<0) Begin
78791>>>>>>>>>>>>>            Get pbCurNegThousandsSep to bSep
78792>>>>>>>>>>>>>            Get psCurNegLeft         to sLeft
78793>>>>>>>>>>>>>            Get psCurNegRight        to sRight
78794>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
78797>>>>>>>>>>>>>        End
78797>>>>>>>>>>>>>>
78797>>>>>>>>>>>>>        Else Begin
78798>>>>>>>>>>>>>            Get pbCurPosThousandsSep to bSep
78799>>>>>>>>>>>>>            Get psCurPosLeft         to sLeft
78800>>>>>>>>>>>>>            Get psCurPosRight        to sRight
78801>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
78804>>>>>>>>>>>>>        End
78804>>>>>>>>>>>>>>
78804>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
78805>>>>>>>>>>>>>    End_Function
78806>>>>>>>>>>>>>    
78806>>>>>>>>>>>>>    // Public: Format for numeric
78806>>>>>>>>>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
78808>>>>>>>>>>>>>        String  sLeft sRight
78808>>>>>>>>>>>>>        Integer bSep
78808>>>>>>>>>>>>>        If (nNumber<0) Begin
78810>>>>>>>>>>>>>            Get pbNumNegThousandsSep to bSep
78811>>>>>>>>>>>>>            Get psNumNegLeft         to sLeft
78812>>>>>>>>>>>>>            Get psNumNegRight        to sRight
78813>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
78816>>>>>>>>>>>>>        End
78816>>>>>>>>>>>>>>
78816>>>>>>>>>>>>>        Else Begin
78817>>>>>>>>>>>>>            Get pbNumPosThousandsSep to bSep
78818>>>>>>>>>>>>>            Get psNumPosLeft         to sLeft
78819>>>>>>>>>>>>>            Get psNumPosRight        to sRight
78820>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
78823>>>>>>>>>>>>>        End
78823>>>>>>>>>>>>>>
78823>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
78824>>>>>>>>>>>>>    End_Function
78825>>>>>>>>>>>>>    
78825>>>>>>>>>>>>>    
78825>>>>>>>>>>>>>    // Public: Format passing format string
78825>>>>>>>>>>>>>    Function FormatVal Number nNumber String sFmt Returns String
78827>>>>>>>>>>>>>        Integer iPos bIsNeg
78827>>>>>>>>>>>>>        String  sLeft sRight
78827>>>>>>>>>>>>>        Integer iPoints bSep
78827>>>>>>>>>>>>>        Move (nNumber<0) to bIsNeg
78828>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
78829>>>>>>>>>>>>>        Case Begin
78829>>>>>>>>>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
78832>>>>>>>>>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
78836>>>>>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
78840>>>>>>>>>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
78842>>>>>>>>>>>>>        Case End
78842>>>>>>>>>>>>>        Send ParseFormat sFmt
78843>>>>>>>>>>>>>        Get pbThousandsSep to bSep
78844>>>>>>>>>>>>>        Get psLeft         to sLeft
78845>>>>>>>>>>>>>        Get psRight        to sRight
78846>>>>>>>>>>>>>        Get piPoints       to iPoints
78847>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
78848>>>>>>>>>>>>>    End_Function
78849>>>>>>>>>>>>>    
78849>>>>>>>>>>>>>End_Class
78850>>>>>>>>>>>
78850>>>>>>>>>>>Global_Variable Handle ghoFormatter
78850>>>>>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
78851>>>>>>>>>>>
78851>>>>>>>>>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
78853>>>>>>>>>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
78854>>>>>>>>>>>End_Function
78855>>>>>>>>>>>
78855>>>>>>>>>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
78857>>>>>>>>>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
78858>>>>>>>>>>>End_Function
78859>>>>>>>>>>>
78859>>>>>>>>>>>Function FormatValue Global Number nNum String sFmt Returns String
78861>>>>>>>>>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
78862>>>>>>>>>>>End_Function
78863>>>>>>>>>>>
78863>>>>>>>>>>>Procedure SetCurrencyFormat Global String sFmt
78865>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt True
78866>>>>>>>>>>>End_Procedure
78867>>>>>>>>>>>
78867>>>>>>>>>>>Procedure SetNumberFormat Global String sFmt
78869>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt False
78870>>>>>>>>>>>End_Procedure
78871>>>>>>>>>>>
78871>>>>>>>>>>>
78871>>>>>>>>>Use tWinStructs.pkg
78871>>>>>>>>>
78871>>>>>>>>>Use cli.pkg
78871>>>>>>>>>Use DFBTRDRV.PKG
78871>>>>>>>>>Use MSSqldrv.pkg
78871>>>>>>>>>Use db2_drv.pkg
78871>>>>>>>>>Use odbc_drv.pkg
78871>>>>>>>>>Use seq_chnl.pkg
78871>>>>>>>>>
78871>>>>>>>>>Register_Function phoWorkspace Returns Handle
78871>>>>>>>>>Register_Function Help_filename Returns String
78871>>>>>>>>>Register_Function GetHelpFile Returns String
78871>>>>>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
78871>>>>>>>>>
78871>>>>>>>>>// Use of Mertech drivers:
78871>>>>>>>>>// Ad the line "Define DUF_Use_Mertech_Drivers" prior "Use" of this package to your source code if using Mertech drivers!
78871>>>>>>>>>
78871>>>>>>>>>
78871>>>>>>>>>
78871>>>>>>>>>
78871>>>>>>>>>
78871>>>>>>>>>// *** Constant Declarations: ***
78871>>>>>>>>>//
78871>>>>>>>>>
78871>>>>>>>>>
78871>>>>>>>>>
78871>>>>>>>>>
78871>>>>>>>>>
78871>>>>>>>>>
78871>>>>>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
78871>>>>>>>>>
78871>>>>>>>>>
78871>>>>>>>>>
78871>>>>>>>>>
78871>>>>>>>>>
78871>>>>>>>>>
78871>>>>>>>>>
78871>>>>>>>>>
78871>>>>>>>>>
78871>>>>>>>>>// System icon menu constants. If the upper left hand
78871>>>>>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
78871>>>>>>>>>    Define SC_RESTORE  for |CI$F120
78871>>>>>>>>>    Define SC_MOVE     for |CI$F010
78871>>>>>>>>>    Define SC_SIZE     for |CI$F000
78871>>>>>>>>>    Define SC_MINIMIZE for |CI$F020
78871>>>>>>>>>    Define SC_MAXIMIZE for |CI$F030
78871>>>>>>>>>    Define SC_CLOSE    for |CI$F060
78871>>>>>>>>>    Define SC_KEYMENU  for |CI$F100
78871>>>>>>>>>    Define SC_NEXTWINDOW for |CI$F040
78871>>>>>>>>>    Define SC_PREVWINDOW for |CI$F050
78871>>>>>>>>>
78871>>>>>>>>>Define CS_SignProgram        for "signtool.exe"
78871>>>>>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
78871>>>>>>>>>Define CS_VerifyCredentials  for "verify"
78871>>>>>>>>>Define CS_VerifyFileParam    for "/a"
78871>>>>>>>>>Define CS_DefAuthVerPolicy   for "/pa"
78871>>>>>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
78871>>>>>>>>>
78871>>>>>>>>>// *** Struct Declarations: ***
78871>>>>>>>>>
78871>>>>>>>>>Struct AboutSHELLEXECUTEINFO
78871>>>>>>>>>    DWord   cbSize
78871>>>>>>>>>    Integer fMask
78871>>>>>>>>>    Handle  hwnd
78871>>>>>>>>>    Pointer lpVerb
78871>>>>>>>>>    Pointer lpFile
78871>>>>>>>>>    Pointer lpParameters
78871>>>>>>>>>    Pointer lpDirectory
78871>>>>>>>>>    Integer nShow
78871>>>>>>>>>    Pointer hInstApp
78871>>>>>>>>>    Pointer lpIDList
78871>>>>>>>>>    Pointer lpClass
78871>>>>>>>>>    Handle  hkeyClass
78871>>>>>>>>>    DWord   dwHotKey
78871>>>>>>>>>    Handle  hIconMonitor // Union
78871>>>>>>>>>    //Handle  hMonitor     // Union
78871>>>>>>>>>    Handle  hProcess
78871>>>>>>>>>End_Struct
78871>>>>>>>>>
78871>>>>>>>>>
78871>>>>>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
78871>>>>>>>>>//Type MEMORYSTATUS
78871>>>>>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
78871>>>>>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
78871>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
78871>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
78871>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
78871>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
78871>>>>>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
78871>>>>>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
78871>>>>>>>>>//End_Type
78871>>>>>>>>>
78871>>>>>>>>>// *** External Function calls: ***
78871>>>>>>>>>//
78871>>>>>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
78872>>>>>>>>>
78872>>>>>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
78873>>>>>>>>>
78873>>>>>>>>>// Do not call directly, use the wrapper function instead
78873>>>>>>>>>External_Function WNetGetUserW "WNetGetUserW" MPR.DLL ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
78874>>>>>>>>>
78874>>>>>>>>>    // Wrapper Function WNetGetUser
78874>>>>>>>>>    Function WNetGetUser Global ;        Pointer lpName ;        Pointer lpUser_Name ;        Pointer lpLength ;        Returns DWord
78876>>>>>>>>>
78876>>>>>>>>>        DWord   dwResult
78876>>>>>>>>>        UWide   uwName uwUserName
78876>>>>>>>>>        UWide   uwName uwUserName
78876>>>>>>>>>
78876>>>>>>>>>        Send StringToWide lpName (&uwName)
78877>>>>>>>>>
78877>>>>>>>>>        Send WideSetBuffer lpUser_Name lpLength (&uwUserName)
78878>>>>>>>>>
78878>>>>>>>>>        Move (WNetGetUserW (uwName.lpUText, uwUserName.lpUText, lpLength)) to dwResult
78879>>>>>>>>>
78879>>>>>>>>>        Send WideToString (&uwUserName) lpUser_Name
78880>>>>>>>>>
78880>>>>>>>>>        Function_Return dwResult
78881>>>>>>>>>    End_Function
78882>>>>>>>>>
78882>>>>>>>>>
78882>>>>>>>>>
78882>>>>>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
78883>>>>>>>>>
78883>>>>>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
78884>>>>>>>>>
78884>>>>>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
78885>>>>>>>>>
78885>>>>>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
78886>>>>>>>>>
78886>>>>>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
78887>>>>>>>>>
78887>>>>>>>>>// *** Global/Desktop Function Declarations: ***
78887>>>>>>>>>
78887>>>>>>>>>Function ComputerName Desktop Returns String
78889>>>>>>>>>    String sName
78889>>>>>>>>>    Get_Environment "COMPUTERNAME" to sName
78890>>>>>>>>>>
78890>>>>>>>>>    Function_Return sName
78891>>>>>>>>>End_Function
78892>>>>>>>>>
78892>>>>>>>>>Function Network_User_Name Desktop Returns String
78894>>>>>>>>>    WString wName
78894>>>>>>>>>    Integer iRetval iLength
78894>>>>>>>>>
78894>>>>>>>>>    Move 0 to iLength
78895>>>>>>>>>    Move (WNetGetUserW (0, 0, AddressOf (iLength))) to iRetval
78896>>>>>>>>>    Move (ZeroString(iLength)) to wName
78897>>>>>>>>>    Move (WNetGetUserW (0, AddressOf (wName), AddressOf (iLength))) to iRetval
78898>>>>>>>>>
78898>>>>>>>>>    If (iRetval = NO_ERROR) Begin
78900>>>>>>>>>        Function_Return (CString (wName))
78901>>>>>>>>>    End
78901>>>>>>>>>>
78901>>>>>>>>>
78901>>>>>>>>>    Function_Return "User Unknown"
78902>>>>>>>>>End_Function
78903>>>>>>>>>
78903>>>>>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
78905>>>>>>>>>    String sClient sDriver sClientDriver
78905>>>>>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
78905>>>>>>>>>    Handle hoMsqlDrv
78905>>>>>>>>>
78905>>>>>>>>>    Move 0 to iDriver
78906>>>>>>>>>    Move "" to sClient
78907>>>>>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
78910>>>>>>>>>    For iCount from 1 to iNumberOfDrivers
78916>>>>>>>>>>
78916>>>>>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
78919>>>>>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
78921>>>>>>>>>            Move iCount to iDriver
78922>>>>>>>>>            Move iNumberOfDrivers to iCount // We're done.
78923>>>>>>>>>        End
78923>>>>>>>>>>
78923>>>>>>>>>    Loop
78924>>>>>>>>>>
78924>>>>>>>>>
78924>>>>>>>>>    // This info is (at current) only available for the MS SQL driver:
78924>>>>>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
78926>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
78929>>>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
78930>>>>>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
78931>>>>>>>>>        Send Destroy of hoMsqlDrv
78932>>>>>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
78933>>>>>>>>>    End
78933>>>>>>>>>>
78933>>>>>>>>>
78933>>>>>>>>>    Function_Return sClient
78934>>>>>>>>>End_Function
78935>>>>>>>>>
78935>>>>>>>>>// *** Class Declarations: ***
78935>>>>>>>>>//
78935>>>>>>>>>Class cBitmapContainerDFLink is a BitmapContainer
78936>>>>>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
78938>>>>>>>>>        Send Mouse_Up iWindowNumber iPosition
78939>>>>>>>>>    End_Procedure
78940>>>>>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
78942>>>>>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
78944>>>>>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
78945>>>>>>>>>    End_Procedure
78946>>>>>>>>>End_Class
78947>>>>>>>>>
78947>>>>>>>>>Class cCopyEditorContentButton is a Button
78948>>>>>>>>>    Procedure Construct_Object
78950>>>>>>>>>        Forward Send Construct_Object
78952>>>>>>>>>        Property Handle phoEditorHandle
78953>>>>>>>>>        Set psToolTip to C_$DescCopy
78954>>>>>>>>>    End_Procedure
78955>>>>>>>>>
78955>>>>>>>>>    Procedure CopyToWindowsClipboard
78957>>>>>>>>>        Handle hoEditor
78957>>>>>>>>>        Boolean bCanCopy
78957>>>>>>>>>        Address aEditorAddress
78957>>>>>>>>>
78957>>>>>>>>>        Get phoEditorHandle to hoEditor
78958>>>>>>>>>        Send Select_All of hoEditor
78959>>>>>>>>>        Get CanCopy of hoEditor to bCanCopy
78960>>>>>>>>>        If (bCanCopy = True) Begin
78962>>>>>>>>>            Get paValue of hoEditor to aEditorAddress
78963>>>>>>>>>            Send Copy   of hoEditor
78964>>>>>>>>>            // Remove the selection after text is copied to the clipboard.
78964>>>>>>>>>            Send Beginning_of_Data of hoEditor
78965>>>>>>>>>            Send Info_Box C_$CopyToClipboard_Text
78966>>>>>>>>>        End
78966>>>>>>>>>>
78966>>>>>>>>>    End_Procedure
78967>>>>>>>>>End_Class
78968>>>>>>>>>
78968>>>>>>>>>Class SysinfoDisplay is a cTextEdit
78969>>>>>>>>>    Procedure Construct_Object
78971>>>>>>>>>        Forward Send Construct_Object
78973>>>>>>>>>
78973>>>>>>>>>        Set Size to 100 245
78974>>>>>>>>>        Set Location to 6 6
78975>>>>>>>>>        Set Border_Style to Border_None
78976>>>>>>>>>        Set Read_Only_State to True
78977>>>>>>>>>        Set pbWrap to True
78978>>>>>>>>>        Set peAnchors to anAll
78979>>>>>>>>>    End_Procedure
78980>>>>>>>>>
78980>>>>>>>>>    // Augmented class message to adjust certain text strings that are wrong...
78980>>>>>>>>>
78980>>>>>>>>>    Procedure AppendTextLn String sText
78982>>>>>>>>>        String sWorkspaceWSFile
78982>>>>>>>>>
78982>>>>>>>>>        // Only works for English:
78982>>>>>>>>>        If (ghoApplication > 0) Begin
78984>>>>>>>>>            If (sText contains "Workspace Name") Begin
78986>>>>>>>>>                Move "Workspace Config Filename:" to sText
78987>>>>>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
78988>>>>>>>>>                Move (sText * sWorkspaceWSFile) to sText
78989>>>>>>>>>            End
78989>>>>>>>>>>
78989>>>>>>>>>        End
78989>>>>>>>>>>
78989>>>>>>>>>        Send AppendText sText
78990>>>>>>>>>        Send AppendText (character(10))
78991>>>>>>>>>    End_Procedure
78992>>>>>>>>>
78992>>>>>>>>>    //    This method will show the name Of the current directory in the system
78992>>>>>>>>>    //    information box
78992>>>>>>>>>    Procedure Show_Current_Directory
78994>>>>>>>>>        String sDir
78994>>>>>>>>>
78994>>>>>>>>>        Get_Current_Directory To sDir
78995>>>>>>>>>
78995>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
78996>>>>>>>>>    End_Procedure
78997>>>>>>>>>
78997>>>>>>>>>    Procedure Show_Windows_Directory
78999>>>>>>>>>        String sWindir
78999>>>>>>>>>
78999>>>>>>>>>        Get_Windows_Directory To sWindir
79000>>>>>>>>>
79000>>>>>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
79001>>>>>>>>>    End_Procedure
79002>>>>>>>>>
79002>>>>>>>>>    Procedure Show_Current_User
79004>>>>>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
79005>>>>>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
79006>>>>>>>>>    End_Procedure
79007>>>>>>>>>
79007>>>>>>>>>    Procedure Show_Number_Format
79009>>>>>>>>>        Integer iFormat
79009>>>>>>>>>        String sFormatText
79009>>>>>>>>>
79009>>>>>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
79012>>>>>>>>>        Move (Character (iFormat)) To sFormatText
79013>>>>>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
79014>>>>>>>>>
79014>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
79017>>>>>>>>>        Move (Character (iFormat)) to sFormatText
79018>>>>>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
79019>>>>>>>>>    End_Procedure
79020>>>>>>>>>
79020>>>>>>>>>    Procedure Show_Filelist_Name
79022>>>>>>>>>        String sFilename
79022>>>>>>>>>
79022>>>>>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
79025>>>>>>>>>
79025>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
79026>>>>>>>>>    End_Procedure
79027>>>>>>>>>
79027>>>>>>>>>    Procedure Show_Lock_Delay
79029>>>>>>>>>        Integer iLockdelay
79029>>>>>>>>>
79029>>>>>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
79032>>>>>>>>>
79032>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
79033>>>>>>>>>    End_Procedure
79034>>>>>>>>>
79034>>>>>>>>>    Procedure Show_Lock_Timeout
79036>>>>>>>>>        Integer iLockTimeout
79036>>>>>>>>>
79036>>>>>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
79039>>>>>>>>>
79039>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
79040>>>>>>>>>    End_Procedure
79041>>>>>>>>>
79041>>>>>>>>>    Procedure Show_Screen_Size
79043>>>>>>>>>        Integer iYscreensize iXscreensize
79043>>>>>>>>>
79043>>>>>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
79044>>>>>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
79045>>>>>>>>>
79045>>>>>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
79046>>>>>>>>>    End_Procedure
79047>>>>>>>>>
79047>>>>>>>>>    Procedure Show_Page_Size
79049>>>>>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
79050>>>>>>>>>    End_procedure
79051>>>>>>>>>
79051>>>>>>>>>    Procedure Show_Date
79053>>>>>>>>>        Date dToday
79053>>>>>>>>>
79053>>>>>>>>>        Move (CurrentDateTime()) to dToday
79054>>>>>>>>>
79054>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
79055>>>>>>>>>    End_procedure
79056>>>>>>>>>
79056>>>>>>>>>    Procedure Show_Date_Format
79058>>>>>>>>>        Integer iDateFormat
79058>>>>>>>>>        String sDateFormat
79058>>>>>>>>>
79058>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
79061>>>>>>>>>        Case Begin
79061>>>>>>>>>            Case (iDateFormat = DF_DATE_USA)
79063>>>>>>>>>                Move C_$USA To sDateFormat
79064>>>>>>>>>                Case Break
79065>>>>>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
79068>>>>>>>>>                Move C_$European To sDateFormat
79069>>>>>>>>>                Case Break
79070>>>>>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
79073>>>>>>>>>                Move C_$Military To sDateFormat
79074>>>>>>>>>                Case Break
79075>>>>>>>>>            Case Else
79075>>>>>>>>>                Move C_$UnknownDateType To sDateFormat
79076>>>>>>>>>                Case Break
79077>>>>>>>>>        Case End
79077>>>>>>>>>
79077>>>>>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
79078>>>>>>>>>    End_Procedure
79079>>>>>>>>>
79079>>>>>>>>>    // 2013-08-14 NGS
79079>>>>>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
79079>>>>>>>>>    Procedure Show_Systemresources
79081>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
79081>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
79081>>>>>>>>>        Integer iRetval
79081>>>>>>>>>        Number nValue
79081>>>>>>>>>        String sValue
79081>>>>>>>>>
79081>>>>>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
79082>>>>>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
79083>>>>>>>>>        If (iRetval = 0) Begin
79085>>>>>>>>>            Move (ShowLastError ()) to iRetval
79086>>>>>>>>>            Procedure_Return
79087>>>>>>>>>        End
79087>>>>>>>>>>
79087>>>>>>>>>
79087>>>>>>>>>        Send AppendTextLn ""
79088>>>>>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
79089>>>>>>>>>
79089>>>>>>>>>        // Show memory in Gigabytes:
79089>>>>>>>>>        Move (nValue/1024/1024/1024) to nValue
79090>>>>>>>>>        Move (Round(nValue)) to nValue
79091>>>>>>>>>        Get FormatNumber nValue 2 to sValue
79092>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
79093>>>>>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
79094>>>>>>>>>
79094>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
79094>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
79095>>>>>>>>>        Move (Round(nValue)) to nValue
79096>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79097>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
79098>>>>>>>>>
79098>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
79098>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
79099>>>>>>>>>        Move (Round(nValue)) to nValue
79100>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79101>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
79102>>>>>>>>>
79102>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
79102>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
79103>>>>>>>>>        Move (Round(nValue)) to nValue
79104>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79105>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
79106>>>>>>>>>
79106>>>>>>>>>        // Add an empty row after the memory information:
79106>>>>>>>>>        Send AppendTextLn ""
79107>>>>>>>>>    End_Procedure
79108>>>>>>>>>
79108>>>>>>>>>    Procedure Show_Registration
79110>>>>>>>>>        String sRegName
79110>>>>>>>>>        Integer iSN iUsersMax iUserCount
79110>>>>>>>>>
79110>>>>>>>>>        Registration sRegName iSN
79111>>>>>>>>>>
79111>>>>>>>>>        Get_Licensed_Max_Users to iUsersMax
79112>>>>>>>>>        Get_Current_User_Count to iUserCount
79113>>>>>>>>>
79113>>>>>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
79114>>>>>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
79115>>>>>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
79116>>>>>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
79117>>>>>>>>>    End_Procedure
79118>>>>>>>>>
79118>>>>>>>>>    //****************************************************************************
79118>>>>>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
79118>>>>>>>>>    // To the workspace object passing the an object and message To send back
79118>>>>>>>>>    // To this object. It is expected that the workspace object will send this
79118>>>>>>>>>    // message for every line Of information it wants displayed (passing the
79118>>>>>>>>>    // information To be displayed
79118>>>>>>>>>    //****************************************************************************
79118>>>>>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
79118>>>>>>>>>
79118>>>>>>>>>    Procedure Show_ServicePack
79120>>>>>>>>>        String sKey sVersion sDataFlex
79120>>>>>>>>>        Handle hoRegistry
79120>>>>>>>>>        Boolean bExists bOpened
79120>>>>>>>>>
79120>>>>>>>>>        Move "DataFlex"        to sDataFlex
79121>>>>>>>>>
79121>>>>>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
79122>>>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
79123>>>>>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
79124>>>>>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
79125>>>>>>>>>
79125>>>>>>>>>        If (bExists) Begin
79127>>>>>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79128>>>>>>>>>        End
79128>>>>>>>>>>
79128>>>>>>>>>        Else Begin
79129>>>>>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79130>>>>>>>>>        End
79130>>>>>>>>>>
79130>>>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
79131>>>>>>>>>        If (bExists) Begin
79133>>>>>>>>>            Get OpenKey of hoRegistry sKey to bOpened
79134>>>>>>>>>            If (bOpened) Begin
79136>>>>>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
79137>>>>>>>>>                If (bExists) Begin
79139>>>>>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
79140>>>>>>>>>                End
79140>>>>>>>>>>
79140>>>>>>>>>                Send CloseKey of hoRegistry
79141>>>>>>>>>            End
79141>>>>>>>>>>
79141>>>>>>>>>        End
79141>>>>>>>>>>
79141>>>>>>>>>        Send Destroy of hoRegistry
79142>>>>>>>>>
79142>>>>>>>>>        If (sVersion <> "") Begin
79144>>>>>>>>>           Send AppendTextLn sVersion
79145>>>>>>>>>           Send AppendTextLn ""
79146>>>>>>>>>        End
79146>>>>>>>>>>
79146>>>>>>>>>    End_Procedure
79147>>>>>>>>>
79147>>>>>>>>>    Procedure Show_WorkspaceInformation
79149>>>>>>>>>        Integer hoWorkspace
79149>>>>>>>>>
79149>>>>>>>>>        If (ghoApplication <> 0) Begin
79151>>>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
79152>>>>>>>>>            If (hoWorkspace <> 0) Begin
79154>>>>>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
79155>>>>>>>>>            End
79155>>>>>>>>>>
79155>>>>>>>>>        End
79155>>>>>>>>>>
79155>>>>>>>>>    End_Procedure
79156>>>>>>>>>
79156>>>>>>>>>    //****************************************************************************
79156>>>>>>>>>    // If connection ids are used, we will send the message EnumerateConnections
79156>>>>>>>>>    // to the connection manager object passing the an object and message to send
79156>>>>>>>>>    // back to this object. It is expected that the connection manager object will
79156>>>>>>>>>    // send this message for every line Of information it wants displayed (passing
79156>>>>>>>>>    // the information To be displayed
79156>>>>>>>>>    //****************************************************************************
79156>>>>>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
79156>>>>>>>>>
79156>>>>>>>>>    Procedure Show_ConnectionIdInformation
79158>>>>>>>>>        If (ghoConnection > 0) Begin
79160>>>>>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
79161>>>>>>>>>            Send AppendTextLn ""
79162>>>>>>>>>        End
79162>>>>>>>>>>
79162>>>>>>>>>    End_Procedure
79163>>>>>>>>>
79163>>>>>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
79165>>>>>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
79166>>>>>>>>>    End_Function
79167>>>>>>>>>
79167>>>>>>>>>    Procedure Show_Versions
79169>>>>>>>>>        Integer iVersion iRevision iBuild
79169>>>>>>>>>
79169>>>>>>>>>        Version_information iVersion iRevision iBuild
79171>>>>>>>>>
79171>>>>>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
79172>>>>>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
79173>>>>>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
79174>>>>>>>>>        Send AppendTextLn "This is a 64-bit exe file"
79175>>>>>>>>>    End_Procedure
79176>>>>>>>>>
79176>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
79178>>>>>>>>>        Boolean bOK
79178>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
79179>>>>>>>>>        Function_Return bOK
79180>>>>>>>>>    End_Function
79181>>>>>>>>>
79181>>>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
79183>>>>>>>>>        Boolean bOK
79183>>>>>>>>>        Function_Return bOK
79184>>>>>>>>>    End_Function
79185>>>>>>>>>
79185>>>>>>>>>    //***
79185>>>>>>>>>    //*** BW
79185>>>>>>>>>    //*** Procedure: Show_Drivers
79185>>>>>>>>>    //*** Purpose  : Show loaded database drivers
79185>>>>>>>>>    //***
79185>>>>>>>>>
79185>>>>>>>>>    Procedure Show_Drivers
79187>>>>>>>>>        String sDriverID sVersion sClient sValue
79187>>>>>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
79187>>>>>>>>>        Handle hoCLIHandler hoBtrvHandler
79187>>>>>>>>>        Boolean bStudioLicense bIsDAWDriver bIsMertechDriver
79187>>>>>>>>>
79187>>>>>>>>>        Move False to bStudioLicense
79188>>>>>>>>>
79188>>>>>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
79189>>>>>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
79190>>>>>>>>>
79190>>>>>>>>>        // For testing purposes:
79190>>>>>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79190>>>>>>>>>//        Load_Driver MSSQLDRV_ID
79190>>>>>>>>>//        Load_Driver ODBC_DRV_ID
79190>>>>>>>>>//        Load_Driver DB2_DRV_ID
79190>>>>>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79190>>>>>>>>>//
79190>>>>>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
79190>>>>>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79190>>>>>>>>>//            Load_Driver SQLFLEX
79190>>>>>>>>>//            Load_Driver MDSPgSQL
79190>>>>>>>>>//            Load_Driver MDSMySQL
79190>>>>>>>>>//            Load_Driver ORAFLEX
79190>>>>>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79190>>>>>>>>>//        #ENDIF
79190>>>>>>>>>        Move False to Err
79191>>>>>>>>>
79191>>>>>>>>>        // Loop through all loaded drivers.
79191>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
79194>>>>>>>>>        If (iNumberOfDrivers > 1) Begin
79196>>>>>>>>>            Send AppendTextLn ""
79197>>>>>>>>>        End
79197>>>>>>>>>>
79197>>>>>>>>>        For iDriver from 1 to iNumberOfDrivers
79203>>>>>>>>>>
79203>>>>>>>>>            // For some weird reason it can happen that - when using Mertech drivers - that the driver index
79203>>>>>>>>>            // was increased in the CLI array, but it has no value. In that case a "Bad parameter..." error
79203>>>>>>>>>            // would be thrown, so we safeguard from that here.
79203>>>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
79204>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
79207>>>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
79208>>>>>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
79209>>>>>>>>>            Get IsMertechDriver sDriverID to bIsMertechDriver
79210>>>>>>>>>
79210>>>>>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True or bIsMertechDriver = True) Begin
79212>>>>>>>>>
79212>>>>>>>>>                // Pervasive/Btrieve database
79212>>>>>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
79214>>>>>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
79215>>>>>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
79216>>>>>>>>>                    If (sClient <> "0.0.0") Begin
79218>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
79219>>>>>>>>>                    End
79219>>>>>>>>>>
79219>>>>>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
79220>>>>>>>>>                    If (sClient <> "0.0.0") Begin
79222>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
79223>>>>>>>>>                    End
79223>>>>>>>>>>
79223>>>>>>>>>                End
79223>>>>>>>>>>
79223>>>>>>>>>
79223>>>>>>>>>                Else Begin
79224>>>>>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
79225>>>>>>>>>                    Move 0 to iNumServers
79226>>>>>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
79228>>>>>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
79231>>>>>>>>>                    End
79231>>>>>>>>>>
79231>>>>>>>>>
79231>>>>>>>>>                    If (bIsDAWDriver = True) Begin
79233>>>>>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
79235>>>>>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
79236>>>>>>>>>                        End
79236>>>>>>>>>>
79236>>>>>>>>>                        Get CKRevision of hoCLIHandler to sVersion
79237>>>>>>>>>                    End
79237>>>>>>>>>>
79237>>>>>>>>>
79237>>>>>>>>>                    If (bIsMertechDriver = True) Begin
79239>>>>>>>>>                    End
79239>>>>>>>>>>
79239>>>>>>>>>
79239>>>>>>>>>                    // If the serialnumber is = 0, it means that the
79239>>>>>>>>>                    // Studio licens is in use and there is no
79239>>>>>>>>>                    // number of max users defined because the driver is
79239>>>>>>>>>                    // relying on the info from the VDF license.
79239>>>>>>>>>                    If (bStudioLicense = False) Begin
79241>>>>>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
79242>>>>>>>>>                        Move (iSerialNo = 0) to bStudioLicense
79243>>>>>>>>>                    End
79243>>>>>>>>>>
79243>>>>>>>>>                End
79243>>>>>>>>>>
79243>>>>>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
79244>>>>>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
79246>>>>>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
79247>>>>>>>>>                End
79247>>>>>>>>>>
79247>>>>>>>>>                If (iNumServers <> 0) Begin
79249>>>>>>>>>                    For iCount from 1 to iNumServers
79255>>>>>>>>>>
79255>>>>>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
79258>>>>>>>>>                        If (not(sValue contains ";PWD=")) Begin
79260>>>>>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
79261>>>>>>>>>                        End
79261>>>>>>>>>>
79261>>>>>>>>>                    Loop
79262>>>>>>>>>>
79262>>>>>>>>>                End
79262>>>>>>>>>>
79262>>>>>>>>>            End
79262>>>>>>>>>>
79262>>>>>>>>>        Loop
79263>>>>>>>>>>
79263>>>>>>>>>
79263>>>>>>>>>        Send AppendTextLn ""
79264>>>>>>>>>        If (bStudioLicense = False) Begin
79266>>>>>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
79267>>>>>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
79268>>>>>>>>>        End
79268>>>>>>>>>>
79268>>>>>>>>>        Else Begin
79269>>>>>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
79270>>>>>>>>>        End
79270>>>>>>>>>>
79270>>>>>>>>>        Send Destroy of hoCLIHandler
79271>>>>>>>>>        Send Destroy of hoBtrvHandler
79272>>>>>>>>>    End_Procedure
79273>>>>>>>>>
79273>>>>>>>>>    Procedure Show_HelpFile
79275>>>>>>>>>        String sHelpFile
79275>>>>>>>>>        Integer eHelpType
79275>>>>>>>>>
79275>>>>>>>>>        If (ghoApplication <> 0) Begin
79277>>>>>>>>>            Get peHelpType Of ghoApplication To eHelpType
79278>>>>>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
79280>>>>>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
79281>>>>>>>>>            End
79281>>>>>>>>>>
79281>>>>>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
79284>>>>>>>>>                Get Help_filename Of Help_object_id To sHelpFile
79285>>>>>>>>>            End
79285>>>>>>>>>>
79285>>>>>>>>>            Else Begin
79286>>>>>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
79287>>>>>>>>>            End
79287>>>>>>>>>>
79287>>>>>>>>>
79287>>>>>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
79288>>>>>>>>>        End
79288>>>>>>>>>>
79288>>>>>>>>>    End_Procedure
79289>>>>>>>>>
79289>>>>>>>>>    Procedure Show_EnterAsTab
79291>>>>>>>>>        Boolean bEnterKeyAsTabKey
79291>>>>>>>>>        String sText
79291>>>>>>>>>
79291>>>>>>>>>        If (ghoApplication <> 0) Begin
79293>>>>>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
79294>>>>>>>>>            If (bEnterKeyAsTabKey) Begin
79296>>>>>>>>>                Move "True" To sText
79297>>>>>>>>>            End
79297>>>>>>>>>>
79297>>>>>>>>>            Else Begin
79298>>>>>>>>>                Move "False" To sText
79299>>>>>>>>>            End
79299>>>>>>>>>>
79299>>>>>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
79300>>>>>>>>>        End
79300>>>>>>>>>>
79300>>>>>>>>>    End_Procedure
79301>>>>>>>>>
79301>>>>>>>>>    //    During activation we will remove the old information and add the newly
79301>>>>>>>>>    //    found systeminformation
79301>>>>>>>>>    Procedure Add_Focus Integer hoRoot
79303>>>>>>>>>        Forward Send Add_Focus hoRoot
79305>>>>>>>>>
79305>>>>>>>>>        Send Delete_Data
79306>>>>>>>>>
79306>>>>>>>>>        Set Changed_State To False
79307>>>>>>>>>        Set Read_Only_State To True
79308>>>>>>>>>
79308>>>>>>>>>        Send Show_Registration
79309>>>>>>>>>        Send Show_Drivers
79310>>>>>>>>>        Send Show_ServicePack
79311>>>>>>>>>        Send Show_Versions
79312>>>>>>>>>        Send AppendTextLn ""
79313>>>>>>>>>
79313>>>>>>>>>        If (ghoApplication <> 0) Begin
79315>>>>>>>>>            Send Show_WorkSpaceInformation
79316>>>>>>>>>            Send Show_HelpFile
79317>>>>>>>>>            Send AppendTextLn ""
79318>>>>>>>>>        End
79318>>>>>>>>>>
79318>>>>>>>>>        Else Begin
79319>>>>>>>>>            Send AppendTextLn ""
79320>>>>>>>>>        End
79320>>>>>>>>>>
79320>>>>>>>>>
79320>>>>>>>>>        If (ghoConnection <> 0) Begin
79322>>>>>>>>>            Send Show_ConnectionIdInformation
79323>>>>>>>>>        End
79323>>>>>>>>>>
79323>>>>>>>>>
79323>>>>>>>>>        Send Show_Current_User
79324>>>>>>>>>        Send Show_Windows_Directory
79325>>>>>>>>>        Send Show_Current_Directory
79326>>>>>>>>>
79326>>>>>>>>>        // This is already shown in the workspace details,
79326>>>>>>>>>        // unless no workspace object is present:
79326>>>>>>>>>        If (ghoApplication = 0) Begin
79328>>>>>>>>>            Send Show_Filelist_Name
79329>>>>>>>>>        End
79329>>>>>>>>>>
79329>>>>>>>>>
79329>>>>>>>>>        If (ghoApplication <> 0) Begin
79331>>>>>>>>>            Send AppendTextLn ""
79332>>>>>>>>>            Send Show_EnterAsTab
79333>>>>>>>>>        End
79333>>>>>>>>>>
79333>>>>>>>>>
79333>>>>>>>>>        Send Show_Screen_Size
79334>>>>>>>>>        Send Show_Page_Size
79335>>>>>>>>>        Send Show_Number_Format
79336>>>>>>>>>        Send Show_Date_Format
79337>>>>>>>>>        Send Show_Lock_Delay
79338>>>>>>>>>        Send Show_Lock_Timeout
79339>>>>>>>>>        Send Show_Date
79340>>>>>>>>>        Send Show_Systemresources
79341>>>>>>>>>        Send Beginning_of_Data
79342>>>>>>>>>
79342>>>>>>>>>        Set Icon to 'default.ico'
79343>>>>>>>>>    End_Procedure
79344>>>>>>>>>End_Class
79345>>>>>>>>>
79345>>>>>>>>>Class SysInfoDialog is a ModalPanel
79346>>>>>>>>>    Procedure Construct_Object
79348>>>>>>>>>        Forward Send Construct_Object
79350>>>>>>>>>
79350>>>>>>>>>        Set Label to C_$SystemInformation
79351>>>>>>>>>        Set Size to 140 267
79352>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79353>>>>>>>>>        Set Border_Style to Border_Thick
79354>>>>>>>>>        Set Sysmenu_Icon to False
79355>>>>>>>>>
79355>>>>>>>>>        // "+1" will make the panel to paint correctly.
79355>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
79356>>>>>>>>>
79356>>>>>>>>>        // 2014-09-14 NGS
79356>>>>>>>>>        // Added a container object around the cTexteditor
79356>>>>>>>>>        // object to get a border around the text.
79356>>>>>>>>>        Object oSysinfoDisplayContainer is a Container3d
79358>>>>>>>>>            Set Location to 2 4
79359>>>>>>>>>            Set Size to 110 255
79360>>>>>>>>>            Set Border_Style to Border_ClientEdge
79361>>>>>>>>>            Set Color to clWhite
79362>>>>>>>>>            Set peAnchors to anAll
79363>>>>>>>>>
79363>>>>>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
79365>>>>>>>>>            End_Object
79366>>>>>>>>>
79366>>>>>>>>>        End_Object
79367>>>>>>>>>
79367>>>>>>>>>        Object oCloseButton is a Button
79369>>>>>>>>>            Set Label to C_$Close
79370>>>>>>>>>            Set Location to 120 210
79371>>>>>>>>>            Set Message item 0 to msg_Close_Panel
79372>>>>>>>>>            Set Default_State To True
79373>>>>>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
79373>>>>>>>>>            // and changes its peAnchors, we might as well prepare this object
79373>>>>>>>>>            // for that situation.
79373>>>>>>>>>            Set peAnchors to anBottomRight
79374>>>>>>>>>        End_Object
79375>>>>>>>>>
79375>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79377>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79378>>>>>>>>>            Set Size to 14 50
79379>>>>>>>>>            Set Location to 120 158
79380>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79380>>>>>>>>>            // we might as well prepare the object for it.
79380>>>>>>>>>            Set peAnchors to anBottomRight
79381>>>>>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
79382>>>>>>>>>        End_Object
79383>>>>>>>>>
79383>>>>>>>>>        On_Key kCancel Send Close_Panel
79384>>>>>>>>>    End_Procedure
79385>>>>>>>>>
79385>>>>>>>>>    Procedure Page Integer iPageObject
79387>>>>>>>>>        Handle hMenu
79387>>>>>>>>>        Integer iPrevState
79387>>>>>>>>>
79387>>>>>>>>>        Forward Send Page iPageObject
79389>>>>>>>>>
79389>>>>>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
79389>>>>>>>>>        //
79389>>>>>>>>>    End_Procedure
79390>>>>>>>>>
79390>>>>>>>>>End_Class
79391>>>>>>>>>
79391>>>>>>>>>Class cAboutEdit is an cRichEdit
79392>>>>>>>>>    Procedure Construct_Object
79394>>>>>>>>>        Forward Send Construct_Object
79396>>>>>>>>>
79396>>>>>>>>>        Property String psContentText
79397>>>>>>>>>
79397>>>>>>>>>        Set Size to 77 153
79398>>>>>>>>>        Set Location to 8 60
79399>>>>>>>>>        Set Read_Only_State to True
79400>>>>>>>>>        Set Skip_State to True
79401>>>>>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
79401>>>>>>>>>        // or 1/20 of a printer's point.
79401>>>>>>>>>        Set piRightMargin to (0.1 * 1440)
79402>>>>>>>>>        Set Border_Style  to Border_None
79403>>>>>>>>>    End_Procedure
79404>>>>>>>>>
79404>>>>>>>>>    // Adds a line of text to the edit object
79404>>>>>>>>>    Procedure Add_Line String sText
79406>>>>>>>>>        String sContentText
79406>>>>>>>>>        Get psContentText to sContentText
79407>>>>>>>>>        Move (sContentText + String(sText)) to sContentText
79408>>>>>>>>>        Set psContentText to sContentText
79409>>>>>>>>>    End_Procedure
79410>>>>>>>>>
79410>>>>>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
79410>>>>>>>>>    // Note that we use a property psContentText and add to it,
79410>>>>>>>>>    // because the object isn't paged yet when we add these
79410>>>>>>>>>    // values and the COM edit object needs to be paged
79410>>>>>>>>>    // for the text to become visible. See Also: Procedure Page below.
79410>>>>>>>>>    Procedure Add_LineLn String sText
79412>>>>>>>>>        String sContentText sCR
79412>>>>>>>>>
79412>>>>>>>>>        Move (Character(10) + String(Character(13))) to sCR
79413>>>>>>>>>        Get psContentText to sContentText
79414>>>>>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
79415>>>>>>>>>        Set psContentText to sContentText
79416>>>>>>>>>    End_Procedure
79417>>>>>>>>>
79417>>>>>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
79419>>>>>>>>>        String sLinkText
79419>>>>>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
79420>>>>>>>>>        Send Show_HomePage sLinkText
79421>>>>>>>>>    End_Procedure
79422>>>>>>>>>
79422>>>>>>>>>    Procedure Page Integer iPageObject
79424>>>>>>>>>        String sContentText
79424>>>>>>>>>
79424>>>>>>>>>        Forward Send Page iPageObject
79426>>>>>>>>>        Get psContentText to sContentText
79427>>>>>>>>>        Send AppendText sContentText
79428>>>>>>>>>        send Beginning_of_Data
79429>>>>>>>>>    End_Procedure
79430>>>>>>>>>
79430>>>>>>>>>End_Class
79431>>>>>>>>>
79431>>>>>>>>>Class AboutDialog is a ModalPanel
79432>>>>>>>>>    Procedure Construct_Object
79434>>>>>>>>>
79434>>>>>>>>>        Forward Send Construct_Object
79436>>>>>>>>>
79436>>>>>>>>>        Set Label to C_$About
79437>>>>>>>>>        Set Size to 118 230
79438>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79439>>>>>>>>>        Set Border_Style to Border_Thick
79440>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
79441>>>>>>>>>
79441>>>>>>>>>        Object oSysInfoDialog is a SysInfoDialog
79443>>>>>>>>>        End_Object
79444>>>>>>>>>
79444>>>>>>>>>        Object oBox is a Container3d
79446>>>>>>>>>            Set Border_Style to Border_Normal
79447>>>>>>>>>            Set Size to 90 220
79448>>>>>>>>>            Set Location to 4 5
79449>>>>>>>>>            Set Color to clWhite
79450>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79450>>>>>>>>>            // we might as well prepare the object for it.
79450>>>>>>>>>            Set peAnchors to anAll
79451>>>>>>>>>
79451>>>>>>>>>            Object oAboutGraphic is a BitmapContainer
79453>>>>>>>>>                Set Border_Style To Border_None
79454>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
79455>>>>>>>>>                Set Color to clWhite
79456>>>>>>>>>                Set Size to 45 50
79457>>>>>>>>>                Set Location to 0 3
79458>>>>>>>>>            End_Object
79459>>>>>>>>>
79459>>>>>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
79461>>>>>>>>>                Set Border_Style to Border_None
79462>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
79463>>>>>>>>>                Set Color to clWhite
79464>>>>>>>>>                Set Size to 30 55
79465>>>>>>>>>                Set Location to 50 3
79466>>>>>>>>>            End_Object
79467>>>>>>>>>
79467>>>>>>>>>            Object oInfoList_Editor is an cAboutEdit
79469>>>>>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
79469>>>>>>>>>                // we might as well prepare the object for it.
79469>>>>>>>>>                Set peAnchors to anAll
79470>>>>>>>>>            End_Object
79471>>>>>>>>>
79471>>>>>>>>>            // These objects are here for backwards compatability only.
79471>>>>>>>>>            // They are not used.
79471>>>>>>>>>            Object oProductName is a TextBox
79473>>>>>>>>>                Set Label To C_$ProductName
79474>>>>>>>>>                Set Size To 10 45
79475>>>>>>>>>                Set Location To 8 53
79476>>>>>>>>>                Set Visible_State to False
79477>>>>>>>>>                Set Focus_Mode to NonFocusable
79478>>>>>>>>>            End_Object
79479>>>>>>>>>
79479>>>>>>>>>            Object oVersion is a TextBox
79481>>>>>>>>>                Set Label To C_$Version
79482>>>>>>>>>                Set Size To 10 25
79483>>>>>>>>>                Set Location To 21 53
79484>>>>>>>>>                Set Visible_State to False
79485>>>>>>>>>                Set Focus_Mode to NonFocusable
79486>>>>>>>>>            End_Object
79487>>>>>>>>>
79487>>>>>>>>>            Object oCopyright is a TextBox
79489>>>>>>>>>                Set Label To C_$Copyright
79490>>>>>>>>>                Set Size To 10 31
79491>>>>>>>>>                Set Location To 34 53
79492>>>>>>>>>                Set Visible_State to False
79493>>>>>>>>>                Set Focus_Mode to NonFocusable
79494>>>>>>>>>            End_Object
79495>>>>>>>>>
79495>>>>>>>>>            Object oAuthor is a TextBox
79497>>>>>>>>>                Set Label To C_$Author
79498>>>>>>>>>                Set Size To 10 22
79499>>>>>>>>>                Set Location To 46 53
79500>>>>>>>>>                Set Visible_State to False
79501>>>>>>>>>                Set Focus_Mode to NonFocusable
79502>>>>>>>>>            End_Object
79503>>>>>>>>>
79503>>>>>>>>>        End_Object
79504>>>>>>>>>
79504>>>>>>>>>        Object oOKButton is a Button
79506>>>>>>>>>            On_Item C_$Close Send Close_Panel
79507>>>>>>>>>            Set Location to 98 176
79508>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79508>>>>>>>>>            // we might as well prepare the object for it.
79508>>>>>>>>>            Set peAnchors to anBottomRight
79509>>>>>>>>>        End_Object
79510>>>>>>>>>
79510>>>>>>>>>        Object oSysInfoButton is a Button
79512>>>>>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
79513>>>>>>>>>            Set Location to 98 123
79514>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79514>>>>>>>>>            // we might as well prepare the object for it.
79514>>>>>>>>>            Set peAnchors to anBottomRight
79515>>>>>>>>>        End_Object
79516>>>>>>>>>
79516>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79518>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79519>>>>>>>>>            Set Size to 14 50
79520>>>>>>>>>            Set Location to 98 70
79521>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79521>>>>>>>>>            // we might as well prepare the object for it.
79521>>>>>>>>>            Set peAnchors to anBottomRight
79522>>>>>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
79523>>>>>>>>>        End_Object
79524>>>>>>>>>
79524>>>>>>>>>        On_Key Kcancel Send KeyAction of oOKButton
79525>>>>>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
79526>>>>>>>>>        Set LogoDF to "DF32.bmp"
79527>>>>>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
79527>>>>>>>>>    End_Procedure
79528>>>>>>>>>
79528>>>>>>>>>    Procedure Page Integer iPageObject
79530>>>>>>>>>        Handle hMenu
79530>>>>>>>>>        Integer iPrevState
79530>>>>>>>>>
79530>>>>>>>>>        Forward Send Page iPageObject
79532>>>>>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
79532>>>>>>>>>        Set Icon to "Default.ico"
79533>>>>>>>>>
79533>>>>>>>>>        // Shadow upper left corner menu items: (icon menu items)
79533>>>>>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
79534>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79535>>>>>>>>>        // The "Move" menu command may come in handy to have.
79535>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79535>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79536>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79537>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79538>>>>>>>>>        // The "Close" menu command may be good to have.
79538>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79538>>>>>>>>>    End_Procedure
79539>>>>>>>>>
79539>>>>>>>>>    Procedure Set ProductName String sText
79541>>>>>>>>>        Set Value of oProductName to sText
79542>>>>>>>>>    End_Procedure
79543>>>>>>>>>
79543>>>>>>>>>    Procedure Set Copyright String sText
79545>>>>>>>>>        Set Value of oCopyright to sText
79546>>>>>>>>>    End_Procedure
79547>>>>>>>>>
79547>>>>>>>>>    Procedure Set Author String sText
79549>>>>>>>>>        Set Value of oAuthor to sText
79550>>>>>>>>>    End_Procedure
79551>>>>>>>>>
79551>>>>>>>>>    Procedure Set Version String sVersion
79553>>>>>>>>>        Handle hoVersionInfo
79553>>>>>>>>>        Boolean bIncluded
79553>>>>>>>>>        Integer iMajor iMinor iRelease iBuild
79553>>>>>>>>>        Date dCompileDate
79553>>>>>>>>>        String sCertInfo
79553>>>>>>>>>
79553>>>>>>>>>        If (sVersion = "") Begin
79555>>>>>>>>>            // This automatically shows the program version of the program, if available.
79555>>>>>>>>>            // It will be displayed as the second item in the edit object.
79555>>>>>>>>>            If (ghoApplication <> 0) Begin
79557>>>>>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
79558>>>>>>>>>                If (hoVersionInfo <> 0) Begin
79560>>>>>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
79561>>>>>>>>>                    If (bIncluded) Begin
79563>>>>>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
79564>>>>>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
79565>>>>>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
79566>>>>>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
79567>>>>>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
79568>>>>>>>>>                    End
79568>>>>>>>>>>
79568>>>>>>>>>                End
79568>>>>>>>>>>
79568>>>>>>>>>            End
79568>>>>>>>>>>
79568>>>>>>>>>        End
79568>>>>>>>>>>
79568>>>>>>>>>
79568>>>>>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
79568>>>>>>>>>        Get GetCompileDate to dCompileDate
79569>>>>>>>>>        If (sVersion <> "") Begin
79571>>>>>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
79572>>>>>>>>>        End
79572>>>>>>>>>>
79572>>>>>>>>>
79572>>>>>>>>>        Get IsProgramDigitallySigned to sCertInfo
79573>>>>>>>>>        If (sCertInfo <> "-1") Begin
79575>>>>>>>>>            If (sCertInfo <> "") Begin
79577>>>>>>>>>                Send Add_LineLn sCertInfo
79578>>>>>>>>>            End
79578>>>>>>>>>>
79578>>>>>>>>>            Else Begin
79579>>>>>>>>>                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
79580>>>>>>>>>            End
79580>>>>>>>>>>
79580>>>>>>>>>        End
79580>>>>>>>>>>
79580>>>>>>>>>    End_Procedure
79581>>>>>>>>>
79581>>>>>>>>>    Function IsDate Desktop String sDate Returns Boolean
79583>>>>>>>>>        Boolean bIsDate
79583>>>>>>>>>        String sGoodCharacters sChar
79583>>>>>>>>>        Integer iCount iLength
79583>>>>>>>>>
79583>>>>>>>>>        Move True to bIsDate
79584>>>>>>>>>        Move "0123456789-/" to sGoodCharacters
79585>>>>>>>>>        Move (Length(sDate)) to iLength
79586>>>>>>>>>        For iCount from 1 to iLength
79592>>>>>>>>>>
79592>>>>>>>>>            Move (Left(sDate, 1)) to sChar
79593>>>>>>>>>            Move (Mid(sDate, 12, 2)) to sDate
79594>>>>>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
79595>>>>>>>>>            If (bIsDate = False) Begin
79597>>>>>>>>>                Move iLength to iCount
79598>>>>>>>>>            End
79598>>>>>>>>>>
79598>>>>>>>>>        Loop
79599>>>>>>>>>>
79599>>>>>>>>>        Function_Return bIsDate
79600>>>>>>>>>    End_Function
79601>>>>>>>>>
79601>>>>>>>>>    Function GetCompileDate Returns Date
79603>>>>>>>>>        Date dCompileDate
79603>>>>>>>>>        String sAppFilename sProgram sData sCompileDate
79603>>>>>>>>>        Integer iChannel iPos iDateFormat iCount iSize
79603>>>>>>>>>        Boolean bIsValid
79603>>>>>>>>>
79603>>>>>>>>>        Move 0 to dCompileDate
79604>>>>>>>>>        // Get full path to the current running executable
79604>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
79605>>>>>>>>>        Get GetApplicationName     of ghoApplication to sProgram
79606>>>>>>>>>
79606>>>>>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
79606>>>>>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
79607>>>>>>>>>
79607>>>>>>>>>        Get_Argument_Size to iSize
79608>>>>>>>>>        Read_Block channel iChannel sData 15000000   // This must be big enough to reach the compile date location
79610>>>>>>>>>        Move (Pos(sProgram,sData)) to iPos
79611>>>>>>>>>        If (iPos > 0) Begin
79613>>>>>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
79613>>>>>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
79614>>>>>>>>>
79614>>>>>>>>>            // If the current date format is non US, we need to temporary
79614>>>>>>>>>            // change the format and then move the string to the date variable.
79614>>>>>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
79617>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
79620>>>>>>>>>            Move (Date(sCompileDate))    to dCompileDate
79621>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
79624>>>>>>>>>        End
79624>>>>>>>>>>
79624>>>>>>>>>//        Else Begin
79624>>>>>>>>>//            Error DFERR_PROGRAM "Compile Date location in .exe not found"
79624>>>>>>>>>//        End
79624>>>>>>>>>
79624>>>>>>>>>        Send Seq_Close_Channel iChannel
79625>>>>>>>>>//        Read_Block channel iChannel sData (8 * 1024)    // First 8K is .exe header skip it
79625>>>>>>>>>//        Read_Block channel iChannel sData 75            // The compile information we're interested in
79625>>>>>>>>>
79625>>>>>>>>>        // The data is padded with Character(0)s. Strip them out
79625>>>>>>>>>//        Move (CString(sData)) to sData
79625>>>>>>>>>
79625>>>>>>>>>        // The compile date is after the first ", ", so string parsing is required
79625>>>>>>>>>//        Move (Pos(", ", sData)) to iPos
79625>>>>>>>>>//        Move (Mid(sData, 10, (iPos + 2) ))  to sCompileDate // In US format
79625>>>>>>>>>        // If the current date format is non US, we need to temporary
79625>>>>>>>>>        // change the format and then move the string to the date variable.
79625>>>>>>>>>//        Get_Attribute DF_DATE_FORMAT        to iDateFormat
79625>>>>>>>>>//        Set_Attribute DF_DATE_FORMAT        to DF_DATE_USA
79625>>>>>>>>>//
79625>>>>>>>>>//        // Note the build in IsDateValid can return the wrong result
79625>>>>>>>>>//        // when controls characters are part of the sCompileDate.
79625>>>>>>>>>//        Get IsDate sCompileDate))           to bIsValid
79625>>>>>>>>>//        If (bIsValid = True) Begin
79625>>>>>>>>>//            Move (Date(sCompileDate))       to dCompileDate
79625>>>>>>>>>//        End
79625>>>>>>>>>//
79625>>>>>>>>>//        // As of DataFlex 19.1 the header has changed; and so has the compile date location.
79625>>>>>>>>>//        // It seems to me that the position for the compilation date can vary. So we read line-by-line
79625>>>>>>>>>//        // until we encounter the program name that appears just in front of the compile date.
79625>>>>>>>>>//        // Although I'm not sure about if/how the position varies, the below seems to work just fine.
79625>>>>>>>>>//        If (dCompileDate = 0) Begin
79625>>>>>>>>>//            Move "" to sCompileDate
79625>>>>>>>>>//            Move 30000 to iSize
79625>>>>>>>>>//            For iCount from 1 to iSize
79625>>>>>>>>>//                Readln channel iChannel sData
79625>>>>>>>>>//                Move (Pos(sProgram, sData)) to iPos
79625>>>>>>>>>//                If (iPos <> 0) Begin
79625>>>>>>>>>//                    Move (Mid(sData, 10, (iPos + (Length(sProgram) + 2)))) to sCompileDate
79625>>>>>>>>>//                    Move (Trim(sCompileDate)) to sCompileDate
79625>>>>>>>>>//                    Move iSize to iCount // We're out of here.
79625>>>>>>>>>//                End
79625>>>>>>>>>//            Loop
79625>>>>>>>>>//            If (Left(sCompileDate, 1) = "0") Begin
79625>>>>>>>>>//                Move ("1" + String(sCompileDate)) to sCompileDate
79625>>>>>>>>>//            End
79625>>>>>>>>>//            Get IsDate sCompileDate)) to bIsValid
79625>>>>>>>>>//            If (bIsValid = True) Begin
79625>>>>>>>>>//                Move (Date(sCompileDate)) to dCompileDate
79625>>>>>>>>>//            End
79625>>>>>>>>>//        End
79625>>>>>>>>>//        Send Seq_Close_Channel iChannel
79625>>>>>>>>>//        Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
79625>>>>>>>>>
79625>>>>>>>>>        Function_Return dCompileDate
79626>>>>>>>>>    End_Function
79627>>>>>>>>>
79627>>>>>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
79627>>>>>>>>>    // (the passed program), has been finished
79627>>>>>>>>>    // The DOS box does also _not_ flash briefly.
79627>>>>>>>>>    Procedure RunProgramWait String sProgram String sParameter
79629>>>>>>>>>        Handle hProcess
79629>>>>>>>>>        Integer iVoid
79629>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79629>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79629>>>>>>>>>
79629>>>>>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
79630>>>>>>>>>
79630>>>>>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
79631>>>>>>>>>        Move SW_SHOW                 to sInfo.nShow
79632>>>>>>>>>
79632>>>>>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
79633>>>>>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
79634>>>>>>>>>        // This will "hide" the DOS box from showing (no flasing box):
79634>>>>>>>>>        Move 0                       to sInfo.nShow
79635>>>>>>>>>
79635>>>>>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
79636>>>>>>>>>        Move sInfo.hProcess to hProcess
79637>>>>>>>>>        If (hProcess) Begin
79639>>>>>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
79640>>>>>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
79641>>>>>>>>>        End
79641>>>>>>>>>>
79641>>>>>>>>>    End_Procedure
79642>>>>>>>>>
79642>>>>>>>>>    Function AddFolderDelimiter String sPath Returns String
79644>>>>>>>>>        String sDirSep
79644>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
79645>>>>>>>>>        Move (Trim(sPath)) to sPath
79646>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
79648>>>>>>>>>            Move (sPath + sDirSep) to sPath
79649>>>>>>>>>        End
79649>>>>>>>>>>
79649>>>>>>>>>        Function_Return sPath
79650>>>>>>>>>    End_Function
79651>>>>>>>>>
79651>>>>>>>>>    // Returns an empty string if the current program is not digitally signed,
79651>>>>>>>>>    // or there is a problem with the certificate.
79651>>>>>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
79651>>>>>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
79651>>>>>>>>>    Function IsProgramDigitallySigned Returns String
79653>>>>>>>>>        Boolean bExists
79653>>>>>>>>>        String sPath sProgram sParams sRetval
79653>>>>>>>>>        Integer iCh
79653>>>>>>>>>
79653>>>>>>>>>        Move "" to sRetval
79654>>>>>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
79655>>>>>>>>>        Get AddFolderDelimiter sPath to sPath
79656>>>>>>>>>        File_Exist (sPath + CS_SignProgram) bExists
79657>>>>>>>>>        If (bExists = False) Begin
79659>>>>>>>>>            Function_Return "-1"
79660>>>>>>>>>        End
79660>>>>>>>>>>
79660>>>>>>>>>
79660>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
79661>>>>>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
79662>>>>>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
79663>>>>>>>>>        Move (sParams * String("| clip"))    to sParams
79664>>>>>>>>>        Get Seq_New_Channel to iCh
79665>>>>>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
79667>>>>>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
79670>>>>>>>>>        Close_Output channel iCh
79672>>>>>>>>>        // New ShellExecute based message that waits for the passed process to end.
79672>>>>>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
79673>>>>>>>>>        Direct_Input channel iCh "CLIPBOARD:"
79675>>>>>>>>>            Readln channel iCh sRetval
79677>>>>>>>>>            Readln channel iCh sRetval
79679>>>>>>>>>            Readln channel iCh sRetval
79681>>>>>>>>>            Readln channel iCh sRetval
79683>>>>>>>>>        Close_Input channel iCh
79685>>>>>>>>>        Send Seq_Release_Channel iCh
79686>>>>>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
79688>>>>>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
79689>>>>>>>>>        End
79689>>>>>>>>>>
79689>>>>>>>>>        Else Begin
79690>>>>>>>>>            Move "" to sRetval
79691>>>>>>>>>        End
79691>>>>>>>>>>
79691>>>>>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
79691>>>>>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
79692>>>>>>>>>>
79692>>>>>>>>>        Function_Return sRetval
79693>>>>>>>>>    End_Function
79694>>>>>>>>>
79694>>>>>>>>>    Procedure Add_LineLn String sValue
79696>>>>>>>>>        Send Add_LineLn of oInfoList_Editor sValue
79697>>>>>>>>>    End_Procedure
79698>>>>>>>>>
79698>>>>>>>>>    Procedure Add_Line String sValue
79700>>>>>>>>>        Send Add_Line of oInfoList_Editor sValue
79701>>>>>>>>>    End_Procedure
79702>>>>>>>>>
79702>>>>>>>>>    Procedure Set Logo string sLogo
79704>>>>>>>>>        // Square bitmaps of 80x80 work best
79704>>>>>>>>>        Set Bitmap of oAboutGraphic to sLogo
79705>>>>>>>>>    End_Procedure
79706>>>>>>>>>
79706>>>>>>>>>    Procedure Set LogoDF String sLogo
79708>>>>>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
79709>>>>>>>>>    End_Procedure
79710>>>>>>>>>
79710>>>>>>>>>    Procedure Show_Sysinfo
79712>>>>>>>>>        Send Popup_Modal of oSysinfoDialog
79713>>>>>>>>>    End_Procedure
79714>>>>>>>>>
79714>>>>>>>>>    Procedure Show_HomePage String sWebpage
79716>>>>>>>>>        Handle hWnd
79716>>>>>>>>>        Get Window_Handle to hWnd
79717>>>>>>>>>        Runprogram Shell Background (Trim(sWebpage))
79718>>>>>>>>>    End_Procedure
79719>>>>>>>>>
79719>>>>>>>>>End_Class
79720>>>>>>>
79720>>>>>>>// Martin Moleman on SQL Server and DateTime2 (Don't use DataTime any longer !)
79720>>>>>>>// One remark about your change: I would not change to datetime2(7) (7 decimals) but to
79720>>>>>>>// datetime2(3) (3 decimals = milliseconds) or If you don't need the milliseconds datetime2(0).
79720>>>>>>>// The reason is that the DataFlex DateTime type only allows 3 decimals. When using 7
79720>>>>>>>// decimals you may Get truncation that again may cause problems with finding.
79720>>>>>>>//
79720>>>>>>>// Important! The conversion from DateTime to Date or datetime2 will also convert all dummy zero Date values from 1753-01-01 to 0001-01-01.
79720>>>>>>>// This is important to realize. The conversion will actually change the data in the database (done by the driver)
79720>>>>>>>
79720>>>>>>>
79720>>>>>>>// DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA
79720>>>>>>>// Determines for all DataFlex data types, which SQL native types willbe used when creating new columns.
79720>>>>>>>// Set_Attribute DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA of {driverNumber} {databaseHandle} ;
79720>>>>>>>// to {MAP_DF_TO_SQL_TYPE_SQL2000|MAP_DF_TO_SQL_TYPE_SQL2005|MAP_DF_TO_SQL_TYPE_SQL2008|MAP_DF_TO_SQL_TYPE_SQL2012}
79720>>>>>>>//
79720>>>>>>>
79720>>>>>>>Class cDbUpdateFunctionLibrary is a cObject
79721>>>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
79722>>>>>>>>
79722>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
79724>>>>>>>>    Integer iStart iEnd
79724>>>>>>>>    String sRetval
79724>>>>>>>>
79724>>>>>>>>    Move (Trim(sConnect)) to sConnect
79725>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
79726>>>>>>>>    If (iStart = 0) Begin
79728>>>>>>>>        Function_Return ""
79729>>>>>>>>    End
79729>>>>>>>>>
79729>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
79730>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
79731>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
79733>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
79734>>>>>>>>    End
79734>>>>>>>>>
79734>>>>>>>>    Else Begin
79735>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
79736>>>>>>>>    End
79736>>>>>>>>>
79736>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
79738>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
79739>>>>>>>>        Decrement iEnd
79740>>>>>>>>    End
79740>>>>>>>>>
79740>>>>>>>>    If (iEnd <> 0) Begin
79742>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
79743>>>>>>>>    End
79743>>>>>>>>>
79743>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
79744>>>>>>>>
79744>>>>>>>>    Function_Return (Trim(sRetval))
79745>>>>>>>>End_Function
79746>>>>>>>>
79746>>>>>>>>
79746>>>>>>>
79746>>>>>>>    Procedure Construct_Object
79748>>>>>>>        Handle ho
79748>>>>>>>        Forward Send Construct_Object
79750>>>>>>>
79750>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
79751>>>>>>>
79751>>>>>>>        Send CreateDbUpdateLibraryProperties
79752>>>>>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
79752>>>>>>>        // we will create one as it is used for all ConnectionID, ConnectionString
79752>>>>>>>        // etc settings.
79752>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
79754>>>>>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
79755>>>>>>>            Set phoSQLConnectionHandler to ho
79756>>>>>>>        End   
79756>>>>>>>>
79756>>>>>>>        
79756>>>>>>>        Property String private.psCollation "Latin1_General_CS_AS"
79757>>>>>>>
79757>>>>>>>    End_Procedure
79758>>>>>>>
79758>>>>>>>    Procedure End_Construct_Object
79760>>>>>>>        Forward Send End_Construct_Object
79762>>>>>>>    End_Procedure
79763>>>>>>>
79763>>>>>>>    // *** SQL Messages for making changes to the SQL back-end ***
79763>>>>>>>    //
79763>>>>>>>    // * Dummy function for the Studio's Code Explorer *
79763>>>>>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
79765>>>>>>>        Function_Return False
79766>>>>>>>    End_Function
79767>>>>>>>
79767>>>>>>>    // Function for creating a new *Database*.
79767>>>>>>>    // Note: This is for creating SQL DATABASES - not tables!
79767>>>>>>>    // Returns True if successful.
79767>>>>>>>    // ToDo: Currently only works for MS-SQL...
79767>>>>>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
79769>>>>>>>        String sSQL sSQL1 sConnectionID sConnectionString
79769>>>>>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
79769>>>>>>>        Handle hConnection hStmt hoSQLManager
79769>>>>>>>        Integer iFetchResult iDbType
79769>>>>>>>        Boolean bOK bMertechDriver bExists
79769>>>>>>>
79769>>>>>>>        Get piDbType to iDbType
79770>>>>>>>//        If (iDbType <> EN_DbTypeMSSQL and sDriverID <> MDSMySQL and sDriverID <> MDSDB2 and sDriverID <> ODBC_DRV_ID) Begin
79770>>>>>>>        If (iDbType <> EN_DbTypeMSSQL and iDbType <> EN_DbTypeDB2 and iDbType <> EN_DbTypeMySQL and iDbType <> EN_DbTypePostgre) Begin
79772>>>>>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL, MySQL & PostGre and DB2 with Mertech drivers"
79773>>>>>>>>
79773>>>>>>>            Function_Return False
79774>>>>>>>        End
79774>>>>>>>>
79774>>>>>>>
79774>>>>>>>        Get SqlUtilCheckIfDatabaseExists sDatabase to bExists
79775>>>>>>>        If (bExists = True) Begin
79777>>>>>>>            Function_Return True
79778>>>>>>>        End
79778>>>>>>>>
79778>>>>>>>
79778>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
79779>>>>>>>        If (bMertechDriver = False) Begin
79781>>>>>>>            Get phoSQLManager to hoSQLManager
79782>>>>>>>        End
79782>>>>>>>>
79782>>>>>>>        Else Begin
79783>>>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
79784>>>>>>>        End
79784>>>>>>>>
79784>>>>>>>
79784>>>>>>>        Get psConnectionID     to sConnectionID
79785>>>>>>>        Get psConnectionString to sConnectionString
79786>>>>>>>        Move 0 to LastErr
79787>>>>>>>
79787>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
79789>>>>>>>            // If an ODBC data source (DSN) we cannot pass the UID & PWD; so strip them from the connection string.
79789>>>>>>>            // ToDo: 2018-08-11 I think this is wrong and the uid & pw should be there.
79789>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
79789>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
79789>>>>>>>//                If (iPos > 0) Begin
79789>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
79789>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
79789>>>>>>>//                End
79789>>>>>>>//            End
79789>>>>>>>        End
79789>>>>>>>>
79789>>>>>>>
79789>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
79790>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
79791>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
79792>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
79794>>>>>>>            Error DFERR_PROGRAM (CS_DUF_LoginToDbServerFailed + "\n" + sConnectionString)
79795>>>>>>>>
79795>>>>>>>            Function_Return False
79796>>>>>>>        End
79796>>>>>>>>
79796>>>>>>>
79796>>>>>>>        Get SqlOpen of hConnection to hStmt
79797>>>>>>>
79797>>>>>>>        If (hStmt = 0) Begin
79799>>>>>>>            Send SqlDisconnect of hoSQLManager
79800>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
79801>>>>>>>>
79801>>>>>>>            Function_Return False
79802>>>>>>>        End
79802>>>>>>>>
79802>>>>>>>
79802>>>>>>>        Get psCollation to sCollation
79803>>>>>>>
79803>>>>>>>        Case Begin
79803>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
79805>>>>>>>                Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
79806>>>>>>>                Get _SqlSelectFromWhereName to sSelectFromWhereName
79807>>>>>>>                Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
79808>>>>>>>
79808>>>>>>>                // Check if database exists
79808>>>>>>>                Send SqlExecDirect of hStmt sSQL
79809>>>>>>>                Get SqlFetch of hStmt to iFetchResult
79810>>>>>>>                Send SqlClose of hStmt
79811>>>>>>>                Send SqlDisconnect of hConnection
79812>>>>>>>                // If database already exists we're out of here!
79812>>>>>>>                // Note that we return True as this is not an error.
79812>>>>>>>                If (iFetchResult > 0) Begin
79814>>>>>>>                    Function_Return True
79815>>>>>>>                End
79815>>>>>>>>
79815>>>>>>>                // Database doesn't exist, create it.
79815>>>>>>>                If (iFetchResult = 0) Begin
79817>>>>>>>                    Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
79818>>>>>>>                    Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
79819>>>>>>>                    If (sCollation <> "") Begin
79821>>>>>>>                        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
79822>>>>>>>                        Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
79823>>>>>>>                    End
79823>>>>>>>>
79823>>>>>>>                    Send SqlUtilExecuteQuery sSQL1 sDriverID
79824>>>>>>>                    Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
79825>>>>>>>                    If (LastErr = CLIERR_GENERAL_ERROR) Begin
79827>>>>>>>                        Function_Return False
79828>>>>>>>                    End
79828>>>>>>>>
79828>>>>>>>                    // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
79828>>>>>>>                    Sleep 1
79829>>>>>>>                    Send SqlUtilExecuteQuery sSQL sDriverID
79830>>>>>>>                End
79830>>>>>>>>
79830>>>>>>>                Case Break
79831>>>>>>>
79831>>>>>>>            Case (sDriverID = MDSPgSQL)
79834>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreatePostgreSQLDatabase.sql as CreatePostgreSQLDatabase.sql
79834>>>>>>>                Get _SqlUtilCreatePostGreSQLDatabaseByScript "CreatePostgreSQLDatabase.sql" sDatabase to bOK
79835>>>>>>>                Case Break
79836>>>>>>>
79836>>>>>>>            Case (sDriverID = MDSMySQL or (iDbType = EN_DbTypeMySQL and sDriverID = ODBC_DRV_ID))
79839>>>>>>>                // ToDo: How should this be set/checked?
79839>>>>>>>//                If (Lowercase(Left(sCollation, 3)) <> "utf") Begin
79839>>>>>>>//                    Set psCollation to "utf8"
79839>>>>>>>//                End
79839>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreateMySQLDatabase.sql as CreateMySQLDatabase.sql
79839>>>>>>>                Get _SqlUtilCreateMySQLDatabaseByScript "CreateMySQLDatabase.sql" sDatabase to bOK
79840>>>>>>>                Case Break
79841>>>>>>>
79841>>>>>>>            Case (sDriverID = MDSDB2)
79844>>>>>>>                Case Break
79845>>>>>>>
79845>>>>>>>            Case Else
79845>>>>>>>                Error DFERR_PROGRAM "Unsupported database type"
79846>>>>>>>>
79846>>>>>>>        Case End
79846>>>>>>>
79846>>>>>>>        If (Err = False) Begin
79848>>>>>>>            Send LogError ("The Database:" * String(sDatabase) * "was created successfully for driver:" * String(sDriverID)) False
79849>>>>>>>        End
79849>>>>>>>>
79849>>>>>>>        // If used in e.g. the cDbUpdateHandler we want to change the login database name to
79849>>>>>>>        // the one we just created.
79849>>>>>>>        If (bUpdateConnectionString = True and Err = False) Begin
79851>>>>>>>            Set psDatabase to sDatabase
79852>>>>>>>            //...and perhaps also the SQLConnections.ini file setting.
79852>>>>>>>            If (bPermanantly = True) Begin
79854>>>>>>>                If (ghoSQLConnectionHandler <> 0) Begin
79856>>>>>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
79857>>>>>>>                End
79857>>>>>>>>
79857>>>>>>>            End
79857>>>>>>>>
79857>>>>>>>        End
79857>>>>>>>>
79857>>>>>>>
79857>>>>>>>        Function_Return (Err = False)
79858>>>>>>>    End_Function
79859>>>>>>>
79859>>>>>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
79859>>>>>>>    // will be used.
79859>>>>>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
79861>>>>>>>        Boolean bOK bExists bShowProgress bErr
79861>>>>>>>        String sStatement sDriverID
79861>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
79861>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
79861>>>>>>>        Integer iDbType
79861>>>>>>>
79861>>>>>>>        If (sDatabase = "") Begin
79863>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
79864>>>>>>>>
79864>>>>>>>            Function_Return False
79865>>>>>>>        End
79865>>>>>>>>
79865>>>>>>>        If (sBackupName = "") Begin
79867>>>>>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
79868>>>>>>>>
79868>>>>>>>            Function_Return False
79869>>>>>>>        End
79869>>>>>>>>
79869>>>>>>>
79869>>>>>>>        // Create backup-folder if it doesn't exist
79869>>>>>>>        Get vFolderExists sPath to bExists
79870>>>>>>>        If (bExists = False) Begin
79872>>>>>>>            Get vCreateDirectory sPath to bErr
79873>>>>>>>            If (bErr = True) Begin
79875>>>>>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
79876>>>>>>>>
79876>>>>>>>                Function_Return False
79877>>>>>>>            End
79877>>>>>>>>
79877>>>>>>>        End
79877>>>>>>>>
79877>>>>>>>        // Make sure the path ends with a back-slash
79877>>>>>>>        If (sPath <> "") Begin
79879>>>>>>>            Get vFolderFormat sPath to sPath
79880>>>>>>>        End
79880>>>>>>>>
79880>>>>>>>
79880>>>>>>>        Get psDriverID to sDriverID
79881>>>>>>>        Get piDbType   to iDbType
79882>>>>>>>        If (num_arguments > 3) Begin
79884>>>>>>>            Move bShowProg to bShowProgress
79885>>>>>>>        End
79885>>>>>>>>
79885>>>>>>>
79885>>>>>>>        Case Begin
79885>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
79887>>>>>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
79887>>>>>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
79887>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
79888>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
79889>>>>>>>
79889>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
79890>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
79891>>>>>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
79892>>>>>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
79893>>>>>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
79894>>>>>>>                Get SqlUtilExecuteEmbeddedScript of ghoDbUpdateFunctionLibrary SQLScriptArray sDriverID False "" bShowProgress to bOK
79895>>>>>>>                Case Break
79896>>>>>>>            Case Else
79896>>>>>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
79897>>>>>>>        Case End
79897>>>>>>>
79897>>>>>>>        Function_Return bOK
79898>>>>>>>    End_Function
79899>>>>>>>
79899>>>>>>>    Function SqlDatabaseCollationQuery String sDatabase Boolean bSilent Returns String
79901>>>>>>>//        Boolean bOK bExists
79901>>>>>>>        String sStatement sDriverID sRetval //sPrevious
79901>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
79901>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
79901>>>>>>>        Integer iDbType iRows iFetchResult //iColumn
79901>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
79901>>>>>>>        tSQLConnection SQLConnection
79901>>>>>>>        tSQLConnection SQLConnection
79901>>>>>>>
79901>>>>>>>        If (sDatabase = "") Begin
79903>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
79904>>>>>>>>
79904>>>>>>>            Function_Return ""
79905>>>>>>>        End
79905>>>>>>>>
79905>>>>>>>
79905>>>>>>>        Move "" to sRetval
79906>>>>>>>        Get psDriverID to sDriverID
79907>>>>>>>        Get piDbType   to iDbType
79908>>>>>>>
79908>>>>>>>        Case Begin
79908>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
79910>>>>>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
79910>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
79911>>>>>>>
79911>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
79912>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
79913>>>>>>>                Get phoSQLManager to hoSQLHandler
79914>>>>>>>
79914>>>>>>>                If (hoSQLHandler <> 0) Begin
79916>>>>>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
79917>>>>>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
79918>>>>>>>
79918>>>>>>>                    If (hoSQLConnect <> 0) Begin
79920>>>>>>>                        Get SQLOpen of hoSQLConnect to hstmt
79921>>>>>>>                        If (hstmt <> 0) Begin
79923>>>>>>>                            Send SqlExecDirect of hstmt sStatement
79924>>>>>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
79925>>>>>>>                            Get SQLFetch of hstmt to iFetchResult
79926>>>>>>>                            If (iFetchResult <> 0) Begin
79928>>>>>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
79929>>>>>>>                            End
79929>>>>>>>>
79929>>>>>>>                            Send SQLClose of hstmt
79930>>>>>>>                        End
79930>>>>>>>>
79930>>>>>>>                        Send SQLDisconnect of hoSQLConnect
79931>>>>>>>                    End
79931>>>>>>>>
79931>>>>>>>                End
79931>>>>>>>>
79931>>>>>>>                Case Break
79932>>>>>>>            Case Else
79932>>>>>>>                If (bSilent = False) Begin
79934>>>>>>>                    Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for this driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
79935>>>>>>>                End
79935>>>>>>>>
79935>>>>>>>        Case End
79935>>>>>>>
79935>>>>>>>        Function_Return sRetval
79936>>>>>>>    End_Function
79937>>>>>>>
79937>>>>>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
79939>>>>>>>        Boolean bMertechDriver // bOK bExists 
79939>>>>>>>        String sDriverID sSQL sConnectionID sConnectionString sSet sWith // sSQL1 
79939>>>>>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
79939>>>>>>>        Handle hConnection hStmt hoSQLManager
79939>>>>>>>        Integer iDbType // iFetchResult
79939>>>>>>>
79939>>>>>>>        If (sDatabase = "") Begin
79941>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
79942>>>>>>>>
79942>>>>>>>            Function_Return False
79943>>>>>>>        End
79943>>>>>>>>
79943>>>>>>>
79943>>>>>>>        If (sSQLCollation = "") Begin
79945>>>>>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
79946>>>>>>>>
79946>>>>>>>            Function_Return False
79947>>>>>>>        End
79947>>>>>>>>
79947>>>>>>>
79947>>>>>>>        Get psDriverID to sDriverID
79948>>>>>>>        Get piDbType   to iDbType
79949>>>>>>>
79949>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
79950>>>>>>>        If (bMertechDriver = False) Begin
79952>>>>>>>            Get phoSQLManager to hoSQLManager
79953>>>>>>>        End
79953>>>>>>>>
79953>>>>>>>        Else Begin
79954>>>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
79955>>>>>>>        End
79955>>>>>>>>
79955>>>>>>>
79955>>>>>>>        Get psConnectionID     to sConnectionID
79956>>>>>>>        Get psConnectionString to sConnectionString
79957>>>>>>>        Move 0 to LastErr
79958>>>>>>>
79958>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
79959>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
79960>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
79961>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
79963>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
79964>>>>>>>>
79964>>>>>>>            Function_Return False
79965>>>>>>>        End
79965>>>>>>>>
79965>>>>>>>
79965>>>>>>>        Get SqlOpen of hConnection to hStmt
79966>>>>>>>
79966>>>>>>>        If (hStmt = 0) Begin
79968>>>>>>>            Send SqlDisconnect of hoSQLManager
79969>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
79970>>>>>>>>
79970>>>>>>>            Function_Return False
79971>>>>>>>        End
79971>>>>>>>>
79971>>>>>>>
79971>>>>>>>        // Check if collation already exists
79971>>>>>>>        Get SqlDatabaseCollationQuery sDatabase False to sSQLCollationCheck
79972>>>>>>>        // If the current collate is the same as the new; do nothing.
79972>>>>>>>        If (sSQLCollation = sSQLCollationCheck) Begin
79974>>>>>>>            Function_Return True
79975>>>>>>>        End
79975>>>>>>>>
79975>>>>>>>
79975>>>>>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
79976>>>>>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
79977>>>>>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
79978>>>>>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
79979>>>>>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
79980>>>>>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
79981>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
79982>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
79983>>>>>>>
79983>>>>>>>        // MS-SQL Syntax:
79983>>>>>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
79983>>>>>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
79983>>>>>>>        // ALTER DATABASE [database] SET MULTI_USER;
79983>>>>>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
79984>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
79985>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
79986>>>>>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
79986>>>>>>>
79986>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
79987>>>>>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
79988>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
79989>>>>>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
79991>>>>>>>           Function_Return False
79992>>>>>>>        End
79992>>>>>>>>
79992>>>>>>>
79992>>>>>>>        Function_Return (Err = False)
79993>>>>>>>    End_Function
79994>>>>>>>
79994>>>>>>>
79994>>>>>>>    // * Dummy function for the Studio's Code Explorer *
79994>>>>>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
79996>>>>>>>        Function_Return False
79997>>>>>>>    End_Function
79998>>>>>>>
79998>>>>>>>    // Converts from SQL to Embedded (DataFlex .dat files).
79998>>>>>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
79998>>>>>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
79998>>>>>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
79998>>>>>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
79998>>>>>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
80000>>>>>>>        Handle hToTable
80000>>>>>>>        Boolean bOK bExists bOpened bMertechDriver bCopyData
80000>>>>>>>        String sDriverID sPhysicalName sRootName sDisplayName
80000>>>>>>>        tSQLConnection SQLConnection
80000>>>>>>>        tSQLConnection SQLConnection
80000>>>>>>>        Integer iPos iMaxRecords
80000>>>>>>>
80000>>>>>>>        Get psDriverID to sDriverID
80001>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
80002>>>>>>>        If (bExists = False) Begin
80004>>>>>>>            Function_Return False
80005>>>>>>>        End
80005>>>>>>>>
80005>>>>>>>
80005>>>>>>>        If (num_arguments > 1) Begin
80007>>>>>>>            Move bCpyDat to bCopyData
80008>>>>>>>        End
80008>>>>>>>>
80008>>>>>>>        Else Begin
80009>>>>>>>            Move False to bCopyData
80010>>>>>>>        End
80010>>>>>>>>
80010>>>>>>>
80010>>>>>>>        Open hTable
80012>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
80015>>>>>>>        If (bOpened = False) Begin
80017>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
80018>>>>>>>>
80018>>>>>>>            Function_Return False
80019>>>>>>>        End
80019>>>>>>>>
80019>>>>>>>        Move 0 to hToTable
80020>>>>>>>
80020>>>>>>>        Move 16711679 to iMaxRecords
80021>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
80024>>>>>>>        Move (Pos(".", sDisplayName)) to iPos
80025>>>>>>>        If (iPos > 0) Begin
80027>>>>>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
80028>>>>>>>        End
80028>>>>>>>>
80028>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
80031>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
80032>>>>>>>        Move (sRootName + ".dat")                    to sPhysicalName
80033>>>>>>>
80033>>>>>>>        If (ghoProgressBar <> 0) Begin
80035>>>>>>>            Send DoAdvance of ghoProgressBar
80036>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
80037>>>>>>>        End
80037>>>>>>>>
80037>>>>>>>
80037>>>>>>>        Move False to Err
80038>>>>>>>
80038>>>>>>>        Structure_Start hToTable DATAFLEX_ID
80039>>>>>>>            Structure_Copy hTable to hToTable
80040>>>>>>>
80040>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
80043>>>>>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
80046>>>>>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
80049>>>>>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
80052>>>>>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
80055>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
80056>>>>>>>
80056>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
80058>>>>>>>
80058>>>>>>>        Set Action_Text of ghoStatusPanel to ""
80059>>>>>>>        Move (not(Err)) to bOK
80060>>>>>>>        If (bOK = True and bCopyData = True) Begin
80062>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
80063>>>>>>>        End
80063>>>>>>>>
80063>>>>>>>
80063>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
80064>>>>>>>        If (bMertechDriver = True) Begin
80066>>>>>>>            Open hTable
80068>>>>>>>        End
80068>>>>>>>>
80068>>>>>>>
80068>>>>>>>        // This must be after copying data...
80068>>>>>>>        If (Err = False) Begin
80070>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
80073>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
80076>>>>>>>        End
80076>>>>>>>>
80076>>>>>>>        Move (not(Err)) to bOK
80077>>>>>>>
80077>>>>>>>        Function_Return (bOK = True)
80078>>>>>>>    End_Function
80079>>>>>>>
80079>>>>>>>    Function AddFolderDelimiter String sPath Returns String
80081>>>>>>>        String sDirSep
80081>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
80082>>>>>>>        Move (Trim(sPath)) to sPath
80083>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
80085>>>>>>>            Move (sPath + sDirSep) to sPath
80086>>>>>>>        End
80086>>>>>>>>
80086>>>>>>>        Function_Return sPath
80087>>>>>>>    End_Function
80088>>>>>>>
80088>>>>>>>    // Creates an SQL Table at the SQL end by its filelist number;
80088>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
80088>>>>>>>    Function SqlTableCreate Integer hTable Returns Boolean
80090>>>>>>>        String sTableName sSQLString sPath sCreateTable sDriverID
80090>>>>>>>        Integer iDbType
80090>>>>>>>        Boolean bExists
80090>>>>>>>
80090>>>>>>>        Get psDriverID to sDriverID
80091>>>>>>>        Get UtilTableHandleToString hTable to sTableName
80092>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
80093>>>>>>>        If (bExists = True) Begin
80095>>>>>>>            Function_Return False
80096>>>>>>>        End
80096>>>>>>>>
80096>>>>>>>
80096>>>>>>>        Get psDataPathFirstPart to sPath
80097>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
80098>>>>>>>
80098>>>>>>>        Get piDbType to iDbType
80099>>>>>>>        Get _SqlProperTableName sTableName to sTableName
80100>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
80101>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
80102>>>>>>>
80102>>>>>>>        Move False to Err
80103>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
80104>>>>>>>
80104>>>>>>>        Function_Return (Err = False)
80105>>>>>>>    End_Function
80106>>>>>>>
80106>>>>>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
80106>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
80106>>>>>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
80108>>>>>>>        String sSQLString sPath sCreateTable sDriverID
80108>>>>>>>        Integer iDbType
80108>>>>>>>        Boolean bExists
80108>>>>>>>
80108>>>>>>>        Get psDriverID to sDriverID
80109>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
80110>>>>>>>        If (bExists = True) Begin
80112>>>>>>>            Function_Return False
80113>>>>>>>        End
80113>>>>>>>>
80113>>>>>>>
80113>>>>>>>        Get psDataPathFirstPart to sPath
80114>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
80115>>>>>>>        If (bExists = True) Begin
80117>>>>>>>            // ToDo: What should we do if an .int file already exists?
80117>>>>>>>        End
80117>>>>>>>>
80117>>>>>>>
80117>>>>>>>        Get piDbType to iDbType
80118>>>>>>>        Get _SqlProperTableName sTableName to sTableName
80119>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
80120>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
80121>>>>>>>
80121>>>>>>>        Move False to Err
80122>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
80123>>>>>>>
80123>>>>>>>        Function_Return (Err = False)
80124>>>>>>>    End_Function
80125>>>>>>>    
80125>>>>>>>    // ToDo: 2019-09-23 This needs to be finilized 
80125>>>>>>>    // It resets SQL constraints after a Structure_End, if necessary.
80125>>>>>>>    Function SqlTableRecreateConstraints Handle hTable Returns Boolean
80127>>>>>>>        Boolean bOK                                                            
80127>>>>>>>        String sStatement
80127>>>>>>>        Move "ALTER TABLE [dbo].[THREADS] ADD  DEFAULT ((0)) FOR [SEGMENTS]" to sStatement
80128>>>>>>>        Function_Return bOK
80129>>>>>>>    End_Function
80130>>>>>>>    
80130>>>>>>>    // First deletes the data cache file and then drops the passed SQL table.
80130>>>>>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
80130>>>>>>>    //       else try using the SqlTableRemoveByTableName message.
80130>>>>>>>    Function SqlTableRemove Handle hTable Returns Boolean
80132>>>>>>>        String sSQLString sPath sDropTable sTableName sDriverID
80132>>>>>>>        Integer iRetval iDbType
80132>>>>>>>        Boolean bExists bMertechDriver bOK
80132>>>>>>>
80132>>>>>>>        Get psDriverID to sDriverID
80133>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
80134>>>>>>>        Get UtilTableHandleToString hTable to sTableName
80135>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
80136>>>>>>>        If (bExists = False) Begin
80138>>>>>>>            Function_Return False
80139>>>>>>>        End
80139>>>>>>>>
80139>>>>>>>
80139>>>>>>>        Get psDataPathFirstPart to sPath
80140>>>>>>>        Get UtilDeleteCacheFile sTableName to iRetval
80141>>>>>>>
80141>>>>>>>        Get piDbType to iDbType
80142>>>>>>>        Get _SqlProperTableName sTableName to sTableName
80143>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
80144>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
80145>>>>>>>
80145>>>>>>>        Move False to Err
80146>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
80147>>>>>>>
80147>>>>>>>        // We also need to remove the cache-file since the table has been changed
80147>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
80148>>>>>>>
80148>>>>>>>        Function_Return (Err = False)
80149>>>>>>>    End_Function
80150>>>>>>>
80150>>>>>>>    // First deletes the data cache file and then drops the passed data table.
80150>>>>>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
80152>>>>>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
80152>>>>>>>        Integer iRetval iDbType
80152>>>>>>>        Boolean bMertechDriver bOK
80152>>>>>>>
80152>>>>>>>        Get psDriverID to sDriverID
80153>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
80154>>>>>>>        Get psDataPathFirstPart to sPath
80155>>>>>>>        Get UtilDeleteCacheFile sTableName to iRetval
80156>>>>>>>
80156>>>>>>>        Get piDbType to iDbType
80157>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
80158>>>>>>>        Get psSchema to sSchema
80159>>>>>>>        If (sSchema = "") Begin
80161>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
80162>>>>>>>        End
80162>>>>>>>>
80162>>>>>>>        Move (Uppercase(sTableName)) to sVal
80163>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
80165>>>>>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
80166>>>>>>>        End
80166>>>>>>>>
80166>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
80167>>>>>>>
80167>>>>>>>        Move False to Err
80168>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
80169>>>>>>>
80169>>>>>>>        // We also need to remove the cache-file since the table has been changed
80169>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
80170>>>>>>>
80170>>>>>>>        Function_Return (Err = False)
80171>>>>>>>    End_Function
80172>>>>>>>
80172>>>>>>>    // *** Sql View Messages ***
80172>>>>>>>
80172>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
80172>>>>>>>    Function SqlViewRemove String sDataView Returns Boolean
80174>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
80174>>>>>>>        Integer iRetval
80174>>>>>>>        Boolean bMertechDriver bOK
80174>>>>>>>
80174>>>>>>>        Get psDriverID to sDriverID
80175>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
80176>>>>>>>        Get UtilDeleteCacheFile sDataView to iRetval
80177>>>>>>>
80177>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
80178>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
80179>>>>>>>        Set psSQLStatementString to sSQLString
80180>>>>>>>
80180>>>>>>>        // As we don't check if the view exist or not, it might happen
80180>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
80180>>>>>>>        Move False to Err
80181>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
80182>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
80183>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
80184>>>>>>>        Move 0 to LastErr
80185>>>>>>>
80185>>>>>>>        // We also need to remove the cache-file since the table has been changed
80185>>>>>>>        Get UtilDeleteCacheFile sDataView to bOK
80186>>>>>>>
80186>>>>>>>        Function_Return (Err = False)
80187>>>>>>>    End_Function
80188>>>>>>>
80188>>>>>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
80190>>>>>>>        Boolean bOK
80190>>>>>>>        Integer iDbType
80190>>>>>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
80190>>>>>>>
80190>>>>>>>        Get psDriverID to sDriverID
80191>>>>>>>        Get piDbType   to iDbType
80192>>>>>>>
80192>>>>>>>        Case Begin
80192>>>>>>>            Case (iDbType = EN_DbTypeDB2)
80194>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
80195>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
80196>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
80197>>>>>>>            Break
80198>>>>>>>
80198>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
80201>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
80202>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
80203>>>>>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - String(sNewtTableName) - "'") to sSQLString
80204>>>>>>>            Break
80205>>>>>>>
80205>>>>>>>            Case (iDbType = EN_DbTypeOracle)
80208>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
80209>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
80210>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
80211>>>>>>>            Break
80212>>>>>>>
80212>>>>>>>            Case (iDbType = EN_DbTypePostgre)
80215>>>>>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
80216>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
80217>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
80218>>>>>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * String(sNewtTableName)) to sSQLString
80219>>>>>>>            Break
80220>>>>>>>
80220>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
80223>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
80224>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
80225>>>>>>>                Move (Replaces("-", sNewtTableName, "_")) to sNewtTableName
80226>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
80227>>>>>>>            Break
80228>>>>>>>        Case End
80228>>>>>>>
80228>>>>>>>        Move False to Err
80229>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
80230>>>>>>>        Move (Err = False) to bOK
80231>>>>>>>
80231>>>>>>>        Function_Return bOK
80232>>>>>>>    End_Function
80233>>>>>>>
80233>>>>>>>    // * Dummy function for the Studio's Code Explorer *
80233>>>>>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
80235>>>>>>>        Function_Return False
80236>>>>>>>    End_Function
80237>>>>>>>
80237>>>>>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
80237>>>>>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
80239>>>>>>>        Integer iLength iDecimals
80239>>>>>>>        String sColumnValue
80239>>>>>>>        String sTableName sDriverID
80239>>>>>>>        Boolean bOK bInitializeValue
80239>>>>>>>
80239>>>>>>>        Get psDriverID to sDriverID
80240>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80241>>>>>>>        If (bOK = False) Begin
80243>>>>>>>            Function_Return False
80244>>>>>>>        End
80244>>>>>>>>
80244>>>>>>>
80244>>>>>>>        Get UtilTableHandleToString hTable to sTableName
80245>>>>>>>        If (sTableName = "") Begin
80247>>>>>>>            Function_Return False
80248>>>>>>>        End
80248>>>>>>>>
80248>>>>>>>
80248>>>>>>>        If (num_arguments > 3) Begin
80250>>>>>>>            Move iLen     to iLength
80251>>>>>>>            Move iDec     to iDecimals
80252>>>>>>>            Move bInitVal to bInitializeValue
80253>>>>>>>            Move sColVal  to sColumnValue
80254>>>>>>>        End
80254>>>>>>>>
80254>>>>>>>
80254>>>>>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
80255>>>>>>>
80255>>>>>>>        Function_Return (bOK = True)
80256>>>>>>>    End_Function
80257>>>>>>>
80257>>>>>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
80257>>>>>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
80259>>>>>>>        Integer iDbType iLength iDecimals iDriver
80259>>>>>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
80259>>>>>>>        String sDriverID sNotNull
80259>>>>>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState bIsMertechDriver
80259>>>>>>>        Handle hTable
80259>>>>>>>
80259>>>>>>>        Get psDriverID to sDriverID
80260>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80261>>>>>>>        If (bOK = False) Begin
80263>>>>>>>            Function_Return True
80264>>>>>>>        End
80264>>>>>>>>
80264>>>>>>>
80264>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
80265>>>>>>>        If (hTable = 0) Begin
80267>>>>>>>            Get NextFreeFilelistSlot to hTable
80268>>>>>>>        End
80268>>>>>>>>
80268>>>>>>>
80268>>>>>>>        Get piDbType to iDbType
80269>>>>>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
80269>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
80270>>>>>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
80272>>>>>>>            Function_Return True
80273>>>>>>>        End
80273>>>>>>>>
80273>>>>>>>
80273>>>>>>>        Get DriverIndex sDriverID to iDriver
80274>>>>>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
80275>>>>>>>        If (bIsMertechDriver = False) Begin
80277>>>>>>>            Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
80280>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
80283>>>>>>>        End
80283>>>>>>>>
80283>>>>>>>
80283>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
80284>>>>>>>        If (num_arguments > 3) Begin
80286>>>>>>>            Move iLen     to iLength
80287>>>>>>>            Move iDec     to iDecimals
80288>>>>>>>            Move bInitVal to bInitializeValue
80289>>>>>>>            Move sColVal  to sColumnValue
80290>>>>>>>        End
80290>>>>>>>>
80290>>>>>>>
80290>>>>>>>        Get _SqlProperTableName sTableName   to sTableName
80291>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
80292>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
80293>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
80294>>>>>>>
80294>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
80295>>>>>>>        If (bFixed = False) Begin
80297>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
80298>>>>>>>        End
80298>>>>>>>>
80298>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
80299>>>>>>>
80299>>>>>>>        Move False to Err
80300>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
80301>>>>>>>
80301>>>>>>>        If (bInitializeValue = True and Err = False) Begin
80303>>>>>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
80304>>>>>>>        End
80304>>>>>>>>
80304>>>>>>>
80304>>>>>>>        If (Err = False) Begin
80306>>>>>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
80307>>>>>>>        End
80307>>>>>>>>
80307>>>>>>>
80307>>>>>>>        Move (not(Err)) to bRetval
80308>>>>>>>
80308>>>>>>>        // We also need to remove the cache-file since the table has been changed
80308>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
80309>>>>>>>        If (bIsMertechDriver = False) Begin
80311>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
80314>>>>>>>        End
80314>>>>>>>>
80314>>>>>>>        Function_Return bRetval
80315>>>>>>>    End_Function
80316>>>>>>>
80316>>>>>>>    // To update all current rows for a table column with a common value.
80316>>>>>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
80318>>>>>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sSqlSafe_Updates sStmt
80318>>>>>>>        Boolean bRetval bSQLDriver
80318>>>>>>>        Integer iCurrErr iDbType
80318>>>>>>>
80318>>>>>>>        Move False to bRetval
80319>>>>>>>        Get piDbType to iDbType
80320>>>>>>>        Get psDriverID to sDriverID
80321>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
80322>>>>>>>        If (bSQLDriver = False) Begin
80324>>>>>>>            Function_Return bRetval
80325>>>>>>>        End
80325>>>>>>>>
80325>>>>>>>        Get UtilTableHandleToString hTable to sTableName
80326>>>>>>>
80326>>>>>>>        Move Err to iCurrErr
80327>>>>>>>        Move False to Err
80328>>>>>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
80329>>>>>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
80330>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
80331>>>>>>>        If (sDriverID = MDSMySQL) Begin
80333>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
80334>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'" * sSet * sSqlSafe_Updates + "=1") to sStmt
80335>>>>>>>        End
80335>>>>>>>>
80335>>>>>>>        // If MySQL and DAW's ODBC driver is used we need to do it slightly different.
80335>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
80337>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
80338>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
80339>>>>>>>        End
80339>>>>>>>>
80339>>>>>>>        Else Begin
80340>>>>>>>            Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
80341>>>>>>>        End
80341>>>>>>>>
80341>>>>>>>
80341>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
80342>>>>>>>        Move (Err = False) to bRetval
80343>>>>>>>        Move iCurrErr to Err
80344>>>>>>>
80344>>>>>>>        Function_Return bRetval
80345>>>>>>>    End_Function
80346>>>>>>>
80346>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
80346>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
80346>>>>>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
80348>>>>>>>        String sDriverID sTableName
80348>>>>>>>        Boolean bOK
80348>>>>>>>
80348>>>>>>>        Get psDriverID to sDriverID
80349>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80350>>>>>>>        If (bOK = False) Begin
80352>>>>>>>            Function_Return False
80353>>>>>>>        End
80353>>>>>>>>
80353>>>>>>>
80353>>>>>>>        Get UtilTableHandleToString hTable to sTableName
80354>>>>>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
80355>>>>>>>
80355>>>>>>>        Function_Return (Err = False)
80356>>>>>>>    End_Function
80357>>>>>>>
80357>>>>>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
80357>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
80357>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
80357>>>>>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
80359>>>>>>>        Integer iDbType iLength iDecimals
80359>>>>>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
80359>>>>>>>        Boolean bExists bOK bFixed
80359>>>>>>>        Handle hTable
80359>>>>>>>
80359>>>>>>>        Get psDriverID to sDriverID
80360>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80361>>>>>>>        If (bOK = False) Begin
80363>>>>>>>            Function_Return False
80364>>>>>>>        End
80364>>>>>>>>
80364>>>>>>>
80364>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
80365>>>>>>>        If (hTable = 0) Begin
80367>>>>>>>            Get NextFreeFilelistSlot to hTable
80368>>>>>>>        End
80368>>>>>>>>
80368>>>>>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
80369>>>>>>>        If (bExists = False) Begin
80371>>>>>>>            Function_Return False
80372>>>>>>>        End
80372>>>>>>>>
80372>>>>>>>
80372>>>>>>>        If (num_arguments > 3) Begin
80374>>>>>>>            Move iLen to iLength
80375>>>>>>>        End
80375>>>>>>>>
80375>>>>>>>        If (num_arguments > 4) Begin
80377>>>>>>>            Move iDec to iDecimals
80378>>>>>>>        End
80378>>>>>>>>
80378>>>>>>>
80378>>>>>>>        Get piDbType to iDbType
80379>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
80380>>>>>>>
80380>>>>>>>        Move False to Err
80381>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
80382>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
80383>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
80384>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
80385>>>>>>>
80385>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
80386>>>>>>>        If (bFixed = False) Begin
80388>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
80389>>>>>>>        End
80389>>>>>>>>
80389>>>>>>>
80389>>>>>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
80390>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
80391>>>>>>>
80391>>>>>>>        // We also need to remove the cache-file since the table has been changed
80391>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
80392>>>>>>>
80392>>>>>>>        Function_Return (Err = False)
80393>>>>>>>    End_Function
80394>>>>>>>
80394>>>>>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
80396>>>>>>>        Boolean bOK bErr bIsSQLDriver
80396>>>>>>>        String sDriverID
80396>>>>>>>        Integer iDataType
80396>>>>>>>
80396>>>>>>>        Get psDriverID to sDriverID
80397>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
80398>>>>>>>        If (bIsSQLDriver = False) Begin
80400>>>>>>>            Function_Return False
80401>>>>>>>        End
80401>>>>>>>>
80401>>>>>>>
80401>>>>>>>        Move Err to bErr
80402>>>>>>>        Move False to bErr
80403>>>>>>>
80403>>>>>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
80403>>>>>>>        // inserts randomly character(10) and spaces, so we correct from that here:
80403>>>>>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
80404>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType
80407>>>>>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
80409>>>>>>>            Move ("[" + String(sValue) + "]") to sValue
80410>>>>>>>        End
80410>>>>>>>>
80410>>>>>>>
80410>>>>>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
80413>>>>>>>        Move (not(Err)) to bOK
80414>>>>>>>        Move bErr to Err
80415>>>>>>>
80415>>>>>>>        Function_Return bOK
80416>>>>>>>    End_Function
80417>>>>>>>
80417>>>>>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
80419>>>>>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
80419>>>>>>>        String sDriverID
80419>>>>>>>
80419>>>>>>>        Get psDriverID to sDriverID
80420>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
80421>>>>>>>        If (bIsSQLDriver = False) Begin
80423>>>>>>>            Function_Return False
80424>>>>>>>        End
80424>>>>>>>>
80424>>>>>>>
80424>>>>>>>        Move Err to bErr
80425>>>>>>>        Move False to bErr
80426>>>>>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
80429>>>>>>>        If (bNullable = bCurrentState) Begin
80431>>>>>>>            Function_Return True
80432>>>>>>>        End
80432>>>>>>>>
80432>>>>>>>
80432>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
80435>>>>>>>        If (bOpen = False) Begin
80437>>>>>>>            Get AutoConnectionIDLogin to bOK
80438>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
80439>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
80440>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
80441>>>>>>>            Open hTable
80443>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
80444>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
80445>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
80446>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
80449>>>>>>>        End
80449>>>>>>>>
80449>>>>>>>        If (bOpen = True) Begin
80451>>>>>>>            Structure_Start hTable sDriverID
80452>>>>>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
80455>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
80456>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
80458>>>>>>>            Set Action_Text of ghoStatusPanel to ""
80459>>>>>>>        End
80459>>>>>>>>
80459>>>>>>>
80459>>>>>>>        Move (not(Err)) to bOK
80460>>>>>>>        Move bErr to Err
80461>>>>>>>
80461>>>>>>>        Function_Return bOK
80462>>>>>>>    End_Function
80463>>>>>>>
80463>>>>>>>    // Drop column by its table handle
80463>>>>>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
80465>>>>>>>        String sDriverID sTableName
80465>>>>>>>        Boolean bOK
80465>>>>>>>
80465>>>>>>>        Get psDriverID to sDriverID
80466>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80467>>>>>>>        If (bOK = False) Begin
80469>>>>>>>            Function_Return False
80470>>>>>>>        End
80470>>>>>>>>
80470>>>>>>>
80470>>>>>>>        Get UtilTableHandleToString hTable to sTableName
80471>>>>>>>        If (sTableName = "") Begin
80473>>>>>>>            Function_Return False
80474>>>>>>>        End
80474>>>>>>>>
80474>>>>>>>
80474>>>>>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
80475>>>>>>>
80475>>>>>>>        Function_Return (bOK = True)
80476>>>>>>>    End_Function
80477>>>>>>>
80477>>>>>>>    // Drop column by its table name as a string.
80477>>>>>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
80479>>>>>>>        Integer iDbType iDriver
80479>>>>>>>        String sDriverID sStmt sAlterTable sDropColumn
80479>>>>>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
80479>>>>>>>        Handle hTable
80479>>>>>>>
80479>>>>>>>        Get psDriverID to sDriverID
80480>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80481>>>>>>>        If (bOK = False) Begin
80483>>>>>>>            Function_Return False
80484>>>>>>>        End
80484>>>>>>>>
80484>>>>>>>
80484>>>>>>>        Get DriverIndex sDriverID to iDriver
80485>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
80488>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
80491>>>>>>>
80491>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
80492>>>>>>>        If (hTable <> 0) Begin
80494>>>>>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
80495>>>>>>>            If (bExists = False) Begin
80497>>>>>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
80500>>>>>>>                Function_Return False
80501>>>>>>>            End
80501>>>>>>>>
80501>>>>>>>        End
80501>>>>>>>>
80501>>>>>>>
80501>>>>>>>        Get piDbType to iDbType
80502>>>>>>>        If (iDbType = EN_DbTypeMSSQL) Begin
80504>>>>>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
80505>>>>>>>            Get UtilDeleteCacheFile sTableName to bOK
80506>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
80509>>>>>>>            Function_Return bOK
80510>>>>>>>        End
80510>>>>>>>>
80510>>>>>>>
80510>>>>>>>        Move False to Err
80511>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
80512>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
80513>>>>>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
80514>>>>>>>
80514>>>>>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
80515>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
80516>>>>>>>        Move (not(Err)) to bRetval
80517>>>>>>>
80517>>>>>>>        // We also need to remove the cache-file since the table has been changed
80517>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
80518>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
80521>>>>>>>
80521>>>>>>>        Function_Return bRetval
80522>>>>>>>    End_Function
80523>>>>>>>
80523>>>>>>>    // Rename a field/column by table handle (filelist number)
80523>>>>>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
80525>>>>>>>        String sDriverID sTableName
80525>>>>>>>        Boolean bOK
80525>>>>>>>
80525>>>>>>>        Get psDriverID to sDriverID
80526>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80527>>>>>>>        If (bOK = False) Begin
80529>>>>>>>            Function_Return False
80530>>>>>>>        End
80530>>>>>>>>
80530>>>>>>>
80530>>>>>>>        Get UtilTableHandleToString hTable to sTableName
80531>>>>>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
80532>>>>>>>
80532>>>>>>>        Function_Return (Err = False)
80533>>>>>>>    End_Function
80534>>>>>>>
80534>>>>>>>    // Rename a field/column by table name.
80534>>>>>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
80536>>>>>>>        Integer iDbType iDataType
80536>>>>>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
80536>>>>>>>        Boolean bOK bRetval
80536>>>>>>>        Handle hTable
80536>>>>>>>
80536>>>>>>>        Move sTableName to sOrgTableName
80537>>>>>>>        Get psDriverID to sDriverID
80538>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80539>>>>>>>        If (bOK = False) Begin
80541>>>>>>>            Function_Return False
80542>>>>>>>        End
80542>>>>>>>>
80542>>>>>>>
80542>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
80543>>>>>>>        If (sVal = "") Begin
80545>>>>>>>            Function_Return False
80546>>>>>>>        End
80546>>>>>>>>
80546>>>>>>>
80546>>>>>>>        Get piDbType to iDbType
80547>>>>>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
80548>>>>>>>        Get _SqlProperTableName sTableName     to sTableName
80549>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
80550>>>>>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
80551>>>>>>>
80551>>>>>>>        Case Begin
80551>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
80553>>>>>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
80554>>>>>>>                Case Break
80555>>>>>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
80555>>>>>>>            Case (iDbType = EN_dbTypeOracle)
80558>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
80559>>>>>>>                Case Break
80560>>>>>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
80560>>>>>>>            Case (iDbType = EN_dbTypeDB2)
80563>>>>>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
80564>>>>>>>                Case Break
80565>>>>>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
80565>>>>>>>            Case (iDbType = EN_dbTypePostgre)
80568>>>>>>>                Move sOrgTableName to sTableName
80569>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
80570>>>>>>>                Case Break
80571>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
80574>>>>>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
80574>>>>>>>                Move sOrgTableName to sTableName
80575>>>>>>>                Get psDatabase to sDatabase
80576>>>>>>>                Get UtilTableNameToHandle sTableName to hTable
80577>>>>>>>                If (hTable = 0) Begin
80579>>>>>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
80580>>>>>>>                    If (bOK = False) Begin
80582>>>>>>>                        Function_Return False
80583>>>>>>>                    End
80583>>>>>>>>
80583>>>>>>>                    Get NextFreeFilelistSlot to hTable
80584>>>>>>>                End
80584>>>>>>>>
80584>>>>>>>                Else Begin
80585>>>>>>>                    Open hTable
80587>>>>>>>                End
80587>>>>>>>>
80587>>>>>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
80588>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
80589>>>>>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
80590>>>>>>>                Case Break
80591>>>>>>>            Case Else
80591>>>>>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
80592>>>>>>>        Case End
80592>>>>>>>
80592>>>>>>>        Move False to Err
80593>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
80594>>>>>>>        Move (Err = False) to bRetval
80595>>>>>>>        // We also need to remove the cache-file since the table has been changed
80595>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
80596>>>>>>>
80596>>>>>>>        Function_Return bRetval
80597>>>>>>>    End_Function
80598>>>>>>>
80598>>>>>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
80600>>>>>>>        Handle hoSQLHandler hSQLConnect hStmt
80600>>>>>>>        Boolean bMertechDriver
80600>>>>>>>        Integer iNumCols iCount iDataType
80600>>>>>>>        String sValue
80600>>>>>>>
80600>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
80601>>>>>>>        If (bMertechDriver = False) Begin
80603>>>>>>>            Get phoSQLManager to hoSQLHandler
80604>>>>>>>        End
80604>>>>>>>>
80604>>>>>>>        Else Begin
80605>>>>>>>            Get _MertechSQLManagerHandle to hoSQLHandler
80606>>>>>>>        End
80606>>>>>>>>
80606>>>>>>>
80606>>>>>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
80607>>>>>>>        If (hSQLConnect <> 0) Begin
80609>>>>>>>            Get SQLOpen of hSQLConnect to hStmt
80610>>>>>>>            If (hStmt <> 0) Begin
80612>>>>>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
80613>>>>>>>
80613>>>>>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
80614>>>>>>>                For iCount from 1 to iNumCols
80620>>>>>>>>
80620>>>>>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
80621>>>>>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
80623>>>>>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
80624>>>>>>>                        Move iNumCols to iCount // We're out of here
80625>>>>>>>                    End
80625>>>>>>>>
80625>>>>>>>                Loop
80626>>>>>>>>
80626>>>>>>>
80626>>>>>>>                Send SQLClose of hStmt
80627>>>>>>>            End
80627>>>>>>>>
80627>>>>>>>            Send SQLDisconnect of hSQLConnect
80628>>>>>>>        End
80628>>>>>>>>
80628>>>>>>>
80628>>>>>>>        Function_Return iDataType
80629>>>>>>>    End_Function
80630>>>>>>>
80630>>>>>>>    // * Dummy function for the Studio's Code Explorer *
80630>>>>>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
80632>>>>>>>        Function_Return False
80633>>>>>>>    End_Function
80634>>>>>>>
80634>>>>>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
80636>>>>>>>        String sMessage // sConnectionString
80636>>>>>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
80636>>>>>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
80636>>>>>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
80639>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
80639>>>>>>>        TimeSpan tsQuery tsFetch
80639>>>>>>>        tSqlErrorArray aSqlErrorArray
80639>>>>>>>        tSqlErrorArray aSqlErrorArray
80639>>>>>>>        Boolean bOK bMertechDriver bShowProgress
80639>>>>>>>        tSQLConnection SQLConnection
80639>>>>>>>        tSQLConnection SQLConnection
80639>>>>>>>
80639>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80640>>>>>>>        If (bOK = False) Begin
80642>>>>>>>            Procedure_Return
80643>>>>>>>        End
80643>>>>>>>>
80643>>>>>>>
80643>>>>>>>        If (num_arguments > 2) Begin
80645>>>>>>>            Move bShowProgr to bShowProgress
80646>>>>>>>        End
80646>>>>>>>>
80646>>>>>>>
80646>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
80647>>>>>>>
80647>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
80648>>>>>>>        If (bMertechDriver = True) Begin
80650>>>>>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
80651>>>>>>>        End
80651>>>>>>>>
80651>>>>>>>        If (bMertechDriver = False) Begin
80653>>>>>>>            Get phoSQLManager to hoSqlHandler
80654>>>>>>>            Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
80655>>>>>>>            Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
80656>>>>>>>        End
80656>>>>>>>>
80656>>>>>>>
80656>>>>>>>        If (hoSQLConnect <> 0) Begin
80658>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
80659>>>>>>>            If (hoStmt <> 0) Begin
80661>>>>>>>                // record starting date/time stamp
80661>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
80662>>>>>>>                // turn on error handling if enabled
80662>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
80664>>>>>>>                    Set pbSqlError to False
80665>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
80666>>>>>>>                    Move Error_Object_Id to hoError
80667>>>>>>>                    If (ghoDbUpdateHandler <> 0) Begin
80669>>>>>>>                        Move ghoDbUpdateHandler to Error_Object_Id
80670>>>>>>>                    End
80670>>>>>>>>
80670>>>>>>>                    Else Begin
80671>>>>>>>                        Move Self to Error_Object_Id
80672>>>>>>>                    End
80672>>>>>>>>
80672>>>>>>>                End
80672>>>>>>>>
80672>>>>>>>
80672>>>>>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
80672>>>>>>>                Set psSQLStatementString to sStmt
80673>>>>>>>                Send Cursor_Wait of Cursor_Control
80674>>>>>>>                Send SqlExecDirect of hoStmt sStmt
80675>>>>>>>                Send Cursor_Ready of Cursor_Control
80676>>>>>>>
80676>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
80678>>>>>>>                    Move hoError to Error_Object_Id
80679>>>>>>>                End
80679>>>>>>>>
80679>>>>>>>
80679>>>>>>>                Move 0 to iMsgs
80680>>>>>>>                // ToDo: There seems to be some issues with this code and Mertech drivers that makes
80680>>>>>>>                // the debugger crash in some cases like an error in the ESQL statement; so we exclude it for now.
80680>>>>>>>                If (bMertechDriver = False) Begin
80682>>>>>>>                    Move Err to iErr
80683>>>>>>>                    Move LastErr to iLastErr
80684>>>>>>>                    Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
80685>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
80686>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
80687>>>>>>>                    Send _SqlColumnInfo hoStmt
80688>>>>>>>                    Send Ignore_Error of Error_Object_Id 12289
80689>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
80690>>>>>>>                    Repeat
80690>>>>>>>>
80690>>>>>>>                        Get SqlFetch of hoStmt to iFetchResult
80691>>>>>>>                        If (iFetchResult <> 0) Begin
80693>>>>>>>                            Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
80694>>>>>>>                        End
80694>>>>>>>>
80694>>>>>>>                    Until (iFetchResult = 0)
80696>>>>>>>                    Send Trap_Error of Error_Object_Id 12289
80697>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
80698>>>>>>>                    Move iErr to Err
80699>>>>>>>                    Move iLastErr to LastErr
80700>>>>>>>                    Set paSQLFetchResults to aSQLFetchResults
80701>>>>>>>                End
80701>>>>>>>>
80701>>>>>>>
80701>>>>>>>                Set piRows    to iRows
80702>>>>>>>                Set piRowType to iRowType
80703>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
80704>>>>>>>                Move (CurrentDateTime()) to dtFetchStart
80705>>>>>>>
80705>>>>>>>                If (iMsgs <> 0) Begin
80707>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
80709>>>>>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
80710>>>>>>>                    End
80710>>>>>>>>
80710>>>>>>>                    For i from 1 to iMsgs
80716>>>>>>>>
80716>>>>>>>                        Get SqlGetMessage of hoStmt i to sMessage
80717>>>>>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
80718>>>>>>>                        If (bShowProgress = True) Begin
80720>>>>>>>                            If (Active_State(ghoStatusPanel)) Begin
80722>>>>>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
80723>>>>>>>                            End
80723>>>>>>>>
80723>>>>>>>                            Else Begin
80724>>>>>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
80726>>>>>>>                            End
80726>>>>>>>>
80726>>>>>>>                        End
80726>>>>>>>>
80726>>>>>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
80727>>>>>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
80728>>>>>>>                    Loop
80729>>>>>>>>
80729>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
80731>>>>>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
80732>>>>>>>                    End
80732>>>>>>>>
80732>>>>>>>                    Set paQueryMessages to sMsg
80733>>>>>>>                End
80733>>>>>>>>
80733>>>>>>>                Else Begin
80734>>>>>>>                    If (bShowProgress = True) Begin
80736>>>>>>>                        Get paSqlErrorArray to aSqlErrorArray
80737>>>>>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
80739>>>>>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
80740>>>>>>>                            Decrement iMsgs
80741>>>>>>>                            For i from 0 to iMsgs
80747>>>>>>>>
80747>>>>>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
80750>>>>>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
80753>>>>>>>                            Loop
80754>>>>>>>>
80754>>>>>>>                        End
80754>>>>>>>>
80754>>>>>>>                    End
80754>>>>>>>>
80754>>>>>>>                End
80754>>>>>>>>
80754>>>>>>>                Move (CurrentDateTime()) to dtFetchEnd
80755>>>>>>>            End
80755>>>>>>>>
80755>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
80756>>>>>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
80757>>>>>>>            Set ptsQueryExec to tsQuery
80758>>>>>>>            Set ptsFetchResults to tsFetch
80759>>>>>>>            Send SqlClose of hoStmt
80760>>>>>>>        End
80760>>>>>>>>
80760>>>>>>>
80760>>>>>>>        Send SqlDisconnect of hoSQLConnect
80761>>>>>>>    End_Procedure
80762>>>>>>>
80762>>>>>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
80762>>>>>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
80762>>>>>>>    // Returns False if no error occured.
80762>>>>>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
80764>>>>>>>        Boolean bOK bShowProgress
80764>>>>>>>        tSQLScriptArray SQLScriptArray
80764>>>>>>>        tSQLScriptArray SQLScriptArray
80764>>>>>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
80764>>>>>>>        TimeSpan tsTotalTime
80764>>>>>>>
80764>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryStart
80765>>>>>>>        Get SqlUtilReadResource sMemFileName to SQLScriptArray
80766>>>>>>>        If (SQLScriptArray.bError = True) Begin
80768>>>>>>>            Function_Return False
80769>>>>>>>        End
80769>>>>>>>>
80769>>>>>>>
80769>>>>>>>        If (num_arguments > 3) Begin
80771>>>>>>>            Move bShowProgr to bShowProgress
80772>>>>>>>        End
80772>>>>>>>>
80772>>>>>>>
80772>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
80773>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
80774>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
80775>>>>>>>
80775>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
80776>>>>>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
80777>>>>>>>        Set ptsTotalQueryTime to tsTotalTime
80778>>>>>>>
80778>>>>>>>        Function_Return bOK
80779>>>>>>>    End_Function
80780>>>>>>>
80780>>>>>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
80780>>>>>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
80780>>>>>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
80780>>>>>>>    Function SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
80782>>>>>>>        Integer iChannel iArgumentSize iCount
80782>>>>>>>        Number nByteCount
80782>>>>>>>        String sSQLScript
80782>>>>>>>        tSQLScriptArray SqlScriptArray
80782>>>>>>>        tSQLScriptArray SqlScriptArray
80782>>>>>>>        UChar[] uCharData
80783>>>>>>>
80783>>>>>>>        Move False to Err
80784>>>>>>>        Get Seq_New_Channel to iChannel
80785>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
80787>>>>>>>            Error DFERR_PROGRAM 'No channel available...'
80788>>>>>>>>
80788>>>>>>>            Move True to SqlScriptArray.bError
80789>>>>>>>            Function_Return SqlScriptArray
80790>>>>>>>        End
80790>>>>>>>>
80790>>>>>>>
80790>>>>>>>        // First decide the size of the script
80790>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
80792>>>>>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
80794>>>>>>>        Close_Input channel iChannel
80796>>>>>>>
80796>>>>>>>        Move (SizeOfArray(uCharData)) to nByteCount
80797>>>>>>>        If (nByteCount  < 1) Begin
80799>>>>>>>            Send Seq_Release_Channel iChannel
80800>>>>>>>            Move True to SqlScriptArray.bError
80801>>>>>>>            Function_Return SqlScriptArray
80802>>>>>>>        End
80802>>>>>>>>
80802>>>>>>>
80802>>>>>>>        // If necessary change the string argument_size
80802>>>>>>>        // Read the script file from memory line-by-line
80802>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
80804>>>>>>>            Move 0 to iCount
80805>>>>>>>            Repeat
80805>>>>>>>>
80805>>>>>>>                Readln channel iChannel sSQLScript
80807>>>>>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
80808>>>>>>>                Increment iCount
80809>>>>>>>            Until (SeqEof = True)
80811>>>>>>>        Close_Input channel iChannel
80813>>>>>>>        Send Seq_Release_Channel iChannel
80814>>>>>>>
80814>>>>>>>        // Finally "sanitize" the script by removing all comments.
80814>>>>>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
80815>>>>>>>
80815>>>>>>>        Function_Return SqlScriptArray
80816>>>>>>>    End_Function
80817>>>>>>>
80817>>>>>>>    Function SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
80819>>>>>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
80819>>>>>>>        Handle hoSql hoSQLConnect hoStmt hoError
80819>>>>>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage iPos
80819>>>>>>>        String[] sMsg aSQLQueryMessages
80821>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd
80821>>>>>>>        TimeSpan tsQuery
80821>>>>>>>        tSqlErrorArray aSqlErrorArray
80821>>>>>>>        tSqlErrorArray aSqlErrorArray
80821>>>>>>>        tSQLConnection SQLConnection
80821>>>>>>>        tSQLConnection SQLConnection
80821>>>>>>>        Boolean bMertechDriver bShowProgress
80821>>>>>>>
80821>>>>>>>        If (num_arguments > 4) Begin
80823>>>>>>>            Move bShowProgr to bShowProgress
80824>>>>>>>        End
80824>>>>>>>>
80824>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
80825>>>>>>>        If (bMertechDriver = False) Begin
80827>>>>>>>            Get phoSQLManager to hoSql
80828>>>>>>>        End
80828>>>>>>>>
80828>>>>>>>        Else Begin
80829>>>>>>>            Get _MertechSQLManagerHandle to hoSql
80830>>>>>>>        End
80830>>>>>>>>
80830>>>>>>>
80830>>>>>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
80831>>>>>>>        // There seems to be a problem to pass strings when their value gets really big, aka
80831>>>>>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
80831>>>>>>>        // or later SqlExecDirect stops working correctly with no error messages!
80831>>>>>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
80831>>>>>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
80831>>>>>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
80831>>>>>>>        Get piChunkMax to iChunkMax
80832>>>>>>>        Move 0 to iChunkCounter
80833>>>>>>>        Move "" to sStmt
80834>>>>>>>
80834>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
80835>>>>>>>        Move (Character(13) + Character(10)) to sCR
80836>>>>>>>
80836>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
80837>>>>>>>
80837>>>>>>>        If (bMertechDriver = True) Begin
80839>>>>>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
80840>>>>>>>        End
80840>>>>>>>>
80840>>>>>>>        If (bMertechDriver = False) Begin
80842>>>>>>>            Get phoSQLManager  to hoSQL
80843>>>>>>>            If (sDriverID = ODBC_DRV_ID) Begin
80845>>>>>>>                If (Uppercase(SQLConnection.sConnectionString) contains CS_SQLIniDSNKeyword) Begin
80847>>>>>>>                    Move (Pos(";", SQLConnection.sConnectionString)) to iPos
80848>>>>>>>                    If (iPos > 0) Begin
80850>>>>>>>                        Move (Left(SQLConnection.sConnectionString, (iPos - 1))) to SQLConnection.sConnectionString
80851>>>>>>>                        Move (Trim(SQLConnection.sConnectionString)) to SQLConnection.sConnectionString
80852>>>>>>>                    End
80852>>>>>>>>
80852>>>>>>>                End
80852>>>>>>>>
80852>>>>>>>            End
80852>>>>>>>>
80852>>>>>>>            Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
80853>>>>>>>            Get SqlConnect     of hoSQL "" "" to hoSQLConnect
80854>>>>>>>        End
80854>>>>>>>>
80854>>>>>>>
80854>>>>>>>        If (hoSQLConnect <> 0) Begin
80856>>>>>>>            Move False to Err
80857>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
80858>>>>>>>            If (hoStmt <> 0) Begin
80860>>>>>>>
80860>>>>>>>                // If the embedded resource should be written as a script file to disk:
80860>>>>>>>                If (bCreateScriptFile = True) Begin
80862>>>>>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
80863>>>>>>>                    Get vFolderFormat sExportFile to sExportFile
80864>>>>>>>                    Move (sExportFile + sMemFileName) to sExportFile
80865>>>>>>>                    Get Seq_New_Channel to iOut
80866>>>>>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
80868>>>>>>>                        Direct_Output channel iOut sExportFile
80870>>>>>>>                    End
80870>>>>>>>>
80870>>>>>>>                End
80870>>>>>>>>
80870>>>>>>>
80870>>>>>>>                // Record starting date/time stamp
80870>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
80871>>>>>>>                // Turn on error handling if enabled
80871>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
80873>>>>>>>                    Set pbSqlError to False
80874>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
80875>>>>>>>                    Move Error_Object_Id to hoError
80876>>>>>>>                    Move Self to Error_Object_Id
80877>>>>>>>                End
80877>>>>>>>>
80877>>>>>>>
80877>>>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
80878>>>>>>>                Decrement iRows
80879>>>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
80881>>>>>>>                    Move (sNoCountKeyWord + sCR) to sStmt
80882>>>>>>>                End
80882>>>>>>>>
80882>>>>>>>
80882>>>>>>>                For iCount from 0 to iRows
80888>>>>>>>>
80888>>>>>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
80889>>>>>>>
80889>>>>>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
80891>>>>>>>                        If (sSQLVal <> "") Begin
80893>>>>>>>                            Move (sSQLVal + sCR) to sSQLVal
80894>>>>>>>                        End
80894>>>>>>>>
80894>>>>>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
80895>>>>>>>                    End
80895>>>>>>>>
80895>>>>>>>
80895>>>>>>>                    // - Each time we encounter a "GO" statement we execute it,
80895>>>>>>>                    // or if at the very end of the script.
80895>>>>>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
80897>>>>>>>
80897>>>>>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
80897>>>>>>>                        // instead of all in one go.
80897>>>>>>>                        Send SqlExecDirect of hoStmt sStmt
80898>>>>>>>
80898>>>>>>>                        If (bCreateScriptFile = True) Begin
80900>>>>>>>                            Write channel iOut sStmt
80902>>>>>>>                        End
80902>>>>>>>>
80902>>>>>>>                        Move "" to sStmt
80903>>>>>>>                        Move 0 to iChunkCounter
80904>>>>>>>                    End
80904>>>>>>>>
80904>>>>>>>                    Increment iChunkCounter
80905>>>>>>>                Loop
80906>>>>>>>>
80906>>>>>>>
80906>>>>>>>                // ToDo: This sometimes generates a GPF with Mertech drivers;
80906>>>>>>>                //       so not used for now.
80906>>>>>>>                If (bMertechDriver = False) Begin
80908>>>>>>>                    Repeat
80908>>>>>>>>
80908>>>>>>>                        If (pbHandleQueryErrors(Self)) Begin
80910>>>>>>>                            Move hoError to Error_Object_Id
80911>>>>>>>                        End
80911>>>>>>>>
80911>>>>>>>                        Move (CurrentDateTime()) to dtQueryExecEnd
80912>>>>>>>
80912>>>>>>>                        Send _SqlColumnInfo hoStmt
80913>>>>>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
80914>>>>>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
80915>>>>>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
80916>>>>>>>                        Set piRows    to iRows
80917>>>>>>>                        Set piRowType to iRowType
80918>>>>>>>
80918>>>>>>>                        If (iMsgs <> 0) Begin
80920>>>>>>>                            If (ghoDbUpdateHandler > 0) Begin
80922>>>>>>>                                Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
80923>>>>>>>                            End
80923>>>>>>>>
80923>>>>>>>                            For i from 1 to iMsgs
80929>>>>>>>>
80929>>>>>>>                                Get SqlGetMessage of hoStmt i to sMessage
80930>>>>>>>                                Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
80931>>>>>>>                                If (bShowProgress = True) Begin
80933>>>>>>>                                    If (Active_State(ghoStatusPanel)) Begin
80935>>>>>>>                                        Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
80936>>>>>>>                                    End
80936>>>>>>>>
80936>>>>>>>                                    Else Begin
80937>>>>>>>                                        Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
80939>>>>>>>                                    End
80939>>>>>>>>
80939>>>>>>>                                End
80939>>>>>>>>
80939>>>>>>>                                Move sMessage to sMsg[SizeOfArray(sMsg)]
80940>>>>>>>                                Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
80941>>>>>>>                            Loop
80942>>>>>>>>
80942>>>>>>>
80942>>>>>>>
80942>>>>>>>                            If (ghoDbUpdateHandler > 0) Begin
80944>>>>>>>                                Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
80945>>>>>>>                            End
80945>>>>>>>>
80945>>>>>>>                            Set paQueryMessages to sMsg
80946>>>>>>>                        End
80946>>>>>>>>
80946>>>>>>>
80946>>>>>>>                        Get SQLNextResultSet of hoStmt to iNextSet
80947>>>>>>>                    Until (iNextSet = 0)
80949>>>>>>>                End
80949>>>>>>>>
80949>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
80950>>>>>>>            End
80950>>>>>>>>
80950>>>>>>>
80950>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
80951>>>>>>>            Set ptsQueryExec to tsQuery
80952>>>>>>>            Send SqlClose of hoStmt
80953>>>>>>>
80953>>>>>>>            If (bCreateScriptFile = True) Begin
80955>>>>>>>                Close_Output channel iOut
80957>>>>>>>                Send Seq_Release_Channel iOut
80958>>>>>>>            End
80958>>>>>>>>
80958>>>>>>>        End
80958>>>>>>>>
80958>>>>>>>        Send SqlDisconnect of hoSQLConnect
80959>>>>>>>
80959>>>>>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
80960>>>>>>>    End_Function
80961>>>>>>>
80961>>>>>>>    // * Dummy function for the Studio's Code Explorer *
80961>>>>>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
80963>>>>>>>        Function_Return False
80964>>>>>>>    End_Function
80965>>>>>>>
80965>>>>>>>    // Does three things with auxilirary files;
80965>>>>>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
80965>>>>>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
80965>>>>>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
80965>>>>>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
80967>>>>>>>        String sDataPath sDDSrcPath sDriverID
80967>>>>>>>        Boolean bOK bExists bMertechDriver
80967>>>>>>>        Integer iCount iCh iPos
80967>>>>>>>
80967>>>>>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
80967>>>>>>>        If (sTableName contains ".") Begin
80969>>>>>>>            Move (Pos(".", sTableName)) to iPos
80970>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
80971>>>>>>>        End
80971>>>>>>>>
80971>>>>>>>
80971>>>>>>>        Get psDriverID to sDriverID
80972>>>>>>>        Get psDataPathFirstPart to sDataPath
80973>>>>>>>        Get vFolderExists sDataPath to bOK
80974>>>>>>>        If (bOK = False) Begin
80976>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
80977>>>>>>>>
80977>>>>>>>            Function_Return False
80978>>>>>>>        End
80978>>>>>>>>
80978>>>>>>>
80978>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
80979>>>>>>>        // First delete the cache file:
80979>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
80980>>>>>>>
80980>>>>>>>        Get Seq_New_Channel to iCh
80981>>>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
80983>>>>>>>            Function_Return False
80984>>>>>>>        End
80984>>>>>>>>
80984>>>>>>>
80984>>>>>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
80985>>>>>>>        If (bExists = False) Begin
80987>>>>>>>            Function_Return False
80988>>>>>>>        End
80988>>>>>>>>
80988>>>>>>>
80988>>>>>>>        Get SqlUtilUpdateIntFile hTable to bOK
80989>>>>>>>        // Add the new column name to the .tag filen (if it doesn't exist):
80989>>>>>>>        Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sColumnName to bOK
80990>>>>>>>
80990>>>>>>>        // If in development environment; output new .fd file:
80990>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
80991>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
80992>>>>>>>        If (iCount > 1) Begin
80994>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
80995>>>>>>>        End
80995>>>>>>>>
80995>>>>>>>        Get vFolderExists sDDSrcPath to bExists
80996>>>>>>>        If (bExists = True) Begin
80998>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
80999>>>>>>>            Move False to Err
81000>>>>>>>            Get AutoConnectionIDLogin to bOK
81001>>>>>>>            If (hTable <> 0) Begin
81003>>>>>>>                Open hTable
81005>>>>>>>            End
81005>>>>>>>>
81005>>>>>>>            Else Begin
81006>>>>>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
81007>>>>>>>            End
81007>>>>>>>>
81007>>>>>>>
81007>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
81010>>>>>>>            If (bOK = True) Begin
81012>>>>>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
81014>>>>>>>            End
81014>>>>>>>>
81014>>>>>>>            If (Err = True) Begin
81016>>>>>>>                Move False to bOK
81017>>>>>>>            End
81017>>>>>>>>
81017>>>>>>>        End
81017>>>>>>>>
81017>>>>>>>
81017>>>>>>>        Function_Return (bOK = True)
81018>>>>>>>    End_Function
81019>>>>>>>
81019>>>>>>>    Function UtilUpdateTAGFile String sFullTAGFileName String sColumnName Returns Boolean
81021>>>>>>>        Integer iChIn iChOut // iCount
81021>>>>>>>        Boolean bExists
81021>>>>>>>        String sExistingColumn
81021>>>>>>>
81021>>>>>>>        Move False to bExists
81022>>>>>>>        Get Seq_New_Channel to iChIn
81023>>>>>>>        Get Seq_New_Channel to iChOut
81024>>>>>>>        If (iChIn = DF_SEQ_CHANNEL_NOT_AVAILABLE or iChOut = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
81026>>>>>>>            Function_Return True
81027>>>>>>>        End
81027>>>>>>>>
81027>>>>>>>
81027>>>>>>>        Move False to Err
81028>>>>>>>        // The following line should also use the channel attribute. (Thank you, Hans van de Laar)
81028>>>>>>>        Direct_Input channel iChIn ("'" + sFullTAGFileName + "'")
81030>>>>>>>        While (not(SeqEof))
81034>>>>>>>            Readln channel iChIn sExistingColumn
81036>>>>>>>            If (Uppercase(sExistingColumn) = Uppercase(sColumnName)) Begin
81038>>>>>>>                Move True to bExists
81039>>>>>>>            End
81039>>>>>>>>
81039>>>>>>>            If (Trim(sExistingColumn) = "") Begin
81041>>>>>>>                Move True to SeqEof
81042>>>>>>>            End
81042>>>>>>>>
81042>>>>>>>        Loop
81043>>>>>>>>
81043>>>>>>>        Close_Input channel iChIn
81045>>>>>>>        Send Seq_Release_Channel iChIn
81046>>>>>>>
81046>>>>>>>        If (bExists = False) Begin
81048>>>>>>>            Append_Output channel iChOut sFullTAGFileName
81050>>>>>>>            Writeln channel iChOut sColumnName
81053>>>>>>>            Close_Output channel iChOut
81055>>>>>>>            Send Seq_Release_Channel iChOut
81056>>>>>>>        End
81056>>>>>>>>
81056>>>>>>>
81056>>>>>>>        Function_Return (Err = False)
81057>>>>>>>    End_Function
81058>>>>>>>
81058>>>>>>>    // Message for changing .int files to use connection ID's
81058>>>>>>>    //
81058>>>>>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
81058>>>>>>>    // OR changes an existing connection id to a new id.
81058>>>>>>>    // Pass the full path to the data folder and the name of the connection id (string value).
81058>>>>>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
81058>>>>>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
81060>>>>>>>        String sFileName sDriverID sDriverFile sConnectionString
81060>>>>>>>        String[] sFilesData
81061>>>>>>>        Boolean bOK bCancel
81061>>>>>>>        Integer iSize iCount
81061>>>>>>>
81061>>>>>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
81062>>>>>>>        Move (SizeOfArray(sFilesData))    to iSize
81063>>>>>>>        If (iSize = 0) Begin
81065>>>>>>>            If (ghoStatusPanel <> 0) Begin
81067>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
81069>>>>>>>                    Send Stop_StatusPanel of ghoStatusPanel
81070>>>>>>>                End
81070>>>>>>>>
81070>>>>>>>            End
81070>>>>>>>>
81070>>>>>>>            Send Info_Box CS_DUF_NoIntFilesFound
81071>>>>>>>            Procedure_Return
81072>>>>>>>        End
81072>>>>>>>>
81072>>>>>>>
81072>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
81073>>>>>>>        Get vFolderFormat sDataPath to sDataPath
81074>>>>>>>        Decrement iSize
81075>>>>>>>        For iCount from 0 to iSize
81081>>>>>>>>
81081>>>>>>>            Move sFilesData[iCount] to sFileName
81082>>>>>>>            // This makes sure that we also can change an existing connection id to something new:
81082>>>>>>>            Get UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
81083>>>>>>>            If (ghoStatusPanel <> 0) Begin
81085>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
81087>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
81088>>>>>>>                    If (bCancel = True) Begin
81090>>>>>>>                        Send Deactivate of ghoStatusPanel
81091>>>>>>>                        Procedure_Return
81092>>>>>>>                    End
81092>>>>>>>>
81092>>>>>>>                End
81092>>>>>>>>
81092>>>>>>>            End
81092>>>>>>>>
81092>>>>>>>        Loop
81093>>>>>>>>
81093>>>>>>>
81093>>>>>>>        Get psDriverID to sDriverID
81094>>>>>>>
81094>>>>>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
81094>>>>>>>        Move "" to sFileName
81095>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
81097>>>>>>>            Move "MSSQLDrv.int" to sFileName
81098>>>>>>>        End
81098>>>>>>>>
81098>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
81100>>>>>>>            Move "DB2_Drv.int" to sFileName
81101>>>>>>>        End
81101>>>>>>>>
81101>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
81103>>>>>>>            Move "ODBC_Drv.int" to sFileName
81104>>>>>>>        End
81104>>>>>>>>
81104>>>>>>>        If (sFileName <> "") Begin
81106>>>>>>>            Move "" to sDriverFile
81107>>>>>>>            Get_File_Path sFileName to sDriverFile
81108>>>>>>>            If (sDriverFile <> "") Begin
81110>>>>>>>                Get psConnectionString to sConnectionString
81111>>>>>>>                Get UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
81112>>>>>>>            End
81112>>>>>>>>
81112>>>>>>>        End
81112>>>>>>>>
81112>>>>>>>    End_Procedure
81113>>>>>>>
81113>>>>>>>    // Checks if the database exists in SQL. Returns = True if it does.
81113>>>>>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
81115>>>>>>>        String[] sDatabaseArray
81116>>>>>>>        String sVal sServer sDriverID
81116>>>>>>>        Integer iCount iSize iPos
81116>>>>>>>        Boolean bExists
81116>>>>>>>        tSQLConnection SQLConnection
81116>>>>>>>        tSQLConnection SQLConnection
81116>>>>>>>
81116>>>>>>>        Move False to bExists
81117>>>>>>>        Get psDriverID to sDriverID
81118>>>>>>>        // DB2 doesn't have a "Database" name, so we always return True.
81118>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
81120>>>>>>>            Function_Return bExists
81121>>>>>>>        End
81121>>>>>>>>
81121>>>>>>>
81121>>>>>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
81122>>>>>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
81124>>>>>>>            Function_Return False
81125>>>>>>>        End
81125>>>>>>>>
81125>>>>>>>
81125>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81126>>>>>>>        Move SQLConnection.sServer to sServer
81127>>>>>>>
81127>>>>>>>        // Special code to handle a FILEDSN that also can contain "/"
81127>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
81129>>>>>>>            Move sDatabaseArray[0] to sVal  // Dummy!
81130>>>>>>>        End
81130>>>>>>>>
81130>>>>>>>        Else If (sServer contains "/") Begin
81133>>>>>>>            Move (Pos("/", sServer)) to iPos
81134>>>>>>>            Move (Mid(sServer, 999, (iPos +1))) to sDatabase
81135>>>>>>>        End
81135>>>>>>>>
81135>>>>>>>
81135>>>>>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
81136>>>>>>>        Decrement iSize
81137>>>>>>>        For iCount from 0 to iSize
81143>>>>>>>>
81143>>>>>>>            Move sDatabaseArray[iCount] to sVal
81144>>>>>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
81146>>>>>>>                Move True to bExists
81147>>>>>>>                If (bExists = True) Begin
81149>>>>>>>                    Move iSize to iCount // We're done.
81150>>>>>>>                End
81150>>>>>>>>
81150>>>>>>>            End
81150>>>>>>>>
81150>>>>>>>        Loop
81151>>>>>>>>
81151>>>>>>>
81151>>>>>>>        Function_Return bExists
81152>>>>>>>    End_Function
81153>>>>>>>
81153>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
81153>>>>>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
81155>>>>>>>        String sDatabase sSchema sTableName sVal
81155>>>>>>>        Boolean bExists
81155>>>>>>>        String[] sTablesArray
81156>>>>>>>        Integer iSize iCount
81156>>>>>>>
81156>>>>>>>        Move False to bExists
81157>>>>>>>        Get UtilTableHandleToString hTable to sTableName
81158>>>>>>>        Get psDatabase to sDatabase
81159>>>>>>>        Get psSchema   to sSchema
81160>>>>>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
81161>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
81162>>>>>>>        Decrement iSize
81163>>>>>>>        For iCount from 0 to iSize
81169>>>>>>>>
81169>>>>>>>            Move sTablesArray[iCount] to sVal
81170>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
81172>>>>>>>                Move True to bExists
81173>>>>>>>                Move iSize to iCount // We're done!
81174>>>>>>>            End
81174>>>>>>>>
81174>>>>>>>        Loop
81175>>>>>>>>
81175>>>>>>>
81175>>>>>>>        Function_Return bExists
81176>>>>>>>    End_Function
81177>>>>>>>
81177>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
81177>>>>>>>    Function SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
81179>>>>>>>        String sDatabase sSchema sVal
81179>>>>>>>        Boolean bExists
81179>>>>>>>        String[] sTablesArray
81180>>>>>>>        Integer iSize iCount
81180>>>>>>>
81180>>>>>>>        Move False to bExists
81181>>>>>>>        Get psDatabase to sDatabase
81182>>>>>>>        Get psSchema   to sSchema
81183>>>>>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
81184>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
81185>>>>>>>        Decrement iSize
81186>>>>>>>        For iCount from 0 to iSize
81192>>>>>>>>
81192>>>>>>>            Move sTablesArray[iCount] to sVal
81193>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
81195>>>>>>>                Move True to bExists
81196>>>>>>>                Move iSize to iCount // We're done!
81197>>>>>>>            End
81197>>>>>>>>
81197>>>>>>>        Loop
81198>>>>>>>>
81198>>>>>>>
81198>>>>>>>        Function_Return bExists
81199>>>>>>>    End_Function
81200>>>>>>>
81200>>>>>>>    Function SqlUtilCheckIfTableNameSpelling String sDriverID String sDatabase String sTableName String sSchema Returns String
81202>>>>>>>        String sVal sTableSpelledCorrectly
81202>>>>>>>        Boolean bExists
81202>>>>>>>        String[] sTablesArray
81203>>>>>>>        Integer iSize iCount
81203>>>>>>>
81203>>>>>>>        Move False to bExists
81204>>>>>>>        Move sTableName to sTableSpelledCorrectly
81205>>>>>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
81206>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
81207>>>>>>>        Decrement iSize
81208>>>>>>>        For iCount from 0 to iSize
81214>>>>>>>>
81214>>>>>>>            Move sTablesArray[iCount] to sVal
81215>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
81217>>>>>>>                Move sVal to sTableSpelledCorrectly
81218>>>>>>>                Move iSize to iCount // We're done!
81219>>>>>>>            End
81219>>>>>>>>
81219>>>>>>>        Loop
81220>>>>>>>>
81220>>>>>>>
81220>>>>>>>        Function_Return sTableSpelledCorrectly
81221>>>>>>>    End_Function
81222>>>>>>>
81222>>>>>>>    // ToDo: This index name function needs to be finished...
81222>>>>>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
81224>>>>>>>        String sSchema sTableName sDriverID
81224>>>>>>>        Boolean bExists
81224>>>>>>>
81224>>>>>>>        Get psDriverID to sDriverID
81225>>>>>>>        Get psSchema to sSchema
81226>>>>>>>        Get UtilTableHandleToString hTable to sTableName
81227>>>>>>>
81227>>>>>>>        Function_Return bExists
81228>>>>>>>    End_Function
81229>>>>>>>
81229>>>>>>>    // Checks if a column/field name exists in a SQL table definition
81229>>>>>>>    // Returns True if it does
81229>>>>>>>    // Sample:
81229>>>>>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
81229>>>>>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
81231>>>>>>>        Integer iNumColumns iColumn
81231>>>>>>>        String sColumn sDriverID
81231>>>>>>>        String[] sColumnsArray
81232>>>>>>>        Boolean bExists bOK
81232>>>>>>>
81232>>>>>>>        Move False to bExists
81233>>>>>>>        Get AutoConnectionIDLogin to bOK
81234>>>>>>>        Get psDriverID to sDriverID
81235>>>>>>>
81235>>>>>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
81236>>>>>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
81237>>>>>>>        Decrement iNumColumns
81238>>>>>>>        For iColumn from 0 to iNumColumns
81244>>>>>>>>
81244>>>>>>>            Move sColumnsArray[iColumn] to sColumn
81245>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
81247>>>>>>>                Move True to bExists
81248>>>>>>>                Move iNumColumns to iColumn // We're out of here
81249>>>>>>>            End
81249>>>>>>>>
81249>>>>>>>        Loop
81250>>>>>>>>
81250>>>>>>>
81250>>>>>>>        Function_Return bExists
81251>>>>>>>    End_Function
81252>>>>>>>
81252>>>>>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
81254>>>>>>>        Integer iNumColumns iColumn iDFType iNativeType
81254>>>>>>>        Boolean bOpened bOK
81254>>>>>>>        String sColumnName sNativeTypeName
81254>>>>>>>
81254>>>>>>>        Get AutoConnectionIDLogin to bOK
81255>>>>>>>        Get OpenTableExclusive hTable to bOK
81256>>>>>>>        If (bOK = False) Begin
81258>>>>>>>            Function_Return False
81259>>>>>>>        End
81259>>>>>>>>
81259>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
81262>>>>>>>        If (bOpened = False) Begin
81264>>>>>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
81265>>>>>>>>
81265>>>>>>>            Function_Return False
81266>>>>>>>        End
81266>>>>>>>>
81266>>>>>>>
81266>>>>>>>        Move False to Err
81267>>>>>>>
81267>>>>>>>        Structure_Start hTable
81268>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
81271>>>>>>>
81271>>>>>>>            For iColumn from 1 to iNumColumns
81277>>>>>>>>
81277>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
81280>>>>>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
81283>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
81286>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
81289>>>>>>>
81289>>>>>>>                Case Begin
81289>>>>>>>                    Case (iDFType = DF_DATE)
81291>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
81293>>>>>>>                            // Convert datetime to date
81293>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
81296>>>>>>>                        End
81296>>>>>>>>
81296>>>>>>>                        Case Break
81297>>>>>>>                    Case (iDFType = DF_DATETIME)
81300>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
81302>>>>>>>                            // Convert datetime to datetime2
81302>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
81305>>>>>>>                        End
81305>>>>>>>>
81305>>>>>>>                        Case Break
81306>>>>>>>                    Case (iDFType = DF_ASCII)
81309>>>>>>>                        If (iNativeType = SQL_CHAR) Begin
81311>>>>>>>                            // Convert char to varchar
81311>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
81314>>>>>>>                        End
81314>>>>>>>>
81314>>>>>>>                        Case Break
81315>>>>>>>                    Case (iDFType = DF_TEXT)
81318>>>>>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
81320>>>>>>>                            // Convert text to varchar(max)
81320>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
81323>>>>>>>                        End
81323>>>>>>>>
81323>>>>>>>                        Case Break
81324>>>>>>>                    Case (iDFType = DF_BINARY)
81327>>>>>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
81329>>>>>>>                            // Convert image to varbinary(max)
81329>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
81332>>>>>>>                        End
81332>>>>>>>>
81332>>>>>>>                        Case Break
81333>>>>>>>                Case End
81333>>>>>>>            Loop
81334>>>>>>>>
81334>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
81335>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
81337>>>>>>>
81337>>>>>>>        Set Action_Text of ghoStatusPanel to ""
81338>>>>>>>        Function_Return (Err = False)
81339>>>>>>>    End_Function
81340>>>>>>>
81340>>>>>>>
81340>>>>>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
81340>>>>>>>    // the DbUpdateVersion database revision in.
81340>>>>>>>    // Also pass the file number of the current (embedded?) table number used in development.
81340>>>>>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
81340>>>>>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
81342>>>>>>>        Boolean bOK bOpened
81342>>>>>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
81342>>>>>>>
81342>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
81345>>>>>>>        Get _TableNameOnly sTableName to sTableName
81346>>>>>>>        If (sTableName = "") Begin
81348>>>>>>>            Function_Return False
81349>>>>>>>        End
81349>>>>>>>>
81349>>>>>>>
81349>>>>>>>        // This just creates the table and a "dummy" column.
81349>>>>>>>        Get SqlTableCreate hTable sDriverID to bOK
81350>>>>>>>        If (bOK = False) Begin
81352>>>>>>>            Function_Return False
81353>>>>>>>        End
81353>>>>>>>>
81353>>>>>>>
81353>>>>>>>        Close hTable
81354>>>>>>>        Move False to Err
81355>>>>>>>
81355>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
81356>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
81357>>>>>>>        Move "Decimal" to sDataType
81358>>>>>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
81359>>>>>>>
81359>>>>>>>        // Adds the "sColumnName" passed to the function
81359>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
81360>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
81361>>>>>>>
81361>>>>>>>        // Now we can delete the dummy column:
81361>>>>>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
81362>>>>>>>
81362>>>>>>>        // Finally, we attach to the newly created table.
81362>>>>>>>        If (Err = False) Begin
81364>>>>>>>            Get ApiTableAttachToSQL hTable True to bOK
81365>>>>>>>        End
81365>>>>>>>>
81365>>>>>>>        Open hTable
81367>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
81370>>>>>>>
81370>>>>>>>        Function_Return (Err = False and bOK = True and bOpened = True)
81371>>>>>>>    End_Function
81372>>>>>>>
81372>>>>>>>    // The table must already exist in the filelist for this function to work.
81372>>>>>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
81372>>>>>>>    Function SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
81374>>>>>>>        Boolean bOK bExists bUseConnectionID bMertech
81374>>>>>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
81374>>>>>>>        String[] sIndexArray
81375>>>>>>>        Integer iCount iCh iSize
81375>>>>>>>
81375>>>>>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
81376>>>>>>>        Get psConnectionString to sConnectionString
81377>>>>>>>
81377>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
81378>>>>>>>        If (bANSI = False) Begin
81380>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
81381>>>>>>>        End
81381>>>>>>>>
81381>>>>>>>
81381>>>>>>>        Get psDataPathFirstPart to sDataPath
81382>>>>>>>        Get vFolderExists sDataPath to bOK
81383>>>>>>>        If (bOK = False) Begin
81385>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilCreateIntFile; psDataPath not found!"
81386>>>>>>>>
81386>>>>>>>            Function_Return False
81387>>>>>>>        End
81387>>>>>>>>
81387>>>>>>>        Get vFolderFormat sDataPath to sDataPath
81388>>>>>>>
81388>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
81391>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
81394>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
81395>>>>>>>        Move sLogicalName  to sPhysicalFileName
81396>>>>>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
81397>>>>>>>
81397>>>>>>>        Get IsMertechDriver sDriverID to bMertech
81398>>>>>>>        If (bMertech = True) Begin
81400>>>>>>>            // This should not be called here. Instead it is called by the SqlUtilUpdateIntFile!
81400>>>>>>>            // Else it will create an error in the error log (although it won't do anything...)
81400>>>>>>>            // Get _MertechSqlUtilCreateIntFile hTable sLogicalName sDataPath sPhysicalFileName to bOK
81400>>>>>>>            Function_Return (bOK = True)
81401>>>>>>>        End
81401>>>>>>>>
81401>>>>>>>
81401>>>>>>>        Get psSchema hTable to sSchemaName
81402>>>>>>>        If (sSchemaName = "") Begin
81404>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
81405>>>>>>>        End
81405>>>>>>>>
81405>>>>>>>
81405>>>>>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
81405>>>>>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
81406>>>>>>>        If (bExists = True) Begin
81408>>>>>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
81409>>>>>>>        End
81409>>>>>>>>
81409>>>>>>>
81409>>>>>>>        Get UtilDeleteCacheFile sRootName to bOK
81410>>>>>>>        Get SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
81411>>>>>>>
81411>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
81412>>>>>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
81417>>>>>>>            If (bUseConnectionID = True) Begin
81419>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
81426>>>>>>>            End
81426>>>>>>>>
81426>>>>>>>            Else Begin
81427>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
81434>>>>>>>            End
81434>>>>>>>>
81434>>>>>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
81439>>>>>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
81444>>>>>>>            // There seems to be a new order how these are set from DF19.
81444>>>>>>>            If (bSysFile = True) Begin
81446>>>>>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
81451>>>>>>>            End
81451>>>>>>>>
81451>>>>>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
81456>>>>>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
81461>>>>>>>            If (bSysFile = True) Begin
81463>>>>>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
81468>>>>>>>            End
81468>>>>>>>>
81468>>>>>>>
81468>>>>>>>            If (bSysFile = False) Begin
81470>>>>>>>                Move (SizeOfArray(sIndexArray)) to iSize
81471>>>>>>>                Move (SortArray(sIndexArray)) to sIndexArray
81472>>>>>>>                If (iSize > 0) Begin
81474>>>>>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
81477>>>>>>>                    Writeln channel iCh // Just an empty line
81479>>>>>>>                End
81479>>>>>>>>
81479>>>>>>>                Decrement iSize
81480>>>>>>>                For iCount from 0 to iSize
81486>>>>>>>>
81486>>>>>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
81489>>>>>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
81492>>>>>>>                    Writeln channel iCh
81494>>>>>>>                Loop
81495>>>>>>>>
81495>>>>>>>            End
81495>>>>>>>>
81495>>>>>>>        Send Seq_Close_Channel iCh
81496>>>>>>>
81496>>>>>>>        // Wait a sec for Windows to finish writing the file:
81496>>>>>>>        Sleep 1
81497>>>>>>>
81497>>>>>>>        Function_Return (bOK = True)
81498>>>>>>>    End_Function
81499>>>>>>>
81499>>>>>>>    // Returns a handle to the SQL server associated with the passed driver ID.
81499>>>>>>>    // Pass e.g. the psServer property to determine the current connection server.
81499>>>>>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
81499>>>>>>>    // This handle can be used to obtain attributes about the server, such as default
81499>>>>>>>    // column types.
81499>>>>>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
81501>>>>>>>        Handle hDatabase
81501>>>>>>>        Integer iDriver iServers iCount
81501>>>>>>>        String sValue
81501>>>>>>>
81501>>>>>>>        If (sServer = "") Begin
81503>>>>>>>            Function_Return 0
81504>>>>>>>        End
81504>>>>>>>>
81504>>>>>>>
81504>>>>>>>        Get DriverIndex sDriverID to iDriver
81505>>>>>>>        If (iDriver = 0) Begin
81507>>>>>>>            Function_Return 0
81508>>>>>>>        End
81508>>>>>>>>
81508>>>>>>>
81508>>>>>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
81511>>>>>>>        For iCount from 1 to iServers
81517>>>>>>>>
81517>>>>>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
81520>>>>>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
81522>>>>>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
81525>>>>>>>            End
81525>>>>>>>>
81525>>>>>>>        Loop
81526>>>>>>>>
81526>>>>>>>
81526>>>>>>>        Function_Return hDatabase
81527>>>>>>>    End_Function
81528>>>>>>>
81528>>>>>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
81528>>>>>>>//        String sRootName
81528>>>>>>>//        Boolean bOK
81528>>>>>>>//
81528>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81528>>>>>>>//        Move (sRootName contains sDriverID) to bOK
81528>>>>>>>//
81528>>>>>>>//        Function_Return bOK
81528>>>>>>>//    End_Function
81528>>>>>>>
81528>>>>>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
81528>>>>>>>//        String sDriverID sRootName sDisplayName sSchema sVal
81528>>>>>>>//        Integer iDbType
81528>>>>>>>//        Boolean bOK
81528>>>>>>>//
81528>>>>>>>//        Get UtilIsFilelistEntryDriverBased to bOK
81528>>>>>>>//        If (bOK = True) Begin
81528>>>>>>>//            Function_Return False
81528>>>>>>>//        End
81528>>>>>>>//
81528>>>>>>>//        Get psDriverID to sDriverID
81528>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
81528>>>>>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
81528>>>>>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
81528>>>>>>>//
81528>>>>>>>//        Get psDriverID to sDriverID
81528>>>>>>>//        Get piDbType   to iDbType
81528>>>>>>>//        Get psSchema   to sSchema
81528>>>>>>>//        If (sSchema = "") Begin
81528>>>>>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
81528>>>>>>>//        End
81528>>>>>>>//
81528>>>>>>>//        Move (Uppercase(sDisplayName)) to sVal
81528>>>>>>>//        If (not(sVal contains (sSchema + "."))) Begin
81528>>>>>>>//            If (iDbType = EN_dbTypeDB2) Begin
81528>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
81528>>>>>>>//            End
81528>>>>>>>//            Else Begin
81528>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
81528>>>>>>>//            End
81528>>>>>>>//        End
81528>>>>>>>//
81528>>>>>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
81528>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
81528>>>>>>>//
81528>>>>>>>//        Function_Return True
81528>>>>>>>//    End_Function
81528>>>>>>>
81528>>>>>>>    // Removes all driver identifications (e.g. "MSSQLDRV:MyTable")
81528>>>>>>>    // from the passed filelist.
81528>>>>>>>    // Returns the number of tables affected.
81528>>>>>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
81530>>>>>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
81530>>>>>>>        Integer iRetval
81530>>>>>>>        Handle hTable
81530>>>>>>>
81530>>>>>>>        // We first save the current filelist as the passed filelist name
81530>>>>>>>        // may come from another workspace, to restore it when we're ready.
81530>>>>>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
81533>>>>>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
81536>>>>>>>        Move 0 to hTable
81537>>>>>>>        Move 0 to iRetval
81538>>>>>>>
81538>>>>>>>        Repeat
81538>>>>>>>>
81538>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81541>>>>>>>            If (hTable <> 0) Begin
81543>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
81546>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
81549>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
81552>>>>>>>                Move (Uppercase(sRootName)) to sVal
81553>>>>>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
81555>>>>>>>                    // Prefixes:
81555>>>>>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
81556>>>>>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
81557>>>>>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
81558>>>>>>>                    // Suffixes:
81558>>>>>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
81559>>>>>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
81560>>>>>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
81561>>>>>>>
81561>>>>>>>                    // Change Filelist entry:
81561>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
81564>>>>>>>
81564>>>>>>>                    Move (Lowercase(sDisplayName)) to sVal
81565>>>>>>>                    If (sVal contains "dbo.") Begin
81567>>>>>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
81568>>>>>>>
81568>>>>>>>                        // Change Filelist entry:
81568>>>>>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
81571>>>>>>>                    End
81571>>>>>>>>
81571>>>>>>>                    Increment iRetval
81572>>>>>>>                End
81572>>>>>>>>
81572>>>>>>>            End
81572>>>>>>>>
81572>>>>>>>        Until (hTable = 0)
81574>>>>>>>
81574>>>>>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
81577>>>>>>>
81577>>>>>>>        Function_Return iRetval
81578>>>>>>>    End_Function
81579>>>>>>>
81579>>>>>>>    // To open all Sql based tables in Filelist.cfg
81579>>>>>>>    Procedure SqlUtilOpenAllTables
81581>>>>>>>        Handle hTable
81581>>>>>>>        String sRoot sDriverID
81581>>>>>>>        Boolean bOK
81581>>>>>>>
81581>>>>>>>        Move 0 to hTable
81582>>>>>>>        Move "" to sDriverID
81583>>>>>>>        Get AutoConnectionIDLogin to bOK
81584>>>>>>>
81584>>>>>>>        Repeat
81584>>>>>>>>
81584>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81587>>>>>>>            If (hTable > 0) Begin
81589>>>>>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
81592>>>>>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
81594>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
81597>>>>>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
81599>>>>>>>                        Open hTable
81601>>>>>>>                    End
81601>>>>>>>>
81601>>>>>>>                End
81601>>>>>>>>
81601>>>>>>>            End
81601>>>>>>>>
81601>>>>>>>
81601>>>>>>>        Until (hTable = 0)
81603>>>>>>>    End_Procedure
81604>>>>>>>
81604>>>>>>>//    Function SqlUtilSchemaName Handle hTable Returns String
81604>>>>>>>//        String sRetval sDriverID
81604>>>>>>>//        String sTableName
81604>>>>>>>//        Integer iDbType iIndex
81604>>>>>>>//        Boolean bOK
81604>>>>>>>//
81604>>>>>>>//        Get psDriverID to sDriverID
81604>>>>>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
81604>>>>>>>//        If (hTable = 0 or bOK = False) Begin
81604>>>>>>>//            Function_Return ""
81604>>>>>>>//        End
81604>>>>>>>//
81604>>>>>>>//        Move False to Err
81604>>>>>>>//        Get UtilTableHandleToString hTable to sTableName
81604>>>>>>>//        Get piDbType to iDbType
81604>>>>>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
81604>>>>>>>//        If (iIndex = -1) Begin
81604>>>>>>>//            Function_Return ""
81604>>>>>>>//        End
81604>>>>>>>//
81604>>>>>>>//        Function_Return sRetval
81604>>>>>>>//    End_Function
81604>>>>>>>
81604>>>>>>>    // Checks if the passed Table;
81604>>>>>>>    // 1) Already has a Filelist entry that points to SQL and
81604>>>>>>>    // 2) It has an .int file.
81604>>>>>>>    // If both is True it should already be connected to SQL
81604>>>>>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
81606>>>>>>>        Boolean bExists bRootName
81606>>>>>>>        String sRootName sDataPath
81606>>>>>>>
81606>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81609>>>>>>>        Move (sRootName contains sDriverID) to bRootName
81610>>>>>>>
81610>>>>>>>        Get psDataPathFirstPart to sDataPath
81611>>>>>>>        Get vFolderExists sDataPath to bExists
81612>>>>>>>        If (bExists = False) Begin
81614>>>>>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
81614>>>>>>>            Function_Return False
81615>>>>>>>        End
81615>>>>>>>>
81615>>>>>>>
81615>>>>>>>        Get vFolderFormat sDataPath to sDataPath
81616>>>>>>>        Get _TableNameOnly sRootName to sRootName
81617>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
81618>>>>>>>
81618>>>>>>>        Function_Return (bRootName = True and bExists = True)
81619>>>>>>>    End_Function
81620>>>>>>>
81620>>>>>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
81622>>>>>>>        Boolean bViewTableType bOpen bOK
81622>>>>>>>        Integer iTableCount iNumTables
81622>>>>>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
81622>>>>>>>        Handle hoCliHandler
81622>>>>>>>        tSQLConnection SQLConnection
81622>>>>>>>        tSQLConnection SQLConnection
81622>>>>>>>
81622>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
81625>>>>>>>        If (bOpen = False) Begin
81627>>>>>>>            Get AutoConnectionIDLogin to bOK
81628>>>>>>>            Open hTable
81630>>>>>>>        End
81630>>>>>>>>
81630>>>>>>>
81630>>>>>>>        Get pSQLConnection to SQLConnection
81631>>>>>>>        Get phoCLIHandler to hoCliHandler
81632>>>>>>>        Set psDriverID of hoCliHandler to sDriverID
81633>>>>>>>
81633>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
81636>>>>>>>        Get _TableNameOnly sTableName to sTableName
81637>>>>>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
81640>>>>>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
81641>>>>>>>
81641>>>>>>>        For iTableCount from 1 to iNumTables
81647>>>>>>>>
81647>>>>>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
81648>>>>>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
81649>>>>>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
81651>>>>>>>                Get TableType of hoCliHandler iTableCount to sTableType
81652>>>>>>>                Move iNumTables to iTableCount // We're done.
81653>>>>>>>            End
81653>>>>>>>>
81653>>>>>>>        Loop
81654>>>>>>>>
81654>>>>>>>
81654>>>>>>>        Move (sTableType = "VIEW") to bViewTableType
81655>>>>>>>        If (bOpen = False) Begin
81657>>>>>>>            Close hTable
81658>>>>>>>        End
81658>>>>>>>>
81658>>>>>>>
81658>>>>>>>        Function_Return bViewTableType
81659>>>>>>>    End_Function
81660>>>>>>>
81660>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
81660>>>>>>>    //
81660>>>>>>>    // SQL utility function that returns a database type (string) constant
81660>>>>>>>    // corresponding to the passed iDbType.
81660>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
81662>>>>>>>        String sRetval
81662>>>>>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
81663>>>>>>>        Function_Return sRetval
81664>>>>>>>    End_Function
81665>>>>>>>
81665>>>>>>>    // SQL utility function that returns a database type constant (integer)
81665>>>>>>>    // corresponding to the passed sDbType string constant.
81665>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
81667>>>>>>>        Integer iRetval
81667>>>>>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
81668>>>>>>>        Function_Return iRetval
81669>>>>>>>    End_Function
81670>>>>>>>
81670>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
81670>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
81670>>>>>>>    // the SQL Connection program's grid.
81670>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
81672>>>>>>>        String sRetval
81672>>>>>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
81673>>>>>>>        Function_Return sRetval
81674>>>>>>>    End_Function
81675>>>>>>>
81675>>>>>>>    // Pass a driver name as a string and the function will return
81675>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
81675>>>>>>>    // quite work and always returns "MS SQL Server"
81675>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
81677>>>>>>>        Integer iRetval
81677>>>>>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
81678>>>>>>>        Function_Return iRetval
81679>>>>>>>    End_Function
81680>>>>>>>
81680>>>>>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
81680>>>>>>>    // that "fits" in the max allowed length for table names.
81680>>>>>>>    // Max number of characters allowed for table names;
81680>>>>>>>    // IBM DB2      = 128
81680>>>>>>>    // MS-SQL       = 128
81680>>>>>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
81680>>>>>>>    // MySQL        = 64
81680>>>>>>>    // PostgreSQL   = 64
81680>>>>>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
81682>>>>>>>        String sGUIDName
81682>>>>>>>        Integer iDbType iLength
81682>>>>>>>
81682>>>>>>>        Get piDbType to iDbType
81683>>>>>>>        Move (RandomHexUUID()) to sGUIDName
81684>>>>>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
81685>>>>>>>        Move (Length(sGUIDName)) to iLength
81686>>>>>>>
81686>>>>>>>        Case Begin
81686>>>>>>>            Case (iDbType = EN_DbTypeDB2)
81688>>>>>>>            If (iLength > 128) Begin
81690>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
81691>>>>>>>            End
81691>>>>>>>>
81691>>>>>>>            Case Break
81692>>>>>>>
81692>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
81695>>>>>>>            If (iLength > 128) Begin
81697>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
81698>>>>>>>            End
81698>>>>>>>>
81698>>>>>>>            Case Break
81699>>>>>>>
81699>>>>>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
81702>>>>>>>            If (iLength > 128) Begin
81704>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
81705>>>>>>>            End
81705>>>>>>>>
81705>>>>>>>            Case Break
81706>>>>>>>
81706>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
81709>>>>>>>            If (iLength > 64) Begin
81711>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
81712>>>>>>>            End
81712>>>>>>>>
81712>>>>>>>            Case Break
81713>>>>>>>
81713>>>>>>>            Case (iDbType = EN_DbTypePostgre)
81716>>>>>>>            If (iLength > 64) Begin
81718>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
81719>>>>>>>            End
81719>>>>>>>>
81719>>>>>>>        Case End
81719>>>>>>>
81719>>>>>>>        Function_Return sGUIDName
81720>>>>>>>    End_Function
81721>>>>>>>
81721>>>>>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
81721>>>>>>>    // Pass the memory resource file reference and the filename to be created,
81721>>>>>>>    // including full path.
81721>>>>>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
81723>>>>>>>        String sText
81723>>>>>>>        Integer iCh iSize iArgSize
81723>>>>>>>
81723>>>>>>>        Move ("Resource:" + sMemFileName) to sMemFileName
81724>>>>>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
81725>>>>>>>        Get_Channel_Size iCh to iSize
81726>>>>>>>        Read_Block channel iCh sText iSize
81728>>>>>>>        Send Seq_Close_Channel iCh
81729>>>>>>>
81729>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
81730>>>>>>>            Write channel iCh sText
81732>>>>>>>        Send Seq_Close_Channel iCh
81733>>>>>>>
81733>>>>>>>        // Wait for file to be written to disk.
81733>>>>>>>        Sleep 2
81734>>>>>>>    End_Procedure
81735>>>>>>>
81735>>>>>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
81737>>>>>>>        String sNotNull sRetval sDefaultValue
81737>>>>>>>        Boolean bOK
81737>>>>>>>
81737>>>>>>>        Get IsSQLDriver sDriverID to bOK
81738>>>>>>>        If (bOK = False) Begin
81740>>>>>>>            Function_Return ""
81741>>>>>>>        End
81741>>>>>>>>
81741>>>>>>>
81741>>>>>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
81742>>>>>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
81743>>>>>>>
81743>>>>>>>        Case Begin
81743>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
81745>>>>>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
81746>>>>>>>                Case Break
81747>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
81750>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
81751>>>>>>>                Case Break
81752>>>>>>>            Case (iDbType = EN_dbTypePostgre)
81755>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
81756>>>>>>>                Case Break
81757>>>>>>>            Case (iDbType = EN_dbTypeDB2)
81760>>>>>>>                Move (String(sNotNull))                                     to sRetval
81761>>>>>>>                Case Break
81762>>>>>>>
81762>>>>>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
81762>>>>>>>            // ToDo: We need to look deeper into how Oracle handles NULL
81762>>>>>>>            Case (iDbType = EN_dbTypeOracle)
81765>>>>>>>                Move  ""                                                    to sRetval
81766>>>>>>>                Case Break
81767>>>>>>>
81767>>>>>>>            Case Else
81767>>>>>>>                Move  ""                                                    to sRetval
81768>>>>>>>        Case End
81768>>>>>>>
81768>>>>>>>        Function_Return sRetval
81769>>>>>>>    End_Function
81770>>>>>>>
81770>>>>>>>    Function SqlUtilUpdateIntFile Integer hTable Returns Boolean
81772>>>>>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
81772>>>>>>>        Boolean bOpened bOK bMertech
81772>>>>>>>
81772>>>>>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
81772>>>>>>>        // which makes the program unable to run because they can't be opened.
81772>>>>>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
81772>>>>>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
81772>>>>>>>        // proper .int files for the two tables.
81772>>>>>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
81774>>>>>>>            Function_Return True
81775>>>>>>>        End
81775>>>>>>>>
81775>>>>>>>
81775>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81778>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
81779>>>>>>>        Move CS_OEM_Txt  to sOrgFormat
81780>>>>>>>        Move CS_ANSI_Txt to sNewFormat
81781>>>>>>>        Get AutoConnectionIDLogin to bOK
81782>>>>>>>
81782>>>>>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
81782>>>>>>>        Sleep 1
81783>>>>>>>
81783>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
81786>>>>>>>        If (bOpened = False) Begin
81788>>>>>>>            Open hTable
81790>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
81793>>>>>>>        End
81793>>>>>>>>
81793>>>>>>>        If (bOpened = False) Begin
81795>>>>>>>            Function_Return False
81796>>>>>>>        End
81796>>>>>>>>
81796>>>>>>>
81796>>>>>>>        Get psDriverID to sDriverID
81797>>>>>>>        Get IsMertechDriver sDriverID to bMertech
81798>>>>>>>        If (bMertech = True) Begin
81800>>>>>>>            Get psDataPathFirstPart to sDataPath
81801>>>>>>>            Get vFolderExists sDataPath to bOK
81802>>>>>>>            If (bOK = False) Begin
81804>>>>>>>                Error DFERR_PROGRAM "Function SqlUtilUpdateIntFile; psDataPath not found!"
81805>>>>>>>>
81805>>>>>>>                Function_Return False
81806>>>>>>>            End
81806>>>>>>>>
81806>>>>>>>            Get vFolderFormat sDataPath to sDataPath
81807>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81810>>>>>>>            Get _TableNameOnly sRootName to sDatabaseName
81811>>>>>>>            Move sDatabaseName to sPhysicalFileName
81812>>>>>>>            Move (sPhysicalFileName + ".int") to sPhysicalFileName
81813>>>>>>>            Get _MertechSqlUtilCreateIntFile hTable sDatabaseName sDataPath sPhysicalFileName to bOK
81814>>>>>>>            Function_Return (bOK = True)
81815>>>>>>>        End
81815>>>>>>>>
81815>>>>>>>
81815>>>>>>>        Move False to Err
81816>>>>>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81819>>>>>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
81820>>>>>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
81820>>>>>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
81820>>>>>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
81821>>>>>>>
81821>>>>>>>        Move False to Err
81822>>>>>>>
81822>>>>>>>        If (hTable > 0) Begin
81824>>>>>>>            Structure_Start hTable
81825>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81828>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81831>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
81833>>>>>>>        End
81833>>>>>>>>
81833>>>>>>>        Else Begin
81834>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81837>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81840>>>>>>>        End
81840>>>>>>>>
81840>>>>>>>        Function_Return (Err = False)
81841>>>>>>>    End_Function
81842>>>>>>>
81842>>>>>>>    Function SqlProcedureArrayMertech String sStmt String sArgument Returns String[]
81844>>>>>>>        String[] sReturnArray
81845>>>>>>>        String sValue // sUserID sPassword
81845>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
81845>>>>>>>        Integer iFetchResult iRetval
81845>>>>>>>        tSQLConnection SQLConnection
81845>>>>>>>        tSQLConnection SQLConnection
81845>>>>>>>
81845>>>>>>>        Get _MertechSQLManagerHandle to hoSQLHandler
81846>>>>>>>        If (hoSQLHandler <> 0) Begin
81848>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81849>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
81850>>>>>>>            If (hoSQLConnect <> 0) Begin
81852>>>>>>>                Get SQLOpen of hoSQLConnect to hStmt
81853>>>>>>>                If (hStmt <> 0) Begin
81855>>>>>>>                    Send SQLSetProcedureName of hStmt sStmt
81856>>>>>>>                    If (sArgument <> "") Begin
81858>>>>>>>                        Send SqlSetArgument  of hStmt 1 sArgument
81859>>>>>>>                    End
81859>>>>>>>>
81859>>>>>>>                    Send SQLCall of hStmt
81860>>>>>>>
81860>>>>>>>                    Get SqlReturnValue       of hStmt to iRetval
81861>>>>>>>                    If (iRetval = 0) Begin
81863>>>>>>>                        Repeat
81863>>>>>>>>
81863>>>>>>>                            Get SQLFetch of hStmt to iFetchResult
81864>>>>>>>                            If (iFetchResult <> 0) Begin
81866>>>>>>>                                Get SQLColumnValue of hStmt 1 to sValue
81867>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
81868>>>>>>>                            End
81868>>>>>>>>
81868>>>>>>>                        Until (iFetchResult = 0)
81870>>>>>>>                        Send SQLClose of hStmt
81871>>>>>>>                    End
81871>>>>>>>>
81871>>>>>>>                End
81871>>>>>>>>
81871>>>>>>>                Send SQLDisconnect of hoSQLConnect
81872>>>>>>>            End
81872>>>>>>>>
81872>>>>>>>        End
81872>>>>>>>>
81872>>>>>>>
81872>>>>>>>        Function_Return sReturnArray
81873>>>>>>>    End_Function
81874>>>>>>>
81874>>>>>>>    // * Dummy function for the Studio's Code Explorer *
81874>>>>>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
81876>>>>>>>        Function_Return False
81877>>>>>>>    End_Function
81878>>>>>>>
81878>>>>>>>    // Enumerate SQL Servers.
81878>>>>>>>    // Pass a driver id. Returns a string array.
81878>>>>>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
81878>>>>>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
81878>>>>>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
81880>>>>>>>        String[] sReturnArray
81881>>>>>>>        Handle hoSQLHandler
81881>>>>>>>        String sServer
81881>>>>>>>        Integer iCount iNumItems iDataSourceType
81881>>>>>>>
81881>>>>>>>        If (num_arguments > 1) Begin
81883>>>>>>>            Move iDatSrcType to iDataSourceType
81884>>>>>>>        End
81884>>>>>>>>
81884>>>>>>>
81884>>>>>>>        Case Begin
81884>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
81886>>>>>>>                Get phoMSSQLHandler to hoSQLHandler
81887>>>>>>>                Get EnumerateServers of hoSQLHandler to iNumItems
81888>>>>>>>                For iCount from 0 to (iNumItems - 1)
81894>>>>>>>>
81894>>>>>>>                    Get String_Value of hoSQLHandler iCount to sServer
81895>>>>>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
81896>>>>>>>                Loop
81897>>>>>>>>
81897>>>>>>>                Case Break
81898>>>>>>>
81898>>>>>>>            Case (sDriverID = DB2_DRV_ID)
81901>>>>>>>                Get phoDB2SQLHandler to hoSQLHandler
81902>>>>>>>                Send SeedDataSources of hoSQLHandler
81903>>>>>>>                Move 0 to iCount
81904>>>>>>>                Repeat
81904>>>>>>>>
81904>>>>>>>                    Get DataSources of hoSQLHandler to sServer
81905>>>>>>>                    If (sServer <> "") Begin
81907>>>>>>>                        Move (Replace(",", sServer, "")) to sServer
81908>>>>>>>                        Move sServer to sReturnArray[iCount]
81909>>>>>>>                    End
81909>>>>>>>>
81909>>>>>>>                    Increment iCount
81910>>>>>>>                Until (sServer = "")
81912>>>>>>>                Case Break
81913>>>>>>>
81913>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
81916>>>>>>>                Get phoODBCSQLHandler to hoSQLHandler
81917>>>>>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
81918>>>>>>>                Move 0 to iCount
81919>>>>>>>                Repeat
81919>>>>>>>>
81919>>>>>>>                    Get DataSources of hoSQLHandler to sServer
81920>>>>>>>                    If (sServer <> "") Begin
81922>>>>>>>                        Move (Replace(",", sServer, ", ")) to sServer
81923>>>>>>>                        Move sServer to sReturnArray[iCount]
81924>>>>>>>                    End
81924>>>>>>>>
81924>>>>>>>                    Increment iCount
81925>>>>>>>                Until (sServer = "")
81927>>>>>>>                Case Break
81928>>>>>>>
81928>>>>>>>            Case (sDriverID = SQLFLEX)
81931>>>>>>>                Get _MertechEnumerateSQLFlexServers to sReturnArray
81932>>>>>>>                Case Break
81933>>>>>>>
81933>>>>>>>            Case (sDriverID = ORAFLEX)
81936>>>>>>>                Get _MertechEnumerateORAFLEXServers to sReturnArray
81937>>>>>>>                Case Break
81938>>>>>>>
81938>>>>>>>            // There appearantly is no way to enumerate servers for this backend.
81938>>>>>>>            Case (sDriverID = MDSPgSQL)
81941>>>>>>>                Move "localhost" to sReturnArray[0]
81942>>>>>>>                Case Break
81943>>>>>>>
81943>>>>>>>            // There appearantly is no way to enumerate servers for this backend.
81943>>>>>>>            Case (sDriverID = MDSMySQL)
81946>>>>>>>                Move "localhost" to sReturnArray[0]
81947>>>>>>>                Case Break
81948>>>>>>>
81948>>>>>>>            Case Else
81948>>>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
81949>>>>>>>>
81949>>>>>>>        Case End
81949>>>>>>>
81949>>>>>>>        Function_Return sReturnArray
81950>>>>>>>    End_Function
81951>>>>>>>
81951>>>>>>>    // Returns all databases as a string array for the passed driver id.
81951>>>>>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
81953>>>>>>>        String[] sReturnArray
81954>>>>>>>        String sServer sVal
81954>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
81954>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
81955>>>>>>>        tSQLConnection SQLConnection
81955>>>>>>>        tSQLConnection SQLConnection
81955>>>>>>>        Boolean bOK
81955>>>>>>>        Integer iCount iSize
81955>>>>>>>
81955>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
81956>>>>>>>        If (bOK = False) Begin
81958>>>>>>>            Function_Return sReturnArray
81959>>>>>>>        End
81959>>>>>>>>
81959>>>>>>>
81959>>>>>>>        Case Begin
81959>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
81961>>>>>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
81962>>>>>>>                Case Break
81963>>>>>>>            Case (sDriverID = DB2_DRV_ID)
81966>>>>>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
81967>>>>>>>                Case Break
81968>>>>>>>
81968>>>>>>>            // This is needed to be able to check if a database exists or not.
81968>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
81971>>>>>>>                Get _SqlDatabasesArrayODBC to sReturnStructArray
81972>>>>>>>                If (SizeOfArray(sReturnStructArray)) Begin
81974>>>>>>>                    If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
81976>>>>>>>                        // If a FILEDSN: (can only be one database name)
81976>>>>>>>                        Move sReturnStructArray[0].sDatabaseName to sReturnArray[0]
81977>>>>>>>                    End
81977>>>>>>>>
81977>>>>>>>                    Else Begin
81978>>>>>>>                        // Else the DSN's were read from the registry.
81978>>>>>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81979>>>>>>>                        Move SQLConnection.sServer to sServer
81980>>>>>>>                        Move (SizeOfArray(sReturnStructArray)) to iSize
81981>>>>>>>                        Decrement iSize
81982>>>>>>>                        for iCount from 0 to iSize
81988>>>>>>>>
81988>>>>>>>                            Move (sReturnStructArray[iCount].sServerName) to sVal
81989>>>>>>>                            If (Uppercase(sServer) = Uppercase(sVal)) Begin
81991>>>>>>>                                Move sReturnStructArray[iCount].sDatabaseName to sReturnArray[0]
81992>>>>>>>                                Move iSize to iCount // We're done.
81993>>>>>>>                            End
81993>>>>>>>>
81993>>>>>>>                        Loop
81994>>>>>>>>
81994>>>>>>>                    End
81994>>>>>>>>
81994>>>>>>>                End
81994>>>>>>>>
81994>>>>>>>                Case Break
81995>>>>>>>
81995>>>>>>>            Case (sDriverID = SQLFLEX)
81998>>>>>>>                Get SqlProcedureArrayMertech "sp_databases" "" to sReturnArray
81999>>>>>>>                Case Break
82000>>>>>>>
82000>>>>>>>            Case (sDriverID = MDSPgSQL)
82003>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT datname FROM pg_database" to sReturnArray
82004>>>>>>>                Case Break
82005>>>>>>>
82005>>>>>>>            Case (sDriverID = MDSMySQL)
82008>>>>>>>                Get SqlEnumerateEsqlMertech "show databases" to sReturnArray
82009>>>>>>>                Case Break
82010>>>>>>>
82010>>>>>>>            Case (sDriverID = ORAFLEX)
82013>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT NAME FROM v$database" to sReturnArray
82014>>>>>>>                Case Break
82015>>>>>>>
82015>>>>>>>            Case Else
82015>>>>>>>//                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
82015>>>>>>>        Case End
82015>>>>>>>
82015>>>>>>>        Function_Return sReturnArray
82016>>>>>>>    End_Function
82017>>>>>>>
82017>>>>>>>    // Returns all table spaces as a string array for the passed driver id.
82017>>>>>>>    Function SqlUtilEnumerateTableSpaces String sDriverID Returns String[]
82019>>>>>>>        String[] sReturnArray
82020>>>>>>>        Boolean bOK
82020>>>>>>>
82020>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
82021>>>>>>>        If (bOK = False) Begin
82023>>>>>>>            Function_Return sReturnArray
82024>>>>>>>        End
82024>>>>>>>>
82024>>>>>>>
82024>>>>>>>        Case Begin
82024>>>>>>>            Case (sDriverID = DB2_DRV_ID)
82026>>>>>>>                Get SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
82027>>>>>>>                Case Break
82028>>>>>>>
82028>>>>>>>            Case (sDriverID = MDSPgSQL)
82031>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT spcname FROM pg_tablespace" 1 to sReturnArray
82032>>>>>>>                Case Break
82033>>>>>>>
82033>>>>>>>            Case (sDriverID = ORAFLEX)
82036>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT TABLESPACE_NAME FROM USER_TABLESPACES" 1 to sReturnArray
82037>>>>>>>                Case Break
82038>>>>>>>
82038>>>>>>>            Case Else
82038>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTableSpaces function."
82039>>>>>>>>
82039>>>>>>>                Case Break
82040>>>>>>>        Case End
82040>>>>>>>
82040>>>>>>>        Function_Return sReturnArray
82041>>>>>>>    End_Function
82042>>>>>>>
82042>>>>>>>    // Returns all schemas as a string array for the passed driver id.
82042>>>>>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
82044>>>>>>>        String[] sReturnArray
82045>>>>>>>        Boolean bOK
82045>>>>>>>
82045>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
82046>>>>>>>        If (bOK = False) Begin
82048>>>>>>>            Function_Return sReturnArray
82049>>>>>>>        End
82049>>>>>>>>
82049>>>>>>>
82049>>>>>>>        Case Begin
82049>>>>>>>            Case (sDriverID = DB2_DRV_ID)
82051>>>>>>>                Get SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
82052>>>>>>>                Case Break
82053>>>>>>>
82053>>>>>>>            Case (sDriverID = MDSPgSQL)
82056>>>>>>>                Get SqlEnumerateEsqlMertech "select schema_name from information_schema.schemata" 1 to sReturnArray
82057>>>>>>>                Case Break
82058>>>>>>>
82058>>>>>>>            Case (sDriverID = ORAFLEX)
82061>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT username from dba_users WHERE default_tablespace not in ('SYSTEM','SYSAUX')" 1 to sReturnArray
82062>>>>>>>                Case Break
82063>>>>>>>
82063>>>>>>>            Case Else
82063>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
82064>>>>>>>>
82064>>>>>>>                Case Break
82065>>>>>>>        Case End
82065>>>>>>>
82065>>>>>>>        Function_Return sReturnArray
82066>>>>>>>    End_Function
82067>>>>>>>
82067>>>>>>>    // Returns a string array with all tables for the current database.
82067>>>>>>>    Function SqlUtilEnumerateTables String sDriverID String sDatabase String sSchema Returns String[]
82069>>>>>>>        String[] sReturnArray sArray
82071>>>>>>>        String sConnectionString sSelect
82071>>>>>>>        Integer iSize iCount iDbType
82071>>>>>>>        Boolean bOK
82071>>>>>>>
82071>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
82073>>>>>>>            Function_Return sArray
82074>>>>>>>        End
82074>>>>>>>>
82074>>>>>>>
82074>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
82075>>>>>>>        If (bOK = False) Begin
82077>>>>>>>            Function_Return sReturnArray
82078>>>>>>>        End
82078>>>>>>>>
82078>>>>>>>        If (sSchema = "") Begin
82080>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
82081>>>>>>>        End
82081>>>>>>>>
82081>>>>>>>
82081>>>>>>>        Get psConnectionString to sConnectionString
82082>>>>>>>
82082>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
82082>>>>>>>        // the dbType.
82082>>>>>>>        Get piDbType to iDbType
82083>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
82085>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
82087>>>>>>>                Move MDSMySQL to sDriverID
82088>>>>>>>            End
82088>>>>>>>>
82088>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
82090>>>>>>>                Move MSSQLDRV_ID to sDriverID
82091>>>>>>>            End
82091>>>>>>>>
82091>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
82093>>>>>>>                Move DB2_DRV_ID to sDriverID
82094>>>>>>>            End
82094>>>>>>>>
82094>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
82096>>>>>>>                Move MDSPgSQL to sDriverID
82097>>>>>>>            End
82097>>>>>>>>
82097>>>>>>>        End
82097>>>>>>>>
82097>>>>>>>
82097>>>>>>>        Case Begin
82097>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
82099>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
82100>>>>>>>                Case Break
82101>>>>>>>
82101>>>>>>>            Case (sDriverID = DB2_DRV_ID)
82104>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
82105>>>>>>>                Case Break
82106>>>>>>>
82106>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
82109>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
82110>>>>>>>                Case Break
82111>>>>>>>
82111>>>>>>>            Case (sDriverID = SQLFLEX)
82114>>>>>>>                Move ("SELECT TABLE_NAME FROM" * sDatabase + ".INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE != 'VIEW'") to sSelect
82115>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
82116>>>>>>>                Case Break
82117>>>>>>>
82117>>>>>>>            Case (sDriverID = MDSMySQL)
82120>>>>>>>                Move ("SELECT TABLE_NAME from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA = '" + sDatabase + "' and TABLE_TYPE = 'BASE TABLE' order by TABLE_NAME") to sSelect
82121>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
82122>>>>>>>                Case Break
82123>>>>>>>
82123>>>>>>>            Case (sDriverID = MDSPgSQL)
82126>>>>>>>                Move "select tablename, schemaname from pg_catalog.pg_tables order by tablename"  to sSelect
82127>>>>>>>                Get SqlEnumerateEsqlMertech sSelect "" to sReturnArray
82128>>>>>>>                Case Break
82129>>>>>>>
82129>>>>>>>            Case (sDriverID = ORAFLEX)
82132>>>>>>>                Move "SELECT table_name from user_tables" to sSelect
82133>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sArray
82134>>>>>>>                Move (SizeOfArray(sArray)) to iSize
82135>>>>>>>                Decrement iSize
82136>>>>>>>                For iCount from 0 to iSize
82142>>>>>>>>
82142>>>>>>>                    If (not(sArray[iCount] contains "$")) Begin
82144>>>>>>>                        Move sArray[iCount] to sReturnArray[SizeOfArray(sReturnArray)]
82145>>>>>>>                    End
82145>>>>>>>>
82145>>>>>>>                Loop
82146>>>>>>>>
82146>>>>>>>                Case Break
82147>>>>>>>
82147>>>>>>>            Case Else
82147>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTables function."
82148>>>>>>>>
82148>>>>>>>                Case Break
82149>>>>>>>        Case End
82149>>>>>>>
82149>>>>>>>        Function_Return sReturnArray
82150>>>>>>>    End_Function
82151>>>>>>>
82151>>>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
82151>>>>>>>    Function SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
82153>>>>>>>        String[] sReturnArray
82154>>>>>>>        String sConnectionString sSelect sSchema
82154>>>>>>>        Boolean bOK
82154>>>>>>>        Integer iDbType
82154>>>>>>>
82154>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
82155>>>>>>>        If (bOK = False) Begin
82157>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
82158>>>>>>>>
82158>>>>>>>            Function_Return sReturnArray
82159>>>>>>>        End
82159>>>>>>>>
82159>>>>>>>
82159>>>>>>>        Get psConnectionString to sConnectionString
82160>>>>>>>        Get psSchema to sSchema
82161>>>>>>>
82161>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
82161>>>>>>>        // the dbType.
82161>>>>>>>        Get piDbType to iDbType
82162>>>>>>>
82162>>>>>>>        Case Begin
82162>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
82164>>>>>>>                If (iDbType = EN_DbTypeMySQL) Begin
82166>>>>>>>                    Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
82167>>>>>>>                End
82167>>>>>>>>
82167>>>>>>>                If (iDbType = EN_DbTypePostgre) Begin
82169>>>>>>>                    Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
82170>>>>>>>                End
82170>>>>>>>>
82170>>>>>>>                If (iDbType = EN_DbTypeMSSQL) Begin
82172>>>>>>>                    Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
82173>>>>>>>                End
82173>>>>>>>>
82173>>>>>>>
82173>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
82174>>>>>>>                Case Break
82175>>>>>>>
82175>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
82178>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
82179>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
82180>>>>>>>                Case Break
82181>>>>>>>
82181>>>>>>>            Case (sDriverID = DB2_DRV_ID)
82184>>>>>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
82185>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
82186>>>>>>>                Case Break
82187>>>>>>>
82187>>>>>>>            Case (sDriverID = SQLFLEX)
82190>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
82191>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
82192>>>>>>>                Case Break
82193>>>>>>>
82193>>>>>>>            Case (sDriverID = MDSMySQL)
82196>>>>>>>                Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
82197>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
82198>>>>>>>                Case Break
82199>>>>>>>
82199>>>>>>>            Case (sDriverID = MDSPgSQL)
82202>>>>>>>                Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
82203>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
82204>>>>>>>                Case Break
82205>>>>>>>
82205>>>>>>>            Case (sDriverID = ORAFLEX)
82208>>>>>>>                Move ("SELECT column_name from user_tab_cols WHERE table_name = '" + sTableName + "'") to sSelect
82209>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
82210>>>>>>>                Case Break
82211>>>>>>>
82211>>>>>>>            Case Else
82211>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateColumns function."
82212>>>>>>>>
82212>>>>>>>                Case Break
82213>>>>>>>        Case End
82213>>>>>>>
82213>>>>>>>        Function_Return sReturnArray
82214>>>>>>>    End_Function
82215>>>>>>>
82215>>>>>>>
82215>>>>>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
82215>>>>>>>    Function SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
82217>>>>>>>        String[] sReturnArray sReturnArray2
82219>>>>>>>        String sConnectionString sSelect sSchema
82219>>>>>>>        Boolean bOK
82219>>>>>>>        Integer iCount iSize
82219>>>>>>>
82219>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
82220>>>>>>>        If (bOK = False) Begin
82222>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
82223>>>>>>>>
82223>>>>>>>            Function_Return sReturnArray
82224>>>>>>>        End
82224>>>>>>>>
82224>>>>>>>
82224>>>>>>>        Get psConnectionString to sConnectionString
82225>>>>>>>        Get psSchema to sSchema
82226>>>>>>>
82226>>>>>>>        Case Begin
82226>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
82228>>>>>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
82229>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
82230>>>>>>>                Case Break
82231>>>>>>>
82231>>>>>>>            Case (sDriverID = DB2_DRV_ID)
82234>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
82235>>>>>>>>
82235>>>>>>>//                Move () to sSelect
82235>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
82235>>>>>>>                Case Break
82236>>>>>>>
82236>>>>>>>            Case (sDriverID = SQLFLEX)
82239>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
82240>>>>>>>>
82240>>>>>>>//                Move () to sSelect
82240>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
82240>>>>>>>                Case Break
82241>>>>>>>
82241>>>>>>>            Case (sDriverID = MDSMySQL)
82244>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
82245>>>>>>>>
82245>>>>>>>//                Move () to sSelect
82245>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
82245>>>>>>>                Case Break
82246>>>>>>>
82246>>>>>>>            Case (sDriverID = MDSPgSQL)
82249>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
82250>>>>>>>>
82250>>>>>>>//                Move () to sSelect
82250>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
82250>>>>>>>                Case Break
82251>>>>>>>
82251>>>>>>>            Case (sDriverID = ORAFLEX)
82254>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
82255>>>>>>>>
82255>>>>>>>//                Move () to sSelect
82255>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
82255>>>>>>>                Case Break
82256>>>>>>>
82256>>>>>>>            Case Else
82256>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateIndexes function."
82257>>>>>>>>
82257>>>>>>>                Case Break
82258>>>>>>>        Case End
82258>>>>>>>
82258>>>>>>>        Move (SizeOfArray(sReturnArray)) to iSize
82259>>>>>>>        Decrement iSize
82260>>>>>>>        For iCount from 0 to iSize
82266>>>>>>>>
82266>>>>>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
82268>>>>>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
82269>>>>>>>            End
82269>>>>>>>>
82269>>>>>>>        Loop
82270>>>>>>>>
82270>>>>>>>
82270>>>>>>>        Function_Return sReturnArray2
82271>>>>>>>    End_Function
82272>>>>>>>
82272>>>>>>>    // Returns a string array with all table names the passed table handle has relation ships with.
82272>>>>>>>    // The format of the array is "TableName.FieldName"
82272>>>>>>>    Function SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
82274>>>>>>>        String[] sFileNameArray sFieldNameArray
82276>>>>>>>        tSQLRelation[] sRelationsArray
82276>>>>>>>        tSQLRelation[] sRelationsArray
82277>>>>>>>        String sConnectionString sSelect sSchema sFileName sFieldName
82277>>>>>>>        Boolean bOK
82277>>>>>>>        Integer iCount iSize iLength
82277>>>>>>>
82277>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
82278>>>>>>>        If (bOK = False) Begin
82280>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
82281>>>>>>>>
82281>>>>>>>            Function_Return sRelationsArray
82282>>>>>>>        End
82282>>>>>>>>
82282>>>>>>>
82282>>>>>>>        Get psConnectionString to sConnectionString
82283>>>>>>>        Get psSchema to sSchema
82284>>>>>>>
82284>>>>>>>        Case Begin
82284>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
82286>>>>>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
82287>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
82288>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
82289>>>>>>>                Case Break
82290>>>>>>>
82290>>>>>>>            Case (sDriverID = DB2_DRV_ID)
82293>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
82294>>>>>>>>
82294>>>>>>>//                Move () to sSelect
82294>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
82294>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
82294>>>>>>>                Case Break
82295>>>>>>>
82295>>>>>>>            Case (sDriverID = SQLFLEX)
82298>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
82299>>>>>>>>
82299>>>>>>>//                Move () to sSelect
82299>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
82299>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
82299>>>>>>>                Case Break
82300>>>>>>>
82300>>>>>>>            Case (sDriverID = MDSMySQL)
82303>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
82304>>>>>>>>
82304>>>>>>>//                Move () to sSelect
82304>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
82304>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
82304>>>>>>>                Case Break
82305>>>>>>>
82305>>>>>>>            Case (sDriverID = MDSPgSQL)
82308>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
82309>>>>>>>>
82309>>>>>>>//                Move () to sSelect
82309>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
82309>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
82309>>>>>>>                Case Break
82310>>>>>>>
82310>>>>>>>            Case (sDriverID = ORAFLEX)
82313>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
82314>>>>>>>>
82314>>>>>>>//                Move () to sSelect
82314>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
82314>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
82314>>>>>>>                Case Break
82315>>>>>>>
82315>>>>>>>            Case Else
82315>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to the SqlUtilEnumerateRelations function."
82316>>>>>>>>
82316>>>>>>>                Case Break
82317>>>>>>>        Case End
82317>>>>>>>
82317>>>>>>>        Move (Length(sTableName)) to iLength
82318>>>>>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
82319>>>>>>>        Move (SizeOfArray(sFileNameArray)) to iSize
82320>>>>>>>        Decrement iSize
82321>>>>>>>        For iCount from 0 to iSize
82327>>>>>>>>
82327>>>>>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
82329>>>>>>>                Move sFileNameArray[iCount]         to sFileName
82330>>>>>>>                Move sFieldNameArray[iCount]        to sFieldName
82331>>>>>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
82332>>>>>>>                Move sFileName  to sRelationsArray[iCount].sFileName
82333>>>>>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
82334>>>>>>>            End
82334>>>>>>>>
82334>>>>>>>        Loop
82335>>>>>>>>
82335>>>>>>>
82335>>>>>>>        Function_Return sRelationsArray
82336>>>>>>>    End_Function
82337>>>>>>>
82337>>>>>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
82339>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
82339>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
82340>>>>>>>        String[] sUsers sPrograms
82342>>>>>>>        String sSelect
82342>>>>>>>        Integer iSize iCount
82342>>>>>>>
82342>>>>>>>        Case Begin
82342>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
82344>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
82345>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sUsers
82346>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sPrograms
82347>>>>>>>                Case Break
82348>>>>>>>            Case (sDriverID = SQLFLEX)
82351>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
82352>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sUsers
82353>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 2 to sPrograms
82354>>>>>>>                Case Break
82355>>>>>>>            Case Else
82355>>>>>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
82356>>>>>>>>
82356>>>>>>>        Case End
82356>>>>>>>
82356>>>>>>>        Move (SizeOfArray(sUsers)) to iSize
82357>>>>>>>        Decrement iSize
82358>>>>>>>        For iCount from 0 to iSize
82364>>>>>>>>
82364>>>>>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
82365>>>>>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
82366>>>>>>>        Loop
82367>>>>>>>>
82367>>>>>>>
82367>>>>>>>        Function_Return SQLLoggedInUser
82368>>>>>>>    End_Function
82369>>>>>>>
82369>>>>>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
82369>>>>>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
82369>>>>>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
82371>>>>>>>        String[] sFilesData
82372>>>>>>>        Boolean bExists
82372>>>>>>>        Integer iCh
82372>>>>>>>        String sFileName sExt
82372>>>>>>>
82372>>>>>>>        Get vFolderExists sDataPath to bExists
82373>>>>>>>        If (bExists = True) Begin
82375>>>>>>>            Move (Utf8ToAnsi(Trim(sDataPath))) to sDataPath
82376>>>>>>>            Move ("dir:" + sDataPath)      to sDataPath
82377>>>>>>>            Get Seq_New_Channel to iCh  // get free channel for input
82378>>>>>>>            Direct_Input channel iCh sDataPath
82380>>>>>>>                Repeat
82380>>>>>>>>
82380>>>>>>>                    Readln channel iCh sFileName
82382>>>>>>>                    Get ParseFileExtension sFileName to sExt
82383>>>>>>>                    If (Uppercase(sExt) = "INT") Begin
82385>>>>>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
82387>>>>>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
82388>>>>>>>                        End
82388>>>>>>>>
82388>>>>>>>                    End
82388>>>>>>>>
82388>>>>>>>                Until (SeqEof = True)
82390>>>>>>>            Close_Input channel iCh
82392>>>>>>>            Send Seq_Release_Channel iCh
82393>>>>>>>        End
82393>>>>>>>>
82393>>>>>>>        Function_Return sFilesData
82394>>>>>>>    End_Function
82395>>>>>>>
82395>>>>>>>    // Only done for MSSQLDRV_ID so far...
82395>>>>>>>    Function SqlEnumerateDatabaseCollations String sDriverID Returns String[]
82397>>>>>>>        Boolean bMertechDriver
82397>>>>>>>        String sSQL sConnectionID sConnectionString sSelect sName sPre
82397>>>>>>>        String sDescription sFrom sSys sValue sPrevious
82397>>>>>>>        Handle hStmt hoSQLManager hoSQLConnect
82397>>>>>>>        Integer iFetchResult iRows iColumn iPos
82397>>>>>>>        tSQLConnection SQLConnection
82397>>>>>>>        tSQLConnection SQLConnection
82397>>>>>>>        String[] asCollations
82398>>>>>>>        
82398>>>>>>>        If (sDriverID = "") Begin
82400>>>>>>>            Error DFERR_PROGRAM "The database driver ID was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
82401>>>>>>>>
82401>>>>>>>            Function_Return asCollations
82402>>>>>>>        End
82402>>>>>>>>
82402>>>>>>>
82402>>>>>>>        // Only done for MSSQLDRV_ID so far...
82402>>>>>>>        If (sDriverID <> MSSQLDRV_ID) Begin
82404>>>>>>>            Function_Return asCollations
82405>>>>>>>        End                 
82405>>>>>>>>
82405>>>>>>>
82405>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
82406>>>>>>>        If (bMertechDriver = False) Begin
82408>>>>>>>            Get phoSQLManager to hoSQLManager
82409>>>>>>>        End
82409>>>>>>>>
82409>>>>>>>        Else Begin
82410>>>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
82411>>>>>>>        End
82411>>>>>>>>
82411>>>>>>>
82411>>>>>>>        Get psConnectionID     to sConnectionID
82412>>>>>>>        Get psConnectionString to sConnectionString
82413>>>>>>>        Move 0 to LastErr
82414>>>>>>>
82414>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82415>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hoSQLConnect
82416>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82417>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
82419>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
82420>>>>>>>>
82420>>>>>>>            Function_Return asCollations
82421>>>>>>>        End
82421>>>>>>>>
82421>>>>>>>
82421>>>>>>>        Get SqlOpen of hoSQLConnect to hStmt
82422>>>>>>>
82422>>>>>>>        If (hStmt = 0) Begin
82424>>>>>>>            Send SqlDisconnect of hoSQLManager
82425>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
82426>>>>>>>>
82426>>>>>>>            Function_Return asCollations
82427>>>>>>>        End
82427>>>>>>>>
82427>>>>>>>
82427>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect      to sSelect
82428>>>>>>>        Get _SqlFindKeyWord CI_SQLName        to sName
82429>>>>>>>        Get _SqlFindKeyWord CI_SQLDescription to sDescription
82430>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom        to sFrom
82431>>>>>>>        Get _SqlFindKeyWord CI_SQLSys         to sSys
82432>>>>>>>
82432>>>>>>>        // MS-SQL Syntax:  
82432>>>>>>>        // SELECT name, description
82432>>>>>>>        //   from sys.fn_helpcollations();
82432>>>>>>>        Move (sSelect  * String(sName) * String(",") * String(sDescription) * String(sFrom) * String(sSys) * String(".fn_helpcollations();")) to sSQL
82433>>>>>>>
82433>>>>>>>        Move 1 to iColumn
82434>>>>>>>        Send SqlExecDirect of hStmt sSQL
82435>>>>>>>        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
82436>>>>>>>        Repeat
82436>>>>>>>>
82436>>>>>>>            Get SQLFetch of hStmt to iFetchResult
82437>>>>>>>            If (iFetchResult <> 0) Begin
82439>>>>>>>                Get SQLColumnValue of hStmt iColumn to sValue 
82440>>>>>>>                If (sValue <> sPrevious) Begin         
82442>>>>>>>                    // We need to skip all collations starting with "SQL" because they
82442>>>>>>>                    // are obsolete and for pre-SQL Server 2000.
82442>>>>>>>                    Move (Pos("SQL", Uppercase(sValue))) to iPos
82443>>>>>>>                    If (iPos <> 1) Begin
82445>>>>>>>                        Move (Trim(sValue)) to asCollations[SizeOfArray(asCollations)
82446>>>>>>>                    End
82446>>>>>>>>
82446>>>>>>>                End
82446>>>>>>>>
82446>>>>>>>                Move sValue to sPrevious
82447>>>>>>>            End
82447>>>>>>>>
82447>>>>>>>        Until (iFetchResult = 0)
82449>>>>>>>        Send SQLClose of hStmt
82450>>>>>>>        Send SQLDisconnect of hoSQLConnect
82451>>>>>>>
82451>>>>>>>        Function_Return asCollations
82452>>>>>>>    End_Function
82453>>>>>>>
82453>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
82453>>>>>>>    // for DAW drivers.
82453>>>>>>>    // Returns: A string array.
82453>>>>>>>    Function SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
82455>>>>>>>        String[] sReturnArray
82456>>>>>>>        String sValue sPrevious
82456>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
82456>>>>>>>        Integer iFetchResult iRows
82456>>>>>>>        tSQLConnection SQLConnection
82456>>>>>>>        tSQLConnection SQLConnection
82456>>>>>>>
82456>>>>>>>        Get phoSQLManager to hoSQLHandler
82457>>>>>>>
82457>>>>>>>        If (hoSQLHandler <> 0) Begin
82459>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
82460>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
82461>>>>>>>
82461>>>>>>>            If (hoSQLConnect <> 0) Begin
82463>>>>>>>                Get SQLOpen of hoSQLConnect to hstmt
82464>>>>>>>                If (hstmt <> 0) Begin
82466>>>>>>>                    Send SqlExecDirect of hstmt sStmt
82467>>>>>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
82468>>>>>>>                    Repeat
82468>>>>>>>>
82468>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
82469>>>>>>>                        If (iFetchResult <> 0) Begin
82471>>>>>>>                            Get SQLColumnValue of hstmt iColumn to sValue
82472>>>>>>>                            If (sValue <> sPrevious) Begin
82474>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
82475>>>>>>>                            End
82475>>>>>>>>
82475>>>>>>>                            Move sValue to sPrevious
82476>>>>>>>                        End
82476>>>>>>>>
82476>>>>>>>                    Until (iFetchResult = 0)
82478>>>>>>>                    Send SQLClose of hstmt
82479>>>>>>>                End
82479>>>>>>>>
82479>>>>>>>                Send SQLDisconnect of hoSQLConnect
82480>>>>>>>            End
82480>>>>>>>>
82480>>>>>>>        End
82480>>>>>>>>
82480>>>>>>>
82480>>>>>>>        Function_Return sReturnArray
82481>>>>>>>    End_Function
82482>>>>>>>
82482>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
82482>>>>>>>    // for Mertech drivers.
82482>>>>>>>    // Returns: A string array.
82482>>>>>>>    Function SqlEnumerateEsqlMertech String sStmt Returns String[]
82484>>>>>>>        String[] sReturnArray
82485>>>>>>>        String sValue
82485>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
82485>>>>>>>        Integer iFetchResult iRows
82485>>>>>>>        tSQLConnection SQLConnection
82485>>>>>>>        tSQLConnection SQLConnection
82485>>>>>>>
82485>>>>>>>        Get _MertechSQLManagerHandle to hoSQLHandler
82486>>>>>>>
82486>>>>>>>        If (hoSQLHandler <> 0) Begin
82488>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
82489>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
82490>>>>>>>
82490>>>>>>>            If (hoSQLConnect <> 0) Begin
82492>>>>>>>                Get SQLOpen of hoSQLConnect to hStmt
82493>>>>>>>                If (hStmt <> 0) Begin
82495>>>>>>>                    Send SqlExecDirect of hStmt sStmt
82496>>>>>>>                    Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
82497>>>>>>>                    Repeat
82497>>>>>>>>
82497>>>>>>>                        Get SQLFetch of hStmt to iFetchResult
82498>>>>>>>                        If (iFetchResult <> 0) Begin
82500>>>>>>>                            Get SQLColumnValue of hStmt 1 to sValue
82501>>>>>>>                            Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
82502>>>>>>>                        End
82502>>>>>>>>
82502>>>>>>>                    Until (iFetchResult = 0)
82504>>>>>>>                    Send SQLClose of hStmt
82505>>>>>>>                End
82505>>>>>>>>
82505>>>>>>>                Send SQLDisconnect of hoSQLConnect
82506>>>>>>>            End
82506>>>>>>>>
82506>>>>>>>        End
82506>>>>>>>>
82506>>>>>>>
82506>>>>>>>        Function_Return sReturnArray
82507>>>>>>>    End_Function
82508>>>>>>>
82508>>>>>>>    // * Dummy function for the Studio's Code Explorer *
82508>>>>>>>    Function PRIVATE_SQL_SUB_FUNCTIONS Returns Boolean
82510>>>>>>>        Function_Return False
82511>>>>>>>    End_Function
82512>>>>>>>
82512>>>>>>>    // Returns the index for the passed sTableName
82512>>>>>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
82512>>>>>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
82514>>>>>>>        Integer iIndex iSize iCount
82514>>>>>>>        String[] sTablesArray
82515>>>>>>>        String sDatabase sSchema sVal sConnectionString
82515>>>>>>>
82515>>>>>>>        Move -1 to iIndex
82516>>>>>>>        Get psConnectionString to sConnectionString
82517>>>>>>>        Get psDatabase to sDatabase
82518>>>>>>>        Get psSchema   to sSchema
82519>>>>>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
82520>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
82521>>>>>>>        Decrement iSize
82522>>>>>>>        For iCount from 0 to iSize
82528>>>>>>>>
82528>>>>>>>            Move sTablesArray[iCount] to sVal
82529>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
82531>>>>>>>                Move iCount to iIndex // We found it!
82532>>>>>>>                Move iSize to iCount  // End the loop
82533>>>>>>>            End
82533>>>>>>>>
82533>>>>>>>        Loop
82534>>>>>>>>
82534>>>>>>>
82534>>>>>>>        Function_Return iIndex
82535>>>>>>>    End_Function
82536>>>>>>>
82536>>>>>>>    // Helper function that builds a string like;
82536>>>>>>>    // "SELECT name from [Master].[sys].[databases] where name"
82536>>>>>>>    Function _SqlSelectFromWhereName Returns String
82538>>>>>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
82538>>>>>>>
82538>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
82539>>>>>>>        Get _SqlFindKeyWord CI_SQLName         to sName
82540>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
82541>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
82542>>>>>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
82543>>>>>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
82544>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
82545>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
82546>>>>>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
82547>>>>>>>        Function_Return sRetval
82548>>>>>>>    End_Function
82549>>>>>>>
82549>>>>>>>    // Helper function to create a SQL statement like;
82549>>>>>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
82549>>>>>>>    // Used for checking if an index exists.
82549>>>>>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
82551>>>>>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
82551>>>>>>>
82551>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
82552>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
82553>>>>>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
82554>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
82555>>>>>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
82556>>>>>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
82557>>>>>>>        Get _SqlFindKeyWord CI_SQLName to sName
82558>>>>>>>
82558>>>>>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
82559>>>>>>>
82559>>>>>>>        Function_Return sRetval
82560>>>>>>>    End_Function
82561>>>>>>>
82561>>>>>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
82561>>>>>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
82561>>>>>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
82563>>>>>>>        String sRetval
82563>>>>>>>        If (iLength <> 0) Begin
82565>>>>>>>            Move ("(" + String(iLength)) to sRetval
82566>>>>>>>            If (iDecimals <> 0) Begin
82568>>>>>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
82569>>>>>>>            End
82569>>>>>>>>
82569>>>>>>>            Move (sRetval + ")") to sRetval
82570>>>>>>>        End
82570>>>>>>>>
82570>>>>>>>        Function_Return sRetval
82571>>>>>>>    End_Function
82572>>>>>>>
82572>>>>>>>    Procedure _SqlColumnInfo Handle hoStmt
82574>>>>>>>        Integer i iCols iItem
82574>>>>>>>        tSqlColumnNew[] aQueryColumns
82574>>>>>>>        tSqlColumnNew[] aQueryColumns
82575>>>>>>>
82575>>>>>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
82576>>>>>>>        For i from 1 to iCols
82582>>>>>>>>
82582>>>>>>>            Move (SizeOfArray(aQueryColumns)) to iItem
82583>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
82584>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
82585>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
82586>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
82587>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
82588>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
82589>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
82590>>>>>>>        Loop
82591>>>>>>>>
82591>>>>>>>        Set piColumns to iCols
82592>>>>>>>        Set paQueryColumns to aQueryColumns
82593>>>>>>>    End_Procedure
82594>>>>>>>
82594>>>>>>>    // Checks that the passed sDriverID is defined.
82594>>>>>>>    // Also checks if the driver has been loaded; else it gets loaded.
82594>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
82596>>>>>>>        Boolean bOK
82596>>>>>>>        Integer iDriver
82596>>>>>>>
82596>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
82598>>>>>>>            Function_Return False
82599>>>>>>>        End
82599>>>>>>>>
82599>>>>>>>
82599>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
82600>>>>>>>
82600>>>>>>>        If (bOK = False) Begin
82602>>>>>>>            Get IsMertechDriver sDriverID to bOK
82603>>>>>>>        End
82603>>>>>>>>
82603>>>>>>>
82603>>>>>>>        If (bOK = False) Begin
82605>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, ODBC_DRV, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMySQL"
82606>>>>>>>>
82606>>>>>>>            Function_Return False
82607>>>>>>>        End
82607>>>>>>>>
82607>>>>>>>
82607>>>>>>>        Get DriverIndex sDriverID to iDriver
82608>>>>>>>        If (iDriver = 0) Begin
82610>>>>>>>            Load_Driver sDriverID
82611>>>>>>>        End
82611>>>>>>>>
82611>>>>>>>
82611>>>>>>>        Function_Return True
82612>>>>>>>    End_Function
82613>>>>>>>
82613>>>>>>>    // Checks that the length parameter has been passed correctly.
82613>>>>>>>    // This is only of concern for certain SQL data types.
82613>>>>>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
82615>>>>>>>        Integer iLength
82615>>>>>>>        Boolean bOK bCheckTypeLength
82615>>>>>>>
82615>>>>>>>        If (num_arguments > 1) Begin
82617>>>>>>>            Move iLen to iLength
82618>>>>>>>        End
82618>>>>>>>>
82618>>>>>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
82619>>>>>>>
82619>>>>>>>        If (bCheckTypeLength = True) Begin
82621>>>>>>>            Move (iLength > 0) to bOK
82622>>>>>>>        End
82622>>>>>>>>
82622>>>>>>>
82622>>>>>>>        Function_Return (bOK = True)
82623>>>>>>>    End_Function
82624>>>>>>>
82624>>>>>>>    Function _SqlProperTableName String sTableName Returns String
82626>>>>>>>        String sVal sSchema sDriverID
82626>>>>>>>        Integer iDbType
82626>>>>>>>
82626>>>>>>>        If (Trim(sTableName) = "") Begin
82628>>>>>>>            Function_Return ""
82629>>>>>>>        End
82629>>>>>>>>
82629>>>>>>>
82629>>>>>>>        Get psDriverID to sDriverID
82630>>>>>>>        Get piDbType   to iDbType
82631>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
82633>>>>>>>            Get psUserID to sSchema
82634>>>>>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
82634>>>>>>>            Move (Uppercase(sSchema)) to sSchema
82635>>>>>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
82636>>>>>>>            Function_Return sTableName
82637>>>>>>>        End
82637>>>>>>>>
82637>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
82639>>>>>>>            Get psDatabase to sVal
82640>>>>>>>            Move (sVal + "." + sTableName) to sTableName
82641>>>>>>>            Function_Return sTableName
82642>>>>>>>        End
82642>>>>>>>>
82642>>>>>>>        If (iDbType = EN_DbTypePostgre) Begin
82644>>>>>>>            Move ('"' + sTableName + '"') to sTableName
82645>>>>>>>            Function_Return sTableName
82646>>>>>>>        End
82646>>>>>>>>
82646>>>>>>>
82646>>>>>>>        Get psSchema to sSchema
82647>>>>>>>        If (sSchema = "") Begin
82649>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
82650>>>>>>>        End
82650>>>>>>>>
82650>>>>>>>
82650>>>>>>>        Move (Uppercase(sTableName)) to sVal
82651>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
82653>>>>>>>            If (iDbType = EN_dbTypeDB2) Begin
82655>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
82656>>>>>>>            End
82656>>>>>>>>
82656>>>>>>>            Else Begin
82657>>>>>>>                Move (sSchema + "." + sTableName) to sTableName
82658>>>>>>>            End
82658>>>>>>>>
82658>>>>>>>        End
82658>>>>>>>>
82658>>>>>>>
82658>>>>>>>        Function_Return sTableName
82659>>>>>>>    End_Function
82660>>>>>>>
82660>>>>>>>    // SQL column names can be case-sensitive. This function is used to check that
82660>>>>>>>    // the passed sFieldName has the correct spelling.
82660>>>>>>>    // Used with Embedded SQL statement calls.
82660>>>>>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
82660>>>>>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
82662>>>>>>>        String sRetval sValue sDriverID
82662>>>>>>>        String[] sColumnNamesArray
82663>>>>>>>        Integer iCount iColumns
82663>>>>>>>
82663>>>>>>>        Move "" to sRetval
82664>>>>>>>        Get psDriverID to sDriverID
82665>>>>>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
82666>>>>>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
82667>>>>>>>        Decrement iColumns
82668>>>>>>>
82668>>>>>>>        For iCount from 0 to iColumns
82674>>>>>>>>
82674>>>>>>>            Move sColumnNamesArray[iCount] to sValue
82675>>>>>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
82677>>>>>>>                Move sValue to sRetval
82678>>>>>>>                Move iColumns to iCount // We're done.
82679>>>>>>>            End
82679>>>>>>>>
82679>>>>>>>        Loop
82680>>>>>>>>
82680>>>>>>>
82680>>>>>>>        Function_Return sRetval
82681>>>>>>>    End_Function
82682>>>>>>>
82682>>>>>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
82684>>>>>>>        String[] sReturnArray
82685>>>>>>>        Handle hoSQLHandler
82685>>>>>>>        Integer iCount iSize iItem
82685>>>>>>>        String sServer
82685>>>>>>>        tSQLConnection SQLConnection
82685>>>>>>>        tSQLConnection SQLConnection
82685>>>>>>>
82685>>>>>>>        Get phoMSSQLHandler to hoSQLHandler
82686>>>>>>>        Send Delete_Data    of hoSQLHandler
82687>>>>>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
82688>>>>>>>
82688>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82689>>>>>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
82690>>>>>>>        Decrement iSize
82691>>>>>>>
82691>>>>>>>        For iCount from 0 to iSize
82697>>>>>>>>
82697>>>>>>>            Get String_Value of hoSQLHandler iCount to sServer
82698>>>>>>>            Move (Trim(sServer)) to sReturnArray[iItem]
82699>>>>>>>            Increment iItem
82700>>>>>>>        Loop
82701>>>>>>>>
82701>>>>>>>
82701>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82702>>>>>>>
82702>>>>>>>        Function_Return sReturnArray
82703>>>>>>>    End_Function
82704>>>>>>>
82704>>>>>>>    Function _SqlTableArrayDAW Returns String[]
82706>>>>>>>        String[] sReturnArray
82707>>>>>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord sConnectionString
82707>>>>>>>        Handle hoSQLHandler
82707>>>>>>>        Integer iCount iSize iItem iPos
82707>>>>>>>        Boolean bOK
82707>>>>>>>        tSQLConnection SQLConnection
82707>>>>>>>        tSQLConnection SQLConnection
82707>>>>>>>
82707>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
82708>>>>>>>        If (SQLConnection.sConnectionString = "") Begin
82710>>>>>>>            Function_Return sReturnArray
82711>>>>>>>        End
82711>>>>>>>>
82711>>>>>>>
82711>>>>>>>        Move SQLConnection.sSchema      to sDefSchema
82712>>>>>>>        Move (Uppercase(sDefSchema))    to sDefSchema
82713>>>>>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
82714>>>>>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
82715>>>>>>>
82715>>>>>>>        Get phoCLIHandler to hoSQLHandler
82716>>>>>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
82717>>>>>>>        Send Delete_Data  of hoSQLHandler
82718>>>>>>>
82718>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82719>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
82720>>>>>>>        // 2020-03-14 This was not correct when testing a MS-SQL ODBC driver connection from CMOS.
82720>>>>>>>//        If (SQLConnection.sDriverID = ODBC_DRV_ID) Begin
82720>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
82720>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
82720>>>>>>>//                If (iPos > 0) Begin
82720>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
82720>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
82720>>>>>>>//                End
82720>>>>>>>//            End
82720>>>>>>>//        End
82720>>>>>>>
82720>>>>>>>        Get EnumerateTables of hoSQLHandler sConnectionString to iSize
82721>>>>>>>        Move False to Err
82722>>>>>>>        Move 0 to iItem
82723>>>>>>>
82723>>>>>>>        // Note that the enumeration starts from table no 1. (not zero)
82723>>>>>>>        for iCount from 1 to iSize
82729>>>>>>>>
82729>>>>>>>            Get TableName    of hoSQLHandler iCount to sTable
82730>>>>>>>            Get TableType    of hoSQLHandler iCount to sTableType
82731>>>>>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
82732>>>>>>>            If (sSchema = "") Begin
82734>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
82735>>>>>>>            End
82735>>>>>>>>
82735>>>>>>>            Get TableComment of hoSQLHandler iCount to sComment
82736>>>>>>>            Move (Trim(sTable)) to sTable
82737>>>>>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
82739>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
82740>>>>>>>            End
82740>>>>>>>>
82740>>>>>>>            Else Begin
82741>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
82742>>>>>>>            End
82742>>>>>>>>
82742>>>>>>>            If (bOK = True) Begin
82744>>>>>>>                Move sTable to sReturnArray[iItem]
82745>>>>>>>                Increment iItem
82746>>>>>>>            End
82746>>>>>>>>
82746>>>>>>>        Loop
82747>>>>>>>>
82747>>>>>>>
82747>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82748>>>>>>>
82748>>>>>>>        Function_Return sReturnArray
82749>>>>>>>    End_Function
82750>>>>>>>
82750>>>>>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
82752>>>>>>>        String[] sReturnArray
82753>>>>>>>        String sValue
82753>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
82753>>>>>>>        Integer iRetval iCols iFetchResult
82753>>>>>>>        tSQLConnection SQLConnection
82753>>>>>>>        tSQLConnection SQLConnection
82753>>>>>>>
82753>>>>>>>        Get phoSQLManager to hoSQLHandler
82754>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
82755>>>>>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
82756>>>>>>>
82756>>>>>>>        If (hoSQLConnect <> 0) Begin
82758>>>>>>>            Get SqlOpen of hoSQLConnect to hStmt
82759>>>>>>>            If (hStmt <> 0) Begin
82761>>>>>>>                Send SqlSetProcedurename of hStmt sStmt
82762>>>>>>>                If (sArgument <> "") Begin
82764>>>>>>>                    Send SqlSetArgument  of hStmt 1 sArgument
82765>>>>>>>                End
82765>>>>>>>>
82765>>>>>>>
82765>>>>>>>                Send SqlCall             of hStmt
82766>>>>>>>                Get SqlReturnValue       of hStmt to iRetval
82767>>>>>>>                If (iRetval = 0) Begin
82769>>>>>>>                    Repeat
82769>>>>>>>>
82769>>>>>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
82770>>>>>>>                        If (iCols > 0) Begin
82772>>>>>>>                            Repeat
82772>>>>>>>>
82772>>>>>>>                                Get SqlFetch of hStmt to iFetchResult
82773>>>>>>>                                If (iFetchResult <> 0) Begin
82775>>>>>>>                                    Get SqlColumnValue of hStmt 1 to sValue
82776>>>>>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
82777>>>>>>>                                End
82777>>>>>>>>
82777>>>>>>>                            Until (iFetchResult = 0)
82779>>>>>>>                        End
82779>>>>>>>>
82779>>>>>>>                        Get SqlNextResultSet of hStmt to iRetval
82780>>>>>>>                    Until (iRetval = 0)
82782>>>>>>>                    Send SqlClose of hStmt
82783>>>>>>>                End
82783>>>>>>>>
82783>>>>>>>            End
82783>>>>>>>>
82783>>>>>>>            Send SqlDisconnect of hoSQLConnect
82784>>>>>>>        End
82784>>>>>>>>
82784>>>>>>>        Function_Return sReturnArray
82785>>>>>>>    End_Function
82786>>>>>>>
82786>>>>>>>    Function _SqlDatabasesArrayDB2 Returns String[]
82788>>>>>>>        String[] sReturnArray
82789>>>>>>>        String sDataSource
82789>>>>>>>        Handle hoSQLHandler
82789>>>>>>>        Integer iItem
82789>>>>>>>
82789>>>>>>>        Get phoDB2SQLHandler to hoSQLHandler
82790>>>>>>>        Send SeedDataSources of hoSQLHandler
82791>>>>>>>
82791>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82792>>>>>>>
82792>>>>>>>        Repeat
82792>>>>>>>>
82792>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
82793>>>>>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
82794>>>>>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
82795>>>>>>>            Increment iItem
82796>>>>>>>        Until (sDataSource = "")
82798>>>>>>>
82798>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82799>>>>>>>
82799>>>>>>>        Function_Return sReturnArray
82800>>>>>>>    End_Function
82801>>>>>>>
82801>>>>>>>    Function _SqlDatabaseSourcesArrayODBC Returns String[]
82803>>>>>>>        String[] sReturnArray
82804>>>>>>>        String sDataSource
82804>>>>>>>        Handle hoSQLHandler
82804>>>>>>>        Integer iItem
82804>>>>>>>
82804>>>>>>>        Get phoODBCSQLHandler to hoSQLHandler
82805>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82806>>>>>>>
82806>>>>>>>        Send SeedDataSources of hoSQLHandler
82807>>>>>>>
82807>>>>>>>        Repeat
82807>>>>>>>>
82807>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
82808>>>>>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
82810>>>>>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
82811>>>>>>>                Increment iItem
82812>>>>>>>            End
82812>>>>>>>>
82812>>>>>>>        Until (sDataSource = "")
82814>>>>>>>
82814>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82815>>>>>>>
82815>>>>>>>        Function_Return sReturnArray
82816>>>>>>>    End_Function
82817>>>>>>>
82817>>>>>>>    Function _SqlDatabasesArrayODBC Returns tSQLIntTableInfo[]
82819>>>>>>>        String[] sDataSources
82820>>>>>>>        tSQLConnection SQLConnection
82820>>>>>>>        tSQLConnection SQLConnection
82820>>>>>>>        tSQLIntTableInfo[] sReturnArray
82820>>>>>>>        tSQLIntTableInfo[] sReturnArray
82821>>>>>>>        Integer iDataSources iCount iItem
82821>>>>>>>        String sConnection sServer sDatabase sKey sSubKey
82821>>>>>>>        Handle hoIniFile hoRegistry hoODBCDataSources
82821>>>>>>>        Boolean bExists bKeyOpened
82821>>>>>>>
82821>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
82822>>>>>>>        Move SQLConnection.sConnectionString to sConnection
82823>>>>>>>        Move SQLConnection.sServer           to sServer
82824>>>>>>>
82824>>>>>>>        // FileDSN - read DATABASE name from DSN ini-file
82824>>>>>>>        If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
82826>>>>>>>            Get Create (RefClass(cIniFile)) to hoIniFile
82827>>>>>>>            Set psFileName of hoIniFile to sServer
82828>>>>>>>            Get ReadString of hoIniFile CS_SQLODBCIniSectionName CS_SQLIniDatabaseKeyword "" to sDatabase
82829>>>>>>>            Move sDatabase to sReturnArray[0].sDatabaseName
82830>>>>>>>            Send Destroy of hoIniFile
82831>>>>>>>        End
82831>>>>>>>>
82831>>>>>>>
82831>>>>>>>        // DSN - read DATABASE name from the registry
82831>>>>>>>        Else Begin
82832>>>>>>>            Get Create (RefClass(cRegistry)) to hoRegistry
82833>>>>>>>
82833>>>>>>>            // We start with checking the "System DNS" area in the registry as it is the
82833>>>>>>>            // most probably place the info is kept that we're after.
82833>>>>>>>            Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
82834>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
82835>>>>>>>            Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
82836>>>>>>>            If (bExists = True) Begin
82838>>>>>>>                Move "SOFTWARE\Wow6432Node\ODBC\ODBC.INI" to sKey
82839>>>>>>>            End
82839>>>>>>>>
82839>>>>>>>            Else Begin
82840>>>>>>>                Move "SOFTWARE\ODBC\ODBC.INI" to sKey
82841>>>>>>>            End
82841>>>>>>>>
82841>>>>>>>
82841>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
82842>>>>>>>            If (bExists) Begin
82844>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
82845>>>>>>>                If (bKeyOpened) Begin
82847>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
82848>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
82849>>>>>>>                    If (iDataSources > 0) Begin
82851>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
82852>>>>>>>                        Decrement iDataSources
82853>>>>>>>                        for iCount from 0 to iDataSources
82859>>>>>>>>
82859>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
82860>>>>>>>                        Loop
82861>>>>>>>>
82861>>>>>>>                        Move 0 to iItem
82862>>>>>>>                        for iCount from 0 to iDataSources
82868>>>>>>>>
82868>>>>>>>                            Move sDataSources[iCount] to sSubKey
82869>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
82870>>>>>>>                            If (bKeyOpened = True) Begin
82872>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
82873>>>>>>>                                If (bExists = True) Begin
82875>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
82876>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
82877>>>>>>>                                    Increment iItem
82878>>>>>>>                                End
82878>>>>>>>>
82878>>>>>>>                            End
82878>>>>>>>>
82878>>>>>>>                        Loop
82879>>>>>>>>
82879>>>>>>>                    End
82879>>>>>>>>
82879>>>>>>>                    Send CloseKey of hoRegistry
82880>>>>>>>                    Send Destroy of hoODBCDataSources
82881>>>>>>>                End
82881>>>>>>>>
82881>>>>>>>            End
82881>>>>>>>>
82881>>>>>>>
82881>>>>>>>            // We then check the "User DNS" area in the registry.
82881>>>>>>>            Set phRootKey of hoRegistry to HKEY_CURRENT_USER
82882>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
82883>>>>>>>            Move "SOFTWARE\ODBC\ODBC.INI" to sKey
82884>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
82885>>>>>>>
82885>>>>>>>            If (bExists) Begin
82887>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
82888>>>>>>>                If (bKeyOpened) Begin
82890>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
82891>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
82892>>>>>>>                    If (iDataSources > 0) Begin
82894>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
82895>>>>>>>                        Decrement iDataSources
82896>>>>>>>                        for iCount from 0 to iDataSources
82902>>>>>>>>
82902>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
82903>>>>>>>                        Loop
82904>>>>>>>>
82904>>>>>>>                        for iCount from 0 to iDataSources
82910>>>>>>>>
82910>>>>>>>                            Move sDataSources[iCount] to sSubKey
82911>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
82912>>>>>>>                            If (bKeyOpened = True) Begin
82914>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
82915>>>>>>>                                If (bExists = True) Begin
82917>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
82918>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
82919>>>>>>>                                    Increment iItem
82920>>>>>>>                                End
82920>>>>>>>>
82920>>>>>>>                            End
82920>>>>>>>>
82920>>>>>>>                        Loop
82921>>>>>>>>
82921>>>>>>>                    End
82921>>>>>>>>
82921>>>>>>>                    Send CloseKey of hoRegistry
82922>>>>>>>                    Send Destroy of hoODBCDataSources
82923>>>>>>>                End
82923>>>>>>>>
82923>>>>>>>            End
82923>>>>>>>>
82923>>>>>>>
82923>>>>>>>            Send Destroy of hoRegistry
82924>>>>>>>        End
82924>>>>>>>>
82924>>>>>>>
82924>>>>>>>        Function_Return sReturnArray
82925>>>>>>>    End_Function
82926>>>>>>>
82926>>>>>>>    // We might have a split Sql script where the info about which database to use is
82926>>>>>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
82926>>>>>>>    // insert it for scriplets to come after the first one.
82926>>>>>>>    Function _SqlFormatStatement String sStmt Returns String
82928>>>>>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
82928>>>>>>>        Integer iStart iEnd iDbType
82928>>>>>>>        Boolean bOK
82928>>>>>>>
82928>>>>>>>        Get piDbType to iDbType
82929>>>>>>>        Get psDriverID to sDriverID
82930>>>>>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
82931>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
82932>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
82933>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
82934>>>>>>>        Move (Replaces(" ", sStmt, "")) to sTmp
82935>>>>>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
82937>>>>>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
82938>>>>>>>            Move (Pos("]", sTmp)) to iEnd
82939>>>>>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
82940>>>>>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
82941>>>>>>>            Set Private.psUseDatabase to sUseDatabase
82942>>>>>>>        End
82942>>>>>>>>
82942>>>>>>>        Else Begin
82943>>>>>>>            Move (Uppercase(sStmt)) to sTmp
82944>>>>>>>
82944>>>>>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
82944>>>>>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
82946>>>>>>>                Get Private.psUseDatabase to sUseDatabase
82947>>>>>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
82948>>>>>>>            End
82948>>>>>>>>
82948>>>>>>>
82948>>>>>>>            // This is a bit special to place here but was done so because it was easier that way.
82948>>>>>>>            // We will get an error when trying to create a view if it already exists.
82948>>>>>>>            // So to avoid such errors; we first remove it & then recreate it.
82948>>>>>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
82951>>>>>>>                // Make sure we only have one space between statements/words.
82951>>>>>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
82952>>>>>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
82953>>>>>>>                Move (Trim(sTmp)) to sTmp
82954>>>>>>>                Move (Pos(" ", sTmp)) to iEnd
82955>>>>>>>                Move (Left(sTmp, iEnd)) to sTmp
82956>>>>>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
82958>>>>>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
82959>>>>>>>                End
82959>>>>>>>>
82959>>>>>>>                Move (Trim(sTmp)) to sTmp
82960>>>>>>>                // Remove data view as it already exists!
82960>>>>>>>                Get SqlViewRemove sDriverID sTmp to bOK
82961>>>>>>>            End
82961>>>>>>>>
82961>>>>>>>        End
82961>>>>>>>>
82961>>>>>>>
82961>>>>>>>        Function_Return sStmt
82962>>>>>>>    End_Function
82963>>>>>>>
82963>>>>>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
82963>>>>>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
82965>>>>>>>        String sRetval
82965>>>>>>>        Integer iDbType iIndex
82965>>>>>>>        tSQLKeyWords[] SQLKeywordArray
82965>>>>>>>        tSQLKeyWords[] SQLKeywordArray
82966>>>>>>>        tSQLKeyWords   SQLKeyWords
82966>>>>>>>        tSQLKeyWords   SQLKeyWords
82966>>>>>>>
82966>>>>>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
82966>>>>>>>        Move "" to sRetval
82967>>>>>>>        Get piDbType to iDbType
82968>>>>>>>        Move iDbType             to SQLKeyWords.iSQLDbType
82969>>>>>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
82970>>>>>>>
82970>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
82971>>>>>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
82972>>>>>>>        If (iIndex >= 0) Begin
82974>>>>>>>            Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
82975>>>>>>>        End
82975>>>>>>>>
82975>>>>>>>
82975>>>>>>>        Function_Return sRetval
82976>>>>>>>    End_Function
82977>>>>>>>
82977>>>>>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
82977>>>>>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
82979>>>>>>>        String[] sSQLScriptArray
82980>>>>>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
82980>>>>>>>        Integer iSize iCount
82980>>>>>>>        Boolean bCommentStart bCommentEnd bDashComment
82980>>>>>>>
82980>>>>>>>        Move False to bCommentStart
82981>>>>>>>        Move False to bCommentEnd
82982>>>>>>>        Move False to bDashComment
82983>>>>>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
82984>>>>>>>        Move "*/"  to sCommentEnd
82985>>>>>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
82986>>>>>>>
82986>>>>>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
82987>>>>>>>        Decrement iSize
82988>>>>>>>        Move "" to sText
82989>>>>>>>
82989>>>>>>>        For iCount from 0 to iSize
82995>>>>>>>>
82995>>>>>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
82996>>>>>>>            Move (Trim(sLine)) to sTmp
82997>>>>>>>            If (sTmp <> "") Begin
82999>>>>>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
83000>>>>>>>                If (bCommentStart = False) Begin
83002>>>>>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
83003>>>>>>>                    If (bCommentStart = False) Begin
83005>>>>>>>                    End
83005>>>>>>>>
83005>>>>>>>                End
83005>>>>>>>>
83005>>>>>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
83006>>>>>>>                If (bCommentEnd = True) Begin
83008>>>>>>>                    Move False to bCommentStart
83009>>>>>>>                End
83009>>>>>>>>
83009>>>>>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
83011>>>>>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
83012>>>>>>>                End
83012>>>>>>>>
83012>>>>>>>            End
83012>>>>>>>>
83012>>>>>>>        Loop
83013>>>>>>>>
83013>>>>>>>
83013>>>>>>>        // Update the retval struct array:
83013>>>>>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
83014>>>>>>>        Function_Return SqlScriptArray
83015>>>>>>>    End_Function
83016>>>>>>>
83016>>>>>>>
83016>>>>>>>    // *** Database API Functions: ***
83016>>>>>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
83016>>>>>>>    // make changes/updates to the database.
83016>>>>>>>
83016>>>>>>>    // * Dummy function for the Studio's Code Explorer *
83016>>>>>>>    Function API_TABLE_FUNCTIONS Returns Boolean
83018>>>>>>>        Function_Return False
83019>>>>>>>    End_Function
83020>>>>>>>
83020>>>>>>>    // This might not do what you think - Here's what it does:
83020>>>>>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
83020>>>>>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
83020>>>>>>>    // to the SQL table.
83020>>>>>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
83020>>>>>>>    // already exists in SQL.
83020>>>>>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
83020>>>>>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
83020>>>>>>>    // restructuring an existing table.
83020>>>>>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
83022>>>>>>>        Boolean bExists bOpened bOK bSystemFile bMertechDriver bUseConnectionID bIsAlias
83022>>>>>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
83022>>>>>>>        Handle hToTable
83022>>>>>>>
83022>>>>>>>        Move True to bUseConnectionID
83023>>>>>>>        If (num_arguments > 1) Begin
83025>>>>>>>            Move bUseConnID to bUseConnectionID
83026>>>>>>>        End
83026>>>>>>>>
83026>>>>>>>
83026>>>>>>>        Get psDriverID to sDriverID
83027>>>>>>>        // If the table doesn't exist on the SQL back-end we do nothing.
83027>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
83028>>>>>>>        If (bExists = False) Begin
83030>>>>>>>            Function_Return False
83031>>>>>>>        End
83031>>>>>>>>
83031>>>>>>>
83031>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
83032>>>>>>>
83032>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
83033>>>>>>>        If (bOK = False) Begin
83035>>>>>>>            Function_Return False
83036>>>>>>>        End
83036>>>>>>>>
83036>>>>>>>
83036>>>>>>>        // Then we need to check that the function hasn't been called before; which in case
83036>>>>>>>        // we do nothing
83036>>>>>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
83037>>>>>>>        If (bExists = True) Begin
83039>>>>>>>            Function_Return False
83040>>>>>>>        End
83040>>>>>>>>
83040>>>>>>>
83040>>>>>>>        Get psConnectionID     to sConnectionID
83041>>>>>>>        Get psConnectionString to sConnectionString
83042>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
83044>>>>>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
83045>>>>>>>>
83045>>>>>>>            Function_Return False
83046>>>>>>>        End
83046>>>>>>>>
83046>>>>>>>
83046>>>>>>>        Set Private.phCurrentTable to hTable
83047>>>>>>>        Get psSchema to sSchema
83048>>>>>>>        If (sSchema = "") Begin
83050>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
83051>>>>>>>        End
83051>>>>>>>>
83051>>>>>>>
83051>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
83052>>>>>>>
83052>>>>>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
83052>>>>>>>        // was a programmer's error and we adjust for it here.
83052>>>>>>>        If (bMertechDriver = True) Begin
83054>>>>>>>            Move False to bUseConnectionID
83055>>>>>>>        End
83055>>>>>>>>
83055>>>>>>>
83055>>>>>>>        // If we should use a connection id we need to check it exists;
83055>>>>>>>        // else we create it before attempting creating the table
83055>>>>>>>        If (bUseConnectionID = True) Begin
83057>>>>>>>            Get AutoConnectionIDLogin to bOK
83058>>>>>>>            If (bOk = False) Begin
83060>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
83061>>>>>>>>
83061>>>>>>>                Function_Return False
83062>>>>>>>            End
83062>>>>>>>>
83062>>>>>>>        End
83062>>>>>>>>
83062>>>>>>>
83062>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
83065>>>>>>>        Get _TableNameOnly sRootName to sRootName
83066>>>>>>>        If (sRootName = "") Begin
83068>>>>>>>            Function_Return False
83069>>>>>>>        End
83069>>>>>>>>
83069>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
83070>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
83073>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
83076>>>>>>>
83076>>>>>>>        // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
83076>>>>>>>        //
83076>>>>>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
83076>>>>>>>        // because then the table should not be visible to users.
83076>>>>>>>//        Move (Pos("@", sDisplayName)) to iPos
83076>>>>>>>//        If (iPos <> 1) Begin
83076>>>>>>>//            If (sDisplayName contains ".") Begin
83076>>>>>>>//                Move (Pos(".", sDisplayName)) to iPos
83076>>>>>>>//                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
83076>>>>>>>//                Move (sSchema + "." + sDisplayName)       to sDisplayName
83076>>>>>>>//            End
83076>>>>>>>//            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
83076>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
83076>>>>>>>//            End
83076>>>>>>>//        End
83076>>>>>>>
83076>>>>>>>        If (bIsAlias = False) Begin
83078>>>>>>>            Get OpenTableExclusive hTable to bOpened
83079>>>>>>>            If (bOpened = False) Begin
83081>>>>>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
83082>>>>>>>>
83082>>>>>>>                Function_Return False
83083>>>>>>>            End
83083>>>>>>>>
83083>>>>>>>        End
83083>>>>>>>>
83083>>>>>>>
83083>>>>>>>        If (ghoProgressBar <> 0) Begin
83085>>>>>>>            Send DoAdvance of ghoProgressBar
83086>>>>>>>            Set Message_Text of ghoStatusPanel to ""
83087>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
83088>>>>>>>        End
83088>>>>>>>>
83088>>>>>>>        // Note: The hToTable will get changed by the Structure_xxx command...
83088>>>>>>>        Move hTable to hToTable
83089>>>>>>>        Move False to Err
83090>>>>>>>
83090>>>>>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
83090>>>>>>>        // then we do a pseudo .int file change with the "SqlUtilUpdateIntFile" function. After that we have
83090>>>>>>>        // a proper and updated .int file.
83090>>>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
83093>>>>>>>        Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
83094>>>>>>>
83094>>>>>>>        If (bIsAlias = False) Begin
83096>>>>>>>            Structure_Start hToTable sDriverID
83097>>>>>>>                Set Private.phCurrentTable to hTable
83098>>>>>>>                If (bUseConnectionID = True) Begin
83100>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
83103>>>>>>>                End
83103>>>>>>>>
83103>>>>>>>                Else Begin
83104>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
83107>>>>>>>                End
83107>>>>>>>>
83107>>>>>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
83110>>>>>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
83110>>>>>>>                Move False to Err
83111>>>>>>>                Move 0 to LastErr
83112>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
83113>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
83115>>>>>>>            Set Action_Text of ghoStatusPanel to ""
83116>>>>>>>        End
83116>>>>>>>>
83116>>>>>>>
83116>>>>>>>        Move (not(Err)) to bOK
83117>>>>>>>        If (bOK = True) Begin
83119>>>>>>>            // The attributes set above will always trigger an error
83119>>>>>>>            // We also adjust the Filelist entries
83119>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
83122>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
83125>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
83128>>>>>>>
83128>>>>>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
83128>>>>>>>            Get SqlUtilUpdateIntFile hTable to bOK
83129>>>>>>>        End
83129>>>>>>>>
83129>>>>>>>
83129>>>>>>>        Function_Return (bOK = True)
83130>>>>>>>    End_Function
83131>>>>>>>
83131>>>>>>>    // Sample usage:
83131>>>>>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
83131>>>>>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
83131>>>>>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
83133>>>>>>>        Boolean bOK bIsSQLTable
83133>>>>>>>
83133>>>>>>>        Get AutoConnectionIDLogin to bOK
83134>>>>>>>        Move False to Err
83135>>>>>>>        Get OpenTableExclusive hTable to bOK
83136>>>>>>>        If (bOK = False) Begin
83138>>>>>>>            Function_Return False
83139>>>>>>>        End
83139>>>>>>>>
83139>>>>>>>
83139>>>>>>>        // ToDo: Add to all table change functions!
83139>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
83140>>>>>>>            If (bIsSQLTable = True) Begin
83142>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
83145>>>>>>>            End
83145>>>>>>>>
83145>>>>>>>
83145>>>>>>>        Set Private.phCurrentTable to hTable
83146>>>>>>>        Structure_Start hTable
83147>>>>>>>            Set_Attribute iAttribute of hTable to iValue
83150>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
83151>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
83153>>>>>>>
83153>>>>>>>        Set Action_Text of ghoStatusPanel to ""
83154>>>>>>>        Function_Return (Err = False)
83155>>>>>>>    End_Function
83156>>>>>>>
83156>>>>>>>    Function ApiTableMoveFileListEntry String sRootName String sLogicalName String sDisplayName Handle hFromSlot Handle hToSlot String sDriverID Returns Boolean
83158>>>>>>>        Boolean bOK
83158>>>>>>>        
83158>>>>>>>        Get ApiTableChangeFileListSlot sRootName sLogicalName sDisplayName hToSlot sDriverID to bOK
83159>>>>>>>        If (bOK = True) Begin
83161>>>>>>>            Get ApiTableChangeFileListSlot "" "" "" hFromSlot sDriverID to bOK
83162>>>>>>>        End
83162>>>>>>>>
83162>>>>>>>        
83162>>>>>>>        Function_Return (bOK = True)
83163>>>>>>>    End_Function
83164>>>>>>>    
83164>>>>>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
83164>>>>>>>    // or to change the filelist slot names.
83164>>>>>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
83166>>>>>>>        String sFileListName
83166>>>>>>>        
83166>>>>>>>        Move False to Err
83167>>>>>>>
83167>>>>>>>        If (ghoProgressBar <> 0) Begin
83169>>>>>>>            Send DoAdvance of ghoProgressBar
83170>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
83171>>>>>>>        End
83171>>>>>>>>
83171>>>>>>>        // If all strings are empty it means that we should remove this entry from filelist.
83171>>>>>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
83173>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
83176>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
83179>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
83182>>>>>>>            Function_Return (Err = False) // And we're done.
83183>>>>>>>        End
83183>>>>>>>>
83183>>>>>>>
83183>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
83185>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
83185>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
83186>>>>>>>        End
83186>>>>>>>>
83186>>>>>>>//        Else Begin
83186>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
83186>>>>>>>//        End
83186>>>>>>>//
83186>>>>>>>//        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
83186>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
83186>>>>>>>
83186>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
83189>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
83192>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
83195>>>>>>>        
83195>>>>>>>        Function_Return (Err = False)
83196>>>>>>>    End_Function
83197>>>>>>>
83197>>>>>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
83199>>>>>>>        Boolean bOK
83199>>>>>>>
83199>>>>>>>        Get AutoConnectionIDLogin to bOK
83200>>>>>>>        Move False to Err
83201>>>>>>>        Get OpenTableExclusive hTable to bOK
83202>>>>>>>        If (bOK = False) Begin
83204>>>>>>>            Function_Return False
83205>>>>>>>        End
83205>>>>>>>>
83205>>>>>>>
83205>>>>>>>        Set Private.phCurrentTable to hTable
83206>>>>>>>        Structure_Start hTable
83207>>>>>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
83210>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
83211>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
83213>>>>>>>
83213>>>>>>>        Set Action_Text of ghoStatusPanel to ""
83214>>>>>>>        Function_Return (Err = False)
83215>>>>>>>    End_Function
83216>>>>>>>
83216>>>>>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
83218>>>>>>>        Boolean bOK bIsSQLTable
83218>>>>>>>
83218>>>>>>>        Move False to Err
83219>>>>>>>        Get AutoConnectionIDLogin to bOK
83220>>>>>>>        Open hToTable
83222>>>>>>>        Get OpenTableExclusive hTable to bOK
83223>>>>>>>        If (bOK = False) Begin
83225>>>>>>>            Function_Return False
83226>>>>>>>        End
83226>>>>>>>>
83226>>>>>>>
83226>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
83227>>>>>>>            If (bIsSQLTable = True) Begin
83229>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
83232>>>>>>>            End
83232>>>>>>>>
83232>>>>>>>
83232>>>>>>>        Set Private.phCurrentTable to hTable
83233>>>>>>>        Structure_Start hTable
83234>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
83237>>>>>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
83240>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
83241>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
83243>>>>>>>
83243>>>>>>>        Set Action_Text of ghoStatusPanel to ""
83244>>>>>>>        Function_Return (Err = False)
83245>>>>>>>    End_Function
83246>>>>>>>
83246>>>>>>>    Procedure ApiTableConvertAllAddException Integer hTable
83248>>>>>>>        Integer[] aTableConvertExceptions
83249>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
83250>>>>>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
83251>>>>>>>        Set paTableConvertExceptions to aTableConvertExceptions
83252>>>>>>>    End_Procedure
83253>>>>>>>
83253>>>>>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
83255>>>>>>>        Integer[] aTableDateCorrectionExceptions
83256>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
83257>>>>>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
83258>>>>>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
83259>>>>>>>    End_Procedure
83260>>>>>>>
83260>>>>>>>    Procedure ApiTableConvertALLToSql
83262>>>>>>>        Integer[] iTablesArray
83263>>>>>>>        Integer iSize iCount
83263>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
83263>>>>>>>        String sDriverID
83263>>>>>>>
83263>>>>>>>        Get psDriverID to sDriverID
83264>>>>>>>        Get pbUseConnectionID to bUseConnectionID
83265>>>>>>>        Get pbToANSI          to bToANSI
83266>>>>>>>        Get pbRecnum          to bRecnum
83267>>>>>>>        Get pbCopyData        to bCopyData
83268>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
83270>>>>>>>            Get pbContinueOnError to bContinueOnError
83271>>>>>>>        End
83271>>>>>>>>
83271>>>>>>>
83271>>>>>>>        Get _AllTablesToConvert to iTablesArray
83272>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
83273>>>>>>>        Set pbVisible   of ghoProgressBarOverall to True
83274>>>>>>>        Set piPosition  of ghoProgressBarOverall to 0
83275>>>>>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
83276>>>>>>>        Set piMaximum   of ghoProgressBarOverall to iSize
83277>>>>>>>
83277>>>>>>>        Decrement iSize
83278>>>>>>>        For iCount from 0 to iSize
83284>>>>>>>>
83284>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
83285>>>>>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
83286>>>>>>>            // Probably the right logic here is to just continue trying to convert every table even
83286>>>>>>>            // if there was an error converting one table...
83286>>>>>>>            //If (bContinueOnError = False and bOK = False) Break
83286>>>>>>>        Loop
83287>>>>>>>>
83287>>>>>>>
83287>>>>>>>    End_Procedure
83288>>>>>>>
83288>>>>>>>    Procedure ApiTableAttachALLToSql
83290>>>>>>>        Integer[] iTablesArray
83291>>>>>>>        Integer iSize iCount
83291>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
83291>>>>>>>        String sDriverID
83291>>>>>>>
83291>>>>>>>        Get psDriverID to sDriverID
83292>>>>>>>        Get pbUseConnectionID to bUseConnectionID
83293>>>>>>>        Get pbToANSI          to bToANSI
83294>>>>>>>        Get pbRecnum          to bRecnum
83295>>>>>>>        Get pbCopyData        to bCopyData
83296>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
83298>>>>>>>            Get pbContinueOnError to bContinueOnError
83299>>>>>>>        End
83299>>>>>>>>
83299>>>>>>>
83299>>>>>>>        Get _AllTablesToConvert to iTablesArray
83300>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
83301>>>>>>>        Decrement iSize
83302>>>>>>>        For iCount from 0 to iSize
83308>>>>>>>>
83308>>>>>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
83309>>>>>>>        Loop
83310>>>>>>>>
83310>>>>>>>
83310>>>>>>>    End_Procedure
83311>>>>>>>
83311>>>>>>>    // Subfunction to the ApiTableUpdate function (et al)
83311>>>>>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
83313>>>>>>>        Handle hTable
83313>>>>>>>        String sConnectionID
83313>>>>>>>        Boolean bTableExists bSameTableNames bANSI bOK
83313>>>>>>>
83313>>>>>>>        Get ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
83314>>>>>>>        If (bSameTableNames = True) Begin
83316>>>>>>>            Function_Return True
83317>>>>>>>        End
83317>>>>>>>>
83317>>>>>>>
83317>>>>>>>        Move True to bOK
83318>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
83319>>>>>>>        Set Private.phCurrentTable              to hTable
83320>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME         of hTable to APITableNameInfoFrom.sRootName
83323>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME      of hTable to APITableNameInfoFrom.sLogicalName
83326>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME      of hTable to APITableNameInfoFrom.sDisplayName
83329>>>>>>>
83329>>>>>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
83331>>>>>>>            Get psConnectionID to sConnectionID
83332>>>>>>>            Get UtilTableExists hTable to bTableExists
83333>>>>>>>            If (bTableExists = True) Begin
83335>>>>>>>                Get SqlUtilUpdateIntFile hTable to bOK
83336>>>>>>>            End
83336>>>>>>>>
83336>>>>>>>            Else Begin
83337>>>>>>>                Get pbToANSI to bANSI
83338>>>>>>>                Get SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
83339>>>>>>>            End
83339>>>>>>>>
83339>>>>>>>        End
83339>>>>>>>>
83339>>>>>>>
83339>>>>>>>        Function_Return bOK
83340>>>>>>>    End_Function
83341>>>>>>>
83341>>>>>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
83343>>>>>>>        Handle hToTable hoLogFile
83343>>>>>>>        Boolean bOK bExists bOpened bMertechDriver bDAWDriver bContinueOnError bIsAlias
83343>>>>>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
83343>>>>>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
83343>>>>>>>        tSQLConnection SQLConnection
83343>>>>>>>        tSQLConnection SQLConnection
83343>>>>>>>
83343>>>>>>>        Get UtilTableExists hTable to bExists
83344>>>>>>>        If (bExists = False) Begin
83346>>>>>>>            Set Private.phCurrentTable to hTable
83347>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end.(Or Filelist.cfg contains a driver but the table doesn't exists on the SQL back-end)"
83348>>>>>>>>
83348>>>>>>>            Function_Return False
83349>>>>>>>        End
83349>>>>>>>>
83349>>>>>>>
83349>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
83350>>>>>>>        // If this is an Alias file there is nothing to convert to SQL.
83350>>>>>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
83350>>>>>>>        If (bIsAlias = True) Begin
83352>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
83355>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
83357>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
83360>>>>>>>                Get psConnectionID to sConnectionID
83361>>>>>>>                Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
83362>>>>>>>            End
83362>>>>>>>>
83362>>>>>>>            Function_Return True
83363>>>>>>>        End
83363>>>>>>>>
83363>>>>>>>
83363>>>>>>>        Set Private.phCurrentTable to hTable
83364>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
83367>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
83370>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
83373>>>>>>>
83373>>>>>>>        If (ghoProgressBar <> 0) Begin
83375>>>>>>>            Send DoAdvance of ghoProgressBar
83376>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
83377>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
83378>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
83379>>>>>>>        End
83379>>>>>>>>
83379>>>>>>>
83379>>>>>>>        // Marco Kuipers suggestion;
83379>>>>>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
83379>>>>>>>        // an SQL table; Instead of creating the table in SQL, attach it to the existing
83379>>>>>>>        // SQL table.
83379>>>>>>>        Get UtilTableIsSQL hTable to bOK
83380>>>>>>>        If (bOK = False) Begin
83382>>>>>>>            Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
83383>>>>>>>            If (bExists = True) Begin
83385>>>>>>>//                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
83385>>>>>>>//                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
83385>>>>>>>                Get phoLogFile to hoLogFile
83386>>>>>>>                If (hoLogFile <> 0) Begin          
83388>>>>>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The table was NOT converted to SQL but instead ATTACHED to the existing SQL table.") to sWarning
83389>>>>>>>//                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
83389>>>>>>>                    Send LogError sWarning False
83390>>>>>>>                End
83390>>>>>>>>
83390>>>>>>>                Else Begin
83391>>>>>>>                    Error DFERR_PROGRAM sWarning
83392>>>>>>>>
83392>>>>>>>                End                                                       
83392>>>>>>>>
83392>>>>>>>                Get ApiTableAttachToSql hTable bUseConnectionID to bOK
83393>>>>>>>                Function_Return bOK // We're done (We have attached to an existing SQL table instead of converting it.
83394>>>>>>>            End
83394>>>>>>>>
83394>>>>>>>        End
83394>>>>>>>>
83394>>>>>>>
83394>>>>>>>        // Does the rootname contain a driver?
83394>>>>>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
83396>>>>>>>            // Does the table already exist as an SQL table?
83396>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
83397>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
83397>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
83397>>>>>>>            If (bExists = False) Begin
83399>>>>>>>                Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
83400>>>>>>>            End
83400>>>>>>>>
83400>>>>>>>            If (bExists = True) Begin
83402>>>>>>>                Set TableName_Text of ghoStatusPanel to ""
83403>>>>>>>                Function_Return False
83404>>>>>>>            End
83404>>>>>>>>
83404>>>>>>>        End
83404>>>>>>>>
83404>>>>>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
83405>>>>>>>
83405>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
83406>>>>>>>        // Mertech drivers don't use Connection ID's; so if bUseConnectionID was
83406>>>>>>>        // passed as True, we adjust for that here.
83406>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
83407>>>>>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
83409>>>>>>>            Move False to bUseConnectionID
83410>>>>>>>        End
83410>>>>>>>>
83410>>>>>>>
83410>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
83411>>>>>>>        Move SQLConnection.sSchema           to sSchema
83412>>>>>>>        If (sSchema = "") Begin
83414>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
83415>>>>>>>            Move (Lowercase(sSchema))        to sSchema
83416>>>>>>>        End
83416>>>>>>>>
83416>>>>>>>
83416>>>>>>>        If (sDriverID = ORAFLEX) Begin
83418>>>>>>>            Move SQLConnection.sUserID       to sSchema
83419>>>>>>>        End
83419>>>>>>>>
83419>>>>>>>
83419>>>>>>>        Move SQLConnection.sDatabase         to sDatabase
83420>>>>>>>        Move SQLConnection.sConnectionID     to sConnectionID
83421>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
83422>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
83424>>>>>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
83425>>>>>>>>
83425>>>>>>>            Function_Return False
83426>>>>>>>        End
83426>>>>>>>>
83426>>>>>>>
83426>>>>>>>        Get AutoConnectionIDLogin to bOK
83427>>>>>>>        Open hTable
83429>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
83432>>>>>>>        If (bOpened = False) Begin
83434>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
83435>>>>>>>>
83435>>>>>>>            Function_Return False
83436>>>>>>>        End
83436>>>>>>>>
83436>>>>>>>
83436>>>>>>>        If (ghoProgressBar <> 0) Begin
83438>>>>>>>            Send DoAdvance of ghoProgressBar
83439>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
83440>>>>>>>        End
83440>>>>>>>>
83440>>>>>>>
83440>>>>>>>        Move 0 to hToTable
83441>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
83442>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
83443>>>>>>>
83443>>>>>>>        Case Begin
83443>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
83445>>>>>>>                Case Break
83446>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
83449>>>>>>>                Case Break
83450>>>>>>>            Case (sDriverID = DB2_DRV_ID)
83453>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
83454>>>>>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
83455>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
83456>>>>>>>                Case Break
83457>>>>>>>            Case (sDriverID = ORAFLEX)
83460>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
83461>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
83462>>>>>>>                Case Break
83463>>>>>>>            Case (sDriverID = MDSMySQL)
83466>>>>>>>                Case Break
83467>>>>>>>            Case (sDriverID = MDSPgSQL)
83470>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
83471>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
83472>>>>>>>                Case Break
83473>>>>>>>            Case (sDriverID = DATAFLEX_ID)
83476>>>>>>>                Case Break
83477>>>>>>>            Case Else
83477>>>>>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
83478>>>>>>>>
83478>>>>>>>                Case Break
83479>>>>>>>        Case End
83479>>>>>>>
83479>>>>>>>        Move False to Err
83480>>>>>>>
83480>>>>>>>        If (bMertechDriver = True) Begin
83482>>>>>>>            // Note: This function also sets the Err flag.
83482>>>>>>>            Get _MertechApiTableConvertToSQL hTable sRootName sDatabase sDriverID sBaseTableSpace sIndexTableSpace bToAnsi bCopyData to bOK
83483>>>>>>>        End
83483>>>>>>>>
83483>>>>>>>
83483>>>>>>>        If (bMertechDriver = False) Begin
83485>>>>>>>            Structure_Start hToTable sDriverID
83486>>>>>>>                Structure_Copy hTable to hToTable
83487>>>>>>>                Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
83490>>>>>>>
83490>>>>>>>                If (sDriverID <> DATAFLEX_ID) Begin
83492>>>>>>>                    If (bUseConnectionID = True) Begin
83494>>>>>>>                        Set_Attribute DF_FILE_LOGIN of hToTable to (CS_DFCONNID + "=" + sConnectionID)
83497>>>>>>>                    End
83497>>>>>>>>
83497>>>>>>>                    Else Begin
83498>>>>>>>                        Set_Attribute DF_FILE_LOGIN of hToTable to sConnectionString
83501>>>>>>>                    End
83501>>>>>>>>
83501>>>>>>>
83501>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE of hToTable to bRecnum
83504>>>>>>>
83504>>>>>>>                    If (sSchema <> "") Begin
83506>>>>>>>                        Set_Attribute DF_FILE_OWNER of hToTable to sSchema
83509>>>>>>>                    End
83509>>>>>>>>
83509>>>>>>>
83509>>>>>>>                    If (sDriverID = DB2_DRV_ID) Begin
83511>>>>>>>                        If (sLongTableSpace <> "") Begin
83513>>>>>>>                            Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
83516>>>>>>>                        End
83516>>>>>>>>
83516>>>>>>>                        If (sBaseTableSpace <> "") Begin
83518>>>>>>>                            Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
83521>>>>>>>                        End
83521>>>>>>>>
83521>>>>>>>                        If (sIndexTableSpace <> "") Begin
83523>>>>>>>                            Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
83526>>>>>>>                        End
83526>>>>>>>>
83526>>>>>>>                    End
83526>>>>>>>>
83526>>>>>>>                End
83526>>>>>>>>
83526>>>>>>>
83526>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
83527>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
83529>>>>>>>            Set Action_Text of ghoStatusPanel to ""
83530>>>>>>>        End
83530>>>>>>>>
83530>>>>>>>
83530>>>>>>>        Move (not(Err)) to bOK
83531>>>>>>>
83531>>>>>>>        If (bOK = True and bCopyData = True) Begin
83533>>>>>>>            If (bMertechDriver = False) Begin
83535>>>>>>>                Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
83536>>>>>>>            End
83536>>>>>>>>
83536>>>>>>>            Else Begin
83537>>>>>>>                Get _MertechCopyDataToSQL hTable sRootName sDriverID to bOK
83538>>>>>>>            End
83538>>>>>>>>
83538>>>>>>>
83538>>>>>>>            If (ghoDbUpdateHandler > 0) Begin
83540>>>>>>>                Get pbContinueOnError to bContinueOnError
83541>>>>>>>            End
83541>>>>>>>>
83541>>>>>>>            // If the data copy failed we will keep the newly created SQL table but
83541>>>>>>>            // rename it by adding a GUID to the end of the table name
83541>>>>>>>            // - or as much as "fit" because different SQL back-ends have
83541>>>>>>>            // different rules how long a table name can be.
83541>>>>>>>            // The new table will probably contain data but something went
83541>>>>>>>            // wrong while converting the data from embedded to SQL.
83541>>>>>>>            If (bOK = False and bContinueOnError = False) Begin
83543>>>>>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
83544>>>>>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
83545>>>>>>>                Error DFERR_PROGRAM ("Copying of" * sLogicalName * " data failed due to bad data. Either duplicate records and/or bad e.g Date/DateTime data. The SQL table was renamed to:" * String(sGUIDName) * "and its Filelist.cfg entry was NOT changed.")
83546>>>>>>>>
83546>>>>>>>            End
83546>>>>>>>>
83546>>>>>>>        End
83546>>>>>>>>
83546>>>>>>>
83546>>>>>>>        // This must be after copying data...
83546>>>>>>>        If (Err = False) Begin
83548>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
83551>>>>>>>            // It seems the Studio does not do this any more, so commented out.
83551>>>>>>>            // We also adjust the display name by prefixing it by the schema name;
83551>>>>>>>            //            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
83551>>>>>>>            //                // The max length for the display_name is 31 characters...
83551>>>>>>>            //                If (Length(sSchema + "." + sDisplayName) < 31) Begin
83551>>>>>>>            //                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
83551>>>>>>>            //                End
83551>>>>>>>            //            End
83551>>>>>>>        End
83551>>>>>>>>
83551>>>>>>>
83551>>>>>>>        Close hTable
83552>>>>>>>        Move (not(Err)) to bOK
83553>>>>>>>        Function_Return bOK
83554>>>>>>>    End_Function
83555>>>>>>>
83555>>>>>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
83555>>>>>>>    // It will first drop all indicies, copy the data and then recreate indicies.
83555>>>>>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
83555>>>>>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
83557>>>>>>>        Boolean bOpened bOK
83557>>>>>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
83557>>>>>>>        String sErrorFile sEmpty sPath
83557>>>>>>>
83557>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
83560>>>>>>>        Get AutoConnectionIDLogin to bOK
83561>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
83563>>>>>>>            Send IncreaseSortBufferSize
83564>>>>>>>//            Send SetAllIndexesToBatch hToTable
83564>>>>>>>        End
83564>>>>>>>>
83564>>>>>>>
83564>>>>>>>        Move False to Err
83565>>>>>>>        Open sPhysicalName as hToTable
83567>>>>>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
83570>>>>>>>        If (bOpened = False) Begin
83572>>>>>>>            Function_Return False
83573>>>>>>>        End
83573>>>>>>>>
83573>>>>>>>
83573>>>>>>>        If (ghoStatusPanel <> 0) Begin
83575>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
83576>>>>>>>            Set piMinimum of ghoProgressBar to 0
83577>>>>>>>            Set piMaximum of ghoProgressBar to 100 // 100%
83578>>>>>>>        End
83578>>>>>>>>
83578>>>>>>>
83578>>>>>>>        Move "" to sEmpty
83579>>>>>>>        Move False to Err
83580>>>>>>>        Move True to bOK
83581>>>>>>>        Set Private.phCurrentTable to hToTable
83582>>>>>>>
83582>>>>>>>        // No need to get the record identifier
83582>>>>>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False
83585>>>>>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
83588>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
83590>>>>>>>            // Remove all indices to speed up copying of data:
83590>>>>>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
83595>>>>>>>            If (iRetval <> 0) Begin       
83597>>>>>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
83598>>>>>>>>
83598>>>>>>>                Close hToTable
83599>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
83602>>>>>>>                Function_Return False
83603>>>>>>>            End
83603>>>>>>>>
83603>>>>>>>        End
83603>>>>>>>>
83603>>>>>>>
83603>>>>>>>        Move (sRootName + ".err") to sErrorFile
83604>>>>>>>        Move 0 to iIndex
83605>>>>>>>        Move False to Err
83606>>>>>>>
83606>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
83608>>>>>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
83611>>>>>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
83616>>>>>>>            If (iRetval <> 0) Begin
83618>>>>>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
83619>>>>>>>>
83619>>>>>>>                Close hToTable
83620>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
83623>>>>>>>                Function_Return False
83624>>>>>>>            End
83624>>>>>>>>
83624>>>>>>>        End
83624>>>>>>>>
83624>>>>>>>        Else Begin
83625>>>>>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
83628>>>>>>>        End
83628>>>>>>>>
83628>>>>>>>
83628>>>>>>>        If (Err = False) Begin
83630>>>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
83631>>>>>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
83632>>>>>>>        End
83632>>>>>>>>
83632>>>>>>>
83632>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
83634>>>>>>>            // Recreate indices:
83634>>>>>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
83639>>>>>>>            If (iRetval <> 0) Begin
83641>>>>>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
83642>>>>>>>>
83642>>>>>>>                Close hToTable
83643>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
83646>>>>>>>                Function_Return False
83647>>>>>>>            End
83647>>>>>>>>
83647>>>>>>>        End
83647>>>>>>>>
83647>>>>>>>
83647>>>>>>>        Close hToTable
83648>>>>>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
83651>>>>>>>
83651>>>>>>>        If (bOK = True) Begin
83653>>>>>>>            Move (not(Err)) to bOK
83654>>>>>>>        End
83654>>>>>>>>
83654>>>>>>>
83654>>>>>>>        If (ghoStatusPanel <> 0) Begin
83656>>>>>>>            Set TableName_Text of ghoStatusPanel to ""
83657>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
83658>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
83659>>>>>>>        End
83659>>>>>>>>
83659>>>>>>>
83659>>>>>>>        Function_Return (bOK = True)
83660>>>>>>>    End_Function
83661>>>>>>>
83661>>>>>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
83661>>>>>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
83661>>>>>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
83663>>>>>>>        Handle hFile
83663>>>>>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
83663>>>>>>>        Integer iIdentityType iDataType iDbType iCount iSize
83663>>>>>>>        Boolean bOk bExists bSqlDriver bMertechDriver bDeleteDummy bExistsInFilelist bSysFile
83663>>>>>>>        tSQLConnection SQLConnection
83663>>>>>>>        tSQLConnection SQLConnection
83663>>>>>>>        tAPIColumn[] aColumns
83663>>>>>>>        tAPIColumn[] aColumns
83664>>>>>>>        tColumnType ColumnType
83664>>>>>>>        tColumnType ColumnType
83664>>>>>>>
83664>>>>>>>        // First check if the passed filenumber already exists; in case we do nothing
83664>>>>>>>        Get UtilTableExists hTable to bOk
83665>>>>>>>        If (bOk = True) Begin
83667>>>>>>>            Function_Return False
83668>>>>>>>        End
83668>>>>>>>>
83668>>>>>>>
83668>>>>>>>        Set Private.phCurrentTable to hTable
83669>>>>>>>        Move sLogicalName to sTableName
83670>>>>>>>        If (ghoProgressBar <> 0) Begin
83672>>>>>>>            Send DoAdvance of ghoProgressBar
83673>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
83674>>>>>>>        End
83674>>>>>>>>
83674>>>>>>>
83674>>>>>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
83675>>>>>>>        Get psDriverID to sDriverID
83676>>>>>>>        Get IsSQLDriver sDriverID to bSqlDriver
83677>>>>>>>        Get piDbType to iDbType
83678>>>>>>>
83678>>>>>>>        // If no columns passed in, we need to create a "dummy" column
83678>>>>>>>        Move False to bDeleteDummy
83679>>>>>>>        If (Num_Arguments = 8) Begin
83681>>>>>>>            Move aColumnIn to aColumns
83682>>>>>>>        End
83682>>>>>>>>
83682>>>>>>>        If ((SizeOfArray(aColumns)) = 0) Begin
83684>>>>>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
83685>>>>>>>            Move ColumnType.iSQLType to iDataType
83686>>>>>>>            If (bRecnum = False) Begin
83688>>>>>>>                Move C_tAPIColumn_Identity to iIdentityType
83689>>>>>>>            End
83689>>>>>>>>
83689>>>>>>>            Else Begin
83690>>>>>>>                Move C_tAPIColumn_None     to iIdentityType
83691>>>>>>>            End
83691>>>>>>>>
83691>>>>>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
83692>>>>>>>            Move True to bDeleteDummy
83693>>>>>>>        End
83693>>>>>>>>
83693>>>>>>>
83693>>>>>>>        // If columns have been passed as an array we need to check if an identity column
83693>>>>>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
83693>>>>>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
83693>>>>>>>        // two identity columns and SQL doesn't like that and throws an error.
83693>>>>>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
83695>>>>>>>            Move (SizeOfArray(aColumns)) to iSize
83696>>>>>>>            Decrement iSize
83697>>>>>>>            for iCount from 0 to iSize
83703>>>>>>>>
83703>>>>>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
83705>>>>>>>                    Move False to bRecnum
83706>>>>>>>                    Move iSize to iCount
83707>>>>>>>                End
83707>>>>>>>>
83707>>>>>>>            Loop
83708>>>>>>>>
83708>>>>>>>        End
83708>>>>>>>>
83708>>>>>>>
83708>>>>>>>        // If this is a SQL based driver we also check if the table exists
83708>>>>>>>        // in the SQL back end; in case we do nothing.
83708>>>>>>>        If (bSqlDriver = True) Begin
83710>>>>>>>            // Get all connection properties
83710>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
83711>>>>>>>            Move SQLConnection.sSchema to sSchema
83712>>>>>>>            If (sSchema = "") Begin
83714>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
83715>>>>>>>            End
83715>>>>>>>>
83715>>>>>>>
83715>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
83716>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
83716>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
83716>>>>>>>            If (bExists = False) Begin
83718>>>>>>>                Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
83719>>>>>>>            End
83719>>>>>>>>
83719>>>>>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
83719>>>>>>>            // we will just add it to Filelist.cfg
83719>>>>>>>            If (bExists = True) Begin
83721>>>>>>>                If (bExistsInFilelist = False) Begin
83723>>>>>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
83725>>>>>>>                        Move (sDriverID + ":" + sRootName) to sRootName
83726>>>>>>>                    End
83726>>>>>>>>
83726>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
83729>>>>>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
83732>>>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
83735>>>>>>>                    Move False to bSysFile
83736>>>>>>>                    Get SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
83737>>>>>>>                End
83737>>>>>>>>
83737>>>>>>>                Function_Return False
83738>>>>>>>            End
83738>>>>>>>>
83738>>>>>>>        End
83738>>>>>>>>
83738>>>>>>>
83738>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
83739>>>>>>>        If (num_arguments > 6) Begin
83741>>>>>>>            If (bANSI = False) Begin
83743>>>>>>>                Move CS_OEM_Txt to sANSI_OEM
83744>>>>>>>            End
83744>>>>>>>>
83744>>>>>>>        End
83744>>>>>>>>
83744>>>>>>>
83744>>>>>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
83744>>>>>>>        // is a programmer's error and we auto-correct for it here.
83744>>>>>>>        // This is also a bit messy. If a Mertech driver is used and we want to create a new table,
83744>>>>>>>        // we first need to create it as embedded (DataFlex) and then convert it to SQL (!)
83744>>>>>>>        // So we set the driver ID temporarily to "DataFlex" to get the table created as embedded and later
83744>>>>>>>        // set it back and use a Mertech function to convert it to SQL.
83744>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
83745>>>>>>>        If (bMertechDriver = True) Begin
83747>>>>>>>            If (bUseConnectionID = True) Begin
83749>>>>>>>                Move False to bUseConnectionID
83750>>>>>>>            End
83750>>>>>>>>
83750>>>>>>>            Move sDriverID to sOriginalDriverID
83751>>>>>>>            Move DATAFLEX_ID to sDriverID
83752>>>>>>>        End
83752>>>>>>>>
83752>>>>>>>
83752>>>>>>>        Move False to Err
83753>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
83755>>>>>>>            Move sRootName to sPhysicalFile
83756>>>>>>>        End
83756>>>>>>>>
83756>>>>>>>
83756>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
83758>>>>>>>            Move SQLConnection.sConnectionID to sConnectionID
83759>>>>>>>
83759>>>>>>>            // If DAW driver and we should use a connection id we need to
83759>>>>>>>            // check if the connection ID exists; else we create it before attempting creating the table
83759>>>>>>>            If (bMertechDriver = False and bUseConnectionID = True) Begin
83761>>>>>>>                Get IsConnectionID sConnectionID sDriverID to bExists
83762>>>>>>>                If (bExists = False) Begin
83764>>>>>>>                    Get AutoSetConnectionID sConnectionID to bOk
83765>>>>>>>                    If (bOk = False) Begin
83767>>>>>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
83768>>>>>>>>
83768>>>>>>>                        Function_Return False
83769>>>>>>>                    End
83769>>>>>>>>
83769>>>>>>>                End
83769>>>>>>>>
83769>>>>>>>            End
83769>>>>>>>>
83769>>>>>>>
83769>>>>>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
83771>>>>>>>                Move (sTableName + ".int") to sPhysicalFile
83772>>>>>>>            End
83772>>>>>>>>
83772>>>>>>>            Else Begin
83773>>>>>>>                Move (sRootName + ".int") to sPhysicalFile
83774>>>>>>>            End
83774>>>>>>>>
83774>>>>>>>            Move (Uppercase(sDisplayName)) to sVal
83775>>>>>>>//            If (not(sVal contains (sSchema + "."))) Begin
83775>>>>>>>//                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
83775>>>>>>>//            End
83775>>>>>>>        End
83775>>>>>>>>
83775>>>>>>>        Move False to Err
83776>>>>>>>        Move 0 to hFile
83777>>>>>>>
83777>>>>>>>        Structure_Start hFile sDriverID
83778>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
83780>>>>>>>                If (bUseConnectionID = True) Begin
83782>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
83785>>>>>>>                End
83785>>>>>>>>
83785>>>>>>>                Else Begin
83786>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
83789>>>>>>>                End
83789>>>>>>>>
83789>>>>>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
83792>>>>>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
83795>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
83798>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
83801>>>>>>>
83801>>>>>>>                If (sSchema <> "") Begin
83803>>>>>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
83806>>>>>>>                End
83806>>>>>>>>
83806>>>>>>>
83806>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
83808>>>>>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
83810>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
83813>>>>>>>                    End
83813>>>>>>>>
83813>>>>>>>                End
83813>>>>>>>>
83813>>>>>>>                If (sDriverID = DB2_DRV_ID or sDriverID = ORAFLEX or sDriverID = MDSPgSQL) Begin
83815>>>>>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
83817>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
83820>>>>>>>                    End
83820>>>>>>>>
83820>>>>>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
83822>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
83825>>>>>>>                    End
83825>>>>>>>>
83825>>>>>>>                End
83825>>>>>>>>
83825>>>>>>>            End
83825>>>>>>>>
83825>>>>>>>
83825>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
83828>>>>>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
83829>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
83830>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
83832>>>>>>>        Set Action_Text of ghoStatusPanel to ""
83833>>>>>>>
83833>>>>>>>        // If Mertech driver we convert the newly created embedded table (DataFlex) to SQL
83833>>>>>>>        If (bMertechDriver = True) Begin
83835>>>>>>>            Move sOriginalDriverID to sDriverID
83836>>>>>>>            If (not(sVal contains (sSchema + "."))) Begin
83838>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
83839>>>>>>>            End
83839>>>>>>>>
83839>>>>>>>            // Note: This function also sets the Err flag.
83839>>>>>>>            //Get _MertechApiTableConvertToSQL hTable sRootName SQLConnection.sDatabase sDriverID SQLConnection.sBaseTableSpace SQLConnection.sIndexTableSpace False to bOK
83839>>>>>>>        End
83839>>>>>>>>
83839>>>>>>>
83839>>>>>>>        Move (not(Err)) to bOK
83840>>>>>>>        If (bOk = True) Begin
83842>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
83844>>>>>>>                Move (sDriverID + ":" + sRootName) to sRootName
83845>>>>>>>            End
83845>>>>>>>>
83845>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
83848>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
83851>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
83854>>>>>>>
83854>>>>>>>            // Lastly we remove the temporary column we created above, if all went well.
83854>>>>>>>            If (bDeleteDummy) Begin
83856>>>>>>>                Get ApiColumnRemove hTable "temp" to bOk
83857>>>>>>>            End
83857>>>>>>>>
83857>>>>>>>        End
83857>>>>>>>>
83857>>>>>>>
83857>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
83858>>>>>>>        Close hTable
83859>>>>>>>        Function_Return (bOK = True)
83860>>>>>>>    End_Function
83861>>>>>>>
83861>>>>>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
83863>>>>>>>        Move False to Err
83864>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
83867>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
83870>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
83873>>>>>>>
83873>>>>>>>        Function_Return (Err = False)
83874>>>>>>>    End_Function
83875>>>>>>>
83875>>>>>>>    // ToDo: Needs to be revised
83875>>>>>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
83877>>>>>>>        Handle hTable
83877>>>>>>>        String sDEFName sDataPath
83877>>>>>>>        Boolean bExists
83877>>>>>>>
83877>>>>>>>        // Do nothing if MSSQL Driver.
83877>>>>>>>//        Get IsMSSQLDriver to bExists
83877>>>>>>>//        If (bExists = True) Begin
83877>>>>>>>//            Procedure_Return
83877>>>>>>>//        End
83877>>>>>>>
83877>>>>>>>        Get psDataPathFirstPart to sDataPath
83878>>>>>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
83879>>>>>>>        If (bExists = True) Begin
83881>>>>>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
83881>>>>>>>            // still be missing from the filelist and needs to be added.
83881>>>>>>>            Get UtilTableNumberIsInUse iFilelistSlot to bExists
83882>>>>>>>            If (bExists = True) Begin
83884>>>>>>>                Procedure_Return
83885>>>>>>>            End
83885>>>>>>>>
83885>>>>>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
83885>>>>>>>            Else Begin
83886>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
83889>>>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
83892>>>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
83895>>>>>>>                Procedure_Return
83896>>>>>>>            End
83896>>>>>>>>
83896>>>>>>>        End
83896>>>>>>>>
83896>>>>>>>
83896>>>>>>>        Move (sPath + sFileName + ".def") to sDEFName
83897>>>>>>>        Move 0 to hTable
83898>>>>>>>        Move False to Err
83899>>>>>>>
83899>>>>>>>        Structure_Start hTable DATAFLEX_ID
83900>>>>>>>            Load_Def sDEFName Onto hTable
83901>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
83904>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
83905>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
83907>>>>>>>        Set Action_Text of ghoStatusPanel to ""
83908>>>>>>>
83908>>>>>>>        Move iFilelistSlot to hTable
83909>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
83912>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83915>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
83918>>>>>>>
83918>>>>>>>    End_Procedure
83919>>>>>>>
83919>>>>>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
83921>>>>>>>        Boolean bTmp bErr bOK
83921>>>>>>>        String sTableName sDisplayName sFileName
83921>>>>>>>
83921>>>>>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
83921>>>>>>>        Move Err to bTmp
83922>>>>>>>        Move False to Err
83923>>>>>>>
83923>>>>>>>        Get AutoConnectionIDLogin to bOK
83924>>>>>>>        // First get the info for the current filelist slot:
83924>>>>>>>        Open iFromFileSlot
83926>>>>>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
83929>>>>>>>        If (bOK = True) Begin
83931>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
83934>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
83937>>>>>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
83940>>>>>>>
83940>>>>>>>            //...then move it.
83940>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
83943>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
83946>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
83949>>>>>>>
83949>>>>>>>            //...and finally remove the old filelist values.
83949>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
83952>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
83955>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
83958>>>>>>>        End
83958>>>>>>>>
83958>>>>>>>        Close iFromFileSlot
83959>>>>>>>
83959>>>>>>>        Move Err to bErr
83960>>>>>>>        Move bTmp to Err
83961>>>>>>>        Function_Return (bErr = False)
83962>>>>>>>    End_Function
83963>>>>>>>
83963>>>>>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
83965>>>>>>>        Handle hTable
83965>>>>>>>        Boolean bOK
83965>>>>>>>        String sDriverID
83965>>>>>>>
83965>>>>>>>        Get UtilTableExists hTableFrom to bOK
83966>>>>>>>        If (bOK = False) Begin
83968>>>>>>>            Set Private.phCurrentTable to hTableFrom
83969>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
83970>>>>>>>>
83970>>>>>>>            Function_Return False
83971>>>>>>>        End
83971>>>>>>>>
83971>>>>>>>
83971>>>>>>>        Get UtilTableExists hTableTo to bOK
83972>>>>>>>        If (bOK = False) Begin
83974>>>>>>>            Set Private.phCurrentTable to hTableTo
83975>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
83976>>>>>>>>
83976>>>>>>>            Function_Return False
83977>>>>>>>        End
83977>>>>>>>>
83977>>>>>>>
83977>>>>>>>        Get AutoConnectionIDLogin to bOK
83978>>>>>>>        Get UtilTableOpen hTableFrom "" DF_EXCLUSIVE to bOK
83979>>>>>>>        If (bOK = False) Begin
83981>>>>>>>            Function_Return False
83982>>>>>>>        End
83982>>>>>>>>
83982>>>>>>>
83982>>>>>>>        Move False to Err
83983>>>>>>>        Open hTableTo
83985>>>>>>>
83985>>>>>>>        Move hTableFrom to hTable
83986>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
83989>>>>>>>        Set Private.phCurrentTable to hTable
83990>>>>>>>
83990>>>>>>>        Structure_Start hTable sDriverID
83991>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
83994>>>>>>>            If (iColumnTo <> 0) Begin
83996>>>>>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
83999>>>>>>>            End
83999>>>>>>>>
83999>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
84000>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84002>>>>>>>        Set Action_Text of ghoStatusPanel to ""
84003>>>>>>>
84003>>>>>>>        If (hTableTo > 0) Begin
84005>>>>>>>            Close hTableTo
84006>>>>>>>        End
84006>>>>>>>>
84006>>>>>>>
84006>>>>>>>        Function_Return (Err = False)
84007>>>>>>>    End_Function
84008>>>>>>>
84008>>>>>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
84008>>>>>>>    Function ApiTableRemove Handle hTable Returns Boolean
84010>>>>>>>        String sTableName sDriverID
84010>>>>>>>        Boolean bOk
84010>>>>>>>        String sDataPath
84010>>>>>>>
84010>>>>>>>        Get AutoConnectionIDLogin to bOK
84011>>>>>>>        Move False to Err
84012>>>>>>>        Get psDriverID to sDriverID
84013>>>>>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
84014>>>>>>>        If (sTableName = "") Begin
84016>>>>>>>            Function_Return False
84017>>>>>>>        End
84017>>>>>>>>
84017>>>>>>>
84017>>>>>>>        Set Private.phCurrentTable to hTable
84018>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
84019>>>>>>>        Delete_db sTableName
84020>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
84021>>>>>>>
84021>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
84023>>>>>>>//            Get SqlTableRemoveByTableName sTableName to bOk  // We don't have to do this because the database is already removed by 'delete_db' above
84023>>>>>>>            Get psDataPathFirstPart to sDataPath
84024>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
84025>>>>>>>        End
84025>>>>>>>>
84025>>>>>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
84025>>>>>>>        If (hTable <> 0) Begin
84027>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
84030>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
84033>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
84036>>>>>>>        End
84036>>>>>>>>
84036>>>>>>>
84036>>>>>>>        Close hTable
84037>>>>>>>        Function_Return (hTable <> 0)
84038>>>>>>>    End_Function
84039>>>>>>>
84039>>>>>>>    Function ApiTableRemoveRelation Handle hTableFrom Integer iColumn Returns Boolean
84041>>>>>>>        Handle hTable
84041>>>>>>>        Boolean bOK
84041>>>>>>>
84041>>>>>>>        Get AutoConnectionIDLogin to bOK
84042>>>>>>>        Move False to Err
84043>>>>>>>        Open hTableFrom Mode DF_EXCLUSIVE
84045>>>>>>>        Move hTableFrom to hTable
84046>>>>>>>
84046>>>>>>>        Structure_Start hTable
84047>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
84050>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
84051>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84053>>>>>>>        Set Action_Text of ghoStatusPanel to ""
84054>>>>>>>
84054>>>>>>>        Close hTableFrom
84055>>>>>>>        Function_Return (Err = False)
84056>>>>>>>    End_Function
84057>>>>>>>
84057>>>>>>>    Function ApiTableRename Handle hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
84059>>>>>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
84059>>>>>>>        Boolean bOK bExists bOpened
84059>>>>>>>        tAPITableNameInfo APITableNameInfo
84059>>>>>>>        tAPITableNameInfo APITableNameInfo
84059>>>>>>>
84059>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
84062>>>>>>>        If (bOpened = False) Begin
84064>>>>>>>            Get OpenTableExclusive hTable to bOpened
84065>>>>>>>            If (bOpened = False) Begin
84067>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
84068>>>>>>>                Function_Return False
84069>>>>>>>            End
84069>>>>>>>>
84069>>>>>>>        End
84069>>>>>>>>
84069>>>>>>>
84069>>>>>>>        Set Private.phCurrentTable to hTable
84070>>>>>>>        Move hTable         to APITableNameInfo.iTableNumber
84071>>>>>>>        Move sRootName      to APITableNameInfo.sRootName
84072>>>>>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
84073>>>>>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
84074>>>>>>>        Get ApiTableFilelistNamesCompare True APITableNameInfo to bExists
84075>>>>>>>        If (bExists = True) Begin
84077>>>>>>>            Function_Return True
84078>>>>>>>        End
84078>>>>>>>>
84078>>>>>>>
84078>>>>>>>        Set Private.phCurrentTable to hTable
84079>>>>>>>        Move False to Err
84080>>>>>>>        Get psDataPathFirstPart to sDataPath
84081>>>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
84084>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
84087>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
84090>>>>>>>
84090>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
84093>>>>>>>        Close hTable
84094>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
84096>>>>>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
84097>>>>>>>            If (bExists = True) Begin
84099>>>>>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
84101>>>>>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
84104>>>>>>>                    // We need a short break here before attempting to delete the physical old files or Windows
84104>>>>>>>                    // might report "File in use..." and the deletion will fail.
84104>>>>>>>                    Sleep 2
84105>>>>>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
84106>>>>>>>                End
84106>>>>>>>>
84106>>>>>>>            End
84106>>>>>>>>
84106>>>>>>>        End
84106>>>>>>>>
84106>>>>>>>
84106>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
84108>>>>>>>            If (not(sPhysicalName contains ".")) Begin
84110>>>>>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
84111>>>>>>>            End
84111>>>>>>>>
84111>>>>>>>
84111>>>>>>>            // Change the table name in the .int file to the new table new:
84111>>>>>>>            Get UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
84112>>>>>>>            If (bOK = False) Begin
84114>>>>>>>                Function_Return False
84115>>>>>>>            End
84115>>>>>>>>
84115>>>>>>>
84115>>>>>>>            // Change table name at the SQL side:
84115>>>>>>>            Get psSchema to sSchema
84116>>>>>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK
84117>>>>>>>
84117>>>>>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
84118>>>>>>>            // Remove cache file and Rename the physical file names:
84118>>>>>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK
84119>>>>>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
84120>>>>>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
84121>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
84122>>>>>>>
84122>>>>>>>            // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
84122>>>>>>>//            If (not(sDisplayName contains ".")) Begin
84122>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
84122>>>>>>>//            End
84122>>>>>>>        End
84122>>>>>>>>
84122>>>>>>>
84122>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
84125>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
84128>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
84131>>>>>>>
84131>>>>>>>        Function_Return (Err = False)
84132>>>>>>>    End_Function
84133>>>>>>>
84133>>>>>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
84135>>>>>>>        Move False to Err
84136>>>>>>>        Set Private.phCurrentTable to hTable
84137>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
84140>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
84143>>>>>>>
84143>>>>>>>        Function_Return (Err = False)
84144>>>>>>>    End_Function
84145>>>>>>>
84145>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
84145>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
84145>>>>>>>    Function ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
84147>>>>>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
84147>>>>>>>        Handle hTable
84147>>>>>>>        Boolean bIsSame
84147>>>>>>>
84147>>>>>>>        Move APITableInfo.iTableNumber      to hTable
84148>>>>>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
84149>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
84152>>>>>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
84153>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
84156>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
84159>>>>>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
84160>>>>>>>
84160>>>>>>>        If (bCompareFilelistUppercase = True) Begin
84162>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
84163>>>>>>>        End
84163>>>>>>>>
84163>>>>>>>        Else Begin
84164>>>>>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
84165>>>>>>>        End
84165>>>>>>>>
84165>>>>>>>
84165>>>>>>>        Function_Return bIsSame
84166>>>>>>>    End_Function
84167>>>>>>>
84167>>>>>>>    // Note: This table update function does _not_ convert an embedded table to SQL. Use function ApiTableConvertToSQL first for that.
84167>>>>>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
84169>>>>>>>        Handle hTable
84169>>>>>>>        String sTableName
84169>>>>>>>        String sDriverIDFrom sDriverIDTo
84169>>>>>>>        Integer iDbType
84169>>>>>>>        Boolean bOk bMertechDriver bOpened bApiTableUpdateAuto
84169>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
84169>>>>>>>        Boolean bIsSame bFilelistError bIsAliasFrom bIsSQLTableFrom bIsSQLTableTo
84169>>>>>>>        tSQLConnection SQLConnection
84169>>>>>>>        tSQLConnection SQLConnection
84169>>>>>>>        tAPITable      APITableFrom APITableTo
84169>>>>>>>        tAPITable      APITableFrom APITableTo
84169>>>>>>>        tColumnType    ColumnType
84169>>>>>>>        tColumnType    ColumnType
84169>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
84169>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
84170>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
84170>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
84171>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
84171>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
84172>>>>>>>
84172>>>>>>>        // We don't allow changes to the framework's DbVersion table.
84172>>>>>>>        If (Lowercase(sTableName) = "dbversion") Begin
84174>>>>>>>            Function_Return False
84175>>>>>>>        End
84175>>>>>>>>
84175>>>>>>>
84175>>>>>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
84176>>>>>>>        Get piDbType                            to iDbType
84177>>>>>>>        Get pbRecnum                            to bRecnum
84178>>>>>>>        Get pbToANSI                            to bToANSI
84179>>>>>>>        Get pbCopyData                          to bCopyData
84180>>>>>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
84181>>>>>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
84182>>>>>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
84183>>>>>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase
84184>>>>>>>        Get IsMertechDriver sDriverIDFrom       to bMertechDriver
84185>>>>>>>        Get pbUseConnectionID                   to bUseConnectionID
84186>>>>>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
84188>>>>>>>            Move False                          to bUseConnectionID
84189>>>>>>>        End
84189>>>>>>>>
84189>>>>>>>
84189>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
84190>>>>>>>        Set Private.phCurrentTable              to hTable
84191>>>>>>>        Get UtilTableExists  hTable             to bTableExists
84192>>>>>>>
84192>>>>>>>        If (ghoProgressBar <> 0) Begin
84194>>>>>>>            Send DoAdvance of ghoProgressBar
84195>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
84196>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
84197>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
84198>>>>>>>        End
84198>>>>>>>>
84198>>>>>>>
84198>>>>>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
84199>>>>>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
84200>>>>>>>        Get UtilTableIsSQL hTable               to bIsSQLTableTo
84201>>>>>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
84202>>>>>>>        Move True                               to APITableFrom.bFromTable
84203>>>>>>>        Move hTable                             to APITableFrom.hTable
84204>>>>>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
84205>>>>>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
84206>>>>>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
84207>>>>>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
84208>>>>>>>
84208>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
84210>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
84211>>>>>>>            If (bOk = True) Begin
84213>>>>>>>                Get ApiTableAttachToSql hTable True to bOk
84214>>>>>>>                Function_Return bOk
84215>>>>>>>            End 
84215>>>>>>>>
84215>>>>>>>        End
84215>>>>>>>>
84215>>>>>>>
84215>>>>>>>        If (bTableExists = True) Begin
84217>>>>>>>            If (bIsSQLTableTo = True) Begin
84219>>>>>>>                Get UtilDeleteCacheFile APITableFrom.ApiTableInfo.sLogicalName to bOk
84220>>>>>>>            End
84220>>>>>>>>
84220>>>>>>>
84220>>>>>>>            Get OpenTableExclusive hTable to bOpened
84221>>>>>>>            If (bOpened = False) Begin
84223>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
84224>>>>>>>                Function_Return False
84225>>>>>>>            End
84225>>>>>>>>
84225>>>>>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
84226>>>>>>>            Get UtilColumnCombineFromAndToArrays   APITableFrom.aApiColumns   APITableTo.aApiColumns    to aAPIColumnCompare
84227>>>>>>>            Get UtilIndexCombineFromAndToArrays    APITableFrom.aApiIndexes   APITableTo.aApiIndexes    to aAPIIndexCompare
84228>>>>>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
84229>>>>>>>        End
84229>>>>>>>>
84229>>>>>>>
84229>>>>>>>        Move False to Err
84230>>>>>>>        Case Begin
84230>>>>>>>            // Alias table:
84230>>>>>>>            Case (bIsAliasFrom = True)
84232>>>>>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
84233>>>>>>>                Case Break
84234>>>>>>>
84234>>>>>>>            // New Table:
84234>>>>>>>            Case (bTableExists = False)
84237>>>>>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
84238>>>>>>>                //LR 20191112 Begin: Make file a system file if bIsSystemFile = True
84238>>>>>>>                If (APITableNameInfoFrom.bIsSystemFile) Begin
84240>>>>>>>                    Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
84241>>>>>>>                End                                                                 
84241>>>>>>>>
84241>>>>>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
84242>>>>>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
84243>>>>>>>                Case Break
84244>>>>>>>
84244>>>>>>>            // Update table:
84244>>>>>>>            Case (bTableExists = True)
84247>>>>>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
84248>>>>>>>                If (bIsSame = True) Begin
84250>>>>>>>                    Case Break
84251>>>>>>>                End
84251>>>>>>>>
84251>>>>>>>                If (bFilelistError = True) Begin
84253>>>>>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
84254>>>>>>>                    If (bOk = False) Begin
84256>>>>>>>                        Case Break
84257>>>>>>>                    End
84257>>>>>>>>
84257>>>>>>>                End
84257>>>>>>>>
84257>>>>>>>
84257>>>>>>>                If (ghoProgressBar <> 0) Begin
84259>>>>>>>                    Send DoAdvance of ghoProgressBar
84260>>>>>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
84261>>>>>>>                End
84261>>>>>>>>
84261>>>>>>>
84261>>>>>>>                // Columns:
84261>>>>>>>                Move True to bOk
84262>>>>>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
84263>>>>>>>                If (bIsSame = False) Begin
84265>>>>>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
84266>>>>>>>                End
84266>>>>>>>>
84266>>>>>>>                If (bOk = False) Begin
84268>>>>>>>                    Case Break
84269>>>>>>>                End
84269>>>>>>>>
84269>>>>>>>
84269>>>>>>>                // Indexes:
84269>>>>>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
84270>>>>>>>                If (bIsSame = False) Begin
84272>>>>>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
84273>>>>>>>                End
84273>>>>>>>>
84273>>>>>>>
84273>>>>>>>                // Relations:
84273>>>>>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
84274>>>>>>>                If (bIsSame = False) Begin
84276>>>>>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
84277>>>>>>>                    If (bOk = False) Begin
84279>>>>>>>                        Case Break
84280>>>>>>>                    End
84280>>>>>>>>
84280>>>>>>>                End
84280>>>>>>>>
84280>>>>>>>
84280>>>>>>>                Case Break
84281>>>>>>>
84281>>>>>>>            Case Else
84281>>>>>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
84282>>>>>>>>
84282>>>>>>>                Move False to bOk
84283>>>>>>>        Case End
84283>>>>>>>        
84283>>>>>>>        // Note: If the from table was SQL; we should either connect to an existing SQL to table,
84283>>>>>>>        // or convert an embedded table to SQL
84283>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
84285>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
84286>>>>>>>            If (bOk = False) Begin
84288>>>>>>>                Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOK
84289>>>>>>>            End
84289>>>>>>>>
84289>>>>>>>        End
84289>>>>>>>>
84289>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
84292>>>>>>>            Get SqlTableConvertToEmbedded hTable True to bOk
84293>>>>>>>        End
84293>>>>>>>>
84293>>>>>>>        
84293>>>>>>>        // Filelist Names:
84293>>>>>>>        Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
84294>>>>>>>        Close hTable
84295>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
84296>>>>>>>
84296>>>>>>>        Function_Return (bOK = True)
84297>>>>>>>    End_Function
84298>>>>>>>
84298>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84298>>>>>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
84300>>>>>>>        Function_Return False
84301>>>>>>>    End_Function
84302>>>>>>>
84302>>>>>>>    // Adds a column name to the passed table number.
84302>>>>>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
84304>>>>>>>        Integer iColumn iCount iFile iPrecision iLastErr
84304>>>>>>>        Boolean bExists bOK bInitializeValue bRetval bMertechDriver
84304>>>>>>>        String sDataPath sDdSrcPath sTableName sColumnValue sDriverID
84304>>>>>>>
84304>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
84305>>>>>>>        If (bExists = True) Begin
84307>>>>>>>            Function_Return False
84308>>>>>>>        End
84308>>>>>>>>
84308>>>>>>>
84308>>>>>>>        Move False to Err
84309>>>>>>>        If (num_arguments > 4) Begin
84311>>>>>>>            Move iPrec to iPrecision
84312>>>>>>>        End
84312>>>>>>>>
84312>>>>>>>        If (num_arguments > 6) Begin
84314>>>>>>>            Move bInitVal to bInitializeValue
84315>>>>>>>            Move sColVal  to sColumnValue
84316>>>>>>>        End
84316>>>>>>>>
84316>>>>>>>        If (iType < -1490) Begin
84318>>>>>>>            Move (iType + 1500) to iType
84319>>>>>>>        End
84319>>>>>>>>
84319>>>>>>>
84319>>>>>>>        Move hTable to iFile
84320>>>>>>>        Get psDriverID to sDriverID
84321>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
84322>>>>>>>        Get AutoConnectionIDLogin to bOK
84323>>>>>>>        Move False to Err
84324>>>>>>>        Move LastErr to iLastErr
84325>>>>>>>        Get OpenTableExclusive iFile to bOK
84326>>>>>>>//        Open iFile Mode DF_EXCLUSIVE
84326>>>>>>>        Set Private.phCurrentTable to hTable
84327>>>>>>>        Structure_Start iFile sDriverID
84328>>>>>>>            Move 0 to iColumn
84329>>>>>>>            Set Private.piCurrentField to iColumn
84330>>>>>>>            Create_Field hTable At iColumn
84331>>>>>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
84334>>>>>>>            If (bMertechDriver = True) Begin
84336>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84337>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_BAD_ATTRIBUTE_VALUE
84338>>>>>>>            End
84338>>>>>>>>
84338>>>>>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
84341>>>>>>>            If (bMertechDriver = True) Begin
84343>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
84344>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_BAD_ATTRIBUTE_VALUE
84345>>>>>>>                Move False to Err
84346>>>>>>>                Move iLastErr to LastErr
84347>>>>>>>            End
84347>>>>>>>>
84347>>>>>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
84350>>>>>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
84353>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
84354>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84356>>>>>>>
84356>>>>>>>        Set Action_Text of ghoStatusPanel to ""
84357>>>>>>>
84357>>>>>>>        // If in development environment; create .fd file:
84357>>>>>>>        Open hTable
84359>>>>>>>        Get psDdSrcPath  of (phoWorkspace(ghoApplication)) to sDDSrcPath
84360>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
84361>>>>>>>        If (iCount > 1) Begin
84363>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
84364>>>>>>>        End
84364>>>>>>>>
84364>>>>>>>        Get vFolderExists sDDSrcPath to bExists
84365>>>>>>>        If (bExists = True) Begin
84367>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
84368>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
84371>>>>>>>            Get _TableNameOnly sTableName to sTableName
84372>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
84374>>>>>>>        End
84374>>>>>>>>
84374>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin  // We only want a tag if DataFlex embedded db
84376>>>>>>>            Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
84377>>>>>>>            Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
84378>>>>>>>            If (iCount > 1) Begin
84380>>>>>>>                Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
84381>>>>>>>            End
84381>>>>>>>>
84381>>>>>>>            Get vFolderFormat sDataPath to sDataPath
84382>>>>>>>            // Add the new column name to the .tag filen (if it doesn't exist):
84382>>>>>>>            // The following line should not be necexxary for the DataFlex driver. (Thank you, Hans van de Laar)
84382>>>>>>>            //Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sFieldName to bOK
84382>>>>>>>        End
84382>>>>>>>>
84382>>>>>>>        // Check for a default value
84382>>>>>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
84384>>>>>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
84385>>>>>>>        End
84385>>>>>>>>
84385>>>>>>>        Close hTable
84386>>>>>>>
84386>>>>>>>        Function_Return (Err = False)
84387>>>>>>>    End_Function
84388>>>>>>>
84388>>>>>>>    // Adds a column name to the passed table number.
84388>>>>>>>    Function ApiColumnInsert String sDriverIDFrom Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
84390>>>>>>>        Integer iCount iFile iPrecision iNumberOfFields iDbType
84390>>>>>>>        Boolean bExists bOK bIsDateType bIsSQLTypeTo
84390>>>>>>>        String sDdSrcPath sTableName
84390>>>>>>>
84390>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
84391>>>>>>>        Move False to Err
84392>>>>>>>        If (bExists = True) Begin
84394>>>>>>>            Function_Return False
84395>>>>>>>        End
84395>>>>>>>>
84395>>>>>>>        If (num_arguments > 4) Begin
84397>>>>>>>            Move iPrec to iPrecision
84398>>>>>>>        End
84398>>>>>>>>
84398>>>>>>>        If (iType < -1490) Begin
84400>>>>>>>            Move (iType + 1500) to iType
84401>>>>>>>        End
84401>>>>>>>>
84401>>>>>>>
84401>>>>>>>        Get AutoConnectionIDLogin to bOK
84402>>>>>>>        Move False to Err
84403>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTypeTo
84404>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
84404>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types. 
84404>>>>>>>        Get piDbType to iDbType
84405>>>>>>>        If (bIsSQLTypeTo = False) Begin
84407>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iType iLength to iType
84408>>>>>>>            If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
84410>>>>>>>                Move DF_DATE to iType
84411>>>>>>>            End
84411>>>>>>>>
84411>>>>>>>        End
84411>>>>>>>>
84411>>>>>>>
84411>>>>>>>        // Structure_start will change the value of hTable...
84411>>>>>>>        Move hTable to iFile
84412>>>>>>>        Get OpenTableExclusive iFile to bOK
84413>>>>>>>        If (bOK = False) Begin
84415>>>>>>>            Function_Return False
84416>>>>>>>        End
84416>>>>>>>>
84416>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
84419>>>>>>>
84419>>>>>>>        // If the passed column number is higher than the current number of fields
84419>>>>>>>        // in the table, this means we should _not_ insert a field but rather add
84419>>>>>>>        // a new field to the end:
84419>>>>>>>        If (iColumn > iNumberOfFields) Begin
84421>>>>>>>            Move 0 to iColumn
84422>>>>>>>        End
84422>>>>>>>>
84422>>>>>>>
84422>>>>>>>        Set Private.phCurrentTable to hTable
84423>>>>>>>        Set Private.piCurrentField to iColumn
84424>>>>>>>
84424>>>>>>>        Structure_Start iFile
84425>>>>>>>            Create_Field iFile At iColumn
84426>>>>>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
84429>>>>>>>            If (bIsSQLTypeTo = False) Begin
84431>>>>>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
84434>>>>>>>            End
84434>>>>>>>>
84434>>>>>>>            Else Begin
84435>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
84438>>>>>>>            End
84438>>>>>>>>
84438>>>>>>>            Get UtilColumnIsDateType iType bIsSQLTypeTo to bIsDateType
84439>>>>>>>            If (bIsDateType = False) Begin
84441>>>>>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
84444>>>>>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
84447>>>>>>>            End
84447>>>>>>>>
84447>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
84448>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84450>>>>>>>
84450>>>>>>>        Set Action_Text of ghoStatusPanel to ""
84451>>>>>>>        // If in development environment; create .fd file:
84451>>>>>>>        Open hTable
84453>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
84454>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
84455>>>>>>>        If (iCount > 1) Begin
84457>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
84458>>>>>>>        End
84458>>>>>>>>
84458>>>>>>>        Get vFolderExists sDDSrcPath to bExists
84459>>>>>>>        If (bExists = True) Begin
84461>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
84462>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
84465>>>>>>>            Get _TableNameOnly sTableName to sTableName
84466>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
84468>>>>>>>        End
84468>>>>>>>>
84468>>>>>>>
84468>>>>>>>        // Check for a default value
84468>>>>>>>        Close hTable
84469>>>>>>>
84469>>>>>>>        Function_Return (Err = False)
84470>>>>>>>    End_Function
84471>>>>>>>
84471>>>>>>>//    Function ApiColumnAddMultiple Handle hTable tAPIColumn[] aColumns Returns Boolean
84471>>>>>>>//        Integer iColumn iCount iFile
84471>>>>>>>//        Boolean bExists bOK
84471>>>>>>>//        String sDdSrcPath sTableName
84471>>>>>>>//
84471>>>>>>>//        Get AutoConnectionIDLogin to bOK
84471>>>>>>>//        Move False to Err
84471>>>>>>>//
84471>>>>>>>//        // Structure_start will change the value of hTable...
84471>>>>>>>//        Move hTable to iFile
84471>>>>>>>//        Open iFile Mode DF_EXCLUSIVE
84471>>>>>>>//
84471>>>>>>>//        Structure_Start iFile
84471>>>>>>>//            Send ApiColumnsAddToTable iFile aColumns False
84471>>>>>>>//        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84471>>>>>>>//
84471>>>>>>>//        // If in development environment; create .fd file:
84471>>>>>>>//        Open hTable
84471>>>>>>>//        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
84471>>>>>>>//        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
84471>>>>>>>//        If (iCount > 1) Begin
84471>>>>>>>//            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
84471>>>>>>>//        End
84471>>>>>>>//        Get vFolderExists sDDSrcPath to bExists
84471>>>>>>>//        If (bExists = True) Begin
84471>>>>>>>//            Get vFolderFormat sDDSrcPath to sDDSrcPath
84471>>>>>>>//            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
84471>>>>>>>//            Get _TableNameOnly sTableName to sTableName
84471>>>>>>>//            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
84471>>>>>>>//        End
84471>>>>>>>//        Close hTable
84471>>>>>>>//
84471>>>>>>>//        Function_Return (Err = False)
84471>>>>>>>//    End_Function
84471>>>>>>>
84471>>>>>>>    // To update all records for a table column with a fixed value.
84471>>>>>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
84473>>>>>>>        Integer iRecs iCurrErr iField iRecord
84473>>>>>>>        Boolean bRetval bOpen
84473>>>>>>>
84473>>>>>>>        Move 0 to iRecs
84474>>>>>>>        Move False to bRetval
84475>>>>>>>        Move Err to iCurrErr
84476>>>>>>>        Move False to Err
84477>>>>>>>
84477>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
84480>>>>>>>        If (bOpen = False) Begin
84482>>>>>>>            Open hTable
84484>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
84487>>>>>>>            If (bOpen = False) Begin
84489>>>>>>>                Function_Return bRetval
84490>>>>>>>            End
84490>>>>>>>>
84490>>>>>>>        End
84490>>>>>>>>
84490>>>>>>>
84490>>>>>>>        Field_Map hTable sFieldName to iField
84492>>>>>>>        If (iField <> 0) Begin
84494>>>>>>>            Set Private.phCurrentTable to hTable
84495>>>>>>>            Set Private.piCurrentField to iField
84496>>>>>>>            Clear hTable
84497>>>>>>>            Repeat
84497>>>>>>>>
84497>>>>>>>                Vfind hTable 0 GT
84499>>>>>>>                If (Found) Begin
84501>>>>>>>                    If (ghoStatusPanel <> 0) Begin
84503>>>>>>>                        Get_Field_Value hTable 0 to iRecord
84506>>>>>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_DUF_UpdateVersion * String(iRecord))
84507>>>>>>>                    End
84507>>>>>>>>
84507>>>>>>>                    Reread hTable
84511>>>>>>>                        Set_Field_Value hTable iField to sColumnValue
84514>>>>>>>                        SaveRecord hTable
84515>>>>>>>                    Unlock
84516>>>>>>>>
84516>>>>>>>                End
84516>>>>>>>>
84516>>>>>>>           Until (not(Found))
84518>>>>>>>        End
84518>>>>>>>>
84518>>>>>>>
84518>>>>>>>        Move (Err = False) to bRetval
84519>>>>>>>        Move iCurrErr to Err
84520>>>>>>>
84520>>>>>>>        Function_Return bRetval
84521>>>>>>>    End_Function
84522>>>>>>>
84522>>>>>>>    // Note: This can only be used from within a Structure_Start/End construct.
84522>>>>>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
84524>>>>>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
84524>>>>>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
84524>>>>>>>        String sFieldName sDriverID sTableName sDefaultValue
84524>>>>>>>
84524>>>>>>>//        Set Private.phCurrentTable to hTable
84524>>>>>>>        Get psDriverID to sDriverID
84525>>>>>>>        Get piDbType to iDbType
84526>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84527>>>>>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
84528>>>>>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
84529>>>>>>>        Get UtilTableIsSQL hTable to bIsSqlTable
84530>>>>>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
84532>>>>>>>            Move True to bIsSqlTable
84533>>>>>>>        End
84533>>>>>>>>
84533>>>>>>>        Move False to bIsOpen
84534>>>>>>>        If (hTable > 0) Begin
84536>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
84539>>>>>>>        End
84539>>>>>>>>
84539>>>>>>>        If (bIsOpen = True) Begin
84541>>>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
84544>>>>>>>        End
84544>>>>>>>>
84544>>>>>>>        Else Begin
84545>>>>>>>            Get pbRecnum to bRecnumTable
84546>>>>>>>        End
84546>>>>>>>>
84546>>>>>>>
84546>>>>>>>        Move False to Err
84547>>>>>>>        Move (SizeOfArray(aColumns)) to iSize
84548>>>>>>>        Decrement iSize
84549>>>>>>>        for iCount from 0 to iSize
84555>>>>>>>>
84555>>>>>>>            Move aColumns[iCount].sFieldName to sFieldName
84556>>>>>>>            If (hTable > 0) Begin
84558>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84559>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
84560>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
84563>>>>>>>                Move (Trim(sFieldName) <> "") to bFieldExists
84564>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
84565>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
84566>>>>>>>            End
84566>>>>>>>>
84566>>>>>>>            Else Begin
84567>>>>>>>                Move False to bFieldExists
84568>>>>>>>            End
84568>>>>>>>>
84568>>>>>>>
84568>>>>>>>            If (bFieldExists = False) Begin
84570>>>>>>>                Move 0 to iColumn
84571>>>>>>>                Create_Field hTable At iColumn
84572>>>>>>>            End
84572>>>>>>>>
84572>>>>>>>            Else Begin
84573>>>>>>>                Move iCount to iColumn
84574>>>>>>>            End
84574>>>>>>>>
84574>>>>>>>
84574>>>>>>>            Set Private.piCurrentField to iColumn
84575>>>>>>>
84575>>>>>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
84576>>>>>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
84579>>>>>>>
84579>>>>>>>            Move aColumns[iCount].iType to iType
84580>>>>>>>            Move (not(iType < -1490)) to bNativeType
84581>>>>>>>            If (iType < -1490) Begin
84583>>>>>>>                Move (iType + 1500) to iType
84584>>>>>>>            End
84584>>>>>>>>
84584>>>>>>>
84584>>>>>>>            If (bIsSqlTable = True) Begin
84586>>>>>>>                If (aColumns[iCount].bIsSQLType = True) Begin
84588>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
84589>>>>>>>                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
84592>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType
84595>>>>>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
84598>>>>>>>
84598>>>>>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
84599>>>>>>>                    If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
84601>>>>>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
84602>>>>>>>                    End
84602>>>>>>>>
84602>>>>>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue
84605>>>>>>>
84605>>>>>>>                End
84605>>>>>>>>
84605>>>>>>>                Else Begin
84606>>>>>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
84609>>>>>>>                End
84609>>>>>>>>
84609>>>>>>>            End
84609>>>>>>>>
84609>>>>>>>            Else Begin
84610>>>>>>>                If (bCreating = False) Begin
84612>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
84613>>>>>>>                    If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
84615>>>>>>>                        Move DF_DATE to iType
84616>>>>>>>                    End
84616>>>>>>>>
84616>>>>>>>                End
84616>>>>>>>>
84616>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
84619>>>>>>>            End
84619>>>>>>>>
84619>>>>>>>
84619>>>>>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
84620>>>>>>>            If (bIsDateType = False) Begin
84622>>>>>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
84625>>>>>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
84628>>>>>>>            End
84628>>>>>>>>
84628>>>>>>>
84628>>>>>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
84630>>>>>>>                Move 0 to iIndex
84631>>>>>>>                Create_Index hTable at iIndex
84632>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
84635>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
84638>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
84641>>>>>>>
84641>>>>>>>                // If we have an identity table - we must create a primary_key table.
84641>>>>>>>                If (bIsSqlTable = True) Begin
84643>>>>>>>                End
84643>>>>>>>>
84643>>>>>>>            End
84643>>>>>>>>
84643>>>>>>>        Loop
84644>>>>>>>>
84644>>>>>>>
84644>>>>>>>        Function_Return (Err = False)
84645>>>>>>>    End_Function
84646>>>>>>>
84646>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
84646>>>>>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
84648>>>>>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
84648>>>>>>>        Boolean bOK bIsSqlTable
84648>>>>>>>        String sFieldNameTo
84648>>>>>>>
84648>>>>>>>        If (num_arguments > 4) Begin
84650>>>>>>>            Move iPrec to iPrecFrom
84651>>>>>>>        End
84651>>>>>>>>
84651>>>>>>>        If (iTypeFrom < -1490) Begin
84653>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
84654>>>>>>>        End
84654>>>>>>>>
84654>>>>>>>
84654>>>>>>>        Get AutoConnectionIDLogin to bOK
84655>>>>>>>        Move False to Err
84656>>>>>>>        Get OpenTableExclusive hTable to bOK
84657>>>>>>>        If (bOK = False) Begin
84659>>>>>>>            Function_Return False
84660>>>>>>>        End
84660>>>>>>>>
84660>>>>>>>
84660>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84661>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
84662>>>>>>>        Field_Map hTable sFieldNameFrom to iColumn
84664>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84665>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
84666>>>>>>>        If (Err = True) Begin
84668>>>>>>>            Function_Return False
84669>>>>>>>        End
84669>>>>>>>>
84669>>>>>>>
84669>>>>>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
84672>>>>>>>        Get UtilTableIsSQL hTable to bIsSqlTable
84673>>>>>>>        If (bIsSqlTable = False) Begin
84675>>>>>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
84678>>>>>>>        End
84678>>>>>>>>
84678>>>>>>>        Else Begin
84679>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
84682>>>>>>>        End
84682>>>>>>>>
84682>>>>>>>        // Let the driver decide the other values;
84682>>>>>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
84685>>>>>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
84688>>>>>>>
84688>>>>>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
84690>>>>>>>            Function_Return False
84691>>>>>>>        End
84691>>>>>>>>
84691>>>>>>>
84691>>>>>>>        Set Private.phCurrentTable to hTable
84692>>>>>>>        Set Private.piCurrentField to iColumn
84693>>>>>>>
84693>>>>>>>        Structure_Start hTable
84694>>>>>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
84697>>>>>>>//            If (bIsSqlTable = False) Begin
84697>>>>>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
84700>>>>>>>//            End
84700>>>>>>>//            Else Begin
84700>>>>>>>//                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
84700>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
84700>>>>>>>//            End
84700>>>>>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to (iLengthFrom + iPrecFrom)
84703>>>>>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
84706>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
84707>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84709>>>>>>>
84709>>>>>>>        Set Action_Text of ghoStatusPanel to ""
84710>>>>>>>        Function_Return (Err = False)
84711>>>>>>>    End_Function
84712>>>>>>>
84712>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
84712>>>>>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
84714>>>>>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
84714>>>>>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
84714>>>>>>>        String sFieldNameTo sDriverIDTo
84714>>>>>>>        tColumnType ColumnType
84714>>>>>>>        tColumnType ColumnType
84714>>>>>>>
84714>>>>>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
84715>>>>>>>        Get piDbType to iDbType
84716>>>>>>>        If (num_arguments > 4) Begin
84718>>>>>>>            Move iPrec to iPrecFrom
84719>>>>>>>            Move iOpt  to iOptionFrom
84720>>>>>>>        End
84720>>>>>>>>
84720>>>>>>>        If (iTypeFrom < -1490) Begin
84722>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
84723>>>>>>>        End
84723>>>>>>>>
84723>>>>>>>
84723>>>>>>>        Get AutoConnectionIDLogin to bOK
84724>>>>>>>        Move False to Err
84725>>>>>>>        Close hTable
84726>>>>>>>        Get OpenTableExclusive hTable to bOK
84727>>>>>>>        If (bOK = False) Begin
84729>>>>>>>            Function_Return False
84730>>>>>>>        End
84730>>>>>>>>
84730>>>>>>>
84730>>>>>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
84733>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
84736>>>>>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
84737>>>>>>>        If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
84739>>>>>>>            Move DF_DATE to iDataFlexType
84740>>>>>>>        End
84740>>>>>>>>
84740>>>>>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
84743>>>>>>>
84743>>>>>>>        If (bIsSQLTableTo = True) Begin
84745>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iTypeTo
84748>>>>>>>        End
84748>>>>>>>>
84748>>>>>>>        Else Begin
84749>>>>>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
84752>>>>>>>        End
84752>>>>>>>>
84752>>>>>>>
84752>>>>>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
84755>>>>>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
84758>>>>>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo
84761>>>>>>>
84761>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
84761>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types.
84761>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
84763>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeTo
84764>>>>>>>            If (iTypeTo = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
84766>>>>>>>                Move DF_DATE to iTypeTo  
84767>>>>>>>            End
84767>>>>>>>>
84767>>>>>>>        End
84767>>>>>>>>
84767>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
84770>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeFrom
84771>>>>>>>        End
84771>>>>>>>>
84771>>>>>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
84772>>>>>>>
84772>>>>>>>        If (bCompareDate_DateTime = False) Begin
84774>>>>>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
84775>>>>>>>            If (bSkip = True) Begin
84777>>>>>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
84779>>>>>>>                    Function_Return True
84780>>>>>>>                End
84780>>>>>>>>
84780>>>>>>>            End
84780>>>>>>>>
84780>>>>>>>        End
84780>>>>>>>>
84780>>>>>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
84783>>>>>>>            Function_Return True
84784>>>>>>>        End
84784>>>>>>>>
84784>>>>>>>
84784>>>>>>>        Set Private.phCurrentTable to hTable
84785>>>>>>>        Set Private.piCurrentField to iColumn
84786>>>>>>>
84786>>>>>>>        Structure_Start hTable
84787>>>>>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
84789>>>>>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
84792>>>>>>>            End
84792>>>>>>>>
84792>>>>>>>
84792>>>>>>>            If (bIsSameDataType = False) Begin
84794>>>>>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
84797>>>>>>>                If (bIsSQLTableTo = True) Begin
84799>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeFrom
84802>>>>>>>                End
84802>>>>>>>>
84802>>>>>>>            End
84802>>>>>>>>
84802>>>>>>>
84802>>>>>>>            If (iLengthFrom <> iLengthTo) Begin
84804>>>>>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
84807>>>>>>>            End
84807>>>>>>>>
84807>>>>>>>            If (iPrecFrom <> iPrecTo) Begin
84809>>>>>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
84812>>>>>>>            End
84812>>>>>>>>
84812>>>>>>>
84812>>>>>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
84814>>>>>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
84814>>>>>>>                If (bRecnumTable = True) Begin
84816>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
84819>>>>>>>                End
84819>>>>>>>>
84819>>>>>>>
84819>>>>>>>                // We might need to create an index here.
84819>>>>>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
84819>>>>>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
84819>>>>>>>                // index update checking logic.
84819>>>>>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
84822>>>>>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
84824>>>>>>>                    Create_Index hTable At iIndex
84825>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
84828>>>>>>>                End
84828>>>>>>>>
84828>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
84831>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
84834>>>>>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
84837>>>>>>>                If (bIsSQLTableTo = True) Begin
84839>>>>>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
84842>>>>>>>                End
84842>>>>>>>>
84842>>>>>>>            End
84842>>>>>>>>
84842>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
84843>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84845>>>>>>>
84845>>>>>>>        Set Action_Text of ghoStatusPanel to ""
84846>>>>>>>        Function_Return (Err = False)
84847>>>>>>>    End_Function
84848>>>>>>>
84848>>>>>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
84850>>>>>>>        Boolean bOK
84850>>>>>>>
84850>>>>>>>        Get AutoConnectionIDLogin to bOK
84851>>>>>>>        Move False to Err
84852>>>>>>>        Get OpenTableExclusive hTable to bOK
84853>>>>>>>        If (bOK = False) Begin
84855>>>>>>>            Function_Return False
84856>>>>>>>        End
84856>>>>>>>>
84856>>>>>>>
84856>>>>>>>        Structure_Start hTable
84857>>>>>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
84860>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
84861>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84863>>>>>>>
84863>>>>>>>        Set Action_Text of ghoStatusPanel to ""
84864>>>>>>>        Function_Return (Err = False)
84865>>>>>>>    End_Function
84866>>>>>>>
84866>>>>>>>    // To move an existing field to another position in a table.
84866>>>>>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Integer iLength Integer iPrecision Returns Boolean
84868>>>>>>>        String sColumn sDriverID
84868>>>>>>>        Integer iType
84868>>>>>>>        Boolean bOK bIsDate
84868>>>>>>>
84868>>>>>>>        Close hTable
84869>>>>>>>        Get AutoConnectionIDLogin to bOK
84870>>>>>>>        Get OpenTableExclusive hTable to bOK
84871>>>>>>>        If (bOK = False) Begin
84873>>>>>>>            Function_Return False
84874>>>>>>>        End
84874>>>>>>>>
84874>>>>>>>
84874>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
84877>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
84879>>>>>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
84880>>>>>>>>
84880>>>>>>>            Function_Return False
84881>>>>>>>        End
84881>>>>>>>>
84881>>>>>>>
84881>>>>>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
84884>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
84887>>>>>>>        Get UtilColumnIsDateType iType bIsSQLType  to bIsDate
84888>>>>>>>
84888>>>>>>>        Set Private.phCurrentTable to hTable
84889>>>>>>>        Set Private.piCurrentField to iOld
84890>>>>>>>
84890>>>>>>>//        If (bIsDate = False) Begin
84890>>>>>>>//            Get_Attribute DF_FIELD_LENGTH    of hTable iOld to iLength
84890>>>>>>>//            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
84890>>>>>>>//        End
84890>>>>>>>//        Else Begin
84890>>>>>>>//            Move 6 to iLength
84890>>>>>>>//            Move 0 to iPrecision
84890>>>>>>>//        End
84890>>>>>>>
84890>>>>>>>        Move False to Err
84891>>>>>>>
84891>>>>>>>        Structure_Start hTable
84892>>>>>>>            Delete_Field hTable iOld
84893>>>>>>>            Create_Field hTable At iNew
84894>>>>>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
84897>>>>>>>
84897>>>>>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
84900>>>>>>>            If (bIsSQLType = False) Begin
84902>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
84905>>>>>>>            End
84905>>>>>>>>
84905>>>>>>>            Else Begin
84906>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
84909>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType
84909>>>>>>>            End
84909>>>>>>>>
84909>>>>>>>
84909>>>>>>>            If (bIsDate = False) Begin
84911>>>>>>>                Set_Attribute DF_FIELD_LENGTH    of hTable iNew to iLength
84914>>>>>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
84917>>>>>>>            End
84917>>>>>>>>
84917>>>>>>>
84917>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
84918>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84920>>>>>>>
84920>>>>>>>        Set Action_Text of ghoStatusPanel to ""
84921>>>>>>>        Function_Return (Err = False)
84922>>>>>>>    End_Function
84923>>>>>>>
84923>>>>>>>    // Deletes a column name for the passed table number (and column number).
84923>>>>>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
84925>>>>>>>        Integer iColumn
84925>>>>>>>        Boolean bOK
84925>>>>>>>
84925>>>>>>>        Get AutoConnectionIDLogin to bOK
84926>>>>>>>        Move False to Err
84927>>>>>>>        Close hTable
84928>>>>>>>        Get OpenTableExclusive hTable to bOK
84929>>>>>>>        If (bOK = False) Begin
84931>>>>>>>            Function_Return False
84932>>>>>>>        End
84932>>>>>>>>
84932>>>>>>>
84932>>>>>>>        If (not(Err)) Begin
84934>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84935>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
84936>>>>>>>            Field_Map hTable sFieldName to iColumn
84938>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
84939>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
84940>>>>>>>            If (iColumn = 0) Begin
84942>>>>>>>                Move 0 to LastErr
84943>>>>>>>                Function_Return False
84944>>>>>>>            End
84944>>>>>>>>
84944>>>>>>>            Move False to Err
84945>>>>>>>
84945>>>>>>>            Set Private.phCurrentTable to hTable
84946>>>>>>>            Set Private.piCurrentField to iColumn
84947>>>>>>>
84947>>>>>>>            Structure_Start hTable
84948>>>>>>>                Delete_Field hTable iColumn
84949>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
84950>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84952>>>>>>>            Set Action_Text of ghoStatusPanel to ""
84953>>>>>>>        End
84953>>>>>>>>
84953>>>>>>>        Else Begin
84954>>>>>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
84955>>>>>>>>
84955>>>>>>>        End
84955>>>>>>>>
84955>>>>>>>
84955>>>>>>>        Function_Return (Err = False)
84956>>>>>>>    End_Function
84957>>>>>>>
84957>>>>>>>    // Renames a field for the passed table number & old field name & new field name
84957>>>>>>>    // Returns True if no errors occured.
84957>>>>>>>    // Sample usage:
84957>>>>>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
84957>>>>>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
84959>>>>>>>        Integer iField
84959>>>>>>>        Boolean bOK bExists bIsOpen
84959>>>>>>>
84959>>>>>>>        Get UtilColumnExists hTable sNewFieldName to bExists
84960>>>>>>>        If (bExists = True) Begin
84962>>>>>>>            Function_Return False
84963>>>>>>>        End
84963>>>>>>>>
84963>>>>>>>
84963>>>>>>>        // Note: The Field_Map command does _not_ work if the table has been
84963>>>>>>>        //       opened exclusively, so we first open it in normal mode.
84963>>>>>>>        Close hTable
84964>>>>>>>        Open hTable
84966>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
84969>>>>>>>        If (bIsOpen = False) Begin
84971>>>>>>>            Function_Return False
84972>>>>>>>        End
84972>>>>>>>>
84972>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84973>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
84974>>>>>>>        Field_Map hTable sOldFieldName to iField
84976>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
84977>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84978>>>>>>>
84978>>>>>>>        Get AutoConnectionIDLogin to bOK
84979>>>>>>>        Get OpenTableExclusive hTable to bOK
84980>>>>>>>        If (bOK = False) Begin
84982>>>>>>>            Function_Return False
84983>>>>>>>        End
84983>>>>>>>>
84983>>>>>>>
84983>>>>>>>        Move False to Err
84984>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
84985>>>>>>>        Set Private.phCurrentTable to hTable
84986>>>>>>>        Set Private.piCurrentField to iField
84987>>>>>>>
84987>>>>>>>        If (iField > 0) Begin
84989>>>>>>>            Structure_Start hTable
84990>>>>>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
84993>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
84994>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84996>>>>>>>        End
84996>>>>>>>>
84996>>>>>>>        Else Begin
84997>>>>>>>            Move 0 to LastErr
84998>>>>>>>            Move False to Err
84999>>>>>>>        End
84999>>>>>>>>
84999>>>>>>>
84999>>>>>>>        Set Action_Text of ghoStatusPanel to ""
85000>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
85001>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85002>>>>>>>
85002>>>>>>>        Function_Return (Err = False)
85003>>>>>>>    End_Function
85004>>>>>>>
85004>>>>>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
85006>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
85006>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
85007>>>>>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo iColumnNumber
85007>>>>>>>        Boolean bRenameField
85007>>>>>>>
85007>>>>>>>        Open hTable
85009>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85010>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
85011>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
85012>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
85015>>>>>>>        Move (iSize max iNumberOfFieldsTo) to iSize
85016>>>>>>>        Decrement iSize
85017>>>>>>>        for iCount from 0 to iSize
85023>>>>>>>>
85023>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
85025>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85026>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
85027>>>>>>>
85027>>>>>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
85029>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iFieldTo = 0) Begin
85031>>>>>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iColumnNumber
85032>>>>>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount]      to bRenameField
85033>>>>>>>                    If (iColumnNumber = -1 and bRenameField = False) Begin
85035>>>>>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber
85036>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
85037>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom
85038>>>>>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
85039>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
85040>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
85041>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
85042>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
85043>>>>>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
85044>>>>>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
85045>>>>>>>                        Increment iItem
85046>>>>>>>                    End
85046>>>>>>>>
85046>>>>>>>                End
85046>>>>>>>>
85046>>>>>>>            End
85046>>>>>>>>
85046>>>>>>>        Loop
85047>>>>>>>>
85047>>>>>>>
85047>>>>>>>        Move False to Err
85048>>>>>>>        Move 0 to LastErr
85049>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85050>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
85051>>>>>>>        Function_Return aAPIColumnsToInsert
85052>>>>>>>    End_Function
85053>>>>>>>
85053>>>>>>>    Function UtilColumnsInsert String sDriverIDFrom Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
85055>>>>>>>        Integer iSize iCount
85055>>>>>>>        Boolean bOK
85055>>>>>>>        tAPIColumn[] aColumnsTo
85055>>>>>>>        tAPIColumn[] aColumnsTo
85056>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
85056>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
85057>>>>>>>
85057>>>>>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
85058>>>>>>>        If (iSize = 0) Begin
85060>>>>>>>            Function_Return True
85061>>>>>>>        End
85061>>>>>>>>
85061>>>>>>>
85061>>>>>>>        Move False to Err
85062>>>>>>>        Decrement iSize
85063>>>>>>>        for iCount from 0 to iSize
85069>>>>>>>>
85069>>>>>>>            Get ApiColumnInsert sDriverIDFrom hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
85070>>>>>>>        Loop
85071>>>>>>>>
85071>>>>>>>
85071>>>>>>>        Function_Return bOK
85072>>>>>>>    End_Function
85073>>>>>>>
85073>>>>>>>    // Returns a struct array with fields that has the same names but different field numbers.
85073>>>>>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
85075>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
85075>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
85076>>>>>>>        Integer iSize iCount iItem iShouldMove
85076>>>>>>>
85076>>>>>>>        Move 0 to iItem
85077>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
85078>>>>>>>        Decrement iSize
85079>>>>>>>        for iCount from 0 to iSize
85085>>>>>>>>
85085>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
85087>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
85088>>>>>>>                If (iShouldMove <> -1) Begin
85090>>>>>>>                    Move aAPIColumnCompare[iCount] to aAPIColumnsToMove[iItem]
85091>>>>>>>                    Move iShouldMove               to aAPIColumnsToMove[iItem].iFieldNumberTo
85092>>>>>>>                    Move aAPIColumnCompare[iShouldMove - 1].sFieldNameTo to aAPIColumnsToMove[iItem].sFieldNameTo
85093>>>>>>>                    Increment iItem
85094>>>>>>>                End
85094>>>>>>>>
85094>>>>>>>            End
85094>>>>>>>>
85094>>>>>>>        Loop
85095>>>>>>>>
85095>>>>>>>
85095>>>>>>>        Move False to Err
85096>>>>>>>        Move 0 to LastErr
85097>>>>>>>        Function_Return aAPIColumnsToMove
85098>>>>>>>    End_Function
85099>>>>>>>
85099>>>>>>>    Function UtilColumnsMove Handle hTable tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
85101>>>>>>>        Integer iSize iCount
85101>>>>>>>        Boolean bOK
85101>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
85101>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
85102>>>>>>>
85102>>>>>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
85103>>>>>>>        If (iSize = 0) Begin
85105>>>>>>>            Function_Return True
85106>>>>>>>        End
85106>>>>>>>>
85106>>>>>>>
85106>>>>>>>        Move False to Err
85107>>>>>>>        Decrement iSize
85108>>>>>>>        for iCount from 0 to iSize
85114>>>>>>>>
85114>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85115>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
85116>>>>>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
85118>>>>>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom aAPIColumnsToMove[iCount].iLengthFrom aAPIColumnsToMove[iCount].iPrecisionFrom to bOK
85119>>>>>>>                Get UtilColumnsStructFill hTable to aColumnsTo
85120>>>>>>>                Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
85121>>>>>>>                Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIColumnsToMove
85122>>>>>>>                If (SizeOfArray(aAPIColumnsToMove)) Begin
85124>>>>>>>                    Move (SizeOfArray(aAPIColumnsToMove)) to iSize
85125>>>>>>>                    Decrement iSize
85126>>>>>>>                    Move 0 to iCount
85127>>>>>>>                End
85127>>>>>>>>
85127>>>>>>>            End
85127>>>>>>>>
85127>>>>>>>        Loop
85128>>>>>>>>
85128>>>>>>>
85128>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85129>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
85130>>>>>>>        If (LastErr = DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) Begin
85132>>>>>>>            Move 0 to LastErr
85133>>>>>>>        End
85133>>>>>>>>
85133>>>>>>>        Function_Return bOK
85134>>>>>>>    End_Function
85135>>>>>>>
85135>>>>>>>    // Checks if the "FROM" and "TO" database field is the same _except_ for the field name.
85135>>>>>>>    // We then assume this field should be renamed.
85135>>>>>>>//    Function UtilColumCheckRename Handle hTable tAPIColumnCompare aAPIColumnCompare Returns Boolean
85135>>>>>>>//        Boolean bDifferentFieldNames bShouldBeRenamed
85135>>>>>>>//
85135>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85135>>>>>>>//        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom) <> Uppercase(aAPIColumnCompare.sFieldNameTo)) to bDifferentFieldNames
85135>>>>>>>//
85135>>>>>>>//        If (bDifferentFieldNames = True) Begin
85135>>>>>>>//            Move (aAPIColumnCompare.iFieldNumber = aAPIColumnCompare.iFieldNumberTo) to bShouldBeRenamed
85135>>>>>>>//            If (bShouldBeRenamed = False) Begin
85135>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
85135>>>>>>>//                Function_Return False
85135>>>>>>>//            End
85135>>>>>>>//
85135>>>>>>>//            Move (aAPIColumnCompare.iTypeFrom = aAPIColumnCompare.iTypeTo) to bShouldBeRenamed
85135>>>>>>>//            If (bShouldBeRenamed = False) Begin
85135>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
85135>>>>>>>//                Function_Return False
85135>>>>>>>//            End
85135>>>>>>>//
85135>>>>>>>//            Move (aAPIColumnCompare.iLengthFrom = aAPIColumnCompare.iLengthTo) to bShouldBeRenamed
85135>>>>>>>//            If (bShouldBeRenamed = False) Begin
85135>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
85135>>>>>>>//                Function_Return False
85135>>>>>>>//            End
85135>>>>>>>//
85135>>>>>>>//            Move (aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo) to bShouldBeRenamed
85135>>>>>>>//            If (bShouldBeRenamed = False) Begin
85135>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
85135>>>>>>>//                Function_Return False
85135>>>>>>>//            End
85135>>>>>>>//        End
85135>>>>>>>//
85135>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
85135>>>>>>>//        Function_Return True
85135>>>>>>>//    End_Function
85135>>>>>>>
85135>>>>>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
85135>>>>>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
85135>>>>>>>    // - The "FROM" field name is <> "TO" field name
85135>>>>>>>//    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
85135>>>>>>>//    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
85135>>>>>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
85137>>>>>>>        Boolean bShouldRename
85137>>>>>>>        String sFieldNameFrom sFieldNameTo
85137>>>>>>>
85137>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
85138>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo
85139>>>>>>>        If (sFieldNameFrom = sFieldNameTo) Begin
85141>>>>>>>            Function_Return False
85142>>>>>>>        End
85142>>>>>>>>
85142>>>>>>>
85142>>>>>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
85143>>>>>>>//        If (bShouldRename = False) Begin
85143>>>>>>>//            Function_Return False
85143>>>>>>>//        End
85143>>>>>>>//
85143>>>>>>>//        If (sFieldNameFrom contains sFieldNameTo) Begin
85143>>>>>>>//            Function_Return True
85143>>>>>>>//        End
85143>>>>>>>
85143>>>>>>>        Function_Return bShouldRename
85144>>>>>>>    End_Function
85145>>>>>>>
85145>>>>>>>    // Returns -1 if the passed iColumn number doesn't exist with the same name in the aAPIColumnCompare struct array.
85145>>>>>>>    // Else it returns the column/field number of the field that exists in another position.
85145>>>>>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Integer
85147>>>>>>>        Integer iCount iSize iRetval
85147>>>>>>>        String sFieldNameFrom
85147>>>>>>>
85147>>>>>>>        Move -1 to iRetval
85148>>>>>>>        If (aAPIColumnCompare[iColumn].bExistsFrom = False or aAPIColumnCompare[iColumn].bExistsTo = False) Begin
85150>>>>>>>            Function_Return iRetval
85151>>>>>>>        End
85151>>>>>>>>
85151>>>>>>>
85151>>>>>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
85152>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
85153>>>>>>>        Decrement iSize
85154>>>>>>>        for iCount from 0 to iSize
85160>>>>>>>>
85160>>>>>>>            // We're only interested in fields other than the passed field/column number:
85160>>>>>>>            If (iCount <> iColumn) Begin
85162>>>>>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
85164>>>>>>>                    Move (iCount + 1) to iRetval
85165>>>>>>>                End
85165>>>>>>>>
85165>>>>>>>            End
85165>>>>>>>>
85165>>>>>>>        Loop
85166>>>>>>>>
85166>>>>>>>
85166>>>>>>>        Move 0 to LastErr
85167>>>>>>>        Function_Return iRetval
85168>>>>>>>    End_Function
85169>>>>>>>
85169>>>>>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
85171>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
85171>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
85172>>>>>>>        Integer iSize iCount iItem iFieldTo iShouldMove
85172>>>>>>>        Boolean bRenameField
85172>>>>>>>
85172>>>>>>>        Open hTable
85174>>>>>>>        Move 0 to iItem
85175>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
85176>>>>>>>        Decrement iSize
85177>>>>>>>        for iCount from 0 to iSize
85183>>>>>>>>
85183>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
85185>>>>>>>                // Check if the field exists in another position (other field number)
85185>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
85186>>>>>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
85187>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iShouldMove = -1 and bRenameField = True) Begin
85189>>>>>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber
85190>>>>>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo
85191>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
85192>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
85193>>>>>>>                    Increment iItem
85194>>>>>>>                End
85194>>>>>>>>
85194>>>>>>>            End
85194>>>>>>>>
85194>>>>>>>        Loop
85195>>>>>>>>
85195>>>>>>>
85195>>>>>>>        Move False to Err
85196>>>>>>>        Move 0 to LastErr
85197>>>>>>>        Function_Return aAPIColumnsToRename
85198>>>>>>>    End_Function
85199>>>>>>>
85199>>>>>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
85201>>>>>>>        Integer iSize iCount
85201>>>>>>>        Boolean bOK
85201>>>>>>>        tAPIColumn[] aColumnsTo
85201>>>>>>>        tAPIColumn[] aColumnsTo
85202>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
85202>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
85203>>>>>>>
85203>>>>>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
85204>>>>>>>        If (iSize = 0) Begin
85206>>>>>>>            Function_Return True
85207>>>>>>>        End
85207>>>>>>>>
85207>>>>>>>
85207>>>>>>>        Move False to Err
85208>>>>>>>        Decrement iSize
85209>>>>>>>        For iCount from 0 to iSize
85215>>>>>>>>
85215>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85216>>>>>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK
85217>>>>>>>        Loop
85218>>>>>>>>
85218>>>>>>>
85218>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85219>>>>>>>        Function_Return bOK
85220>>>>>>>    End_Function
85221>>>>>>>
85221>>>>>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
85223>>>>>>>        Boolean bDateType
85223>>>>>>>
85223>>>>>>>        If (bIsSQLTableTo = True) Begin
85225>>>>>>>            Move (iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
85226>>>>>>>        End
85226>>>>>>>>
85226>>>>>>>        Else Begin
85227>>>>>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
85228>>>>>>>        End
85228>>>>>>>>
85228>>>>>>>
85228>>>>>>>        Function_Return bDateType
85229>>>>>>>    End_Function
85230>>>>>>>
85230>>>>>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
85232>>>>>>>        Integer iCount iColumns iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
85232>>>>>>>        Integer iCount2 iColumn2
85232>>>>>>>        Handle hFile
85232>>>>>>>        Boolean bFieldExistsFrom bFieldExistsTo bIsSQLDriver bIsSame bOK bSkip
85232>>>>>>>        Boolean bRecnum bIsSQLTableTo bRecnumTable bIsOpen bSkipTypeChange bIsDateType
85232>>>>>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
85232>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
85232>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
85237>>>>>>>        tColumnType ColumnType
85237>>>>>>>        tColumnType ColumnType
85237>>>>>>>
85237>>>>>>>        Move False to Err
85238>>>>>>>        Close hTable
85239>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
85240>>>>>>>        If (bIsOpen = False) Begin
85242>>>>>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
85243>>>>>>>>
85243>>>>>>>            Function_Return False
85244>>>>>>>        End 
85244>>>>>>>>
85244>>>>>>>        
85244>>>>>>>        Get piDbType to iDbType
85245>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
85248>>>>>>>        Move bIsSQLTableFrom to bIsSQLDriver
85249>>>>>>>        Get UtilTableIsSQL hTable to bIsSQLTableTo
85250>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
85253>>>>>>>
85253>>>>>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
85254>>>>>>>
85254>>>>>>>        // Before we start to change the table we need to do three things;
85254>>>>>>>        // 1) Insert any new fields
85254>>>>>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
85255>>>>>>>        If (SizeOfArray(aApiInsertColumns)) Begin
85257>>>>>>>            Get UtilColumnsInsert sDriverIDFrom hTable aApiInsertColumns to bOK
85258>>>>>>>            If (bOK = False) Begin
85260>>>>>>>                Function_Return False
85261>>>>>>>            End
85261>>>>>>>>
85261>>>>>>>            // Update info with changes made.
85261>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
85262>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
85263>>>>>>>        End
85263>>>>>>>>
85263>>>>>>>
85263>>>>>>>        // 2) Move fields with same names
85263>>>>>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
85264>>>>>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
85266>>>>>>>            Get UtilColumnsMove hTable aColumnsFrom aColumnsTo aAPIMoveColumns to bOK
85267>>>>>>>            If (bOK = False) Begin
85269>>>>>>>                Function_Return False
85270>>>>>>>            End
85270>>>>>>>>
85270>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
85271>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
85272>>>>>>>        End
85272>>>>>>>>
85272>>>>>>>        
85272>>>>>>>        // 3) Rename fields
85272>>>>>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
85273>>>>>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
85275>>>>>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
85276>>>>>>>            If (bOK = False) Begin
85278>>>>>>>                Function_Return False
85279>>>>>>>            End
85279>>>>>>>>
85279>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
85280>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
85281>>>>>>>        End
85281>>>>>>>>
85281>>>>>>>
85281>>>>>>>        // 4) Remove fields if more fields currently exists compared to the new table definition.
85281>>>>>>>//        Get utilColumnsCheckForRemoves hTable aAPIColumnCompare to aAPIRemoveColumns
85281>>>>>>>//        If (SizeOfArray(aAPIRemoveColumns)) Begin
85281>>>>>>>//            Get UtilColumnsRemove hTable aAPIRemoveColumns to bOK
85281>>>>>>>//            If (bOK = False) Begin
85281>>>>>>>//                Function_Return False
85281>>>>>>>//            End
85281>>>>>>>//            Get UtilColumnsStructFill hTable to aColumnsTo
85281>>>>>>>//            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
85281>>>>>>>//        End
85281>>>>>>>
85281>>>>>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again:
85281>>>>>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
85283>>>>>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
85284>>>>>>>            If (bIsSame = True) Begin
85286>>>>>>>                Function_Return True
85287>>>>>>>            End
85287>>>>>>>>
85287>>>>>>>        End
85287>>>>>>>>
85287>>>>>>>
85287>>>>>>>        // We can now continue to make standard field changes:
85287>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
85288>>>>>>>        Set Private.phCurrentTable to hTable
85289>>>>>>>        Move hTable to hFile
85290>>>>>>>        Structure_Start hFile sDriverIDTo
85291>>>>>>>
85291>>>>>>>            Move (SizeOfArray(aAPIColumnCompare)) to iColumns
85292>>>>>>>            Decrement iColumns
85293>>>>>>>            for iCount from 0 to iColumns
85299>>>>>>>>
85299>>>>>>>                Send DoAdvance of ghoProgressBar
85300>>>>>>>
85300>>>>>>>                Move aAPIColumnCompare[iCount].iFieldNumber to iColumn
85301>>>>>>>                Set Private.piCurrentField                  to iColumn
85302>>>>>>>                Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom aAPIColumnCompare[iCount].bIsSQLTypeTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
85303>>>>>>>                If (bIsSame = False) Begin
85305>>>>>>>
85305>>>>>>>                    Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
85306>>>>>>>                    If (bFieldExistsFrom = True) Begin
85308>>>>>>>                        Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
85309>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
85310>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom
85311>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
85312>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
85313>>>>>>>
85313>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
85314>>>>>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
85315>>>>>>>                        If (iTypeFrom < -1490) Begin
85317>>>>>>>                            Move (iTypeFrom + 1500)                     to iTypeFrom
85318>>>>>>>                        End
85318>>>>>>>>
85318>>>>>>>
85318>>>>>>>                        // If one of the two tables are SQL and the other Embedded we need to "translate"
85318>>>>>>>                        // data types between Embedded and SQL, else we can't compare the data types.
85318>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
85320>>>>>>>                            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
85321>>>>>>>                            If (iTypeFrom = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
85323>>>>>>>                                Move DF_DATE to iTypeFrom
85324>>>>>>>                            End
85324>>>>>>>>
85324>>>>>>>                        End
85324>>>>>>>>
85324>>>>>>>                        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
85327>>>>>>>                            Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
85328>>>>>>>                        End
85328>>>>>>>>
85328>>>>>>>
85328>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
85329>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
85330>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
85331>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
85332>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
85333>>>>>>>
85333>>>>>>>                        Move False to bSkipTypeChange
85334>>>>>>>                        If (bCompareDate_DateTime = False) Begin
85336>>>>>>>                            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
85337>>>>>>>                        End
85337>>>>>>>>
85337>>>>>>>
85337>>>>>>>                        If (bFieldExistsTo = False) Begin
85339>>>>>>>                            Move 0 to iColumn
85340>>>>>>>                            Create_Field hFile At iColumn
85341>>>>>>>                            Set Private.piCurrentField to iColumn
85342>>>>>>>                        End
85342>>>>>>>>
85342>>>>>>>
85342>>>>>>>                        If (sFieldNameFrom <> sFieldNameTo) Begin
85344>>>>>>>                            Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
85347>>>>>>>                        End
85347>>>>>>>>
85347>>>>>>>
85347>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity) Begin
85349>>>>>>>                            Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
85352>>>>>>>                            Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
85353>>>>>>>                            If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
85355>>>>>>>                                Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
85356>>>>>>>                            End
85356>>>>>>>>
85356>>>>>>>                            Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
85359>>>>>>>                        End
85359>>>>>>>>
85359>>>>>>>
85359>>>>>>>                        If (bSkipTypeChange = False) Begin
85361>>>>>>>                            If (iTypeFrom <> iTypeTo) Begin
85363>>>>>>>                                If (bIsSQLTableTo = True) Begin
85365>>>>>>>                                    Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iTypeFrom
85368>>>>>>>                                End
85368>>>>>>>>
85368>>>>>>>                                Else Begin                                                   
85369>>>>>>>                                    If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
85371>>>>>>>                                        Move DF_DATE to iDataFlexType  // Date
85372>>>>>>>                                    End
85372>>>>>>>>
85372>>>>>>>                                    Set_Attribute DF_FIELD_TYPE of hFile iColumn to iDataFlexType
85375>>>>>>>                                End
85375>>>>>>>>
85375>>>>>>>                            End
85375>>>>>>>>
85375>>>>>>>                        End
85375>>>>>>>>
85375>>>>>>>
85375>>>>>>>                        Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType
85376>>>>>>>                        // We can't set the length or precision for Date type columns (they are fixed).
85376>>>>>>>                        If (bIsDateType = False) Begin
85378>>>>>>>                            If (iLengthFrom <> iLengthTo) Begin
85380>>>>>>>                                Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
85383>>>>>>>                            End
85383>>>>>>>>
85383>>>>>>>                            If (iPrecisionFrom <> iPrecisionTo) Begin
85385>>>>>>>                                Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
85388>>>>>>>                            End
85388>>>>>>>>
85388>>>>>>>                        End
85388>>>>>>>>
85388>>>>>>>
85388>>>>>>>                        If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
85390>>>>>>>                            // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
85390>>>>>>>                            If (bRecnumTable = True) Begin
85392>>>>>>>                                Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
85395>>>>>>>                            End
85395>>>>>>>>
85395>>>>>>>
85395>>>>>>>                            // We might need to create an index here.
85395>>>>>>>                            // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
85395>>>>>>>                            // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
85395>>>>>>>                            // index update checking logic.
85395>>>>>>>                            Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
85398>>>>>>>                            If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
85400>>>>>>>                                Create_Index hFile at iIndex
85401>>>>>>>                                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
85404>>>>>>>                            End
85404>>>>>>>>
85404>>>>>>>
85404>>>>>>>                            Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
85407>>>>>>>                            Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
85410>>>>>>>                                // Note: The order of these two are crucial!
85410>>>>>>>                                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
85413>>>>>>>                                Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
85416>>>>>>>                        End
85416>>>>>>>>
85416>>>>>>>                    End
85416>>>>>>>>
85416>>>>>>>                    Else Begin
85417>>>>>>>                        Delete_Field hFile iColumn
85418>>>>>>>                        Move (RemoveFromArray(aColumnsTo, iCount)) to aColumnsTo
85419>>>>>>>                        Move (SizeOfArray(aColumnsTo)) to iCount2
85420>>>>>>>                        Decrement iCount2
85421>>>>>>>                        // We need to adjust FieldNumbers in the array with one, as we just deleted a field,
85421>>>>>>>                        // starting with the array number we just deleted the field for.
85421>>>>>>>                        for iColumn2 from iCount to iCount2
85427>>>>>>>>
85427>>>>>>>                            Move (aColumnsTo[iColumn2].iFieldNumber - 1) to aColumnsTo[iColumn2].iFieldNumber
85428>>>>>>>                        Loop
85429>>>>>>>>
85429>>>>>>>                        Decrement iCount
85430>>>>>>>                        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
85431>>>>>>>                        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
85432>>>>>>>                        If (SizeOfArray(aColumnsFrom) = SizeOfArray(aColumnsTo)) Begin
85434>>>>>>>                            Move iColumns to iCount 
85435>>>>>>>                        End
85435>>>>>>>>
85435>>>>>>>                    End
85435>>>>>>>>
85435>>>>>>>                End
85435>>>>>>>>
85435>>>>>>>            Loop
85436>>>>>>>>
85436>>>>>>>
85436>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85437>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85439>>>>>>>
85439>>>>>>>        Set Action_Text of ghoStatusPanel to ""
85440>>>>>>>        Function_Return (Err = False)
85441>>>>>>>    End_Function
85442>>>>>>>
85442>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85442>>>>>>>    Function API_INDEX_FUNCTIONS Returns Boolean
85444>>>>>>>        Function_Return False
85445>>>>>>>    End_Function
85446>>>>>>>
85446>>>>>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
85446>>>>>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
85446>>>>>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
85446>>>>>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
85448>>>>>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10  iIndexSegments
85448>>>>>>>        String sDriverID
85448>>>>>>>        Boolean bOK bExists bIsMertechDriver bIsSQLTable
85448>>>>>>>
85448>>>>>>>        Get AutoConnectionIDLogin to bOK
85449>>>>>>>        Get OpenTableExclusive hTable to bOK
85450>>>>>>>        If (bOK = False) Begin
85452>>>>>>>            Function_Return False
85453>>>>>>>        End
85453>>>>>>>>
85453>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
85456>>>>>>>
85456>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
85457>>>>>>>            If (bIsSQLTable = True) Begin
85459>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
85462>>>>>>>            End
85462>>>>>>>>
85462>>>>>>>
85462>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iIndexSegments
85465>>>>>>>            Move (iIndexSegments > 0) to bExists
85466>>>>>>>        If (bExists = True) Begin
85468>>>>>>>            Function_Return True
85469>>>>>>>        End
85469>>>>>>>>
85469>>>>>>>
85469>>>>>>>        Move -1 to iSegment1
85470>>>>>>>        Move -1 to iSegment2
85471>>>>>>>        Move -1 to iSegment3
85472>>>>>>>        Move -1 to iSegment4
85473>>>>>>>        Move -1 to iSegment5
85474>>>>>>>        Move -1 to iSegment6
85475>>>>>>>        Move -1 to iSegment7
85476>>>>>>>        Move -1 to iSegment8
85477>>>>>>>        Move -1 to iSegment9
85478>>>>>>>        Move -1 to iSegment10
85479>>>>>>>
85479>>>>>>>        If (num_arguments > 3) Begin
85481>>>>>>>            Move iSgmnt1 to iSegment1
85482>>>>>>>        End
85482>>>>>>>>
85482>>>>>>>        If (num_arguments > 4) Begin
85484>>>>>>>            Move iSgmnt2 to iSegment2
85485>>>>>>>        End
85485>>>>>>>>
85485>>>>>>>        If (num_arguments > 5) Begin
85487>>>>>>>            Move iSgmnt3 to iSegment3
85488>>>>>>>        End
85488>>>>>>>>
85488>>>>>>>        If (num_arguments > 6) Begin
85490>>>>>>>            Move iSgmnt4 to iSegment4
85491>>>>>>>        End
85491>>>>>>>>
85491>>>>>>>        If (num_arguments > 7) Begin
85493>>>>>>>            Move iSgmnt5 to iSegment5
85494>>>>>>>        End
85494>>>>>>>>
85494>>>>>>>        If (num_arguments > 8) Begin
85496>>>>>>>            Move iSgmnt6 to iSegment6
85497>>>>>>>        End
85497>>>>>>>>
85497>>>>>>>        If (num_arguments > 9) Begin
85499>>>>>>>            Move iSgmnt7 to iSegment7
85500>>>>>>>        End
85500>>>>>>>>
85500>>>>>>>        If (num_arguments > 10) Begin
85502>>>>>>>            Move iSgmnt8 to iSegment8
85503>>>>>>>        End
85503>>>>>>>>
85503>>>>>>>        If (num_arguments > 11) Begin
85505>>>>>>>            Move iSgmnt9 to iSegment9
85506>>>>>>>        End
85506>>>>>>>>
85506>>>>>>>        If (num_arguments > 12) Begin
85508>>>>>>>            Move iSgmnt10 to iSegment10
85509>>>>>>>        End
85509>>>>>>>>
85509>>>>>>>
85509>>>>>>>        Move False to Err
85510>>>>>>>        Move hTable to iTableNo
85511>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85512>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
85513>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
85514>>>>>>>
85514>>>>>>>        // We start by deleting the index, if it exists.
85514>>>>>>>        If (bExists = True) Begin
85516>>>>>>>            Structure_Start hTable sDriverID
85517>>>>>>>                Delete_Index iTableNo iIndex
85518>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
85519>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85521>>>>>>>        End
85521>>>>>>>>
85521>>>>>>>
85521>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85522>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
85523>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
85524>>>>>>>        Set Action_Text of ghoStatusPanel to ""
85525>>>>>>>        Move False to Err
85526>>>>>>>        Move 0 to LastErr
85527>>>>>>>
85527>>>>>>>        // Need to re-open if index deleted.
85527>>>>>>>        Move iTableNo to hTable
85528>>>>>>>        Get OpenTableExclusive hTable to bOK
85529>>>>>>>        If (bOK = False) Begin
85531>>>>>>>            Function_Return False
85532>>>>>>>        End
85532>>>>>>>>
85532>>>>>>>
85532>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85533>>>>>>>        Structure_Start hTable sDriverID
85534>>>>>>>            Create_Index hTable At iIndex
85535>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
85538>>>>>>>
85538>>>>>>>            If (iSgmnt1 <> -1) Begin
85540>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
85543>>>>>>>            End
85543>>>>>>>>
85543>>>>>>>            If (iSegment2 <> -1) Begin
85545>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
85548>>>>>>>            End
85548>>>>>>>>
85548>>>>>>>            If (iSegment3 <> -1) Begin
85550>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
85553>>>>>>>            End
85553>>>>>>>>
85553>>>>>>>            If (iSegment4 <> -1) Begin
85555>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
85558>>>>>>>            End
85558>>>>>>>>
85558>>>>>>>            If (iSegment5 <> -1) Begin
85560>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
85563>>>>>>>            End
85563>>>>>>>>
85563>>>>>>>            If (iSegment6 <> -1) Begin
85565>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
85568>>>>>>>            End
85568>>>>>>>>
85568>>>>>>>            If (iSegment7 <> -1) Begin
85570>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
85573>>>>>>>            End
85573>>>>>>>>
85573>>>>>>>            If (iSegment8 <> -1) Begin
85575>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
85578>>>>>>>            End
85578>>>>>>>>
85578>>>>>>>            If (iSegment9 <> -1) Begin
85580>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
85583>>>>>>>            End
85583>>>>>>>>
85583>>>>>>>            If (iSegment10 <> -1) Begin
85585>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
85588>>>>>>>            End
85588>>>>>>>>
85588>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85589>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85591>>>>>>>
85591>>>>>>>        Set Action_Text of ghoStatusPanel to ""
85592>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85593>>>>>>>
85593>>>>>>>        Function_Return (Err = False)
85594>>>>>>>    End_Function
85595>>>>>>>
85595>>>>>>>    // Example:
85595>>>>>>>    // Get ApiIndexCreateEx hTable 1 (StrSplitToArray("1,5,6,7,8,2,3,4,10,9,11", ",")) to bOk
85595>>>>>>>    // Note: The StrSplitToArray function was introduced with DataFlex 18.2
85595>>>>>>>    Function ApiIndexCreateEx Handle hTable Integer iIndex Integer[] iSgmnts Returns Boolean
85597>>>>>>>        Integer iTableNo iNumSgmnt iNumSgmnts
85597>>>>>>>        String sDriverID
85597>>>>>>>        Boolean bOK bIsSQLTable
85597>>>>>>>
85597>>>>>>>        Get AutoConnectionIDLogin to bOK
85598>>>>>>>
85598>>>>>>>        Move False to Err
85599>>>>>>>        Move hTable to iTableNo
85600>>>>>>>        Get OpenTableExclusive hTable to bOK
85601>>>>>>>        If (bOK = False) Begin
85603>>>>>>>            Function_Return False
85604>>>>>>>        End
85604>>>>>>>>
85604>>>>>>>
85604>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
85607>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
85608>>>>>>>            If (bIsSQLTable = True) Begin
85610>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
85613>>>>>>>            End
85613>>>>>>>>
85613>>>>>>>
85613>>>>>>>        // We start by deleting the index
85613>>>>>>>        Structure_Start hTable sDriverID
85614>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85615>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
85616>>>>>>>            Delete_Index iTableNo iIndex
85617>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
85618>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
85619>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
85621>>>>>>>
85621>>>>>>>        Move False to Err
85622>>>>>>>        Move iTableNo to hTable
85623>>>>>>>        Get OpenTableExclusive hTable to bOK
85624>>>>>>>        If (bOK = False) Begin
85626>>>>>>>            Function_Return False
85627>>>>>>>        End
85627>>>>>>>>
85627>>>>>>>
85627>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85628>>>>>>>        Structure_Start hTable sDriverID
85629>>>>>>>            Move (SizeOfArray(iSgmnts)) to iNumSgmnts
85630>>>>>>>
85630>>>>>>>            Create_Index hTable at iIndex
85631>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSgmnts
85634>>>>>>>
85634>>>>>>>            for iNumSgmnt from 0 to (iNumSgmnts - 1)
85640>>>>>>>>
85640>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iNumSgmnt + 1) to iSgmnts[iNumSgmnt]
85643>>>>>>>            Loop
85644>>>>>>>>
85644>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
85646>>>>>>>
85646>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85647>>>>>>>
85647>>>>>>>        Function_Return (Err = False)
85648>>>>>>>    End_Function
85649>>>>>>>
85649>>>>>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
85651>>>>>>>        Integer iCount iSegmentsFrom iFieldFrom iSegmentsTo iSQLIndexType iTableNo
85651>>>>>>>        String sDriverID sSQLIndexName
85651>>>>>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
85651>>>>>>>
85651>>>>>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
85652>>>>>>>        If (iSegmentsFrom = 0) Begin
85654>>>>>>>            Function_Return False
85655>>>>>>>        End
85655>>>>>>>>
85655>>>>>>>
85655>>>>>>>        Get AutoConnectionIDLogin to bOK
85656>>>>>>>        Move False to Err
85657>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
85658>>>>>>>        If (bIsOpen = False) Begin
85660>>>>>>>            Function_Return False
85661>>>>>>>        End
85661>>>>>>>>
85661>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
85664>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTable
85665>>>>>>>            If (bIsSQLTable = True) Begin
85667>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
85670>>>>>>>            End
85670>>>>>>>>
85670>>>>>>>
85670>>>>>>>        Move 0     to iSegmentsTo
85671>>>>>>>        Move 0     to iSQLIndexType
85672>>>>>>>        Move ""    to sSQLIndexName
85673>>>>>>>        Move False to bIsSQLTemporaryIndex
85674>>>>>>>        Move False to bIsSQLPrimaryKey
85675>>>>>>>        Move False to bIsSQLClustered
85676>>>>>>>
85676>>>>>>>            Get UtilIndexTempRenameSQLName hTable APIIndex.sSQLIndexName sDriverID          to bOK
85677>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber              to iSegmentsTo
85680>>>>>>>        Move (iSegmentsTo > 0) to bExists
85681>>>>>>>        If (bExists = True) Begin
85683>>>>>>>            If (bIsSQLTable = True and iSegmentsTo > 0) Begin
85685>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber                 to sSQLIndexName
85688>>>>>>>                    Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
85691>>>>>>>                    Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
85692>>>>>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
85695>>>>>>>                    Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
85698>>>>>>>            End
85698>>>>>>>>
85698>>>>>>>        End
85698>>>>>>>>
85698>>>>>>>
85698>>>>>>>        Move hTable to iTableNo
85699>>>>>>>        Move False to Err
85700>>>>>>>        Move 0 to LastErr
85701>>>>>>>
85701>>>>>>>        // Note: If the SQL index type = DF_INDEX_TEMPORARY, we _must_ set the DF_INDEX_SQL_TYPE
85701>>>>>>>        //       _outside_ the Structure_Start/End construct.
85701>>>>>>>//        Move False to bIsSQLTemporaryIndex
85701>>>>>>>//        #IF (!@ > 170)
85701>>>>>>>//            If (bIsSQLTemporaryIndex = True and APIIndex.iIndexNumber <= iLastIndex) Begin
85701>>>>>>>//                If (APIIndex.iSQLIndexType <> iSQLIndexType) Begin
85701>>>>>>>//                    Set_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
85701>>>>>>>//                End
85701>>>>>>>//            End
85701>>>>>>>//        #ENDIF
85701>>>>>>>
85701>>>>>>>        Structure_Start hTable sDriverID
85702>>>>>>>            If (bExists = True) Begin
85704>>>>>>>                Delete_Index iTableNo APIIndex.iIndexNumber
85705>>>>>>>            End
85705>>>>>>>>
85705>>>>>>>
85705>>>>>>>            Create_Index hTable At APIIndex.iIndexNumber
85706>>>>>>>
85706>>>>>>>            If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
85708>>>>>>>                Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType
85711>>>>>>>                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
85714>>>>>>>                Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
85717>>>>>>>                Set_Attribute DF_INDEX_NAME            of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
85720>>>>>>>            End
85720>>>>>>>>
85720>>>>>>>
85720>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
85723>>>>>>>
85723>>>>>>>            for iCount from 0 to (iSegmentsFrom -1)
85729>>>>>>>>
85729>>>>>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom
85730>>>>>>>                If (iFieldFrom <> -1 ) Begin
85732>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
85735>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bAscending
85738>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bUppercase
85741>>>>>>>                End
85741>>>>>>>>
85741>>>>>>>            Loop
85742>>>>>>>>
85742>>>>>>>
85742>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85743>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85745>>>>>>>
85745>>>>>>>        Set Action_Text of ghoStatusPanel to ""
85746>>>>>>>
85746>>>>>>>        Function_Return (Err = False)
85747>>>>>>>    End_Function
85748>>>>>>>
85748>>>>>>>    // If an SQL index is to be renamed we need to check that the name doesn't exist already, but
85748>>>>>>>    // with another index number. If we find one we temporarily renames it by adding "TMP" to the SQL name.
85748>>>>>>>    Function UtilIndexTempRenameSQLName Handle hTable String sSQLIndexName String sDriverID Returns Boolean
85750>>>>>>>        Integer iLastIndex iCount iTableNo iSegments
85750>>>>>>>        String sSQLIndexNameCompare sTmpIndexName
85750>>>>>>>        Boolean bIsOpen bExists bIsSQLDriver bIsMertechDriver
85750>>>>>>>
85750>>>>>>>        // The Mertech drivers DF_INDEX_NAME property is read_only,
85750>>>>>>>        // so we can then not rename the index.
85750>>>>>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
85751>>>>>>>        If (bIsMertechDriver = True) Begin
85753>>>>>>>            Function_Return False
85754>>>>>>>        End    
85754>>>>>>>>
85754>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
85755>>>>>>>        
85755>>>>>>>        If (bIsSQLDriver = False) Begin
85757>>>>>>>            Function_Return False
85758>>>>>>>        End
85758>>>>>>>>
85758>>>>>>>
85758>>>>>>>        Move False to Err
85759>>>>>>>        Move hTable to iTableNo
85760>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
85763>>>>>>>        for iCount from 0 to iLastIndex
85769>>>>>>>>
85769>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iSegments
85772>>>>>>>            Move (iSegments > 0) to bExists
85773>>>>>>>            If (bExists = True) Begin
85775>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable iCount to sSQLIndexNameCompare
85778>>>>>>>                If (Lowercase(sSQLIndexName) = Lowercase(sSQLIndexNameCompare)) Begin
85780>>>>>>>                    Move (sSQLIndexNameCompare + String("_TMP")) to sTmpIndexName
85781>>>>>>>                    Structure_Start iTableNo sDriverID
85782>>>>>>>                        Set_Attribute DF_INDEX_NAME of iTableNo iCount to sTmpIndexName
85785>>>>>>>                    Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85787>>>>>>>                    Open hTable
85789>>>>>>>                End
85789>>>>>>>>
85789>>>>>>>            End
85789>>>>>>>>
85789>>>>>>>        Loop
85790>>>>>>>>
85790>>>>>>>
85790>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
85793>>>>>>>        If (bIsOpen = False) Begin
85795>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
85796>>>>>>>        End
85796>>>>>>>>
85796>>>>>>>        If (bIsOpen = False) Begin
85798>>>>>>>            Function_Return False
85799>>>>>>>        End
85799>>>>>>>>
85799>>>>>>>
85799>>>>>>>        Function_Return (Err = False)
85800>>>>>>>    End_Function
85801>>>>>>>
85801>>>>>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
85801>>>>>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
85801>>>>>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
85803>>>>>>>        Integer iSize iCount
85803>>>>>>>        Integer iRetVal
85803>>>>>>>
85803>>>>>>>        Move 0 to iRetVal
85804>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
85807>>>>>>>        If (iRetVal = 0) Begin
85809>>>>>>>            Function_Return 0
85810>>>>>>>        End
85810>>>>>>>>
85810>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSize
85811>>>>>>>        Decrement iSize
85812>>>>>>>        for iCount from 0 to iSize
85818>>>>>>>>
85818>>>>>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
85820>>>>>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
85822>>>>>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
85823>>>>>>>                End
85823>>>>>>>>
85823>>>>>>>            End
85823>>>>>>>>
85823>>>>>>>        Loop
85824>>>>>>>>
85824>>>>>>>
85824>>>>>>>        Function_Return iRetVal
85825>>>>>>>    End_Function
85826>>>>>>>
85826>>>>>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
85828>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
85828>>>>>>>        Boolean bIsSQLTable
85828>>>>>>>        
85828>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
85829>>>>>>>            If (bIsSQLTable = True) Begin
85831>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
85834>>>>>>>            End
85834>>>>>>>>
85834>>>>>>>
85834>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
85837>>>>>>>        If (iSegment = iNumSegments) Begin
85839>>>>>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
85839>>>>>>>        End
85839>>>>>>>>
85839>>>>>>>
85839>>>>>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
85842>>>>>>>            for iCurSegment from iSegment to (iNumSegments - 1)
85848>>>>>>>>
85848>>>>>>>                //*** Move index segment attributes
85848>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
85851>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
85854>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
85857>>>>>>>
85857>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
85860>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
85863>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
85866>>>>>>>            Loop
85867>>>>>>>>
85867>>>>>>>
85867>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
85870>>>>>>>        End
85870>>>>>>>>
85870>>>>>>>
85870>>>>>>>        Function_Return (Err = False)
85871>>>>>>>    End_Function
85872>>>>>>>
85872>>>>>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
85874>>>>>>>        Integer iCount iSize iIndex
85874>>>>>>>        String sDriverID
85874>>>>>>>        Boolean bOK bIsSQLTable bIsOpen
85874>>>>>>>
85874>>>>>>>        Move (SizeOfArray(APIIndex)) to iSize
85875>>>>>>>        If (iSize = 0) Begin
85877>>>>>>>            Function_Return True
85878>>>>>>>        End
85878>>>>>>>>
85878>>>>>>>
85878>>>>>>>        Get AutoConnectionIDLogin to bOK
85879>>>>>>>        Move False to Err
85880>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
85883>>>>>>>        If (bIsOpen = False) Begin
85885>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
85886>>>>>>>            If (bIsOpen = False) Begin
85888>>>>>>>                Function_Return False
85889>>>>>>>            End
85889>>>>>>>>
85889>>>>>>>        End
85889>>>>>>>>
85889>>>>>>>
85889>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
85892>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTable
85893>>>>>>>            If (bIsSQLTable = True) Begin
85895>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
85898>>>>>>>            End
85898>>>>>>>>
85898>>>>>>>
85898>>>>>>>        Move False to Err
85899>>>>>>>        Move 0 to LastErr
85900>>>>>>>        Decrement iSize
85901>>>>>>>
85901>>>>>>>        Structure_Start hTable sDriverID
85902>>>>>>>            for iCount from 0 to iSize
85908>>>>>>>>
85908>>>>>>>//                Move False to bIsSQLPrimaryKey
85908>>>>>>>//                #IF (!@ > 180)   // DF 18.1 and up
85908>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85908>>>>>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
85908>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
85908>>>>>>>//                #ENDIF
85908>>>>>>>                // We can't delete if this is a primary key index:
85908>>>>>>>//                If (bIsSQLPrimaryKey = False) Begin
85908>>>>>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
85909>>>>>>>                    Delete_Index hTable iIndex
85910>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
85910>>>>>>>//                End
85910>>>>>>>            Loop
85911>>>>>>>>
85911>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85912>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85914>>>>>>>//        Move False to Err
85914>>>>>>>        Move 0 to LastErr
85915>>>>>>>
85915>>>>>>>        Set Action_Text of ghoStatusPanel to ""
85916>>>>>>>        Function_Return (Err = False)
85917>>>>>>>    End_Function
85918>>>>>>>
85918>>>>>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
85920>>>>>>>        Boolean bOK
85920>>>>>>>
85920>>>>>>>        Get AutoConnectionIDLogin to bOK
85921>>>>>>>        Move False to Err
85922>>>>>>>        Get OpenTableExclusive hTable to bOK
85923>>>>>>>        If (bOK = False) Begin
85925>>>>>>>            Function_Return False
85926>>>>>>>        End
85926>>>>>>>>
85926>>>>>>>        Structure_Start hTable
85927>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
85930>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85931>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85933>>>>>>>
85933>>>>>>>        Set Action_Text of ghoStatusPanel to ""
85934>>>>>>>        Function_Return (Err = False)
85935>>>>>>>    End_Function
85936>>>>>>>
85936>>>>>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
85938>>>>>>>        Integer iCase
85938>>>>>>>        Boolean bOK
85938>>>>>>>
85938>>>>>>>        If (bUppercase = True) Begin
85940>>>>>>>            Move DF_CASE_IGNORED to iCase
85941>>>>>>>        End
85941>>>>>>>>
85941>>>>>>>        Else Begin
85942>>>>>>>            Move DF_CASE_USED to iCase
85943>>>>>>>        End
85943>>>>>>>>
85943>>>>>>>
85943>>>>>>>        Get AutoConnectionIDLogin to bOK
85944>>>>>>>        Move False to Err
85945>>>>>>>        Get OpenTableExclusive hTable to bOK
85946>>>>>>>        If (bOK = False) Begin
85948>>>>>>>            Function_Return False
85949>>>>>>>        End
85949>>>>>>>>
85949>>>>>>>        Structure_Start hTable
85950>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
85953>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85954>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85956>>>>>>>
85956>>>>>>>        Set Action_Text of ghoStatusPanel to ""
85957>>>>>>>        Function_Return (Err = False)
85958>>>>>>>    End_Function
85959>>>>>>>
85959>>>>>>>    // To delete an index
85959>>>>>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
85961>>>>>>>        Integer iTableNo iNumSegments
85961>>>>>>>        String sDriverID
85961>>>>>>>        Boolean bOK bIsSQLTable
85961>>>>>>>
85961>>>>>>>        Get AutoConnectionIDLogin to bOK
85962>>>>>>>        Move False to Err
85963>>>>>>>        Move hTable to iTableNo
85964>>>>>>>        Get OpenTableExclusive hTable to bOK
85965>>>>>>>        If (bOK = False) Begin
85967>>>>>>>            Function_Return False
85968>>>>>>>        End
85968>>>>>>>>
85968>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
85971>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
85972>>>>>>>            If (bIsSQLTable = True) Begin
85974>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
85977>>>>>>>            End
85977>>>>>>>>
85977>>>>>>>
85977>>>>>>>        // Check to see if the index exists or not...
85977>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
85980>>>>>>>        If (iNumSegments = 0) Begin
85982>>>>>>>            Function_Return True // Then nothing to do.
85983>>>>>>>        End
85983>>>>>>>>
85983>>>>>>>
85983>>>>>>>        Structure_Start hTable sDriverID
85984>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
85985>>>>>>>            Delete_Index iTableNo iIndex
85986>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
85987>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85988>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85990>>>>>>>
85990>>>>>>>        Set Action_Text of ghoStatusPanel to ""
85991>>>>>>>        Function_Return (Err = False)
85992>>>>>>>    End_Function
85993>>>>>>>
85993>>>>>>>    // Delete an Index Segment
85993>>>>>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
85995>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
85995>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
85995>>>>>>>        Integer iIndexType
85995>>>>>>>        String sDriverID
85995>>>>>>>
85995>>>>>>>        Get AutoConnectionIDLogin to bOK
85996>>>>>>>        Move False to Err
85997>>>>>>>
85997>>>>>>>        Get OpenTableExclusive hTable to bOK
85998>>>>>>>        If (bOK = False) Begin
86000>>>>>>>            Function_Return False
86001>>>>>>>        End
86001>>>>>>>>
86001>>>>>>>
86001>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
86002>>>>>>>            If (bIsSQLTable = True) Begin
86004>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
86007>>>>>>>            End
86007>>>>>>>>
86007>>>>>>>
86007>>>>>>>        // Check to see if the index exists or not...
86007>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
86010>>>>>>>        If (iNumSegments = 0) Begin
86012>>>>>>>            Function_Return False
86013>>>>>>>        End
86013>>>>>>>>
86013>>>>>>>
86013>>>>>>>        Move False to bIndexTemporary
86014>>>>>>>        Get psDriverID to sDriverID
86015>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
86016>>>>>>>        If (bSQLDriver) Begin
86018>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
86021>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
86024>>>>>>>                Move True to bIndexTemporary
86025>>>>>>>        End
86025>>>>>>>>
86025>>>>>>>
86025>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
86025>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
86027>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
86030>>>>>>>            If (iSegment = iNumSegments) Begin
86032>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
86035>>>>>>>            End
86035>>>>>>>>
86035>>>>>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
86038>>>>>>>                For iCurSegment from iSegment to (iNumSegments - 1)
86044>>>>>>>>
86044>>>>>>>                    //*** Move index segment attributes
86044>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
86047>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
86050>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
86053>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
86056>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
86059>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
86062>>>>>>>                Loop
86063>>>>>>>>
86063>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
86066>>>>>>>            End
86066>>>>>>>>
86066>>>>>>>        End
86066>>>>>>>>
86066>>>>>>>
86066>>>>>>>        Else Begin
86067>>>>>>>           Structure_Start hTable
86068>>>>>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
86071>>>>>>>               If (iSegment = iNumSegments) Begin
86073>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
86076>>>>>>>               End
86076>>>>>>>>
86076>>>>>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
86079>>>>>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
86085>>>>>>>>
86085>>>>>>>                       //*** Move index segment attributes
86085>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
86088>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
86091>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
86094>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
86097>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
86100>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
86103>>>>>>>                   Loop
86104>>>>>>>>
86104>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
86107>>>>>>>               End
86107>>>>>>>>
86107>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
86108>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86110>>>>>>>            Set Action_Text of ghoStatusPanel to ""
86111>>>>>>>        End
86111>>>>>>>>
86111>>>>>>>
86111>>>>>>>        Function_Return (Err = False)
86112>>>>>>>    End_Function
86113>>>>>>>
86113>>>>>>>    // Add/Insert an Index Segment
86113>>>>>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
86115>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
86115>>>>>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
86115>>>>>>>        Integer iIndexType
86115>>>>>>>        String sDriverId
86115>>>>>>>
86115>>>>>>>        Get AutoConnectionIDLogin to bOK
86116>>>>>>>        Move False to Err
86117>>>>>>>
86117>>>>>>>        Get OpenTableExclusive hTable to bOK
86118>>>>>>>        If (bOK = False) Begin
86120>>>>>>>            Function_Return False
86121>>>>>>>        End
86121>>>>>>>>
86121>>>>>>>
86121>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
86122>>>>>>>            If (bIsSQLTable = True) Begin
86124>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
86127>>>>>>>            End
86127>>>>>>>>
86127>>>>>>>
86127>>>>>>>        Move False to bIndexTemporary
86128>>>>>>>        // Check to see if the index exists or not...
86128>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
86131>>>>>>>        If (iNumSegments = 0) Begin
86133>>>>>>>            Function_Return False
86134>>>>>>>        End
86134>>>>>>>>
86134>>>>>>>
86134>>>>>>>        Get psDriverID to sDriverID
86135>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
86136>>>>>>>        If (bSQLDriver) Begin
86138>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
86141>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
86144>>>>>>>                Move True to bIndexTemporary
86145>>>>>>>        End
86145>>>>>>>>
86145>>>>>>>
86145>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
86145>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
86147>>>>>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
86150>>>>>>>
86150>>>>>>>           If (iSegment > iNumSegments) Begin
86152>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
86155>>>>>>>               Move (iNumSegments + 1) to iCurSegment
86156>>>>>>>           End
86156>>>>>>>>
86156>>>>>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
86159>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
86162>>>>>>>               Move iNumSegments to iCurSegment
86163>>>>>>>
86163>>>>>>>               While (iCurSegment > iSegment)
86167>>>>>>>                   //*** Move index segment attributes
86167>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
86170>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
86173>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
86176>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
86179>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
86182>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
86185>>>>>>>                   Decrement iCurSegment
86186>>>>>>>               Loop
86187>>>>>>>>
86187>>>>>>>
86187>>>>>>>               //*** Now set new segment attributes
86187>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
86190>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
86193>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
86196>>>>>>>           End
86196>>>>>>>>
86196>>>>>>>        End
86196>>>>>>>>
86196>>>>>>>
86196>>>>>>>        Else Begin
86197>>>>>>>        Structure_Start hTable
86198>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
86201>>>>>>>
86201>>>>>>>            If (iSegment > iNumSegments) Begin
86203>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
86206>>>>>>>                Move (iNumSegments + 1) to iCurSegment
86207>>>>>>>            End
86207>>>>>>>>
86207>>>>>>>            Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
86210>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
86213>>>>>>>                Move iNumSegments to iCurSegment
86214>>>>>>>
86214>>>>>>>                While (iCurSegment > iSegment)
86218>>>>>>>                    //*** Move index segment attributes
86218>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
86221>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
86224>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
86227>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
86230>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
86233>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
86236>>>>>>>                    Decrement iCurSegment
86237>>>>>>>                Loop
86238>>>>>>>>
86238>>>>>>>
86238>>>>>>>                //*** Now set new segment attributes
86238>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
86241>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
86244>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
86247>>>>>>>            End
86247>>>>>>>>
86247>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86248>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86250>>>>>>>            Set Action_Text of ghoStatusPanel to ""
86251>>>>>>>        End
86251>>>>>>>>
86251>>>>>>>
86251>>>>>>>        Function_Return (Err = False)
86252>>>>>>>    End_Function
86253>>>>>>>
86253>>>>>>>    // * Dummy function for the Studio's Code Explorer *
86253>>>>>>>    Function TABLE_UTILITY_FUNCTIONS Returns Boolean
86255>>>>>>>        Function_Return False
86256>>>>>>>    End_Function  
86257>>>>>>>    
86257>>>>>>>    // Preparation message before an SQL onversion. It will check and wash all embedded data tables and prepare them
86257>>>>>>>    // for an SQL conversion.
86257>>>>>>>    Function UtilPrepareDataFolderForSQLConversion Boolean bMoveMiscFilesToBackup Boolean bFixALLBogusFilelistEntries Boolean bConvertTo30Format Boolean bRepairAndReindex Boolean bFixBogusDates Returns Boolean
86259>>>>>>>        Boolean bConvertTo30FormatbOK bRepairAndReindexOK bFixBogusDatesOK bMoveMiscFilesToBackupOK
86259>>>>>>>        
86259>>>>>>>        Move True to bConvertTo30FormatbOK
86260>>>>>>>        Move True to bRepairAndReindexOK
86261>>>>>>>        Move True to bFixBogusDatesOK
86262>>>>>>>        Move True to bMoveMiscFilesToBackupOK
86263>>>>>>>        
86263>>>>>>>        If (bMoveMiscFilesToBackup = True) Begin   
86265>>>>>>>            Set Message_Text of ghoStatusPanel to "Moving misc. files to backup..."
86266>>>>>>>            Get UtilMoveMiscFilesToBackupFolder to bMoveMiscFilesToBackupOK
86267>>>>>>>        End                                                                                
86267>>>>>>>>
86267>>>>>>>        If (bFixALLBogusFilelistEntries = True) Begin
86269>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus Filelist.cfg entries..."
86270>>>>>>>            Get UtilTableFixALLBogusFilelistEntries to bFixALLBogusFilelistEntries
86271>>>>>>>        End
86271>>>>>>>>
86271>>>>>>>        If (bConvertTo30Format = True) Begin
86273>>>>>>>            Set Message_Text of ghoStatusPanel to "Converting .dat files from 2.3->..."
86274>>>>>>>            Get UtilTableConvertALLTablesFrom23Format to bConvertTo30FormatbOK
86275>>>>>>>        End                                                 
86275>>>>>>>>
86275>>>>>>>        If (bRepairAndReindex = True) Begin
86277>>>>>>>            Set Message_Text of ghoStatusPanel to "Repairing and reindexing..."
86278>>>>>>>            Get UtilTableRepairAndReindexALL to bRepairAndReindexOK
86279>>>>>>>        End  
86279>>>>>>>>
86279>>>>>>>        If (bFixBogusDates = True) Begin
86281>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
86282>>>>>>>            Get UtilTablesFixAllDateBogusValues True False to bFixBogusDatesOK
86283>>>>>>>        End                                    
86283>>>>>>>>
86283>>>>>>>        
86283>>>>>>>        Function_Return (bConvertTo30FormatbOK = True and bFixALLBogusFilelistEntries = True and bRepairAndReindexOK = True and bFixBogusDatesOK = True and bMoveMiscFilesToBackupOK = True)
86284>>>>>>>    End_Function
86285>>>>>>>
86285>>>>>>>    Function UtilTableConvertALLTablesFrom23Format Returns Boolean
86287>>>>>>>        Boolean bOK bFlexErrs bTemp
86287>>>>>>>        Handle hTable
86287>>>>>>>        String sTableName
86287>>>>>>>        Integer iCount iSize
86287>>>>>>>        
86287>>>>>>>        Move True to bOK
86288>>>>>>>        Move 0 to hTable    
86289>>>>>>>
86289>>>>>>>        Get UtilFilelistNoOfTables to iSize
86290>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
86291>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
86292>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
86293>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
86294>>>>>>>
86294>>>>>>>        Repeat
86294>>>>>>>>
86294>>>>>>>            Set Action_Text of ghoStatusPanel to "Checking if table is in 2.3 format..."
86295>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount  
86296>>>>>>>            Increment iCount
86297>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
86300>>>>>>>            If (hTable > 0) Begin
86302>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
86305>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
86306>>>>>>>                If (bFlexErrs = False) Begin
86308>>>>>>>                    Get UtilTableConvertFrom23Format hTable to bTemp
86309>>>>>>>                    If (bTemp = False) Begin
86311>>>>>>>                        Move False to bOK
86312>>>>>>>                    End
86312>>>>>>>>
86312>>>>>>>                End
86312>>>>>>>>
86312>>>>>>>            End
86312>>>>>>>>
86312>>>>>>>        Until (hTable = 0)
86314>>>>>>>        
86314>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86315>>>>>>>        Function_Return bOK
86316>>>>>>>    End_Function
86317>>>>>>>    
86317>>>>>>>    // Converts an embedded table from 2.3 -> 3.0.
86317>>>>>>>    // Returns: FALSE only if the table can't be opened or the conversion fails.
86317>>>>>>>    // It will return a TRUE if successful or the table is an SQL table.
86317>>>>>>>    Function UtilTableConvertFrom23Format Handle hTable Returns Boolean
86319>>>>>>>        Boolean bOK bIsEmbedded bIsAlias
86319>>>>>>>        String sRevision
86319>>>>>>>        
86319>>>>>>>        Get AutoConnectionIDLogin to bOK
86320>>>>>>>        If (bOK = False) Begin
86322>>>>>>>            Function_Return True
86323>>>>>>>        End
86323>>>>>>>>
86323>>>>>>>        Get OpenTableExclusive hTable to bOK
86324>>>>>>>        If (bOK = False) Begin
86326>>>>>>>            Function_Return True
86327>>>>>>>        End
86327>>>>>>>>
86327>>>>>>>        Get UtilTableIsEmbedded hTable to bIsEmbedded
86328>>>>>>>        If (bIsEmbedded = False) Begin
86330>>>>>>>            Function_Return True
86331>>>>>>>        End                             
86331>>>>>>>>
86331>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
86332>>>>>>>        If (bIsAlias = True) Begin
86334>>>>>>>            Function_Return True
86335>>>>>>>        End                     
86335>>>>>>>>
86335>>>>>>>        
86335>>>>>>>        Move False to Err
86336>>>>>>>        Get_Attribute DF_FILE_REVISION of hTable to sRevision
86339>>>>>>>        If (sRevision contains "2.3") Begin
86341>>>>>>>            Move False to Err
86342>>>>>>>            Set Private.phCurrentTable to hTable
86343>>>>>>>            Structure_Start hTable    
86344>>>>>>>                Set_Attribute DF_FILE_INTEGRITY_CHECK of hTable to True
86347>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table to 3.0/4.0"
86348>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
86350>>>>>>>            Set Action_Text of ghoStatusPanel to ""
86351>>>>>>>        End
86351>>>>>>>>
86351>>>>>>>        
86351>>>>>>>        Function_Return (Err = False)
86352>>>>>>>    End_Function
86353>>>>>>>
86353>>>>>>>    Function UtilTableFixALLBogusFilelistEntries Returns Boolean
86355>>>>>>>        Boolean bIgnore bExists bOK bResponse
86355>>>>>>>        Handle hTable   
86355>>>>>>>        String sTableName
86355>>>>>>>        
86355>>>>>>>        Move False to Err 
86356>>>>>>>        Move True to bOK
86357>>>>>>>        Move 0 to hTable
86358>>>>>>>        Repeat
86358>>>>>>>>
86358>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
86361>>>>>>>            If (hTable > 0) Begin
86363>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
86366>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST")  to bIgnore
86367>>>>>>>                If (bIgnore = False) Begin
86369>>>>>>>                    Get UtilTableExists hTable to bExists
86370>>>>>>>                    If (bExists = False) Begin
86372>>>>>>>                        Get ApiTableChangeFileListSlot "" "" "" hTable DATAFLEX_ID to bResponse
86373>>>>>>>                        If (bResponse = False) Begin
86375>>>>>>>                            Move False to bOK
86376>>>>>>>                        End
86376>>>>>>>>
86376>>>>>>>                        
86376>>>>>>>                    End
86376>>>>>>>>
86376>>>>>>>                End
86376>>>>>>>>
86376>>>>>>>            End
86376>>>>>>>>
86376>>>>>>>        Until (hTable = 0)                     
86378>>>>>>>        
86378>>>>>>>        Set Action_Text of ghoStatusPanel to "" 
86379>>>>>>>        Function_Return bOK
86380>>>>>>>    End_Function
86381>>>>>>>    
86381>>>>>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
86381>>>>>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
86381>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
86381>>>>>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
86381>>>>>>>    //
86381>>>>>>>    // The root of the problem is the following:
86381>>>>>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
86381>>>>>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
86381>>>>>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside
86381>>>>>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
86381>>>>>>>    // an SQL error will be thrown;
86381>>>>>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
86381>>>>>>>    Function UtilTablesFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
86383>>>>>>>        Boolean bOK bIsAlias bIsSQL
86383>>>>>>>        Integer iCount iSize iDateSize
86383>>>>>>>        Handle hTable
86383>>>>>>>        String sLogicalName
86383>>>>>>>        Integer[] aTablesToCheck aDateFields
86385>>>>>>>
86385>>>>>>>        Get _AllTablesDateCorrections to aTablesToCheck
86386>>>>>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
86387>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
86388>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
86389>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
86390>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
86391>>>>>>>
86391>>>>>>>        Move True to bOK
86392>>>>>>>        Decrement iSize
86393>>>>>>>        for iCount from 0 to iSize
86399>>>>>>>>
86399>>>>>>>            Move aTablesToCheck[iCount] to hTable
86400>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
86401>>>>>>>            Get UtilTableIsAlias hTable to bIsAlias
86402>>>>>>>            Get UtilTableIsSql   hTable to bIsSQL
86403>>>>>>>
86403>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86406>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
86407>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
86408>>>>>>>
86408>>>>>>>            If (bIsAlias = False and bIsSQL = False) Begin
86410>>>>>>>                Get UtilCheckForDateFields hTable to aDateFields
86411>>>>>>>                Move (SizeOfArray(aDateFields)) to iDateSize
86412>>>>>>>                If (iDateSize > 0) Begin
86414>>>>>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
86415>>>>>>>                    Close hTable
86416>>>>>>>                End
86416>>>>>>>>
86416>>>>>>>            End
86416>>>>>>>>
86416>>>>>>>        Loop
86417>>>>>>>>
86417>>>>>>>
86417>>>>>>>        Close DF_ALL
86418>>>>>>>        Function_Return bOK
86419>>>>>>>    End_Function
86420>>>>>>>
86420>>>>>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
86420>>>>>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
86422>>>>>>>        Integer[] aDateFields aDateFieldsEmpty
86424>>>>>>>        Integer iSize iCount iType
86424>>>>>>>        Boolean bOpen bOK
86424>>>>>>>        
86424>>>>>>>        Get UtilTableExists hTable to bOK
86425>>>>>>>        If (bOK = False) Begin
86427>>>>>>>            Set Private.phCurrentTable to hTable
86428>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
86429>>>>>>>>
86429>>>>>>>            Function_Return aDateFieldsEmpty
86430>>>>>>>        End
86430>>>>>>>>
86430>>>>>>>        Set Private.phCurrentTable to hTable
86431>>>>>>>        Set Private.piCurrentField to 0
86432>>>>>>>
86432>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
86432>>>>>>>        Open hTable
86434>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
86437>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
86437>>>>>>>        If (bOpen = False) Begin
86439>>>>>>>//            Error DFERR_PROGRAM ("Table could not be opened." * String(hTable))
86439>>>>>>>            Function_Return aDateFieldsEmpty
86440>>>>>>>        End
86440>>>>>>>>
86440>>>>>>>
86440>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
86443>>>>>>>        For iCount from 1 to iSize
86449>>>>>>>>
86449>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
86452>>>>>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
86454>>>>>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
86455>>>>>>>            End
86455>>>>>>>>
86455>>>>>>>        Loop
86456>>>>>>>>
86456>>>>>>>
86456>>>>>>>        Function_Return aDateFields
86457>>>>>>>    End_Function
86458>>>>>>>
86458>>>>>>>    // Loops through all records for the passed hTable, and checks that all Date values
86458>>>>>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
86458>>>>>>>    // and the record is saved
86458>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
86458>>>>>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
86458>>>>>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
86460>>>>>>>        Integer iSize iCount iField iRecord iTotalRecords iDateFormat iDriverIndex
86460>>>>>>>        String sDriverID sDateMin
86460>>>>>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges 
86460>>>>>>>        Date dDate dDateMin
86460>>>>>>>        Integer[] iaChangeField
86461>>>>>>>
86461>>>>>>>        Get UtilTableExists hTable to bOK
86462>>>>>>>        // I believe we should just skip files not found and not report an error.
86462>>>>>>>        // This is because a filelist may have entries but no files/tables on disk, but
86462>>>>>>>        // this may be adjusted by other calls to DUF in a later update package. 
86462>>>>>>>        // Especially considering that this call is probably done at the very
86462>>>>>>>        // beginning of a DUF update.
86462>>>>>>>        If (bOK = False) Begin
86464>>>>>>>//            Set Private.phCurrentTable to hTable
86464>>>>>>>//            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
86464>>>>>>>//            Function_Return False
86464>>>>>>>            Function_Return True
86465>>>>>>>        End
86465>>>>>>>>
86465>>>>>>>
86465>>>>>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the
86465>>>>>>>        // date format to "USA" = "MM/DD/YYYY"
86465>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
86468>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
86471>>>>>>>
86471>>>>>>>//        Send SetAllIndexesToBatch hTable True
86471>>>>>>>        Open hTable
86473>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86476>>>>>>>        If (bOpened = False) Begin
86478>>>>>>>            Function_Return False
86479>>>>>>>        End
86479>>>>>>>>
86479>>>>>>>        
86479>>>>>>>        Set Private.phCurrentTable to hTable
86480>>>>>>>        Move 0 to iRecord
86481>>>>>>>        Move (SizeOfArray(aDateFields)) to iSize
86482>>>>>>>        Decrement iSize
86483>>>>>>>
86483>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
86486>>>>>>>        Get DriverIndex sDriverID to iDriverIndex
86487>>>>>>>        If (iDriverIndex <> 0) Begin
86489>>>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDateMin
86492>>>>>>>            If (sDateMin = "") Begin
86494>>>>>>>                Move CS_DUFLowestAllowedDateValue to dDateMin
86495>>>>>>>            End
86495>>>>>>>>
86495>>>>>>>            Else Begin
86496>>>>>>>                If (IsDate(sDateMin)) Begin
86498>>>>>>>                    Move sDateMin to dDateMin
86499>>>>>>>                End
86499>>>>>>>>
86499>>>>>>>                Else Begin
86500>>>>>>>                    Move CS_DUFLowestAllowedDateValue to dDateMin
86501>>>>>>>                End
86501>>>>>>>>
86501>>>>>>>            End
86501>>>>>>>>
86501>>>>>>>        End
86501>>>>>>>>
86501>>>>>>>        Else Begin
86502>>>>>>>            Move CS_DUFLowestAllowedDateValue to dDateMin
86503>>>>>>>        End
86503>>>>>>>>
86503>>>>>>>
86503>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
86506>>>>>>>        Set piPosition   of ghoProgressBar to 0
86507>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 100
86508>>>>>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
86509>>>>>>>        Move False to Err
86510>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
86511>>>>>>>
86511>>>>>>>        Clear hTable
86512>>>>>>>        Repeat
86512>>>>>>>>
86512>>>>>>>            Vfind hTable 0 GT
86514>>>>>>>            Move Found to bFound
86515>>>>>>>            If (bFound = True) Begin
86517>>>>>>>                Move False to bSaveChanges
86518>>>>>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField
86519>>>>>>>                Move (SizeOfArray(aDateFields)) to iSize
86520>>>>>>>                Decrement iSize
86521>>>>>>>                For iCount from 0 to iSize
86527>>>>>>>>
86527>>>>>>>                    Move aDateFields[iCount] to iField
86528>>>>>>>                    Get_Field_Value hTable iField to dDate
86531>>>>>>>                    If (bFixZeroDates = True) Begin
86533>>>>>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
86534>>>>>>>                    End
86534>>>>>>>>
86534>>>>>>>                    Else Begin
86535>>>>>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
86536>>>>>>>                    End
86536>>>>>>>>
86536>>>>>>>                    If (bChange = True) Begin
86538>>>>>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]
86539>>>>>>>                    End
86539>>>>>>>>
86539>>>>>>>                Loop
86540>>>>>>>>
86540>>>>>>>
86540>>>>>>>                // Only change Date fields that needs to be changed.
86540>>>>>>>                If (SizeOfArray(iaChangeField)) Begin
86542>>>>>>>                    Reread hTable
86546>>>>>>>                        Move (SizeOfArray(iaChangeField)) to iSize
86547>>>>>>>                        Decrement iSize
86548>>>>>>>                        For iCount from 0 to iSize
86554>>>>>>>>
86554>>>>>>>                            Move iaChangeField[iCount] to iField
86555>>>>>>>                            Set Private.piCurrentField to iField
86556>>>>>>>                            Set_Field_Value hTable iField to dDateMin
86559>>>>>>>                        Loop
86560>>>>>>>>
86560>>>>>>>                        Move False to Err
86561>>>>>>>                        SaveRecord hTable
86562>>>>>>>                    Unlock
86563>>>>>>>>
86563>>>>>>>                End
86563>>>>>>>>
86563>>>>>>>
86563>>>>>>>                Increment iRecord
86564>>>>>>>                // Increment the StatusPanel counter and check the
86564>>>>>>>                // cancel status every 100 records rather than every
86564>>>>>>>                // record, it's way faster.
86564>>>>>>>                If (Mod(iRecord, 100) = 0) Begin
86566>>>>>>>                    Send DoAdvance of ghoProgressBar
86567>>>>>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
86568>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
86569>>>>>>>                End
86569>>>>>>>>
86569>>>>>>>            End
86569>>>>>>>>
86569>>>>>>>        Until (bFound = False)
86571>>>>>>>
86571>>>>>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
86574>>>>>>>        If (bResetIndexesToOnLine = True) Begin
86576>>>>>>>            Send SetAllIndexesToBatch hTable False
86577>>>>>>>        End
86577>>>>>>>>
86577>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
86578>>>>>>>
86578>>>>>>>        Function_Return (Err = False)
86579>>>>>>>    End_Function
86580>>>>>>>
86580>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
86580>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
86580>>>>>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
86582>>>>>>>        Boolean bIsSame
86582>>>>>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
86582>>>>>>>
86582>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
86583>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
86584>>>>>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
86585>>>>>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
86586>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
86587>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
86588>>>>>>>
86588>>>>>>>        If (bCompareFilelistUppercase = True) Begin
86590>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
86591>>>>>>>        End
86591>>>>>>>>
86591>>>>>>>        Else Begin
86592>>>>>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
86593>>>>>>>        End
86593>>>>>>>>
86593>>>>>>>        If (bIsSame = False) Begin
86595>>>>>>>            Function_Return False
86596>>>>>>>        End
86596>>>>>>>>
86596>>>>>>>
86596>>>>>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
86597>>>>>>>        If (bIsSame = False) Begin
86599>>>>>>>            Function_Return False
86600>>>>>>>        End
86600>>>>>>>>
86600>>>>>>>
86600>>>>>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
86601>>>>>>>        If (bIsSame = False) Begin
86603>>>>>>>            Function_Return False
86604>>>>>>>        End
86604>>>>>>>>
86604>>>>>>>
86604>>>>>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
86605>>>>>>>        If (bIsSame = False) Begin
86607>>>>>>>            Function_Return False
86608>>>>>>>        End
86608>>>>>>>>
86608>>>>>>>
86608>>>>>>>        Function_Return bIsSame
86609>>>>>>>    End_Function
86610>>>>>>>
86610>>>>>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
86612>>>>>>>        Handle hTableFrom hTableTo
86612>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
86612>>>>>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
86612>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
86612>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
86612>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
86613>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
86613>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
86614>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
86614>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
86615>>>>>>>
86615>>>>>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
86616>>>>>>>        If (bIsSame = True) Begin
86618>>>>>>>            Function_Return True
86619>>>>>>>        End
86619>>>>>>>>
86619>>>>>>>
86619>>>>>>>        Move False to bFilelistError
86620>>>>>>>        Move True to bIsSame
86621>>>>>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
86622>>>>>>>        Get pbCompareIndexAscending to bCompareIndexAscending
86623>>>>>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
86624>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
86625>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
86626>>>>>>>
86626>>>>>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
86627>>>>>>>        Get _TableNameOnly sRootName             to sRootName
86628>>>>>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
86629>>>>>>>
86629>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
86629>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
86629>>>>>>>        If (bCodeGenerateMode = True) Begin
86631>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
86631>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
86633>>>>>>>                Function_Return False
86634>>>>>>>            End
86634>>>>>>>>
86634>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
86635>>>>>>>            If (bIsSame = False) Begin
86637>>>>>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
86638>>>>>>>                Move True to bFilelistError
86639>>>>>>>                Function_Return False
86640>>>>>>>            End
86640>>>>>>>>
86640>>>>>>>        End
86640>>>>>>>>
86640>>>>>>>
86640>>>>>>>        If (bCodeGenerateMode = False) Begin
86642>>>>>>>            // Then we want to create this table
86642>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
86644>>>>>>>                Function_Return False
86645>>>>>>>            End
86645>>>>>>>>
86645>>>>>>>
86645>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
86646>>>>>>>            If (bIsSame = False) Begin
86648>>>>>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
86649>>>>>>>>
86649>>>>>>>                Move True to bFilelistError
86650>>>>>>>                Function_Return False
86651>>>>>>>            End
86651>>>>>>>>
86651>>>>>>>        End
86651>>>>>>>>
86651>>>>>>>
86651>>>>>>>        // Check columns:
86651>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
86652>>>>>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
86653>>>>>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
86654>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
86655>>>>>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
86656>>>>>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
86657>>>>>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
86658>>>>>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
86659>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
86660>>>>>>>        If (bIsSame = False) Begin
86662>>>>>>>            Function_Return False
86663>>>>>>>        End
86663>>>>>>>>
86663>>>>>>>
86663>>>>>>>        // ...then check indexes:
86663>>>>>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
86664>>>>>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
86665>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
86666>>>>>>>        If (bIsSame = False) Begin
86668>>>>>>>            Function_Return False
86669>>>>>>>        End
86669>>>>>>>>
86669>>>>>>>
86669>>>>>>>        // ...and finally relationships:
86669>>>>>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
86670>>>>>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
86671>>>>>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
86672>>>>>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
86673>>>>>>>
86673>>>>>>>        Function_Return (bIsSame = True)
86674>>>>>>>    End_Function
86675>>>>>>>
86675>>>>>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
86675>>>>>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
86677>>>>>>>        Handle hTable
86677>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
86677>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
86677>>>>>>>
86677>>>>>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
86679>>>>>>>            Move True to bFilelistError
86680>>>>>>>            Function_Return False
86681>>>>>>>        End
86681>>>>>>>>
86681>>>>>>>
86681>>>>>>>        Move APITableCompare.hTable to hTable
86682>>>>>>>        Move True  to bIsSame
86683>>>>>>>        Move False to bFilelistError
86684>>>>>>>
86684>>>>>>>        If (APITableCompare.bExistsFrom = True) Begin
86686>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
86687>>>>>>>        End
86687>>>>>>>>
86687>>>>>>>        Else Begin
86688>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
86689>>>>>>>        End
86689>>>>>>>>
86689>>>>>>>        Get _TableNameOnly sRootName                                   to sRootName
86690>>>>>>>
86690>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
86691>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
86692>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
86693>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
86694>>>>>>>
86694>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
86694>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
86694>>>>>>>        If (bCodeGenerateMode = True) Begin
86696>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
86696>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
86698>>>>>>>                Function_Return False
86699>>>>>>>            End
86699>>>>>>>>
86699>>>>>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
86700>>>>>>>            If (bIsSame = False) Begin
86702>>>>>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
86703>>>>>>>                Move True to bFilelistError
86704>>>>>>>                Function_Return False
86705>>>>>>>            End
86705>>>>>>>>
86705>>>>>>>        End
86705>>>>>>>>
86705>>>>>>>
86705>>>>>>>        If (bCodeGenerateMode = False) Begin
86707>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
86709>>>>>>>                // Then we might want to create this table
86709>>>>>>>                Function_Return False
86710>>>>>>>            End
86710>>>>>>>>
86710>>>>>>>
86710>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
86711>>>>>>>            If (bIsSame = False) Begin
86713>>>>>>>                Function_Return False
86714>>>>>>>            End
86714>>>>>>>>
86714>>>>>>>
86714>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
86715>>>>>>>            If (bIsSame = False) Begin
86717>>>>>>>                Function_Return False
86718>>>>>>>            End
86718>>>>>>>>
86718>>>>>>>
86718>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
86719>>>>>>>            If (bIsSame = False) Begin
86721>>>>>>>                Function_Return False
86722>>>>>>>            End
86722>>>>>>>>
86722>>>>>>>
86722>>>>>>>            // Check table names et al.
86722>>>>>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
86723>>>>>>>            If (bIsSame = False) Begin
86725>>>>>>>                Function_Return False
86726>>>>>>>            End
86726>>>>>>>>
86726>>>>>>>        End
86726>>>>>>>>
86726>>>>>>>
86726>>>>>>>        // Check Columns:
86726>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
86727>>>>>>>        If (bIsSame = False) Begin
86729>>>>>>>            Function_Return False
86730>>>>>>>        End
86730>>>>>>>>
86730>>>>>>>
86730>>>>>>>        // ...then check Indexes:
86730>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
86731>>>>>>>        If (bIsSame = False) Begin
86733>>>>>>>            Function_Return False
86734>>>>>>>        End
86734>>>>>>>>
86734>>>>>>>
86734>>>>>>>        // ...and finally Relationships:
86734>>>>>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
86735>>>>>>>
86735>>>>>>>        Function_Return (bIsSame = True)
86736>>>>>>>    End_Function
86737>>>>>>>
86737>>>>>>>    // To fill a complete Table array structure (tAPITable[]) with data.
86737>>>>>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
86737>>>>>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
86737>>>>>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
86737>>>>>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
86739>>>>>>>        tAPITableNameInfo ApiTableNameInfo
86739>>>>>>>        tAPITableNameInfo ApiTableNameInfo
86739>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
86739>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
86741>>>>>>>        tAPIColumn[]    aApiColumns
86741>>>>>>>        tAPIColumn[]    aApiColumns
86742>>>>>>>        tAPIIndex[]     aApiIndexes
86742>>>>>>>        tAPIIndex[]     aApiIndexes
86743>>>>>>>        tAPIRelation[]  aApiRelations
86743>>>>>>>        tAPIRelation[]  aApiRelations
86744>>>>>>>        Handle hTable
86744>>>>>>>        Integer iCount
86744>>>>>>>        Boolean bUserCancel bOK
86744>>>>>>>        String sLogicalName sMessageText
86744>>>>>>>
86744>>>>>>>        Get AutoConnectionIDLogin to bOK
86745>>>>>>>        Move 0 to hTable
86746>>>>>>>        If (bFromTables = True) Begin
86748>>>>>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
86749>>>>>>>            If (bCompareUtil = True) Begin
86751>>>>>>>                Move (sMessageText * "(1 of 3)") to sMessageText
86752>>>>>>>            End
86752>>>>>>>>
86752>>>>>>>        End
86752>>>>>>>>
86752>>>>>>>        Else Begin
86753>>>>>>>            Move "Reading 'TO' Table Structure:" to sMessageText
86754>>>>>>>            If (bCompareUtil = True) Begin
86756>>>>>>>                Move (sMessageText * "(2 of 3)") to sMessageText
86757>>>>>>>            End
86757>>>>>>>>
86757>>>>>>>        End
86757>>>>>>>>
86757>>>>>>>        Set Message_Text of ghoStatusPanel to sMessageText
86758>>>>>>>
86758>>>>>>>        Get UtilFilelistNoOfTables to iCount
86759>>>>>>>        Set piMaximum of ghoProgressBar to iCount
86760>>>>>>>        Move 0 to iCount
86761>>>>>>>
86761>>>>>>>        Repeat
86761>>>>>>>>
86761>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
86764>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
86766>>>>>>>
86766>>>>>>>                Open hTable
86768>>>>>>>                // ToDo: Needs to be revised
86768>>>>>>>                // For some reason tables may be reported as "unopened", while in
86768>>>>>>>                // fact the open was successful (!)
86768>>>>>>>//                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
86768>>>>>>>//                If (bIsOpen = False) Begin
86768>>>>>>>//                    Move True to aApiTablesEmpty[0].bError
86768>>>>>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
86768>>>>>>>//                    Function_Return aApiTablesEmpty
86768>>>>>>>//                End
86768>>>>>>>
86768>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86771>>>>>>>                Set piPosition of ghoProgressBar to iCount
86772>>>>>>>                Send DoAdvance of ghoProgressBarOverall
86773>>>>>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
86774>>>>>>>
86774>>>>>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
86775>>>>>>>//                Close hTable DF_PERMANENT
86775>>>>>>>                Increment iCount
86776>>>>>>>            End
86776>>>>>>>>
86776>>>>>>>
86776>>>>>>>            If (bStatusPanel = True) Begin
86778>>>>>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
86779>>>>>>>                If (bUserCancel = True) Begin
86781>>>>>>>                    Move True to aApiTablesEmpty[0].bCancel
86782>>>>>>>                    Function_Return aApiTablesEmpty
86783>>>>>>>                End
86783>>>>>>>>
86783>>>>>>>            End
86783>>>>>>>>
86783>>>>>>>
86783>>>>>>>        Until (hTable = 0)
86785>>>>>>>
86785>>>>>>>        Function_Return aApiTables
86786>>>>>>>    End_Function
86787>>>>>>>
86787>>>>>>>    // Returns a 'single' table APITable struct.
86787>>>>>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
86789>>>>>>>        tAPITableNameInfo ApiTableNameInfo
86789>>>>>>>        tAPITableNameInfo ApiTableNameInfo
86789>>>>>>>        tAPITable         ApiTable ApiTableEmpty
86789>>>>>>>        tAPITable         ApiTable ApiTableEmpty
86789>>>>>>>        tAPIColumn[]     aApiColumns
86789>>>>>>>        tAPIColumn[]     aApiColumns
86790>>>>>>>        tAPIIndex[]      aApiIndexes
86790>>>>>>>        tAPIIndex[]      aApiIndexes
86791>>>>>>>        tAPIRelation[]   aApiRelations
86791>>>>>>>        tAPIRelation[]   aApiRelations
86792>>>>>>>        Boolean bIsOpen
86792>>>>>>>
86792>>>>>>>        Open hTable
86794>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
86797>>>>>>>        If (bIsOpen = False) Begin
86799>>>>>>>            Move True to ApiTableEmpty.bError
86800>>>>>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
86801>>>>>>>            Function_Return ApiTableEmpty
86802>>>>>>>        End
86802>>>>>>>>
86802>>>>>>>
86802>>>>>>>        // Fill Table Name Info
86802>>>>>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
86803>>>>>>>
86803>>>>>>>        // Fill columns
86803>>>>>>>        Get UtilColumnsStructFill hTable to aApiColumns
86804>>>>>>>        If (SizeOfArray(aApiColumns)) Begin
86806>>>>>>>            If (aApiColumns[0].bCancel = True) Begin
86808>>>>>>>                Move True to ApiTableEmpty.bError
86809>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
86810>>>>>>>                Function_Return ApiTableEmpty
86811>>>>>>>            End
86811>>>>>>>>
86811>>>>>>>        End
86811>>>>>>>>
86811>>>>>>>
86811>>>>>>>        // Fill indexes
86811>>>>>>>        Get UtilIndexesStructFill hTable to aApiIndexes
86812>>>>>>>        If (SizeOfArray(aApiIndexes)) Begin
86814>>>>>>>            If (aApiIndexes[0].bCancel = True) Begin
86816>>>>>>>                Move True to ApiTableEmpty.bError
86817>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
86818>>>>>>>                Function_Return ApiTableEmpty
86819>>>>>>>            End
86819>>>>>>>>
86819>>>>>>>        End
86819>>>>>>>>
86819>>>>>>>
86819>>>>>>>        // Fill relationships
86819>>>>>>>        Get UtilRelationsStructFill hTable to aApiRelations
86820>>>>>>>        If (SizeOfArray(aApiRelations)) Begin
86822>>>>>>>            If (aApiRelations[0].bCancel = True) Begin
86824>>>>>>>                Move True to ApiTableEmpty.bError
86825>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
86826>>>>>>>                Function_Return ApiTableEmpty
86827>>>>>>>            End
86827>>>>>>>>
86827>>>>>>>        End
86827>>>>>>>>
86827>>>>>>>
86827>>>>>>>        Move hTable             to ApiTable.hTable
86828>>>>>>>        Move bFromTables        to ApiTable.bFromTable
86829>>>>>>>        Move (not(bFromTables)) to ApiTable.bToTable
86830>>>>>>>
86830>>>>>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
86831>>>>>>>        Move aApiColumns        to ApiTable.aApiColumns
86832>>>>>>>        Move aApiIndexes        to ApiTable.aApiIndexes
86833>>>>>>>        Move aApiRelations      to ApiTable.aApiRelations
86834>>>>>>>
86834>>>>>>>        Function_Return ApiTable
86835>>>>>>>    End_Function
86836>>>>>>>
86836>>>>>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
86838>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
86838>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
86838>>>>>>>        Boolean bIsOpen
86838>>>>>>>
86838>>>>>>>        Open hTable
86840>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
86843>>>>>>>        If (bIsOpen = False) Begin
86845>>>>>>>            Move True   to APITableNameInfoEmpty.bError
86846>>>>>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
86847>>>>>>>            Function_Return APITableNameInfoEmpty
86848>>>>>>>        End
86848>>>>>>>>
86848>>>>>>>
86848>>>>>>>        Move hTable                                  to APITableNameInfo.iTableNumber
86849>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
86852>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
86855>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
86858>>>>>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
86861>>>>>>>
86861>>>>>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
86862>>>>>>>        Get UtilTableIsSQL                    hTable to APITableNameInfo.bIsSQL
86863>>>>>>>
86863>>>>>>>        Function_Return APITableNameInfo
86864>>>>>>>    End_Function
86865>>>>>>>
86865>>>>>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
86867>>>>>>>        Integer iSize iCount iItem
86867>>>>>>>        tAPITableNameInfo ApiTableNameInfo
86867>>>>>>>        tAPITableNameInfo ApiTableNameInfo
86867>>>>>>>
86867>>>>>>>        Move -1 to iItem
86868>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
86869>>>>>>>        Decrement iSize
86870>>>>>>>        for iCount from 0 to iSize
86876>>>>>>>>
86876>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
86877>>>>>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
86879>>>>>>>                Move iCount to iItem
86880>>>>>>>                Move iSize  to iCount // We're done.
86881>>>>>>>            End
86881>>>>>>>>
86881>>>>>>>        Loop
86882>>>>>>>>
86882>>>>>>>
86882>>>>>>>        Function_Return iItem
86883>>>>>>>    End_Function
86884>>>>>>>
86884>>>>>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
86886>>>>>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
86889>>>>>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
86892>>>>>>>
86892>>>>>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
86895>>>>>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
86898>>>>>>>
86898>>>>>>>        Function_Return (EQ)
86899>>>>>>>    End_Function
86900>>>>>>>
86900>>>>>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
86902>>>>>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
86902>>>>>>>        Handle hTable
86902>>>>>>>        tAPITable[] aAPITableFromAndTo
86902>>>>>>>        tAPITable[] aAPITableFromAndTo
86903>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
86903>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
86903>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
86903>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
86903>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
86903>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
86904>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
86904>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
86905>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
86905>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
86906>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
86906>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
86907>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
86907>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
86907>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
86907>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
86910>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
86910>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
86913>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
86913>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
86916>>>>>>>
86916>>>>>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
86917>>>>>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
86918>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
86920>>>>>>>            Function_Return aAPITableCompare
86921>>>>>>>        End
86921>>>>>>>>
86921>>>>>>>
86921>>>>>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
86922>>>>>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
86923>>>>>>>
86923>>>>>>>        Move 0 to iItem
86924>>>>>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
86925>>>>>>>        Decrement iSize
86926>>>>>>>        for iCount from 0 to iSize
86932>>>>>>>>
86932>>>>>>>
86932>>>>>>>            Move iCount to iItemFrom
86933>>>>>>>            Move iCount to iItemTo
86934>>>>>>>            Move APITableEmpty to APITableFrom
86935>>>>>>>            Move APITableEmpty to APITableTo
86936>>>>>>>
86936>>>>>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
86938>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
86939>>>>>>>            End
86939>>>>>>>>
86939>>>>>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
86941>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
86942>>>>>>>            End
86942>>>>>>>>
86942>>>>>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
86944>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
86945>>>>>>>                Move (iCount + 1) to iItemTo
86946>>>>>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
86947>>>>>>>            End
86947>>>>>>>>
86947>>>>>>>            If (APITableFrom.hTable > APITableTo.hTable) Begin
86949>>>>>>>                Get FindTableNumber aAPITableTo APITableFrom.hTable to iItemTo
86950>>>>>>>                If (iItemTo <> -1) Begin
86952>>>>>>>                    Move aAPITableTo[iItemTo] to APITableTo
86953>>>>>>>                End
86953>>>>>>>>
86953>>>>>>>                Else Begin
86954>>>>>>>                    Move APITableEmpty to APITableTo
86955>>>>>>>                End
86955>>>>>>>>
86955>>>>>>>            End
86955>>>>>>>>
86955>>>>>>>
86955>>>>>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
86956>>>>>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
86957>>>>>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
86958>>>>>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
86959>>>>>>>
86959>>>>>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
86960>>>>>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
86961>>>>>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
86962>>>>>>>            Move APITableTo.aApiRelations   to aApiRelationTo
86963>>>>>>>
86963>>>>>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
86964>>>>>>>
86964>>>>>>>            If (hTable > 0) Begin
86966>>>>>>>
86966>>>>>>>                // Table info:
86966>>>>>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
86967>>>>>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
86968>>>>>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
86969>>>>>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
86970>>>>>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
86971>>>>>>>
86971>>>>>>>                // Column info:
86971>>>>>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
86972>>>>>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
86973>>>>>>>
86973>>>>>>>                // Index info:
86973>>>>>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
86974>>>>>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
86975>>>>>>>
86975>>>>>>>                // Relation info:
86975>>>>>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
86976>>>>>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
86977>>>>>>>
86977>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
86978>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
86979>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bError
86980>>>>>>>                If (iItemTo > iItemFrom) Begin
86982>>>>>>>                    Increment iCount
86983>>>>>>>                End
86983>>>>>>>>
86983>>>>>>>                Increment iItem
86984>>>>>>>            End
86984>>>>>>>>
86984>>>>>>>
86984>>>>>>>        Loop
86985>>>>>>>>
86985>>>>>>>
86985>>>>>>>        Function_Return aAPITableCompare
86986>>>>>>>    End_Function
86987>>>>>>>
86987>>>>>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
86989>>>>>>>        Integer iSize iCount iItem
86989>>>>>>>        tAPITableNameInfo ApiTableNameInfo
86989>>>>>>>        tAPITableNameInfo ApiTableNameInfo
86989>>>>>>>
86989>>>>>>>        Move -1 to iItem
86990>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
86991>>>>>>>        Decrement iSize
86992>>>>>>>        For iCount from 0 to iSize
86998>>>>>>>>
86998>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
86999>>>>>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
87001>>>>>>>                Move iCount to iItem
87002>>>>>>>                Move iSize  to iCount // We're done.
87003>>>>>>>            End
87003>>>>>>>>
87003>>>>>>>        Loop
87004>>>>>>>>
87004>>>>>>>
87004>>>>>>>        Function_Return iItem
87005>>>>>>>    End_Function
87006>>>>>>>
87006>>>>>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
87008>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
87008>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
87008>>>>>>>
87008>>>>>>>        If (APITableNameInfoFrom.iTableNumber = 0 and APITableNameInfoTo.iTableNumber = 0) Begin
87010>>>>>>>            Function_Return APITableNameInfoCompare
87011>>>>>>>        End
87011>>>>>>>>
87011>>>>>>>
87011>>>>>>>        // FROM database info:
87011>>>>>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
87013>>>>>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
87014>>>>>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
87015>>>>>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
87016>>>>>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
87017>>>>>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
87018>>>>>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
87019>>>>>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
87020>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
87021>>>>>>>        End
87021>>>>>>>>
87021>>>>>>>
87021>>>>>>>        // TO database info:
87021>>>>>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
87023>>>>>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
87024>>>>>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
87025>>>>>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
87026>>>>>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
87027>>>>>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
87028>>>>>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
87029>>>>>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
87030>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsTo
87031>>>>>>>        End
87031>>>>>>>>
87031>>>>>>>
87031>>>>>>>        Function_Return APITableNameInfoCompare
87032>>>>>>>    End_Function
87033>>>>>>>
87033>>>>>>>    // Note:
87033>>>>>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
87033>>>>>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
87033>>>>>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
87033>>>>>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
87033>>>>>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
87033>>>>>>>    Function UtilTableHandleToString Handle hTable Returns String
87035>>>>>>>        String sTableName
87035>>>>>>>        Boolean bOpen bExists bOK
87035>>>>>>>
87035>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
87036>>>>>>>        If (bExists = False) Begin
87038>>>>>>>            Function_Return ""
87039>>>>>>>        End
87039>>>>>>>>
87039>>>>>>>
87039>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87040>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
87043>>>>>>>        If (bOpen = False) Begin
87045>>>>>>>            Get AutoConnectionIDLogin to bOK
87046>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
87047>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
87048>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
87049>>>>>>>            Open hTable
87051>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
87052>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
87053>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
87054>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
87057>>>>>>>        End
87057>>>>>>>>
87057>>>>>>>        If (bOpen = True) Begin
87059>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
87060>>>>>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
87063>>>>>>>            // If blank it is an embedded table:
87063>>>>>>>            If (sTableName = "") Begin
87065>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
87068>>>>>>>                Move 0 to LastErr
87069>>>>>>>                Move False to Err
87070>>>>>>>            End
87070>>>>>>>>
87070>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
87071>>>>>>>        End
87071>>>>>>>>
87071>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87072>>>>>>>        Move 0 to LastErr
87073>>>>>>>
87073>>>>>>>        Function_Return sTableName
87074>>>>>>>    End_Function
87075>>>>>>>
87075>>>>>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
87075>>>>>>>    // Returns 0 if unsuccessful.
87075>>>>>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
87075>>>>>>>    Function UtilTableNameToHandle String sTableName Returns Integer
87077>>>>>>>        String sValue sPrefixTableName sDriverID
87077>>>>>>>        Handle hTable hRetval
87077>>>>>>>
87077>>>>>>>        Get psDriverID to sDriverID
87078>>>>>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
87080>>>>>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
87081>>>>>>>        End
87081>>>>>>>>
87081>>>>>>>        Move 0 to hTable
87082>>>>>>>        Move 0 to hRetval
87083>>>>>>>        Repeat
87083>>>>>>>>
87083>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
87086>>>>>>>            If (hTable <> 0) Begin
87088>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
87091>>>>>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
87093>>>>>>>                    Move hTable to hRetval
87094>>>>>>>                    Move 0 to hTable
87095>>>>>>>                End
87095>>>>>>>>
87095>>>>>>>            End
87095>>>>>>>>
87095>>>>>>>        Until (hTable = 0)
87097>>>>>>>
87097>>>>>>>        Function_Return hRetval
87098>>>>>>>    End_Function
87099>>>>>>>
87099>>>>>>>    // Use function to move all *.dat, *.k?? & *.hdr files to a "Data\Backup" folder
87099>>>>>>>    // _after_ all tables have successfully been converted to SQL (.int files)
87099>>>>>>>    Function UtilMoveAllEmbeddedToBackupFolder Returns Boolean
87101>>>>>>>        Boolean bOK bExists
87101>>>>>>>        String sDataPath sBackupFolder
87101>>>>>>>
87101>>>>>>>        Close DF_ALL DF_PERMANENT
87102>>>>>>>        Send DoAdvance of ghoProgressBar
87103>>>>>>>
87103>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
87104>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
87105>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
87106>>>>>>>        Get vFolderFormat sDataPath to sDataPath
87107>>>>>>>
87107>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
87108>>>>>>>        If (bExists = False) Begin
87110>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
87111>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
87112>>>>>>>            If (bExists = False) Begin
87114>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
87115>>>>>>>>
87115>>>>>>>                Function_Return False
87116>>>>>>>            End
87116>>>>>>>>
87116>>>>>>>        End
87116>>>>>>>>
87116>>>>>>>
87116>>>>>>>        Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
87117>>>>>>>        Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
87118>>>>>>>        Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
87119>>>>>>>        Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
87120>>>>>>>        // We need to wait for Windows before we can copy files back
87120>>>>>>>        Sleep 2  
87121>>>>>>>        
87121>>>>>>>        //...except for these files that needs to be copied back to the Data folder:
87121>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeMast.*")  sDataPath to bOK 
87122>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeType.*")  sDataPath to bOK                                 
87123>>>>>>>        Get vCopyFile (sBackupFolder + "\Flexerrs.*")  sDataPath to bOK                                 
87124>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr001.*")  sDataPath to bOK                                 
87125>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr002.*")  sDataPath to bOK                                 
87126>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr003.*")  sDataPath to bOK                                 
87127>>>>>>>//            Get vCopyFile (sBackupFolder + "\DbVersion.*") sDataPath to bOK  
87127>>>>>>>        
87127>>>>>>>
87127>>>>>>>        Set Message_Text of ghoStatusPanel to ""
87128>>>>>>>        Function_Return True
87129>>>>>>>    End_Function
87130>>>>>>>    
87130>>>>>>>    Function UtilTableRepairAndReindexALL Returns Boolean
87132>>>>>>>        Boolean bOK bRetval
87132>>>>>>>        Handle hTable
87132>>>>>>>        Integer iSize iCount
87132>>>>>>>        
87132>>>>>>>        Move True to bOK
87133>>>>>>>        Get UtilFilelistNoOfTables to iSize
87134>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
87135>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
87136>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
87137>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
87138>>>>>>>
87138>>>>>>>        Repeat
87138>>>>>>>>
87138>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
87139>>>>>>>            Increment iCount
87140>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
87143>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin // 50 = Flexerrs.
87145>>>>>>>                Get UtilTableRepairAndReindex hTable to bRetval
87146>>>>>>>                If (bRetval = False) Begin
87148>>>>>>>                    Move False to bOK
87149>>>>>>>                End
87149>>>>>>>>
87149>>>>>>>            End
87149>>>>>>>>
87149>>>>>>>        Until (hTable = 0)
87151>>>>>>>                
87151>>>>>>>        Function_Return bOK
87152>>>>>>>    End_Function           
87153>>>>>>>    
87153>>>>>>>    // Checks if an Embedded (DataFlex) data-file needs to be repaired.
87153>>>>>>>    // After the header has been repaired - also makes a re-index.  
87153>>>>>>>    // Returns TRUE if successful OR the table was an an ALIAS or SQL table in case we do nothing.
87153>>>>>>>    Function UtilTableRepairAndReindex Handle hTable Returns Boolean
87155>>>>>>>        Boolean bOK bIsAlias bIsEmbedded bIsOpen bBadExists
87155>>>>>>>        Integer iRetval
87155>>>>>>>        String sRootName sFileName sDataPath
87155>>>>>>>        
87155>>>>>>>        Move False to Err
87156>>>>>>>        Move 0 to LastErr 
87157>>>>>>>        Move True to bOK
87158>>>>>>>        
87158>>>>>>>        Get UtilTableIsEmbedded hTable to bIsEmbedded
87159>>>>>>>        If (bIsEmbedded = False or hTable = 50) Begin // 50 = Flexerrs
87161>>>>>>>            Function_Return True
87162>>>>>>>        End
87162>>>>>>>>
87162>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias 
87163>>>>>>>        If (bIsAlias = True) Begin
87165>>>>>>>            Function_Return True
87166>>>>>>>        End
87166>>>>>>>>
87166>>>>>>>        
87166>>>>>>>        // Check for bad file and remove if exists
87166>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
87169>>>>>>>        Set private.phCurrentTable to hTable  
87170>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
87171>>>>>>>        
87171>>>>>>>        // This is important! Else it can happen that the table can't be opened,
87171>>>>>>>        // with a "4077 - File in use" error.
87171>>>>>>>        Close DF_ALL DF_PERMANENT    
87172>>>>>>>        Open hTable
87174>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87177>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87178>>>>>>>        If (bIsOpen = False) Begin
87180>>>>>>>            Error DFERR_PROGRAM ("Could not open table to be repaired and reindexed:" * String(sRootName))
87181>>>>>>>>
87181>>>>>>>            Function_Return False        
87182>>>>>>>        End
87182>>>>>>>>
87182>>>>>>>
87182>>>>>>>        Get vFilePathExists (sRootName + ".BAD")  to bBadExists
87183>>>>>>>        If (bBadExists = True) Begin
87185>>>>>>>            Get_File_Path (sRootName + ".BAD") to sFileName
87186>>>>>>>            Get vDeleteFile sFileName to iRetval
87187>>>>>>>        End
87187>>>>>>>>
87187>>>>>>>        
87187>>>>>>>        Set TableName_Text of ghoStatusPanel to ("Repairing and reindex Table Name:" * sRootName * "Number:" * String(hTable))
87188>>>>>>>        
87188>>>>>>>        Move False to Err
87189>>>>>>>        // **** Repair and reindex the table. ****
87189>>>>>>>        Get UtilTableRepairEmbedded hTable sRootName to bOK
87190>>>>>>>
87190>>>>>>>        // Check for bad file: if it exists, something went wrong
87190>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
87191>>>>>>>        Get vFolderFormat sDataPath to sDataPath
87192>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".BAD") to bBadExists
87193>>>>>>>        If (bBadExists = True) Begin
87195>>>>>>>            Error DFERR_PROGRAM ("Error while sorting data. .BAD file created:"  * String(sRootName) + ".BAD")
87196>>>>>>>>
87196>>>>>>>            Move False to bOK
87197>>>>>>>        End
87197>>>>>>>>
87197>>>>>>>        Close hTable
87198>>>>>>>
87198>>>>>>>        Function_Return bOK
87199>>>>>>>    End_Function
87200>>>>>>>
87200>>>>>>>    // Repair and reindex the named DataFlex data-table.
87200>>>>>>>    // No checks are done if the passed table name is an embedded or SQL,
87200>>>>>>>    // so use with care (make sure you only pass embedded table names).
87200>>>>>>>    Function UtilTableRepairEmbedded Handle hTable String sTableName Returns Boolean
87202>>>>>>>        String sMode
87202>>>>>>>        Integer iVoid
87202>>>>>>>
87202>>>>>>>        Set Message_Text of ghoStatusPanel to "Repair/Reindex in progress..."
87203>>>>>>>        Move "0" to sMode   // 0=Reindex after repair!    
87204>>>>>>>        Close hTable        // The table needs to be closed, else error 4177 "Table in use".
87205>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_REPAIR_FILE Callback ghoDbUpdateHandler Passing sTableName sMode 0 Result iVoid 
87210>>>>>>>        Set Message_Text of ghoStatusPanel to ""
87211>>>>>>>        Function_Return (iVoid = 0)
87212>>>>>>>    End_Function
87213>>>>>>>
87213>>>>>>>    // Returns _two_ arrays.
87213>>>>>>>    // Returns all files that are Master files in array ByRef iaFileIsMaster
87213>>>>>>>    // Also returns all files that are Alias files in a second array.
87213>>>>>>>    // IMPORTANT: All master & alias files _must_ have been included into
87213>>>>>>>    //            the DoSetAllMasterAndAlias message.
87213>>>>>>>    Function UtilTableAllMasterAndAliasFiles Integer[] ByRef iaFileIsMaster Returns Integer[]
87215>>>>>>>        Integer[] iaFileIsAlias
87216>>>>>>>        Integer hTable iFileAlias iSize
87216>>>>>>>        Boolean bOpen
87216>>>>>>>
87216>>>>>>>        Move 0 to hTable
87217>>>>>>>        Repeat
87217>>>>>>>>
87217>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
87220>>>>>>>            If (hTable <> 0) Begin
87222>>>>>>>                Open hTable
87224>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
87227>>>>>>>                If (bOpen = True) Begin
87229>>>>>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iFileAlias
87232>>>>>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
87234>>>>>>>                        Move (SizeOfArray(iaFileIsMaster)) to iSize
87235>>>>>>>                        Move hTable to iaFileIsMaster[iSize]
87236>>>>>>>                    End
87236>>>>>>>>
87236>>>>>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
87239>>>>>>>                        Move (SizeOfArray(iaFileIsAlias)) to iSize
87240>>>>>>>                        Move hTable to iaFileIsAlias[iSize]
87241>>>>>>>                    End
87241>>>>>>>>
87241>>>>>>>                End
87241>>>>>>>>
87241>>>>>>>            End
87241>>>>>>>>
87241>>>>>>>        Until (hTable = 0)
87243>>>>>>>
87243>>>>>>>        Function_Return iaFileIsAlias
87244>>>>>>>    End_Function  
87245>>>>>>>    
87245>>>>>>>    // Is a repair of the data-header necessary? (Embedded tables only)
87245>>>>>>>    Function UtilTableRepairIsNeeded Handle hTable String sTableName Returns Integer
87247>>>>>>>        String sMode
87247>>>>>>>        Integer iRepairNeeded bIsOpen
87247>>>>>>>
87247>>>>>>>        Move "0" to sMode
87248>>>>>>>        Set private.phCurrentTable to hTable 
87249>>>>>>>        Close hTable
87250>>>>>>>        Open hTable
87252>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87255>>>>>>>        Call_Driver hTable DATAFLEX_ID Function FLEX_GET_REPAIRS_NEEDED Callback 0 Passing sTableName sMode 0 Result iRepairNeeded
87260>>>>>>>
87260>>>>>>>        Function_Return iRepairNeeded
87261>>>>>>>    End_Function
87262>>>>>>>
87262>>>>>>>
87262>>>>>>>    // Helper function
87262>>>>>>>    // Takes two params:
87262>>>>>>>    //   1. An array with all master table numbers  (Function UtilTableAllMasterAndAliasFiles)
87262>>>>>>>    //   2. An array with all alias table numbers   (Function UtilTableAllMasterAndAliasFiles)
87262>>>>>>>    // Returns:
87262>>>>>>>    //  DF_FILE_ALIAS_DEFAULT if no master or alias
87262>>>>>>>    //  DF_FILE_IS_MASTER if master
87262>>>>>>>    //  DF_FILE_IS_ALIAS if alias
87262>>>>>>>    Function UtilTableIsMasterAlias Handle hTable Integer[] iaFileIsMaster Integer[] iaFileIsAlias Returns Integer
87264>>>>>>>        Integer i iSize
87264>>>>>>>
87264>>>>>>>        Move (SizeOfArray(iaFileIsMaster)) to iSize
87265>>>>>>>        Decrement iSize
87266>>>>>>>        for i from 0 to iSize
87272>>>>>>>>
87272>>>>>>>            If (hTable = iaFileIsMaster[i]) Begin
87274>>>>>>>                Function_Return DF_FILE_IS_MASTER
87275>>>>>>>            End
87275>>>>>>>>
87275>>>>>>>        Loop
87276>>>>>>>>
87276>>>>>>>
87276>>>>>>>        Move (SizeOfArray(iaFileIsAlias)) to iSize
87277>>>>>>>        Decrement iSize
87278>>>>>>>        for i from 0 to iSize
87284>>>>>>>>
87284>>>>>>>            If (hTable = iaFileIsAlias[i]) Begin
87286>>>>>>>                Function_Return DF_FILE_IS_ALIAS
87287>>>>>>>            End
87287>>>>>>>>
87287>>>>>>>        Loop
87288>>>>>>>>
87288>>>>>>>
87288>>>>>>>        Function_Return DF_FILE_ALIAS_DEFAULT
87289>>>>>>>    End_Function
87290>>>>>>>
87290>>>>>>>    // Determine the available indexes of a table.
87290>>>>>>>    //
87290>>>>>>>    // Arguments:
87290>>>>>>>    //   Handle hTable - The number of the table
87290>>>>>>>    //
87290>>>>>>>    // Returns:
87290>>>>>>>    //   String - A string to be used with the sort command
87290>>>>>>>    //   to re-index all indexes of a table.
87290>>>>>>>    Function UtilTableIndexString Handle hTable Returns String
87292>>>>>>>        String  sSortString
87292>>>>>>>        Integer iLastIndex iNumSegments iCount
87292>>>>>>>
87292>>>>>>>        Move "" to sSortString
87293>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
87296>>>>>>>
87296>>>>>>>        for iCount from 1 to iLastIndex
87302>>>>>>>>
87302>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iNumSegments
87305>>>>>>>            If iNumSegments Begin
87307>>>>>>>                If (Length(sSortString)) ;                    Move (Append(sSortString, " ")) to sSortString
87310>>>>>>>                Move (Append(sSortString, iCount)) to sSortString
87311>>>>>>>            End
87311>>>>>>>>
87311>>>>>>>        Loop
87312>>>>>>>>
87312>>>>>>>
87312>>>>>>>        Function_Return sSortString
87313>>>>>>>    End_Function
87314>>>>>>>
87314>>>>>>>    
87314>>>>>>>    // * Dummy function for the Studio's Code Explorer *
87314>>>>>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
87316>>>>>>>        Function_Return False
87317>>>>>>>    End_Function
87318>>>>>>>
87318>>>>>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
87318>>>>>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
87320>>>>>>>        Boolean bIsSame
87320>>>>>>>        Integer iCount iColumns iColumn
87320>>>>>>>
87320>>>>>>>        Move True to bIsSame
87321>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
87322>>>>>>>        Set piMaximum of ghoProgressBar  to iColumns
87323>>>>>>>        Decrement iColumns
87324>>>>>>>
87324>>>>>>>        for iCount from 0 to iColumns
87330>>>>>>>>
87330>>>>>>>            Set piPosition of ghoProgressBar to iCount
87331>>>>>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
87332>>>>>>>            If (bIsSame = False) Begin
87334>>>>>>>                Function_Return False
87335>>>>>>>            End
87335>>>>>>>>
87335>>>>>>>        Loop
87336>>>>>>>>
87336>>>>>>>
87336>>>>>>>        Function_Return (bIsSame = True)
87337>>>>>>>    End_Function
87338>>>>>>>
87338>>>>>>>    // Compares a single column (For 'FROM' & 'TO' tables)
87338>>>>>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
87340>>>>>>>        Integer iFromType iToType iDbType
87340>>>>>>>        tColumnType ColumnType
87340>>>>>>>        tColumnType ColumnType
87340>>>>>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
87340>>>>>>>
87340>>>>>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
87342>>>>>>>            Function_Return False
87343>>>>>>>        End
87343>>>>>>>>
87343>>>>>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
87345>>>>>>>            Function_Return False
87346>>>>>>>        End
87346>>>>>>>>
87346>>>>>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
87348>>>>>>>            Function_Return False
87349>>>>>>>        End                                                                
87349>>>>>>>>
87349>>>>>>>
87349>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = True) Begin
87351>>>>>>>            If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
87353>>>>>>>                Function_Return False
87354>>>>>>>            End
87354>>>>>>>>
87354>>>>>>>            If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
87356>>>>>>>                If ((APIColumnCompare.sDefaultValueFrom = ""   and APIColumnCompare.sDefaultValueTo = "''") or ;                    (APIColumnCompare.sDefaultValueFrom = "''" and APIColumnCompare.sDefaultValueTo = "")) Begin
87358>>>>>>>                    End
87358>>>>>>>>
87358>>>>>>>                Else Begin
87359>>>>>>>                    Function_Return False
87360>>>>>>>                End
87360>>>>>>>>
87360>>>>>>>            End
87360>>>>>>>>
87360>>>>>>>        End
87360>>>>>>>>
87360>>>>>>>
87360>>>>>>>        Get piDbType                       to iDbType
87361>>>>>>>        Move APIColumnCompare.iTypeFrom    to iFromType
87362>>>>>>>        Move APIColumnCompare.iTypeTo      to iToType
87363>>>>>>>
87363>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
87363>>>>>>>        // data types between Embedded and SQL.
87363>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
87365>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
87366>>>>>>>        End
87366>>>>>>>>
87366>>>>>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
87368>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
87369>>>>>>>        End
87369>>>>>>>>
87369>>>>>>>
87369>>>>>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
87370>>>>>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
87371>>>>>>>
87371>>>>>>>        // Make Date and DateTime comparison?
87371>>>>>>>        If (bCompareDate_DataTime = True) Begin
87373>>>>>>>            If (iFromType <> iToType) Begin
87375>>>>>>>                Function_Return False
87376>>>>>>>            End
87376>>>>>>>>
87376>>>>>>>        End
87376>>>>>>>>
87376>>>>>>>
87376>>>>>>>        // This is when not checking for Date/DateTime differences but all other other field types...
87376>>>>>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
87378>>>>>>>            If (iFromType <> iToType) Begin
87380>>>>>>>                Function_Return False
87381>>>>>>>            End
87381>>>>>>>>
87381>>>>>>>        End
87381>>>>>>>>
87381>>>>>>>
87381>>>>>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
87381>>>>>>>        If (bIsDateTypeFrom = False) Begin
87383>>>>>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
87385>>>>>>>                Function_Return False
87386>>>>>>>            End
87386>>>>>>>>
87386>>>>>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
87388>>>>>>>                Function_Return False
87389>>>>>>>            End
87389>>>>>>>>
87389>>>>>>>        End
87389>>>>>>>>
87389>>>>>>>
87389>>>>>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
87391>>>>>>>            Function_Return False
87392>>>>>>>        End
87392>>>>>>>>
87392>>>>>>>
87392>>>>>>>        Function_Return True
87393>>>>>>>    End_Function
87394>>>>>>>
87394>>>>>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
87396>>>>>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iCheckFieldNumber
87396>>>>>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
87396>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
87396>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
87398>>>>>>>        String sDriverID sRootName sLogicalName
87398>>>>>>>
87398>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87399>>>>>>>        Get piDbType to iDbType
87400>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
87403>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
87406>>>>>>>
87406>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87409>>>>>>>        If (bIsOpen = False) Begin
87411>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
87412>>>>>>>            Open hTable
87414>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
87415>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87418>>>>>>>            If (bIsOpen = False) Begin
87420>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
87421>>>>>>>                Move True to APIColumnsEmpty[0].bError
87422>>>>>>>                Function_Return APIColumnsEmpty
87423>>>>>>>            End
87423>>>>>>>>
87423>>>>>>>        End
87423>>>>>>>>
87423>>>>>>>
87423>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87426>>>>>>>        Get IsSQLDriver    sDriverID to bSqlDriver
87427>>>>>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
87428>>>>>>>
87428>>>>>>>        Get UtilTableIsSQLByRootName sRootName to bIsSqlTable
87429>>>>>>>        If (bIsSqlTable = True) Begin
87431>>>>>>>            Get UtilTableExists hTable to bExists
87432>>>>>>>            If (bExists = False) Begin
87434>>>>>>>                Move True to APIColumnsEmpty[0].bError
87435>>>>>>>                Function_Return APIColumnsEmpty
87436>>>>>>>            End
87436>>>>>>>>
87436>>>>>>>        End
87436>>>>>>>>
87436>>>>>>>
87436>>>>>>>        Move 0 to iCount
87437>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
87440>>>>>>>        Set piMaximum of ghoProgressBar to iNumColumns
87441>>>>>>>
87441>>>>>>>        for iColumn from 1 to iNumColumns
87447>>>>>>>>
87447>>>>>>>            Move 0 to iOptions
87448>>>>>>>            Move False to bIdentityKey
87449>>>>>>>            Move False to Err
87450>>>>>>>            Move 0     to LastErr
87451>>>>>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
87452>>>>>>>            Set piPosition of ghoProgressBar to iColumn
87453>>>>>>>            If (bDawSqlDriver = True) Begin
87455>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
87456>>>>>>>                If (bIsSqlTable = True) Begin
87458>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iType
87461>>>>>>>                    Move iType                                                to APIColumns[iCount].iType
87462>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
87465>>>>>>>                    Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
87468>>>>>>>                    Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue
87471>>>>>>>                End
87471>>>>>>>>
87471>>>>>>>                Else Begin
87472>>>>>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
87475>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
87476>>>>>>>                End
87476>>>>>>>>
87476>>>>>>>
87476>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
87476>>>>>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
87479>>>>>>>                Move (iCheckFieldNumber >= 0) to bExists
87480>>>>>>>                If (bExists = False) Begin
87482>>>>>>>                    Move 0 to APIColumns[iCount].iType
87483>>>>>>>                End
87483>>>>>>>>
87483>>>>>>>                If (bExists = True) Begin
87485>>>>>>>                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
87488>>>>>>>                End
87488>>>>>>>>
87488>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
87489>>>>>>>                If (bIdentityKey = True) Begin
87491>>>>>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
87492>>>>>>>                End
87492>>>>>>>>
87492>>>>>>>            End
87492>>>>>>>>
87492>>>>>>>            Else Begin
87493>>>>>>>                Move False to Err
87494>>>>>>>                Move 0     to LastErr
87495>>>>>>>                If (bIsSqlTable = True) Begin
87497>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
87500>>>>>>>                End
87500>>>>>>>>
87500>>>>>>>                Else Begin
87501>>>>>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
87504>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
87505>>>>>>>                End
87505>>>>>>>>
87505>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
87505>>>>>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
87506>>>>>>>                If (bExists = False) Begin
87508>>>>>>>                    Move 0 to APIColumns[iCount].iType
87509>>>>>>>                End
87509>>>>>>>>
87509>>>>>>>            End
87509>>>>>>>>
87509>>>>>>>
87509>>>>>>>            If (bExists = True) Begin
87511>>>>>>>                Move iColumn to APIColumns[iCount].iFieldNumber
87512>>>>>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
87515>>>>>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
87515>>>>>>>//                If (bIsSqlTable = True) Begin
87515>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
87515>>>>>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
87515>>>>>>>//                End
87515>>>>>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
87518>>>>>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
87521>>>>>>>
87521>>>>>>>                // If the length was zero we might have an Overlap(!) field.
87521>>>>>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
87521>>>>>>>                If (APIColumns[iCount].iLength = 0) Begin
87523>>>>>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
87526>>>>>>>                    If (iType = DF_OVERLAP) Begin
87528>>>>>>>                        Move 0 to APIColumns[iCount].iFieldNumber
87529>>>>>>>                        Move 0 to APIColumns[iCount].iLength
87530>>>>>>>                        Move 0 to APIColumns[iCount].iOptions
87531>>>>>>>                        Move 0 to APIColumns[iCount].iPrecision
87532>>>>>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
87533>>>>>>>                        Move "" to APIColumns[iCount].sFieldName
87534>>>>>>>                        Decrement iCount
87535>>>>>>>                    End
87535>>>>>>>>
87535>>>>>>>                End
87535>>>>>>>>
87535>>>>>>>            End
87535>>>>>>>>
87535>>>>>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
87536>>>>>>>            If (bUserCancel = True) Begin
87538>>>>>>>                Move True to APIColumnsEmpty[0].bCancel
87539>>>>>>>                Function_Return APIColumnsEmpty
87540>>>>>>>            End
87540>>>>>>>>
87540>>>>>>>            Increment iCount
87541>>>>>>>        Loop
87542>>>>>>>>
87542>>>>>>>
87542>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87543>>>>>>>        Function_Return APIColumns
87544>>>>>>>    End_Function
87545>>>>>>>
87545>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
87545>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
87545>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
87545>>>>>>>    // have "holes" in the series of index numbers.
87545>>>>>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
87547>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
87547>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
87548>>>>>>>        tAPIColumnCompare   APIColumnCompare
87548>>>>>>>        tAPIColumnCompare   APIColumnCompare
87548>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
87548>>>>>>>
87548>>>>>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
87549>>>>>>>        Decrement iSizeFrom
87550>>>>>>>        for iCount from 0 to iSizeFrom
87556>>>>>>>>
87556>>>>>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
87557>>>>>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
87558>>>>>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
87559>>>>>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
87560>>>>>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
87561>>>>>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
87562>>>>>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
87563>>>>>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom
87564>>>>>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
87565>>>>>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
87566>>>>>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
87567>>>>>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
87568>>>>>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
87569>>>>>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
87570>>>>>>>        Loop
87571>>>>>>>>
87571>>>>>>>
87571>>>>>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
87572>>>>>>>        Decrement iSizeTo
87573>>>>>>>        for iCount from 0 to iSizeTo
87579>>>>>>>>
87579>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
87580>>>>>>>            // Search if the field number already exists in the array; else add it.
87580>>>>>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
87581>>>>>>>            If (iItem = -1) Begin
87583>>>>>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
87584>>>>>>>            End
87584>>>>>>>>
87584>>>>>>>
87584>>>>>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
87585>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
87586>>>>>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
87587>>>>>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
87588>>>>>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
87589>>>>>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
87590>>>>>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
87591>>>>>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
87592>>>>>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
87593>>>>>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
87594>>>>>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
87595>>>>>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
87596>>>>>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
87597>>>>>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
87598>>>>>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
87599>>>>>>>        Loop
87600>>>>>>>>
87600>>>>>>>
87600>>>>>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
87601>>>>>>>
87601>>>>>>>        Function_Return aAPIColumnCompare
87602>>>>>>>    End_Function
87603>>>>>>>
87603>>>>>>>    // Checks if a field name exists in a table definition
87603>>>>>>>    // Returns True if it does
87603>>>>>>>    // Sample:
87603>>>>>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
87603>>>>>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
87605>>>>>>>        Integer iNumColumns iColumn
87605>>>>>>>        String sColumn
87605>>>>>>>        Boolean bExists bOK bOpen
87605>>>>>>>
87605>>>>>>>        Get AutoConnectionIDLogin to bOK
87606>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
87607>>>>>>>        Open hTable
87609>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
87610>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
87613>>>>>>>        If (bOpen = False) Begin
87615>>>>>>>            Function_Return False
87616>>>>>>>        End
87616>>>>>>>>
87616>>>>>>>
87616>>>>>>>        Move False to bExists
87617>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
87620>>>>>>>        for iColumn from 1 to iNumColumns
87626>>>>>>>>
87626>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
87629>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
87631>>>>>>>                Move iNumColumns to iColumn
87632>>>>>>>                Move True to bExists
87633>>>>>>>            End
87633>>>>>>>>
87633>>>>>>>        Loop
87634>>>>>>>>
87634>>>>>>>        Close hTable
87635>>>>>>>
87635>>>>>>>        Function_Return bExists
87636>>>>>>>    End_Function
87637>>>>>>>
87637>>>>>>>    // Returns the field/column number for the passed FieldName as an integer.
87637>>>>>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
87639>>>>>>>        Integer iNumColumns iColumn iRetval
87639>>>>>>>        String sColumn
87639>>>>>>>        Boolean bOK bOpen
87639>>>>>>>
87639>>>>>>>        Get AutoConnectionIDLogin to bOK
87640>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87641>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
87642>>>>>>>        Open hTable
87644>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
87645>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
87648>>>>>>>        If (bOpen = False) Begin
87650>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
87651>>>>>>>            Function_Return False
87652>>>>>>>        End
87652>>>>>>>>
87652>>>>>>>
87652>>>>>>>        Move 0 to iColumn
87653>>>>>>>        Move 0 to iRetval
87654>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
87657>>>>>>>        for iColumn from 1 to iNumColumns
87663>>>>>>>>
87663>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
87666>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
87668>>>>>>>                Move iColumn to iRetval
87669>>>>>>>                Move iNumColumns to iColumn
87670>>>>>>>            End
87670>>>>>>>>
87670>>>>>>>        Loop
87671>>>>>>>>
87671>>>>>>>        Close hTable
87672>>>>>>>
87672>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87673>>>>>>>        Function_Return iRetval
87674>>>>>>>    End_Function
87675>>>>>>>
87675>>>>>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
87675>>>>>>>    // The reciprocal function is UtilColumnTypeToInteger.
87675>>>>>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
87677>>>>>>>        tColumnType RetvalType
87677>>>>>>>        tColumnType RetvalType
87677>>>>>>>
87677>>>>>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
87678>>>>>>>        Function_Return RetvalType.iSQLType
87679>>>>>>>    End_Function
87680>>>>>>>
87680>>>>>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
87680>>>>>>>    // The reciprocal function is UtilColumnTypeToString.
87680>>>>>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
87682>>>>>>>        tColumnType RetvalType
87682>>>>>>>        tColumnType RetvalType
87682>>>>>>>
87682>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
87683>>>>>>>        Function_Return RetvalType.sSQLType
87684>>>>>>>    End_Function
87685>>>>>>>
87685>>>>>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
87687>>>>>>>        tColumnType RetvalType
87687>>>>>>>        tColumnType RetvalType
87687>>>>>>>
87687>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
87688>>>>>>>        Function_Return RetvalType.sPrecision
87689>>>>>>>    End_Function
87690>>>>>>>
87690>>>>>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
87692>>>>>>>        tColumnType RetvalType
87692>>>>>>>        tColumnType RetvalType
87692>>>>>>>
87692>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
87693>>>>>>>        // Nils 2019-02-15. This return value seems to have been wrong. The function should return False
87693>>>>>>>        // if the column type length is _not_ fixed.
87693>>>>>>>        Function_Return (RetvalType.bCanEditSize = False)
87694>>>>>>>    End_Function
87695>>>>>>>
87695>>>>>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
87697>>>>>>>        tColumnType RetvalType
87697>>>>>>>        tColumnType RetvalType
87697>>>>>>>        String sValue
87697>>>>>>>        Integer iRetval iPos
87697>>>>>>>
87697>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
87698>>>>>>>        Move RetvalType.sPrecision to sValue
87699>>>>>>>        Move (Pos(".", sValue)) to iPos
87700>>>>>>>        If (iPos <> 0) Begin
87702>>>>>>>            Move (Left(sValue, (iPos -1))) to iRetval
87703>>>>>>>        End
87703>>>>>>>>
87703>>>>>>>        Else Begin
87704>>>>>>>            Move sValue to iRetval
87705>>>>>>>        End
87705>>>>>>>>
87705>>>>>>>        Function_Return iRetval
87706>>>>>>>    End_Function
87707>>>>>>>
87707>>>>>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
87709>>>>>>>        tColumnType RetvalType
87709>>>>>>>        tColumnType RetvalType
87709>>>>>>>        String sValue
87709>>>>>>>        Integer iRetval iPos
87709>>>>>>>
87709>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
87710>>>>>>>        Move RetvalType.sPrecision to sValue
87711>>>>>>>        Move (Pos(".", sValue)) to iPos
87712>>>>>>>        If (iPos = 0) Begin
87714>>>>>>>            Function_Return 0
87715>>>>>>>        End
87715>>>>>>>>
87715>>>>>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
87716>>>>>>>
87716>>>>>>>        Function_Return iRetval
87717>>>>>>>    End_Function
87718>>>>>>>
87718>>>>>>>    // * Dummy function for the Studio's Code Explorer *
87718>>>>>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
87720>>>>>>>        Function_Return False
87721>>>>>>>    End_Function
87722>>>>>>>
87722>>>>>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
87722>>>>>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
87724>>>>>>>        Boolean bIsSame
87724>>>>>>>        Integer iCount iSize
87724>>>>>>>
87724>>>>>>>        Move True to bIsSame
87725>>>>>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
87726>>>>>>>        Decrement iSize
87727>>>>>>>        For iCount from 0 to iSize
87733>>>>>>>>
87733>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87734>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
87735>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
87736>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
87737>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
87738>>>>>>>            If (bIsSame = False) Begin
87740>>>>>>>                Function_Return False
87741>>>>>>>            End
87741>>>>>>>>
87741>>>>>>>        Loop
87742>>>>>>>>
87742>>>>>>>
87742>>>>>>>        Function_Return bIsSame
87743>>>>>>>    End_Function
87744>>>>>>>
87744>>>>>>>    // Compares a single index for a 'FROM' and a 'TO' table.
87744>>>>>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
87746>>>>>>>        Boolean bIsSame
87746>>>>>>>        Integer iSegment
87746>>>>>>>
87746>>>>>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
87747>>>>>>>        If (bIsSame = False) Begin
87749>>>>>>>            Function_Return False
87750>>>>>>>        End
87750>>>>>>>>
87750>>>>>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
87751>>>>>>>        If (bIsSame = False) Begin
87753>>>>>>>            Function_Return False
87754>>>>>>>        End
87754>>>>>>>>
87754>>>>>>>
87754>>>>>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
87756>>>>>>>            // * We should probably not compare SQL index names?
87756>>>>>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
87756>>>>>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
87756>>>>>>>            //     Function_Return False
87756>>>>>>>            // End
87756>>>>>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
87757>>>>>>>            If (bIsSame = False) Begin
87759>>>>>>>                Function_Return False
87760>>>>>>>            End
87760>>>>>>>>
87760>>>>>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
87761>>>>>>>            If (bIsSame = False) Begin
87763>>>>>>>                Function_Return False
87764>>>>>>>            End
87764>>>>>>>>
87764>>>>>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
87765>>>>>>>            If (bIsSame = False) Begin
87767>>>>>>>                Function_Return False
87768>>>>>>>            End
87768>>>>>>>>
87768>>>>>>>            Move (Uppercase(APIIndexCompare.sSQLIndexNameFrom) = Uppercase(APIIndexCompare.sSQLIndexNameTo)) to bIsSame
87769>>>>>>>            If (bIsSame = False) Begin
87771>>>>>>>                Function_Return False
87772>>>>>>>            End
87772>>>>>>>>
87772>>>>>>>        End
87772>>>>>>>>
87772>>>>>>>
87772>>>>>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
87773>>>>>>>        Move (iSegment = -1) to bIsSame
87774>>>>>>>
87774>>>>>>>        Function_Return (bIsSame = True)
87775>>>>>>>    End_Function
87776>>>>>>>
87776>>>>>>>    // Compares each segment for the passed index.
87776>>>>>>>    // Returns -1 if same; else returns the index segment that differs.
87776>>>>>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
87778>>>>>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
87778>>>>>>>        Boolean bIsSame
87778>>>>>>>
87778>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
87779>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87780>>>>>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
87781>>>>>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
87782>>>>>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
87783>>>>>>>
87783>>>>>>>        Decrement iNumSegments
87784>>>>>>>        for iSegment from 0 to iNumSegments
87790>>>>>>>>
87790>>>>>>>            Move False to bIsSame
87791>>>>>>>            If (iSegment < iNumSegmentsFrom and iSegment < iNumSegmentsTo) Begin
87793>>>>>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
87794>>>>>>>            End
87794>>>>>>>>
87794>>>>>>>            If (bIsSame = False) Begin
87796>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
87797>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
87798>>>>>>>                Function_Return iSegment
87799>>>>>>>            End
87799>>>>>>>>
87799>>>>>>>        Loop
87800>>>>>>>>
87800>>>>>>>
87800>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87801>>>>>>>        Function_Return -1 // This means bIsSame = True
87802>>>>>>>    End_Function
87803>>>>>>>
87803>>>>>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
87805>>>>>>>        Boolean bIsSame
87805>>>>>>>
87805>>>>>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
87806>>>>>>>        If (bIsSame = False) Begin
87808>>>>>>>            Function_Return False
87809>>>>>>>        End
87809>>>>>>>>
87809>>>>>>>        If (bCompareIndexUppercase = True) Begin
87811>>>>>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
87812>>>>>>>            If (bIsSame = False) Begin
87814>>>>>>>                Function_Return False
87815>>>>>>>            End
87815>>>>>>>>
87815>>>>>>>        End
87815>>>>>>>>
87815>>>>>>>        If (bCompareIndexAscending = True) Begin
87817>>>>>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
87818>>>>>>>            If (bIsSame = False) Begin
87820>>>>>>>                Function_Return False
87821>>>>>>>            End
87821>>>>>>>>
87821>>>>>>>        End
87821>>>>>>>>
87821>>>>>>>
87821>>>>>>>        Function_Return True
87822>>>>>>>    End_Function
87823>>>>>>>
87823>>>>>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
87825>>>>>>>        Boolean bIsSame bOK
87825>>>>>>>        Integer iSize iSizeTo iCount
87825>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
87825>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
87826>>>>>>>
87826>>>>>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
87827>>>>>>>        If (iSize = 0) Begin
87829>>>>>>>            Function_Return True
87830>>>>>>>        End
87830>>>>>>>>
87830>>>>>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo
87831>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTableTo
87832>>>>>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
87833>>>>>>>
87833>>>>>>>        for iCount from 0 to (iSize - 1)
87839>>>>>>>>
87839>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
87840>>>>>>>            If (bIsSame = False) Begin
87842>>>>>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
87843>>>>>>>            End
87843>>>>>>>>
87843>>>>>>>        Loop
87844>>>>>>>>
87844>>>>>>>
87844>>>>>>>        // We probably should delete other indexes if they exists.
87844>>>>>>>        for iCount from (iSize +1) to iSizeTo
87850>>>>>>>>
87850>>>>>>>            Get ApiIndexRemove hTable iCount to bOK
87851>>>>>>>        Loop
87852>>>>>>>>
87852>>>>>>>
87852>>>>>>>        Function_Return bOK
87853>>>>>>>    End_Function
87854>>>>>>>
87854>>>>>>>//    Function UtilIsSameColumnDefinitions Handle hTable tAPIColumn[] aColumns Returns Boolean
87854>>>>>>>//        Boolean bEqual bIdentityKey bSqlDriver bDawSqlDriver bIsOpen
87854>>>>>>>//        Integer iCount iColumn iSize iOptions iLength iPrecision iType
87854>>>>>>>//        String sFieldName sDriverID
87854>>>>>>>//
87854>>>>>>>//        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87854>>>>>>>//        If (bIsOpen = False) Begin
87854>>>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
87854>>>>>>>//            Open hTable
87854>>>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
87854>>>>>>>//            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87854>>>>>>>//            If (bIsOpen = False) Begin
87854>>>>>>>//                Function_Return False
87854>>>>>>>//            End
87854>>>>>>>//        End
87854>>>>>>>//
87854>>>>>>>//        Move True to bEqual
87854>>>>>>>//        Get psDriverID to sDriverID
87854>>>>>>>//        Get IsSQLDriver    sDriverID to bSqlDriver
87854>>>>>>>//        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
87854>>>>>>>//        Move (SizeOfArray(aColumns)) to iSize
87854>>>>>>>//        Decrement iSize
87854>>>>>>>//
87854>>>>>>>//        For iCount from 0 to iSize
87854>>>>>>>//            Move 0 to iOptions
87854>>>>>>>//            Move False to bIdentityKey
87854>>>>>>>//            Move aColumns[iCount].sFieldName to sFieldName
87854>>>>>>>//
87854>>>>>>>//            // We need to use the column name - not the column integer as
87854>>>>>>>//            // the order does not need to be the same, and the logic should still work.
87854>>>>>>>//            Get UtilColumnNameToColumnNumber hTable sFieldName to iColumn
87854>>>>>>>//            If (iColumn > 0) Begin
87854>>>>>>>//                If (bDawSqlDriver = True) Begin
87854>>>>>>>//                    Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
87854>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iType
87854>>>>>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
87854>>>>>>>//                        Move False to bEqual
87854>>>>>>>//                    End
87854>>>>>>>//                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
87854>>>>>>>//                    If (bIdentityKey = True) Begin
87854>>>>>>>//                        Move C_tAPIColumn_Identity to iOptions
87854>>>>>>>//                    End
87854>>>>>>>//                    If (iOptions <> aColumns[iCount].iOptions) Begin
87854>>>>>>>//                        Move False to bEqual
87854>>>>>>>//                    End
87854>>>>>>>//                    Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
87854>>>>>>>//                End
87854>>>>>>>//                Else Begin
87854>>>>>>>//                    Get_Attribute DF_FIELD_TYPE     of hTable iColumn to iType
87854>>>>>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
87854>>>>>>>//                        Move False to bEqual
87854>>>>>>>//                    End
87854>>>>>>>//                End
87854>>>>>>>//                Get_Attribute DF_FIELD_LENGTH       of hTable iColumn to iLength
87854>>>>>>>//                If (iLength <> aColumns[iCount].iLength) Begin
87854>>>>>>>//                    Move False to bEqual
87854>>>>>>>//                End
87854>>>>>>>//                Get_Attribute DF_FIELD_PRECISION    of hTable iColumn to iPrecision
87854>>>>>>>//                If (iPrecision <> aColumns[iCount].iPrecision) Begin
87854>>>>>>>//                    Move False to bEqual
87854>>>>>>>//                End
87854>>>>>>>//                If (bEqual = False) Begin
87854>>>>>>>//                    Function_Return False
87854>>>>>>>//                End
87854>>>>>>>//            End
87854>>>>>>>//
87854>>>>>>>//            Else Begin
87854>>>>>>>//                Function_Return False
87854>>>>>>>//            End
87854>>>>>>>//        Loop
87854>>>>>>>//
87854>>>>>>>//        Function_Return bEqual
87854>>>>>>>//    End_Function
87854>>>>>>>
87854>>>>>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
87856>>>>>>>        tAPIIndex[] APIIndexes
87856>>>>>>>        tAPIIndex[] APIIndexes
87857>>>>>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
87857>>>>>>>        String sDriverID
87857>>>>>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable
87857>>>>>>>
87857>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87858>>>>>>>        Get psDriverID to sDriverID
87859>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
87860>>>>>>>        Get UtilTableIsSQL hTable to bIsSQLTable
87861>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87864>>>>>>>        If (bIsOpen = False) Begin
87866>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
87867>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87868>>>>>>>            Open hTable
87870>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
87871>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
87872>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87875>>>>>>>            If (bIsOpen = False) Begin
87877>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
87878>>>>>>>                Move True to APIIndexes[0].bError
87879>>>>>>>                Function_Return APIIndexes
87880>>>>>>>            End
87880>>>>>>>>
87880>>>>>>>        End
87880>>>>>>>>
87880>>>>>>>
87880>>>>>>>        Move 0 to iCount
87881>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
87884>>>>>>>        for iIndex from 1 to iIndexes
87890>>>>>>>>
87890>>>>>>>            // This is a test that the index exists as there might be "holes" aka the index
87890>>>>>>>            // numbers doesn't not need to be consequitive:
87890>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
87893>>>>>>>            If (iNumSegments > 0) Begin
87895>>>>>>>
87895>>>>>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
87896>>>>>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
87899>>>>>>>                If (bIsSQLTable = True) Begin
87901>>>>>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
87904>>>>>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
87907>>>>>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
87910>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
87913>>>>>>>                End
87913>>>>>>>>
87913>>>>>>>
87913>>>>>>>                Move 0 to iSegmentCount
87914>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
87917>>>>>>>                For iSegment from 1 to iNumSegments
87923>>>>>>>>
87923>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
87926>>>>>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
87927>>>>>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
87930>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
87933>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
87936>>>>>>>                    Increment iSegmentCount
87937>>>>>>>                Loop
87938>>>>>>>>
87938>>>>>>>                Increment iCount
87939>>>>>>>            End
87939>>>>>>>>
87939>>>>>>>        Loop
87940>>>>>>>>
87940>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87941>>>>>>>
87941>>>>>>>        Function_Return APIIndexes
87942>>>>>>>    End_Function
87943>>>>>>>
87943>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
87943>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
87943>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
87943>>>>>>>    // have "holes" in the series of index numbers.
87943>>>>>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
87945>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
87945>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
87946>>>>>>>        tAPIIndexCompare   APIIndexCompare
87946>>>>>>>        tAPIIndexCompare   APIIndexCompare
87946>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
87946>>>>>>>
87946>>>>>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
87947>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
87948>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
87950>>>>>>>            Function_Return aAPIIndexCompare
87951>>>>>>>        End
87951>>>>>>>>
87951>>>>>>>
87951>>>>>>>        Decrement iSizeFrom
87952>>>>>>>        for iCount from 0 to iSizeFrom
87958>>>>>>>>
87958>>>>>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
87959>>>>>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
87960>>>>>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
87961>>>>>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
87962>>>>>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
87963>>>>>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
87964>>>>>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
87965>>>>>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
87966>>>>>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
87967>>>>>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
87968>>>>>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
87969>>>>>>>        Loop
87970>>>>>>>>
87970>>>>>>>
87970>>>>>>>        Decrement iSizeTo
87971>>>>>>>        for iCount from 0 to iSizeTo
87977>>>>>>>>
87977>>>>>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
87978>>>>>>>            // Search if the Index number already exists in the array; else add it.
87978>>>>>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
87979>>>>>>>            If (iItem = -1) Begin
87981>>>>>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
87982>>>>>>>            End
87982>>>>>>>>
87982>>>>>>>
87982>>>>>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
87983>>>>>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
87984>>>>>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
87985>>>>>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
87986>>>>>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
87987>>>>>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
87988>>>>>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
87989>>>>>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
87990>>>>>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
87991>>>>>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
87992>>>>>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
87993>>>>>>>        Loop
87994>>>>>>>>
87994>>>>>>>
87994>>>>>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
87995>>>>>>>
87995>>>>>>>        Function_Return aAPIIndexCompare
87996>>>>>>>    End_Function
87997>>>>>>>
87997>>>>>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
87997>>>>>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
87999>>>>>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
87999>>>>>>>        String sDriverID
87999>>>>>>>
87999>>>>>>>        Get psDriverID to sDriverID
88000>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
88001>>>>>>>        Get IsSQLDriver sDriverID to bIsSqlTable
88002>>>>>>>        If (bIsSqlTable = True) Begin
88004>>>>>>>            Get UtilTableIsSQL hTable to bIsSqlTable
88005>>>>>>>        End
88005>>>>>>>>
88005>>>>>>>
88005>>>>>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
88006>>>>>>>        If (bIsSame = False) Begin
88008>>>>>>>            Function_Return False
88009>>>>>>>        End
88009>>>>>>>>
88009>>>>>>>
88009>>>>>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
88011>>>>>>>            // Don't think we should do this. Or should we?
88011>>>>>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
88011>>>>>>>
88011>>>>>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
88012>>>>>>>            If (bIsSame = False) Begin
88014>>>>>>>                Function_Return False
88015>>>>>>>            End
88015>>>>>>>>
88015>>>>>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
88016>>>>>>>            If (bIsSame = False) Begin
88018>>>>>>>                Function_Return False
88019>>>>>>>            End
88019>>>>>>>>
88019>>>>>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
88020>>>>>>>            If (bIsSame = False) Begin
88022>>>>>>>                Function_Return False
88023>>>>>>>            End
88023>>>>>>>>
88023>>>>>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
88024>>>>>>>            If (bIsSame = False) Begin
88026>>>>>>>                Function_Return False
88027>>>>>>>            End
88027>>>>>>>>
88027>>>>>>>        End
88027>>>>>>>>
88027>>>>>>>
88027>>>>>>>        Function_Return bIsSame
88028>>>>>>>    End_Function
88029>>>>>>>
88029>>>>>>>    // DF_INDEX_SQL_TYPE values
88029>>>>>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
88029>>>>>>>    // returns a string with the name.
88029>>>>>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
88031>>>>>>>        String sRetval
88031>>>>>>>        Case Begin
88031>>>>>>>            Case (iIndexType = DF_INDEX_CLIENT)
88033>>>>>>>                Move "DF_INDEX_CLIENT" to sRetval
88034>>>>>>>                Case Break
88035>>>>>>>            Case (iIndexType = DF_INDEX_SERVER)
88038>>>>>>>                Move "DF_INDEX_SERVER" to sRetval
88039>>>>>>>                Case Break
88040>>>>>>>            Case (iIndexType = DF_INDEX_SERVER_ONLY)
88043>>>>>>>                Move "DF_INDEX_SERVER_ONLY" to sRetval
88044>>>>>>>                Case Break
88045>>>>>>>            Case (iIndexType = DF_INDEX_TEMPORARY)
88048>>>>>>>                Move "DF_INDEX_TEMPORARY" to sRetval
88049>>>>>>>                Case Break
88050>>>>>>>            Case Else
88050>>>>>>>                Move "UNKNOWN INDEX TYPE" to sRetval
88051>>>>>>>        Case End
88051>>>>>>>        Function_Return sRetval
88052>>>>>>>    End_Function
88053>>>>>>>
88053>>>>>>>    // * Dummy function for the Studio's Code Explorer *
88053>>>>>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
88055>>>>>>>        Function_Return False
88056>>>>>>>    End_Function
88057>>>>>>>
88057>>>>>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
88057>>>>>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
88059>>>>>>>        Boolean bIsSame
88059>>>>>>>        Integer iSize iCount
88059>>>>>>>
88059>>>>>>>        Move True to bIsSame
88060>>>>>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
88061>>>>>>>        Decrement iSize
88062>>>>>>>        For iCount from 0 to iSize
88068>>>>>>>>
88068>>>>>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
88069>>>>>>>            If (bIsSame = False) Begin
88071>>>>>>>                Function_Return False
88072>>>>>>>            End
88072>>>>>>>>
88072>>>>>>>        Loop
88073>>>>>>>>
88073>>>>>>>
88073>>>>>>>        Function_Return bIsSame
88074>>>>>>>    End_Function
88075>>>>>>>
88075>>>>>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
88075>>>>>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
88077>>>>>>>        Boolean bIsSame
88077>>>>>>>
88077>>>>>>>        Move True to bIsSame
88078>>>>>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
88080>>>>>>>            Function_Return False
88081>>>>>>>        End
88081>>>>>>>>
88081>>>>>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
88083>>>>>>>            Function_Return False
88084>>>>>>>        End
88084>>>>>>>>
88084>>>>>>>
88084>>>>>>>        // We could also compare field names, but I don't think that is necessary...
88084>>>>>>>
88084>>>>>>>        Function_Return bIsSame
88085>>>>>>>    End_Function
88086>>>>>>>
88086>>>>>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
88086>>>>>>>    // already exists.
88086>>>>>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
88088>>>>>>>        Boolean bOK
88088>>>>>>>        Integer iSizeTo iSize iCount iColumn
88088>>>>>>>        String sDriverID
88088>>>>>>>
88088>>>>>>>        Move True to bOK
88089>>>>>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
88090>>>>>>>        If (iSizeTo > 0) Begin
88092>>>>>>>            Get AutoConnectionIDLogin to bOK
88093>>>>>>>            Move False to Err
88094>>>>>>>            Open hTable Mode DF_EXCLUSIVE
88096>>>>>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88099>>>>>>>            Decrement iSizeTo
88100>>>>>>>
88100>>>>>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
88100>>>>>>>            // for the "TO" database. But start by deleting all current "TO" relations:
88100>>>>>>>            Structure_Start hTable sDriverID
88101>>>>>>>                for iCount from 0 to iSizeTo
88107>>>>>>>>
88107>>>>>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
88108>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
88111>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
88114>>>>>>>                Loop
88115>>>>>>>>
88115>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88116>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88118>>>>>>>            Set Action_Text of ghoStatusPanel to ""
88119>>>>>>>        End
88119>>>>>>>>
88119>>>>>>>
88119>>>>>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
88120>>>>>>>        Decrement iSize
88121>>>>>>>        for iCount from 0 to iSize
88127>>>>>>>>
88127>>>>>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
88128>>>>>>>        Loop
88129>>>>>>>>
88129>>>>>>>
88129>>>>>>>        Function_Return bOK
88130>>>>>>>    End_Function
88131>>>>>>>
88131>>>>>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
88133>>>>>>>        tAPIRelation[] APIRelations
88133>>>>>>>        tAPIRelation[] APIRelations
88134>>>>>>>        Integer iColumn iColumnTo iNumColumns iCount
88134>>>>>>>        Handle hParent
88134>>>>>>>        Boolean bIsOpen
88134>>>>>>>
88134>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88135>>>>>>>        Move 0 to iCount
88136>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88139>>>>>>>        If (bIsOpen = False) Begin
88141>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
88142>>>>>>>            Open hTable
88144>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
88145>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88148>>>>>>>            If (bIsOpen = False) Begin
88150>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
88151>>>>>>>                Move True to APIRelations[0].bError
88152>>>>>>>                Function_Return APIRelations
88153>>>>>>>            End
88153>>>>>>>>
88153>>>>>>>        End
88153>>>>>>>>
88153>>>>>>>
88153>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
88156>>>>>>>        For iColumn from 1 to iNumColumns
88162>>>>>>>>
88162>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
88165>>>>>>>            If (hParent <> 0) Begin
88167>>>>>>>                Open hParent
88169>>>>>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
88170>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
88173>>>>>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
88174>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
88177>>>>>>>
88177>>>>>>>                Move hParent                                            to APIRelations[iCount].hTableTo
88178>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
88181>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
88184>>>>>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
88185>>>>>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
88188>>>>>>>                Move False                                              to APIRelations[iCount].bShouldChange
88189>>>>>>>                Move False                                              to APIRelations[iCount].bCancel
88190>>>>>>>                Move False                                              to APIRelations[iCount].bError
88191>>>>>>>                Close hParent
88192>>>>>>>                Increment iCount
88193>>>>>>>            End
88193>>>>>>>>
88193>>>>>>>        Loop
88194>>>>>>>>
88194>>>>>>>
88194>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88195>>>>>>>        Function_Return APIRelations
88196>>>>>>>    End_Function
88197>>>>>>>
88197>>>>>>>    Function UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
88199>>>>>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
88201>>>>>>>            Function_Return (EQ)
88202>>>>>>>        End
88202>>>>>>>>
88202>>>>>>>
88202>>>>>>>        Function_Return (GT)
88203>>>>>>>    End_Function
88204>>>>>>>
88204>>>>>>>    Function SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
88206>>>>>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
88209>>>>>>>
88209>>>>>>>        Function_Return (GT)
88210>>>>>>>    End_Function
88211>>>>>>>
88211>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
88211>>>>>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
88211>>>>>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
88213>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
88213>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
88214>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
88214>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
88215>>>>>>>        tAPIRelationCompare   APIRelationCompare
88215>>>>>>>        tAPIRelationCompare   APIRelationCompare
88215>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
88215>>>>>>>
88215>>>>>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
88216>>>>>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
88217>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
88219>>>>>>>            Function_Return aAPIRelationCompare
88220>>>>>>>        End
88220>>>>>>>>
88220>>>>>>>
88220>>>>>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
88221>>>>>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(UtilRelationArrayCompare))) to aAPIRelationFromAndTo
88222>>>>>>>
88222>>>>>>>        Decrement iSizeFrom
88223>>>>>>>        for iCount from 0 to iSizeFrom
88229>>>>>>>>
88229>>>>>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
88230>>>>>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
88231>>>>>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
88232>>>>>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
88233>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
88234>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
88235>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
88236>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
88237>>>>>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
88238>>>>>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
88239>>>>>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
88240>>>>>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
88241>>>>>>>        Loop
88242>>>>>>>>
88242>>>>>>>
88242>>>>>>>        Decrement iSizeTo
88243>>>>>>>        for iCount from 0 to iSizeTo
88249>>>>>>>>
88249>>>>>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
88250>>>>>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
88251>>>>>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
88252>>>>>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
88253>>>>>>>
88253>>>>>>>            // Search if the relation already exists in the array; else add it.
88253>>>>>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to iItem
88254>>>>>>>            If (iItem = -1) Begin
88256>>>>>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
88257>>>>>>>            End
88257>>>>>>>>
88257>>>>>>>
88257>>>>>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
88258>>>>>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
88259>>>>>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
88260>>>>>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
88261>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
88262>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
88263>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
88264>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
88265>>>>>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
88266>>>>>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
88267>>>>>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
88268>>>>>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
88269>>>>>>>        Loop
88270>>>>>>>>
88270>>>>>>>
88270>>>>>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to aAPIRelationCompare
88271>>>>>>>
88271>>>>>>>        Function_Return aAPIRelationCompare
88272>>>>>>>    End_Function
88273>>>>>>>
88273>>>>>>>    // * Dummy function for the Studio's Code Explorer *
88273>>>>>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
88275>>>>>>>        Function_Return False
88276>>>>>>>    End_Function
88277>>>>>>>
88277>>>>>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
88277>>>>>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
88277>>>>>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
88277>>>>>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
88279>>>>>>>        Boolean bFound
88279>>>>>>>
88279>>>>>>>        Move False to Err
88280>>>>>>>        Open CodeMast
88282>>>>>>>        Open CodeType
88284>>>>>>>
88284>>>>>>>        If (bCodeType = True) Begin
88286>>>>>>>            Set Private.phCurrentTable to CODETYPE.File_Number
88287>>>>>>>            Clear CodeType
88288>>>>>>>            Move sTypeValue to CODETYPE.Type
88289>>>>>>>            Find eq CODETYPE by 1
88290>>>>>>>>
88290>>>>>>>            Move Found to bFound
88291>>>>>>>            If (bFound = True) Begin
88293>>>>>>>                Reread CodeType
88297>>>>>>>            End
88297>>>>>>>>
88297>>>>>>>            Else Begin
88298>>>>>>>                Clear CodeType
88299>>>>>>>            End
88299>>>>>>>>
88299>>>>>>>
88299>>>>>>>            Move sTypeValue to CODETYPE.Type
88300>>>>>>>            Move sValue2    to CODETYPE.Description
88301>>>>>>>            Move sValue3    to CODETYPE.Comment
88302>>>>>>>            SaveRecord CODETYPE
88303>>>>>>>
88303>>>>>>>            If (bFound = True) Begin
88305>>>>>>>                Unlock
88306>>>>>>>>
88306>>>>>>>            End
88306>>>>>>>>
88306>>>>>>>        End
88306>>>>>>>>
88306>>>>>>>
88306>>>>>>>        If (bCodeType = False) Begin
88308>>>>>>>            Set Private.phCurrentTable to CODEMAST.File_Number
88309>>>>>>>            Clear CODEMAST
88310>>>>>>>            Move sTypeValue to CODEMAST.Type
88311>>>>>>>            Move sValue2    to CODEMAST.Code
88312>>>>>>>            Find eq CODEMAST by 1
88313>>>>>>>>
88313>>>>>>>            Move Found to bFound
88314>>>>>>>            If (bFound = True) Begin
88316>>>>>>>                Reread CODEMAST
88320>>>>>>>            End
88320>>>>>>>>
88320>>>>>>>            Else Begin
88321>>>>>>>                Clear CODEMAST
88322>>>>>>>            End
88322>>>>>>>>
88322>>>>>>>
88322>>>>>>>            Move sTypeValue to CODEMAST.Type
88323>>>>>>>            Move sValue2    to CODEMAST.Code
88324>>>>>>>            Move sValue3    to CODEMAST.Description
88325>>>>>>>            SaveRecord CODEMAST
88326>>>>>>>
88326>>>>>>>            If (bFound = True) Begin
88328>>>>>>>                Unlock
88329>>>>>>>>
88329>>>>>>>            End
88329>>>>>>>>
88329>>>>>>>        End
88329>>>>>>>>
88329>>>>>>>
88329>>>>>>>        Close CodeMast
88330>>>>>>>        Close CodeType
88331>>>>>>>
88331>>>>>>>        Function_Return (Err = False)
88332>>>>>>>    End_Function
88333>>>>>>>
88333>>>>>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
88333>>>>>>>    // CodeType and then spins through all CodeMast records to change all related records.
88333>>>>>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
88335>>>>>>>        Boolean bFound
88335>>>>>>>
88335>>>>>>>        Move False to Err
88336>>>>>>>        Open CodeMast
88338>>>>>>>        Open CodeType
88340>>>>>>>
88340>>>>>>>        Clear CodeType
88341>>>>>>>        Move sFromValue to CODETYPE.Type
88342>>>>>>>        Find eq CODETYPE.Type
88343>>>>>>>>
88343>>>>>>>        If (Found = True) Begin
88345>>>>>>>            Reread CODETYPE
88349>>>>>>>                Move sToValue to CODETYPE.Type
88350>>>>>>>                SaveRecord CODETYPE
88351>>>>>>>            Unlock
88352>>>>>>>>
88352>>>>>>>        End
88352>>>>>>>>
88352>>>>>>>
88352>>>>>>>        Clear CODEMAST
88353>>>>>>>        Find gt CODEMAST by Recnum
88354>>>>>>>>
88354>>>>>>>        While (Found = True)
88358>>>>>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
88359>>>>>>>            If (bFound = True) Begin
88361>>>>>>>                Reread CODEMAST
88365>>>>>>>                    Move sToValue to CODEMAST.Type
88366>>>>>>>                    SaveRecord CODEMAST
88367>>>>>>>                Unlock
88368>>>>>>>>
88368>>>>>>>            End
88368>>>>>>>>
88368>>>>>>>            Find gt CODEMAST by Recnum
88369>>>>>>>>
88369>>>>>>>        Loop
88370>>>>>>>>
88370>>>>>>>
88370>>>>>>>        Close CodeMast
88371>>>>>>>        Close CodeType
88372>>>>>>>
88372>>>>>>>        Function_Return (Err = False)
88373>>>>>>>    End_Function
88374>>>>>>>
88374>>>>>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
88374>>>>>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
88376>>>>>>>        Boolean bFound
88376>>>>>>>
88376>>>>>>>        Move False to Err
88377>>>>>>>        Open CodeMast
88379>>>>>>>
88379>>>>>>>        Clear CODEMAST
88380>>>>>>>        Move sTypeValue to CODEMAST.Type
88381>>>>>>>        Move sValue2    to CODEMAST.Code
88382>>>>>>>        Find eq CODEMAST.Code
88383>>>>>>>>
88383>>>>>>>        Move Found to bFound
88384>>>>>>>        If (bFound = True) Begin
88386>>>>>>>            Delete CODEMAST
88387>>>>>>>        End
88387>>>>>>>>
88387>>>>>>>
88387>>>>>>>        Close CodeMast
88388>>>>>>>
88388>>>>>>>        Function_Return (Err = False)
88389>>>>>>>    End_Function
88390>>>>>>>
88390>>>>>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
88392>>>>>>>        Boolean bRecnum bToAnsi
88392>>>>>>>        Integer iCh
88392>>>>>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
88392>>>>>>>
88392>>>>>>>        If (Trim(sDataPath) = "") Begin
88394>>>>>>>            Function_Return False
88395>>>>>>>        End
88395>>>>>>>>
88395>>>>>>>
88395>>>>>>>        Move False to Err
88396>>>>>>>        Get psDriverID     to sDriverID
88397>>>>>>>        Get psConnectionID to sConnectionID
88398>>>>>>>        Get psSchema       to sSchemaName
88399>>>>>>>        Get True           to bRecnum
88400>>>>>>>        Get pbToANSI       to bToAnsi
88401>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
88402>>>>>>>        If (bToAnsi = False) Begin
88404>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
88405>>>>>>>        End
88405>>>>>>>>
88405>>>>>>>
88405>>>>>>>        Get vFolderFormat sDataPath to sDataPath
88406>>>>>>>        Move "CodeMast.int"         to sFileName
88407>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
88408>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
88411>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
88414>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
88417>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
88420>>>>>>>            Writeln channel iCh ("")
88423>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
88426>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
88429>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
88432>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
88435>>>>>>>            Writeln channel iCh ("")
88438>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
88441>>>>>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
88444>>>>>>>            Writeln channel iCh ("")
88447>>>>>>>        Send Seq_Close_Channel iCh
88448>>>>>>>
88448>>>>>>>        Get vFolderFormat sDataPath to sDataPath
88449>>>>>>>        Move "CodeType.int"         to sFileName
88450>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
88451>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
88454>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
88457>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
88460>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
88463>>>>>>>            Writeln channel iCh ("")
88466>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
88469>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
88472>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
88475>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
88478>>>>>>>            Writeln channel iCh ("")
88481>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 0")
88484>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
88487>>>>>>>            Writeln channel iCh ("")
88490>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
88493>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
88496>>>>>>>            Writeln channel iCh ("")
88499>>>>>>>        Send Seq_Close_Channel iCh
88500>>>>>>>
88500>>>>>>>        Function_Return (Err = False)
88501>>>>>>>    End_Function
88502>>>>>>>
88502>>>>>>>    // * Dummy function for the Studio's Code Explorer *
88502>>>>>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
88504>>>>>>>        Function_Return False
88505>>>>>>>    End_Function
88506>>>>>>>
88506>>>>>>>    // Use function to move *.fd, termlist.*, collate.*, dfcollate.* files to a "Data\Backup" folder,
88506>>>>>>>    // and to remove all *.cch files (DAW SQL driver cache files. They will get recreated when needed.)
88506>>>>>>>    Function UtilMoveMiscFilesToBackupFolder Returns Boolean
88508>>>>>>>        Boolean bOK bExists
88508>>>>>>>        String sDataPath sBackupFolder
88508>>>>>>>
88508>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving misc. files to Backup folder."
88509>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
88510>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
88511>>>>>>>        Get vFolderFormat sDataPath to sDataPath
88512>>>>>>>
88512>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
88513>>>>>>>        If (bExists = False) Begin
88515>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
88516>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
88517>>>>>>>            If (bExists = False) Begin
88519>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all misc. files to. You need to move them somewhere manually.")
88520>>>>>>>>
88520>>>>>>>                Function_Return False
88521>>>>>>>            End
88521>>>>>>>>
88521>>>>>>>            Get vMoveFile (sDataPath + "*.fd")         (sDataPath + sBackupFolder) to bOK  
88522>>>>>>>            Get vMoveFile (sDataPath + "*.bad")        (sDataPath + sBackupFolder) to bOK  
88523>>>>>>>            Get vMoveFile (sDataPath + "*.err")        (sDataPath + sBackupFolder) to bOK  
88524>>>>>>>            Get vMoveFile (sDataPath + "*.bak")        (sDataPath + sBackupFolder) to bOK
88525>>>>>>>            Get vMoveFile (sDataPath + "*.def")        (sDataPath + sBackupFolder) to bOK
88526>>>>>>>            Get vMoveFile (sDataPath + "*.fil")        (sDataPath + sBackupFolder) to bOK
88527>>>>>>>            Get vMoveFile (sDataPath + "*.hlp")        (sDataPath + sBackupFolder) to bOK
88528>>>>>>>            Get vMoveFile (sDataPath + "*.old")        (sDataPath + sBackupFolder) to bOK           
88529>>>>>>>            Get vMoveFile (sDataPath + "*.prn")        (sDataPath + sBackupFolder) to bOK           
88530>>>>>>>            Get vMoveFile (sDataPath + "*.sts")        (sDataPath + sBackupFolder) to bOK           
88531>>>>>>>            Get vMoveFile (sDataPath + "*.td")         (sDataPath + sBackupFolder) to bOK           
88532>>>>>>>            Get vMoveFile (sDataPath + "*.log")        (sDataPath + sBackupFolder) to bOK           
88533>>>>>>>            Get vMoveFile (sDataPath + "*.bat")        (sDataPath + sBackupFolder) to bOK           
88534>>>>>>>            Get vMoveFile (sDataPath + "*.cmd")        (sDataPath + sBackupFolder) to bOK           
88535>>>>>>>            Get vMoveFile (sDataPath + "*.zip")        (sDataPath + sBackupFolder) to bOK           
88536>>>>>>>            Get vMoveFile (sDataPath + "*.abs")        (sDataPath + sBackupFolder) to bOK           
88537>>>>>>>            Get vMoveFile (sDataPath + "termlist.*")   (sDataPath + sBackupFolder) to bOK
88538>>>>>>>            Get vMoveFile (sDataPath + "*.dfr")        (sDataPath + sBackupFolder) to bOK
88539>>>>>>>            Get vMoveFile (sDataPath + "vsutil.cfg")   (sDataPath + sBackupFolder) to bOK
88540>>>>>>>            Get vMoveFile (sDataPath + "collate.*")    (sDataPath + sBackupFolder) to bOK
88541>>>>>>>            Get vMoveFile (sDataPath + "df_collate.*") (sDataPath + sBackupFolder) to bOK
88542>>>>>>>            Get vDeleteFile (sDataPath + "*.cch")                                  to bOK
88543>>>>>>>        End
88543>>>>>>>>
88543>>>>>>>
88543>>>>>>>        Set Message_Text of ghoStatusPanel to ""
88544>>>>>>>        Function_Return True
88545>>>>>>>    End_Function
88546>>>>>>>    
88546>>>>>>>    // Check if the file exists in the Data folder,
88546>>>>>>>    // else creates it from memory as it has been compiled into the program as a resource:
88546>>>>>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
88548>>>>>>>        String sPath
88548>>>>>>>        Boolean bExists
88548>>>>>>>
88548>>>>>>>        Get psDataPathFirstPart to sPath
88549>>>>>>>        Move (sPath + sFileName) to sFileName
88550>>>>>>>        Get vFilePathExists sFileName to bExists
88551>>>>>>>
88551>>>>>>>        If (bExists = False) Begin
88553>>>>>>>            // Read from memory & create file on disk.
88553>>>>>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
88554>>>>>>>            Get vFilePathExists sFileName to bExists
88555>>>>>>>        End
88555>>>>>>>>
88555>>>>>>>        Function_Return bExists
88556>>>>>>>    End_Function
88557>>>>>>>
88557>>>>>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
88559>>>>>>>        tColumnType RetvalType
88559>>>>>>>        tColumnType RetvalType
88559>>>>>>>        Integer iRetval
88559>>>>>>>
88559>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
88560>>>>>>>        Move RetvalType.iDataFlexType to iRetval
88561>>>>>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
88563>>>>>>>            If (iLength <= 255) Begin
88565>>>>>>>                Move DF_ASCII to iRetval
88566>>>>>>>            End
88566>>>>>>>>
88566>>>>>>>        End
88566>>>>>>>>
88566>>>>>>>        Function_Return iRetval
88567>>>>>>>    End_Function
88568>>>>>>>
88568>>>>>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
88570>>>>>>>        String sRetval
88570>>>>>>>
88570>>>>>>>        Case Begin
88570>>>>>>>            Case (iDataType = DF_ASCII)
88572>>>>>>>                Move "DF_ASCII" to sRetval
88573>>>>>>>                Case Break
88574>>>>>>>            Case (iDataType = DF_BCD)
88577>>>>>>>                Move "DF_BCD" to sRetval
88578>>>>>>>                Case Break
88579>>>>>>>            Case (iDataType = DF_BINARY)
88582>>>>>>>                Move "DF_BINARY" to sRetval
88583>>>>>>>                Case Break
88584>>>>>>>            Case (iDataType = DF_DATE)
88587>>>>>>>                Move "DF_DATE" to sRetval
88588>>>>>>>                Case Break
88589>>>>>>>            Case (iDataType = DF_DATETIME)
88592>>>>>>>                Move "DF_DATETIME" to sRetval
88593>>>>>>>                Case Break
88594>>>>>>>            Case (iDataType = DF_TEXT)
88597>>>>>>>                Move "DF_TEXT" to sRetval
88598>>>>>>>                Case Break
88599>>>>>>>            Case Else
88599>>>>>>>                Move "" to sRetval
88600>>>>>>>        Case End
88600>>>>>>>
88600>>>>>>>        Function_Return sRetval
88601>>>>>>>    End_Function
88602>>>>>>>
88602>>>>>>>    // The default value used for a datatype as specified in the driver int file.
88602>>>>>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
88604>>>>>>>        String sRetval sServer
88604>>>>>>>        tColumnType RetvalType
88604>>>>>>>        tColumnType RetvalType
88604>>>>>>>        Integer iDriver iDataFlexType
88604>>>>>>>        Handle hDatabase
88604>>>>>>>
88604>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
88605>>>>>>>        Move RetvalType.iDataFlexType to iDataFlexType
88606>>>>>>>        Get DriverIndex sDriverID to iDriver
88607>>>>>>>        Get psServer to sServer
88608>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
88609>>>>>>>        If (hDatabase = 0) Begin
88611>>>>>>>            Function_Return ""
88612>>>>>>>        End
88612>>>>>>>>
88612>>>>>>>
88612>>>>>>>        Case Begin
88612>>>>>>>            Case (iDataFlexType = DF_ASCII)
88614>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
88617>>>>>>>                Case Break
88618>>>>>>>            Case (iDataFlexType = DF_BCD)
88621>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
88624>>>>>>>                Case Break
88625>>>>>>>            Case (iDataFlexType = DF_BINARY)
88628>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
88631>>>>>>>                Case Break
88632>>>>>>>            Case (iDataFlexType = DF_DATE)
88635>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
88638>>>>>>>                Case Break
88639>>>>>>>            Case (iDataFlexType = DF_DATETIME)
88642>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
88645>>>>>>>                Case Break
88646>>>>>>>            Case (iDataFlexType = DF_TEXT)
88649>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
88652>>>>>>>                Case Break
88653>>>>>>>            Case Else
88653>>>>>>>                Move "" to sRetval
88654>>>>>>>        Case End
88654>>>>>>>
88654>>>>>>>        Function_Return sRetval
88655>>>>>>>    End_Function
88656>>>>>>>
88656>>>>>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
88658>>>>>>>        String sDriverID sServer
88658>>>>>>>        tColumnType RetvalType
88658>>>>>>>        tColumnType RetvalType
88658>>>>>>>        Integer iDbType iDriver
88658>>>>>>>        Handle hDatabase
88658>>>>>>>
88658>>>>>>>        Get psDriverID to sDriverID
88659>>>>>>>        Get piDbType   to iDbType
88660>>>>>>>        Get DriverIndex sDriverID to iDriver
88661>>>>>>>        Get psServer to sServer
88662>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
88663>>>>>>>        If (hDatabase = 0) Begin
88665>>>>>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database. (Check that at least one connection is 'Enabled')"
88666>>>>>>>>
88666>>>>>>>            Procedure_Return
88667>>>>>>>        End
88667>>>>>>>>
88667>>>>>>>
88667>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
88670>>>>>>>
88670>>>>>>>    End_Procedure
88671>>>>>>>
88671>>>>>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
88673>>>>>>>        String sDriverID sServer
88673>>>>>>>        tColumnType RetvalType
88673>>>>>>>        tColumnType RetvalType
88673>>>>>>>        Integer iDbType iDriver
88673>>>>>>>        Handle hDatabase
88673>>>>>>>
88673>>>>>>>        Get psDriverID to sDriverID
88674>>>>>>>        Get piDbType   to iDbType
88675>>>>>>>        Get DriverIndex sDriverID to iDriver
88676>>>>>>>        Get psServer to sServer
88677>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
88678>>>>>>>        If (hDatabase = 0) Begin
88680>>>>>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
88681>>>>>>>>
88681>>>>>>>            Procedure_Return
88682>>>>>>>        End
88682>>>>>>>>
88682>>>>>>>
88682>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
88685>>>>>>>
88685>>>>>>>    End_Procedure
88686>>>>>>>
88686>>>>>>>    // Returns a struct array with the default column types for the SQL back-end and how they
88686>>>>>>>    // are mapped to the standard DataFlex data types.
88686>>>>>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
88686>>>>>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
88688>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
88688>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
88690>>>>>>>        String sDataType
88690>>>>>>>        Integer iDataType iDriverID iCount
88690>>>>>>>        Boolean bSQLDriver
88690>>>>>>>
88690>>>>>>>        Move 0 to iCount
88691>>>>>>>        Get DriverIndex sDriverID to iDriverID
88692>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
88693>>>>>>>        If (bSQLDriver = False) Begin
88695>>>>>>>            Function_Return EmptyArray
88696>>>>>>>        End
88696>>>>>>>>
88696>>>>>>>
88696>>>>>>>        // DF_ASCII
88696>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
88698>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
88701>>>>>>>        End
88701>>>>>>>>
88701>>>>>>>        Else Begin
88702>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
88705>>>>>>>        End
88705>>>>>>>>
88705>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
88706>>>>>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
88707>>>>>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
88708>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
88709>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
88710>>>>>>>        Increment iCount
88711>>>>>>>
88711>>>>>>>        // DF_BINARY
88711>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
88713>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
88716>>>>>>>        End
88716>>>>>>>>
88716>>>>>>>        Else Begin
88717>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
88720>>>>>>>        End
88720>>>>>>>>
88720>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
88721>>>>>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
88722>>>>>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
88723>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
88724>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
88725>>>>>>>        Increment iCount
88726>>>>>>>
88726>>>>>>>        // DF_DATE
88726>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
88728>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
88731>>>>>>>        End
88731>>>>>>>>
88731>>>>>>>        Else Begin
88732>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
88735>>>>>>>        End
88735>>>>>>>>
88735>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
88736>>>>>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
88737>>>>>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
88738>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
88739>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
88740>>>>>>>        Increment iCount
88741>>>>>>>
88741>>>>>>>        // DF_DATETIME
88741>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
88743>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
88746>>>>>>>        End
88746>>>>>>>>
88746>>>>>>>        Else Begin
88747>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
88750>>>>>>>        End
88750>>>>>>>>
88750>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
88751>>>>>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
88752>>>>>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
88753>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
88754>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
88755>>>>>>>        Increment iCount
88756>>>>>>>
88756>>>>>>>        // DF_NUMERIC
88756>>>>>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
88756>>>>>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
88756>>>>>>>        // we make them here all "Numeric"...
88756>>>>>>>        Case Begin
88756>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
88758>>>>>>>                Move SQL_NUMERIC to iDataType
88759>>>>>>>                Move "numeric"   to sDataType
88760>>>>>>>                Case Break
88761>>>>>>>            Case (sDriverID = DB2_DRV_ID)
88764>>>>>>>                Move SQL_NUMERIC to iDataType
88765>>>>>>>                Move "NUMERIC"   to sDataType
88766>>>>>>>                Case Break
88767>>>>>>>            Case (sDriverID = SQLFLEX)
88770>>>>>>>                Move eSQLServer_NUMERIC to iDataType
88771>>>>>>>                Move "numeric"   to sDataType
88772>>>>>>>                Case Break
88773>>>>>>>            Case (sDriverID = MDSMySQL)
88776>>>>>>>                Move eMySQL_DECIMAL to iDataType
88777>>>>>>>                Move "decimal"   to sDataType
88778>>>>>>>                Case Break
88779>>>>>>>            Case (sDriverID = ORAFLEX)
88782>>>>>>>                Move eOracle_NUMBER to iDataType
88783>>>>>>>                Move "NUMBER"   to sDataType
88784>>>>>>>                Case Break
88785>>>>>>>            Case (sDriverID = MDSPgSQL)
88788>>>>>>>                Move ePgSQL_FLOAT4 to iDataType
88789>>>>>>>                Move "decimal"   to sDataType
88790>>>>>>>                Case Break
88791>>>>>>>            Case Else
88791>>>>>>>                Move DF_BCD      to iDataType
88792>>>>>>>                Move "Numeric"   to sDataType
88793>>>>>>>        Case End
88793>>>>>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
88794>>>>>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
88795>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
88796>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
88797>>>>>>>        Increment iCount
88798>>>>>>>
88798>>>>>>>        // DF_TEXT
88798>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
88800>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
88803>>>>>>>        End
88803>>>>>>>>
88803>>>>>>>        Else Begin
88804>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
88807>>>>>>>        End
88807>>>>>>>>
88807>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
88808>>>>>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
88809>>>>>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
88810>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
88811>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
88812>>>>>>>
88812>>>>>>>        Function_Return ColumnTypeArray
88813>>>>>>>    End_Function
88814>>>>>>>
88814>>>>>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
88816>>>>>>>        tColumnType[] ColumnTypeArray
88816>>>>>>>        tColumnType[] ColumnTypeArray
88817>>>>>>>        tColumnType   ColumnType
88817>>>>>>>        tColumnType   ColumnType
88817>>>>>>>        Integer iCount iSize
88817>>>>>>>
88817>>>>>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
88818>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
88819>>>>>>>        Decrement iSize
88820>>>>>>>
88820>>>>>>>        for iCount from 0 to iSize
88826>>>>>>>>
88826>>>>>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
88828>>>>>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
88829>>>>>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
88830>>>>>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
88831>>>>>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
88832>>>>>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
88833>>>>>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
88834>>>>>>>                Move iSize to iCount
88835>>>>>>>            End
88835>>>>>>>>
88835>>>>>>>        Loop
88836>>>>>>>>
88836>>>>>>>
88836>>>>>>>        Function_Return ColumnType
88837>>>>>>>    End_Function
88838>>>>>>>
88838>>>>>>>    // Returns a struct with the default column types for the SQL back-end and how they
88838>>>>>>>    // are mapped to a DUF data type.
88838>>>>>>>    Function UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
88840>>>>>>>        tColumnType ColumnType
88840>>>>>>>        tColumnType ColumnType
88840>>>>>>>        String sDataType
88840>>>>>>>        Integer iDriverID iCount
88840>>>>>>>
88840>>>>>>>        Move 0 to iCount
88841>>>>>>>        Get DriverIndex sDriverID to iDriverID
88842>>>>>>>
88842>>>>>>>        Case Begin
88842>>>>>>>            // DF_ASCII
88842>>>>>>>            Case (iType = DF_ASCII_DUF)
88844>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
88846>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
88849>>>>>>>                End
88849>>>>>>>>
88849>>>>>>>                Else Begin
88850>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
88853>>>>>>>                End
88853>>>>>>>>
88853>>>>>>>                Move DF_ASCII    to ColumnType.iDataFlexType
88854>>>>>>>                Move "ASCII"     to ColumnType.sDataFlexType
88855>>>>>>>                Move sDataType   to ColumnType.sSQLType
88856>>>>>>>                Move DF_ASCII    to ColumnType.iSQLType
88857>>>>>>>                Move False       to ColumnType.bCanEditSize
88858>>>>>>>                Case Break
88859>>>>>>>
88859>>>>>>>            // DF_BINARY
88859>>>>>>>            Case (iType = DF_BINARY_DUF)
88862>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
88864>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
88867>>>>>>>                End
88867>>>>>>>>
88867>>>>>>>                Else Begin
88868>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
88871>>>>>>>                End
88871>>>>>>>>
88871>>>>>>>                Move DF_BINARY   to ColumnType.iDataFlexType
88872>>>>>>>                Move "Binary"    to ColumnType.sDataFlexType
88873>>>>>>>                Move sDataType   to ColumnType.sSQLType
88874>>>>>>>                Move DF_BINARY   to ColumnType.iSQLType
88875>>>>>>>                Move False       to ColumnType.bCanEditSize
88876>>>>>>>                Case Break
88877>>>>>>>
88877>>>>>>>            // DF_DATE
88877>>>>>>>            Case (iType = DF_DATE_DUF)
88880>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
88882>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
88885>>>>>>>                End
88885>>>>>>>>
88885>>>>>>>                Else Begin
88886>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
88889>>>>>>>                End
88889>>>>>>>>
88889>>>>>>>                Move DF_DATE     to ColumnType.iDataFlexType
88890>>>>>>>                Move "Date"      to ColumnType.sDataFlexType
88891>>>>>>>                Move sDataType   to ColumnType.sSQLType
88892>>>>>>>                Move DF_DATE     to ColumnType.iSQLType
88893>>>>>>>                Move True        to ColumnType.bCanEditSize
88894>>>>>>>                Case Break
88895>>>>>>>
88895>>>>>>>            // DF_DATETIME
88895>>>>>>>            Case (iType = DF_DATETIME_DUF)
88898>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
88900>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
88903>>>>>>>                End
88903>>>>>>>>
88903>>>>>>>                Else Begin
88904>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
88907>>>>>>>                End
88907>>>>>>>>
88907>>>>>>>                Move DF_DATETIME to ColumnType.iDataFlexType
88908>>>>>>>                Move "DateTime"  to ColumnType.sDataFlexType
88909>>>>>>>                Move sDataType   to ColumnType.sSQLType
88910>>>>>>>                Move DF_DATETIME to ColumnType.iSQLType
88911>>>>>>>                Move True        to ColumnType.bCanEditSize
88912>>>>>>>                Case Break
88913>>>>>>>
88913>>>>>>>            // DF_NUMERIC
88913>>>>>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
88913>>>>>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
88913>>>>>>>            // we make them here all "Numeric"...
88913>>>>>>>            // If (sDriverID = ODBC_DRV_ID) Begin
88913>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
88913>>>>>>>            // End
88913>>>>>>>            // Else Begin
88913>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
88913>>>>>>>            // End
88913>>>>>>>            // ToDo: How should we find the best "Numeric" data type here?
88913>>>>>>>            Case (iType = DF_BCD_DUF)
88916>>>>>>>                Move DF_BCD      to ColumnType.iDataFlexType
88917>>>>>>>                Move "Numeric"   to ColumnType.sDataFlexType
88918>>>>>>>                Move "Numeric"   to ColumnType.sSQLType
88919>>>>>>>                Move SQL_NUMERIC to ColumnType.iSQLType
88920>>>>>>>                Move False       to ColumnType.bCanEditSize
88921>>>>>>>                Case Break
88922>>>>>>>
88922>>>>>>>            // DF_TEXT
88922>>>>>>>            Case (iType = DF_TEXT_DUF)
88925>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
88927>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
88930>>>>>>>                End
88930>>>>>>>>
88930>>>>>>>                Else Begin
88931>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
88934>>>>>>>                End
88934>>>>>>>>
88934>>>>>>>                Move DF_TEXT     to ColumnType.iDataFlexType
88935>>>>>>>                Move "Text"      to ColumnType.sDataFlexType
88936>>>>>>>                Move sDataType   to ColumnType.sSQLType
88937>>>>>>>                Move DF_TEXT     to ColumnType.iSQLType
88938>>>>>>>                Move False       to ColumnType.bCanEditSize
88939>>>>>>>                Case Break
88940>>>>>>>
88940>>>>>>>            Case Else
88940>>>>>>>                Move -1999       to ColumnType.iDataFlexType
88941>>>>>>>                Move "Undefined" to ColumnType.sDataFlexType
88942>>>>>>>                Move "Undefined" to ColumnType.sSQLType
88943>>>>>>>                Move -1999       to ColumnType.iSQLType
88944>>>>>>>                Move True        to ColumnType.bCanEditSize
88945>>>>>>>
88945>>>>>>>        Case End
88945>>>>>>>
88945>>>>>>>        Function_Return ColumnType
88946>>>>>>>    End_Function
88947>>>>>>>
88947>>>>>>>    Function UtilDeleteCacheFile String sTableName Returns Boolean
88949>>>>>>>        String sDataPath sDriverID
88949>>>>>>>        Boolean bMertechDriver bOK
88949>>>>>>>        Integer iPos
88949>>>>>>>
88949>>>>>>>        If (sTableName contains ".") Begin
88951>>>>>>>            Move (Pos(".", sTableName)) to iPos
88952>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
88953>>>>>>>        End
88953>>>>>>>>
88953>>>>>>>
88953>>>>>>>        Get psDriverID to sDriverID
88954>>>>>>>        Get psDataPathFirstPart to sDataPath
88955>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
88956>>>>>>>        // First delete the cache file:
88956>>>>>>>        If (bMertechDriver = False) Begin
88958>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
88959>>>>>>>        End
88959>>>>>>>>
88959>>>>>>>        Else Begin
88960>>>>>>>            Get _MertechDeleteTDFile sTableName to bOK
88961>>>>>>>        End
88961>>>>>>>>
88961>>>>>>>
88961>>>>>>>        Function_Return bOK
88962>>>>>>>    End_Function
88963>>>>>>>
88963>>>>>>>    // Changes source code files.
88963>>>>>>>    // Pass a file name with full path and a value to search for, together with the value
88963>>>>>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
88963>>>>>>>    // to use a Connection ID.
88963>>>>>>>    // Sample: Get UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
88963>>>>>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
88963>>>>>>>    // Returns True if no errors occured.
88963>>>>>>>    Function UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
88965>>>>>>>        Integer iCh iRow iItems iCount
88965>>>>>>>        String sValue sRow
88965>>>>>>>        String[] sFileArray
88966>>>>>>>        Boolean bExists bIsActive
88966>>>>>>>
88966>>>>>>>        Move False to Err
88967>>>>>>>        Move 0 to iRow
88968>>>>>>>
88968>>>>>>>        If (ghoStatusPanel <> 0) Begin
88970>>>>>>>            Get Active_state of ghoStatusPanel to bIsActive
88971>>>>>>>        End
88971>>>>>>>>
88971>>>>>>>
88971>>>>>>>        Get vFilePathExists sFileName to bExists
88972>>>>>>>        If (bExists = False) Begin
88974>>>>>>>            If (bShowResult = True) Begin
88976>>>>>>>                If (bIsActive = True) Begin
88978>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
88979>>>>>>>                End
88979>>>>>>>>
88979>>>>>>>                Else Begin
88980>>>>>>>                    Showln "File does not exist: " sFileName
88983>>>>>>>                End
88983>>>>>>>>
88983>>>>>>>            End
88983>>>>>>>>
88983>>>>>>>            Function_Return False
88984>>>>>>>        End
88984>>>>>>>>
88984>>>>>>>
88984>>>>>>>        Get Seq_Open_Input_Channel sFileName to iCh
88985>>>>>>>        If (iCh < 1) Begin
88987>>>>>>>            Function_Return False
88988>>>>>>>        End
88988>>>>>>>>
88988>>>>>>>
88988>>>>>>>        If (bShowResult = True) Begin
88990>>>>>>>            If (ghoStatusPanel <> 0) Begin
88992>>>>>>>                Get Active_state of ghoStatusPanel to bIsActive
88993>>>>>>>                If (bIsActive = True) Begin
88995>>>>>>>                    Set Message_Text of ghoStatusPanel to sFileName
88996>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
88997>>>>>>>                    Send DoAdvance of ghoProgressBar
88998>>>>>>>                End
88998>>>>>>>>
88998>>>>>>>            End
88998>>>>>>>>
88998>>>>>>>            Else Begin
88999>>>>>>>                Showln ""
89001>>>>>>>                Showln "sFileName = " sFileName
89004>>>>>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
89009>>>>>>>            End
89009>>>>>>>>
89009>>>>>>>        End
89009>>>>>>>>
89009>>>>>>>
89009>>>>>>>        While (not(SeqEof))
89013>>>>>>>            Readln channel iCh sRow
89015>>>>>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
89017>>>>>>>//                If (bShowResult = True) Begin
89017>>>>>>>//                    If (bIsActive = True) Begin
89017>>>>>>>//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
89017>>>>>>>//                    End
89017>>>>>>>//                    Else Begin
89017>>>>>>>//                        Showln "Changed from: " sRow " to: " sChangeTo
89017>>>>>>>//                    End
89017>>>>>>>//                End
89017>>>>>>>                // Change the whole line to the new connection id:
89017>>>>>>>                Move sChangeTo to sRow
89018>>>>>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
89018>>>>>>>            End
89018>>>>>>>>
89018>>>>>>>            Move sRow to sFileArray[iRow]
89019>>>>>>>            Increment iRow
89020>>>>>>>        Loop
89021>>>>>>>>
89021>>>>>>>        Send Seq_Close_Channel iCh
89022>>>>>>>
89022>>>>>>>        Sleep 1 // Wait for Windows to close the file
89023>>>>>>>
89023>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
89024>>>>>>>        If (iCh < 1) Begin
89026>>>>>>>            Function_Return False
89027>>>>>>>        End
89027>>>>>>>>
89027>>>>>>>        Move (SizeOfArray(sFileArray)) to iItems
89028>>>>>>>        Decrement iItems
89029>>>>>>>
89029>>>>>>>        For iCount from 0 to iItems
89035>>>>>>>>
89035>>>>>>>            Move sFileArray[iCount] to sValue
89036>>>>>>>            Writeln channel iCh sValue
89039>>>>>>>        Loop
89040>>>>>>>>
89040>>>>>>>        Send Seq_Close_Channel iCh
89041>>>>>>>
89041>>>>>>>        Function_Return (Err = False)
89042>>>>>>>    End_Function
89043>>>>>>>
89043>>>>>>>    Function AutoSetConnectionID String sConnectionID Returns Boolean
89045>>>>>>>        Integer iRetval
89045>>>>>>>        Move 1 to iRetval
89046>>>>>>>        If (ghoSQLConnectionHandler <> 0) Begin
89048>>>>>>>            Set psConnectionID of ghoSQLConnectionHandler to sConnectionID
89049>>>>>>>            Get AutoSetConnectionID of ghoSQLConnectionHandler to iRetval
89050>>>>>>>        End
89050>>>>>>>>
89050>>>>>>>        Function_Return (iRetval = 0)
89051>>>>>>>    End_Function
89052>>>>>>>
89052>>>>>>>    // *** DEPRECIATED ***
89052>>>>>>>    // Use the AutoSetConnectionID function instead.
89052>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
89052>>>>>>>    // the connection ID hasn't been established with the driver's CLI interface.
89052>>>>>>>    // NOTE: Only applicable for DAW drivers, as Mertech drivers doesn't use connection ID's.
89052>>>>>>>//    Function UtilCreateConnectionID String sConnectionID Returns Boolean
89052>>>>>>>//        String sConnectionString sDriverID
89052>>>>>>>//        Boolean bOK bSilent bDawDriver
89052>>>>>>>//        Handle hoCLI
89052>>>>>>>//
89052>>>>>>>//        Move False to bOK
89052>>>>>>>//        Get psDriverID to sDriverID
89052>>>>>>>//        Get IsDAWSQLDriver sDriverID to bDawDriver
89052>>>>>>>//        If (bDawDriver = False) Begin
89052>>>>>>>//            Error DFERR_PROGRAM "The UtilCreateConnectionID function is only available for DAW drivers. (Not Mertech)."
89052>>>>>>>//            Function_Return False
89052>>>>>>>//        End
89052>>>>>>>//
89052>>>>>>>//        Get psConnectionString to sConnectionString
89052>>>>>>>//        Get pbSilentLogin      to bSilent
89052>>>>>>>//
89052>>>>>>>//        Get phoCLIHandler to hoCLI
89052>>>>>>>//        If (hoCLI <> 0) Begin
89052>>>>>>>//            Set psDriverID of hoCLI to sDriverID
89052>>>>>>>//            Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to bOK
89052>>>>>>>//        End
89052>>>>>>>//
89052>>>>>>>//        Function_Return (bOK = False)
89052>>>>>>>//    End_Function
89052>>>>>>>
89052>>>>>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
89052>>>>>>>    // and opens it in "notepad.exe".
89052>>>>>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
89052>>>>>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
89052>>>>>>>    Procedure UtilShowErrorList
89054>>>>>>>        tSqlErrorArray aSqlErrorArray
89054>>>>>>>        tSqlErrorArray aSqlErrorArray
89054>>>>>>>        Integer iRows iCount iCh iErrorNum
89054>>>>>>>        String sPath sFileName sErrorTxt sStatement
89054>>>>>>>
89054>>>>>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
89055>>>>>>>        Get vFolderFormat sPath to sPath
89056>>>>>>>        Move "SQLErrorLog.txt"  to sFileName
89057>>>>>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
89058>>>>>>>            Get paSqlErrorArray to aSqlErrorArray
89059>>>>>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
89060>>>>>>>            If (iRows > 0) Begin
89062>>>>>>>                Decrement iRows
89063>>>>>>>                for iCount from 0 to iRows
89069>>>>>>>>
89069>>>>>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
89070>>>>>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
89071>>>>>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
89072>>>>>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
89078>>>>>>>                    Writeln channel iCh "SQL Statement: " sStatement
89082>>>>>>>                Loop
89083>>>>>>>>
89083>>>>>>>            End
89083>>>>>>>>
89083>>>>>>>        Send Seq_Close_Channel iCh
89084>>>>>>>
89084>>>>>>>        If (iRows > 0) Begin
89086>>>>>>>            Runprogram Shell Background (sPath + sFileName)
89087>>>>>>>        End
89087>>>>>>>>
89087>>>>>>>    End_Procedure
89088>>>>>>>
89088>>>>>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
89088>>>>>>>    // and the table needs to exist as an SQL table.
89088>>>>>>>    Function UtilTableIsSql Handle hTable Returns Boolean
89090>>>>>>>        String sRootName sDriverID
89090>>>>>>>        Boolean bIsSQL
89090>>>>>>>
89090>>>>>>>        Move False to bIsSQL
89091>>>>>>>        If (hTable > 0) Begin
89093>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89096>>>>>>>            Get UtilTableIsSqlByRootName sRootName to bIsSQL
89097>>>>>>>            If (bIsSQL = True) Begin
89099>>>>>>>                Get psDriverID to sDriverID
89100>>>>>>>                Get _TableNameOnly sRootName to sRootName
89101>>>>>>>                Get SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
89102>>>>>>>            End
89102>>>>>>>>
89102>>>>>>>        End
89102>>>>>>>>
89102>>>>>>>
89102>>>>>>>        Function_Return bIsSQL
89103>>>>>>>    End_Function
89104>>>>>>>
89104>>>>>>>    Function UtilTableIsSqlByRootName String sRootName Returns Boolean
89106>>>>>>>        Boolean bIsSQL
89106>>>>>>>        Move (sRootName contains ":") to bIsSQL
89107>>>>>>>        Function_Return bIsSQL
89108>>>>>>>    End_Function
89109>>>>>>>
89109>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
89109>>>>>>>    // that the embedded .dat file exists on disk.
89109>>>>>>>    Function UtilTableIsEmbedded Handle hTable Returns Boolean
89111>>>>>>>        Boolean bExists bIsEmbedded
89111>>>>>>>        String sDataPath sRootName
89111>>>>>>>
89111>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
89112>>>>>>>        If (bExists = False) Begin
89114>>>>>>>            Function_Return False
89115>>>>>>>        End
89115>>>>>>>>
89115>>>>>>>
89115>>>>>>>        Move False to bIsEmbedded
89116>>>>>>>        If (hTable > 0) Begin
89118>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89121>>>>>>>            Move (not(sRootName contains ":")) to bIsEmbedded
89122>>>>>>>        End
89122>>>>>>>>
89122>>>>>>>        If (bIsEmbedded = True) Begin
89124>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
89125>>>>>>>            Get vFolderFormat sDataPath to sDataPath
89126>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bIsEmbedded
89127>>>>>>>        End
89127>>>>>>>>
89127>>>>>>>
89127>>>>>>>        Function_Return bIsEmbedded
89128>>>>>>>    End_Function
89129>>>>>>>
89129>>>>>>>
89129>>>>>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
89129>>>>>>>    // An Alias file/table is a filelist number that share the same Physical filename
89129>>>>>>>    // but the Logical name is different.
89129>>>>>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
89129>>>>>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
89131>>>>>>>        String sRootName sRootNameCompare sLogicalName sLogicalNameCompare
89131>>>>>>>        Handle hInTable hMasterTable 
89131>>>>>>>        Boolean bIsAlias
89131>>>>>>>        
89131>>>>>>>        Move hTable to hInTable
89132>>>>>>>        Move False to bIsAlias
89133>>>>>>>        Move 0 to hMasterTable
89134>>>>>>>        
89134>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89137>>>>>>>        // Remove any prefix with a driver name.
89137>>>>>>>        Get _TableNameOnly sRootName to sRootName     
89138>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89141>>>>>>>        Get _TableNameOnly sLogicalName to sLogicalName     
89142>>>>>>>        
89142>>>>>>>        // If the table has the same root and logical name it can't be an alias,
89142>>>>>>>        // so we can safely return a "False".
89142>>>>>>>        If (Uppercase(sRootName) = Uppercase(sLogicalName)) Begin
89144>>>>>>>            Function_Return False
89145>>>>>>>        End
89145>>>>>>>>
89145>>>>>>>        
89145>>>>>>>        // Now we need to find a master table with the same root name (sRootName above),
89145>>>>>>>        // as the passed hTable root name.
89145>>>>>>>        // A master table always has the same root and logical name.
89145>>>>>>>        Move 0 to hTable
89146>>>>>>>        Repeat
89146>>>>>>>>
89146>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89149>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
89151>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameCompare
89154>>>>>>>                Get _TableNameOnly sRootNameCompare to sRootNameCompare
89155>>>>>>>                // If we found another table with the same root and logical name
89155>>>>>>>                // we have found a master table.
89155>>>>>>>                If (Uppercase(sRootName) = Uppercase(sRootNameCompare)) Begin
89157>>>>>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameCompare
89160>>>>>>>                    Get _TableNameOnly sLogicalNameCompare to sLogicalNameCompare     
89161>>>>>>>                    If (Uppercase(sRootNameCompare) = Uppercase(sLogicalNameCompare)) Begin
89163>>>>>>>                        Move hTable to hMasterTable   
89164>>>>>>>                        Move 0 to hTable // To end the loop.
89165>>>>>>>                    End
89165>>>>>>>>
89165>>>>>>>                End
89165>>>>>>>>
89165>>>>>>>            End
89165>>>>>>>>
89165>>>>>>>        Until (hTable = 0)
89167>>>>>>>        
89167>>>>>>>        If (hMasterTable <> 0 and hMasterTable <> hInTable) Begin
89169>>>>>>>            Move True to bIsAlias
89170>>>>>>>        End
89170>>>>>>>>
89170>>>>>>>        
89170>>>>>>>        Function_Return bIsAlias
89171>>>>>>>    End_Function
89172>>>>>>>
89172>>>>>>>    // To Open a table with any driver.
89172>>>>>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
89172>>>>>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
89172>>>>>>>    //
89172>>>>>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
89172>>>>>>>    // The found flag is still used to indicate if the open was successful or not. The function
89172>>>>>>>    // returns a True if successful (table could be opened).
89172>>>>>>>    //
89172>>>>>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
89172>>>>>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
89172>>>>>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
89172>>>>>>>    // set properly we can open the table.
89172>>>>>>>    //
89172>>>>>>>    // DAW Driver Syntax:
89172>>>>>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
89172>>>>>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
89172>>>>>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
89172>>>>>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
89172>>>>>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
89172>>>>>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
89172>>>>>>>    //
89172>>>>>>>    // DAW Driver Sample:
89172>>>>>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
89172>>>>>>>    //
89172>>>>>>>    // Mertech Driver Samples:
89172>>>>>>>    //   SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
89172>>>>>>>    //   MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
89172>>>>>>>    //   PgFlex:    Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
89172>>>>>>>    //   ORAFlex:   Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
89172>>>>>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
89174>>>>>>>        String sTableNameOrg
89174>>>>>>>        Boolean bOpen bOK
89174>>>>>>>        tSQLConnection SQLConnection
89174>>>>>>>        tSQLConnection SQLConnection
89174>>>>>>>        
89174>>>>>>>        Move False to bOpen
89175>>>>>>>        Move sTableName to sTableNameOrg
89176>>>>>>>        If (hTable > 0) Begin
89178>>>>>>>            Send Ignore_Error of Error_Object_Id 20529
89179>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89180>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
89181>>>>>>>            Send Ignore_Error of Error_Object_Id 10
89182>>>>>>>            Open hTable Mode iMode
89184>>>>>>>            Send Trap_Error of Error_Object_Id 20529
89185>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89186>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
89187>>>>>>>            Send Trap_Error of Error_Object_Id 10
89188>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
89191>>>>>>>            If (bOpen = True) Begin
89193>>>>>>>                Function_Return True
89194>>>>>>>            End
89194>>>>>>>>
89194>>>>>>>        End
89194>>>>>>>>
89194>>>>>>>
89194>>>>>>>        Get UtilTableOpenAsIntFile hTable sTableName iMode to bOK 
89195>>>>>>>        If (hTable > 0) Begin
89197>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
89200>>>>>>>        End
89200>>>>>>>>
89200>>>>>>>
89200>>>>>>>        Function_Return bOpen
89201>>>>>>>    End_Function
89202>>>>>>>
89202>>>>>>>    Function UtilTableOpenAsIntFile Integer hTable String sTableName Integer iMode Returns Boolean
89204>>>>>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
89204>>>>>>>        Boolean bOpen bMertechDriver bOK
89204>>>>>>>        tSQLConnection SQLConnection
89204>>>>>>>        tSQLConnection SQLConnection
89204>>>>>>>
89204>>>>>>>        If (hTable < 1) Begin
89206>>>>>>>            Function_Return False
89207>>>>>>>        End
89207>>>>>>>>
89207>>>>>>>
89207>>>>>>>        Move sTableName to sTableNameOrg
89208>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
89209>>>>>>>        Move SQLConnection.sDriverID to sDriverID
89210>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
89211>>>>>>>        Move SQLConnection.sConnectionString to sConnection
89212>>>>>>>        Move SQLConnection.sSchema to sSchema
89213>>>>>>>        If (sSchema = "") Begin
89215>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
89216>>>>>>>        End
89216>>>>>>>>
89216>>>>>>>
89216>>>>>>>        // We need to remove the ".int" part of the table name because
89216>>>>>>>        // the table name after the "#" in the connection syntax below wants the
89216>>>>>>>        // "bare" table name without any extension.
89216>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
89218>>>>>>>            If (Lowercase(sTableName) contains ".int") Begin
89220>>>>>>>                Get ParseFileExtension sTableName to sExt
89221>>>>>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
89222>>>>>>>            End
89222>>>>>>>>
89222>>>>>>>            Else Begin
89223>>>>>>>                Move sTableName to sTableNameShort
89224>>>>>>>                Move (Append(sTableName, ".int")) to sTableName
89225>>>>>>>            End
89225>>>>>>>>
89225>>>>>>>            If (bMertechDriver = False) Begin
89227>>>>>>>                Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
89228>>>>>>>                Move sConnection to sTableName
89229>>>>>>>            End
89229>>>>>>>>
89229>>>>>>>        End
89229>>>>>>>>
89229>>>>>>>
89229>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
89230>>>>>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
89231>>>>>>>        If (hTable = 0) Begin
89233>>>>>>>            Get NextFreeFilelistSlot to hTable
89234>>>>>>>        End
89234>>>>>>>>
89234>>>>>>>
89234>>>>>>>        Case Begin
89234>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
89236>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
89236>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
89238>>>>>>>                    Close hTable
89239>>>>>>>                    Open sTableName as hTable
89241>>>>>>>                End
89241>>>>>>>>
89241>>>>>>>                Else Begin
89242>>>>>>>                    Get OpenTableExclusive hTable to bOK
89243>>>>>>>                    If (bOK = False) Begin
89245>>>>>>>                        Function_Return False
89246>>>>>>>                    End
89246>>>>>>>>
89246>>>>>>>                End
89246>>>>>>>>
89246>>>>>>>                Case Break
89247>>>>>>>
89247>>>>>>>            Case (sDriverID = DB2_DRV_ID)
89250>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
89250>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
89252>>>>>>>                    Close hTable
89253>>>>>>>                    Open sTableName as hTable
89255>>>>>>>                End
89255>>>>>>>>
89255>>>>>>>                Else Begin
89256>>>>>>>                    Get OpenTableExclusive hTable to bOK
89257>>>>>>>                    If (bOK = False) Begin
89259>>>>>>>                        Function_Return False
89260>>>>>>>                    End
89260>>>>>>>>
89260>>>>>>>                End
89260>>>>>>>>
89260>>>>>>>                Case Break
89261>>>>>>>
89261>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
89264>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
89264>>>>>>>                If (iMode = DF_SHARE) Begin
89266>>>>>>>                    Close hTable
89267>>>>>>>                    Open sTableName as hTable
89269>>>>>>>                End
89269>>>>>>>>
89269>>>>>>>                Else Begin
89270>>>>>>>                    Get OpenTableExclusive hTable to bOK
89271>>>>>>>                    If (bOK = False) Begin
89273>>>>>>>                        Function_Return False
89274>>>>>>>                    End
89274>>>>>>>>
89274>>>>>>>                End
89274>>>>>>>>
89274>>>>>>>                Case Break
89275>>>>>>>
89275>>>>>>>            Case (sDriverID = SQLFLEX)
89278>>>>>>>                // ToDo: What is the <owner>? Same as Schema?
89278>>>>>>>                // SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
89278>>>>>>>                Move (SQLFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
89279>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
89279>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
89281>>>>>>>                    Close hTable
89282>>>>>>>                    Open sTableName as hTable
89284>>>>>>>                End
89284>>>>>>>>
89284>>>>>>>                Else Begin
89285>>>>>>>                    Get OpenTableExclusive hTable to bOK
89286>>>>>>>                    If (bOK = False) Begin
89288>>>>>>>                        Function_Return False
89289>>>>>>>                    End
89289>>>>>>>>
89289>>>>>>>                End
89289>>>>>>>>
89289>>>>>>>                Case Break
89290>>>>>>>
89290>>>>>>>            Case (sDriverID = MDSMySQL)
89293>>>>>>>                // MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
89293>>>>>>>                Move (MDSMySQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + sTableNameOrg) to sTableName
89294>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
89294>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
89296>>>>>>>                    Close hTable
89297>>>>>>>                    Open sTableName as hTable
89299>>>>>>>                End
89299>>>>>>>>
89299>>>>>>>                Else Begin
89300>>>>>>>                    Get OpenTableExclusive hTable to bOK
89301>>>>>>>                    If (bOK = False) Begin
89303>>>>>>>                        Function_Return False
89304>>>>>>>                    End
89304>>>>>>>>
89304>>>>>>>                End
89304>>>>>>>>
89304>>>>>>>                Case Break
89305>>>>>>>
89305>>>>>>>            Case (sDriverID = MDSPgSQL)
89308>>>>>>>                // PgFlex: Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
89308>>>>>>>                Move (MDSPgSQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
89309>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
89309>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
89311>>>>>>>                    Close hTable
89312>>>>>>>                    Open sTableName as hTable
89314>>>>>>>                End
89314>>>>>>>>
89314>>>>>>>                Else Begin
89315>>>>>>>                    Get OpenTableExclusive hTable to bOK
89316>>>>>>>                    If (bOK = False) Begin
89318>>>>>>>                        Function_Return False
89319>>>>>>>                    End
89319>>>>>>>>
89319>>>>>>>                End
89319>>>>>>>>
89319>>>>>>>                Case Break
89320>>>>>>>
89320>>>>>>>            Case (sDriverID = ORAFLEX)
89323>>>>>>>                // ToDo: What is the <owner>? Same as Schema?
89323>>>>>>>                // ORAFlex: Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
89323>>>>>>>                Move (ORAFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sSchema + "*" + sTableName) to sTableName
89324>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
89324>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
89326>>>>>>>                    Close hTable
89327>>>>>>>                    Open sTableName as hTable
89329>>>>>>>                End
89329>>>>>>>>
89329>>>>>>>                Else Begin
89330>>>>>>>                    Get OpenTableExclusive hTable to bOK
89331>>>>>>>                    If (bOK = False) Begin
89333>>>>>>>                        Function_Return False
89334>>>>>>>                    End
89334>>>>>>>>
89334>>>>>>>                End
89334>>>>>>>>
89334>>>>>>>                Case Break
89335>>>>>>>
89335>>>>>>>            Case (sDriverID = DATAFLEX_ID)
89338>>>>>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
89340>>>>>>>                    Close hTable
89341>>>>>>>                    Open sTableName as hTable
89343>>>>>>>                End
89343>>>>>>>>
89343>>>>>>>                Else If (iMode = DF_EXCLUSIVE) Begin
89346>>>>>>>                    Get OpenTableExclusive hTable to bOK
89347>>>>>>>                    If (bOK = False) Begin
89349>>>>>>>                        Function_Return False
89350>>>>>>>                    End
89350>>>>>>>>
89350>>>>>>>                End
89350>>>>>>>>
89350>>>>>>>                Else Begin
89351>>>>>>>                    Open hTable
89353>>>>>>>                End
89353>>>>>>>>
89353>>>>>>>                Case Break
89354>>>>>>>
89354>>>>>>>            Case Else
89354>>>>>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
89355>>>>>>>>
89355>>>>>>>        Case End
89355>>>>>>>
89355>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
89356>>>>>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
89357>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
89359>>>>>>>            Move False to Found
89360>>>>>>>        End
89360>>>>>>>>
89360>>>>>>>        // If open failed, the Err is set to true,
89360>>>>>>>        // but we don't want that because it could end our loop.
89360>>>>>>>        Move False to Err
89361>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89364>>>>>>>
89364>>>>>>>        Function_Return bOpen
89365>>>>>>>    End_Function
89366>>>>>>>
89366>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
89366>>>>>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
89366>>>>>>>    // if it is an SQL table
89366>>>>>>>    Function UtilTableExists Handle hTable Returns Boolean
89368>>>>>>>        Boolean bExists bIsSQLTable
89368>>>>>>>        String sDataPath sRootName
89368>>>>>>>
89368>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
89369>>>>>>>        If (bExists = False) Begin
89371>>>>>>>            Function_Return False
89372>>>>>>>        End
89372>>>>>>>>
89372>>>>>>>
89372>>>>>>>        Move False to bIsSQLTable
89373>>>>>>>        If (hTable > 0) Begin
89375>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89378>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
89379>>>>>>>        End
89379>>>>>>>>
89379>>>>>>>        If (bIsSQLTable = True) Begin
89381>>>>>>>            Get UtilTableIsSQL hTable to bExists
89382>>>>>>>            Function_Return bExists
89383>>>>>>>        End
89383>>>>>>>>
89383>>>>>>>        Else Begin
89384>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
89385>>>>>>>            Get vFolderFormat sDataPath to sDataPath
89386>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
89387>>>>>>>        End
89387>>>>>>>>
89387>>>>>>>
89387>>>>>>>        Function_Return bExists
89388>>>>>>>    End_Function
89389>>>>>>>
89389>>>>>>>    // Pass a table handle
89389>>>>>>>    // Returns True if the table exists in filelist.cfg.
89389>>>>>>>    Function UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
89391>>>>>>>        Handle hTable
89391>>>>>>>        Boolean bFound
89391>>>>>>>
89391>>>>>>>        Move False to bFound
89392>>>>>>>        Move 0 to hTable
89393>>>>>>>        Repeat
89393>>>>>>>>
89393>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89396>>>>>>>            If (hTable > 0) Begin
89398>>>>>>>                If (hTable = hCheckTable) Begin
89400>>>>>>>                    Move True to bFound
89401>>>>>>>                End
89401>>>>>>>>
89401>>>>>>>            End
89401>>>>>>>>
89401>>>>>>>            If (bFound = True) ;                Break
89404>>>>>>>        Until (hTable = 0)
89406>>>>>>>
89406>>>>>>>        Function_Return (bFound = True)
89407>>>>>>>    End_Function
89408>>>>>>>
89408>>>>>>>    // Pass a table's logical name
89408>>>>>>>    // Returns True if the table exists in filelist.cfg.
89408>>>>>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
89410>>>>>>>        Handle hTable
89410>>>>>>>        Boolean bFound
89410>>>>>>>        String sCompareTable
89410>>>>>>>
89410>>>>>>>        Move False to bFound
89411>>>>>>>        Move 0 to hTable
89412>>>>>>>        Repeat
89412>>>>>>>>
89412>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89415>>>>>>>            If (hTable > 0) Begin
89417>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
89420>>>>>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
89422>>>>>>>                    Move True to bFound
89423>>>>>>>                End
89423>>>>>>>>
89423>>>>>>>            End
89423>>>>>>>>
89423>>>>>>>            If (bFound = True) ;                Break
89426>>>>>>>        Until (hTable = 0)
89428>>>>>>>
89428>>>>>>>        Function_Return (bFound = True)
89429>>>>>>>    End_Function
89430>>>>>>>
89430>>>>>>>    // Function will report the default driver "DATAFLEX" if table can't be opened
89430>>>>>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
89432>>>>>>>        Boolean bOK bExists
89432>>>>>>>        String sDriverID
89432>>>>>>>
89432>>>>>>>        Get UtilTableExists hTable to bExists
89433>>>>>>>        If (bExists = False) Begin
89435>>>>>>>            Function_Return DATAFLEX_ID
89436>>>>>>>        End
89436>>>>>>>>
89436>>>>>>>        Get OpenTableExclusive hTable to bOK
89437>>>>>>>        If (bOK = False) Begin
89439>>>>>>>            Function_Return DATAFLEX_ID
89440>>>>>>>        End
89440>>>>>>>>
89440>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89443>>>>>>>        Function_Return sDriverID
89444>>>>>>>    End_Function
89445>>>>>>>
89445>>>>>>>    // Number of tables in Filelist.cfg. Returns integger
89445>>>>>>>    Function UtilFilelistNoOfTables Returns Integer
89447>>>>>>>        Handle hTable
89447>>>>>>>        Integer iRetval
89447>>>>>>>
89447>>>>>>>        Move 0 to hTable
89448>>>>>>>        Move 0 to iRetval
89449>>>>>>>
89449>>>>>>>        Repeat
89449>>>>>>>>
89449>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89452>>>>>>>            If (hTable > 0) Begin
89454>>>>>>>                Increment iRetval
89455>>>>>>>            End
89455>>>>>>>>
89455>>>>>>>        Until (hTable = 0)
89457>>>>>>>
89457>>>>>>>        Function_Return iRetval
89458>>>>>>>    End_Function
89459>>>>>>>
89459>>>>>>>    // Checks if any of the tables in Filelist.cfg is an SQL driver and returns the first Driver ID.
89459>>>>>>>    Function UtilIsAnyFilelistEntrySQLtable Returns String
89461>>>>>>>        Handle hTable
89461>>>>>>>        String sRoot sDriverID
89461>>>>>>>        Boolean bIsSQLTable
89461>>>>>>>        Integer iPos
89461>>>>>>>
89461>>>>>>>        Move 0 to hTable
89462>>>>>>>        Move "" to sDriverID
89463>>>>>>>        Move False to bIsSQLTable
89464>>>>>>>
89464>>>>>>>        Repeat
89464>>>>>>>>
89464>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89467>>>>>>>            If (hTable > 0) Begin
89469>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
89472>>>>>>>                If (sRoot contains ":") Begin
89474>>>>>>>                    Move (Pos(":", sRoot)) to iPos
89475>>>>>>>                    Move (Left(sRoot, (iPos -1))) to sDriverID
89476>>>>>>>                End
89476>>>>>>>>
89476>>>>>>>                Get IsSQLDriver sDriverID to bIsSQLTable
89477>>>>>>>            End
89477>>>>>>>>
89477>>>>>>>
89477>>>>>>>        Until (hTable = 0 or bIsSQLTable = True)
89479>>>>>>>
89479>>>>>>>        Function_Return sDriverID
89480>>>>>>>    End_Function
89481>>>>>>>
89481>>>>>>>    Function UtilIsAllFilelistEntriesDataFlexTables Returns Boolean
89483>>>>>>>        String sRootName
89483>>>>>>>        Boolean bIsSQL
89483>>>>>>>        Handle hTable
89483>>>>>>>
89483>>>>>>>        Move False to bIsSQL
89484>>>>>>>        Move 0 to hTable
89485>>>>>>>        Repeat
89485>>>>>>>>
89485>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89488>>>>>>>            If (hTable > 0) Begin
89490>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89493>>>>>>>                Get UtilTableIsSqlByRootName sRootName to bIsSQL
89494>>>>>>>                If (bIsSQL = True) Begin
89496>>>>>>>                    Move 0 to hTable
89497>>>>>>>                End
89497>>>>>>>>
89497>>>>>>>            End
89497>>>>>>>>
89497>>>>>>>        Until (hTable = 0)
89499>>>>>>>
89499>>>>>>>        Function_Return (bIsSQL = False)
89500>>>>>>>    End_Function
89501>>>>>>>
89501>>>>>>>    // * Dummy function for the Studio's Code Explorer *
89501>>>>>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
89503>>>>>>>        Function_Return False
89504>>>>>>>    End_Function
89505>>>>>>>
89505>>>>>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
89507>>>>>>>        String  sRetval
89507>>>>>>>        String[] sOverlapFieldsArray
89508>>>>>>>        Integer iType iColumn iColumns
89508>>>>>>>        Boolean bOpen bOverlap
89508>>>>>>>
89508>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89511>>>>>>>        If (bOpen = False) Begin
89513>>>>>>>            Open hTable
89515>>>>>>>        End
89515>>>>>>>>
89515>>>>>>>
89515>>>>>>>        Move "" to sRetval
89516>>>>>>>
89516>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
89519>>>>>>>
89519>>>>>>>        for iColumn from 0 to iColumns
89525>>>>>>>>
89525>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
89528>>>>>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
89530>>>>>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
89533>>>>>>>                If (bOverlap) Begin
89535>>>>>>>                    If (sRetval <> "") Begin
89537>>>>>>>                        Append sRetval ","
89538>>>>>>>                    End
89538>>>>>>>>
89538>>>>>>>                    Append sRetval iColumn
89539>>>>>>>                End
89539>>>>>>>>
89539>>>>>>>            End
89539>>>>>>>>
89539>>>>>>>        Loop
89540>>>>>>>>
89540>>>>>>>
89540>>>>>>>        If (bOpen = False) Begin
89542>>>>>>>            Close hTable
89543>>>>>>>        End
89543>>>>>>>>
89543>>>>>>>
89543>>>>>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
89544>>>>>>>
89544>>>>>>>        Function_Return sOverlapFieldsArray
89545>>>>>>>    End_Function
89546>>>>>>>
89546>>>>>>>    // Returns a struct array with all data types for the passed driver & dbtype.
89546>>>>>>>    Function UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
89548>>>>>>>        tColumnType[] ColumnType
89548>>>>>>>        tColumnType[] ColumnType
89549>>>>>>>
89549>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
89549>>>>>>>        // the dbType.
89549>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
89551>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
89553>>>>>>>                Move MDSMySQL to sDriverID
89554>>>>>>>            End
89554>>>>>>>>
89554>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
89556>>>>>>>                Move MSSQLDRV_ID to sDriverID
89557>>>>>>>            End
89557>>>>>>>>
89557>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
89559>>>>>>>                Move DB2_DRV_ID to sDriverID
89560>>>>>>>            End
89560>>>>>>>>
89560>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
89562>>>>>>>                Move MDSPgSQL to sDriverID
89563>>>>>>>            End
89563>>>>>>>>
89563>>>>>>>        End
89563>>>>>>>>
89563>>>>>>>
89563>>>>>>>        Case Begin
89563>>>>>>>            Case (iDbType = EN_dbTypeDataFlex)
89565>>>>>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
89566>>>>>>>                Case Break
89567>>>>>>>
89567>>>>>>>            Case (iDbType = EN_DbTypeDB2)
89570>>>>>>>                Get _UtilEnumerateDB2Types to ColumnType
89571>>>>>>>                Case Break
89572>>>>>>>
89572>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
89575>>>>>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
89576>>>>>>>                Case Break
89577>>>>>>>
89577>>>>>>>            Case (sDriverID = MDSMySQL)
89580>>>>>>>                Get _UtilEnumerateMySQLTypes to ColumnType
89581>>>>>>>                Case Break
89582>>>>>>>
89582>>>>>>>            Case (sDriverID = ORAFLEX)
89585>>>>>>>                Get _UtilEnumerateOracleTypes to ColumnType
89586>>>>>>>                Case Break
89587>>>>>>>
89587>>>>>>>            Case (sDriverID = MDSPgSQL)
89590>>>>>>>                Get _UtilEnumeratePostgreSQLTypes to ColumnType
89591>>>>>>>                Case Break
89592>>>>>>>        Case End
89592>>>>>>>
89592>>>>>>>        Function_Return ColumnType
89593>>>>>>>    End_Function
89594>>>>>>>
89594>>>>>>>    Function UtilEnumerateODBCDrivers Returns String
89596>>>>>>>        Handle hoRegistry hoODBCDriverNames
89596>>>>>>>        Boolean bExists bKeyOpened
89596>>>>>>>        String sKey
89596>>>>>>>        String[] sDrivers
89597>>>>>>>        Integer iDriverNames iDriverName
89597>>>>>>>
89597>>>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
89598>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
89599>>>>>>>        Set pfAccessRights of hoRegistry to Key_Read
89600>>>>>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
89601>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
89602>>>>>>>        If (bExists) Begin
89604>>>>>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
89605>>>>>>>            If (bKeyOpened) Begin
89607>>>>>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
89608>>>>>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
89609>>>>>>>                If (iDriverNames > 0) Begin
89611>>>>>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
89612>>>>>>>                    Decrement iDriverNames
89613>>>>>>>                    for iDriverName from 0 to iDriverNames
89619>>>>>>>>
89619>>>>>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
89620>>>>>>>                    Loop
89621>>>>>>>>
89621>>>>>>>                End
89621>>>>>>>>
89621>>>>>>>                Send CloseKey of hoRegistry
89622>>>>>>>            End
89622>>>>>>>>
89622>>>>>>>        End
89622>>>>>>>>
89622>>>>>>>        Send Destroy of hoRegistry
89623>>>>>>>
89623>>>>>>>        Function_Return sDrivers
89624>>>>>>>    End_Function
89625>>>>>>>
89625>>>>>>>    // DataFlex Embedded Database Data Types:
89625>>>>>>>    // Helper function for UtilEnumerateColumnTypes
89625>>>>>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
89627>>>>>>>        tColumnType[] ColumnType
89627>>>>>>>        tColumnType[] ColumnType
89628>>>>>>>        Integer i
89628>>>>>>>
89628>>>>>>>        Move DF_ASCII           to ColumnType[i].iSQLType
89629>>>>>>>        Move "ASCII"            to ColumnType[i].sSQLType
89630>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
89631>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
89632>>>>>>>        Move "254"              to ColumnType[i].sPrecision
89633>>>>>>>        Increment i
89634>>>>>>>
89634>>>>>>>        Move DF_BCD             to ColumnType[i].iSQLType
89635>>>>>>>        Move "Numeric"          to ColumnType[i].sSQLType
89636>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
89637>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
89638>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
89639>>>>>>>        Increment i
89640>>>>>>>
89640>>>>>>>        Move DF_DATE            to ColumnType[i].iSQLType
89641>>>>>>>        Move "Date"             to ColumnType[i].sSQLType
89642>>>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
89643>>>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
89644>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
89645>>>>>>>        Move True               to ColumnType[i].bCanEditSize
89646>>>>>>>        Increment i
89647>>>>>>>
89647>>>>>>>        Move DF_TEXT            to ColumnType[i].iSQLType
89648>>>>>>>        Move "Text"             to ColumnType[i].sSQLType
89649>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
89650>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
89651>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
89652>>>>>>>        Increment i
89653>>>>>>>
89653>>>>>>>        Move DF_BINARY          to ColumnType[i].iSQLType
89654>>>>>>>        Move "Binary"           to ColumnType[i].sSQLType
89655>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
89656>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
89657>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
89658>>>>>>>        Increment i
89659>>>>>>>
89659>>>>>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
89660>>>>>>>        Move "DateTime"         to ColumnType[i].sSQLType
89661>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
89662>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
89663>>>>>>>        Move "23"               to ColumnType[i].sPrecision
89664>>>>>>>        Move True               to ColumnType[i].bCanEditSize
89665>>>>>>>        Increment i
89666>>>>>>>
89666>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
89667>>>>>>>        Move "Overlap"          to ColumnType[i].sSQLType
89668>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
89669>>>>>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
89670>>>>>>>        Move "0.0"              to ColumnType[i].sPrecision
89671>>>>>>>
89671>>>>>>>        Function_Return ColumnType
89672>>>>>>>    End_Function
89673>>>>>>>
89673>>>>>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
89675>>>>>>>        tColumnType[] aColumnType
89675>>>>>>>        tColumnType[] aColumnType
89676>>>>>>>        Integer i
89676>>>>>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DB2_DRV_DriverDef.inc)
89676>>>>>>>>// Generated By The Database Update Framework
89676>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.1\bin\MSSQLDRV_DriverDef.xml
89676>>>>>>>>// Driver COLUMN DATA TYPES
89676>>>>>>>>//
89676>>>>>>>>// Created: 2019-07-18 18:57:13.935
89676>>>>>>>>
89676>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
89677>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
89678>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
89679>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89680>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
89681>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
89682>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
89683>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
89684>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
89685>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
89686>>>>>>>>            Increment i
89687>>>>>>>>
89687>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
89688>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
89689>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
89690>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89691>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
89692>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
89693>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
89694>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89695>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89696>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
89697>>>>>>>>            Increment i
89698>>>>>>>>
89698>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
89699>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
89700>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
89701>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89702>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
89703>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
89704>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
89705>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89706>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89707>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
89708>>>>>>>>            Increment i
89709>>>>>>>>
89709>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
89710>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
89711>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
89712>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89713>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
89714>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
89715>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
89716>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89717>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89718>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
89719>>>>>>>>            Increment i
89720>>>>>>>>
89720>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
89721>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
89722>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
89723>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89724>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
89725>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
89726>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
89727>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89728>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89729>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
89730>>>>>>>>            Increment i
89731>>>>>>>>
89731>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
89732>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
89733>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
89734>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89735>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
89736>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
89737>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
89738>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89739>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89740>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
89741>>>>>>>>            Increment i
89742>>>>>>>>
89742>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
89743>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
89744>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
89745>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89746>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
89747>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
89748>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
89749>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89750>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89751>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
89752>>>>>>>>            Increment i
89753>>>>>>>>
89753>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
89754>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
89755>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
89756>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89757>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
89758>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
89759>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
89760>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89761>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89762>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
89763>>>>>>>>            Increment i
89764>>>>>>>>
89764>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
89765>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
89766>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
89767>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89768>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
89769>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
89770>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
89771>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
89772>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
89773>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
89774>>>>>>>>            Increment i
89775>>>>>>>>
89775>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
89776>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
89777>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
89778>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89779>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
89780>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
89781>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
89782>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
89783>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
89784>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
89785>>>>>>>>            Increment i
89786>>>>>>>>
89786>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
89787>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
89788>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
89789>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89790>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
89791>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
89792>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
89793>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89794>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89795>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
89796>>>>>>>>            Increment i
89797>>>>>>>>
89797>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
89798>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
89799>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
89800>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89801>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
89802>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
89803>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
89804>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
89805>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
89806>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
89807>>>>>>>>            Increment i
89808>>>>>>>>
89808>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
89809>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
89810>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
89811>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89812>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
89813>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
89814>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
89815>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89816>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89817>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
89818>>>>>>>>            Increment i
89819>>>>>>>>
89819>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
89820>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
89821>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
89822>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89823>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
89824>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
89825>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
89826>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89827>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89828>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
89829>>>>>>>>            Increment i
89830>>>>>>>>
89830>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
89831>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
89832>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
89833>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89834>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
89835>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
89836>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
89837>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89838>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89839>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
89840>>>>>>>>            Increment i
89841>>>>>>>>
89841>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
89842>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
89843>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
89844>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89845>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
89846>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
89847>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
89848>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
89849>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
89850>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
89851>>>>>>>>            Increment i
89852>>>>>>>>
89852>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
89853>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
89854>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
89855>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89856>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
89857>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
89858>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
89859>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89860>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89861>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
89862>>>>>>>>            Increment i
89863>>>>>>>>
89863>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
89864>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
89865>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
89866>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89867>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
89868>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
89869>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
89870>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89871>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89872>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
89873>>>>>>>>            Increment i
89874>>>>>>>>
89874>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
89875>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
89876>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
89877>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89878>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
89879>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
89880>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
89881>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
89882>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
89883>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
89884>>>>>>>>            Increment i
89885>>>>>>>>
89885>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
89886>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
89887>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
89888>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89889>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
89890>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
89891>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
89892>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89893>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89894>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
89895>>>>>>>>            Increment i
89896>>>>>>>>
89896>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
89897>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
89898>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
89899>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89900>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
89901>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
89902>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
89903>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
89904>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
89905>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
89906>>>>>>>>            Increment i
89907>>>>>>>>
89907>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
89908>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
89909>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
89910>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89911>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
89912>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
89913>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
89914>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89915>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89916>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
89917>>>>>>>>            Increment i
89918>>>>>>>>
89918>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
89919>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
89920>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
89921>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89922>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
89923>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
89924>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
89925>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89926>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89927>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
89928>>>>>>>>            Increment i
89929>>>>>>>>
89929>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
89930>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
89931>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
89932>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89933>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
89934>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
89935>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
89936>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89937>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89938>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
89939>>>>>>>>            Increment i
89940>>>>>>>>
89940>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
89941>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
89942>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
89943>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89944>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
89945>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
89946>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
89947>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89948>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89949>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
89950>>>>>>>>            Increment i
89951>>>>>>>>
89951>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
89952>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
89953>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
89954>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89955>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
89956>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
89957>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
89958>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89959>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89960>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
89961>>>>>>>>            Increment i
89962>>>>>>>>
89962>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
89963>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
89964>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
89965>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89966>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
89967>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
89968>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
89969>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89970>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89971>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
89972>>>>>>>>            Increment i
89973>>>>>>>>
89973>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
89974>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
89975>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
89976>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89977>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
89978>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
89979>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
89980>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89981>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89982>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
89983>>>>>>>>            Increment i
89984>>>>>>>>
89984>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
89985>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
89986>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
89987>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89988>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
89989>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
89990>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
89991>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
89992>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
89993>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
89994>>>>>>>>            Increment i
89995>>>>>>>>
89995>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
89996>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
89997>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
89998>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
89999>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
90000>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90001>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
90002>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90003>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90004>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
90005>>>>>>>>            Increment i
90006>>>>>>>>
90006>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
90007>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
90008>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90009>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90010>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
90011>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90012>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
90013>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90014>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90015>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
90016>>>>>>>>            Increment i
90017>>>>>>>>
90017>>>>>>>>
90017>>>>>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
90017>>>>>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
90017>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
90017>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
90017>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
90017>>>>>>>//        Increment i
90017>>>>>>>//
90017>>>>>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
90017>>>>>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
90017>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
90017>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
90017>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
90017>>>>>>>//        Increment i
90017>>>>>>>//
90017>>>>>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
90017>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
90017>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
90017>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
90017>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
90017>>>>>>>//        Increment i
90017>>>>>>>//
90017>>>>>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
90017>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
90017>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
90017>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
90017>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
90017>>>>>>>//        Increment i
90017>>>>>>>//
90017>>>>>>>//        // ToDo: We need to change the sType when using this!
90017>>>>>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
90017>>>>>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
90017>>>>>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
90017>>>>>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
90017>>>>>>>//        Move "254"                  to ColumnType[i].sPrecision
90017>>>>>>>//        Increment i
90017>>>>>>>//
90017>>>>>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
90017>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
90017>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
90017>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
90017>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
90017>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
90017>>>>>>>//        Increment i
90017>>>>>>>//
90017>>>>>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
90017>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
90017>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
90017>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
90017>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
90017>>>>>>>//        Increment i
90017>>>>>>>//
90017>>>>>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
90017>>>>>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
90017>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
90017>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
90017>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
90017>>>>>>>//        Increment i
90017>>>>>>>//
90017>>>>>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
90017>>>>>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
90017>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
90017>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
90017>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
90017>>>>>>>//        Increment i
90017>>>>>>>//
90017>>>>>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
90017>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
90017>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
90017>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
90017>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
90017>>>>>>>//        Increment i
90017>>>>>>>//
90017>>>>>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
90017>>>>>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
90017>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
90017>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
90017>>>>>>>//        Move "255"              to ColumnType[i].sPrecision
90017>>>>>>>//        Increment i
90017>>>>>>>//
90017>>>>>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
90017>>>>>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
90017>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
90017>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
90017>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
90017>>>>>>>//        Increment i
90017>>>>>>>//
90017>>>>>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
90017>>>>>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
90017>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
90017>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
90017>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
90017>>>>>>>//        Increment i
90017>>>>>>>//
90017>>>>>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
90017>>>>>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
90017>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
90017>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
90017>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
90017>>>>>>>//        Increment i
90017>>>>>>>//
90017>>>>>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
90017>>>>>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
90017>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
90017>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
90017>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
90017>>>>>>>//        Increment i
90017>>>>>>>//
90017>>>>>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
90017>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
90017>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
90017>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
90017>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
90017>>>>>>>//        Increment i
90017>>>>>>>//
90017>>>>>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
90017>>>>>>>//        Move "REAL"             to ColumnType[i].sSQLType
90017>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
90017>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
90017>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
90017>>>>>>>//        Increment i
90017>>>>>>>//
90017>>>>>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
90017>>>>>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
90017>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
90017>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
90017>>>>>>>//        Move "5.0"              to ColumnType[i].sPrecision
90017>>>>>>>//        Increment i
90017>>>>>>>//
90017>>>>>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
90017>>>>>>>//        Move "TIME"             to ColumnType[i].sSQLType
90017>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
90017>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
90017>>>>>>>//        Move "19.0"             to ColumnType[i].sPrecision
90017>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
90017>>>>>>>//        Increment i
90017>>>>>>>//
90017>>>>>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
90017>>>>>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
90017>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
90017>>>>>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
90017>>>>>>>//        Move "23.6"             to ColumnType[i].sPrecision
90017>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
90017>>>>>>>//        Increment i
90017>>>>>>>//
90017>>>>>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
90017>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
90017>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
90017>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
90017>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
90017>>>>>>>//        Increment i
90017>>>>>>>//
90017>>>>>>>//        // ToDo: We need to change the sType when using this!
90017>>>>>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
90017>>>>>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
90017>>>>>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
90017>>>>>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
90017>>>>>>>//        Move "16384"                to ColumnType[i].sPrecision
90017>>>>>>>//        Increment i
90017>>>>>>>//
90017>>>>>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
90017>>>>>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
90017>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
90017>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
90017>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
90017>>>>>>>//
90017>>>>>>>//        Move SQL_XML            to ColumnType[i].iSQLType
90017>>>>>>>//        Move "XML"              to ColumnType[i].sSQLType
90017>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
90017>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
90017>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
90017>>>>>>>
90017>>>>>>>        Function_Return aColumnType
90018>>>>>>>    End_Function
90019>>>>>>>
90019>>>>>>>    // Microsoft SQL Server Database Data Types:
90019>>>>>>>    // Helper function for UtilEnumerateColumnTypes
90019>>>>>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
90021>>>>>>>        tColumnType[] aColumnType
90021>>>>>>>        tColumnType[] aColumnType
90022>>>>>>>        Integer i
90022>>>>>>>
90022>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSQLDRV_DriverDef.inc)
90024>>>>>>>>// Generated By The Database Update Framework
90024>>>>>>>>// Driver XML File: C:\Program Files\DataFlex 20.0\Lib\MSSQLDRV_DriverDef.xml
90024>>>>>>>>// Driver COLUMN DATA TYPES
90024>>>>>>>>//
90024>>>>>>>>// Created: 2019-11-15 21:57:51.001
90024>>>>>>>>
90024>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
90025>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
90026>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90027>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90028>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
90029>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90030>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
90031>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90032>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90033>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
90034>>>>>>>>            Increment i
90035>>>>>>>>
90035>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
90036>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
90037>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90038>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90039>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
90040>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90041>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
90042>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
90043>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
90044>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
90045>>>>>>>>            Increment i
90046>>>>>>>>
90046>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
90047>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
90048>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
90049>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90050>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
90051>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
90052>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
90053>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90054>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90055>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
90056>>>>>>>>            Increment i
90057>>>>>>>>
90057>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
90058>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
90059>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90060>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90061>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
90062>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90063>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
90064>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90065>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90066>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
90067>>>>>>>>            Increment i
90068>>>>>>>>
90068>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
90069>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
90070>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
90071>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90072>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
90073>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
90074>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
90075>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
90076>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
90077>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
90078>>>>>>>>            Increment i
90079>>>>>>>>
90079>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
90080>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
90081>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
90082>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90083>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
90084>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
90085>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
90086>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
90087>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
90088>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
90089>>>>>>>>            Increment i
90090>>>>>>>>
90090>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
90091>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
90092>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90093>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90094>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
90095>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
90096>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
90097>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
90098>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
90099>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
90100>>>>>>>>            Increment i
90101>>>>>>>>
90101>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
90102>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
90103>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90104>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90105>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
90106>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
90107>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
90108>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
90109>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
90110>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
90111>>>>>>>>            Increment i
90112>>>>>>>>
90112>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
90113>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
90114>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90115>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90116>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
90117>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90118>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
90119>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90120>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90121>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
90122>>>>>>>>            Increment i
90123>>>>>>>>
90123>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
90124>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
90125>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90126>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90127>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
90128>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90129>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
90130>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90131>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90132>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
90133>>>>>>>>            Increment i
90134>>>>>>>>
90134>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
90135>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
90136>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90137>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90138>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
90139>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90140>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
90141>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
90142>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
90143>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
90144>>>>>>>>            Increment i
90145>>>>>>>>
90145>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
90146>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
90147>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90148>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90149>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
90150>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90151>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
90152>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90153>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90154>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
90155>>>>>>>>            Increment i
90156>>>>>>>>
90156>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
90157>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
90158>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
90159>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90160>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
90161>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
90162>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
90163>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90164>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90165>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
90166>>>>>>>>            Increment i
90167>>>>>>>>
90167>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
90168>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
90169>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90170>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90171>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
90172>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90173>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
90174>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90175>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90176>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
90177>>>>>>>>            Increment i
90178>>>>>>>>
90178>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
90179>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
90180>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90181>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90182>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
90183>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90184>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
90185>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
90186>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
90187>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
90188>>>>>>>>            Increment i
90189>>>>>>>>
90189>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
90190>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
90191>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90192>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90193>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
90194>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90195>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
90196>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90197>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90198>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
90199>>>>>>>>            Increment i
90200>>>>>>>>
90200>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
90201>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
90202>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90203>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90204>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
90205>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90206>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
90207>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90208>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90209>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
90210>>>>>>>>            Increment i
90211>>>>>>>>
90211>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
90212>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
90213>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90214>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90215>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
90216>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90217>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
90218>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90219>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90220>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
90221>>>>>>>>            Increment i
90222>>>>>>>>
90222>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
90223>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
90224>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90225>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90226>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
90227>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90228>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
90229>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90230>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90231>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
90232>>>>>>>>            Increment i
90233>>>>>>>>
90233>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
90234>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
90235>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
90236>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90237>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
90238>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
90239>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
90240>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
90241>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
90242>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
90243>>>>>>>>            Increment i
90244>>>>>>>>
90244>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
90245>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
90246>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90247>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90248>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
90249>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90250>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
90251>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90252>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90253>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
90254>>>>>>>>            Increment i
90255>>>>>>>>
90255>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
90256>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
90257>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
90258>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90259>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
90260>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
90261>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
90262>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90263>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90264>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
90265>>>>>>>>            Increment i
90266>>>>>>>>
90266>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
90267>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
90268>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90269>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90270>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
90271>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90272>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
90273>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
90274>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
90275>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
90276>>>>>>>>            Increment i
90277>>>>>>>>
90277>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
90278>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
90279>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90280>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90281>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
90282>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
90283>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
90284>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90285>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90286>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
90287>>>>>>>>            Increment i
90288>>>>>>>>
90288>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
90289>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
90290>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90291>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90292>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
90293>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90294>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
90295>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90296>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90297>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
90298>>>>>>>>            Increment i
90299>>>>>>>>
90299>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
90300>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
90301>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
90302>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90303>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
90304>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
90305>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
90306>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90307>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90308>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
90309>>>>>>>>            Increment i
90310>>>>>>>>
90310>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
90311>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
90312>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90313>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90314>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
90315>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90316>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
90317>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
90318>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
90319>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
90320>>>>>>>>            Increment i
90321>>>>>>>>
90321>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
90322>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
90323>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90324>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90325>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
90326>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90327>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
90328>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90329>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90330>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
90331>>>>>>>>            Increment i
90332>>>>>>>>
90332>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
90333>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
90334>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90335>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90336>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
90337>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90338>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
90339>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90340>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90341>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
90342>>>>>>>>            Increment i
90343>>>>>>>>
90343>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
90344>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
90345>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90346>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90347>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
90348>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90349>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
90350>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
90351>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
90352>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
90353>>>>>>>>            Increment i
90354>>>>>>>>
90354>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
90355>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
90356>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90357>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90358>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
90359>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90360>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
90361>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
90362>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
90363>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
90364>>>>>>>>            Increment i
90365>>>>>>>>
90365>>>>>>>>
90365>>>>>>>
90365>>>>>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
90365>>>>>>>//            Move "bigint"           to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
90365>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
90365>>>>>>>//            Move "binary"           to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
90365>>>>>>>//            Move "bit"              to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
90365>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
90365>>>>>>>//            Move "char"             to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
90365>>>>>>>//            Move "date"             to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
90365>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
90365>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "23.3"             to ColumnType[i].sPrecision
90365>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
90365>>>>>>>//            Move "datetime2"         to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "23.6"              to ColumnType[i].sPrecision
90365>>>>>>>//            Move True                to ColumnType[i].bCanEditSize
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
90365>>>>>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "34.0"                 to ColumnType[i].sPrecision
90365>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
90365>>>>>>>//            Move "decimal"          to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
90365>>>>>>>//            Move "float"            to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
90365>>>>>>>//            Move "int"              to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "8.0"              to ColumnType[i].sPrecision
90365>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
90365>>>>>>>//            Move "money"            to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
90365>>>>>>>//            Move "nchar"            to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
90365>>>>>>>//            Move "ntext"            to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
90365>>>>>>>//            Move "numeric"          to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
90365>>>>>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
90365>>>>>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
90365>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
90365>>>>>>>//            Move "real"             to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
90365>>>>>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "23.0"                 to ColumnType[i].sPrecision
90365>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
90365>>>>>>>//            Move "smallint"         to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "4.0"              to ColumnType[i].sPrecision
90365>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
90365>>>>>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "10.0"              to ColumnType[i].sPrecision
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
90365>>>>>>>//            Move "text"             to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
90365>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
90365>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "19.0"             to ColumnType[i].sPrecision
90365>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
90365>>>>>>>//            Move "tinyint"          to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "2.0"              to ColumnType[i].sPrecision
90365>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
90365>>>>>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "36"               to ColumnType[i].sPrecision
90365>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
90365>>>>>>>//            Move "varbinary"        to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
90365>>>>>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
90365>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
90365>>>>>>>//            Move "varchar"          to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
90365>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
90365>>>>>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
90365>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
90365>>>>>>>//            Move "xml"              to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
90365>>>>>>>//            Move "DATE"             to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "date"             to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
90365>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
90365>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "8.7"              to ColumnType[i].sPrecision
90365>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
90365>>>>>>>//            Increment i
90365>>>>>>>//
90365>>>>>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
90365>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
90365>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
90365>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
90365>>>>>>>//            Move "23.6"             to ColumnType[i].sPrecision
90365>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
90365>>>>>>>//            Increment i
90365>>>>>>>
90365>>>>>>>        End
90365>>>>>>>>
90365>>>>>>>
90365>>>>>>>        // Mertech SQLFlex driver
90365>>>>>>>        If (sDriverID = SQLFLEX) Begin
90367>>>>>>>
Including file: sql_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\sql_drv_DriverDef.inc)
90367>>>>>>>>// Generated By The Database Update Framework
90367>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\sql_drv_DriverDef.xml
90367>>>>>>>>// Driver COLUMN DATA TYPES
90367>>>>>>>>//
90367>>>>>>>>// Created: 2018-03-14 23:47:46.885
90367>>>>>>>>
90367>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
90368>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
90369>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90370>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90371>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
90372>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90373>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
90374>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90375>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90376>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
90377>>>>>>>>            Increment i
90378>>>>>>>>
90378>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
90379>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
90380>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90381>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90382>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
90383>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90384>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
90385>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
90386>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
90387>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
90388>>>>>>>>            Increment i
90389>>>>>>>>
90389>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
90390>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
90391>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
90392>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90393>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
90394>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
90395>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
90396>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90397>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90398>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
90399>>>>>>>>            Increment i
90400>>>>>>>>
90400>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
90401>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
90402>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90403>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90404>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
90405>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90406>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
90407>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90408>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90409>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
90410>>>>>>>>            Increment i
90411>>>>>>>>
90411>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
90412>>>>>>>>            Move 40                                      to aColumnType[i].iSQLType
90413>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
90414>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90415>>>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
90416>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
90417>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
90418>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90419>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90420>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
90421>>>>>>>>            Increment i
90422>>>>>>>>
90422>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
90423>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
90424>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90425>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90426>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
90427>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
90428>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
90429>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90430>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90431>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
90432>>>>>>>>            Increment i
90433>>>>>>>>
90433>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
90434>>>>>>>>            Move 42                                      to aColumnType[i].iSQLType
90435>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90436>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90437>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
90438>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
90439>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
90440>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90441>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90442>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
90443>>>>>>>>            Increment i
90444>>>>>>>>
90444>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
90445>>>>>>>>            Move 43                                      to aColumnType[i].iSQLType
90446>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90447>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90448>>>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
90449>>>>>>>>            Move 12                                      to aColumnType[i].iMinSize
90450>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
90451>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90452>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90453>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
90454>>>>>>>>            Increment i
90455>>>>>>>>
90455>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
90456>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
90457>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90458>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90459>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
90460>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90461>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
90462>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90463>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90464>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
90465>>>>>>>>            Increment i
90466>>>>>>>>
90466>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
90467>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
90468>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90469>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90470>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
90471>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90472>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
90473>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90474>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90475>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
90476>>>>>>>>            Increment i
90477>>>>>>>>
90477>>>>>>>>            Move "geography"                             to aColumnType[i].sSQLType
90478>>>>>>>>            Move 130                                     to aColumnType[i].iSQLType
90479>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
90480>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90481>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90482>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
90483>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
90484>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90485>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90486>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
90487>>>>>>>>            Increment i
90488>>>>>>>>
90488>>>>>>>>            Move "geometry"                              to aColumnType[i].sSQLType
90489>>>>>>>>            Move 129                                     to aColumnType[i].iSQLType
90490>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
90491>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90492>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90493>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
90494>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
90495>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90496>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90497>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
90498>>>>>>>>            Increment i
90499>>>>>>>>
90499>>>>>>>>            Move "hierarchyid"                           to aColumnType[i].sSQLType
90500>>>>>>>>            Move 128                                     to aColumnType[i].iSQLType
90501>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
90502>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90503>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90504>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
90505>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
90506>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90507>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90508>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
90509>>>>>>>>            Increment i
90510>>>>>>>>
90510>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
90511>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
90512>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90513>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90514>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90515>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90516>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90517>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
90518>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
90519>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
90520>>>>>>>>            Increment i
90521>>>>>>>>
90521>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
90522>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
90523>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90524>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90525>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
90526>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90527>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
90528>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90529>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90530>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
90531>>>>>>>>            Increment i
90532>>>>>>>>
90532>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
90533>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
90534>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90535>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90536>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
90537>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90538>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
90539>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90540>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90541>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
90542>>>>>>>>            Increment i
90543>>>>>>>>
90543>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
90544>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
90545>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90546>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90547>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90548>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90549>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90550>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
90551>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
90552>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
90553>>>>>>>>            Increment i
90554>>>>>>>>
90554>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
90555>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
90556>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90557>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90558>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
90559>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90560>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
90561>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90562>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90563>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
90564>>>>>>>>            Increment i
90565>>>>>>>>
90565>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
90566>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
90567>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90568>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90569>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
90570>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90571>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
90572>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90573>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90574>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
90575>>>>>>>>            Increment i
90576>>>>>>>>
90576>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
90577>>>>>>>>            Move -100                                    to aColumnType[i].iSQLType
90578>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90579>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90580>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90581>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90582>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90583>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90584>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90585>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
90586>>>>>>>>            Increment i
90587>>>>>>>>
90587>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
90588>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
90589>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90590>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90591>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
90592>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90593>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
90594>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90595>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90596>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
90597>>>>>>>>            Increment i
90598>>>>>>>>
90598>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
90599>>>>>>>>            Move 58                                      to aColumnType[i].iSQLType
90600>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90601>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90602>>>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
90603>>>>>>>>            Move 12                                      to aColumnType[i].iMinSize
90604>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
90605>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90606>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90607>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
90608>>>>>>>>            Increment i
90609>>>>>>>>
90609>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
90610>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
90611>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90612>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90613>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
90614>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
90615>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
90616>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90617>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90618>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
90619>>>>>>>>            Increment i
90620>>>>>>>>
90620>>>>>>>>            Move "sql_variant"                           to aColumnType[i].sSQLType
90621>>>>>>>>            Move -150                                    to aColumnType[i].iSQLType
90622>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
90623>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90624>>>>>>>>            Move 8016                                    to aColumnType[i].iDefaultSize
90625>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
90626>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
90627>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90628>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90629>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
90630>>>>>>>>            Increment i
90631>>>>>>>>
90631>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
90632>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
90633>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90634>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90635>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90636>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90637>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90638>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
90639>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
90640>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
90641>>>>>>>>            Increment i
90642>>>>>>>>
90642>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
90643>>>>>>>>            Move 41                                      to aColumnType[i].iSQLType
90644>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90645>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90646>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
90647>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
90648>>>>>>>>            Move 16                                      to aColumnType[i].nMaxSize
90649>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90650>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90651>>>>>>>>            Move 16                                      to aColumnType[i].sPrecision
90652>>>>>>>>            Increment i
90653>>>>>>>>
90653>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
90654>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
90655>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
90656>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90657>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
90658>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
90659>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
90660>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
90661>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
90662>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
90663>>>>>>>>            Increment i
90664>>>>>>>>
90664>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
90665>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
90666>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90667>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90668>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
90669>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
90670>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
90671>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90672>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90673>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
90674>>>>>>>>            Increment i
90675>>>>>>>>
90675>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
90676>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
90677>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
90678>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90679>>>>>>>>            Move 38                                      to aColumnType[i].iDefaultSize
90680>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
90681>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
90682>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90683>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90684>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
90685>>>>>>>>            Increment i
90686>>>>>>>>
90686>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
90687>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
90688>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90689>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90690>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
90691>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90692>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
90693>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
90694>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
90695>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
90696>>>>>>>>            Increment i
90697>>>>>>>>
90697>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
90698>>>>>>>>            Move -98                                     to aColumnType[i].iSQLType
90699>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90700>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90701>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90702>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90703>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90704>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90705>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90706>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
90707>>>>>>>>            Increment i
90708>>>>>>>>
90708>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
90709>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
90710>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90711>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90712>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
90713>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90714>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
90715>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90716>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90717>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
90718>>>>>>>>            Increment i
90719>>>>>>>>
90719>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
90720>>>>>>>>            Move -99                                     to aColumnType[i].iSQLType
90721>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90722>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90723>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90724>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90725>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90726>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90727>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90728>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
90729>>>>>>>>            Increment i
90730>>>>>>>>
90730>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
90731>>>>>>>>            Move -370                                    to aColumnType[i].iSQLType
90732>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90733>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90734>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90735>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90736>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90737>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90738>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90739>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
90740>>>>>>>>            Increment i
90741>>>>>>>>
90741>>>>>>>>
90741>>>>>>>
90741>>>>>>>//            Move eSQLServer_BIGINT  to ColumnType[i].iSQLType
90741>>>>>>>//            Move "BigInt"           to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
90741>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_BINARY  to ColumnType[i].iSQLType
90741>>>>>>>//            Move "Binary"           to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_BIT     to ColumnType[i].iSQLType
90741>>>>>>>//            Move "Bit"              to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision
90741>>>>>>>//            Move True               to ColumnType[i].bCanEditSize // In SQL allows 1, 0, or "NULL"
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_CHAR    to ColumnType[i].iSQLType
90741>>>>>>>//            Move "Char"             to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_DATE    to ColumnType[i].iSQLType
90741>>>>>>>//            Move "Date"             to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
90741>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_DATETIME    to ColumnType[i].iSQLType
90741>>>>>>>//            Move "DateTime"             to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "23.3"                 to ColumnType[i].sPrecision
90741>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_DATETIME2   to ColumnType[i].iSQLType
90741>>>>>>>//            Move "DateTime2"            to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "23.6"                 to ColumnType[i].sPrecision
90741>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_DATETIMEOFFSET  to ColumnType[i].iSQLType
90741>>>>>>>//            Move "DateTimeOffest"           to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "DateTime"                 to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "23.0"                     to ColumnType[i].sPrecision
90741>>>>>>>//            Move True                       to ColumnType[i].bCanEditSize
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_DECIMAL to ColumnType[i].iSQLType
90741>>>>>>>//            Move "Decimal"          to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_DOUBLE  to ColumnType[i].iSQLType
90741>>>>>>>//            Move "Double"           to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_FLOAT   to ColumnType[i].iSQLType
90741>>>>>>>//            Move "Float"            to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_INT     to ColumnType[i].iSQLType
90741>>>>>>>//            Move "Int"              to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "11.0"             to ColumnType[i].sPrecision
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_NCHAR   to ColumnType[i].iSQLType
90741>>>>>>>//            Move "Nchar"            to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_NTEXT   to ColumnType[i].iSQLType
90741>>>>>>>//            Move "Ntext"            to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_NUMERIC to ColumnType[i].iSQLType
90741>>>>>>>//            Move "Numeric"          to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_NVARCHAR    to ColumnType[i].iSQLType
90741>>>>>>>//            Move "NvarChar"             to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "4000"                 to ColumnType[i].sPrecision
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_NVARCHARMAX to ColumnType[i].iSQLType
90741>>>>>>>//            Move "NvarCharMax"          to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "16384"                to ColumnType[i].sPrecision
90741>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_REAL    to ColumnType[i].iSQLType
90741>>>>>>>//            Move "Real"             to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_SMALLDATETIME   to ColumnType[i].iSQLType
90741>>>>>>>//            Move "SmallDateTime"            to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "DATETIME"                 to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "23.0"                     to ColumnType[i].sPrecision
90741>>>>>>>//            Move True                       to ColumnType[i].bCanEditSize
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_SMALLINT    to ColumnType[i].iSQLType
90741>>>>>>>//            Move "SmallInt"             to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_BCD                 to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "NUMERIC"              to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "6.0"                  to ColumnType[i].sPrecision
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_TEXT    to ColumnType[i].iSQLType
90741>>>>>>>//            Move "Text"             to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
90741>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_TIME    to ColumnType[i].iSQLType
90741>>>>>>>//            Move "Time"             to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "16.0"             to ColumnType[i].sPrecision
90741>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_TIMESTAMP   to ColumnType[i].iSQLType
90741>>>>>>>//            Move "TimeStamp"            to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_ASCII               to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "8.0"                  to ColumnType[i].sPrecision
90741>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_TINYINT to ColumnType[i].iSQLType
90741>>>>>>>//            Move "TinyInt"          to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "3.0"              to ColumnType[i].sPrecision
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_GUID    to ColumnType[i].iSQLType
90741>>>>>>>//            Move "UniqueIdentifier" to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "38"               to ColumnType[i].sPrecision
90741>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_VARBINARY   to ColumnType[i].iSQLType
90741>>>>>>>//            Move "VarBinary"            to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "BINARY"               to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "8000"                 to ColumnType[i].sPrecision
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_VARBINARYMAX to ColumnType[i].iSQLType
90741>>>>>>>//            Move "VarBinary(Max)"        to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_BINARY               to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "BINARY"                to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "16384"                 to ColumnType[i].sPrecision
90741>>>>>>>//            Move True                    to ColumnType[i].bCanEditSize
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_VARCHAR to ColumnType[i].iSQLType
90741>>>>>>>//            Move "VarChar"          to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
90741>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_VARCHARMAX  to ColumnType[i].iSQLType
90741>>>>>>>//            Move "VarChar(Max)"         to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "TEXT"                 to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "16384"                to ColumnType[i].sPrecision
90741>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_SQLVARIANT  to ColumnType[i].iSQLType
90741>>>>>>>//            Move "SQL_Variant"          to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "Binary"               to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "8016"                 to ColumnType[i].sPrecision
90741>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
90741>>>>>>>//            Increment i
90741>>>>>>>//
90741>>>>>>>//            Move eSQLServer_XML     to ColumnType[i].iSQLType
90741>>>>>>>//            Move "XML"              to ColumnType[i].sSQLType
90741>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
90741>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
90741>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
90741>>>>>>>        End
90741>>>>>>>>
90741>>>>>>>
90741>>>>>>>        Function_Return aColumnType
90742>>>>>>>    End_Function
90743>>>>>>>
90743>>>>>>>    // MySQL Data Types
90743>>>>>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
90745>>>>>>>        tColumnType[] aColumnType
90745>>>>>>>        tColumnType[] aColumnType
90746>>>>>>>        Integer i
90746>>>>>>>
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdsmysql_DriverDef.inc)
90746>>>>>>>>// Generated By The Database Update Framework
90746>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
90746>>>>>>>>// Driver COLUMN DATA TYPES
90746>>>>>>>>//
90746>>>>>>>>// Created: 2018-03-14 23:46:49.593
90746>>>>>>>>
90746>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
90747>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
90748>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90749>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90750>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
90751>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90752>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
90753>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90754>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90755>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
90756>>>>>>>>            Increment i
90757>>>>>>>>
90757>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
90758>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
90759>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90760>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90761>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
90762>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
90763>>>>>>>>            Move 64                                      to aColumnType[i].nMaxSize
90764>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90765>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90766>>>>>>>>            Move 64                                      to aColumnType[i].sPrecision
90767>>>>>>>>            Increment i
90768>>>>>>>>
90768>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
90769>>>>>>>>            Move 252                                     to aColumnType[i].iSQLType
90770>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90771>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90772>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90773>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90774>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90775>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
90776>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
90777>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
90778>>>>>>>>            Increment i
90779>>>>>>>>
90779>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
90780>>>>>>>>            Move 254                                     to aColumnType[i].iSQLType
90781>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90782>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90783>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
90784>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90785>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
90786>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90787>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90788>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
90789>>>>>>>>            Increment i
90790>>>>>>>>
90790>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
90791>>>>>>>>            Move 10                                      to aColumnType[i].iSQLType
90792>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
90793>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90794>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
90795>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
90796>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
90797>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
90798>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
90799>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
90800>>>>>>>>            Increment i
90801>>>>>>>>
90801>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
90802>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
90803>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90804>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90805>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
90806>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
90807>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
90808>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
90809>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
90810>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
90811>>>>>>>>            Increment i
90812>>>>>>>>
90812>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
90813>>>>>>>>            Move 246                                     to aColumnType[i].iSQLType
90814>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90815>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90816>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
90817>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
90818>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
90819>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90820>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90821>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
90822>>>>>>>>            Increment i
90823>>>>>>>>
90823>>>>>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
90824>>>>>>>>            Move 0                                       to aColumnType[i].iSQLType
90825>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90826>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90827>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
90828>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
90829>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
90830>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90831>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90832>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
90833>>>>>>>>            Increment i
90834>>>>>>>>
90834>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
90835>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
90836>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90837>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90838>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
90839>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
90840>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
90841>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90842>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90843>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
90844>>>>>>>>            Increment i
90845>>>>>>>>
90845>>>>>>>>            Move "enum"                                  to aColumnType[i].sSQLType
90846>>>>>>>>            Move 247                                     to aColumnType[i].iSQLType
90847>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90848>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90849>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
90850>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
90851>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
90852>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90853>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90854>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
90855>>>>>>>>            Increment i
90856>>>>>>>>
90856>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
90857>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
90858>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90859>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90860>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
90861>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
90862>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
90863>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90864>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90865>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
90866>>>>>>>>            Increment i
90867>>>>>>>>
90867>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
90868>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
90869>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90870>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90871>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
90872>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
90873>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
90874>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90875>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90876>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
90877>>>>>>>>            Increment i
90878>>>>>>>>
90878>>>>>>>>            Move "longblob"                              to aColumnType[i].sSQLType
90879>>>>>>>>            Move 251                                     to aColumnType[i].iSQLType
90880>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90881>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90882>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90883>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90884>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90885>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
90886>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
90887>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
90888>>>>>>>>            Increment i
90889>>>>>>>>
90889>>>>>>>>            Move "longtext"                              to aColumnType[i].sSQLType
90890>>>>>>>>            Move -251                                    to aColumnType[i].iSQLType
90891>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90892>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90893>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90894>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90895>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90896>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
90897>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
90898>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
90899>>>>>>>>            Increment i
90900>>>>>>>>
90900>>>>>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
90901>>>>>>>>            Move 250                                     to aColumnType[i].iSQLType
90902>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90903>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90904>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90905>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90906>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90907>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
90908>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
90909>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
90910>>>>>>>>            Increment i
90911>>>>>>>>
90911>>>>>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
90912>>>>>>>>            Move 9                                       to aColumnType[i].iSQLType
90913>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90914>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90915>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
90916>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90917>>>>>>>>            Move 9                                       to aColumnType[i].nMaxSize
90918>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90919>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90920>>>>>>>>            Move 9                                       to aColumnType[i].sPrecision
90921>>>>>>>>            Increment i
90922>>>>>>>>
90922>>>>>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
90923>>>>>>>>            Move -250                                    to aColumnType[i].iSQLType
90924>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90925>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90926>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90927>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90928>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90929>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
90930>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
90931>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
90932>>>>>>>>            Increment i
90933>>>>>>>>
90933>>>>>>>>            Move "set"                                   to aColumnType[i].sSQLType
90934>>>>>>>>            Move 248                                     to aColumnType[i].iSQLType
90935>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90936>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90937>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
90938>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
90939>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
90940>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90941>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90942>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
90943>>>>>>>>            Increment i
90944>>>>>>>>
90944>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
90945>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
90946>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90947>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90948>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
90949>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90950>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
90951>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
90952>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
90953>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
90954>>>>>>>>            Increment i
90955>>>>>>>>
90955>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
90956>>>>>>>>            Move -252                                    to aColumnType[i].iSQLType
90957>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90958>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90959>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
90960>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90961>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
90962>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
90963>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
90964>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
90965>>>>>>>>            Increment i
90966>>>>>>>>
90966>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
90967>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
90968>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
90969>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90970>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
90971>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
90972>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
90973>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
90974>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
90975>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
90976>>>>>>>>            Increment i
90977>>>>>>>>
90977>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
90978>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
90979>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90980>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90981>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
90982>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
90983>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
90984>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
90985>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
90986>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
90987>>>>>>>>            Increment i
90988>>>>>>>>
90988>>>>>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
90989>>>>>>>>            Move 249                                     to aColumnType[i].iSQLType
90990>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
90991>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
90992>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
90993>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
90994>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
90995>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
90996>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
90997>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
90998>>>>>>>>            Increment i
90999>>>>>>>>
90999>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
91000>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
91001>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91002>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91003>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
91004>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91005>>>>>>>>            Move 4                                       to aColumnType[i].nMaxSize
91006>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
91007>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
91008>>>>>>>>            Move 4                                       to aColumnType[i].sPrecision
91009>>>>>>>>            Increment i
91010>>>>>>>>
91010>>>>>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
91011>>>>>>>>            Move -249                                    to aColumnType[i].iSQLType
91012>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91013>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91014>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
91015>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91016>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
91017>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91018>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91019>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
91020>>>>>>>>            Increment i
91021>>>>>>>>
91021>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
91022>>>>>>>>            Move 253                                     to aColumnType[i].iSQLType
91023>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91024>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91025>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
91026>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
91027>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
91028>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91029>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91030>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
91031>>>>>>>>            Increment i
91032>>>>>>>>
91032>>>>>>>>            Move "year"                                  to aColumnType[i].sSQLType
91033>>>>>>>>            Move 13                                      to aColumnType[i].iSQLType
91034>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
91035>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91036>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
91037>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
91038>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
91039>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
91040>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
91041>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
91042>>>>>>>>            Increment i
91043>>>>>>>>
91043>>>>>>>>
91043>>>>>>>
91043>>>>>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
91043>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
91043>>>>>>>//        Increment i
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
91043>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
91043>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
91043>>>>>>>//        Increment i
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
91043>>>>>>>//        Move "blob"             to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
91043>>>>>>>//        Increment i
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
91043>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
91043>>>>>>>//        Increment i
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
91043>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
91043>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
91043>>>>>>>//        Increment i
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
91043>>>>>>>//        Move "datetime"         to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
91043>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
91043>>>>>>>//        Increment i
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
91043>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
91043>>>>>>>//        Increment i
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
91043>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
91043>>>>>>>//        Increment i
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
91043>>>>>>>//        Move "enum"             to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
91043>>>>>>>//        Increment i
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
91043>>>>>>>//        Move "float"            to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
91043>>>>>>>//        Increment i
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
91043>>>>>>>//        Move "int"              to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
91043>>>>>>>//        Increment i
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
91043>>>>>>>//        Move "longblob"         to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
91043>>>>>>>//        Increment i
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
91043>>>>>>>//        Move "longtext"         to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
91043>>>>>>>//        Increment i
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
91043>>>>>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
91043>>>>>>>//        Increment i
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
91043>>>>>>>//        Move "mediumint"        to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
91043>>>>>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
91043>>>>>>>//        Increment i
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
91043>>>>>>>//        Move "set"              to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
91043>>>>>>>//        Increment i
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
91043>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
91043>>>>>>>//        Increment i
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
91043>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
91043>>>>>>>//        Increment i
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
91043>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "10.0"             to ColumnType[i].sPrecision
91043>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
91043>>>>>>>//        Increment i
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
91043>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
91043>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
91043>>>>>>>//        Increment i
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
91043>>>>>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
91043>>>>>>>//        Increment i
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
91043>>>>>>>//        Move "tinyint"          to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
91043>>>>>>>//        Increment i
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
91043>>>>>>>//        Move "tinytext"         to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
91043>>>>>>>//        Increment i
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
91043>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
91043>>>>>>>//        Increment i
91043>>>>>>>//
91043>>>>>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
91043>>>>>>>//        Move "year"             to ColumnType[i].sSQLType
91043>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91043>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
91043>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
91043>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
91043>>>>>>>//        Increment i
91043>>>>>>>
91043>>>>>>>        Function_Return aColumnType
91044>>>>>>>    End_Function
91045>>>>>>>
91045>>>>>>>    // Oracle Data Types
91045>>>>>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
91047>>>>>>>        tColumnType[] aColumnType
91047>>>>>>>        tColumnType[] aColumnType
91048>>>>>>>        Integer i
91048>>>>>>>
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ora_drv_DriverDef.inc)
91048>>>>>>>>// Generated By The Database Update Framework
91048>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
91048>>>>>>>>// Driver COLUMN DATA TYPES
91048>>>>>>>>//
91048>>>>>>>>// Created: 2018-03-14 23:47:34.82
91048>>>>>>>>
91048>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
91049>>>>>>>>            Move 113                                     to aColumnType[i].iSQLType
91050>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91051>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91052>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
91053>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91054>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
91055>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
91056>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
91057>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
91058>>>>>>>>            Increment i
91059>>>>>>>>
91059>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
91060>>>>>>>>            Move 96                                      to aColumnType[i].iSQLType
91061>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91062>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91063>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91064>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91065>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
91066>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91067>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91068>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
91069>>>>>>>>            Increment i
91070>>>>>>>>
91070>>>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
91071>>>>>>>>            Move 112                                     to aColumnType[i].iSQLType
91072>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91073>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91074>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
91075>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91076>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
91077>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
91078>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
91079>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
91080>>>>>>>>            Increment i
91081>>>>>>>>
91081>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
91082>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
91083>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91084>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91085>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
91086>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
91087>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
91088>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
91089>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
91090>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
91091>>>>>>>>            Increment i
91092>>>>>>>>
91092>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
91093>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
91094>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91095>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91096>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91097>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91098>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
91099>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
91100>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
91101>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
91102>>>>>>>>            Increment i
91103>>>>>>>>
91103>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
91104>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
91105>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91106>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91107>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
91108>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91109>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
91110>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
91111>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
91112>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
91113>>>>>>>>            Increment i
91114>>>>>>>>
91114>>>>>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
91115>>>>>>>>            Move 190                                     to aColumnType[i].iSQLType
91116>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
91117>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91118>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
91119>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
91120>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
91121>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
91122>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
91123>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
91124>>>>>>>>            Increment i
91125>>>>>>>>
91125>>>>>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
91126>>>>>>>>            Move 189                                     to aColumnType[i].iSQLType
91127>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
91128>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91129>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
91130>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
91131>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
91132>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
91133>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
91134>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
91135>>>>>>>>            Increment i
91136>>>>>>>>
91136>>>>>>>>            Move "long"                                  to aColumnType[i].sSQLType
91137>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
91138>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91139>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91140>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
91141>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91142>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
91143>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91144>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91145>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
91146>>>>>>>>            Increment i
91147>>>>>>>>
91147>>>>>>>>            Move "longraw"                               to aColumnType[i].sSQLType
91148>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
91149>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91150>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91151>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
91152>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91153>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
91154>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
91155>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
91156>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
91157>>>>>>>>            Increment i
91158>>>>>>>>
91158>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
91159>>>>>>>>            Move 286                                     to aColumnType[i].iSQLType
91160>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91161>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91162>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91163>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91164>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
91165>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91166>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91167>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
91168>>>>>>>>            Increment i
91169>>>>>>>>
91169>>>>>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
91170>>>>>>>>            Move 288                                     to aColumnType[i].iSQLType
91171>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91172>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91173>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
91174>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91175>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
91176>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
91177>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
91178>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
91179>>>>>>>>            Increment i
91180>>>>>>>>
91180>>>>>>>>            Move "number"                                to aColumnType[i].sSQLType
91181>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
91182>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91183>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91184>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91185>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91186>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
91187>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
91188>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
91189>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
91190>>>>>>>>            Increment i
91191>>>>>>>>
91191>>>>>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
91192>>>>>>>>            Move 287                                     to aColumnType[i].iSQLType
91193>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91194>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91195>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91196>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91197>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
91198>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91199>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91200>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
91201>>>>>>>>            Increment i
91202>>>>>>>>
91202>>>>>>>>            Move "raw"                                   to aColumnType[i].sSQLType
91203>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
91204>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91205>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91206>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91207>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91208>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
91209>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
91210>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
91211>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
91212>>>>>>>>            Increment i
91213>>>>>>>>
91213>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
91214>>>>>>>>            Move 187                                     to aColumnType[i].iSQLType
91215>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
91216>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91217>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
91218>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
91219>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
91220>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
91221>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
91222>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
91223>>>>>>>>            Increment i
91224>>>>>>>>
91224>>>>>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
91225>>>>>>>>            Move 232                                     to aColumnType[i].iSQLType
91226>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
91227>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91228>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
91229>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
91230>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
91231>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
91232>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
91233>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
91234>>>>>>>>            Increment i
91235>>>>>>>>
91235>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
91236>>>>>>>>            Move 188                                     to aColumnType[i].iSQLType
91237>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
91238>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91239>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
91240>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
91241>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
91242>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
91243>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
91244>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
91245>>>>>>>>            Increment i
91246>>>>>>>>
91246>>>>>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
91247>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
91248>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91249>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91250>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91251>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91252>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
91253>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91254>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91255>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
91256>>>>>>>>            Increment i
91257>>>>>>>>
91257>>>>>>>>
91257>>>>>>>
91257>>>>>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
91257>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
91257>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
91257>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
91257>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
91257>>>>>>>//        Increment i
91257>>>>>>>//
91257>>>>>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
91257>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
91257>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
91257>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
91257>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
91257>>>>>>>//        Increment i
91257>>>>>>>//
91257>>>>>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
91257>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
91257>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
91257>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
91257>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
91257>>>>>>>//        Increment i
91257>>>>>>>//
91257>>>>>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
91257>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
91257>>>>>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
91257>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
91257>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
91257>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
91257>>>>>>>//        Increment i
91257>>>>>>>//
91257>>>>>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
91257>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
91257>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91257>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
91257>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
91257>>>>>>>//        Increment i
91257>>>>>>>//
91257>>>>>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
91257>>>>>>>//        Move "INT"              to ColumnType[i].sSQLType
91257>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91257>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
91257>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
91257>>>>>>>//        Increment i
91257>>>>>>>//
91257>>>>>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
91257>>>>>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
91257>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
91257>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
91257>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
91257>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
91257>>>>>>>//        Increment i
91257>>>>>>>//
91257>>>>>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
91257>>>>>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
91257>>>>>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
91257>>>>>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
91257>>>>>>>//        Move "23.0"              to ColumnType[i].sPrecision
91257>>>>>>>//        Move True                to ColumnType[i].bCanEditSize
91257>>>>>>>//        Increment i
91257>>>>>>>//
91257>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
91257>>>>>>>//        Move "LONG"             to ColumnType[i].sSQLType
91257>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
91257>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
91257>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
91257>>>>>>>//        Increment i
91257>>>>>>>//
91257>>>>>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
91257>>>>>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
91257>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
91257>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
91257>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
91257>>>>>>>//        Increment i
91257>>>>>>>//
91257>>>>>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
91257>>>>>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
91257>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
91257>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
91257>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
91257>>>>>>>//        Increment i
91257>>>>>>>//
91257>>>>>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
91257>>>>>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
91257>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
91257>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
91257>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
91257>>>>>>>//        Increment i
91257>>>>>>>//
91257>>>>>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
91257>>>>>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
91257>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91257>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
91257>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
91257>>>>>>>//        Increment i
91257>>>>>>>//
91257>>>>>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
91257>>>>>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
91257>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
91257>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
91257>>>>>>>//        Move "4000"             to ColumnType[i].sPrecision
91257>>>>>>>//        Increment i
91257>>>>>>>//
91257>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
91257>>>>>>>//        Move "RAW"              to ColumnType[i].sSQLType
91257>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
91257>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
91257>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
91257>>>>>>>//        Increment i
91257>>>>>>>//
91257>>>>>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
91257>>>>>>>//        Move "ROWID"            to ColumnType[i].sSQLType
91257>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
91257>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
91257>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
91257>>>>>>>//        Increment i
91257>>>>>>>//
91257>>>>>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
91257>>>>>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
91257>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
91257>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
91257>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
91257>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
91257>>>>>>>//        Increment i
91257>>>>>>>//
91257>>>>>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
91257>>>>>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
91257>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
91257>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
91257>>>>>>>//        Move "13.0"                 to ColumnType[i].sPrecision
91257>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
91257>>>>>>>//        Increment i
91257>>>>>>>//
91257>>>>>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
91257>>>>>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
91257>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
91257>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
91257>>>>>>>//        Move "11.0"                 to ColumnType[i].sPrecision
91257>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
91257>>>>>>>//        Increment i
91257>>>>>>>//
91257>>>>>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
91257>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
91257>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
91257>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
91257>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
91257>>>>>>>
91257>>>>>>>        Function_Return aColumnType
91258>>>>>>>    End_Function
91259>>>>>>>
91259>>>>>>>    // PostgreSQL Data Types
91259>>>>>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
91261>>>>>>>        tColumnType[] aColumnType
91261>>>>>>>        tColumnType[] aColumnType
91262>>>>>>>        Integer i
91262>>>>>>>
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdspgsql_DriverDef.inc)
91262>>>>>>>>// Generated By The Database Update Framework
91262>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
91262>>>>>>>>// Driver COLUMN DATA TYPES
91262>>>>>>>>//
91262>>>>>>>>// Created: 2018-03-14 23:47:02.984
91262>>>>>>>>
91262>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
91263>>>>>>>>            Move 20                                      to aColumnType[i].iSQLType
91264>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91265>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91266>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
91267>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91268>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
91269>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
91270>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
91271>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
91272>>>>>>>>            Increment i
91273>>>>>>>>
91273>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
91274>>>>>>>>            Move 1560                                    to aColumnType[i].iSQLType
91275>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91276>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91277>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91278>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91279>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
91280>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
91281>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
91282>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
91283>>>>>>>>            Increment i
91284>>>>>>>>
91284>>>>>>>>            Move "boolean"                               to aColumnType[i].sSQLType
91285>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
91286>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
91287>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91288>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91289>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
91290>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
91291>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91292>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91293>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
91294>>>>>>>>            Increment i
91295>>>>>>>>
91295>>>>>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
91296>>>>>>>>            Move 17                                      to aColumnType[i].iSQLType
91297>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91298>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91299>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91300>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91301>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
91302>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
91303>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
91304>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
91305>>>>>>>>            Increment i
91306>>>>>>>>
91306>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
91307>>>>>>>>            Move 18                                      to aColumnType[i].iSQLType
91308>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91309>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91310>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91311>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91312>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
91313>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91314>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91315>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
91316>>>>>>>>            Increment i
91317>>>>>>>>
91317>>>>>>>>            Move "citext"                                to aColumnType[i].sSQLType
91318>>>>>>>>            Move -25                                     to aColumnType[i].iSQLType
91319>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91320>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91321>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91322>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91323>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
91324>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91325>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91326>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
91327>>>>>>>>            Increment i
91328>>>>>>>>
91328>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
91329>>>>>>>>            Move 1082                                    to aColumnType[i].iSQLType
91330>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
91331>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91332>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
91333>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
91334>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
91335>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
91336>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
91337>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
91338>>>>>>>>            Increment i
91339>>>>>>>>
91339>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
91340>>>>>>>>            Move 701                                     to aColumnType[i].iSQLType
91341>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91342>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91343>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
91344>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91345>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
91346>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91347>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91348>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
91349>>>>>>>>            Increment i
91350>>>>>>>>
91350>>>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
91351>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
91352>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91353>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91354>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
91355>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91356>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
91357>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
91358>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
91359>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
91360>>>>>>>>            Increment i
91361>>>>>>>>
91361>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
91362>>>>>>>>            Move 790                                     to aColumnType[i].iSQLType
91363>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91364>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91365>>>>>>>>            Move 30                                      to aColumnType[i].iDefaultSize
91366>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91367>>>>>>>>            Move 30                                      to aColumnType[i].nMaxSize
91368>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
91369>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
91370>>>>>>>>            Move 30                                      to aColumnType[i].sPrecision
91371>>>>>>>>            Increment i
91372>>>>>>>>
91372>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
91373>>>>>>>>            Move 1700                                    to aColumnType[i].iSQLType
91374>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91375>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91376>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
91377>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91378>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
91379>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91380>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91381>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
91382>>>>>>>>            Increment i
91383>>>>>>>>
91383>>>>>>>>            Move "oid"                                   to aColumnType[i].sSQLType
91384>>>>>>>>            Move 26                                      to aColumnType[i].iSQLType
91385>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
91386>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91387>>>>>>>>            Move 20                                      to aColumnType[i].iDefaultSize
91388>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
91389>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
91390>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
91391>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
91392>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
91393>>>>>>>>            Increment i
91394>>>>>>>>
91394>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
91395>>>>>>>>            Move 700                                     to aColumnType[i].iSQLType
91396>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91397>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91398>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
91399>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91400>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
91401>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
91402>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
91403>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
91404>>>>>>>>            Increment i
91405>>>>>>>>
91405>>>>>>>>            Move "regproc"                               to aColumnType[i].sSQLType
91406>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
91407>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
91408>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91409>>>>>>>>            Move 64                                      to aColumnType[i].iDefaultSize
91410>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
91411>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
91412>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91413>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91414>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
91415>>>>>>>>            Increment i
91416>>>>>>>>
91416>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
91417>>>>>>>>            Move 21                                      to aColumnType[i].iSQLType
91418>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91419>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91420>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
91421>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91422>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
91423>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
91424>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
91425>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
91426>>>>>>>>            Increment i
91427>>>>>>>>
91427>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
91428>>>>>>>>            Move 25                                      to aColumnType[i].iSQLType
91429>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91430>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91431>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91432>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91433>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
91434>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91435>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91436>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
91437>>>>>>>>            Increment i
91438>>>>>>>>
91438>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
91439>>>>>>>>            Move 1083                                    to aColumnType[i].iSQLType
91440>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91441>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91442>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
91443>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
91444>>>>>>>>            Move 15                                      to aColumnType[i].nMaxSize
91445>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91446>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91447>>>>>>>>            Move 15                                      to aColumnType[i].sPrecision
91448>>>>>>>>            Increment i
91449>>>>>>>>
91449>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
91450>>>>>>>>            Move 1114                                    to aColumnType[i].iSQLType
91451>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
91452>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91453>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
91454>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
91455>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
91456>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
91457>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
91458>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
91459>>>>>>>>            Increment i
91460>>>>>>>>
91460>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
91461>>>>>>>>            Move 1184                                    to aColumnType[i].iSQLType
91462>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
91463>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91464>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
91465>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
91466>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
91467>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91468>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91469>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
91470>>>>>>>>            Increment i
91471>>>>>>>>
91471>>>>>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
91472>>>>>>>>            Move 2950                                    to aColumnType[i].iSQLType
91473>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
91474>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91475>>>>>>>>            Move 40                                      to aColumnType[i].iDefaultSize
91476>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
91477>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
91478>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91479>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91480>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
91481>>>>>>>>            Increment i
91482>>>>>>>>
91482>>>>>>>>            Move "varbit"                                to aColumnType[i].sSQLType
91483>>>>>>>>            Move 1562                                    to aColumnType[i].iSQLType
91484>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91485>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91486>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91487>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91488>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
91489>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91490>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91491>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
91492>>>>>>>>            Increment i
91493>>>>>>>>
91493>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
91494>>>>>>>>            Move 1043                                    to aColumnType[i].iSQLType
91495>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
91496>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
91497>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
91498>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
91499>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
91500>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
91501>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
91502>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
91503>>>>>>>>            Increment i
91504>>>>>>>>
91504>>>>>>>>
91504>>>>>>>
91504>>>>>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
91504>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
91504>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91504>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
91504>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
91504>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
91504>>>>>>>//        Increment i
91504>>>>>>>//
91504>>>>>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
91504>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
91504>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
91504>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
91504>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
91504>>>>>>>//        Increment i
91504>>>>>>>//
91504>>>>>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
91504>>>>>>>//        Move "boolean"          to ColumnType[i].sSQLType
91504>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
91504>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
91504>>>>>>>//        Move "1"                to ColumnType[i].sPrecision
91504>>>>>>>//        Increment i
91504>>>>>>>//
91504>>>>>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
91504>>>>>>>//        Move "bytea"            to ColumnType[i].sSQLType
91504>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
91504>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
91504>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
91504>>>>>>>//        Increment i
91504>>>>>>>//
91504>>>>>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
91504>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
91504>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
91504>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
91504>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
91504>>>>>>>//        Increment i
91504>>>>>>>//
91504>>>>>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
91504>>>>>>>//        Move "citext"           to ColumnType[i].sSQLType
91504>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
91504>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
91504>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
91504>>>>>>>//        Increment i
91504>>>>>>>//
91504>>>>>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
91504>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
91504>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
91504>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
91504>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
91504>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
91504>>>>>>>//        Increment i
91504>>>>>>>//
91504>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
91504>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
91504>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91504>>>>>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
91504>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
91504>>>>>>>//        Increment i
91504>>>>>>>//
91504>>>>>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
91504>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
91504>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
91504>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
91504>>>>>>>//        Move "22"               to ColumnType[i].sPrecision
91504>>>>>>>//        Increment i
91504>>>>>>>//
91504>>>>>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
91504>>>>>>>//        Move "integer"          to ColumnType[i].sSQLType
91504>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91504>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
91504>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
91504>>>>>>>//        Increment i
91504>>>>>>>//
91504>>>>>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
91504>>>>>>>//        Move "money"            to ColumnType[i].sSQLType
91504>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91504>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
91504>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
91504>>>>>>>//        Increment i
91504>>>>>>>//
91504>>>>>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
91504>>>>>>>//        Move "oid"              to ColumnType[i].sSQLType
91504>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
91504>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
91504>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
91504>>>>>>>//        Increment i
91504>>>>>>>//
91504>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
91504>>>>>>>//        Move "real"             to ColumnType[i].sSQLType
91504>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91504>>>>>>>//        Move "Real"             to ColumnType[i].sDataFlexType
91504>>>>>>>//        Move "6.6"              to ColumnType[i].sPrecision
91504>>>>>>>//        Increment i
91504>>>>>>>//
91504>>>>>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
91504>>>>>>>//        Move "regproc"          to ColumnType[i].sSQLType
91504>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
91504>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
91504>>>>>>>//        Move "64"               to ColumnType[i].sPrecision
91504>>>>>>>//        Increment i
91504>>>>>>>//
91504>>>>>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
91504>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
91504>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
91504>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
91504>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
91504>>>>>>>//        Increment i
91504>>>>>>>//
91504>>>>>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
91504>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
91504>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
91504>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
91504>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
91504>>>>>>>//        Increment i
91504>>>>>>>//
91504>>>>>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
91504>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
91504>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
91504>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
91504>>>>>>>//        Move "15.0"             to ColumnType[i].sPrecision
91504>>>>>>>//        Increment i
91504>>>>>>>//
91504>>>>>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
91504>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
91504>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
91504>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
91504>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
91504>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
91504>>>>>>>//        Increment i
91504>>>>>>>//
91504>>>>>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
91504>>>>>>>//        Move "uuid"             to ColumnType[i].sSQLType
91504>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
91504>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
91504>>>>>>>//        Move "40"               to ColumnType[i].sPrecision
91504>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
91504>>>>>>>//        Increment i
91504>>>>>>>//
91504>>>>>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
91504>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
91504>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
91504>>>>>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
91504>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
91504>>>>>>>//        Increment i
91504>>>>>>>
91504>>>>>>>        Function_Return aColumnType
91505>>>>>>>    End_Function
91506>>>>>>>
91506>>>>>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
91506>>>>>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
91508>>>>>>>        Integer iValue iSize iCount iStart
91508>>>>>>>        tColumnType[] ColumnTypeArray
91508>>>>>>>        tColumnType[] ColumnTypeArray
91509>>>>>>>        tColumnType RetvalType
91509>>>>>>>        tColumnType RetvalType
91509>>>>>>>        String sValue
91509>>>>>>>        Boolean bFrameworkDataFlexType
91509>>>>>>>
91509>>>>>>>        Move "Undefined" to RetvalType.sSQLType
91510>>>>>>>        Move -1999       to RetvalType.iSQLType
91511>>>>>>>
91511>>>>>>>        Move 0 to iStart
91512>>>>>>>        Move (Uppercase(sType)) to sType
91513>>>>>>>        Move (iType <= -1490) to bFrameworkDataFlexType
91514>>>>>>>        If (bFrameworkDataFlexType = True) Begin
91516>>>>>>>            Get UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
91517>>>>>>>            Function_Return RetvalType
91518>>>>>>>        End
91518>>>>>>>>
91518>>>>>>>
91518>>>>>>>        Get UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
91519>>>>>>>
91519>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
91520>>>>>>>        Decrement iSize
91521>>>>>>>
91521>>>>>>>        for iCount from iStart to iSize
91527>>>>>>>>
91527>>>>>>>            Move ColumnTypeArray[iCount].iSQLType to iValue
91528>>>>>>>            Move ColumnTypeArray[iCount].sSQLType to sValue
91529>>>>>>>            If (bIntegerInputType = True) Begin
91531>>>>>>>                If (iValue = iType) Begin
91533>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
91534>>>>>>>                    Move iType                                  to RetvalType.iSQLType
91535>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
91536>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
91537>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
91538>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
91539>>>>>>>                    Move iSize to iCount // We're done!
91540>>>>>>>                End
91540>>>>>>>>
91540>>>>>>>            End
91540>>>>>>>>
91540>>>>>>>            Else Begin
91541>>>>>>>                Move (Uppercase(sValue)) to sValue
91542>>>>>>>                If (sValue = sType) Begin
91544>>>>>>>                    Move sType                                  to RetvalType.sSQLType
91545>>>>>>>                    Move ColumnTypeArray[iCount].iSQLType       to RetvalType.iSQLType
91546>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
91547>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
91548>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
91549>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
91550>>>>>>>                    Move iSize to iCount // We're done!
91551>>>>>>>                End
91551>>>>>>>>
91551>>>>>>>            End
91551>>>>>>>>
91551>>>>>>>        Loop
91552>>>>>>>>
91552>>>>>>>
91552>>>>>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
91552>>>>>>>        // In which case we search for a match in DataFlex standard types:
91552>>>>>>>        If (RetvalType.sSQLType = "Undefined") Begin
91554>>>>>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
91555>>>>>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
91556>>>>>>>            Decrement iSize
91557>>>>>>>
91557>>>>>>>            for iCount from iStart to iSize
91563>>>>>>>>
91563>>>>>>>                Move ColumnTypeArray[iCount].iSQLType to iValue
91564>>>>>>>                Move ColumnTypeArray[iCount].sSQLType to sValue
91565>>>>>>>                If (iValue = iType) Begin
91567>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
91568>>>>>>>                    Move iType                                  to RetvalType.iSQLType
91569>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
91570>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
91571>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
91572>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
91573>>>>>>>                    Move iSize to iCount // We're done!
91574>>>>>>>                End
91574>>>>>>>>
91574>>>>>>>            Loop
91575>>>>>>>>
91575>>>>>>>        End
91575>>>>>>>>
91575>>>>>>>
91575>>>>>>>        Function_Return RetvalType
91576>>>>>>>    End_Function
91577>>>>>>>
91577>>>>>>>    Function _AllTablesToConvert Returns Integer[]
91579>>>>>>>        Integer[] aTableConvertExceptions iTablesArray
91581>>>>>>>        Handle hTable
91581>>>>>>>        Integer iIndex
91581>>>>>>>        String sTableName
91581>>>>>>>        Boolean bFlexErrs
91581>>>>>>>
91581>>>>>>>        // a) Get the exception table array the developer has specified
91581>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
91582>>>>>>>
91582>>>>>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
91582>>>>>>>        Repeat
91582>>>>>>>>
91582>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91585>>>>>>>            If (hTable <> 0) Begin
91587>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
91590>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
91591>>>>>>>                If (bFlexErrs = False) Begin
91593>>>>>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
91595>>>>>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
91596>>>>>>>                        If (iIndex = -1) Begin
91598>>>>>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
91599>>>>>>>                        End
91599>>>>>>>>
91599>>>>>>>                    End
91599>>>>>>>>
91599>>>>>>>                End
91599>>>>>>>>
91599>>>>>>>            End
91599>>>>>>>>
91599>>>>>>>        Until (hTable = 0)
91601>>>>>>>
91601>>>>>>>        Move 0 to hTable
91602>>>>>>>
91602>>>>>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
91602>>>>>>>        Repeat
91602>>>>>>>>
91602>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91605>>>>>>>            If (hTable > 0) Begin
91607>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
91610>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
91611>>>>>>>                If (bFlexErrs = False) Begin
91613>>>>>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
91614>>>>>>>                    If (iIndex = -1) Begin
91616>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
91617>>>>>>>                    End
91617>>>>>>>>
91617>>>>>>>                End
91617>>>>>>>>
91617>>>>>>>            End
91617>>>>>>>>
91617>>>>>>>        Until (hTable = 0)
91619>>>>>>>
91619>>>>>>>        Function_Return iTablesArray
91620>>>>>>>    End_Function
91621>>>>>>>
91621>>>>>>>    Function _AllTablesDateCorrections Returns Integer[]
91623>>>>>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
91625>>>>>>>        Handle hTable
91625>>>>>>>        Integer iIndex
91625>>>>>>>        String sTableName
91625>>>>>>>        Boolean bFlexErrs
91625>>>>>>>
91625>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
91626>>>>>>>        Move 0 to hTable
91627>>>>>>>
91627>>>>>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
91627>>>>>>>        Repeat
91627>>>>>>>>
91627>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91630>>>>>>>            If (hTable > 0) Begin
91632>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
91635>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
91636>>>>>>>                If (bFlexErrs = False) Begin
91638>>>>>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
91639>>>>>>>                    If (iIndex = -1) Begin
91641>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
91642>>>>>>>                    End
91642>>>>>>>>
91642>>>>>>>                End
91642>>>>>>>>
91642>>>>>>>            End
91642>>>>>>>>
91642>>>>>>>        Until (hTable = 0)
91644>>>>>>>
91644>>>>>>>        Function_Return iTablesArray
91645>>>>>>>    End_Function
91646>>>>>>>
91646>>>>>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
91648>>>>>>>        tAPIColumn NewAPIColumn
91648>>>>>>>        tAPIColumn NewAPIColumn
91648>>>>>>>
91648>>>>>>>        Move sFieldName to NewAPIColumn.sFieldName
91649>>>>>>>        Move iType      to NewAPIColumn.iType
91650>>>>>>>        Move iLength    to NewAPIColumn.iLength
91651>>>>>>>        Move iPrecision to NewAPIColumn.iPrecision
91652>>>>>>>        Move iOptions   to NewAPIColumn.iOptions
91653>>>>>>>
91653>>>>>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
91654>>>>>>>
91654>>>>>>>        Function_Return aCurrent
91655>>>>>>>    End_Function
91656>>>>>>>
91656>>>>>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
91658>>>>>>>        String sRetval sFieldName
91658>>>>>>>        Integer iCount iSize
91658>>>>>>>
91658>>>>>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
91659>>>>>>>        Decrement iSize
91660>>>>>>>        for iCount from 0 to iSize
91666>>>>>>>>
91666>>>>>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
91667>>>>>>>            Move (sRetval * (String(sFieldName))) to sRetval
91668>>>>>>>        Loop
91669>>>>>>>>
91669>>>>>>>        Move (Trim(sRetval)) to sRetval
91670>>>>>>>
91670>>>>>>>        Function_Return sRetval
91671>>>>>>>    End_Function
91672>>>>>>>
91672>>>>>>>    // *** Miscellaneous other functions ***
91672>>>>>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
91672>>>>>>>    //
91672>>>>>>>
91672>>>>>>>    // Callback functionality used when e.g. calling driver functions directly.
91672>>>>>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
91674>>>>>>>        Integer iPerc
91674>>>>>>>        Number nReady nTotal
91674>>>>>>>
91674>>>>>>>        Send DoAdvance of ghoProgressBar
91675>>>>>>>
91675>>>>>>>        If (sCallback_Text contains "Copy records") Begin
91677>>>>>>>            Move CS_DUF_CopyingData to sCallback_Text
91678>>>>>>>        End
91678>>>>>>>>
91678>>>>>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
91680>>>>>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
91681>>>>>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
91682>>>>>>>        End
91682>>>>>>>>
91682>>>>>>>        If (sCallback_Text contains "Creating index") Begin
91684>>>>>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
91685>>>>>>>        End
91685>>>>>>>>
91685>>>>>>>
91685>>>>>>>        Case Begin
91685>>>>>>>            Case (iCallback_Type = DF_Message_Text)
91687>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
91688>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
91689>>>>>>>                Case Break
91690>>>>>>>            Case (iCallback_Type = DF_Message_Heading_1)
91693>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
91694>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
91695>>>>>>>                Case Break
91696>>>>>>>            Case (iCallback_Type = DF_Message_Heading_2)
91699>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
91700>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
91701>>>>>>>                Case Break
91702>>>>>>>            Case (iCallback_Type = DF_Message_Heading_3)
91705>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
91706>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
91707>>>>>>>                Case Break
91708>>>>>>>            Case (iCallback_Type = DF_Message_Heading_4)
91711>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
91712>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
91713>>>>>>>                Case Break
91714>>>>>>>            Case (iCallback_Type = DF_Message_Heading_5)
91717>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
91718>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
91719>>>>>>>                Case Break
91720>>>>>>>            Case (iCallback_Type = DF_Message_Warning)
91723>>>>>>>                Send None
91724>>>>>>>                Case Break
91725>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Title)
91728>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
91729>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
91730>>>>>>>                Case Break
91731>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Value)
91734>>>>>>>                //*** Interpret numbers
91734>>>>>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
91735>>>>>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
91736>>>>>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
91737>>>>>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
91738>>>>>>>                Case Break
91739>>>>>>>            Case Else
91739>>>>>>>                Set Message_Text to ""
91740>>>>>>>                Set Action_Text  to ""
91741>>>>>>>        Case End
91741>>>>>>>
91741>>>>>>>        Send ProcessEvents of ghoStatusPanel
91742>>>>>>>        Function_Return False
91743>>>>>>>    End_Function
91744>>>>>>>
91744>>>>>>>    Procedure IncreaseSortBufferSize
91746>>>>>>>        String sNull
91746>>>>>>>        Integer iSortBufferSize
91746>>>>>>>        Boolean bBufferSet
91746>>>>>>>
91746>>>>>>>        Move "" to sNull
91747>>>>>>>        Move (1024 * 128) to iSortBufferSize
91748>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
91753>>>>>>>
91753>>>>>>>    End_Procedure
91754>>>>>>>
91754>>>>>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
91756>>>>>>>        Integer iLastIndex iIndex iNumSegments
91756>>>>>>>        Boolean bOK
91756>>>>>>>        String sDriverID
91756>>>>>>>
91756>>>>>>>        If (hTable > 0) Begin
91758>>>>>>>            Get UtilDriverFromTableNumber hTable to sDriverID
91759>>>>>>>            Close hTable
91760>>>>>>>            Get OpenTableExclusive hTable to bOK
91761>>>>>>>            If (bOK = False) Begin
91763>>>>>>>                Procedure_Return
91764>>>>>>>            End
91764>>>>>>>>
91764>>>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
91767>>>>>>>            Structure_Start hTable sDriverID
91768>>>>>>>                for iIndex from 1 to iLastIndex
91774>>>>>>>>
91774>>>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
91777>>>>>>>                    If (iNumSegments > 0) Begin
91779>>>>>>>                        If (bSetToBatch = True) Begin
91781>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
91784>>>>>>>                        End
91784>>>>>>>>
91784>>>>>>>                        Else Begin
91785>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
91788>>>>>>>                        End
91788>>>>>>>>
91788>>>>>>>                    End
91788>>>>>>>>
91788>>>>>>>                Loop
91789>>>>>>>>
91789>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91791>>>>>>>        End
91791>>>>>>>>
91791>>>>>>>    End_Procedure
91792>>>>>>>
91792>>>>>>>    Function NextFreeFilelistSlot Returns Handle
91794>>>>>>>        Handle hTable
91794>>>>>>>
91794>>>>>>>        Move 0 to hTable
91795>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
91798>>>>>>>
91798>>>>>>>        Function_Return hTable
91799>>>>>>>    End_Function
91800>>>>>>>
91800>>>>>>>    // For debugging purposes. To print Sql statements as they are build...
91800>>>>>>>    Procedure DebugPrint String sStmt String sFileName
91802>>>>>>>        Integer iCh
91802>>>>>>>        Get Seq_Append_Output_Channel sFileName to iCh
91803>>>>>>>            Write channel iCh sStmt
91805>>>>>>>        Send Seq_Close_Channel iCh
91806>>>>>>>    End_Procedure
91807>>>>>>>
91807>>>>>>>    // Returns the integer number for the passed Driver ID that is
91807>>>>>>>    // needed by some database API calls.
91807>>>>>>>    Function DriverIndex String sDriverID Returns Integer
91809>>>>>>>        String  sCurrentDriver
91809>>>>>>>        Integer iNumberOfDrivers iDriver iCount
91809>>>>>>>
91809>>>>>>>        Move 0 to iDriver
91810>>>>>>>
91810>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
91813>>>>>>>        for iCount from 1 to iNumberOfDrivers
91819>>>>>>>>
91819>>>>>>>
91819>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
91822>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
91824>>>>>>>                Move iCount to iDriver
91825>>>>>>>            End
91825>>>>>>>>
91825>>>>>>>        Loop
91826>>>>>>>>
91826>>>>>>>
91826>>>>>>>        // In case it was not found, it wasn't loaded so we do that now.
91826>>>>>>>        If (iDriver = 0) Begin
91828>>>>>>>            Move False to Err
91829>>>>>>>            Load_Driver sDriverID
91830>>>>>>>            If (Err = False) Begin
91832>>>>>>>                Get_Attribute DF_NUMBER_DRIVERS to iDriver
91835>>>>>>>            End
91835>>>>>>>>
91835>>>>>>>        End
91835>>>>>>>>
91835>>>>>>>
91835>>>>>>>        Function_Return iDriver
91836>>>>>>>    End_Function
91837>>>>>>>
91837>>>>>>>    
91837>>>>>>>    Function MinMSSQLDRV_And_ClientVersion String sMSSQLDRVVersion Integer iClientVersion Boolean bShowErrorDialog Boolean bExitProgram Returns String
91839>>>>>>>        String sDriverID sVersion sClient sClientLowest sRetval
91839>>>>>>>        Integer iNumberOfDrivers iDriver iClient
91839>>>>>>>        Handle hoCLIHandler hoMSSQLHandler   
91839>>>>>>>        Boolean bOK
91839>>>>>>>        
91839>>>>>>>        Move "" to sRetval
91840>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLIHandler
91841>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMSSQLHandler
91842>>>>>>>        Load_Driver MSSQLDRV_ID
91843>>>>>>>
91843>>>>>>>        // Loop through all loaded drivers.
91843>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
91846>>>>>>>        For iDriver from 1 to iNumberOfDrivers
91852>>>>>>>>
91852>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
91855>>>>>>>            If (sDriverID = MSSQLDRV_ID) Begin
91857>>>>>>>                Set psDriverID of hoCLIHandler to sDriverID
91858>>>>>>>                Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient   
91861>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClientVersion to sClientLowest 
91862>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClient to sClient 
91863>>>>>>>                Get CKRevision of hoCLIHandler to sVersion
91864>>>>>>>                Move (SFormat (String(C_$DatabaseDriver), (sDriverID * "-" * (String(C_$Version) + ": " + String(sVersion))))) to sRetval
91865>>>>>>>                If (sClient <> "" and sRetval <> "") Begin
91867>>>>>>>                    Move (String(sRetval) + "\n" + String(C_$SQL_Client_Text) + "\n" + Trim(sClient)) to sRetval
91868>>>>>>>                End                                
91868>>>>>>>>
91868>>>>>>>                Else Begin
91869>>>>>>>                    Move (String(C_$SQL_Client_Text) + "\n" + Trim(sClient) * "(" + String(iClient) + ")") to sRetval
91870>>>>>>>                End
91870>>>>>>>>
91870>>>>>>>            End
91870>>>>>>>>
91870>>>>>>>        Loop
91871>>>>>>>>
91871>>>>>>>        Send Destroy of hoCLIHandler  
91872>>>>>>>        Send Destroy of hoMSSQLHandler  
91873>>>>>>>        If (bShowErrorDialog = True) Begin
91875>>>>>>>            Get IsFirstStringGreaterThanSecond sVersion sMSSQLDRVVersion to bOK
91876>>>>>>>            If (bOK = False or (iClient < iClientVersion)) Begin
91878>>>>>>>                Move (MSSQLDRV_ID + ".dll" * String(C_$SQL_Driver_Version_Min_Text) *  String(sMSSQLDRVVersion) + String("\n") + String(C_$SQL_Client_Version_Min_Text) + "\n" + String(sClientLowest) + String("\n\n") + String(C_$SQL_Versions_Are_Text) + String("\n") + String(sRetval)) to sRetval
91879>>>>>>>                If (bExitProgram = True) Begin
91881>>>>>>>                    Move (String(sRetval) + String("\n\n") + String(C_$PleaseAdjustTxt) * String(C_$ProgramWillExit_Text)) to sRetval
91882>>>>>>>                End
91882>>>>>>>>
91882>>>>>>>                Send Stop_Box sRetval  
91883>>>>>>>                If (bExitProgram = True) Begin
91885>>>>>>>                    Send Exit_Application
91886>>>>>>>                End
91886>>>>>>>>
91886>>>>>>>            End
91886>>>>>>>>
91886>>>>>>>        End
91886>>>>>>>>
91886>>>>>>>        
91886>>>>>>>        Function_Return sRetval
91887>>>>>>>    End_Function  
91888>>>>>>>    
91888>>>>>>>    // Returns True if first "." separated string is greater than the second.
91888>>>>>>>    // It checks from left to right, one part of the string at a time.
91888>>>>>>>    // E.g. if sVersion="20.1.31.10 and sSQLVersion="6.3.0.13" the function would return TRUE.
91888>>>>>>>    Function IsFirstStringGreaterThanSecond Global String sVersion String sSQLVersion Returns Boolean
91890>>>>>>>        String[] asVersion asSQLVersion          
91892>>>>>>>        Integer iSize iCount iVersion iSQLVersion
91892>>>>>>>        
91892>>>>>>>        Move (StrSplitToArray(sVersion, "."))    to asVersion
91893>>>>>>>        Move (StrSplitToArray(sSQLVersion, ".")) to asSQLVersion
91894>>>>>>>        Move (SizeOfArray(asVersion)) to iSize
91895>>>>>>>        // Make sure the two arrays are of the same size:
91895>>>>>>>        If (SizeOfArray(asSQLVersion) < iSize) Begin
91897>>>>>>>            Move (ResizeArray(asSQLVersion, iSize, 0)) to asSQLVersion
91898>>>>>>>        End
91898>>>>>>>>
91898>>>>>>>        Decrement iSize
91899>>>>>>>        for iCount from 0 to iSize
91905>>>>>>>>
91905>>>>>>>            Move asVersion[iCount]    to iVersion
91906>>>>>>>            Move asSQLVersion[iCount] to iSQLVersion
91907>>>>>>>            CompilerWarnings Off
91907>>>>>>>            If (iVersion > iSQLVersion) Break
91910>>>>>>>            CompilerWarnings On
91910>>>>>>>        Loop
91911>>>>>>>>
91911>>>>>>>        
91911>>>>>>>        Function_Return (iVersion > iSQLVersion)
91912>>>>>>>    End_Function
91913>>>>>>>
91913>>>>>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
91913>>>>>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
91913>>>>>>>    //       so in that case we "cheat" and report those tables were opened OK.
91913>>>>>>>    Function OpenTableExclusive Handle hTable Returns Boolean
91915>>>>>>>        Integer iMode
91915>>>>>>>        Boolean bOpened
91915>>>>>>>        String sTableName
91915>>>>>>>
91915>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91916>>>>>>>        // Can't open a table properly if run through the Debugger/Studio,
91916>>>>>>>        // so we generate an error here:
91916>>>>>>>        If (IsDebuggerPresent()) Begin
91918>>>>>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio"
91919>>>>>>>>
91919>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
91920>>>>>>>            Function_Return False
91921>>>>>>>        End
91921>>>>>>>>
91921>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
91924>>>>>>>        If (bOpened) Begin
91926>>>>>>>            If (IsDebuggerPresent()) Begin
91928>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
91931>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
91933>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
91934>>>>>>>                    Function_Return True
91935>>>>>>>                End
91935>>>>>>>>
91935>>>>>>>            End
91935>>>>>>>>
91935>>>>>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
91938>>>>>>>            If (iMode=DF_EXCLUSIVE) Begin
91940>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
91941>>>>>>>                Function_Return True
91942>>>>>>>            End
91942>>>>>>>>
91942>>>>>>>            Close hTable
91943>>>>>>>        End
91943>>>>>>>>
91943>>>>>>>        Else Begin
91944>>>>>>>            Open hTable
91946>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
91949>>>>>>>            If (bOpened and IsDebuggerPresent()) Begin
91951>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
91954>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
91956>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
91957>>>>>>>                    Function_Return True
91958>>>>>>>                End
91958>>>>>>>>
91958>>>>>>>            End
91958>>>>>>>>
91958>>>>>>>
91958>>>>>>>        End
91958>>>>>>>>
91958>>>>>>>
91958>>>>>>>        Close hTable
91959>>>>>>>        Open hTable Mode DF_EXCLUSIVE
91961>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
91964>>>>>>>
91964>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91965>>>>>>>        Function_Return bOpened
91966>>>>>>>    End_Function
91967>>>>>>>
91967>>>>>>>    Function AutoConnectionIDLogin Returns Boolean
91969>>>>>>>        String sConnectionID sConnectionString sDriverID
91969>>>>>>>        Boolean bExists bOK bSQLDriver bMertech
91969>>>>>>>        Handle hoCLI hoDriver
91969>>>>>>>        Integer iRetval
91969>>>>>>>        tSQLConnection SQLConnection
91969>>>>>>>        tSQLConnection SQLConnection
91969>>>>>>>
91969>>>>>>>        Get psDriverID to sDriverID
91970>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
91971>>>>>>>        If (bSQLDriver = False) Begin
91973>>>>>>>            Function_Return True
91974>>>>>>>        End
91974>>>>>>>>
91974>>>>>>>
91974>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91975>>>>>>>        Move SQLConnection.sDriverID                  to sDriverID
91976>>>>>>>        Move SQLConnection.sConnectionString          to sConnectionString
91977>>>>>>>        Get IsMertechDriver sDriverID to bMertech
91978>>>>>>>        If (bMertech = True) Begin
91980>>>>>>>            Get _MertechSQLManagerHandle to hoCLI
91981>>>>>>>            Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
91982>>>>>>>            Set psDriverID of hoDriver to SQLConnection.sDriverID
91983>>>>>>>            Get DbLogin  of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
91984>>>>>>>            Send Destroy of hoDriver
91985>>>>>>>            Function_Return bOK
91986>>>>>>>        End
91986>>>>>>>>
91986>>>>>>>
91986>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
91987>>>>>>>
91987>>>>>>>        Get IsConnectionID sConnectionID sDriverID to bExists
91988>>>>>>>        If (bExists = False) Begin
91990>>>>>>>            // We always start by deleting the current connection - if any - because the
91990>>>>>>>            // login details my have changed.
91990>>>>>>>            Get phoCLIHandler to hoCLI
91991>>>>>>>            Set psDriverID    of hoCLI to sDriverID
91992>>>>>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
91993>>>>>>>            Get AutoSetConnectionID sConnectionID to bOk
91994>>>>>>>            If (bOk = False) Begin
91996>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
91997>>>>>>>>
91997>>>>>>>                Function_Return False
91998>>>>>>>            End
91998>>>>>>>>
91998>>>>>>>            Move bOK to bExists
91999>>>>>>>        End
91999>>>>>>>>
91999>>>>>>>
91999>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
92000>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
92001>>>>>>>        Get DbLogin of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
92002>>>>>>>        Send Destroy of hoDriver
92003>>>>>>>
92003>>>>>>>        Function_Return (bExists = True)
92004>>>>>>>    End_Function
92005>>>>>>>
92005>>>>>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
92005>>>>>>>    // Returns: False if nobody else is running
92005>>>>>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
92005>>>>>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
92005>>>>>>>    //      tables are not locked as DataFlex tables are.
92005>>>>>>>    Function IsDatabaseInUse Returns Boolean
92007>>>>>>>        Handle  hTable
92007>>>>>>>        String  sRootName
92007>>>>>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs bExists
92007>>>>>>>        Integer iCount iTables
92007>>>>>>>
92007>>>>>>>        Move 0 to iTables
92008>>>>>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
92009>>>>>>>        Get AutoConnectionIDLogin to bOK
92010>>>>>>>        Get UtilFilelistNoOfTables to iTables
92011>>>>>>>        Set piPosition   of ghoProgressBar to 0
92012>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 1
92013>>>>>>>        Set piMaximum    of ghoProgressBar to iTables
92014>>>>>>>        Move 0 to hTable
92015>>>>>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92018>>>>>>>        Move False to bErr
92019>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92020>>>>>>>
92020>>>>>>>        Repeat
92020>>>>>>>>
92020>>>>>>>            Set piPosition of ghoProgressBar to iCount
92021>>>>>>>            Increment iCount
92022>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92025>>>>>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
92026>>>>>>>
92026>>>>>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
92026>>>>>>>            Get UtilTableIsSQLByRootName sRootName to bIsSQLTable
92027>>>>>>>            Move False to bOpen
92028>>>>>>>            Get UtilTableExists hTable to bExists
92029>>>>>>>            // Don't bother about CodeType (253, CodeMast (254) or) FlexErrs (Normally table 50)
92029>>>>>>>            If (bIsSQLTable = False and bExists = True and hTable <> 0 and hTable <> 253 and hTable <> 254 and bFlexErrs = False) Begin
92031>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92032>>>>>>>                Open hTable
92034>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
92037>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92038>>>>>>>                If (bOpen = True) Begin
92040>>>>>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
92040>>>>>>>                    Get UtilTableIsAlias hTable to bAlias
92041>>>>>>>                    If (bAlias = False) Begin
92043>>>>>>>                        Close hTable
92044>>>>>>>                        Get OpenTableExclusive hTable to bOpen
92045>>>>>>>                        If (bOpen = False) Begin
92047>>>>>>>                            Move True to bErr
92048>>>>>>>                        End
92048>>>>>>>>
92048>>>>>>>                    End
92048>>>>>>>>
92048>>>>>>>                End
92048>>>>>>>>
92048>>>>>>>                Close hTable
92049>>>>>>>            End
92049>>>>>>>>
92049>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92052>>>>>>>            If (bErr = True ) ;                Break
92055>>>>>>>        Until (not(hTable))
92057>>>>>>>
92057>>>>>>>        Set Action_Text of ghoStatusPanel to ""
92058>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92059>>>>>>>        Move False to Err
92060>>>>>>>
92060>>>>>>>        Function_Return bErr
92061>>>>>>>    End_Function
92062>>>>>>>
92062>>>>>>>    // Checks if the passed connection id exists in the CLI interface.
92062>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
92062>>>>>>>    // the connection id hasn't been established with the driver's CLI interface.
92062>>>>>>>    // NOTE: Only applicable for DAW drivers.
92062>>>>>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
92064>>>>>>>        String sID sConnString
92064>>>>>>>        Integer iDriver iNumConn iCount
92064>>>>>>>        Handle hoCLI
92064>>>>>>>        Boolean bOK
92064>>>>>>>
92064>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
92065>>>>>>>        If (bOK = False) Begin
92067>>>>>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers (not Mertech)."
92068>>>>>>>>
92068>>>>>>>            Function_Return False
92069>>>>>>>        End
92069>>>>>>>>
92069>>>>>>>
92069>>>>>>>        Move False to bOK
92070>>>>>>>        Get phoCLIHandler to hoCLI
92071>>>>>>>        If (hoCLI <> 0) Begin
92073>>>>>>>            Set psDriverID of hoCLI to sDriverID
92074>>>>>>>            Get DriverIndex of hoCLI sDriverID to iDriver
92075>>>>>>>
92075>>>>>>>            // If driver not loaded; load it.
92075>>>>>>>            If (iDriver = 0) Begin
92077>>>>>>>                Load_Driver sDriverID
92078>>>>>>>                Get DriverIndex sDriverID to iDriver
92079>>>>>>>            End
92079>>>>>>>>
92079>>>>>>>            If (iDriver <> 0) Begin
92081>>>>>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
92084>>>>>>>                Decrement iNumConn
92085>>>>>>>                for iCount from 0 to iNumConn
92091>>>>>>>>
92091>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
92094>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
92097>>>>>>>                    If (sID = sConnectionID) Begin
92099>>>>>>>                        Move True to bOK
92100>>>>>>>                    End
92100>>>>>>>>
92100>>>>>>>                Loop
92101>>>>>>>>
92101>>>>>>>            End
92101>>>>>>>>
92101>>>>>>>        End
92101>>>>>>>>
92101>>>>>>>
92101>>>>>>>        Function_Return bOK
92102>>>>>>>    End_Function
92103>>>>>>>
92103>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
92105>>>>>>>        Boolean bOK
92105>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
92106>>>>>>>        Function_Return bOK
92107>>>>>>>    End_Function
92108>>>>>>>
92108>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
92110>>>>>>>        Boolean bOK
92110>>>>>>>        Move False to bOK
92111>>>>>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMySQL) to bOK
92112>>>>>>>        Function_Return bOK
92113>>>>>>>    End_Function
92114>>>>>>>
92114>>>>>>>    Function IsMSSQLDriver Returns Boolean
92116>>>>>>>        Integer iDriverIndex
92116>>>>>>>
92116>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
92117>>>>>>>
92117>>>>>>>        Function_Return (iDriverIndex <> 0)
92118>>>>>>>    End_Function
92119>>>>>>>
92119>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
92119>>>>>>>    // attempt to load the driver.
92119>>>>>>>    // Returns true if the passed driver is SQL based.
92119>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
92121>>>>>>>        Boolean bOK
92121>>>>>>>
92121>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
92122>>>>>>>
92122>>>>>>>        If (bOK = False) Begin
92124>>>>>>>            Get IsMertechDriver sDriverID to bOK
92125>>>>>>>        End
92125>>>>>>>>
92125>>>>>>>
92125>>>>>>>        Function_Return bOK
92126>>>>>>>    End_Function
92127>>>>>>>
92127>>>>>>>    // *** Error Handler ***
92127>>>>>>>    //
92127>>>>>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
92127>>>>>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
92127>>>>>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
92129>>>>>>>        Integer iSize iErrorMode
92129>>>>>>>        tSqlErrorArray aSqlErrorArray
92129>>>>>>>        tSqlErrorArray aSqlErrorArray
92129>>>>>>>
92129>>>>>>>        If (pbProcessingError(Self)) Begin
92131>>>>>>>            Procedure_Return
92132>>>>>>>        End
92132>>>>>>>>
92132>>>>>>>
92132>>>>>>>        Get Error_Report_Mode to iErrorMode
92133>>>>>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
92135>>>>>>>            Procedure_Return
92136>>>>>>>        End
92136>>>>>>>>
92136>>>>>>>
92136>>>>>>>        Set pbProcessingError to True
92137>>>>>>>        Set pbSqlError to True
92138>>>>>>>        Get paSqlErrorArray      to aSqlErrorArray
92139>>>>>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
92140>>>>>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
92141>>>>>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
92142>>>>>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
92143>>>>>>>        Set paSqlErrorArray      to aSqlErrorArray
92144>>>>>>>        Set pbProcessingError to False
92145>>>>>>>    End_Procedure
92146>>>>>>>
92146>>>>>>>    // *** Miscellanous Helper Functions ***
92146>>>>>>>    //
92146>>>>>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
92146>>>>>>>    // returns the table name only; stripped of any path or filename extension.
92146>>>>>>>    Function _TableNameOnly String sName Returns String
92148>>>>>>>        String sPath sExt
92148>>>>>>>
92148>>>>>>>        Get ParseFolderName sName to sPath
92149>>>>>>>        If (sPath <> "") Begin
92151>>>>>>>            Move (Replace(sPath, sName, "")) to sName
92152>>>>>>>        End
92152>>>>>>>>
92152>>>>>>>        Get ParseFileExtension sName to sExt
92153>>>>>>>        If (sExt <> "") Begin
92155>>>>>>>            Move (Replace(("." + sExt), sName, "")) to sName
92156>>>>>>>        End
92156>>>>>>>>
92156>>>>>>>
92156>>>>>>>        Function_Return sName
92157>>>>>>>    End_Function
92158>>>>>>>
92158>>>>>>>    // Removes any prefix to a table name.
92158>>>>>>>    // Example mssqldrv:mytable returns mytable
92158>>>>>>>    //         dbo.mytable returns mytable
92158>>>>>>>    Function _TableNoPrefix String sName Returns String
92160>>>>>>>        Integer iPos
92160>>>>>>>
92160>>>>>>>        Move (Pos(":", sName)) to iPos
92161>>>>>>>        If (iPos <> 0) Begin
92163>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
92164>>>>>>>        End
92164>>>>>>>>
92164>>>>>>>        Move (Pos(".", sName)) to iPos
92165>>>>>>>        If (iPos <> 0) Begin
92167>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
92168>>>>>>>        End
92168>>>>>>>>
92168>>>>>>>
92168>>>>>>>        Function_Return sName
92169>>>>>>>    End_Function
92170>>>>>>>
92170>>>>>>>    // Returns the first datapath found in the psDataPath property.
92170>>>>>>>    // The returned path always ends with a "\"
92170>>>>>>>    Function psDataPathFirstPart Returns String
92172>>>>>>>        String sDataPath
92172>>>>>>>        Integer iCount
92172>>>>>>>
92172>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
92173>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
92174>>>>>>>        If (iCount > 1) Begin
92176>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
92177>>>>>>>        End
92177>>>>>>>>
92177>>>>>>>        If (sDataPath <> "") Begin
92179>>>>>>>            Get vFolderFormat sDataPath to sDataPath
92180>>>>>>>        End
92180>>>>>>>>
92180>>>>>>>
92180>>>>>>>        Function_Return sDataPath
92181>>>>>>>    End_Function
92182>>>>>>>
92182>>>>>>>    Function psLogTextFileWithPath Returns String
92184>>>>>>>        String sFileName
92184>>>>>>>        Handle hoLogFile
92184>>>>>>>        Get phoLogFile to hoLogFile
92185>>>>>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
92186>>>>>>>        Function_Return sFileName
92187>>>>>>>    End_Function
92188>>>>>>>
92188>>>>>>>    // *** Property Messages ***
92188>>>>>>>    //
92188>>>>>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
92188>>>>>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
92188>>>>>>>    //
92188>>>>>>>
92188>>>>>>>    Function pSQLConnection Returns tSQLConnection
92190>>>>>>>        tSQLConnection SQLConnection
92190>>>>>>>        tSQLConnection SQLConnection
92190>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92192>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
92192>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92193>>>>>>>>
92193>>>>>>>            Function_Return
92194>>>>>>>        End
92194>>>>>>>>
92194>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92195>>>>>>>        Function_Return SQLConnection
92196>>>>>>>    End_Function
92197>>>>>>>
92197>>>>>>>    // * Dummy function for the Studio's Code Explorer *
92197>>>>>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
92199>>>>>>>        Function_Return False
92200>>>>>>>    End_Function
92201>>>>>>>
92201>>>>>>>    Procedure Set psServer String sValue
92203>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92205>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
92205>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92206>>>>>>>>
92206>>>>>>>            Procedure_Return
92207>>>>>>>        End
92207>>>>>>>>
92207>>>>>>>        Set psServer of ghoSQLConnectionHandler to sValue
92208>>>>>>>    End_Procedure
92209>>>>>>>
92209>>>>>>>    Function psServer Returns String
92211>>>>>>>        String sValue
92211>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92213>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92214>>>>>>>>
92214>>>>>>>            Function_Return
92215>>>>>>>        End
92215>>>>>>>>
92215>>>>>>>        Get psServer of ghoSQLConnectionHandler to sValue
92216>>>>>>>        Function_Return sValue
92217>>>>>>>    End_Function
92218>>>>>>>
92218>>>>>>>    Procedure Set psDatabase String sValue
92220>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92222>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92223>>>>>>>>
92223>>>>>>>            Procedure_Return
92224>>>>>>>        End
92224>>>>>>>>
92224>>>>>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
92225>>>>>>>    End_Procedure
92226>>>>>>>
92226>>>>>>>    Function psDatabase Returns String
92228>>>>>>>        String sValue
92228>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92230>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92231>>>>>>>>
92231>>>>>>>            Function_Return
92232>>>>>>>        End
92232>>>>>>>>
92232>>>>>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
92233>>>>>>>        Function_Return sValue
92234>>>>>>>    End_Function
92235>>>>>>>
92235>>>>>>>    Procedure Set psUserID String sValue
92237>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92239>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92240>>>>>>>>
92240>>>>>>>            Procedure_Return
92241>>>>>>>        End
92241>>>>>>>>
92241>>>>>>>        Set psUserID of ghoSQLConnectionHandler to sValue
92242>>>>>>>    End_Procedure
92243>>>>>>>
92243>>>>>>>    Function psUserID Returns String
92245>>>>>>>        String sValue
92245>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92247>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92248>>>>>>>>
92248>>>>>>>            Function_Return
92249>>>>>>>        End
92249>>>>>>>>
92249>>>>>>>        Get psUserID of ghoSQLConnectionHandler to sValue
92250>>>>>>>        Function_Return sValue
92251>>>>>>>    End_Function
92252>>>>>>>
92252>>>>>>>    Procedure Set psPassword String sValue
92254>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92256>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92257>>>>>>>>
92257>>>>>>>            Procedure_Return
92258>>>>>>>        End
92258>>>>>>>>
92258>>>>>>>        Set psPassword of ghoSQLConnectionHandler to sValue
92259>>>>>>>    End_Procedure
92260>>>>>>>
92260>>>>>>>    Function psPassword Returns String
92262>>>>>>>        String sValue
92262>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92264>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92265>>>>>>>>
92265>>>>>>>            Function_Return
92266>>>>>>>        End
92266>>>>>>>>
92266>>>>>>>        Get psPassword of ghoSQLConnectionHandler to sValue
92267>>>>>>>        Function_Return sValue
92268>>>>>>>    End_Function
92269>>>>>>>
92269>>>>>>>    Procedure Set pbTrusted Boolean bValue
92271>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92273>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92274>>>>>>>>
92274>>>>>>>            Procedure_Return
92275>>>>>>>        End
92275>>>>>>>>
92275>>>>>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
92276>>>>>>>    End_Procedure
92277>>>>>>>
92277>>>>>>>    Function pbTrusted Returns Boolean
92279>>>>>>>        Boolean bValue
92279>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92281>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92282>>>>>>>>
92282>>>>>>>            Function_Return
92283>>>>>>>        End
92283>>>>>>>>
92283>>>>>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
92284>>>>>>>        Function_Return bValue
92285>>>>>>>    End_Function
92286>>>>>>>
92286>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
92288>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92290>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92291>>>>>>>>
92291>>>>>>>            Procedure_Return
92292>>>>>>>        End
92292>>>>>>>>
92292>>>>>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
92293>>>>>>>    End_Procedure
92294>>>>>>>
92294>>>>>>>    Function pbSilentLogin Returns Boolean
92296>>>>>>>        Boolean bValue
92296>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92298>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92299>>>>>>>>
92299>>>>>>>            Function_Return
92300>>>>>>>        End
92300>>>>>>>>
92300>>>>>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
92301>>>>>>>        Function_Return bValue
92302>>>>>>>    End_Function
92303>>>>>>>
92303>>>>>>>    Procedure Set psConnectionID String sValue
92305>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92307>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92308>>>>>>>>
92308>>>>>>>            Procedure_Return
92309>>>>>>>        End
92309>>>>>>>>
92309>>>>>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
92310>>>>>>>    End_Procedure
92311>>>>>>>
92311>>>>>>>    Function psConnectionID Returns String
92313>>>>>>>        String sValue
92313>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92315>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92316>>>>>>>>
92316>>>>>>>            Function_Return
92317>>>>>>>        End
92317>>>>>>>>
92317>>>>>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
92318>>>>>>>        Function_Return sValue
92319>>>>>>>    End_Function
92320>>>>>>>
92320>>>>>>>    Procedure Set psConnectionString String sValue
92322>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92324>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92325>>>>>>>>
92325>>>>>>>            Procedure_Return
92326>>>>>>>        End
92326>>>>>>>>
92326>>>>>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
92327>>>>>>>    End_Procedure
92328>>>>>>>
92328>>>>>>>    Function psConnectionString Returns String
92330>>>>>>>        String sValue
92330>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92332>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92333>>>>>>>>
92333>>>>>>>            Function_Return
92334>>>>>>>        End
92334>>>>>>>>
92334>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
92335>>>>>>>        Function_Return sValue
92336>>>>>>>    End_Function
92337>>>>>>>
92337>>>>>>>    // The normal connection string looks something like this;
92337>>>>>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
92337>>>>>>>    // ...and the full connection string looks like this;
92337>>>>>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
92337>>>>>>>    Function psFullConnectionString Returns String
92339>>>>>>>        String sConnectionID sConnectionString
92339>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92341>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92342>>>>>>>>
92342>>>>>>>            Function_Return
92343>>>>>>>        End
92343>>>>>>>>
92343>>>>>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
92344>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
92345>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
92346>>>>>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
92347>>>>>>>    End_Function
92348>>>>>>>
92348>>>>>>>    Function piConnectionOptions Returns Integer
92350>>>>>>>        Integer iValue
92350>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92352>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92353>>>>>>>>
92353>>>>>>>            Function_Return
92354>>>>>>>        End
92354>>>>>>>>
92354>>>>>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
92355>>>>>>>        Function_Return iValue
92356>>>>>>>    End_Function
92357>>>>>>>
92357>>>>>>>    Procedure Set psSchema String sValue
92359>>>>>>>        tSQLConnection SQLConnection
92359>>>>>>>        tSQLConnection SQLConnection
92359>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92361>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92362>>>>>>>>
92362>>>>>>>            Procedure_Return
92363>>>>>>>        End
92363>>>>>>>>
92363>>>>>>>        Set psSchema of ghoSQLConnectionHandler to sValue
92364>>>>>>>    End_Procedure
92365>>>>>>>
92365>>>>>>>    Function psSchema Returns String
92367>>>>>>>        String sRetval
92367>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92369>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92370>>>>>>>>
92370>>>>>>>            Function_Return
92371>>>>>>>        End
92371>>>>>>>>
92371>>>>>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
92372>>>>>>>        Function_Return sRetval
92373>>>>>>>    End_Function
92374>>>>>>>
92374>>>>>>>    Procedure Set psBaseTableSpace String sValue
92376>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92378>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92379>>>>>>>>
92379>>>>>>>            Procedure_Return
92380>>>>>>>        End
92380>>>>>>>>
92380>>>>>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
92381>>>>>>>    End_Procedure
92382>>>>>>>
92382>>>>>>>    Function psBaseTableSpace Returns String
92384>>>>>>>        String sRetval
92384>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92386>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92387>>>>>>>>
92387>>>>>>>            Function_Return
92388>>>>>>>        End
92388>>>>>>>>
92388>>>>>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
92389>>>>>>>        Function_Return sRetval
92390>>>>>>>    End_Function
92391>>>>>>>
92391>>>>>>>    Procedure Set psLongTableSpace String sValue
92393>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92395>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92396>>>>>>>>
92396>>>>>>>            Procedure_Return
92397>>>>>>>        End
92397>>>>>>>>
92397>>>>>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
92398>>>>>>>    End_Procedure
92399>>>>>>>
92399>>>>>>>    Function psLongTableSpace Returns String
92401>>>>>>>        String sRetval
92401>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92403>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92404>>>>>>>>
92404>>>>>>>            Function_Return
92405>>>>>>>        End
92405>>>>>>>>
92405>>>>>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
92406>>>>>>>        Function_Return sRetval
92407>>>>>>>    End_Function
92408>>>>>>>
92408>>>>>>>    Procedure Set psIndexTableSpace String sValue
92410>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92412>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92413>>>>>>>>
92413>>>>>>>            Procedure_Return
92414>>>>>>>        End
92414>>>>>>>>
92414>>>>>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
92415>>>>>>>    End_Procedure
92416>>>>>>>
92416>>>>>>>    Function psIndexTableSpace Returns String
92418>>>>>>>        String sRetval
92418>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92420>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92421>>>>>>>>
92421>>>>>>>            Function_Return
92422>>>>>>>        End
92422>>>>>>>>
92422>>>>>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
92423>>>>>>>        Function_Return sRetval
92424>>>>>>>    End_Function
92425>>>>>>>
92425>>>>>>>    Procedure Set pbUseConnectionID Boolean bState
92427>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92429>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92430>>>>>>>>
92430>>>>>>>            Procedure_Return
92431>>>>>>>        End
92431>>>>>>>>
92431>>>>>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
92432>>>>>>>    End_Procedure
92433>>>>>>>
92433>>>>>>>    Function pbUseConnectionID Returns Boolean
92435>>>>>>>        Boolean bState
92435>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92437>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92438>>>>>>>>
92438>>>>>>>            Function_Return
92439>>>>>>>        End
92439>>>>>>>>
92439>>>>>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
92440>>>>>>>        Function_Return bState
92441>>>>>>>    End_Function
92442>>>>>>>
92442>>>>>>>    Procedure Set pbToANSI Boolean bState
92444>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92446>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92447>>>>>>>>
92447>>>>>>>            Procedure_Return
92448>>>>>>>        End
92448>>>>>>>>
92448>>>>>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
92449>>>>>>>    End_Procedure
92450>>>>>>>
92450>>>>>>>    Function pbToANSI Returns Boolean
92452>>>>>>>        Boolean bState
92452>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92454>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92455>>>>>>>>
92455>>>>>>>            Function_Return
92456>>>>>>>        End
92456>>>>>>>>
92456>>>>>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
92457>>>>>>>        Function_Return bState
92458>>>>>>>    End_Function
92459>>>>>>>
92459>>>>>>>    Procedure Set pbRecnum Boolean bState
92461>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92463>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92464>>>>>>>>
92464>>>>>>>            Procedure_Return
92465>>>>>>>        End
92465>>>>>>>>
92465>>>>>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
92466>>>>>>>    End_Procedure
92467>>>>>>>
92467>>>>>>>    Function pbRecnum Returns Boolean
92469>>>>>>>        Boolean bState
92469>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92471>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92472>>>>>>>>
92472>>>>>>>            Function_Return
92473>>>>>>>        End
92473>>>>>>>>
92473>>>>>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
92474>>>>>>>        Function_Return bState
92475>>>>>>>    End_Function
92476>>>>>>>
92476>>>>>>>    Procedure Set pbCopyData Boolean bState
92478>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92480>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92481>>>>>>>>
92481>>>>>>>            Procedure_Return
92482>>>>>>>        End
92482>>>>>>>>
92482>>>>>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
92483>>>>>>>    End_Procedure
92484>>>>>>>
92484>>>>>>>    Function pbCopyData Returns Boolean
92486>>>>>>>        Boolean bState
92486>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92488>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92489>>>>>>>>
92489>>>>>>>            Function_Return
92490>>>>>>>        End
92490>>>>>>>>
92490>>>>>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
92491>>>>>>>        Function_Return bState
92492>>>>>>>    End_Function
92493>>>>>>>
92493>>>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
92495>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92497>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92498>>>>>>>>
92498>>>>>>>            Procedure_Return
92499>>>>>>>        End
92499>>>>>>>>
92499>>>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
92500>>>>>>>    End_Procedure
92501>>>>>>>
92501>>>>>>>    Function pbApiTableUpdateAuto Returns Boolean
92503>>>>>>>        Boolean bState
92503>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92505>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92506>>>>>>>>
92506>>>>>>>            Function_Return
92507>>>>>>>        End
92507>>>>>>>>
92507>>>>>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
92508>>>>>>>        Function_Return bState
92509>>>>>>>    End_Function
92510>>>>>>>
92510>>>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
92512>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92514>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92515>>>>>>>>
92515>>>>>>>            Procedure_Return
92516>>>>>>>        End
92516>>>>>>>>
92516>>>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
92517>>>>>>>    End_Procedure
92518>>>>>>>
92518>>>>>>>    Function pbCompareDate_DateTime Returns Boolean
92520>>>>>>>        Boolean bState
92520>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92522>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92523>>>>>>>>
92523>>>>>>>            Function_Return
92524>>>>>>>        End
92524>>>>>>>>
92524>>>>>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
92525>>>>>>>        Function_Return bState
92526>>>>>>>    End_Function
92527>>>>>>>
92527>>>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
92529>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92531>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92532>>>>>>>>
92532>>>>>>>            Procedure_Return
92533>>>>>>>        End
92533>>>>>>>>
92533>>>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
92534>>>>>>>    End_Procedure
92535>>>>>>>
92535>>>>>>>    Function pbCompareIndexAscending Returns Boolean
92537>>>>>>>        Boolean bState
92537>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92539>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92540>>>>>>>>
92540>>>>>>>            Function_Return
92541>>>>>>>        End
92541>>>>>>>>
92541>>>>>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
92542>>>>>>>        Function_Return bState
92543>>>>>>>    End_Function
92544>>>>>>>
92544>>>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
92546>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92548>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92549>>>>>>>>
92549>>>>>>>            Procedure_Return
92550>>>>>>>        End
92550>>>>>>>>
92550>>>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
92551>>>>>>>    End_Procedure
92552>>>>>>>
92552>>>>>>>    Function pbCompareIndexUppercase Returns Boolean
92554>>>>>>>        Boolean bState
92554>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92556>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92557>>>>>>>>
92557>>>>>>>            Function_Return
92558>>>>>>>        End
92558>>>>>>>>
92558>>>>>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
92559>>>>>>>        Function_Return bState
92560>>>>>>>    End_Function
92561>>>>>>>
92561>>>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
92563>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92565>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92566>>>>>>>>
92566>>>>>>>            Procedure_Return
92567>>>>>>>        End
92567>>>>>>>>
92567>>>>>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
92568>>>>>>>    End_Procedure
92569>>>>>>>
92569>>>>>>>    Function psDriverDefaultValueASCII Returns String
92571>>>>>>>        String sRetval
92571>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92573>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92574>>>>>>>>
92574>>>>>>>            Function_Return
92575>>>>>>>        End
92575>>>>>>>>
92575>>>>>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
92576>>>>>>>        Function_Return sRetval
92577>>>>>>>    End_Function
92578>>>>>>>
92578>>>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
92580>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92582>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92583>>>>>>>>
92583>>>>>>>            Procedure_Return
92584>>>>>>>        End
92584>>>>>>>>
92584>>>>>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
92585>>>>>>>    End_Procedure
92586>>>>>>>
92586>>>>>>>    Function psDriverDefaultValueBinary Returns String
92588>>>>>>>        String sRetval
92588>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92590>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92591>>>>>>>>
92591>>>>>>>            Function_Return
92592>>>>>>>        End
92592>>>>>>>>
92592>>>>>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
92593>>>>>>>        Function_Return sRetval
92594>>>>>>>    End_Function
92595>>>>>>>
92595>>>>>>>    Procedure Set psDriverDefaultValueDate String sValue
92597>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92599>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92600>>>>>>>>
92600>>>>>>>            Procedure_Return
92601>>>>>>>        End
92601>>>>>>>>
92601>>>>>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
92602>>>>>>>    End_Procedure
92603>>>>>>>
92603>>>>>>>    Function psDriverDefaultValueDate Returns String
92605>>>>>>>        String sRetval
92605>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92607>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92608>>>>>>>>
92608>>>>>>>            Function_Return
92609>>>>>>>        End
92609>>>>>>>>
92609>>>>>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
92610>>>>>>>        Function_Return sRetval
92611>>>>>>>    End_Function
92612>>>>>>>
92612>>>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
92614>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92616>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92617>>>>>>>>
92617>>>>>>>            Procedure_Return
92618>>>>>>>        End
92618>>>>>>>>
92618>>>>>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
92619>>>>>>>    End_Procedure
92620>>>>>>>
92620>>>>>>>    Function psDriverDefaultValueDateTime Returns String
92622>>>>>>>        String sRetval
92622>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92624>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92625>>>>>>>>
92625>>>>>>>            Function_Return
92626>>>>>>>        End
92626>>>>>>>>
92626>>>>>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
92627>>>>>>>        Function_Return sRetval
92628>>>>>>>    End_Function
92629>>>>>>>
92629>>>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
92631>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92633>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92634>>>>>>>>
92634>>>>>>>            Procedure_Return
92635>>>>>>>        End
92635>>>>>>>>
92635>>>>>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
92636>>>>>>>    End_Procedure
92637>>>>>>>
92637>>>>>>>    Function psDriverDefaultValueNumeric Returns String
92639>>>>>>>        String sRetval
92639>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92641>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92642>>>>>>>>
92642>>>>>>>            Function_Return
92643>>>>>>>        End
92643>>>>>>>>
92643>>>>>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
92644>>>>>>>        Function_Return sRetval
92645>>>>>>>    End_Function
92646>>>>>>>
92646>>>>>>>    Procedure Set psDriverDefaultValueText String sValue
92648>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92650>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92651>>>>>>>>
92651>>>>>>>            Procedure_Return
92652>>>>>>>        End
92652>>>>>>>>
92652>>>>>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
92653>>>>>>>    End_Procedure
92654>>>>>>>
92654>>>>>>>    Function psDriverDefaultValueText Returns String
92656>>>>>>>        String sRetval
92656>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92658>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92659>>>>>>>>
92659>>>>>>>            Function_Return
92660>>>>>>>        End
92660>>>>>>>>
92660>>>>>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
92661>>>>>>>        Function_Return sRetval
92662>>>>>>>    End_Function
92663>>>>>>>
92663>>>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
92665>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92667>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92668>>>>>>>>
92668>>>>>>>            Procedure_Return
92669>>>>>>>        End
92669>>>>>>>>
92669>>>>>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
92670>>>>>>>    End_Procedure
92671>>>>>>>
92671>>>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
92673>>>>>>>        Boolean bState
92673>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92675>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92676>>>>>>>>
92676>>>>>>>            Function_Return
92677>>>>>>>        End
92677>>>>>>>>
92677>>>>>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
92678>>>>>>>        Function_Return bState
92679>>>>>>>    End_Function
92680>>>>>>>
92680>>>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
92682>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92684>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92685>>>>>>>>
92685>>>>>>>            Procedure_Return
92686>>>>>>>        End
92686>>>>>>>>
92686>>>>>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
92687>>>>>>>    End_Procedure
92688>>>>>>>
92688>>>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
92690>>>>>>>        Boolean bState
92690>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92692>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92693>>>>>>>>
92693>>>>>>>            Function_Return
92694>>>>>>>        End
92694>>>>>>>>
92694>>>>>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
92695>>>>>>>        Function_Return bState
92696>>>>>>>    End_Function
92697>>>>>>>
92697>>>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
92699>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92701>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92702>>>>>>>>
92702>>>>>>>            Procedure_Return
92703>>>>>>>        End
92703>>>>>>>>
92703>>>>>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
92704>>>>>>>    End_Procedure
92705>>>>>>>
92705>>>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
92707>>>>>>>        Boolean bState
92707>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92709>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92710>>>>>>>>
92710>>>>>>>            Function_Return
92711>>>>>>>        End
92711>>>>>>>>
92711>>>>>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
92712>>>>>>>        Function_Return bState
92713>>>>>>>    End_Function
92714>>>>>>>
92714>>>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
92716>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92718>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92719>>>>>>>>
92719>>>>>>>            Procedure_Return
92720>>>>>>>        End
92720>>>>>>>>
92720>>>>>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
92721>>>>>>>    End_Procedure
92722>>>>>>>
92722>>>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
92724>>>>>>>        Boolean bState
92724>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92726>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92727>>>>>>>>
92727>>>>>>>            Function_Return
92728>>>>>>>        End
92728>>>>>>>>
92728>>>>>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
92729>>>>>>>        Function_Return bState
92730>>>>>>>    End_Function
92731>>>>>>>
92731>>>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
92733>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92735>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92736>>>>>>>>
92736>>>>>>>            Procedure_Return
92737>>>>>>>        End
92737>>>>>>>>
92737>>>>>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
92738>>>>>>>    End_Procedure
92739>>>>>>>
92739>>>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
92741>>>>>>>        Boolean bState
92741>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92743>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92744>>>>>>>>
92744>>>>>>>            Function_Return
92745>>>>>>>        End
92745>>>>>>>>
92745>>>>>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
92746>>>>>>>        Function_Return bState
92747>>>>>>>    End_Function
92748>>>>>>>
92748>>>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
92750>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92752>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92753>>>>>>>>
92753>>>>>>>            Procedure_Return
92754>>>>>>>        End
92754>>>>>>>>
92754>>>>>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
92755>>>>>>>    End_Procedure
92756>>>>>>>
92756>>>>>>>    Function pbDriverDefaultNullableText Returns Boolean
92758>>>>>>>        Boolean bState
92758>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92760>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
92761>>>>>>>>
92761>>>>>>>            Function_Return
92762>>>>>>>        End
92762>>>>>>>>
92762>>>>>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
92763>>>>>>>        Function_Return bState
92764>>>>>>>    End_Function
92765>>>>>>>
92765>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
92765>>>>>>>    //       the psDriverID *must* be the first property that gets changed!
92765>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
92765>>>>>>>    //       for a connection string has the wrong format for that driver.
92765>>>>>>>    Procedure Set psDriverID String sValue
92767>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92768>>>>>>>        Delegate Set psDriverID to sValue
92770>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92771>>>>>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
92772>>>>>>>    End_Procedure
92773>>>>>>>
92773>>>>>>>    Function psDriverID Returns String
92775>>>>>>>        String sDriverID
92775>>>>>>>
92775>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92776>>>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
92776>>>>>>>        Delegate Get psDriverID to sDriverID
92778>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92779>>>>>>>        Move False to Err
92780>>>>>>>
92780>>>>>>>        // ...and in case it didn't use property of this class. Then the library is
92780>>>>>>>        // probably used as "utilites" from a special made program and
92780>>>>>>>        // the ghoSQLConnectionHandler must have been setup
92780>>>>>>>        If (sDriverID = "") Begin
92782>>>>>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
92783>>>>>>>        End
92783>>>>>>>>
92783>>>>>>>        Function_Return sDriverID
92784>>>>>>>    End_Function
92785>>>>>>>
92785>>>>>>>    Procedure Set piDbType Integer iValue
92787>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92788>>>>>>>        Delegate Set piDbType to iValue
92790>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92791>>>>>>>        Set piDbType of ghoSQLConnectionHandler to iValue
92792>>>>>>>    End_Procedure
92793>>>>>>>
92793>>>>>>>    Function piDbType Returns Integer
92795>>>>>>>        Integer iRetval
92795>>>>>>>        Get piDbType of ghoSQLConnectionHandler to iRetval
92796>>>>>>>        Function_Return iRetval
92797>>>>>>>    End_Function
92798>>>>>>>
92798>>>>>>>    Function phoLogFile Returns Handle
92800>>>>>>>        Handle hoLogFile   
92800>>>>>>>        Boolean bErr
92800>>>>>>>        
92800>>>>>>>        Move Err to bErr
92801>>>>>>>        Move 0 to hoLogFile
92802>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
92803>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92804>>>>>>>        Delegate Get phoLogFile to hoLogFile
92806>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92807>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92808>>>>>>>        Move bErr to Err
92809>>>>>>>        
92809>>>>>>>        Function_Return hoLogFile
92810>>>>>>>    End_Function
92811>>>>>>>
92811>>>>>>>    Function pnCurrentVersionUpdate Returns Number
92813>>>>>>>        Number nCurrentVersionUpdate
92813>>>>>>>
92813>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92814>>>>>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
92816>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92817>>>>>>>
92817>>>>>>>        Function_Return nCurrentVersionUpdate
92818>>>>>>>    End_Function
92819>>>>>>>
92819>>>>>>>    Procedure LogError String sText Boolean bError
92821>>>>>>>        Handle hoLogFile
92821>>>>>>>        Number nCurrentVersionUpdate
92821>>>>>>>
92821>>>>>>>        Get phoLogFile to hoLogFile
92822>>>>>>>        If (hoLogFile = 0) Begin
92824>>>>>>>            Procedure_Return
92825>>>>>>>        End
92825>>>>>>>>
92825>>>>>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
92826>>>>>>>
92826>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92827>>>>>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
92828>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92829>>>>>>>    End_Procedure
92830>>>>>>>
92830>>>>>>>    Function pbContinueOnError Returns Boolean
92832>>>>>>>        Boolean bContinueOnError
92832>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
92834>>>>>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
92835>>>>>>>        End
92835>>>>>>>>
92835>>>>>>>        Function_Return bContinueOnError
92836>>>>>>>    End_Function
92837>>>>>>>
92837>>>>>>>    // Latin1_General_CI_AS = General Insensitive collation
92837>>>>>>>    // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.
92837>>>>>>>    // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
92837>>>>>>>    // Good read about which collation to select:
92837>>>>>>>    // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
92837>>>>>>>    Procedure Set psCollation String sCollation
92839>>>>>>>        Set private.psCollation to sCollation
92840>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
92842>>>>>>>            Set psCollation of ghoDbUpdateHandler to sCollation
92843>>>>>>>        End
92843>>>>>>>>
92843>>>>>>>    End_Procedure
92844>>>>>>>
92844>>>>>>>    Function psCollation Returns String
92846>>>>>>>        String sCollation
92846>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
92848>>>>>>>            Get psCollation of ghoDbUpdateHandler to sCollation
92849>>>>>>>        End   
92849>>>>>>>>
92849>>>>>>>        Else Begin
92850>>>>>>>            Get private.psCollation to sCollation
92851>>>>>>>        End
92851>>>>>>>>
92851>>>>>>>        Function_Return sCollation
92852>>>>>>>    End_Function
92853>>>>>>>
92853>>>>>>>
92853>>>>>>>    Function StrToFieldNumber Integer iFile String sField Returns Integer
92855>>>>>>>        Integer iMax iPos
92855>>>>>>>        String sName
92855>>>>>>>
92855>>>>>>>        Move (Lowercase(sField)) to sField
92856>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
92859>>>>>>>        for iPos from 0 to iMax
92865>>>>>>>>
92865>>>>>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
92868>>>>>>>            Move (Lowercase(sName)) to sName
92869>>>>>>>            If (sName = sField) Begin
92871>>>>>>>                Function_Return iPos
92872>>>>>>>            End
92872>>>>>>>>
92872>>>>>>>        Loop
92873>>>>>>>>
92873>>>>>>>        Function_Return -1
92874>>>>>>>    End_Function
92875>>>>>>>
92875>>>>>>>
92875>>>>>>>    // * Dummy function for the Studio's Code Explorer *
92875>>>>>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
92877>>>>>>>        Function_Return False
92878>>>>>>>    End_Function
92879>>>>>>>
92879>>>>>>>    // *** Helper functions with compiled sql script code ***
92879>>>>>>>    //
92879>>>>>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
92879>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
92879>>>>>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
92879>>>>>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
92879>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
92879>>>>>>>    //   ALTER TABLE MyTable
92879>>>>>>>    //       REBUILD
92879>>>>>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
92881>>>>>>>        Boolean bOK
92881>>>>>>>
92881>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
92883>>>>>>>            Function_Return False
92884>>>>>>>        End
92884>>>>>>>>
92884>>>>>>>
92884>>>>>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
92884>>>>>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
92885>>>>>>>
92885>>>>>>>        Function_Return (bOK = True)
92886>>>>>>>    End_Function
92887>>>>>>>
92887>>>>>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
92887>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
92887>>>>>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
92887>>>>>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
92887>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
92887>>>>>>>    //   ALTER TABLE MyTable
92887>>>>>>>    //       REBUILD
92887>>>>>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
92889>>>>>>>        tSQLScriptArray SQLScriptArray
92889>>>>>>>        tSQLScriptArray SQLScriptArray
92889>>>>>>>        String sDriverID
92889>>>>>>>        Boolean bOK
92889>>>>>>>        Integer iSize iCount
92889>>>>>>>
92889>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
92891>>>>>>>            Function_Return False
92892>>>>>>>        End
92892>>>>>>>>
92892>>>>>>>
92892>>>>>>>        Get psDriverID to sDriverID
92893>>>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
92894>>>>>>>        If (SQLScriptArray.bError = True) Begin
92896>>>>>>>            Function_Return False
92897>>>>>>>        End
92897>>>>>>>>
92897>>>>>>>
92897>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
92898>>>>>>>        Decrement iSize
92899>>>>>>>
92899>>>>>>>        for iCount from 0 to iSize
92905>>>>>>>>
92905>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
92907>>>>>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
92908>>>>>>>            End
92908>>>>>>>>
92908>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
92910>>>>>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
92911>>>>>>>            End
92911>>>>>>>>
92911>>>>>>>        Loop
92912>>>>>>>>
92912>>>>>>>
92912>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
92913>>>>>>>
92913>>>>>>>        Function_Return (bOK = True)
92914>>>>>>>    End_Function
92915>>>>>>>
92915>>>>>>>    Function _SqlUtilCreatePostGreSQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
92917>>>>>>>        tSQLScriptArray SQLScriptArray
92917>>>>>>>        tSQLScriptArray SQLScriptArray
92917>>>>>>>        String sDriverID sCollation
92917>>>>>>>        Boolean bOK
92917>>>>>>>        Integer iSize iCount
92917>>>>>>>
92917>>>>>>>        If (Trim(sDatabaseName) = "") Begin
92919>>>>>>>            Function_Return False
92920>>>>>>>        End
92920>>>>>>>>
92920>>>>>>>
92920>>>>>>>        Get psDriverID  to sDriverID
92921>>>>>>>        Get psCollation to sCollation
92922>>>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
92923>>>>>>>        If (SQLScriptArray.bError = True) Begin
92925>>>>>>>            Function_Return False
92926>>>>>>>        End
92926>>>>>>>>
92926>>>>>>>
92926>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
92927>>>>>>>        Decrement iSize
92928>>>>>>>
92928>>>>>>>        for iCount from 0 to iSize
92934>>>>>>>>
92934>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
92936>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
92937>>>>>>>            End
92937>>>>>>>>
92937>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
92939>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
92940>>>>>>>            End
92940>>>>>>>>
92940>>>>>>>        Loop
92941>>>>>>>>
92941>>>>>>>
92941>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
92942>>>>>>>
92942>>>>>>>        Function_Return (bOK = True)
92943>>>>>>>    End_Function
92944>>>>>>>
92944>>>>>>>    Function _SqlUtilCreateMySQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
92946>>>>>>>        tSQLScriptArray SQLScriptArray
92946>>>>>>>        tSQLScriptArray SQLScriptArray
92946>>>>>>>        String sDriverID sCollation
92946>>>>>>>        Boolean bOK
92946>>>>>>>        Integer iSize iCount
92946>>>>>>>
92946>>>>>>>        If (Trim(sDatabaseName) = "") Begin
92948>>>>>>>            Function_Return False
92949>>>>>>>        End
92949>>>>>>>>
92949>>>>>>>
92949>>>>>>>        Get psDriverID  to sDriverID
92950>>>>>>>        Get psCollation to sCollation
92951>>>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
92952>>>>>>>        If (SQLScriptArray.bError = True) Begin
92954>>>>>>>            Function_Return False
92955>>>>>>>        End
92955>>>>>>>>
92955>>>>>>>
92955>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
92956>>>>>>>        Decrement iSize
92957>>>>>>>
92957>>>>>>>        for iCount from 0 to iSize
92963>>>>>>>>
92963>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
92965>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
92966>>>>>>>            End
92966>>>>>>>>
92966>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
92968>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
92969>>>>>>>            End
92969>>>>>>>>
92969>>>>>>>        Loop
92970>>>>>>>>
92970>>>>>>>        // ToDo: THIS FAILS BUT THE SQL SCRIPT WORKS IN MYSQL!
92970>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
92971>>>>>>>
92971>>>>>>>        Function_Return (bOK = True)
92972>>>>>>>    End_Function
92973>>>>>>>
92973>>>>>>>    // *** Helper functions for Mertech Drivers ***
92973>>>>>>>    // Created to not clutter up the standard function code with lots of #IFDEF's
92973>>>>>>>    // and commands that the Studio editor knows nothing about.
92973>>>>>>>    Function _MertechDeleteTDFile String sTableName Returns Boolean
92975>>>>>>>        Integer iRetval
92975>>>>>>>        String sPath
92975>>>>>>>
92975>>>>>>>        If (sPath = "" or sTableName = "") Begin
92977>>>>>>>            Function_Return True
92978>>>>>>>        End
92978>>>>>>>>
92978>>>>>>>
92978>>>>>>>        Get vFolderFormat sPath to sPath
92979>>>>>>>        Get vDeleteFile (sPath + String(sTableName) + ".td") to iRetval
92980>>>>>>>        Function_Return (iRetval = 0)
92981>>>>>>>    End_Function
92982>>>>>>>
92982>>>>>>>    Function _MertechSqlUtilCreateIntFile Handle hTable String sTableName String sDataPath String sPhysicalFileName Returns Boolean
92984>>>>>>>        Boolean bOpen bOK
92984>>>>>>>        Move False to Err
92985>>>>>>>        Function_Return (Err = False)
92986>>>>>>>    End_Function
92987>>>>>>>
92987>>>>>>>    Function _MertechEnumerateSQLFlexServers Returns String[]
92989>>>>>>>        Integer iNumItems iCount
92989>>>>>>>        String[] sReturnArray
92990>>>>>>>        String sServer
92990>>>>>>>
92990>>>>>>>
92990>>>>>>>        Function_Return sReturnArray
92991>>>>>>>    End_Function
92992>>>>>>>
92992>>>>>>>    Function _MertechEnumerateORAFLEXServers Returns String[]
92994>>>>>>>        String[] sReturnArray
92995>>>>>>>        String sServer
92995>>>>>>>
92995>>>>>>>
92995>>>>>>>        Function_Return sReturnArray
92996>>>>>>>    End_Function
92997>>>>>>>
92997>>>>>>>    Function _MertechSQLConnect String sDriverID String sServer String sUserID String sPassword Returns Handle
92999>>>>>>>        Handle hoSQLHandler hoSQLConnect
92999>>>>>>>
92999>>>>>>>        Move 0 to hoSQLConnect
93000>>>>>>>
93000>>>>>>>        Function_Return hoSQLConnect
93001>>>>>>>    End_Function
93002>>>>>>>
93002>>>>>>>    // Returns the handle of the Mertech SQL handler.
93002>>>>>>>    // It also ensures that the correct Server & Database attributes are set both for
93002>>>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
93002>>>>>>>    Function _MertechSQLManagerHandle Returns Handle
93004>>>>>>>        Handle hoSQLHandler
93004>>>>>>>        String sDriverID sServer sDatabase
93004>>>>>>>
93004>>>>>>>        Move 0 to hoSQLHandler
93005>>>>>>>        Get psDriverID to sDriverID
93006>>>>>>>        Get psServer   to sServer
93007>>>>>>>        Get psDatabase to sDatabase
93008>>>>>>>
93008>>>>>>>        Function_Return hoSQLHandler
93009>>>>>>>    End_Function
93010>>>>>>>
93010>>>>>>>    // For Mertech drivers we cannot use Structure_Start/End. Instead we must use
93010>>>>>>>    // macro-commands <sigh!>
93010>>>>>>>    // Note: The function sets the Err flag.
93010>>>>>>>    Function _MertechApiTableConvertToSQL Handle hTable String sRootName String sDatabase String sDriverID String sBaseTableSpace String sIndexTableSpace Boolean bToAnsi Boolean bCopyData Returns Boolean
93012>>>>>>>
93012>>>>>>>        Move False to Err
93013>>>>>>>
93013>>>>>>>        Function_Return (Err = False)
93014>>>>>>>    End_Function
93015>>>>>>>
93015>>>>>>>    Function _MertechCopyDataToSQL Handle hTable String sRootName String sDriverID Returns Boolean
93017>>>>>>>        Move False to Err
93018>>>>>>>        Function_Return (Err = False)
93019>>>>>>>    End_Function
93020>>>>>>>
93020>>>>>>>End_Class
93021>>>>>Use for_all.pkg // Handy to have available in the OnUpdate event.
Including file: for_all.pkg    (C:\Program Files\DataFlex 20.1\Pkg\for_all.pkg)
93021>>>>>>>// This module contains the command definitions for the FOR_ALL construct.
93021>>>>>>>//
93021>>>>>>>// FOR_ALL is used to select and process a set of records in a database file;
93021>>>>>>>// FOR_ALL constructs may be nested. FOR_ALL is intended to work in
93021>>>>>>>// conjunction with constraint-clauses.
93021>>>>>>>//
93021>>>>>>>// SYNTAX:
93021>>>>>>>//
93021>>>>>>>//  For_All <File> BY|DOWN <Index> {AS QUE|QUEUE} {DO}
93021>>>>>>>//    <Constraints...>
93021>>>>>>>//    {DO}
93021>>>>>>>//      <loop body>
93021>>>>>>>//  End_For_All
93021>>>>>>>//
93021>>>>>>>// This set of macros implements a constraint-oriented file enumeration
93021>>>>>>>// syntax.  For example, to list all Customers by name in reverse order:
93021>>>>>>>//
93021>>>>>>>//   For_All Customer DOWN Customer.Customer_Name DO
93021>>>>>>>//     showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
93021>>>>>>>//   End_For_All
93021>>>>>>>//
93021>>>>>>>// To list only Customers with a Balance greater than their credit limit:
93021>>>>>>>//
93021>>>>>>>//   For_All Customer BY Index.1
93021>>>>>>>//     CONSTRAIN Customer.Balance GT Customer.Credit_Limit
93021>>>>>>>//     DO
93021>>>>>>>//       showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
93021>>>>>>>//   End_For_All
93021>>>>>>>//
93021>>>>>>>// Constraint clauses are:
93021>>>>>>>//
93021>>>>>>>//   CONSTRAIN <File> RELATES TO <File> ...
93021>>>>>>>//   CONSTRAIN <File> AS <Expression>
93021>>>>>>>//   CONSTRAIN <File.Field> AS <Expression>
93021>>>>>>>//   CONSTRAIN <File.Field> BETWEEN <lowBound> AND <highBound>
93021>>>>>>>//
93021>>>>>>>// For example, to list all customers with a bad status whose names start
93021>>>>>>>// with "A" and which have not made a payment in thirty days:
93021>>>>>>>//
93021>>>>>>>//    For_All Customer BY Index.2       //Index.2 = <Status>+<Name>
93021>>>>>>>//      CONSTRAIN Customer.Status EQ BAD
93021>>>>>>>//      CONSTRAIN Customer.Customer_Name GE "A"
93021>>>>>>>//      CONSTRAIN Customer.Customer_Name LT "B"
93021>>>>>>>//      CONSTRAIN Customer.Last_Pymt_Date LE (Today - 30)
93021>>>>>>>//      DO
93021>>>>>>>//        showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
93021>>>>>>>//    End_For_All
93021>>>>>>>//
93021>>>>>>>
93021>>>>>>>
93021>>>>>>>//This command starts the loop process body when constraints are used;
93021>>>>>>>//If no constraints are required, DO should be specified on the FOR_ALL
93021>>>>>>>//command line, and not on a line by itself
93021>>>>>>>//
93021>>>>>>>
93021>>>>>>>//Ends a For_All loop
93021>>>>>>>//
93021>>>>>>>
93021>>>>>>>
93021>>>>>
93021>>>>>
93021>>>>>Class cDbUpdateVersion is a cObject
93022>>>>>
93022>>>>>    Procedure Construct_Object    
93024>>>>>        Boolean bOnCreateExecuted bUseCustomDbVersion
93024>>>>>        String[] aSQLQueryMessages
93025>>>>>        
93025>>>>>        Forward Send Construct_Object
93027>>>>>
93027>>>>>        // cDbUpdateHandler object event.
93027>>>>>        Delegate Get Private.pbOnCreateExecuted to bOnCreateExecuted
93029>>>>>        If (bOnCreateExecuted = False) Begin    
93031>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
93033>>>>>            If (bUseCustomDbVersion = False) Begin
93035>>>>>                Delegate Send CheckAutoCreateDbVersionTable 
93037>>>>>            End
93037>>>>>>
93037>>>>>            Delegate Send CheckIntFilesIntegrity
93039>>>>>            Delegate Send OnCreate
93041>>>>>            Delegate Set Private.pbOnCreateExecuted to True
93043>>>>>        End
93043>>>>>>
93043>>>>>
93043>>>>>        // Don't touch! It is used by class logic to indicate if the OnUpdate
93043>>>>>        // event was triggered, thus an actual change of the database was made.
93043>>>>>        Property Boolean pbVersionUpdate False
93044>>>>>
93044>>>>>        // This property must be manually set within each cDbUpdateVersion object
93044>>>>>        // by the programmer, to a consecutive number.
93044>>>>>        Property Number pnVersionNumber
93045>>>>>
93045>>>>>        Property Boolean pbUseConnectionID True
93046>>>>>        Property Boolean private.pbToANSI   True
93047>>>>>        Property Boolean private.pbRecnum   True
93048>>>>>        Property Boolean private.pbCopyData True
93049>>>>>        Property Boolean private.pbApiTableUpdateAuto False
93050>>>>>        Property Boolean private.pbCompareDate_DateTime False
93051>>>>>        Property Boolean private.pbCompareIndexAscending False
93052>>>>>        Property Boolean private.pbCompareIndexUppercase False
93053>>>>>        Property String private.psSchema
93054>>>>>        Property String private.psBaseTableSpace
93055>>>>>        Property String private.psLongTableSpace
93056>>>>>        Property String private.psIndexTableSpace
93057>>>>>
93057>>>>>        // Driver default value settings:
93057>>>>>        Property String private.psDriverDefaultValueASCII    ""
93058>>>>>        Property String private.psDriverDefaultValueBinary   ""
93059>>>>>        Property String private.psDriverDefaultValueDate     ""
93060>>>>>        Property String private.psDriverDefaultValueDateTime ""
93061>>>>>        Property String private.psDriverDefaultValueNumeric  ""
93062>>>>>        Property String private.psDriverDefaultValueText     ""
93063>>>>>
93063>>>>>        // Driver "nullability" settings:
93063>>>>>        Property Boolean private.pbDriverDefaultNullableASCII    False
93064>>>>>        Property Boolean private.pbDriverDefaultNullableBinary   False
93065>>>>>        Property Boolean private.pbDriverDefaultNullableDate     False
93066>>>>>        Property Boolean private.pbDriverDefaultNullableDateTime False
93067>>>>>        Property Boolean private.pbDriverDefaultNullableNumeric  False
93068>>>>>        Property Boolean private.pbDriverDefaultNullableText     False
93069>>>>>
93069>>>>>        // paSQLQueryMessages is a property of the container class cDbUpdateHandler.
93069>>>>>        // It is being used to gather ESQL message replies, and is output to the log file
93069>>>>>        // if pbVerboseState = True in the cDbUpdateHandler object.
93069>>>>>        // (See: Procedure Set pbDatabaseWasUpdated in the cDbUpdateHandler class)
93069>>>>>        // We reset it here for each cDbUpdateVersion object
93069>>>>>        Delegate Set paSQLQueryMessages to aSQLQueryMessages
93071>>>>>    End_Procedure
93072>>>>>
93072>>>>>    // *** Main hook event message ***
93072>>>>>    // Place your database update logic here!
93072>>>>>    Procedure OnUpdate
93074>>>>>    End_Procedure
93075>>>>>
93075>>>>>    // These properties also exists in the cDbUpdateFunctionLibray that is
93075>>>>>    // imported to the cDbUpdateHandler container class which should be a
93075>>>>>    // parent object to this object. To have the Studio's Property Panel
93075>>>>>    // "behave" aka show these properties we need to duplicate them in this
93075>>>>>    // class and "relay" them to the parent object.
93075>>>>>    Procedure Set pbToANSI Boolean bState
93077>>>>>        Set private.pbToANSI  to bState
93078>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93079>>>>>        Delegate Set pbToANSI to bState
93081>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93082>>>>>    End_Procedure
93083>>>>>
93083>>>>>    Function pbToANSI Returns Boolean
93085>>>>>        Function_Return (private.pbToAnsi(Self))
93086>>>>>    End_Function
93087>>>>>
93087>>>>>    Procedure Set pbRecnum Boolean bState
93089>>>>>        Set private.pbRecnum  to bState
93090>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93091>>>>>        Delegate Set pbRecnum to bState
93093>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93094>>>>>    End_Procedure
93095>>>>>
93095>>>>>    Function pbRecnum Returns Boolean
93097>>>>>        Function_Return (private.pbRecnum(Self))
93098>>>>>    End_Function
93099>>>>>
93099>>>>>    Procedure Set pbCopyData Boolean bState
93101>>>>>        Set private.pbCopyData  to bState
93102>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93103>>>>>        Delegate Set pbCopyData to bState
93105>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93106>>>>>    End_Procedure
93107>>>>>
93107>>>>>    Function pbCopyData Returns Boolean
93109>>>>>        Function_Return (private.pbCopyData(Self))
93110>>>>>    End_Function
93111>>>>>
93111>>>>>    // ToDo: Should we put these four properties under another "Property Panel" section?
93111>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
93113>>>>>        Set private.pbApiTableUpdateAuto  to bState
93114>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93115>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
93116>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93117>>>>>    End_Procedure
93118>>>>>
93118>>>>>    Function pbApiTableUpdateAuto Returns Boolean
93120>>>>>        Function_Return (private.pbApiTableUpdateAuto(Self))
93121>>>>>    End_Function
93122>>>>>
93122>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
93124>>>>>        Set private.pbCompareDate_DateTime  to bState
93125>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93126>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
93127>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93128>>>>>    End_Procedure
93129>>>>>
93129>>>>>    Function pbCompareDate_DateTime Returns Boolean
93131>>>>>        Function_Return (private.pbCompareDate_DateTime(Self))
93132>>>>>    End_Function
93133>>>>>
93133>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
93135>>>>>        Set private.pbCompareIndexAscending  to bState
93136>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93137>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
93138>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93139>>>>>    End_Procedure
93140>>>>>
93140>>>>>    Function pbCompareIndexAscending Returns Boolean
93142>>>>>        Function_Return (private.pbCompareIndexAscending(Self))
93143>>>>>    End_Function
93144>>>>>
93144>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
93146>>>>>        Set private.pbCompareIndexUppercase  to bState
93147>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93148>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
93149>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93150>>>>>    End_Procedure
93151>>>>>
93151>>>>>    Function pbCompareIndexUppercase Returns Boolean
93153>>>>>        Function_Return (private.pbCompareIndexUppercase(Self))
93154>>>>>    End_Function
93155>>>>>
93155>>>>>    Procedure Set psSchema String sValue
93157>>>>>        Set private.psSchema  to sValue
93158>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93159>>>>>        Delegate Set psSchema to sValue
93161>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93162>>>>>    End_Procedure
93163>>>>>
93163>>>>>    // First retrieve the private value that might have been set in the object.
93163>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93163>>>>>    // it might have been specified in the SQLConnections.ini file.
93163>>>>>    Function psSchema Returns String
93165>>>>>        String sValue
93165>>>>>        Get private.psSchema to sValue
93166>>>>>        If (sValue = "") Begin
93168>>>>>            Get psSchema of ghoSQLConnectionHandler to sValue
93169>>>>>        End
93169>>>>>>
93169>>>>>        Function_Return sValue
93170>>>>>    End_Function
93171>>>>>
93171>>>>>    Procedure Set psBaseTableSpace String sValue
93173>>>>>        Set private.psBaseTableSpace  to sValue
93174>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93175>>>>>        Delegate Set psBaseTableSpace to sValue
93177>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93178>>>>>    End_Procedure
93179>>>>>
93179>>>>>    // First retrieve the private value that might have been set in the object.
93179>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93179>>>>>    // it might have been specified in the SQLConnections.ini file.
93179>>>>>    Function psBaseTableSpace Returns String
93181>>>>>        String sValue
93181>>>>>        Get private.psBaseTableSpace to sValue
93182>>>>>        If (sValue = "") Begin
93184>>>>>            Get psBaseTableSpace of ghoSQLConnectionHandler to sValue
93185>>>>>        End
93185>>>>>>
93185>>>>>        Function_Return sValue
93186>>>>>    End_Function
93187>>>>>
93187>>>>>    Procedure Set psLongTableSpace String sValue
93189>>>>>        Set private.psLongTableSpace  to sValue
93190>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93191>>>>>        Delegate Set psLongTableSpace to sValue
93193>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93194>>>>>    End_Procedure
93195>>>>>
93195>>>>>    // First retrieve the private value that might have been set in the object.
93195>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93195>>>>>    // it might have been specified in the SQLConnections.ini file.
93195>>>>>    Function psLongTableSpace Returns String
93197>>>>>        String sValue
93197>>>>>        Get private.psLongTableSpace to sValue
93198>>>>>        If (sValue = "") Begin
93200>>>>>            Get psLongTableSpace of ghoSQLConnectionHandler to sValue
93201>>>>>        End
93201>>>>>>
93201>>>>>        Function_Return sValue
93202>>>>>    End_Function
93203>>>>>
93203>>>>>    Procedure Set psIndexTableSpace String sValue
93205>>>>>        Set private.psIndexTableSpace  to sValue
93206>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93207>>>>>        Delegate Set psIndexTableSpace to sValue
93209>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93210>>>>>    End_Procedure
93211>>>>>
93211>>>>>    // First retrieve the private value that might have been set in the object.
93211>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93211>>>>>    // it might have been specified in the SQLConnections.ini file.
93211>>>>>    Function psIndexTableSpace Returns String
93213>>>>>        String sValue
93213>>>>>        Get private.psIndexTableSpace to sValue
93214>>>>>        If (sValue = "") Begin
93216>>>>>            Get psIndexTableSpace of ghoSQLConnectionHandler to sValue
93217>>>>>        End
93217>>>>>>
93217>>>>>        Function_Return sValue
93218>>>>>    End_Function
93219>>>>>
93219>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
93221>>>>>        Set private.psDriverDefaultValueASCII  to sValue
93222>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93223>>>>>        Delegate Set psDriverDefaultValueASCII to sValue
93225>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93226>>>>>    End_Procedure
93227>>>>>
93227>>>>>    // First retrieve the private value that might have been set in the object.
93227>>>>>    // If blank; get it from the parent object
93227>>>>>    Function psDriverDefaultValueASCII Returns String
93229>>>>>        String sValue
93229>>>>>        Get private.psDriverDefaultValueASCII to sValue
93230>>>>>        If (sValue = "") Begin
93232>>>>>            Delegate Get psDriverDefaultValueASCII to sValue
93234>>>>>        End
93234>>>>>>
93234>>>>>        Function_Return sValue
93235>>>>>    End_Function
93236>>>>>
93236>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
93238>>>>>        Set private.psDriverDefaultValueBinary  to sValue
93239>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93240>>>>>        Delegate Set psDriverDefaultValueBinary to sValue
93242>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93243>>>>>    End_Procedure
93244>>>>>
93244>>>>>    // First retrieve the private value that might have been set in the object.
93244>>>>>    // If blank; get it from the parent object
93244>>>>>    Function psDriverDefaultValueBinary Returns String
93246>>>>>        String sValue
93246>>>>>        Get private.psDriverDefaultValueBinary to sValue
93247>>>>>        If (sValue = "") Begin
93249>>>>>            Delegate Get psDriverDefaultValueBinary to sValue
93251>>>>>        End
93251>>>>>>
93251>>>>>        Function_Return sValue
93252>>>>>    End_Function
93253>>>>>
93253>>>>>    Procedure Set psDriverDefaultValueDate String sValue
93255>>>>>        Set private.psDriverDefaultValueDate  to sValue
93256>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93257>>>>>        Delegate Set psDriverDefaultValueDate to sValue
93259>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93260>>>>>    End_Procedure
93261>>>>>
93261>>>>>    // First retrieve the private value that might have been set in the object.
93261>>>>>    // If blank; get it from the parent object
93261>>>>>    Function psDriverDefaultValueDate Returns String
93263>>>>>        String sValue
93263>>>>>        Get private.psDriverDefaultValueDate to sValue
93264>>>>>        If (sValue = "") Begin
93266>>>>>            Delegate Get psDriverDefaultValueDate to sValue
93268>>>>>        End
93268>>>>>>
93268>>>>>        Function_Return sValue
93269>>>>>    End_Function
93270>>>>>
93270>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
93272>>>>>        Set private.psDriverDefaultValueDateTime  to sValue
93273>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93274>>>>>        Delegate Set psDriverDefaultValueDateTime to sValue
93276>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93277>>>>>    End_Procedure
93278>>>>>
93278>>>>>    // First retrieve the private value that might have been set in the object.
93278>>>>>    // If blank; get it from the parent object
93278>>>>>    Function psDriverDefaultValueDateTime Returns String
93280>>>>>        String sValue
93280>>>>>        Get private.psDriverDefaultValueDateTime to sValue
93281>>>>>        If (sValue = "") Begin
93283>>>>>            Delegate Get psDriverDefaultValueDateTime to sValue
93285>>>>>        End
93285>>>>>>
93285>>>>>        Function_Return sValue
93286>>>>>    End_Function
93287>>>>>
93287>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
93289>>>>>        Set private.psDriverDefaultValueNumeric  to sValue
93290>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93291>>>>>        Delegate Set psDriverDefaultValueNumeric to sValue
93293>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93294>>>>>    End_Procedure
93295>>>>>
93295>>>>>    // First retrieve the private value that might have been set in the object.
93295>>>>>    // If blank; get it from the parent object
93295>>>>>    Function psDriverDefaultValueNumeric Returns String
93297>>>>>        String sValue
93297>>>>>        Get private.psDriverDefaultValueNumeric to sValue
93298>>>>>        If (sValue = "") Begin
93300>>>>>            Delegate Get psDriverDefaultValueNumeric to sValue
93302>>>>>        End
93302>>>>>>
93302>>>>>        Function_Return sValue
93303>>>>>    End_Function
93304>>>>>
93304>>>>>    Procedure Set psDriverDefaultValueText String sValue
93306>>>>>        Set private.psDriverDefaultValueText  to sValue
93307>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93308>>>>>        Delegate Set psDriverDefaultValueText to sValue
93310>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93311>>>>>    End_Procedure
93312>>>>>
93312>>>>>    // First retrieve the private value that might have been set in the object.
93312>>>>>    // If blank; get it from the parent object
93312>>>>>    Function psDriverDefaultValueText Returns String
93314>>>>>        String sValue
93314>>>>>        Get private.psDriverDefaultValueText to sValue
93315>>>>>        If (sValue = "") Begin
93317>>>>>            Delegate Get psDriverDefaultValueText to sValue
93319>>>>>        End
93319>>>>>>
93319>>>>>        Function_Return sValue
93320>>>>>    End_Function
93321>>>>>
93321>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
93323>>>>>        Set private.pbDriverDefaultNullableASCII  to bState
93324>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93325>>>>>        Delegate Set pbDriverDefaultNullableASCII to bState
93327>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93328>>>>>    End_Procedure
93329>>>>>
93329>>>>>    // First retrieve the private value that might have been set in the object.
93329>>>>>    // If blank; get it from the parent object
93329>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
93331>>>>>        Boolean bState
93331>>>>>        Get private.pbDriverDefaultNullableASCII to bState
93332>>>>>        If (bState = False) Begin
93334>>>>>            Delegate Get pbDriverDefaultNullableASCII to bState
93336>>>>>        End
93336>>>>>>
93336>>>>>        Function_Return bState
93337>>>>>    End_Function
93338>>>>>
93338>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
93340>>>>>        Set private.pbDriverDefaultNullableBinary  to bState
93341>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93342>>>>>        Delegate Set pbDriverDefaultNullableBinary to bState
93344>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93345>>>>>    End_Procedure
93346>>>>>
93346>>>>>    // First retrieve the private value that might have been set in the object.
93346>>>>>    // If blank; get it from the parent object
93346>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
93348>>>>>        Boolean bState
93348>>>>>        Get private.pbDriverDefaultNullableBinary to bState
93349>>>>>        If (bState = False) Begin
93351>>>>>            Delegate Get pbDriverDefaultNullableBinary to bState
93353>>>>>        End
93353>>>>>>
93353>>>>>        Function_Return bState
93354>>>>>    End_Function
93355>>>>>
93355>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
93357>>>>>        Set private.pbDriverDefaultNullableDate  to bState
93358>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93359>>>>>        Delegate Set pbDriverDefaultNullableDate to bState
93361>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93362>>>>>    End_Procedure
93363>>>>>
93363>>>>>    // First retrieve the private value that might have been set in the object.
93363>>>>>    // If blank; get it from the parent object
93363>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
93365>>>>>        Boolean bState
93365>>>>>        Get private.pbDriverDefaultNullableDate to bState
93366>>>>>        If (bState = False) Begin
93368>>>>>            Delegate Get pbDriverDefaultNullableDate to bState
93370>>>>>        End
93370>>>>>>
93370>>>>>        Function_Return bState
93371>>>>>    End_Function
93372>>>>>
93372>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
93374>>>>>        Set private.pbDriverDefaultNullableDateTime  to bState
93375>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93376>>>>>        Delegate Set pbDriverDefaultNullableDateTime to bState
93378>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93379>>>>>    End_Procedure
93380>>>>>
93380>>>>>    // First retrieve the private value that might have been set in the object.
93380>>>>>    // If blank; get it from the parent object
93380>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
93382>>>>>        Boolean bState
93382>>>>>        Get private.pbDriverDefaultNullableDateTime to bState
93383>>>>>        If (bState = False) Begin
93385>>>>>            Delegate Get pbDriverDefaultNullableDateTime to bState
93387>>>>>        End
93387>>>>>>
93387>>>>>        Function_Return bState
93388>>>>>    End_Function
93389>>>>>
93389>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
93391>>>>>        Set private.pbDriverDefaultNullableNumeric  to bState
93392>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93393>>>>>        Delegate Set pbDriverDefaultNullableNumeric to bState
93395>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93396>>>>>    End_Procedure
93397>>>>>
93397>>>>>    // First retrieve the private value that might have been set in the object.
93397>>>>>    // If blank; get it from the parent object
93397>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
93399>>>>>        Boolean bState
93399>>>>>        Get private.pbDriverDefaultNullableNumeric to bState
93400>>>>>        If (bState = False) Begin
93402>>>>>            Delegate Get pbDriverDefaultNullableNumeric to bState
93404>>>>>        End
93404>>>>>>
93404>>>>>        Function_Return bState
93405>>>>>    End_Function
93406>>>>>
93406>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
93408>>>>>        Set private.pbDriverDefaultNullableText  to bState
93409>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93410>>>>>        Delegate Set pbDriverDefaultNullableText to bState
93412>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93413>>>>>    End_Procedure
93414>>>>>
93414>>>>>    // First retrieve the private value that might have been set in the object.
93414>>>>>    // If blank; get it from the parent object
93414>>>>>    Function pbDriverDefaultNullableText Returns Boolean
93416>>>>>        Boolean bState
93416>>>>>        Get private.pbDriverDefaultNullableText to bState
93417>>>>>        If (bState = False) Begin
93419>>>>>            Delegate Get pbDriverDefaultNullableText to bState
93421>>>>>        End
93421>>>>>>
93421>>>>>        Function_Return bState
93422>>>>>    End_Function
93423>>>>>
93423>>>>>    Function ApiTableConvertToSQL Handle hTable Returns Boolean
93425>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK
93425>>>>>        String sDriverID sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace
93425>>>>>
93425>>>>>        Get psDriverID to sDriverID
93426>>>>>        Get psSchema to sSchema
93427>>>>>
93427>>>>>        Get psBaseTableSpace to sBaseTableSpace
93428>>>>>        If (sBaseTableSpace <> "") Begin
93430>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93431>>>>>            Delegate Set psBaseTableSpace to sBaseTableSpace
93433>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93434>>>>>        End
93434>>>>>>
93434>>>>>
93434>>>>>        Get psLongTableSpace to sLongTableSpace
93435>>>>>        If (sLongTableSpace <> "") Begin
93437>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93438>>>>>            Delegate Set psLongTableSpace to sLongTableSpace
93440>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93441>>>>>        End
93441>>>>>>
93441>>>>>
93441>>>>>        Get psIndexTableSpace to sIndexTableSpace
93442>>>>>        If (sIndexTableSpace <> "") Begin
93444>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93445>>>>>            Delegate Set psIndexTableSpace to sIndexTableSpace
93447>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93448>>>>>        End
93448>>>>>>
93448>>>>>
93448>>>>>        Get pbUseConnectionID to bUseConnectionID
93449>>>>>        Get pbToANSI          to bToANSI
93450>>>>>        Get pbRecnum          to bRecnum
93451>>>>>        Get pbCopyData        to bCopyData
93452>>>>>
93452>>>>>        Get ApiTableConvertToSQL_Ex hTable sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
93453>>>>>
93453>>>>>        Function_Return bOK
93454>>>>>    End_Function
93455>>>>>
93455>>>>>//    Function ApiTableMoveAllToBackupFolder Returns Boolean
93455>>>>>//        Boolean bOK bExists
93455>>>>>//        String sDataPath sBackupFolder
93455>>>>>//        
93455>>>>>//        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
93455>>>>>//        Move CS_DUFBackupDataFolder to sBackupFolder
93455>>>>>//        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
93455>>>>>//        Get vFolderFormat sDataPath to sDataPath
93455>>>>>//        
93455>>>>>//        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
93455>>>>>//        If (bExists = False) Begin
93455>>>>>//            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
93455>>>>>//            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
93455>>>>>//            If (bExists = False) Begin
93455>>>>>//                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
93455>>>>>//                Function_Return False
93455>>>>>//            End                                                                                                                                            
93455>>>>>//            Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
93455>>>>>//            Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
93455>>>>>//            Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
93455>>>>>//            Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
93455>>>>>//        End
93455>>>>>//        
93455>>>>>//        Set Message_Text of ghoStatusPanel to ""
93455>>>>>//        Function_Return bOK
93455>>>>>//    End_Function
93455>>>>>//
93455>>>>>    // This is automatically called after the OnUpdate
93455>>>>>    // event has been executed. It will automatically update the
93455>>>>>    // version database field/column with the "pnVersionNumber"
93455>>>>>    // value of the parent cDbUpdateHandler class - if it has been changed.
93455>>>>>    Procedure UpdateVersionColumnValue
93457>>>>>        Number nVersion nCurrentValue
93457>>>>>        Integer hTable iColumn
93457>>>>>        Boolean bVersionUpdate bDbUpdateErrorHasOccured bUseCustomDbVersion
93457>>>>>
93457>>>>>        // This is a property of the container class; cDbUpdateHandler that gets set when
93457>>>>>        // an error occurres when processing ESQL or database API messages of the cDbUpdateFunctionLibrary.
93457>>>>>        Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
93459>>>>>        Get pbVersionUpdate to bVersionUpdate
93460>>>>>
93460>>>>>        If (bVersionUpdate = True and bDbUpdateErrorHasOccured = False) Begin
93462>>>>>            Get pnVersionNumber to nVersion
93463>>>>>            Delegate Get piDbVersionFileNumber  to hTable
93465>>>>>            Delegate Get piDbVersionFieldNumber to iColumn
93467>>>>>            // NB! We need to permanently close tables as they e.g. now might no longer be embedded
93467>>>>>            // but instead SQL tables. If we don't the "old" embedded table will be opened instead.
93467>>>>>            Close DF_ALL DF_PERMANENT
93468>>>>>
93468>>>>>            Open hTable
93470>>>>>
93470>>>>>            // It is then the developer responsibility to take care of finding
93470>>>>>            // the correct record that is to be updated (The DbVersion table is not used). 
93470>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
93472>>>>>            If (bUseCustomDbVersion = True) Begin
93474>>>>>                Delegate Send OnFindVersionRecord   // cDbUpdateHandler object event (Programmer's hook!).
93476>>>>>            End
93476>>>>>>
93476>>>>>
93476>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
93479>>>>>            If (nCurrentValue < nVersion) Begin
93481>>>>>                Lock
93482>>>>>>
93482>>>>>                    If (bUseCustomDbVersion = False) Begin
93484>>>>>                        Vfind hTable Recnum GE                            
93486>>>>>                    End
93486>>>>>>
93486>>>>>                    Set_Field_Value hTable iColumn to nVersion
93489>>>>>                    SaveRecord hTable
93490>>>>>                Unlock
93491>>>>>>
93491>>>>>            End
93491>>>>>>
93491>>>>>            Close hTable
93492>>>>>        End
93492>>>>>>
93492>>>>>    End_Procedure
93493>>>>>
93493>>>>>// Property of the container object (cDbUpdateHandler)
93493>>>>>Register_Function piCurrentErrorHandlerID Returns Integer
93493>>>>>
93493>>>>>    Procedure End_Construct_Object
93495>>>>>        Forward Send End_Construct_Object
93497>>>>>        Send ProcessUpdate True
93498>>>>>    End_Procedure
93499>>>>>    
93499>>>>>    Procedure ProcessUpdate Boolean bShouldTestForDuplicateVersionNumbers
93501>>>>>        Number nVersion nCurrentValue
93501>>>>>        Integer hTable iColumn iSize iDbVersionFileNumber iStatus
93501>>>>>        Boolean bStopOnFirstError bDbUpdateErrorHasOccured bContinueOnError bOpened bSystemTable bUseCustomDbVersion bTableExists bOnPreUpdateExecuted
93501>>>>>        String sObjectName
93501>>>>>        tDbVersionInfo[] dbVersionInfoArray
93501>>>>>        tDbVersionInfo[] dbVersionInfoArray
93502>>>>>
93502>>>>>        Delegate Set Private.pbUpdateVersionObjectError to False
93504>>>>>
93504>>>>>        // If the programmer forgot to set the version number we do not allow for the application
93504>>>>>        // to continue to run, as this potentially could endanger the integrity of the database. E.g. if
93504>>>>>        // one database update is depended on an earlier update and that earlier version
93504>>>>>        // update was never executed it could lead to disastrous results.
93504>>>>>        // This is a programmer error and should be discovered before any customer sees it. Thus no point in translating...
93504>>>>>        Get pnVersionNumber to nVersion
93505>>>>>        If (nVersion = 0) Begin
93507>>>>>            Get piCurrentErrorHandlerID to Error_Object_Id
93508>>>>>            Move (Name(Self)) to sObjectName
93509>>>>>            Error DFERR_PROGRAM ("The pnVersionNumber property was not set properly by the programmer for the following object; Program will now exit!\n\n" + sObjectName)
93510>>>>>>
93510>>>>>            Send Exit_Application
93511>>>>>        End
93511>>>>>>
93511>>>>>
93511>>>>>        // These are send to the parent container object (cDbUpdateHandler). The order is very sensitive!
93511>>>>>        // Hook event for the developer to e.g. create a database before the update events starts.
93511>>>>>        Delegate Get Private.pbOnPreUpdateExecuted to bOnPreUpdateExecuted
93513>>>>>        If (bOnPreUpdateExecuted = False) Begin
93515>>>>>            Delegate Send OnPreUpdate
93517>>>>>            Delegate Set Private.pbOnPreUpdateExecuted to True
93519>>>>>        End
93519>>>>>>
93519>>>>>        
93519>>>>>        Delegate Get piDbVersionFileNumber to iDbVersionFileNumber
93521>>>>>        
93521>>>>>        Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
93523>>>>>        If (bUseCustomDbVersion = False) Begin
93525>>>>>//            Delegate Send CheckAutoCreateDbVersionTable // cDbUpdateHandler object event.
93525>>>>>        End
93525>>>>>>
93525>>>>>        Else Begin
93526>>>>>            Get UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
93527>>>>>            If (bTableExists = False) Begin
93529>>>>>                Delegate Send OnCreateCustomDbVersionTable
93531>>>>>            End
93531>>>>>>
93531>>>>>        End
93531>>>>>>
93531>>>>>        
93531>>>>>        // We now check that two or more cDbVersion objects does not have the same pnVersionNumber.
93531>>>>>        // Note that the paDbVersionInfoArray is a property of the container object (cDbUpdateHandler)
93531>>>>>        If (bShouldTestForDuplicateVersionNumbers = True) Begin
93533>>>>>            Delegate Get paDbVersionInfoArray to dbVersionInfoArray
93535>>>>>            Move (SizeOfArray(dbVersionInfoArray)) to iSize
93536>>>>>            Move nVersion to dbVersionInfoArray[iSize].nVersionNumber
93537>>>>>            Move (Self)   to dbVersionInfoArray[iSize].hObject
93538>>>>>            Delegate Set paDbVersionInfoArray to dbVersionInfoArray
93540>>>>>            Delegate Send CheckForDuplicates nVersion   // cDbUpdateHandler object event.
93542>>>>>        End
93542>>>>>>
93542>>>>>
93542>>>>>        Delegate Get piDbVersionFileNumber  to hTable
93544>>>>>        Delegate Get piDbVersionFieldNumber to iColumn
93546>>>>>
93546>>>>>        Open hTable
93548>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
93551>>>>>        If (bOpened = False) Begin
93553>>>>>            Send Stop_Box CS_DUF_DbUpdateTableMissing
93554>>>>>            Send Exit_Application
93555>>>>>        End
93555>>>>>>
93555>>>>>        
93555>>>>>        // It can happen that the table isn't initialized with a record even though it is a system table,
93555>>>>>        // in case we take care of it here.
93555>>>>>        Get_Attribute DF_FILE_STATUS of hTable to iStatus
93558>>>>>        If (iStatus = DF_FILE_INACTIVE) Begin
93560>>>>>            Vfind hTable 0 GT
93562>>>>>        End
93562>>>>>>
93562>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemTable
93565>>>>>        If (bSystemTable = True) Begin
93567>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
93570>>>>>        End
93570>>>>>>
93570>>>>>        Else Begin
93571>>>>>            If (bUseCustomDbVersion = True) Begin
93573>>>>>                Send OnFindVersionRecord
93574>>>>>                Get_Field_Value hTable iColumn to nCurrentValue
93577>>>>>            End
93577>>>>>>
93577>>>>>        End
93577>>>>>>
93577>>>>>
93577>>>>>        Close hTable
93578>>>>>
93578>>>>>        // We also guard from missing 'DatabaseVersionInfoTable' and column properties settings.
93578>>>>>        // If not set we do nothing.
93578>>>>>        If (nCurrentValue < nVersion) Begin
93580>>>>>
93580>>>>>            // If pbStopOnFirstError is True in the parent, the idea is that we do _no_ further
93580>>>>>            // execution of database update code. So if true _and_ one error
93580>>>>>            // has already occured; we're out of here.
93580>>>>>            Delegate Get pbStopOnFirstError        to bStopOnFirstError
93582>>>>>            Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
93584>>>>>            If (bStopOnFirstError = True) Begin
93586>>>>>                If (bDbUpdateErrorHasOccured = True) Begin
93588>>>>>                    Procedure_Return
93589>>>>>                End
93589>>>>>>
93589>>>>>            End
93589>>>>>>
93589>>>>>
93589>>>>>            // This is send to the parent container object (cDbUpdateHandler)
93589>>>>>            Delegate Send InitDatabaseUpdate (Self)    // cDbUpdateHandler object event.
93591>>>>>
93591>>>>>            // If the parent property pbContinueOnError = False, an update
93591>>>>>            // of a following cDbUpdateVersion object should not take place and we're out of here.
93591>>>>>            Delegate Get pbContinueOnError to bContinueOnError
93593>>>>>            If (bContinueOnError = False and bDbUpdateErrorHasOccured = True) Begin
93595>>>>>                Procedure_Return
93596>>>>>            End
93596>>>>>>
93596>>>>>
93596>>>>>            Delegate Set pnCurrentVersionUpdate to nVersion
93598>>>>>
93598>>>>>            Set Title_Text of ghoStatusPanel to (CS_DUF_UpdateVersion * CS_DUF_UpdateFromVersion * String(nCurrentValue) * CS_DUF_UpdateToVersion * String(nVersion))
93599>>>>>
93599>>>>>            // *** Programmer's main hook event for database update functions:
93599>>>>>            Send OnUpdate
93600>>>>>
93600>>>>>            Set pbVersionUpdate to True
93601>>>>>            Send UpdateVersionColumnValue
93602>>>>>            Delegate Set pbDatabaseWasUpdated to True   // cDbUpdateHandler property.
93604>>>>>        End
93604>>>>>>
93604>>>>>
93604>>>>>    End_Procedure
93605>>>>>
93605>>>>>End_Class
93606>>>Use cDbUpdateUserCount.pkg
Including file: cDbUpdateUserCount.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.pkg)
93606>>>>>//****************************************************************************
93606>>>>>// $Module type: Class
93606>>>>>// $Module name: cDbUpdateUserCount.pkg
93606>>>>>// $Author     : Emil Stojanov Quantaris B.V.
93606>>>>>//
93606>>>>>//               Collected from DAW's newsgroups.
93606>>>>>//
93606>>>>>// Description : It uses the windows API to lock bytes in a file.
93606>>>>>//               If the application or PC craches it will release the lock
93606>>>>>//               automatically.
93606>>>>>//
93606>>>>>// Note 1      : It will count the number of running app's, so if a
93606>>>>>//               user starts the app twice on one machine it will count as two users.
93606>>>>>// Note 2      : The class was originally named cUserCount by Emil Stojanov.
93606>>>>>//               However, to not conflict with any other usage of this class it was
93606>>>>>//               renamed to "fit" into the "Database Update Framework" (cDbUpdateHandler
93606>>>>>//               and cDbUpdateVersion classes)
93606>>>>>//
93606>>>>>// $Rev History:
93606>>>>>//    2008-10-17  Module header created (Militaty data format)
93606>>>>>//    2008-10-17  Minor changes by Nils G Svedmyr. Created UI text constants
93606>>>>>//                for easy translation to other languages.
93606>>>>>//                Added the tUserCount struct for easier passing of parameters.
93606>>>>>//                Added the ApplicationPath message.
93606>>>>>//****************************************************************************
93606>>>>>Use LanguageText.pkg
93606>>>>>Use cDbUpdateUserCount.inc
Including file: cDbUpdateUserCount.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.inc)
93606>>>>>>>Use GlobalFunctionsProcedures.pkg
93606>>>>>>>// Sample:
93606>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
93606>>>>>>>
93606>>>>>>>
93606>>>>>>>// Symbols used by UserCounting
93606>>>>>>>    Define GENERIC_READ         for |CI$80000000
93606>>>>>>>    Define GENERIC_WRITE        for |CI$40000000
93606>>>>>>>    Define GENERIC_EXECUTE      for |CI$20000000
93606>>>>>>>    Define GENERIC_ALL          for |CI$10000000
93606>>>>>>>    Define CREATE_NEW           for 1
93606>>>>>>>    Define CREATE_ALWAYS        for 2
93606>>>>>>>    Define OPEN_EXISTING        for 3
93606>>>>>>>    Define OPEN_ALWAYS          for 4
93606>>>>>>>    Define TRUNCATE_EXISTING    for 5
93606>>>>>>>    Define FILE_BEGIN           for 0
93606>>>>>>>    Define FILE_CURRENT         for 1
93606>>>>>>>    Define FILE_END             for 2
93606>>>>>>>    Define FILE_SHARE_READ      for |CI$00000001
93606>>>>>>>    Define FILE_SHARE_WRITE     for |CI$00000002
93606>>>>>>>    Define FILE_SHARE_DELETE    for |CI$00000004
93606>>>>>>>    Define FILE_FLAG_WRITE_THROUGH            for |CI$80000000
93606>>>>>>>    Define _MAX_PATH  for 260
93606>>>>>>>    Define _MAX_DRIVE for 3
93606>>>>>>>    Define _MAX_DIR   for 256
93606>>>>>>>    Define _MAX_FNAME for 256
93606>>>>>>>    Define _MAX_EXT   for 256
93606>>>>>>>
93606>>>>>>>External_Function Win32_CreateFile "CreateFileA" KERNEL32.DLL ;    Pointer lpFileName ;              // file name    DWord dwDesiredAccess ;           // access mode    DWord dwShareMode ;               // share mode    Pointer lpSecurityAttributes ;    // SD    DWord dwCreationDisposition ;     // how to create    DWord dwFlagsAndAttributes ;      // file attributes    Handle hTemplateFile ;            // handle to template file    Returns Handle
93607>>>>>>>
93607>>>>>>>External_Function Win32_ReadFile "ReadFile" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Pointer lpBuffer ;              // pointer to the buffer that receives the data    dWord nNumberOfBytesToRead ;    // number of bytes to read    Pointer lpNumberOfBytesRead ;   // number of bytes read    Pointer lpOverlapped ;          // pointer to an overlapped structure    Returns Integer
93608>>>>>>>
93608>>>>>>>External_Function Win32_WriteFile "WriteFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    Pointer lpBuffer ;                  // pointer to buffer containing data to write    dWord nNumberOfBytesToWrite ;       // number of bytes to write    Pointer lpNumberOfBytesWritten ;    // number of bytes written    Pointer lpOverlapped ;              // pointer to an overlapped structure    Returns Integer
93609>>>>>>>
93609>>>>>>>External_Function Win32_LockFile "LockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToLockLow ;     // low-order word of length    dWord nNumberOfBytesToLockHigh ;    // high-order word of length    Returns Integer
93610>>>>>>>
93610>>>>>>>External_Function Win32_UnlockFile "UnlockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToUnLockLow ;   // low-order word of length    dWord nNumberOfBytesToUnLockHigh ;  // high-order word of length    Returns Integer
93611>>>>>>>
93611>>>>>>>External_Function Win32_SetFilePointer "SetFilePointer" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Integer lDistanceToMove ;       // bytes to move pointer (low-order 32-bits)    Pointer lpDistanceToMoveHigh ;  // bytes to move pointer (high-order 32-bits)    dWord dwMoveMethod ;            // starting point    Returns dWord
93612>>>>>>>
93612>>>>>>>External_Function Win32_CloseHandle "CloseHandle" KERNEL32.DLL ;    Handle hObject ;    // handle to object    Returns Integer
93613>>>>>>>
93613>>>>>>>External_Function SetDefaultPrinterEf "SetDefaultPrinterA" winspool.drv Pointer lpPrinter Returns Boolean
93614>>>>>>>// Sample:
93614>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
93614>>>>>>>Function DoSetDefaultPrinter String sPrinter Returns Boolean
93616>>>>>>>    Boolean bReturn
93616>>>>>>>    Move (Utf8ToAnsi(sPrinter)) to sPrinter
93617>>>>>>>    Move (sPrinter + (Character(0))) to sPrinter
93618>>>>>>>    Move (SetDefaultPrinterEf(AddressOf(sPrinter))) to bReturn
93619>>>>>>>    Function_Return bReturn
93620>>>>>>>End_Function
93621>>>>>Use vWin32fh.pkg
93621>>>>>Use seq_chnl.pkg
93621>>>>>
93621>>>>>// User interface constant strings:
93621>>>>>    Define CS_UserCountError            for "User count error:"
93621>>>>>    Define CS_UnableToInitUserCountSys  for "Unable to initialize user counting system!"
93621>>>>>    Define CS_UnableResetUserCountSys   for "Error resetting usercounting system!"
93621>>>>>    Define CS_ErrorAdvancingPointer     for "Error advancing file pointer!"
93621>>>>>    Define CS_MaxNoOfUserExceeded       for "Maximum number of users exceeded!"
93621>>>>>
93621>>>>>
93621>>>>>
93621>>>>>
93621>>>>>
93621>>>>>
93621>>>>>
93621>>>>>
93621>>>>>
93621>>>>>
93621>>>>>
93621>>>>>
93621>>>>>
93621>>>>>    Struct tUserCount
93621>>>>>        Integer iUserCount
93621>>>>>        Integer iError
93621>>>>>        String  sErrorTxt
93621>>>>>    End_Struct
93621>>>>>
93621>>>>>    Define CI_UserCountMaxUsers for 9999
93621>>>>>
93621>>>>>Class cDbUpdateUserCount is a cObject
93622>>>>>    Procedure Construct_Object
93624>>>>>        Forward Send Construct_Object
93626>>>>>
93626>>>>>        Property String  psLockFileName
93627>>>>>        Property Integer piMaxUsers
93628>>>>>        Property Boolean pbCheckDataFlexUserCount True
93629>>>>>
93629>>>>>        Property Handle  phUserCountFile
93630>>>>>        Property Integer pdwLockPosition
93631>>>>>    End_Procedure
93632>>>>>
93632>>>>>    Function IsProgramRunning Returns Boolean
93634>>>>>        tUserCount UserCount
93634>>>>>        tUserCount UserCount
93634>>>>>
93634>>>>>        Get CheckUserCount to UserCount
93635>>>>>
93635>>>>>        Function_Return (UserCount.iUserCount > 1)
93636>>>>>    End_Function
93637>>>>>
93637>>>>>    // Returns the full path of the Application (no trailing "\")
93637>>>>>    Function ApplicationPath Returns String
93639>>>>>        String sApplicationFileName sPath
93639>>>>>        Integer iNumChars iRetval
93639>>>>>
93639>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
93640>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
93641>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
93642>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
93643>>>>>        Move (CString(sApplicationFileName)) to sPath
93644>>>>>
93644>>>>>        Function_Return sPath
93645>>>>>    End_Function
93646>>>>>
93646>>>>>    Function OpenUserCountFile String sFileName Returns Handle
93648>>>>>        Handle  hFile
93648>>>>>        Pointer pFileName
93648>>>>>        String sPath sFile
93648>>>>>        Integer iCh
93648>>>>>
93648>>>>>        Move (Addressof(sFileName)) to pFileName
93649>>>>>        Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
93650>>>>>
93650>>>>>        // If lock file doesn't exist, create it.
93650>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
93652>>>>>            Get ApplicationPath to sPath
93653>>>>>            Get vFolderFormat sPath to sPath
93654>>>>>            Move (sPath + psLockFileName(Self)) to sFile
93655>>>>>            Get Seq_Open_Output_Channel sFile to iCh
93656>>>>>            If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
93658>>>>>                Function_Return 0
93659>>>>>            End
93659>>>>>>
93659>>>>>            Direct_Output channel iCh sFile
93661>>>>>                Write channel iCh ""
93663>>>>>            Send Seq_Close_Channel iCh
93664>>>>>            Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
93665>>>>>        End
93665>>>>>>
93665>>>>>
93665>>>>>        Function_Return hFile
93666>>>>>    End_Function
93667>>>>>
93667>>>>>    Function CloseUserCountFile Handle hFile Returns Integer
93669>>>>>        Integer iReturnValue 
93669>>>>>        Boolean bOK
93669>>>>>
93669>>>>>        Move (Win32_CloseHandle(hFile)) to iReturnValue
93670>>>>>        If (iReturnValue = 0) Begin
93672>>>>>            Move False to bOK
93673>>>>>        End
93673>>>>>>
93673>>>>>        Else Begin
93674>>>>>            Move True to bOK
93675>>>>>        End
93675>>>>>>
93675>>>>>        Function_Return bOK
93676>>>>>    End_Function
93677>>>>>
93677>>>>>    Function UnlockUserCountFile Handle hFile dWord dwLockPos Returns Integer
93679>>>>>        Integer iReturnValue
93679>>>>>        Boolean bOK
93679>>>>>
93679>>>>>        Move (Win32_UnLockFile(hFile, dwLockPos, 0, 1, 0)) to iReturnValue
93680>>>>>        If (iReturnValue = 0) Begin
93682>>>>>            Move False to bOK
93683>>>>>        End
93683>>>>>>
93683>>>>>        Else Begin
93684>>>>>            Move True to bOK
93685>>>>>        End           
93685>>>>>>
93685>>>>>        Function_Return bOK
93686>>>>>    End_Function
93687>>>>>
93687>>>>>    Function ReSetUserCountPointer Handle hFile Returns dWord
93689>>>>>        dWord dwCurrPos
93689>>>>>
93689>>>>>        Move (Win32_SetFilePointer(hFile, 0, 0, FILE_BEGIN)) to dwCurrPos
93690>>>>>        Function_Return dwCurrPos
93691>>>>>    End_Function
93692>>>>>
93692>>>>>    Function SetUserCountPointer Handle hFile Integer iAdvance Returns dWord
93694>>>>>        DWord dwCurrPos
93694>>>>>
93694>>>>>        Move (Win32_SetFilePointer(hFile, iAdvance, 0, FILE_CURRENT)) to dwCurrPos
93695>>>>>        Function_Return dwCurrPos
93696>>>>>    End_Function
93697>>>>>
93697>>>>>    Function ReadUserCountFile Handle hFile Returns Boolean
93699>>>>>        Integer iReturnValue                               
93699>>>>>        Boolean bOK
93699>>>>>        String  sBuffer
93699>>>>>        Pointer pBuffer
93699>>>>>        String  sSize
93699>>>>>        Pointer pSize
93699>>>>>
93699>>>>>        Move (Repeat((Character(0)),5)) to sBuffer
93700>>>>>        Move (AddressOf(sBuffer)) to pBuffer
93701>>>>>
93701>>>>>        Move (Repeat((Character(0)),4)) to sSize
93702>>>>>        Move (AddressOf(sSize)) to pSize
93703>>>>>
93703>>>>>        Move (Win32_ReadFile(hFile, pBuffer, 1, pSize, 0)) to iReturnValue
93704>>>>>        If (iReturnValue = 0) Begin
93706>>>>>            Move False to bOK
93707>>>>>        End
93707>>>>>>
93707>>>>>        Else Begin
93708>>>>>            Move True to bOK
93709>>>>>        End                 
93709>>>>>>
93709>>>>>        Function_Return bOK
93710>>>>>    End_Function
93711>>>>>
93711>>>>>    Function LockUserCountFile Handle hFile dWord dwFilePos Returns Integer
93713>>>>>        Integer iReturnValue
93713>>>>>
93713>>>>>        Move (Win32_LockFile(hFile, dwFilePos, 0, 1, 0)) to iReturnValue
93714>>>>>        Function_Return iReturnValue
93715>>>>>    End_Function
93716>>>>>
93716>>>>>    Procedure DoCheckUserCount
93718>>>>>        tUserCount UserCount
93718>>>>>        tUserCount UserCount
93718>>>>>
93718>>>>>        Get CheckUserCount to UserCount
93719>>>>>        // If all is fine, we're done.
93719>>>>>        If (UserCount.iError = 0) Begin
93721>>>>>            Procedure_Return
93722>>>>>        End
93722>>>>>>
93722>>>>>
93722>>>>>        Send UserError (CS_UserCountError * String(UserCount.iError) + "\n" + UserCount.sErrorTxt)
93723>>>>>
93723>>>>>        If (UserCount.iUserCount = CI_UserCountMaxUsers) Begin
93725>>>>>            Abort
93726>>>>>>
93726>>>>>        End
93726>>>>>>
93726>>>>>    End_Procedure
93727>>>>>
93727>>>>>    Function CheckUserCount Returns tUserCount
93729>>>>>        Handle  hFile
93729>>>>>        String  sPath sFile
93729>>>>>        Integer iResult
93729>>>>>        DWord   dwFilePos
93729>>>>>        Integer bLocked
93729>>>>>        Integer iMaxUsers
93729>>>>>        Integer iCurUser
93729>>>>>        tUserCount UserCount
93729>>>>>        tUserCount UserCount
93729>>>>>
93729>>>>>        Move 0 to UserCount.iError
93730>>>>>
93730>>>>>        Get phUserCountFile to hFile
93731>>>>>        If (not(hFile)) Begin
93733>>>>>            Get ApplicationPath to sPath
93734>>>>>            Get vFolderFormat sPath to sPath
93735>>>>>            Move (sPath + psLockFileName(Self)) to sFile
93736>>>>>            Get OpenUserCountFile sFile to hFile
93737>>>>>            If (hFile = INVALID_HANDLE_VALUE) Begin
93739>>>>>                Move 1 to UserCount.iUserCount
93740>>>>>                Move 1 to UserCount.iError
93741>>>>>                Move CS_UnableToInitUserCountSys to UserCount.sErrorTxt
93742>>>>>                Function_Return UserCount
93743>>>>>            End
93743>>>>>>
93743>>>>>            Else Begin
93744>>>>>                Move False to bLocked
93745>>>>>                Set phUserCountFile to hFile
93746>>>>>                Get piMaxUsers to iMaxUsers
93747>>>>>
93747>>>>>                // Set Filepointer to beginning of the file
93747>>>>>                Get ResetUserCountPointer hFile to dwFilePos
93748>>>>>                If (dwFilePos = -1) Begin
93750>>>>>                    Move 1 to UserCount.iUserCount
93751>>>>>                    Move 2 to UserCount.iError
93752>>>>>                    Move CS_UnableResetUserCountSys to UserCount.sErrorTxt
93753>>>>>                    Function_Return UserCount
93754>>>>>                End
93754>>>>>>
93754>>>>>                For iCurUser from 1 to iMaxUsers
93760>>>>>>
93760>>>>>                    Get LockUserCountFile hFile dwFilePos to iResult
93761>>>>>                    If (not(iResult)) Begin  // byte is locked
93763>>>>>                        Get SetUserCountPointer hFile 10 to dwFilePos
93764>>>>>                        If (dwFilePos = -1) Begin
93766>>>>>                            Move 1 to UserCount.iUserCount
93767>>>>>                            Move 3 to UserCount.iError
93768>>>>>                            Move CS_ErrorAdvancingPointer to UserCount.sErrorTxt
93769>>>>>                            Function_Return UserCount
93770>>>>>                        End
93770>>>>>>
93770>>>>>                    End
93770>>>>>>
93770>>>>>                    Else Begin  // byte is not locked
93771>>>>>                        Set pdwLockPosition to dwFilePos
93772>>>>>                        Move True to bLocked
93773>>>>>                        Move iMaxUsers to iCurUser
93774>>>>>                    End
93774>>>>>>
93774>>>>>                Loop
93775>>>>>>
93775>>>>>                If (not(bLocked)) Begin
93777>>>>>                    Move CI_UserCountMaxUsers to UserCount.iUserCount
93778>>>>>                    Move 4 to UserCount.iError
93779>>>>>                    Move CS_MaxNoOfUserExceeded to UserCount.sErrorTxt
93780>>>>>                    Function_Return UserCount
93781>>>>>                End
93781>>>>>>
93781>>>>>            End
93781>>>>>>
93781>>>>>        End
93781>>>>>>
93781>>>>>
93781>>>>>        Function_Return UserCount
93782>>>>>    End_Function
93783>>>>>
93783>>>>>
93783>>>>>    Procedure DoReleaseUserCount
93785>>>>>        Integer iResult
93785>>>>>        Handle  hFile
93785>>>>>        DWord   dwLockPos
93785>>>>>
93785>>>>>        Get phUserCountFile to hFile
93786>>>>>        Get pdwLockPosition to dwLockPos
93787>>>>>        If (hFile) Begin
93789>>>>>            If (dwLockPos) Begin
93791>>>>>                Get UnlockUserCountFile hFile dwLockPos to iResult
93792>>>>>            End
93792>>>>>>
93792>>>>>            Get CloseUserCountFile hFile to iResult
93793>>>>>        End
93793>>>>>>
93793>>>>>    End_Procedure
93794>>>>>
93794>>>>>    Function CurrentNumberOfUsers Returns Integer
93796>>>>>        Handle  hFile
93796>>>>>        Integer iMaxUsers
93796>>>>>        DWord   dwFilePos
93796>>>>>        Integer iCurUser
93796>>>>>        Integer iResult
93796>>>>>        Integer iNumberOfLocks
93796>>>>>        String  sPath sFile
93796>>>>>
93796>>>>>        Move 0 to iNumberOfLocks
93797>>>>>
93797>>>>>        Get ApplicationPath to sPath
93798>>>>>        Get vFolderFormat sPath to sPath
93799>>>>>        Move (sPath + psLockFileName(Self)) to sFile
93800>>>>>        Get OpenUserCountFile sFile to hFile
93801>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
93803>>>>>            Send UserError CS_UnableToInitUserCountSys
93804>>>>>            Abort
93805>>>>>>
93805>>>>>        End
93805>>>>>>
93805>>>>>
93805>>>>>        If (hFile > 0) Begin
93807>>>>>            Get piMaxUsers To iMaxUsers
93808>>>>>
93808>>>>>            // Set Filepointer to beginning of the file
93808>>>>>            Get ResetUserCountPointer hFile to dwFilePos
93809>>>>>            If (dwFilePos = -1) Begin
93811>>>>>                Send UserError CS_UnableResetUserCountSys
93812>>>>>                Abort
93813>>>>>>
93813>>>>>            End
93813>>>>>>
93813>>>>>            For iCurUser from 1 to iMaxUsers
93819>>>>>>
93819>>>>>                Get LockUserCountFile hFile dwFilePos to iResult
93820>>>>>                If (Not(iResult)) Begin  // byte is locked
93822>>>>>                    Increment iNumberOfLocks
93823>>>>>                End
93823>>>>>>
93823>>>>>                Else Begin  // byte is not locked
93824>>>>>                    Get UnlockUserCountFile hFile dwFilePos to iResult
93825>>>>>                End
93825>>>>>>
93825>>>>>                Get SetUserCountPointer hFile 10 to dwFilePos
93826>>>>>                If (dwFilePos = -1) Begin
93828>>>>>                    Send UserError CS_ErrorAdvancingPointer
93829>>>>>                    Abort
93830>>>>>>
93830>>>>>                End
93830>>>>>>
93830>>>>>            Loop
93831>>>>>>
93831>>>>>        End
93831>>>>>>
93831>>>>>        Get CloseUserCountFile hFile to iResult
93832>>>>>        Function_Return iNumberOfLocks
93833>>>>>    End_Function
93834>>>>>
93834>>>>>End_Class
93835>>>Use cDbUpdateFunctionLibrary.pkg
93835>>>
93835>>>//{ DataBindable=True }
93835>>>    // Note: We import all functionality of the DatabaseFunctionLibrary into the class:
93835>>>Class cDbUpdateHandler is a cObject
93836>>>    Import_Class_Protocol cDbUpdateFunctionLibrary
93837>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
93838>>>
93838>>>    Procedure Construct_Object
93840>>>        tUserCount UserCount
93840>>>        tUserCount UserCount
93840>>>        Integer iUserCount
93840>>>        Handle ho                     
93840>>>
93840>>>        Forward Send Construct_Object
93842>>>        Move Self to ghoDbUpdateHandler  
93843>>>        
93843>>>        // Latin1_General_CI_AS = General Insensitive collation
93843>>>        // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.   
93843>>>        // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
93843>>>        // Good read about which collation to select:
93843>>>        // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
93843>>>        Property String psCollation "Latin1_General_CS_AS" //"SQL_Latin1_General_Cp1_CS_AS"
93844>>>
93844>>>        // Struct array that will contain pnVersionNumbers & object id's of
93844>>>        // all child cDbVersion objects.
93844>>>        Property tDbVersionInfo[] paDbVersionInfoArray
93845>>>
93845>>>        Property Integer Error_Processing_State False  // internal use
93846>>>        
93846>>>        Property Boolean Private.pbDbVersionCheckDone False
93847>>>
93847>>>        Property Boolean pbUseCustomDbVersion False  
93848>>>        
93848>>>        // If this property = True _and_ no DbVersion table exists 
93848>>>        // when the framework is started, a DbVersion table will be created automatically.
93848>>>        Property Boolean pbAutoCreateDbVersionTable True
93849>>>
93849>>>        // Connected to the pbAutoCreateDbVersionTable property. If it is true,
93849>>>        // the Filelist.cfg slot number indicated by this property will be used
93849>>>        // if a DbVersion table is to be created. If this value = -1 at runtime
93849>>>        // an Unhandled Exception Error will be genereted and the program halted. So
93849>>>        // this property _must_ be set in the cDbUpdateHandler object if pbAutoCreateDbVersionTable = True,
93849>>>        // to a value that corresponds to a free Filelist.cfg slot number.
93849>>>        Property Integer Private.piDbVersionFileNumber -1
93850>>>        Property Integer Private.piDbVersionFieldNumber 1
93851>>>
93851>>>        // This is a message of the cDbUpdateFunctionLibrary_Mixin class
93851>>>        // that creates all library properties
93851>>>        Send CreateDbUpdateLibraryProperties
93852>>>
93852>>>        Property tDbUpdateHandlerMasterAlias[] paDbUpdateHandlerMasterAlias
93853>>>
93853>>>        // Error handling:
93853>>>        Property Boolean Private.pbOnCreateExecuted False
93854>>>        Property Boolean Private.pbOnPreUpdateExecuted False
93855>>>        Property Boolean Private.pbProcessingError False
93856>>>        Property Boolean pbDbUpdateErrorHasOccured False
93857>>>        // Don't touch. It is being used by the cDbUpdateVersion
93857>>>        // subclass to tell if that particular update went OK or not.
93857>>>        Property Boolean Private.pbUpdateVersionObjectError False
93858>>>        Property String[] paSQLQueryMessages
93859>>>
93859>>>        Property Integer piOrgErrorHandlerID Error_Object_Id
93860>>>        Move Self to Error_Object_Id
93861>>>        // Error handling:
93861>>>        // Temporarily redirect all errors to this object so we can silently
93861>>>        // log all errors that might appear while updating the database.
93861>>>        // We temporarily redirect all errors to this object so we can
93861>>>        // log and write errors to the log file. It will be reset after
93861>>>        // the database updates have been finished.
93861>>>        Property Integer piCurrentErrorHandlerID Error_Object_Id
93862>>>
93862>>>        Property Handle phoLogFile (Create(Self,RefClass(cDbUpdateLogFile)))
93863>>>
93863>>>        // Error Reporting Related
93863>>>        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
93863>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
93864>>>
93864>>>        // If the pbContinueOnError = False, an update
93864>>>        // of another cDbUpdateVersion object will _not_ be
93864>>>        // performed if an error occured in a previous
93864>>>        // cDbUpdateVersion object.
93864>>>        Property Boolean pbContinueOnError False
93865>>>        // Stops execution in other cDbUpdateVersion objecs,
93865>>>        // if errors occurred in one cDbUpdateVersion object.
93865>>>        Property Boolean pbStopOnFirstError False
93866>>>        // If True errors that occured while updating the database
93866>>>        // will be shown in the default app for .txt files when done.
93866>>>        // Note: The log file will _always_ be created in the Data folder.
93866>>>        Property Boolean pbShowErrorLogPostRun True
93867>>>
93867>>>        // Be _very_ careful to set this property to true!
93867>>>        // If = True, no question will be asked if the update
93867>>>        // should begin. Also, even if the pbShowErrorLogPostRun=True,
93867>>>        // the error log won't be shown. The logfile itself will still be created though.
93867>>>        // You have to know what you're doing!
93867>>>        Property Boolean pbSilentMode False
93868>>>        
93868>>>        Property Boolean pbEnableCancelButton False
93869>>>
93869>>>        // Don't touch! Very private. The value is used by the error log to write for which
93869>>>        // cDbUpdateVersion object an error occured.
93869>>>        Property Number pnCurrentVersionUpdate 0
93870>>>
93870>>>        // The user counting logic is used to safe-guard agains anybody else is
93870>>>        // using the application when a database update is to be performed.
93870>>>        // (Garters & suspenders!)
93870>>>        Property Handle phoUserCountSystem (Create(Self,RefClass(cDbUpdateUserCount)))
93871>>>        Set psLockFileName of (phoUserCountSystem(Self)) to "DbUpdateUserCount.ucf"
93872>>>        Set piMaxUsers     of (phoUserCountSystem(Self)) to (CI_UserCountMaxUsers -1) // Large number!
93873>>>
93873>>>        // This lock file is used to guard against somebody else tries to start the
93873>>>        // application while updates are in progress.
93873>>>        Property Handle phoDatabaseUpdateLock (Create(Self,RefClass(cDbUpdateUserCount)))
93874>>>        Set psLockFileName of (phoDatabaseUpdateLock(Self)) to "DbUpdateLock.ucf"
93875>>>        Set piMaxUsers     of (phoDatabaseUpdateLock(Self)) to 1
93876>>>                                                                                      // Only the current user allowed.
93876>>>        // Properties for the table & column of a system file field/column where
93876>>>        // the database version update number gets saved.
93876>>>        Property Integer Private.Data_File  0
93877>>>        Property Integer Private.Data_Field 0
93878>>>
93878>>>        // Property that is used to indicate that we have already
93878>>>        // started the database update.
93878>>>        Property Boolean Private.pbDatabaseUpdateStarted False
93879>>>
93879>>>        // Don't touch! It is used by the child class cDbUpdateVersion logic to indicate that
93879>>>        // at least one OnUpdate child event has been triggered. Thus at least one active
93879>>>        // change of the database has been made.
93879>>>        Property Boolean Private.pbDatabaseWasUpdated False
93880>>>
93880>>>        // We need to trigger the user counting system so that a bit in the
93880>>>        // user counting file is locked. This is to guard that not more than one user
93880>>>        // is currently runnning the program.
93880>>>        Get CheckUserCount of (phoUserCountSystem(Self)) to UserCount
93881>>>
93881>>>        Get CurrentNumberOfUsers of (phoDatabaseUpdateLock(Self)) to iUserCount
93882>>>        If (iUserCount > 0) Begin
93884>>>            Send Stop_Box CS_DUF_UpdateInProgressTxt
93885>>>            Send Exit_Application
93886>>>        End
93886>>>>
93886>>>
93886>>>        Set pbHandleQueryErrors to False
93887>>>            
93887>>>        // This can't be right?    
93887>>>//        If (ghoDbUpdateFunctionLibrary = 0) Begin
93887>>>//            Move Self to ghoDbUpdateFunctionLibrary
93887>>>//        End
93887>>>
93887>>>        Property Handle phoSQLConnectionHandler 0
93888>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
93888>>>        // we will create one as it is used for all ConnectionID, ConnectionString
93888>>>        // etc information.
93888>>>        If (ghoSQLConnectionHandler = 0) Begin
93890>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
93891>>>            Set phoSQLConnectionHandler to ho
93892>>>        End             
93892>>>>
93892>>>        
93892>>>        Property Boolean pbCheckIntFiles False   
93893>>>        Property Handle  phIntFilesTable 2048
93894>>>        Property Boolean Private.pbIntFilesTablesCheckDone False
93895>>>        
93895>>>        Set Icon to "Default.ico"
93896>>>    End_Procedure
93897>>>
93897>>>    Procedure End_Construct_Object
93899>>>        Boolean bCheckIntFiles
93899>>>        
93899>>>        Forward Send End_Construct_Object
93901>>>        If (Private.pbOnCreateExecuted(Self) = False) Begin  
93903>>>            Send OnCreate
93904>>>            Set Private.pbOnCreateExecuted to True
93905>>>        End
93905>>>>
93905>>>        Send Cleanup
93906>>>    End_Procedure
93907>>>    
93907>>>    // Programmers hook event.
93907>>>    Procedure OnCreate
93909>>>    End_Procedure        
93910>>>                                 
93910>>>    // *** MAIN .Int file (and Filelist.cfg) Check Integrity Message ***
93910>>>    //                                                
93910>>>    // The logic is activated by setting the property "pbCheckIntFiles = True" in the
93910>>>    // cDbUpdateHandler object.
93910>>>    //
93910>>>    // Checks that all .int files are intact, or else writes new copies to disk. 
93910>>>    // Also checks that there is a Filelist.cfg, and if missing writes a new copy to disk.
93910>>>    //
93910>>>    // If not done previously the phIntFilesTable will be created and filled with data
93910>>>    // from the current set of .int files - iif (if-and-only-if) this is a development
93910>>>    // machine. Which is decided by checking if the DdSrc folder exists. And a copy
93910>>>    // of Filelist.cfg is made for backup purposes.
93910>>>    //
93910>>>    // Note: If an error occurrs the application will exit, as it means that at least one
93910>>>    // .int file is in error or the Filelist.cfg was missing and couldn't be recreated.
93910>>>    Procedure CheckIntFilesIntegrity
93912>>>        Boolean bCheckIntFiles bExists bOK bSaved bIsSQL bFileListExist bResult bDevelop bZipExists
93912>>>        String sPaths sDataPath sIntFileName sRootFileNname sFileListName sDDSrcPath sCurrentFolder
93912>>>        String sFileListZipFile sParam sProgram sFile 
93912>>>        Integer iDataPaths iCount
93912>>>        Handle hTable hIntFilesTable                    
93912>>>        UChar[] asFileListArray 
93913>>>        String[] asSavedIntFile
93914>>>        tDUFIntFile[] DUFIntFiles
93914>>>        tDUFIntFile[] DUFIntFiles
93915>>>        
93915>>>        Get pbCheckIntFiles to bCheckIntFiles
93916>>>        If (bCheckIntFiles = False) Begin
93918>>>            Procedure_Return
93919>>>        End
93919>>>>
93919>>>        
93919>>>        Move True to bResult        
93920>>>        
93920>>>        // Note: Include_Resource is a compiler directive!
93920>>>        // It will embedd the Filelist.cfg from the developers machine
93920>>>        // into the executable. Thus the file _must_ be named "Filelist.cfg", or you
93920>>>        // need to change the next code line.         
93920>>>        //
93920>>>        // This is a pickle (!) with the Filelist.cfg as it is "busy" as it is open in the Studio,
93920>>>        // when we get here and then it seems the compiler can't embedd it!        
93920>>>        // ToDo: Change compiler directives in Project properties (?)
93920>>>//        Include_Resource Filelist2.cfg as res_EmbeddedFilelistCfg type DF_RESOURCE_TYPE_BINARY
93920>>>//        Get ReadFileListResource "res_EmbeddedFilelistCfg" to asFileListArray
93920>>>        
93920>>>        Get psFileList of (phoWorkspace(ghoApplication)) to sFileListName
93921>>>        Get vFilePathExists sFileListName to bExists 
93922>>>        If (bExists = True) Begin
93924>>>            Get ParseFolderName sFileListName to sDataPath    
93925>>>            Get vFolderFormat sDataPath to sDataPath                              
93926>>>            Get ParseFileName sFileListName to sFile
93927>>>            // We need to create a backup copy of Filelist.cfg.
93927>>>            Get vCopyFile sFileListName (sDataPath + CS_FilelistBackupFile) to bOK
93928>>>            Get vFilePathExists (sDataPath + CS_FilelistBackupFile) to bOK
93929>>>            If (bOK = False) Begin
93931>>>                Move False to bResult
93932>>>                Error DFERR_PROGRAM ("Could not create a copy of Filelist.cfg for backup purposed! ***Please investigte the reason why this happened ***")
93933>>>>
93933>>>            End
93933>>>>
93933>>>        End
93933>>>>
93933>>>        // If the Filelist.cfg is missing - create it from a previous backup copy.
93933>>>        Else Begin
93934>>>            Get vCopyFile (sDataPath + CS_FilelistBackupFile) sFileListName to bOK
93935>>>//            Get WriteFileListResource asFileListArray sFileListName to bOK  
93935>>>            If (bOK = False) Begin   
93937>>>                Move False to bResult
93938>>>                Error DFERR_PROGRAM ("Filelist.cfg file is missing and couldn't be created!" * String(sFileListName))
93939>>>>
93939>>>            End
93939>>>>
93939>>>        End
93939>>>>
93939>>>        
93939>>>        Get phIntFilesTable to hIntFilesTable
93940>>>        Get_Attribute DF_FILE_ROOT_NAME of hIntFilesTable to sRootFileNname
93943>>>        Get _TableNoPrefix sRootFileNname to sRootFileNname
93944>>>        // This will automatically create the phIntFilesTable if not exists.
93944>>>        // It is used to save data from the current set of .int files.
93944>>>        If (sRootFileNname <> CS_IntFilesTableRootName) Begin
93946>>>            Send AutoCreateIntFilesTable
93947>>>        End                                                       
93947>>>>
93947>>>        
93947>>>        // Check if this is a development machine. *Only* then we will attempt to read .int files to the internal table. 
93947>>>        // ToDo: Or should this always be attempted? Else the 
93947>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
93948>>>        Move (IsDebuggerPresent()) to bDevelop
93949>>>        If (bDevelop = False) Begin
93951>>>            Get vFolderExists sDDSrcPath to bDevelop
93952>>>        End
93952>>>>
93952>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
93953>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths
93954>>>        For iCount from 1 to iDataPaths
93960>>>>
93960>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
93961>>>            Get vFolderFormat sDataPath to sDataPath 
93962>>>            Get vFolderExists sDataPath to bExists
93963>>>            If (bExists = True) Begin                  
93965>>>                Move 0 to hTable
93966>>>                Repeat
93966>>>>
93966>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable    
93969>>>                    If (hTable <> 0) Begin
93971>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
93974>>>                        Get UtilTableIsSqlByRootName sIntFileName to bIsSQL
93975>>>                        If (bIsSQL = True) Begin
93977>>>                            Get _TableNoPrefix sIntFileName to sIntFileName
93978>>>                            Move (sIntFileName + ".int")    to sIntFileName
93979>>>                            Get IsIntFileSaved sIntFileName to bSaved  
93980>>>                            Move True to bOK            
93981>>>                            
93981>>>                            // Save .int file to database if not done previously.
93981>>>                            // We only attempt to read .int files on a development machine.
93981>>>                            If (bDevelop = True) Begin
93983>>>                                If (bSaved = False) Begin
93985>>>                                    Get SaveIntFileData sDataPath sIntFileName to bOK
93986>>>                                    If (bOK = False) Begin
93988>>>                                        Move False to bResult    
93989>>>                                    End
93989>>>>
93989>>>                                End         
93989>>>>
93989>>>                                If (bOK = True) Begin
93991>>>                                    Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
93992>>>                                    If (SizeOfArray(asSavedIntFile)) Begin
93994>>>                                        Get UpdateIntFileData sDataPath sIntFileName asSavedIntFile to bOK
93995>>>                                        If (bOK = False) Begin
93997>>>                                            Move False to bResult
93998>>>                                            Error DFERR_PROGRAM ("Could not update .int file data to the internal database table:" * String(sIntFileName))
93999>>>>
93999>>>                                        End
93999>>>>
93999>>>                                    End
93999>>>>
93999>>>                                End
93999>>>>
93999>>>                            End
93999>>>>
93999>>>                            
93999>>>                            Get vFilePathExists (sDataPath + sIntFileName) to bExists
94000>>>                            If (bExists = False) Begin                           
94002>>>                                // If the .int file is missing on disk; create it from database.
94002>>>                                Get CreateIntFileFromSavedData hIntFilesTable sIntFileName sDataPath to bOK
94003>>>                                If (bOK = False) Begin         
94005>>>                                    Move False to bResult
94006>>>                                    Error DFERR_PROGRAM ("Could not create .int file:" * String(sIntFileName))
94007>>>>
94007>>>                                End
94007>>>>
94007>>>                            End
94007>>>>
94007>>>                        End
94007>>>>
94007>>>                    End
94007>>>>
94007>>>                Until (hTable = 0)
94009>>>            End
94009>>>>
94009>>>        Loop       
94010>>>>
94010>>>        
94010>>>        // If an error occured we need to exit the application.
94010>>>        If (bResult = False) Begin  
94012>>>            Send Info_Box CS_DUF_DbUpdatedErrorText 
94013>>>            Send Exit_Application
94014>>>        End
94014>>>>
94014>>>        
94014>>>    End_Procedure               
94015>>>
94015>>>    // To update currently saved IntFile data to the database.
94015>>>    // Because it is much easier, we first delete all current records and
94015>>>    // then saves the changed .int file to the database.
94015>>>    Function UpdateIntFileData String sDataPath String sIntFileName String[] asSavedIntFile Returns Boolean
94017>>>        Boolean bOK
94017>>>        
94017>>>        Move False to bOK
94018>>>
94018>>>        Get DeleteIntFileData sDataPath sIntFileName to bOK
94019>>>        If (bOK = True) Begin
94021>>>            Get SaveIntFileData sDataPath sIntFileName to bOK
94022>>>        End
94022>>>>
94022>>>        
94022>>>        Function_Return bOK
94023>>>    End_Function
94024>>>    
94024>>>    Function IsIntFileSaved String sIntFileName Returns Boolean
94026>>>        Handle hTable
94026>>>        Boolean bOK
94026>>>        Integer iColumn iIndex   
94026>>>        String sFileName
94026>>>        
94026>>>        Move False to bOK
94027>>>        Get phIntFilesTable to hTable
94028>>>        Move 2              to iColumn // This is the "InfFileName" field no.
94029>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
94030>>>
94030>>>        Open hTable
94032>>>        Set_Field_Value hTable iColumn to sIntFileName
94035>>>        Vfind hTable iIndex GE
94037>>>        Get_Field_Value hTable iColumn to sFileName
94040>>>        If (Trim(sIntFileName) = Trim(sFileName)) Begin
94042>>>            Move True to bOK    
94043>>>        End
94043>>>>
94043>>>        Close hTable
94044>>>        
94044>>>        Function_Return bOK       
94045>>>    End_Function   
94046>>>    
94046>>>    // Checks that the passed .int file is the same as what is saved in the database.
94046>>>    // If not same, the return string array will contain the read .int file,
94046>>>    // else the returned array will be empty.
94046>>>    Function HasIntFileChanged String sDataPath String sIntFileName Returns String[]
94048>>>        String[] asIntFileOrg asIntFile asSavedIntFile asReturnIntFile
94052>>>        Boolean bIsSame
94052>>>        
94052>>>        Get ReadIntFileData    sDataPath sIntFileName to asIntFileOrg   
94053>>>        Get CurrentIntFileData sDataPath sIntFileName to asSavedIntFile
94054>>>        Get RemoveBlankLines asIntFileOrg   to asIntFile
94055>>>        Get RemoveBlankLines asSavedIntFile to asSavedIntFile
94056>>>        
94056>>>        Move (IsSameArray(asIntFile, asSavedIntFile)) to bIsSame
94057>>>        If (bIsSame = False) Begin
94059>>>            Move asIntFileOrg to asReturnIntFile    
94060>>>        End
94060>>>>
94060>>>        
94060>>>        Function_Return asReturnIntFile    
94061>>>    End_Function                                   
94062>>>    
94062>>>    // Takes a string array as parameter and returns a new
94062>>>    // string array without any empty rows and all rows trimmed.
94062>>>    // This is e.g. used by the HasIntFileChanged message to compare
94062>>>    // two .int file arrays. 
94062>>>    Function RemoveBlankLines String[] asIntFile Returns String[]
94064>>>        Integer iSize iCount iRow
94064>>>        String sVal        
94064>>>        String[] asRetValArray
94065>>>        
94065>>>        Move (SizeOfArray(asIntFile)) to iSize
94066>>>        If (iSize = 0) Begin
94068>>>            Function_Return asRetValArray
94069>>>        End                          
94069>>>>
94069>>>        Decrement iSize         
94070>>>        Move 0 to iRow
94071>>>        
94071>>>        For iCount from 0  to iSize
94077>>>>
94077>>>            Move asIntFile[iCount] to sVal
94078>>>            Move (Trim(sVal)) to sVal
94079>>>            If (sVal <> "") Begin
94081>>>                Move sVal to asRetValArray[iRow]
94082>>>                Increment iRow        
94083>>>            End
94083>>>>
94083>>>        Loop
94084>>>>
94084>>>        
94084>>>        Function_Return asRetValArray
94085>>>    End_Function
94086>>>    
94086>>>    Function SaveIntFileData String sPath String sIntFileName Returns Boolean
94088>>>        Handle hTable
94088>>>        Boolean bOK bErr
94088>>>        Integer iIDCol iFileCol iTextCol iIndex iIDIdx iSize iCount 
94088>>>        Number iID
94088>>>        String sFileName
94088>>>        String[] asIntFile
94089>>>        
94089>>>        Move Err to bErr
94090>>>        Move False to Err
94091>>>        Move False to bOK
94092>>>        Get phIntFilesTable to hTable  
94093>>>        Move 1              to iIDCol
94094>>>        Move 2              to iFileCol
94095>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
94096>>>        Move 1              to iIDIdx   // Main ID index.
94097>>>        Move 2              to iIndex   // This is the IntFileName + ID index.
94098>>>
94098>>>        Get ReadIntFileData sPath sIntFileName to asIntFile
94099>>>        Move (SizeOfArray(asIntFile)) to iSize
94100>>>        If (iSize = 0) Begin
94102>>>            Function_Return False
94103>>>        End
94103>>>>
94103>>>        Decrement iSize
94104>>>        Open hTable  
94106>>>                  
94106>>>        // Find the last used ID no:
94106>>>        Fill_Field hTable iIDCol with DF_HIGH
94108>>>        Vfind hTable iIDIdx LE
94110>>>        Get_Field_Value hTable iIDCol to iID 
94113>>>        // This only happens the very first time we save a record.
94113>>>        If (iID = 999999999999) Begin
94115>>>            Move 0 to iID
94116>>>        End
94116>>>>
94116>>>        Increment iID        
94117>>>        
94117>>>        Lock
94118>>>>
94118>>>            For iCount from 0 to iSize
94124>>>>
94124>>>                Clear hTable
94125>>>                Set_Field_Value hTable iIDCol   to iID     
94128>>>                Set_Field_Value hTable iFileCol to sIntFileName
94131>>>                Set_Field_Value hTable iTextCol to asIntFile[iCount]
94134>>>                SaveRecord hTable
94135>>>                Increment iID
94136>>>            Loop
94137>>>>
94137>>>        Unlock
94138>>>>
94138>>>        Close hTable
94139>>>        
94139>>>        Move (not(Err)) to bOK
94140>>>        Move bErr to Err
94141>>>        
94141>>>        Function_Return bOK
94142>>>    End_Function
94143>>>    
94143>>>    // Deletes all records for the passed sIntFileName value,
94143>>>    // from the phIntFilesTable.
94143>>>    // Returns True if no errors occured.
94143>>>    Function DeleteIntFileData String sPath String sIntFileName Returns Boolean
94145>>>        Handle hTable
94145>>>        Boolean bOK bErr bFound
94145>>>        Integer iFileCol iIndex
94145>>>        String sVal
94145>>>        String[] asIntFile
94146>>>        
94146>>>        Move Err to bErr
94147>>>        Move False to Err
94148>>>        Move False to bOK
94149>>>        Move 2              to iFileCol
94150>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
94151>>>        Get phIntFilesTable to hTable  
94152>>>        Open hTable  
94154>>>                  
94154>>>        // Find the first record
94154>>>        Set_Field_Value hTable iFileCol to sIntFileName
94157>>>        Vfind hTable iIndex GE
94159>>>        Get_Field_Value hTable iFileCol to sVal
94162>>>        Move (Found and Trim(sVal) = Trim(sIntFileName)) to bFound
94163>>>        While (bFound = True)
94167>>>            Delete hTable
94168>>>            Vfind hTable iIndex GT
94170>>>            Get_Field_Value hTable iFileCol to sVal
94173>>>            Move (Found and Trim(sVal) = Trim(sIntFileName)) to bFound
94174>>>        Loop
94175>>>>
94175>>>        Unlock
94176>>>>
94176>>>        Close hTable
94177>>>        
94177>>>        Move (not(Err)) to bOK
94178>>>        Move bErr to Err
94179>>>        
94179>>>        Function_Return bOK
94180>>>    End_Function
94181>>>
94181>>>    // Returns all saved phIntFilesTable records for the passed 
94181>>>    // sIntFileName value as a string array.
94181>>>    Function CurrentIntFileData String sPath String sIntFileName Returns String[]
94183>>>        Handle hTable
94183>>>        Boolean bOK bErr bFound
94183>>>        Integer iFileCol iTextCol iIndex
94183>>>        String sVal sFileName
94183>>>        String[] asIntFile asEmptyArray
94185>>>        
94185>>>        Move Err to bErr
94186>>>        Move False to Err
94187>>>        Move False to bOK
94188>>>        Move 2              to iFileCol
94189>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
94190>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
94191>>>        Get phIntFilesTable to hTable  
94192>>>        Open hTable  
94194>>>
94194>>>        // Find the first record
94194>>>        Set_Field_Value hTable iFileCol to sIntFileName
94197>>>        Vfind hTable iIndex GE
94199>>>        Get_Field_Value hTable iFileCol to sFileName
94202>>>        Move (Found and Trim(sFileName) = Trim(sIntFileName)) to bFound
94203>>>        While (bFound = True)
94207>>>            Get_Field_Value hTable iFileCol to sFileName
94210>>>            Move (Found and Trim(sFileName) = Trim(sIntFileName)) to bFound
94211>>>            If (bFound = True) Begin
94213>>>                Get_Field_Value hTable iTextCol to sVal
94216>>>                Move (Trim(sVal)) to asIntFile[SizeOfArray(asIntFile)]
94217>>>            End
94217>>>>
94217>>>            Vfind hTable iIndex GT
94219>>>        Loop
94220>>>>
94220>>>        
94220>>>        Close hTable
94221>>>        Move (not(Err)) to bOK
94222>>>        If (bOK = False) Begin
94224>>>            Move asEmptyArray to asIntFile
94225>>>        End
94225>>>>
94225>>>        Move bErr to Err               
94226>>>        
94226>>>        Function_Return asIntFile
94227>>>    End_Function
94228>>>
94228>>>    // Reads the passed sIntFileName from disk and returns its value
94228>>>    // as a string array.
94228>>>    Function ReadIntFileData String sPath String sIntFileName Returns String[]
94230>>>        String[] asIntFile       
94231>>>        String sFileName sLine
94231>>>        Integer iCh iSize iCount
94231>>>        
94231>>>        Get vFolderFormat sPath to sPath
94232>>>        If (not(sIntFileName contains ".")) Begin
94234>>>            Move (sIntFileName + ".int") to sIntFileName
94235>>>        End
94235>>>>
94235>>>        Move (sPath + sIntFileName) to sFileName
94236>>>        Get Seq_Open_input_Channel sFileName to iCh
94237>>>        If (iCh < 0) Begin
94239>>>            Function_Return asIntFile
94240>>>        End                                 
94240>>>>
94240>>>        
94240>>>        Repeat
94240>>>>
94240>>>            Readln channel iCh sLine
94242>>>            If (SeqEof = False) Begin
94244>>>                Move sLine to asIntFile[SizeOfArray(asIntFile)]
94245>>>            End
94245>>>>
94245>>>        Until (SeqEof = True)
94247>>>        Send Seq_Close_Channel iCh    
94248>>>        
94248>>>        Function_Return asIntFile
94249>>>    End_Function
94250>>>    
94250>>>    // Reads the Filelist.cfg from memeory as a resource.
94250>>>    // The Filelist.cfg has been compiled into the program.
94250>>>    Function ReadFileListResource String sMemFileName Returns UChar[]
94252>>>        Integer iCh iCount
94252>>>        Number nByteCount
94252>>>        String[] asFileListArray sEmptyArray
94254>>>        String sLine
94254>>>        UChar[] uCharData
94255>>>        
94255>>>        Move False to Err
94256>>>        Get Seq_New_Channel to iCh
94257>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
94259>>>            Error DFERR_PROGRAM 'No channel available...'
94260>>>>
94260>>>            Function_Return sEmptyArray
94261>>>        End
94261>>>>
94261>>>
94261>>>        // First decide the size of the script
94261>>>        Direct_Input channel iCh ("Resource: " + sMemFileName)
94263>>>        Read_Block channel iCh uCharData -1 // -1 means that all data should be read.
94265>>>        Close_Input channel iCh
94267>>>        Send Seq_Release_Channel iCh
94268>>>
94268>>>        Function_Return uCharData
94269>>>    End_Function    
94270>>>    
94270>>>    // Writes a copy of the workspace Filelist.cfg to disk.
94270>>>    // It does so by reading from a memory resource, as the file has
94270>>>    // been compiled into the program.
94270>>>    Function WriteFileListResource UChar[] asFileListArray String sFileListName Returns Boolean
94272>>>        Boolean bOK bErr
94272>>>        Integer iSize iCh
94272>>>        
94272>>>        Move Err to bErr
94273>>>        Move False to Err
94274>>>        Move False to bOK
94275>>>        Move (SizeOfArray(asFileListArray)) to iSize
94276>>>        If (iSize = 0) Begin
94278>>>            Function_Return False
94279>>>        End
94279>>>>
94279>>>
94279>>>        Get Seq_New_Channel to iCh
94280>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
94282>>>            Error DFERR_PROGRAM 'No channel available...'
94283>>>>
94283>>>            Function_Return False
94284>>>        End                      
94284>>>>
94284>>>        
94284>>>        Direct_Output channel iCh sFileListName
94286>>>        Writeln channel iCh asFileListArray
94289>>>                
94289>>>        Close_Input channel iCh
94291>>>        Send Seq_Release_Channel iCh
94292>>>        Move (not(Err)) to bOK
94293>>>        Move bErr to Err
94294>>>        
94294>>>        Function_Return bOK
94295>>>    End_Function
94296>>>
94296>>>    // Writes an .int for the passed sIntFileName file to disk by reading data from the phIntFilesTable data table.
94296>>>    // It first deletes the .cch file (if any).
94296>>>    Function CreateIntFileFromSavedData Handle hTable String sIntFileName String sDataPath Returns Boolean
94298>>>        Boolean bOK bFound bExists bErr
94298>>>        Integer iCh iSize iCount
94298>>>        String sFileName sCCHFileName sVal
94298>>>        String[] asIntFile
94299>>>        
94299>>>        Move Err to bErr   
94300>>>        Move False to Err
94301>>>        Move False to bOK
94302>>>
94302>>>        Get CurrentIntFileData sDataPath sIntFileName to asIntFile
94303>>>        Move (SizeOfArray(asIntFile)) to iSize
94304>>>        If (iSize = 0) Begin
94306>>>            Function_Return False        
94307>>>        End                      
94307>>>>
94307>>>        Decrement iSize
94308>>>        
94308>>>        Get Seq_New_Channel to iCh
94309>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
94311>>>            Function_Return False
94312>>>        End   
94312>>>>
94312>>>        
94312>>>        // Before we start to actually create the new .int file, make sure we delete
94312>>>        // the .cch file first.                                     
94312>>>        Move (Uppercase(sIntFileName)) to sCCHFileName
94313>>>        Move (Replace(".INT", sCCHFileName, ".CCH")) to sCCHFileName
94314>>>        Get vFilePathExists (sDataPath + sCCHFileName) to bExists
94315>>>        If (bExists = True) Begin
94317>>>            Get vDeleteFile (sDataPath + sCCHFileName) to bOK
94318>>>            If (bOK = False) Begin
94320>>>                Function_Return False
94321>>>            End
94321>>>>
94321>>>        End
94321>>>>
94321>>>        
94321>>>        Direct_Output channel iCh (sDataPath + sIntFileName)
94323>>>        For iCount from 0 to iSize
94329>>>>
94329>>>            Writeln channel iCh asIntFile[iCount]
94332>>>        Loop
94333>>>>
94333>>>        
94333>>>        Close_Input channel iCh
94335>>>        Send Seq_Release_Channel iCh
94336>>>        Move (not(Err)) to bOK
94337>>>        Move bErr to Err
94338>>>        
94338>>>        Function_Return bOK
94339>>>    End_Function   
94340>>>              
94340>>>    // Automatically writes .int files to disk that is missing.
94340>>>    // We only need to make this test this once, but because the message is called
94340>>>    // from each child cDbUpdateVersion object (and it needs to be called from there),
94340>>>    // we use property Private.pbIntFilesTablesCheckDone to ensure it is only run once.
94340>>>    Procedure AutoCreateIntFilesTable 
94342>>>        Integer hTable 
94342>>>        Boolean bIntFilesTablesCheckDone bTableExists
94342>>>        String sInfoTxt 
94342>>>        
94342>>>        Get phIntFilesTable to hTable  
94343>>>        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
94344>>>        If (bIntFilesTablesCheckDone = True) Begin
94346>>>            Procedure_Return
94347>>>        End
94347>>>>
94347>>>
94347>>>        If (hTable < 1) Begin
94349>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94350>>>            Error DFERR_PROGRAM "The phIntFilesTable has been set to 0 (!). The default value is 2048 and if changed MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object.\nProgram will now exit!"
94351>>>>
94351>>>            Procedure_Return
94352>>>        End
94352>>>>
94352>>>
94352>>>        Get UtilTableExists of ghoDbUpdateFunctionLibrary hTable to bTableExists
94353>>>        If (bTableExists = True) Begin
94355>>>            Set Private.pbIntFilesTablesCheckDone to True
94356>>>            Procedure_Return
94357>>>        End
94357>>>>
94357>>>
94357>>>        Send CreateIntFilesTable hTable
94358>>>
94358>>>        Set Private.pbIntFilesTablesCheckDone to True
94359>>>    End_Function
94360>>>                
94360>>>    Procedure CreateIntFilesTable Handle hTable
94362>>>        String sTableName sColumnName sInfoTxt sDriverID sDataPath
94362>>>        Boolean bTableExists bOK bUseConnectionID bExists
94362>>>        tAPIColumn[] APIColumn
94362>>>        tAPIColumn[] APIColumn
94363>>>
94363>>>        Get UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
94364>>>        If (bTableExists = True) Begin
94366>>>            Procedure_Return
94367>>>        End
94367>>>>
94367>>>
94367>>>        Move False to Err
94368>>>        Get psDriverID to sDriverID
94369>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
94370>>>
94370>>>        Move CS_IntFilesTableRootName to sTableName
94371>>>
94371>>>        Move 1                  to APIColumn[0].iFieldNumber
94372>>>        Move "ID"               to APIColumn[0].sFieldName
94373>>>        Move DF_BCD             to APIColumn[0].iType
94374>>>        Move False              to APIColumn[0].bIsSQLType
94375>>>        Move 12                 to APIColumn[0].iLength
94376>>>        Move 0                  to APIColumn[0].iPrecision
94377>>>
94377>>>        Move 2                  to APIColumn[1].iFieldNumber
94378>>>        Move "IntFileName"      to APIColumn[1].sFieldName
94379>>>        Move DF_ASCII           to APIColumn[1].iType
94380>>>        Move False              to APIColumn[1].bIsSQLType
94381>>>        Move 50                 to APIColumn[1].iLength
94382>>>        Move 0                  to APIColumn[1].iPrecision
94383>>>
94383>>>        Move 3                  to APIColumn[2].iFieldNumber
94384>>>        Move "IntLineText"      to APIColumn[2].sFieldName
94385>>>        Move DF_ASCII           to APIColumn[2].iType
94386>>>        Move False              to APIColumn[2].bIsSQLType
94387>>>        Move 100                to APIColumn[2].iLength
94388>>>        Move 0                  to APIColumn[2].iPrecision
94389>>>
94389>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
94390>>>        
94390>>>        If (bOK = True and Err = False) Begin
94392>>>            Move ("Int Files Table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
94393>>>        End
94393>>>>
94393>>>        Else Begin
94394>>>            Move ("ERROR" * "Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
94395>>>            Error sInfoTxt
94396>>>>
94396>>>            Procedure_Return
94397>>>        End
94397>>>>
94397>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
94398>>>
94398>>>        Get ApiIndexCreate hTable 1 1 1   to bOK     // Index 1 = ID
94399>>>        If (bOK = True) Begin
94401>>>            Get ApiIndexCreate hTable 2 2 2 1 to bOK // Index 2 = InteFileName, ID.
94402>>>        End
94402>>>>
94402>>>        If (bOK = False) Begin
94404>>>            Move ("ERROR" * "Indexes for Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
94405>>>            Error sInfoTxt
94406>>>>
94406>>>            Procedure_Return
94407>>>        End                    
94407>>>>
94407>>>        
94407>>>        // Check if the new .int file was created. If so and a .dat file exists - delete it.
94407>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
94408>>>        Get vFolderFormat sDataPath to sDataPath
94409>>>        Move (CS_IntFilesTableRootName + ".int") to sTableName
94410>>>        Get vFilePathExists (sDataPath + sTableName) to bExists
94411>>>        If (bExists = True) Begin
94413>>>            Move CS_IntFilesTableRootName to sTableName
94414>>>            Get vFilePathExists (sDataPath + sTableName + ".dat") to bExists
94415>>>            If (bExists = True) Begin
94417>>>                Get vDeleteFile (sDataPath + sTableName + ".dat") to bOK
94418>>>                Get vDeleteFile (sDataPath + sTableName + ".hdr") to bOK
94419>>>                Get vDeleteFile (sDataPath + sTableName + ".k??") to bOK
94420>>>            End
94420>>>>
94420>>>        End
94420>>>>
94420>>>        
94420>>>    End_Procedure
94421>>>
94421>>>    Procedure CheckAutoCreateDbVersionTable
94423>>>        Boolean bDbVersionCheckDone bUseCustomDbVersion bAutoCreateDbVersionTable bTableExists
94423>>>        Integer iDbVersionFileNumber
94423>>>
94423>>>        Get Private.pbDbVersionCheckDone to bDbVersionCheckDone
94424>>>        If (bDbVersionCheckDone = True) Begin
94426>>>            Procedure_Return
94427>>>        End
94427>>>>
94427>>>        Get pbUseCustomDbVersion to bUseCustomDbVersion
94428>>>        If (bUseCustomDbVersion = True) Begin
94430>>>            Procedure_Return
94431>>>        End
94431>>>>
94431>>>
94431>>>        Get pbAutoCreateDbVersionTable to bAutoCreateDbVersionTable
94432>>>        If (bAutoCreateDbVersionTable = True and iDbVersionFileNumber = -1) Begin
94434>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94435>>>            Error DFERR_PROGRAM "The iDbVersionFileSlotNumber = -1. It MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object. Could not auto-create the DbVersion table.\nProgram will now exit!"
94436>>>>
94436>>>            Send Exit_Application
94437>>>        End
94437>>>>
94437>>>
94437>>>        Get piDbVersionFileNumber to iDbVersionFileNumber
94438>>>        Get UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
94439>>>        If (bTableExists = True) Begin
94441>>>            Set Private.pbDbVersionCheckDone to True
94442>>>            Procedure_Return
94443>>>        End
94443>>>>
94443>>>
94443>>>        Send CreateDbVersionTable iDbVersionFileNumber
94444>>>
94444>>>        // We only need to these DbVersion checks once, but because this message is called
94444>>>        // from each child cDbUpdateVersion object (and it needs to be called from there),
94444>>>        // we use a property to only run these tests once.
94444>>>        Set Private.pbDbVersionCheckDone to True
94445>>>    End_Procedure
94446>>>
94446>>>    Procedure CreateDbVersionTable Handle hTable
94448>>>        String sTableName sColumnName sInfoTxt sDriverID 
94448>>>        Boolean bTableExists bOK bUseConnectionID
94448>>>        tAPIColumn[] APIColumn
94448>>>        tAPIColumn[] APIColumn
94449>>>
94449>>>        Get UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
94450>>>        If (bTableExists = True) Begin
94452>>>            Procedure_Return
94453>>>        End
94453>>>>
94453>>>
94453>>>        Get psDriverID to sDriverID
94454>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
94455>>>
94455>>>        Move "DbVersion"        to sTableName
94456>>>        Move 1                  to APIColumn[0].iFieldNumber
94457>>>        Move "DatabaseVersion"  to APIColumn[0].sFieldName
94458>>>        Move DF_BCD             to APIColumn[0].iType
94459>>>        Move False              to APIColumn[0].bIsSQLType
94460>>>        Move 4                  to APIColumn[0].iLength
94461>>>        Move 2                  to APIColumn[0].iPrecision
94462>>>
94462>>>        Move False to Err                                
94463>>>        
94463>>>        // Note: We always create an embedded DbVersion table. To do this we temporarily need to set the psDriverID to "DATAFLEX".
94463>>>        // To convert the DbVersion table to SQL, use the 'ApiTableConvertToSQL' function.
94463>>>        Set psDriverID to DATAFLEX_ID
94464>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
94465>>>        Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
94466>>>        Set psDriverID to sDriverID
94467>>>        
94467>>>        If (bOK = True and Err = False) Begin
94469>>>//            Move ("Column '" + APIColumn[0].sFieldName + "'" * "NUMERIC" * String(APIColumn[0].iLength) + ", was successfully added to '" + sTableName + "'" * "(at filelist slot:" * String(hTable) + ")") to sInfoTxt
94469>>>            Move ("DbVersion table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
94470>>>        End
94470>>>>
94470>>>        Else Begin
94471>>>            Move ("The column could NOT be added. Either column" * sColumnName * "already exists or the Table name is incorrect?") to sInfoTxt
94472>>>        End
94472>>>>
94472>>>
94472>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
94473>>>    End_Procedure
94474>>>
94474>>>    Procedure Set pbVerboseState Boolean bVerboseState
94476>>>        Handle ho
94476>>>        Get phoLogFile to ho
94477>>>        Set pbVerboseState of ho to bVerboseState
94478>>>    End_Procedure
94479>>>
94479>>>    Function pbVerboseState Returns Boolean
94481>>>        Boolean bVerboseState
94481>>>        Handle ho
94481>>>        Get phoLogFile to ho
94482>>>        Get pbVerboseState of ho to bVerboseState
94483>>>        Function_Return bVerboseState
94484>>>    End_Function
94485>>>
94485>>>    // Callback functionality used when e.g. calling driver functions directly.
94485>>>    // Note that this overrules the callback function of the cDbUpdateFunctionLibrary class.
94485>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
94487>>>        Integer iPerc
94487>>>        Number nReady nTotal nVersion
94487>>>        Boolean bVerboseState
94487>>>        Handle hoLogFile
94487>>>
94487>>>        Get pbVerboseState to bVerboseState
94488>>>        Get pnCurrentVersionUpdate to nVersion
94489>>>        Get phoLogFile     to hoLogFile
94490>>>        Send DoAdvance of ghoProgressBar
94491>>>
94491>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
94493>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
94494>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
94495>>>        End
94495>>>>
94495>>>        If (sCallback_Text contains "Creating index") Begin
94497>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
94498>>>        End
94498>>>>
94498>>>
94498>>>        Case Begin
94498>>>            Case (iCallback_Type = DF_Message_Text)
94500>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94501>>>                Set Action_Text  of ghoStatusPanel to ""
94502>>>                If (bVerboseState = True) Begin
94504>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94505>>>                End
94505>>>>
94505>>>                Case Break
94506>>>            Case (iCallback_Type = DF_Message_Heading_1)
94509>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94510>>>                If (bVerboseState = True) Begin
94512>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94513>>>                End
94513>>>>
94513>>>                Case Break
94514>>>            Case (iCallback_Type = DF_Message_Heading_2)
94517>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94518>>>                Set Action_Text  of ghoStatusPanel to ""
94519>>>                If (bVerboseState = True) Begin
94521>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94522>>>                End
94522>>>>
94522>>>                Case Break
94523>>>            Case (iCallback_Type = DF_Message_Heading_3)
94526>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94527>>>                Set Action_Text  of ghoStatusPanel to ""
94528>>>                If (bVerboseState = True) Begin
94530>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94531>>>                End
94531>>>>
94531>>>                Case Break
94532>>>            Case (iCallback_Type = DF_Message_Heading_4)
94535>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94536>>>                Set Action_Text  of ghoStatusPanel to ""
94537>>>                If (bVerboseState = True) Begin
94539>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94540>>>                End
94540>>>>
94540>>>                Case Break
94541>>>            Case (iCallback_Type = DF_Message_Heading_5)
94544>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94545>>>                Set Action_Text  of ghoStatusPanel to ""
94546>>>                If (bVerboseState = True) Begin
94548>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94549>>>                End
94549>>>>
94549>>>                Case Break
94550>>>            Case (iCallback_Type = DF_Message_Warning)
94553>>>                If (bVerboseState = True) Begin
94555>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94556>>>                End
94556>>>>
94556>>>                Case Break
94557>>>            Case (iCallback_Type = DF_Message_Progress_Title)
94560>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94561>>>                Set Action_Text  of ghoStatusPanel to ""
94562>>>                If (bVerboseState = True) Begin
94564>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94565>>>                End
94565>>>>
94565>>>                Case Break
94566>>>            Case (iCallback_Type = DF_Message_Progress_Value)
94569>>>                //*** Interpret numbers
94569>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
94570>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
94571>>>                Move ((nReady/nTotal) * 100)                                                      to iPerc
94572>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% (Total:") * String(nTotal) + ")")
94573>>>                Set piPosition of ghoProgressBar to iPerc
94574>>>                Case Break
94575>>>            Case Else
94575>>>                Set Message_Text to ""
94576>>>                Set Action_Text  to ""
94577>>>        Case End
94577>>>
94577>>>        Send ProcessEvents of ghoStatusPanel
94578>>>        Function_Return False
94579>>>    End_Function
94580>>>
94580>>>    // This was made to be a procedure/function pair so we
94580>>>    // at the same time can set the property of the cDbUpdateFunctionLibrary
94580>>>
94580>>>    Procedure Set piDbType Integer iDbType
94582>>>        If (ghoSQLConnectionHandler = 0) Begin
94584>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94585>>>>
94585>>>            Procedure_Return
94586>>>        End
94586>>>>
94586>>>        Set piDbType of ghoSQLConnectionHandler to iDbType
94587>>>    End_Procedure
94588>>>
94588>>>    Function piDbType Returns Integer
94590>>>        Integer iDbType
94590>>>        If (ghoSQLConnectionHandler = 0) Begin
94592>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94593>>>>
94593>>>            Function_Return ""
94594>>>        End
94594>>>>
94594>>>        Get piDbType of ghoSQLConnectionHandler to iDbType
94595>>>        Function_Return iDbType
94596>>>    End_Function
94597>>>
94597>>>    Procedure Set psDriverID String sDriverID
94599>>>        If (ghoSQLConnectionHandler = 0) Begin
94601>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94602>>>>
94602>>>            Procedure_Return
94603>>>        End
94603>>>>
94603>>>        Set psDriverID of ghoSQLConnectionHandler to sDriverID
94604>>>    End_Procedure
94605>>>
94605>>>    Function psDriverID Returns String
94607>>>        String sValue
94607>>>        If (ghoSQLConnectionHandler = 0) Begin
94609>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94610>>>>
94610>>>            Function_Return ""
94611>>>        End
94611>>>>
94611>>>        Get psDriverID of ghoSQLConnectionHandler to sValue
94612>>>        Function_Return sValue
94613>>>    End_Function
94614>>>
94614>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
94616>>>        If (ghoSQLConnectionHandler = 0) Begin
94618>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94619>>>>
94619>>>            Procedure_Return
94620>>>        End
94620>>>>
94620>>>        Send CreateSQLConnection of ghoSQLConnectionHandler sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
94621>>>    End_Procedure
94622>>>
94622>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
94624>>>        Integer iRetval
94624>>>        If (ghoSQLConnectionHandler = 0) Begin
94626>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94627>>>>
94627>>>            Function_Return 2
94628>>>        End
94628>>>>
94628>>>
94628>>>        Get RedirectConnection of ghoSQLConnectionHandler to iRetval
94629>>>        Function_Return iRetval
94630>>>    End_Function
94631>>>
94631>>>    Procedure Set psConnectionID String sValue
94633>>>        If (ghoSQLConnectionHandler = 0) Begin
94635>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94636>>>>
94636>>>            Procedure_Return
94637>>>        End
94637>>>>
94637>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
94638>>>    End_Procedure
94639>>>
94639>>>    Function psConnectionID Returns String
94641>>>        String sValue
94641>>>        If (ghoSQLConnectionHandler = 0) Begin
94643>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94644>>>>
94644>>>            Function_Return ""
94645>>>        End
94645>>>>
94645>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
94646>>>
94646>>>        Function_Return sValue
94647>>>    End_Function
94648>>>
94648>>>    // These "properties" are settings of the cCLIHandler class, but are being
94648>>>    // relayed to the ghoSQLConnectionHandler object
94648>>>    // simply by changing one of its parameters.
94648>>>    Procedure Set psServer String sValue
94650>>>        If (ghoSQLConnectionHandler = 0) Begin
94652>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94653>>>>
94653>>>            Procedure_Return
94654>>>        End
94654>>>>
94654>>>        Set psServer of ghoSQLConnectionHandler to sValue
94655>>>    End_Procedure
94656>>>
94656>>>    Function psServer Returns String
94658>>>        String sValue
94658>>>        If (ghoSQLConnectionHandler = 0) Begin
94660>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94661>>>>
94661>>>            Function_Return ""
94662>>>        End
94662>>>>
94662>>>        Get psServer of ghoSQLConnectionHandler to sValue
94663>>>
94663>>>        Function_Return sValue
94664>>>    End_Function
94665>>>
94665>>>    Procedure Set psDatabase String sValue
94667>>>        If (ghoSQLConnectionHandler = 0) Begin
94669>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94670>>>>
94670>>>            Procedure_Return
94671>>>        End
94671>>>>
94671>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
94672>>>    End_Procedure
94673>>>
94673>>>    Function psDatabase Returns String
94675>>>        String sValue
94675>>>        If (ghoSQLConnectionHandler = 0) Begin
94677>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94678>>>>
94678>>>            Function_Return ""
94679>>>        End
94679>>>>
94679>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
94680>>>
94680>>>        Function_Return sValue
94681>>>    End_Function
94682>>>
94682>>>    Procedure Set psUserID String sValue
94684>>>        If (ghoSQLConnectionHandler = 0) Begin
94686>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94687>>>>
94687>>>            Procedure_Return
94688>>>        End
94688>>>>
94688>>>        Set psUserID of ghoSQLConnectionHandler to sValue
94689>>>    End_Procedure
94690>>>
94690>>>    Function psUserID Returns String
94692>>>        String sValue
94692>>>        If (ghoSQLConnectionHandler = 0) Begin
94694>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94695>>>>
94695>>>            Function_Return ""
94696>>>        End
94696>>>>
94696>>>        Get psUserID of ghoSQLConnectionHandler to sValue
94697>>>
94697>>>        Function_Return sValue
94698>>>    End_Function
94699>>>
94699>>>    Procedure Set psPassword String sValue
94701>>>        If (ghoSQLConnectionHandler = 0) Begin
94703>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94704>>>>
94704>>>            Procedure_Return
94705>>>        End
94705>>>>
94705>>>        Set psPassword of ghoSQLConnectionHandler to sValue
94706>>>    End_Procedure
94707>>>
94707>>>    Function psPassword Returns String
94709>>>        String sValue
94709>>>        If (ghoSQLConnectionHandler = 0) Begin
94711>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94712>>>>
94712>>>            Function_Return ""
94713>>>        End
94713>>>>
94713>>>        Get psPassword of ghoSQLConnectionHandler to sValue
94714>>>
94714>>>        Function_Return sValue
94715>>>    End_Function
94716>>>
94716>>>    Procedure Set pbTrusted Boolean bValue
94718>>>        If (ghoSQLConnectionHandler = 0) Begin
94720>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94721>>>>
94721>>>            Procedure_Return
94722>>>        End
94722>>>>
94722>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
94723>>>    End_Procedure
94724>>>
94724>>>    Function pbTrusted Returns Boolean
94726>>>        Boolean bValue
94726>>>        If (ghoSQLConnectionHandler = 0) Begin
94728>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94729>>>>
94729>>>            Function_Return False
94730>>>        End
94730>>>>
94730>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
94731>>>
94731>>>        Function_Return bValue
94732>>>    End_Function
94733>>>
94733>>>    Procedure Set psConnectionString String sValue
94735>>>        If (ghoSQLConnectionHandler = 0) Begin
94737>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94738>>>>
94738>>>            Procedure_Return
94739>>>        End
94739>>>>
94739>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
94740>>>    End_Procedure
94741>>>
94741>>>    Function psConnectionString Returns String
94743>>>        String sValue
94743>>>        If (ghoSQLConnectionHandler = 0) Begin
94745>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94746>>>>
94746>>>            Function_Return ""
94747>>>        End
94747>>>>
94747>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
94748>>>
94748>>>        Function_Return sValue
94749>>>    End_Function
94750>>>
94750>>>    Function piConnectionOptions Returns Integer
94752>>>        Integer iValue
94752>>>        If (ghoSQLConnectionHandler = 0) Begin
94754>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94755>>>>
94755>>>            Function_Return 0
94756>>>        End
94756>>>>
94756>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
94757>>>
94757>>>        Function_Return iValue
94758>>>    End_Function
94759>>>
94759>>>
94759>>>    Procedure Set pbCheckDataFlexUserCount Boolean bState
94761>>>        Set pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
94762>>>    End_Procedure
94763>>>
94763>>>    Function pbCheckDataFlexUserCount Returns Boolean
94765>>>        Boolean bState
94765>>>        Get pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
94766>>>        Function_Return bState
94767>>>    End_Function
94768>>>
94768>>>    Procedure Set psLogTextFile String sValue
94770>>>        Set psLogTextFile of (phoLogFile(Self)) to sValue
94771>>>    End_Procedure
94772>>>
94772>>>    Function psLogTextFile Returns String
94774>>>        String sValue
94774>>>        Get psLogTextFile of (phoLogFile(Self)) to sValue
94775>>>        Function_Return sValue
94776>>>    End_Function
94777>>>
94777>>>    Procedure Set psEditorProgram String sValue
94779>>>        Set psEditorProgram of (phoLogFile(Self)) to sValue
94780>>>    End_Procedure
94781>>>
94781>>>    Function psEditorProgram Returns String
94783>>>        String sValue
94783>>>        Get psEditorProgram of (phoLogFile(Self)) to sValue
94784>>>        Function_Return sValue
94785>>>    End_Function
94786>>>
94786>>>    Procedure Set pbUseDataTableLog Boolean bState
94788>>>        Set pbUseDataTableLog of (phoLogFile(Self)) to bState
94789>>>    End_Procedure
94790>>>
94790>>>    Function pbUseDataTableLog Returns Boolean
94792>>>        Boolean bState
94792>>>        Get pbUseDataTableLog of (phoLogFile(Self)) to bState
94793>>>        Function_Return bState
94794>>>    End_Function
94795>>>
94795>>>    Procedure Set pbQuickWrite Boolean bState
94797>>>        Set pbQuickWrite of (phoLogFile(Self)) to bState
94798>>>    End_Procedure
94799>>>
94799>>>    Function pbQuickWrite Returns Boolean
94801>>>        Boolean bState
94801>>>        Get pbQuickWrite of (phoLogFile(Self)) to bState
94802>>>        Function_Return bState
94803>>>    End_Function
94804>>>
94804>>>    Procedure Set pbDatabaseWasUpdated Boolean bState
94806>>>        Boolean bUpdateVersionObjectError bVerboseState
94806>>>        Integer iSize iCount
94806>>>        Number nVersion
94806>>>        String[] aSQLQueryMessages
94807>>>
94807>>>        Get Private.pbUpdateVersionObjectError to bUpdateVersionObjectError
94808>>>        Set Private.pbDatabaseWasUpdated to bState
94809>>>        // If no errors occurred in the current cDbUpdateVersion object - write
94809>>>        // to the log that it was OK.
94809>>>        If (bUpdateVersionObjectError = False) Begin
94811>>>            Get pnCurrentVersionUpdate to nVersion
94812>>>            Send LogError of (phoLogFile(Self)) nVersion 0 CS_SuccessfulUpdate 0 False
94813>>>        End
94813>>>>
94813>>>
94813>>>        Get pbVerboseState to bVerboseState
94814>>>        If (bVerboseState = True) Begin
94816>>>            Get paSQLQueryMessages to aSQLQueryMessages
94817>>>            Move (SizeOfArray(aSQLQueryMessages)) to iSize
94818>>>            Decrement iSize
94819>>>            For iCount from 0 to iSize
94825>>>>
94825>>>                Send LogError of (phoLogFile(Self)) nVersion 0 aSQLQueryMessages[iCount] 0 False
94826>>>            Loop
94827>>>>
94827>>>        End
94827>>>>
94827>>>
94827>>>    End_Procedure 
94828>>>    
94828>>>    Procedure Set piDbVersionFileNumber Integer iFileNumber
94830>>>        Set Private.piDbVersionFileNumber to iFileNumber
94831>>>    End_Procedure                                         
94832>>>    
94832>>>    Function piDbVersionFileNumber Returns Integer
94834>>>        Function_Return (Private.piDbVersionFileNumber(Self))
94835>>>    End_Function
94836>>>
94836>>>    Procedure Set piDbVersionFieldNumber Integer iFieldNumber
94838>>>        Set Private.piDbVersionFieldNumber to iFieldNumber
94839>>>    End_Procedure                                         
94840>>>    
94840>>>    Function piDbVersionFieldNumber Returns Integer
94842>>>        Function_Return (Private.piDbVersionFieldNumber(Self))
94843>>>    End_Function
94844>>>
94844>>>    Function pbDatabaseWasUpdated Returns Boolean
94846>>>        Function_Return (Private.pbDatabaseWasUpdated(Self))
94847>>>    End_Function
94848>>>    
94848>>>    //
94848>>>    Procedure ReinitializeFramework  
94850>>>        tDbVersionInfo[] aDbVersionInfoArray
94850>>>        tDbVersionInfo[] aDbVersionInfoArray
94851>>>        Handle hoDbVersionObject
94851>>>        Integer iSize iCount
94851>>>        
94851>>>        Set Private.pbDatabaseUpdateStarted to False
94852>>>        Get paDbVersionInfoArray to aDbVersionInfoArray
94853>>>        Move (SizeOfArray(aDbVersionInfoArray)) to iSize
94854>>>        Decrement iSize
94855>>>        
94855>>>        For iCount from 0 to iSize
94861>>>>
94861>>>            Move aDbVersionInfoArray[0].hObject to hoDbVersionObject
94862>>>            Send ProcessUpdate                  of hoDbVersionObject False
94863>>>        Loop
94864>>>>
94864>>>        Send Cleanup
94865>>>    End_Procedure
94866>>>    
94866>>>    // This event is triggered by the cDbUpdateVersion child class when
94866>>>    // a database change is to be started, and is considered private.
94866>>>    // It is only executed once for the first cDbUpateVersion object!
94866>>>    Procedure InitDatabaseUpdate Handle hDbUpdateVersionObject
94868>>>        Boolean bDatabaseUpdateStarted bInUse bExists bCheckDataFlexUserCount
94868>>>        Integer iRetval iDataFlexUsers iUserCount
94868>>>        Handle hoUserCountSystem
94868>>>        tUserCount UserCount
94868>>>        tUserCount UserCount
94868>>>        DateTime dtUpdateStarted
94868>>>        tSQLConnection SQLConnection
94868>>>        tSQLConnection SQLConnection
94868>>>
94868>>>        // *Important:* If we already started the update; we do no further checking.
94868>>>        Get Private.pbDatabaseUpdateStarted to bDatabaseUpdateStarted
94869>>>        If (bDatabaseUpdateStarted = True) Begin
94871>>>            Procedure_Return
94872>>>        End
94872>>>>
94872>>>
94872>>>        // If not silent mode; Ask user if OK to start database update.
94872>>>        If (pbSilentMode(Self) = False) Begin
94874>>>            Get YesNo_Box CS_DUF_DatabaseNeedsUpdate CS_DUF_HeaderUpdateText to iRetval
94875>>>            If (iRetval <> MBR_Yes) Begin
94877>>>                Send Exit_Application
94878>>>            End
94878>>>>
94878>>>        End
94878>>>>
94878>>>        
94878>>>        Send EnableCancelButton     of ghoStatusPanel (pbEnableCancelButton(Self))
94879>>>        Send Initialize_StatusPanel of ghoStatusPanel ("   " + CS_DUF_WorkingUpdateText) CS_DUF_WorkingHeaderText ""
94880>>>        Send Start_StatusPanel      of ghoStatusPanel
94881>>>
94881>>>        // This will save the status of all open tables including Master/Alias settings,
94881>>>        // so we can restore them later;
94881>>>        Send SaveOpenTables
94882>>>
94882>>>        Move 0 to iDataFlexUsers
94883>>>        // Make various tests to check that the database is not in use.
94883>>>        Get IsDatabaseInUse of hDbUpdateVersionObject to bInUse
94884>>>        // We also use our own user counting mechanism to guard against the
94884>>>        // database isn't opened already as we need exclusive access to the tables.:
94884>>>        Get phoUserCountSystem to hoUserCountSystem
94885>>>        Get CheckUserCount of hoUserCountSystem to UserCount
94886>>>        Get CurrentNumberOfUsers of hoUserCountSystem to iUserCount
94887>>>
94887>>>        Get pbCheckDataFlexUserCount of hoUserCountSystem to bCheckDataFlexUserCount
94888>>>        // Check DataFlex user count to see if anybody else is using the DataFlex license...
94888>>>        If (bCheckDataFlexUserCount = True) Begin
94890>>>            Get_Current_User_Count to iDataFlexUsers
94891>>>            // For some reason DataFlex - in some cases - might think that 2 users
94891>>>            // are in use while debugging from the Studio.
94891>>>            If (IsDebuggerPresent() and iDataFlexUsers = 2) Begin
94893>>>                Decrement iDataFlexUsers
94894>>>            End
94894>>>>
94894>>>        End 
94894>>>>
94894>>>        Else Begin
94895>>>            Move 1 to iDataFlexUsers 
94896>>>            Move 1 to iUserCount
94897>>>            Move False to bInUse
94898>>>        End
94898>>>>
94898>>>
94898>>>        If (pbSilentMode(Self) = False and iDataFlexUsers > 1) Begin
94900>>>            Get YesNo_Box CS_DUF_DatabaseInUseShort to iRetval
94901>>>            If (iRetval <> MBR_Yes) Begin
94903>>>                Send Exit_Application
94904>>>            End
94904>>>>
94904>>>        End
94904>>>>
94904>>>
94904>>>        If (bInUse = True or (UserCount.iError <> 0) or (iUserCount > 1)) Begin
94906>>>            Send Stop_Box CS_DUF_DatabaseInUseText
94907>>>            Send Exit_Application
94908>>>        End
94908>>>>
94908>>>
94908>>>        // This will put a look on the DbUpdateLock.ucf file.
94908>>>        // It is released when the update process is finished
94908>>>        Get CheckUserCount of (phoDatabaseUpdateLock(Self)) to UserCount
94909>>>
94909>>>        Move (CurrentDateTime()) to dtUpdateStarted
94910>>>        Set pdtUpdateStart of (phoLogFile(Self)) to dtUpdateStarted
94911>>>        Set Private.pbDatabaseUpdateStarted to True
94912>>>
94912>>>        // We need to close all tables before starting to make changes.
94912>>>        Close DF_ALL DF_PERMANENT
94913>>>
94913>>>        // If these properties has not exclicitly been set in the object, set them
94913>>>        // to settings from the SQLConnections.ini file;
94913>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
94914>>>        If (psSchema(Self) = "") Begin
94916>>>            Set psSchema            to SQLConnection.sSchema
94917>>>        End
94917>>>>
94917>>>        If (psBaseTableSpace(Self) = "") Begin
94919>>>            Set psBaseTableSpace    to SQLConnection.sBaseTableSpace
94920>>>        End
94920>>>>
94920>>>        If (psLongTableSpace(Self) = "") Begin
94922>>>            Set psLongTableSpace    to SQLConnection.sLongTableSpace
94923>>>        End
94923>>>>
94923>>>        If (psIndexTableSpace(Self) = "") Begin
94925>>>            Set psIndexTableSpace   to SQLConnection.sIndexTableSpace
94926>>>        End
94926>>>>
94926>>>        If (SQLConnection.sDriverID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
94928>>>            Procedure_Return
94929>>>        End
94929>>>>
94929>>>
94929>>>        Get SQLUtilCheckIfDatabaseExists of hDbUpdateVersionObject SQLConnection.sDatabase to bExists
94930>>>        If (SQLConnection.sDatabase <> "" and bExists = False) Begin
94932>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94933>>>            Send Stop_StatusPanel of ghoStatusPanel
94934>>>            // ToDo: NS 2019-09-23 I think we should always show an error message to the user if this occur (!)
94934>>>            Send Stop_Box (CS_DUF_DatabaseConnStringSpec + SQLConnection.sDatabase + CS_DUF_DatabaseDoesntExist )
94935>>>//            Error DFERR_PROGRAM ("The database specified in the connection string: '" + SQLConnection.sDatabase + "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit.")
94935>>>            Send Exit_Application
94936>>>        End
94936>>>>
94936>>>    End_Procedure
94937>>>
94937>>>    // *** Hook message for pre-processing ***
94937>>>    // Event to be used to auto-create a version table when "DUF_Use_Custom_DbVersion" is used.
94937>>>    // Aka, when another table than the standard "DbVersion" is used.
94937>>>    Procedure OnCreateCustomDbVersionTable
94939>>>    End_Procedure
94940>>>    
94940>>>    // *** Hook message for pre-processing ***
94940>>>    // The programmer can use this event for putting code that
94940>>>    // needs to be executed _before_ code in any of the cDbUpdateVersion
94940>>>    // child objects are executed.
94940>>>    Procedure OnPreUpdate
94942>>>    End_Procedure
94943>>>
94943>>>    // *** Hook message for post-processing ***
94943>>>    // The programmer should use this event for putting code that
94943>>>    // needs to be executed _after_ all database updates have finished.
94943>>>    Procedure OnPostUpdate
94945>>>    End_Procedure
94946>>>
94946>>>    // *** Hook message for custom DbVersion record find ***
94946>>>    // The programmer can use this event for putting code that
94946>>>    // needs to be executed to find a *custom* DbVersion table record.
94946>>>    // By default the DbVersion table is used but this can be
94946>>>    // customized by adding this line to the code;
94946>>>    // "Define DUF_Use_Custom_DbVersion" before the line "Use cDbUpdateHandler.pkg"
94946>>>    // Note: You do _not_ need to use this event if the DbVersion table is used
94946>>>    //       to save the current database version to. Only if you use your own
94946>>>    //       table _and_ it is not a system table (contains only one record).
94946>>>    Procedure OnFindVersionRecord
94948>>>        // Open MyTable
94948>>>        // Move xx to MyTable.Field1
94948>>>        // Move yy to MyTable.Field2
94948>>>        // Find le MyTable by Index.x
94948>>>    End_Procedure
94949>>>
94949>>>    // Hook event for writing header error text (pre-update) to
94949>>>    // a datatable. Only called if the pbUseDataTableLog property = True.
94949>>>    // Don't forget to Open the table first (!) as all
94949>>>    // tables have been closed at this stage.
94949>>>    // The start date & time is passed.
94949>>>    Procedure OnErrorWriteHeader_DataTable DateTime dtUpdateStart
94951>>>    End_Procedure
94952>>>
94952>>>    // Hook event to log errors to a database table.
94952>>>    // Only called if the pbUseDataTableLog = True.
94952>>>    // Don't forget to Open the table first (!) as all
94952>>>    // tables have been closed at this stage.
94952>>>    // If pbQuickWrite = True the DbUpdateErrorArray
94952>>>    // will contain just one row, as it is called for each error
94952>>>    // that occurred. Else it is called once at the end after all updates
94952>>>    // have run and contains all errors.
94952>>>    Procedure OnErrorWriteRow_DataTable tDbUpdateError[] DbUpdateErrorArray
94954>>>    End_Procedure
94955>>>
94955>>>    // Automatically send after all processing is done, but before the OnPostUpdate event.
94955>>>    Procedure Cleanup
94957>>>        Boolean bDatabaseWasUpdated bError
94957>>>
94957>>>        Send CheckAutoCreateDbVersionTable
94958>>>        Send RestoreOpenTables
94959>>>
94959>>>        // The function library have two purposes; one is to use it in the
94959>>>        // Database Update Framework, but it can also be used on its own.
94959>>>        // If that is the case it has its own error handling system, which
94959>>>        // we temporarily disbled when running updates because we have
94959>>>        // error handling/logging here too... We now restore its setting.
94959>>>        If (ghoDbUpdateFunctionLibrary > 0) Begin
94961>>>            Set pbHandleQueryErrors of ghoDbUpdateFunctionLibrary to True
94962>>>        End
94962>>>>
94962>>>        Set pbHandleQueryErrors to True
94963>>>
94963>>>        Get pbDatabaseWasUpdated to bDatabaseWasUpdated
94964>>>        Get pbDbUpdateErrorHasOccured to bError
94965>>>        If (bDatabaseWasUpdated = True or bError = True) Begin
94967>>>
94967>>>            // We should always create the log as it also contains info about
94967>>>            // the update being successful.
94967>>>            Send WriteErrorLog of (phoLogFile(Self))
94968>>>
94968>>>            // This is a programmer's hook message:
94968>>>            Send OnPostUpdate
94969>>>
94969>>>            Send Stop_StatusPanel of ghoStatusPanel
94970>>>
94970>>>            If (pbSilentMode(Self) = False) Begin
94972>>>                If (bError = True) Begin
94974>>>                    If (pbShowErrorLogPostRun(Self) = True) Begin
94976>>>                        Send ShowErrorLog of (phoLogFile(Self))
94977>>>                    End
94977>>>>
94977>>>                    Send Info_Box CS_DUF_DbUpdatedErrorText
94978>>>                    Send Exit_Application
94979>>>                End
94979>>>>
94979>>>                Else Begin
94980>>>                    If (Private.pbDatabaseWasUpdated(Self) = True) Begin
94982>>>                        Send Info_Box CS_DUF_DatabaseUpdatedText
94983>>>                    End
94983>>>>
94983>>>                    Else Begin
94984>>>                        Send Info_Box CS_DUF_DatabaseCheckedText
94985>>>                    End
94985>>>>
94985>>>
94985>>>                End
94985>>>>
94985>>>            End
94985>>>>
94985>>>        End
94985>>>>
94985>>>
94985>>>        // Restore the standard error handler:
94985>>>        Get piOrgErrorHandlerID to Error_Object_Id
94986>>>    End_Procedure
94987>>>
94987>>>    // We do this _before_ we close the database to make changes, and save
94987>>>    // all 'Master' & 'Alias' tables settings so we can restore when
94987>>>    // we reopen the database.
94987>>>    Procedure SaveOpenTables
94989>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94989>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94990>>>        Get _MasterAndAliasFiles to aDbUpdateHandlerMasterAlias
94991>>>        Set paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
94992>>>    End_Procedure
94993>>>
94993>>>    // Returns a struct array with all currently open tables and a "state" that indicates if the table
94993>>>    // was opened DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER or DF_FILE_IS_ALIAS
94993>>>    Function _MasterAndAliasFiles Returns tDbUpdateHandlerMasterAlias[]
94995>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94995>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94996>>>        Integer hTable iMasterAliasType iSize
94996>>>        Boolean bOpen
94996>>>
94996>>>        Move 0 to hTable
94997>>>        Repeat
94997>>>>
94997>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
95000>>>            If (hTable <> 0) Begin
95002>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
95005>>>                If (bOpen = True) Begin
95007>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iMasterAliasType
95010>>>                    Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
95011>>>                    Move hTable to aDbUpdateHandlerMasterAlias[iSize].hTable
95012>>>                    Move iMasterAliasType to aDbUpdateHandlerMasterAlias[iSize].iMode
95013>>>                End
95013>>>>
95013>>>            End
95013>>>>
95013>>>        Until (hTable = 0)
95015>>>
95015>>>        Function_Return aDbUpdateHandlerMasterAlias
95016>>>    End_Function
95017>>>
95017>>>    // Message that re-opens all files in the filelist.cfg and restores any master & alias attributes.
95017>>>    // Takes one parameter:
95017>>>    //   A struct array with all master & alias
95017>>>    Procedure RestoreOpenTables
95019>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
95019>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
95020>>>        Integer hTable iFileAlias iSize iCount
95020>>>        Boolean bOpen
95020>>>        String sRootName
95020>>>
95020>>>        Move 0 to hTable
95021>>>        Get paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
95022>>>        Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
95023>>>        Decrement iSize
95024>>>        For iCount from 0 to iSize
95030>>>>
95030>>>            Move aDbUpdateHandlerMasterAlias[iCount].hTable to hTable
95031>>>            // We also need to check that the table hasn't been removed...
95031>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
95034>>>            If (hTable <> 0 and sRootName <> "") Begin
95036>>>                Open hTable
95038>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
95041>>>                If (bOpen = True) Begin
95043>>>                    Move aDbUpdateHandlerMasterAlias[iCount].iMode to iFileAlias
95044>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
95046>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_MASTER
95049>>>                    End
95049>>>>
95049>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
95052>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_ALIAS
95055>>>                    End
95055>>>>
95055>>>                End
95055>>>>
95055>>>            End
95055>>>>
95055>>>        Loop
95056>>>>
95056>>>    End_Procedure
95057>>>
95057>>>    // This checks for both duplicate pnVersionNumbers _and_ that
95057>>>    // the cDbVersion object pnVersionNumber's all are consecutive (higher than the previous).
95057>>>    Procedure CheckForDuplicates Number nVersion
95059>>>        tDbVersionInfo[] DbVersionInfoArray
95059>>>        tDbVersionInfo[] DbVersionInfoArray
95060>>>        Integer iCount iSize iHits iDuplicateIndex
95060>>>        Number nCompare
95060>>>        Handle hObject1 hObject2
95060>>>        String sObjectName1 sObjectName2
95060>>>        Boolean bObjectOrderError
95060>>>
95060>>>        Get paDbVersionInfoArray to DbVersionInfoArray
95061>>>        Move (SizeOfArray(DbVersionInfoArray)) to iSize
95062>>>        Decrement iSize
95063>>>        Move 0 to iHits
95064>>>        Move 0 to nCompare
95065>>>        Move False to bObjectOrderError
95066>>>        For iCount from 0 to iSize
95072>>>>
95072>>>            If (nVersion = DbVersionInfoArray[iCount].nVersionNumber) Begin
95074>>>                Increment iHits
95075>>>                If (iHits > 1) Begin
95077>>>                    Move iCount to iDuplicateIndex
95078>>>                    If (nCompare <> 0) Begin
95080>>>                        Move (nCompare >= DbVersionInfoArray[iCount].nVersionNumber) to bObjectOrderError
95081>>>                    End
95081>>>>
95081>>>                End
95081>>>>
95081>>>            End
95081>>>>
95081>>>            Move DbVersionInfoArray[iCount].nVersionNumber to nCompare
95082>>>        Loop
95083>>>>
95083>>>        If (iHits > 1) Begin
95085>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
95086>>>            Move DbVersionInfoArray[(iDuplicateIndex   )].hObject to hObject1
95087>>>            Move DbVersionInfoArray[(iDuplicateIndex -1)].hObject to hObject2
95088>>>            Move (Name(hObject1)) to sObjectName1
95089>>>            Move (Name(hObject2)) to sObjectName2
95090>>>            Error DFERR_PROGRAM ("Duplicate version numbers! The SAME pnVersionNumber value was set for the following two objects; Program will now exit!\n\n" + sObjectName1 + "\n" + sObjectName2)
95091>>>>
95091>>>            Send Exit_Application
95092>>>        End
95092>>>>
95092>>>        Else If (bObjectOrderError = True) Begin
95095>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
95096>>>            Error DFERR_PROGRAM ("cDbVersion objects out of order! One or more of the cDbVersion objects has been placed out of order. This means that at least one pnVersionNumber is HIGHER than the following object's pnVersionNumber.\nProgram will now exit!")
95097>>>>
95097>>>            Send Exit_Application
95098>>>        End
95098>>>>
95098>>>    End_Procedure
95099>>>
95099>>>    // We take care of all errors in the Error_Report below and
95099>>>    // collect them all to an array property. So just ignore any
95099>>>    // "Ignore_Error" & "Trap_Error" messages that might be send/used
95099>>>    // in some other package.
95099>>>    Procedure Ignore_Error Integer iError
95101>>>    End_Procedure
95102>>>
95102>>>    Procedure Trap_Error Integer iError
95104>>>    End_Procedure
95105>>>
95105>>>    // Build complete error description from Flexerrs and user error message.
95105>>>    Function Error_Description Integer Error# String ErrMsg Returns String
95107>>>        String Full_Error_Text
95107>>>        
95107>>>        Move (Trim(ErrMsg)) to ErrMsg
95108>>>        Move (Trim(Error_Text(DESKTOP, Error#))) to Full_Error_Text
95109>>>        
95109>>>        If (ErrMsg <> "") Begin
95111>>>            
95111>>>            If ((Full_Error_Text<>"" ) and ;                Error_Text_Available( DESKTOP, Error# ) ) Begin
95113>>>                // Make sure last character of error text is a separating symbol.
95113>>>                // if not, add a "." So we have format of "error-text. error-detail"
95113>>>                If (Pos(Right(Full_Error_Text,1),".,:;") =0) ;                    Move (Full_Error_Text - ".") to Full_Error_Text
95116>>>                Move (Full_Error_Text * ErrMsg)  to Full_Error_Text
95117>>>            End
95117>>>>
95117>>>            Else ;                Move ErrMsg to Full_Error_Text
95119>>>            
95119>>>        End
95119>>>>
95119>>>        
95119>>>        Function_Return Full_Error_Text
95120>>>    End_Function
95121>>>
95121>>>    // While we update the database we collect all errors in
95121>>>    // the struct array paDbUpdateErrorArray.
95121>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
95123>>>        Number nVersion
95123>>>        Handle hoLogFile 
95123>>>//        String sErrExtraText
95123>>>        
95123>>>        If (Private.pbProcessingError(Self)) Begin
95125>>>            Procedure_Return
95126>>>        End
95126>>>>
95126>>>
95126>>>        // The UtilTableNameFromHandleToString function does a:
95126>>>        // "Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName" call
95126>>>        // and it generates an error if the table is of the embedded type.
95126>>>        // As we don't want to trigger an error in that very specific case,
95126>>>        // we just ignore it here.
95126>>>        //
95126>>>        // If no report mode, just set the err indicator to true.
95126>>>        If (Error_Report_Mode(Self) = DUF_ERROR_NO_REPORT) Begin
95128>>>            Move False to Err
95129>>>            Procedure_Return
95130>>>        End
95130>>>>
95130>>>
95130>>>        If (iErrorNumber = DFERR_UNSUPPORTED_ATTRIBUTE) Begin
95132>>>            Procedure_Return
95133>>>        End
95133>>>>
95133>>>
95133>>>        Set Private.pbProcessingError to True
95134>>>        Set Private.pbUpdateVersionObjectError to True
95135>>>
95135>>>        Set pbDbUpdateErrorHasOccured to True
95136>>>        Get pnCurrentVersionUpdate to nVersion
95137>>>        Get phoLogFile to hoLogFile
95138>>>//        Get Error_Description iErrorLine sErrorText to sErrorText
95138>>>        Send LogError of hoLogFile nVersion iErrorNumber sErrorText iErrorLine True
95139>>>
95139>>>        Set Private.pbProcessingError to False
95140>>>    End_Procedure
95141>>>
95141>>>End_Class
95142>
95142>Object oHtmlHelp is a cHtmlHelp
95144>    Set pbAlwaysOnTop to False
95145>
95145>    // Overriden class message to also handle internet HTML Help links;
95145>    // which in which case we should not try to find the path to the help file.
95145>    Function GetHelpFile Returns String
95148>        String sHelpFile
95148>
95148>        Get psHelpFile of ghoApplication to sHelpFile
95149>        If (sHelpFile <> "" and not(sHelpFile contains "http:")) Begin
95151>            Get_File_Path sHelpFile to sHelpFile
95152>        End
95152>        Function_Return sHelpFile
95153>    End_Function
95154>
95154>End_Object
95155>
95155>Object oApplication is a cApplication
95157>    Set peHelpType to htHtmlHelp
95158>
95158>    // Note: These help file settings gets changed by the Help toolbar button(s).
95158>    Set psHelpFile to "Developer5.chm"
95159>//    Set psHelpFile to "http://www.rdctools.com/HTMLHelp/Developer5.htm"
95159>
95159>    Set pbPreserveEnvironment to True
95160>    Set psProduct to "Database Update Framework Lab"
95161>    Set psCompany to "RDC Tools International"
95162>
95162>    // DF 19 and up.
95162>    Object oConnection is a cConnection
95164>        Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (C:\Program Files\DataFlex 20.1\Pkg\LoginEncryption.pkg)
95164>>>Use cLoginEncryption.pkg
95164>>>
95164>>>Object oLoginEncryption is a cLoginEncryption
95166>>>
95166>>>    // this must be created in your appsrc directory and must contain an encryption
95166>>>    // key that is set to psEncryptPassword. It will look something like this
95166>>>    //
95166>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
95166>>>    //  
Including file: LoginEncryptionKey.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\LoginEncryptionKey.inc)
95166>>>>// Studio generated login encryption key
95166>>>>Set psEncryptPassword to "%sLm*XHVF>f0yB.:.PHrBx6L)8x70i7zAN{q._WC"
95167>>>>
95167>>>    
95167>>>    // use this to register this object to your cConnection Object. This object
95167>>>    // must be created after the cConnection object
95167>>>    Move Self to ghoLoginEncryption
95168>>>End_Object
95169>        Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (C:\Program Files\DataFlex 20.1\Pkg\DatabaseLoginDialog.dg)
95169>>>
95169>>>Use Windows.pkg
95169>>>Use cConnection.pkg
95169>>>Use dfLine.pkg
95169>>>
95169>>>Object oDatabaseLoginDialog is a ModalPanel
95171>>>    Set Label to "Database Login"
95172>>>    Set Location to 2 2
95173>>>    Set Size to 110 211
95174>>>    
95174>>>    Property String psId
95176>>>    Property Boolean pbOk False
95178>>>    Property Boolean pbChanged False
95180>>>    Property Boolean pbAllowRemember True
95182>>>    
95182>>>    // this registers this object with the cConnection object.
95182>>>    Move Self to ghoLoginConnectDialog
95183>>>    
95183>>>    Object oUserIDForm is a Form
95185>>>        Set Label to "User Name"
95186>>>        Set Size to 12 85
95187>>>        Set Location to 34 79
95188>>>        Set Label_Col_Offset to 64
95189>>>        Set peAnchors to anTopLeftRight
95190>>>    End_Object
95191>>>    
95191>>>    Object oPwdForm is a Form
95193>>>        Set Size to 12 85
95194>>>        Set Location to 49 79
95195>>>        Set Label_Col_Offset to 64
95196>>>        Set Password_State to True
95197>>>        Set peAnchors to anTopLeftRight
95198>>>        Set Label to "Password"
95199>>>    End_Object
95200>>>    
95200>>>    Object oTrustedConnection is a CheckBox
95202>>>        Set Size to 10 50
95203>>>        Set Location to 65 79
95204>>>        Set Label to "Trusted Connection"
95205>>>    End_Object
95206>>>    
95206>>>    Object oRemember is a CheckBox
95208>>>        Set Size to 10 50
95209>>>        Set Location to 79 14
95210>>>        Set Label to "Remember and don't ask again"
95211>>>        Set Checked_State to True
95212>>>    End_Object
95213>>>    
95213>>>    Object oLogin_btn is a Button
95215>>>        Set Label to "&Login"
95216>>>        Set Location to 92 102
95217>>>        Set peAnchors to anBottomRight
95218>>>        Set Default_State to True
95219>>>        
95219>>>        Procedure OnClick
95222>>>            Boolean bTrust
95222>>>            String sUser sPwd sConn sErr sId
95222>>>            Integer iError
95222>>>            Get psId to sId
95223>>>            Get Value of oUserIDForm to sUser
95224>>>            Get Value of oPwdForm to sPwd
95225>>>            Get Checked_State of oTrustedConnection to bTrust
95226>>>            
95226>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
95227>>>            If (iError=0) Begin
95229>>>                Set pbOk to True
95230>>>                Set pbChanged to True
95231>>>                Send Close_Panel
95232>>>            End
95232>>>>
95232>>>            Else Begin
95233>>>                Get psErrorText of ghoConnection to sErr
95234>>>                Send UserError sErr "Login Error"
95235>>>            End
95235>>>>
95235>>>        End_Procedure
95236>>>    End_Object
95237>>>    
95237>>>    Object oCancel_btn is a Button
95239>>>        Set Label to "&Cancel"
95240>>>        Set Location to 92 157
95241>>>        Set peAnchors to anBottomRight
95242>>>        
95242>>>        Procedure OnClick
95245>>>            Send Close_Panel
95246>>>        End_Procedure
95247>>>    End_Object
95248>>>    
95248>>>    Object oConnectionIdInfo is a TextBox
95250>>>        Set Size to 10 50
95251>>>        Set Location to 4 14
95252>>>        Set Label to 'Connection Id='
95253>>>    End_Object
95254>>>    
95254>>>    Object oConnectionServerInfo is a TextBox
95256>>>        Set Size to 10 50
95257>>>        Set Location to 16 14
95258>>>        Set Label to 'Server'
95259>>>    End_Object
95260>>>    
95260>>>    Object oLineControl1 is a LineControl
95262>>>        Set Size to 2 202
95263>>>        Set Location to 29 5
95264>>>    End_Object
95265>>>    
95265>>>    Function LoginConnectIdDialog String sId Returns Boolean
95268>>>        Boolean bOk bChanged bTrusted bAllowRemember bRemember
95268>>>        String sUser sPwd sDescription
95268>>>        tConnection Connect
95268>>>        tConnection Connect
95268>>>        
95268>>>        Get pbAllowRemember to bAllowRemember
95269>>>        
95269>>>        
95269>>>        If not bAllowRemember Begin
95271>>>            Set Enabled_State of oRemember to bRemember
95272>>>            Set Visible_State of oRemember to bRemember
95273>>>        End
95273>>>>
95273>>>        
95273>>>        Get ConnectionIdInfo of ghoConnection sId to Connect
95274>>>        Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
95275>>>        Set Value of oConnectionServerInfo to Connect.sString
95276>>>        
95276>>>        Set psId to sId
95277>>>        Set pbOk to False
95278>>>        Set pbChanged to False
95279>>>        Set Value of oUserIDForm to Connect.sUID
95280>>>        Set Value of oPwdForm to ""
95281>>>        
95281>>>        Send Popup
95282>>>        
95282>>>        Get pbOk to bOk
95283>>>        Get pbChanged to bChanged
95284>>>        If (bChanged and bOk) Begin
95286>>>            If bAllowRemember Begin
95288>>>                Get Checked_State of oRemember to bRemember
95289>>>                If bRemember Begin
95291>>>                    Get Checked_State of oTrustedConnection to bTrusted
95292>>>                    If not (bTrusted) Begin
95294>>>                        Get Value of oUserIDForm to sUser
95295>>>                        Get Value of oPwdForm to sPwd
95296>>>                    End
95296>>>>
95296>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
95297>>>                End
95297>>>>
95297>>>            End
95297>>>>
95297>>>        End
95297>>>>
95297>>>        Function_Return bOk
95298>>>    End_Function
95299>>>    
95299>>>    
95299>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
95300>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
95301>>>End_Object
95302>>>
95302>    End_Object
95303>
95303>End_Object   
95304>
95304>Object oDbUpdateHandler is a cDbUpdateHandler 
95306>    Set piDbVersionFieldNumber to 1
95307>    Set piDbVersionFileNumber to 1
95308>    
95308>End_Object
95309>
95309>Object oCJSkinFramework is a cCJSkinFramework
95311>    Set pbLoadPreference to True
95312>End_Object
95313>
95313>Object oToolTipController is a cToolTipController
95315>    Set piDurationPopup to 10000
95316>    Set piMaxWidth to 500
95317>    Move Self to ghoToolTipController
95318>End_Object
95319>
95319>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files\DataFlex 20.1\Pkg\oEditContextMenu.pkg)
95319>>>Use cCJStandardMenuItemClasses.pkg
95319>>>
95319>>>Object oEditContextMenu is a cCJContextMenu
95321>>>    
95321>>>    Move Self to Default_Form_Floating_Menu_ID
95322>>>    
95322>>>    Object oUndoMenuItem is a cCJUndoMenuItem
95324>>>    End_Object
95325>>>    
95325>>>    Object oCutMenuItem is a cCJCutMenuItem
95327>>>        Set pbControlBeginGroup to True
95328>>>    End_Object
95329>>>    
95329>>>    Object oCopyMenuItem is a cCJCopyMenuItem
95331>>>    End_Object
95332>>>
95332>>>    Object oPasteMenuItem is a cCJPasteMenuItem
95334>>>    End_Object
95335>>>
95335>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
95337>>>    End_Object
95338>>>
95338>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
95340>>>        Set pbControlBeginGroup to True
95341>>>    End_Object
95342>>>
95342>>>End_Object
95343>>>
95343>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files\DataFlex 20.1\Pkg\oDEOEditContextMenu17.pkg)
95343>>>Use Windows.pkg
95343>>>Use cCJStandardMenuItemClasses.pkg
95343>>>Use cCJDeoMenuItemClasses.pkg
95343>>>
95343>>>
95343>>>Object oDEOEditContextMenu17 is a cCJContextMenu
95345>>>    
95345>>>    Move Self to Default_dbFloating_Menu_ID
95346>>>    
95346>>>    Object oUndoMenuItem is a cCJUndoMenuItem
95348>>>    End_Object
95349>>>    
95349>>>    Object oCutMenuItem is a cCJCutMenuItem
95351>>>        Set pbControlBeginGroup to True
95352>>>    End_Object
95353>>>    
95353>>>    Object oCopyMenuItem is a cCJCopyMenuItem
95355>>>    End_Object
95356>>>
95356>>>    Object oPasteMenuItem is a cCJPasteMenuItem
95358>>>    End_Object
95359>>>
95359>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
95361>>>    End_Object
95362>>>
95362>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
95364>>>        Set pbControlBeginGroup to True
95365>>>    End_Object
95366>>>
95366>>>    Object oPromptMenuItem is a cCJPromptMenuItem
95368>>>        Set pbControlBeginGroup to True
95369>>>    End_Object
95370>>>
95370>>>    Object oFindNextMenu is a cCJFindNextMenuItem
95372>>>        Set pbControlBeginGroup to True
95373>>>    End_Object
95374>>>
95374>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
95376>>>    End_Object
95377>>>
95377>>>    Object oClearMenuItem is a cCJClearMenuItem
95379>>>        Set pbControlBeginGroup to True
95380>>>    End_Object
95381>>>
95381>>>    Object oClearAllMenu is a cCJClearAllMenuItem
95383>>>    End_Object
95384>>>
95384>>>    Object oSaveMenu is a cCJSaveMenuItem
95386>>>    End_Object
95387>>>    
95387>>>    Object oDeleteMenu is a cCJDeleteMenuItem
95389>>>    End_Object
95390>>>
95390>>>    Object oRememberitem is a cCJRememberFieldMenuItem
95392>>>        Set pbControlBeginGroup to True
95393>>>    End_Object
95394>>>
95394>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
95396>>>    End_Object
95397>>>
95397>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
95399>>>    End_Object
95400>>>
95400>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
95402>>>    End_Object
95403>>>
95403>>>End_Object
95404>Use cSkinComboBoxCJMenuItem.pkg
Including file: cSkinComboBoxCJMenuItem.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cSkinComboBoxCJMenuItem.pkg)
95404>>>Use cCJCommandBarSystem.pkg
95404>>>Use Wingdi.pkg
95404>>>Use LanguageText.pkg
95404>>>
95404>>>// User interface constant strings:
95404>>>Define CS_NoSkinShort For "-None"
95404>>>Define CS_NoSkinLong  For "Do not use a skin"
95404>>>
95404>>>
95404>>>
95404>>>
95404>>>
95404>>>
95404>>>
95404>>>
95404>>>
95404>>>
95404>>>Class cSkinComboBoxCJMenuItem is a cCJMenuItem
95405>>>
95405>>>    Procedure Construct_Object
95407>>>        Forward Send Construct_Object
95409>>>
95409>>>        Set peControlType to xtpControlComboBox
95410>>>
95410>>>        Property tSkinInformation[] pSkins
95411>>>
95411>>>    End_Procedure
95412>>>
95412>>>    Procedure End_Construct_Object
95414>>>        Forward Send End_Construct_Object
95416>>>    End_Procedure
95417>>>
95417>>>    // Custom array sort for the tSkinInformation struct array.
95417>>>    // Used by LoadSkins message to sort the skin array alphabetically after it has been loaded.
95417>>>    // Why?
95417>>>    // First of all, structs can't be used with the standard SortArray function, that is why we need to
95417>>>    // create a custom sort algorithm.
95417>>>    // Secondly the list of skins would else be sorted in the alphabetical order by the file names.
95417>>>    // However, it is not always the case that the skin description (sName) is the same as the file name.
95417>>>    // If it isn't (which is almost always the case if you have many skin files) the list will look
95417>>>    // randomly ordered. This custom sort method will take care of that.
95417>>>    Function SkinSort tSkinInformation sDescription tSkinInformation sSearchDescription Returns Integer
95419>>>        If ((sDescription.sName * sDescription.sSkinIni) > (sSearchDescription.sName * sSearchDescription.sSkinIni)) Begin
95421>>>            Function_Return (GT)
95422>>>        End
95422>>>>
95422>>>        If ((sDescription.sName * sDescription.sSkinIni) < (sSearchDescription.sName * sSearchDescription.sSkinIni)) Begin
95424>>>            Function_Return (LT)
95425>>>        End
95425>>>>
95425>>>        Function_Return (EQ)
95426>>>    End_Function
95427>>>
95427>>>    Procedure OnCreateControl Handle hoObj
95429>>>        Forward Send OnCreateControl hoObj
95431>>>
95431>>>        Send LoadSkins
95432>>>        Send FillComboList hoObj
95433>>>    End_Procedure
95434>>>
95434>>>    // Load all skins. We will only look for skins in expected
95434>>>    // directory which is the Programs folder.
95434>>>    // Important: When loading skins they will be sorted alphabetically. (See Skinsort function above).
95434>>>    // This is not the case with the 'standard' VDF behaviour.
95434>>>    Procedure LoadSkins
95436>>>        Integer iCount iItems iSize
95436>>>        Boolean bFound
95436>>>        String sFile sIni sSkin
95436>>>        tSkinInformation[] SkinsArray SkinsArrayNoLarge
95436>>>        tSkinInformation[] SkinsArray SkinsArrayNoLarge
95438>>>        tSkinInformation NoneRow
95438>>>        tSkinInformation NoneRow
95438>>>
95438>>>        If (ghoSkinFramework > 0) Begin
95440>>>            Get EnumerateSkins of ghoSkinFramework "" True   to SkinsArray
95441>>>
95441>>>            Move (SortArray(SkinsArray, Self, get_SkinSort)) to SkinsArray
95442>>>            Move CS_NoSkinShort to NoneRow.sName
95443>>>            Move CS_NoSkinLong  to NoneRow.sSkinfile
95444>>>            Move CS_NoSkinLong  to NoneRow.sSkinIni
95445>>>            Move (InsertInArray(SkinsArray, 0, NoneRow))     to SkinsArray
95446>>>
95446>>>            // Get the currently loaded skin.
95446>>>            Get psSkinFile of ghoSkinFramework to sFile
95447>>>            Get psSkinIni  of ghoSkinFramework to sIni
95448>>>
95448>>>            // Remove all Extra Large and Large skins from the array.
95448>>>            Move (SizeOfArray(SkinsArray)) to iItems
95449>>>            Decrement iItems
95450>>>            For iCount From 0 to iItems
95456>>>>
95456>>>                Move SkinsArray[iCount].sSkinIni to sSkin
95457>>>                Move (Uppercase(sSkin) contains " LARGE") to bFound
95458>>>                If (bFound = False) Begin
95460>>>                    Move (SizeOfArray(SkinsArrayNoLarge)) to iSize
95461>>>                    Move SkinsArray[iCount].sName         to SkinsArrayNoLarge[iSize].sName
95462>>>                    Move SkinsArray[iCount].sSkinfile     to SkinsArrayNoLarge[iSize].sSkinfile
95463>>>                    Move SkinsArray[iCount].sSkinIni      to SkinsArrayNoLarge[iSize].sSkinIni
95464>>>                End
95464>>>>
95464>>>            Loop
95465>>>>
95465>>>            Set pSkins to SkinsArrayNoLarge
95466>>>        End
95466>>>>
95466>>>    End_Procedure
95467>>>
95467>>>    // Fills the CodeJock combobox with all skins from the current Programs folder.
95467>>>    Procedure FillComboList Handle hoCombo
95469>>>        Integer iCount iItems iCurrent iTxtEntentSize
95469>>>        String  sFile sIni sCurrSkin
95469>>>        String  sSkin sSkinText
95469>>>        tSkinInformation[] SkinsArray
95469>>>        tSkinInformation[] SkinsArray
95470>>>        Integer iSize
95470>>>
95470>>>        If (ghoSkinFramework < 1) Begin
95472>>>            Procedure_Return
95473>>>        End
95473>>>>
95473>>>
95473>>>        // Get the currently loaded skin.
95473>>>        Get psSkinFile of ghoSkinFramework to sFile
95474>>>        Get psSkinIni  of ghoSkinFramework to sIni
95475>>>        Get pSkins to SkinsArray
95476>>>        Move (SizeOfArray(SkinsArray)) to iItems
95477>>>        Decrement iItems
95478>>>        Send ComClear of hoCombo
95479>>>
95479>>>        For iCount From 0 to iItems
95485>>>>
95485>>>            Move SkinsArray[iCount].sSkinIni  to sSkin
95486>>>            Move (Replace(".ini", sSkin, "")) to sSkin
95487>>>            Move (SkinsArray[iCount].sName * "-" * sSkin) to sSkinText
95488>>>            Send ComAddItem of hoCombo sSkinText (iCount +1)
95489>>>            Get Text_Extent sSkinText to iSize
95490>>>            If (iSize > iTxtEntentSize) Begin
95492>>>                Move iSize to iTxtEntentSize
95493>>>            End
95493>>>>
95493>>>            Move (SkinsArray[iCount].sSkinFile * "-" * SkinsArray[iCount].sSkinIni) to sCurrSkin
95494>>>            If (sCurrSkin = (sFile * "-" * sIni)) Begin
95496>>>                Move iCount to iCurrent
95497>>>            End
95497>>>>
95497>>>        Loop
95498>>>>
95498>>>
95498>>>        Move (Low(iTxtEntentSize) + 30)  to iSize
95499>>>        Set ComDropDownWidth of hoCombo  to iSize
95500>>>        Set ComWidth         of hoCombo  to (iSize + 100)
95501>>>        Set ComListIndex     of hoCombo  to (iCurrent +1)
95502>>>    End_Procedure
95503>>>
95503>>>    // Event for when an item is selected from the comboform
95503>>>    Procedure OnExecute Variant vCommandBarControl
95505>>>        Handle  hoCombo
95505>>>        Integer iSelection
95505>>>        String  sSkinFile sSkinIni
95505>>>        tSkinInformation[] SkinsArray
95505>>>        tSkinInformation[] SkinsArray
95506>>>
95506>>>        // Create and bind proxy control
95506>>>        Get CreateProxyControl vCommandBarControl to hoCombo
95507>>>        // Get the current selection
95507>>>        Get ComListIndex of hoCombo to iSelection
95508>>>        Decrement iSelection
95509>>>        Get pSkins to SkinsArray
95510>>>        Move SkinsArray[iSelection].sSkinfile to sSkinFile
95511>>>        Move SkinsArray[iSelection].sSkinIni  to sSkinIni
95512>>>
95512>>>        Send DoChangeSkin sSkinFile sSkinIni
95513>>>
95513>>>        // Dispose of the proxy control
95513>>>        Send Destroy of hoCombo
95514>>>    End_Procedure
95515>>>
95515>>>    // Send this message to change the current skin.
95515>>>    Procedure DoChangeSkin String sSkinFile String sSkinIni
95517>>>        Handle hoClient
95517>>>
95517>>>        Set psSkinFile of ghoSkinFramework to sSkinFile
95518>>>        Set psSkinIni  of ghoSkinFramework to sSkinIni
95519>>>        Send ApplySkin of ghoSkinFramework
95520>>>
95520>>>        // Note: The following line is essential for the resizing logic
95520>>>        // to function properly when changing a skin and a view is maximized.
95520>>>        Move (Client_Id(phoMainPanel(ghoApplication))) to hoClient
95521>>>        Set Size of hoClient to (Hi(Size(hoClient))) (Low(Size(hoClient) +2))
95522>>>        Set Size of hoClient to (Hi(Size(hoClient))) (Low(Size(hoClient) -2))
95523>>>    End_Procedure
95524>>>
95524>>>    // Returns: DPI setting as an integer.
95524>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
95524>>>    //                      iDPI=120 is "Medium setting" 125%
95524>>>    //                      iDPI= 144 is "Large setting" 150%
95524>>>    Function GetCurrentDPI Returns Integer
95526>>>        Handle hDC
95526>>>        Integer iPixelsX
95526>>>        Move (GetDC(0)) to hDC
95527>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
95528>>>        Move (ReleaseDC(0, hDC)) to hDC
95529>>>        Function_Return iPixelsX
95530>>>    End_Function
95531>>>
95531>>>End_Class
95532>
95532>Object oMain is a Panel
95534>    Set Label to "Test Program - The Database Update Framework"
95535>    Set Location to 2 2
95536>    Set Size to 309 493
95537>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
95538>    Set Icon to "TestTools.ico"
95539>
95539>    Property Handle phoViewMenu 0
95541>    Property Handle phoReportMenu 0
95543>
95543>    Object oCommandBarSystem is a cCJCommandBarSystem
95545>        Set pbTimerUpdate to True
95546>            Set pbAutoResizeIcons to True
95547>            Set pbTabbedWorkspaces to True // Switch on for DF 19 to see the new tabbed-view look.
95548>            Set peVisualTheme to xtpThemeOffice2013Publisher
95549>        Set pbLargeIcons to True
95550>
95550>        Procedure OnCreateCommandBars
95553>            Handle hoOptions
95553>            
95553>            Forward Send OnCreateCommandBars
95555>            
95555>            Get OptionsObject to hoOptions
95556>            Send ComSetIconSize of hoOptions False 32 32  // Set icon size for Toolbar buttons.
95557>        End_Procedure
95558>
95558>
95558>        Procedure OnCreateTabbedWorkspace Handle hoTabWorkspace Handle hoTabPaintManager
95561>            Set ComShowIcons of hoTabPaintManager to True
95562>//            Send ComSetIconSize of hoTabPaintManager 24 24
95562>
95562>            // This will truncate the middle part of long items
95562>            Set ComDrawTextPathEllipsis of hoTabPaintManager to True
95563>        End_Procedure
95564>
95564>        // This is needed to get the "Key_Shift+Key_Tab" key combination to activate
95564>        // the previous tab workspace view.
95564>        Object oPreviousTabAction is a cCJAction
95566>            Set piShortCutKey to (xtpKey_Shift + xtpKey_Ctrl) VK_TAB
95567>            Procedure OnExecute Variant vCommandBarControl
95570>                Handle hoCommandBars hoClientArea
95570>                Forward Send OnExecute vCommandBarControl
95572>                Get CommandBarSystemObject to hoCommandBars
95573>                Get ClientAreaObject of hoCommandBars to hoClientArea
95574>                If hoClientArea Begin
95576>                    Send Switch_Next_View of hoClientArea
95577>                End
95577>            End_Procedure
95578>        End_Object
95579>
95579>        Object oToolBar is a cCJToolbar
95581>            Set psTitle to "Edit Toolbar"
95582>            Set pbGripper to False
95583>            Set peStretched to stStretch
95584>
95584>            Object oCutToolbarItem is a cCJCutMenuItem  
95586>                Set psImage to "ActionCut1.ico"
95587>            End_Object
95588>
95588>            Object oCopyToolbarItem is a cCJCopyMenuItem
95590>                Set psImage to "ActionCopy1.ico"
95591>            End_Object
95592>
95592>            Object oPasteToolbarItem is a cCJPasteMenuItem
95594>                Set psImage to "ActionPaste1.ico"
95595>            End_Object
95596>
95596>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
95598>                Set psImage to "ActionDelete1.ico"
95599>                Set pbControlBeginGroup to True
95600>            End_Object
95601>
95601>            Object oTheme_tb is a cCJMenuItem
95603>                Set peControlType to xtpControlLabel
95604>                Set psCaption to "Theme:"
95605>                Set pbControlBeginGroup to True
95606>            End_Object
95607>
95607>            Object oThemeItem is a cCJMenuItem
95609>                Set peControlType to xtpControlComboBox
95610>                Set psToolTip to "Select a theme to change the appearance of menu- and toolbars."
95611>
95611>                Procedure OnCreateControl Handle hoObj
95614>                    Integer iItem eTheme
95614>                    Set ComWidth of hoObj to 250
95615>                    Send FillComboList hoObj
95616>                    Get peVisualTheme to eTheme
95617>                    Get FindDataItem hoObj eTheme to iItem
95618>                    Set ComListIndex of hoObj to (If(iItem,iItem,1))
95619>                End_Procedure
95620>
95620>                Function FindDataItem Handle hoCombo Integer eVal Returns Integer
95623>                    Integer iCount i eTheme
95623>                    Get ComListCount of hoCombo to iCount
95624>                    For i from 1 to iCount
95630>                        Get ComItemData of hoCombo i to eTheme
95631>                        If (eTheme=eVal) Begin
95633>                            Send SetTheTheme eTheme
95634>                            Function_Return i
95635>                        End
95635>                    Loop
95636>                    Function_Return 0
95637>                End_Function
95638>
95638>                Procedure AddTheme Handle hoCombo String sText Integer eTheme
95641>                    Integer iCount
95641>                    Get ComListCount of hoCombo to iCount
95642>                    Increment iCount
95643>                    Send ComAddItem  of hoCombo sText iCount
95644>                    Set ComItemData  of hoCombo iCount to  eTheme
95645>                End_Procedure
95646>
95646>                Procedure FillComboList Handle hoCombo
95649>                    Send ComClear     of hoCombo
95650>                    Send AddTheme hoCombo "xtpThemeOffice2013Word" xtpThemeOffice2013Word
95651>                    Send AddTheme hoCombo "xtpThemeOffice2013Outlook" xtpThemeOffice2013Outlook
95652>                    Send AddTheme hoCombo "xtpThemeOffice2013Excel" xtpThemeOffice2013Excel
95653>                    Send AddTheme hoCombo "xtpThemeOffice2013PowerPoint" xtpThemeOffice2013PowerPoint
95654>                    Send AddTheme hoCombo "xtpThemeOffice2013Publisher" xtpThemeOffice2013Publisher
95655>                    Send AddTheme hoCombo "xtpThemeOffice2013OneNote" xtpThemeOffice2013OneNote
95656>                    Send AddTheme hoCombo "xtpThemeOffice2013Access" xtpThemeOffice2013Access
95657>                    Send AddTheme hoCombo "xtpThemeOffice2003" xtpThemeOffice2003
95658>                    Send AddTheme hoCombo "xtpThemeOffice2000" xtpThemeOffice2000
95659>                    Send AddTheme hoCombo "xtpThemeOfficeXP" xtpThemeOfficeXP
95660>
95660>                    Send AddTheme hoCombo "xtpThemeOffice2010Blue" xtpThemeOffice2010Blue
95661>                    Send AddTheme hoCombo "xtpThemeOffice2010Black" xtpThemeOffice2010Black
95662>                    Send AddTheme hoCombo "xtpThemeOffice2010Silver" xtpThemeOffice2010Silver
95663>
95663>                    Send AddTheme hoCombo "xtpThemeOffice2007Aqua" xtpThemeOffice2007Aqua
95664>                    Send AddTheme hoCombo "xtpThemeOffice2007Black" xtpThemeOffice2007Black
95665>                    Send AddTheme hoCombo "xtpThemeOffice2007Blue" xtpThemeOffice2007Blue
95666>                    Send AddTheme hoCombo "xtpThemeOffice2007Silver" xtpThemeOffice2007Silver
95667>
95667>                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Blue" xtpThemeVisualStudio2015Blue
95668>                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Light" xtpThemeVisualStudio2015Light
95669>                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Dark" xtpThemeVisualStudio2015Dark
95670>
95670>                    Send AddTheme hoCombo "xtpThemeVisualStudio2012Light" xtpThemeVisualStudio2012Light
95671>                    Send AddTheme hoCombo "xtpThemeVisualStudio2012Dark" xtpThemeVisualStudio2012Dark
95672>
95672>                    Send AddTheme hoCombo "xtpThemeVisualStudio2008" xtpThemeVisualStudio2008
95673>                    Send AddTheme hoCombo "xtpThemeVisualStudio6" xtpThemeVisualStudio6
95674>
95674>                    Send AddTheme hoCombo "xtpThemeWindows7" xtpThemeWindows7
95675>
95675>                    Send AddTheme hoCombo "xtpThemeWhidbey" xtpThemeWhidbey
95676>
95676>                    Send AddTheme hoCombo "xtpThemeNativeWinXP" xtpThemeNativeWinXP
95677>                End_Procedure
95678>
95678>                Function CurrentTheme Handle vCommandBarControl Returns Integer
95681>                    Handle hMessage hoCombo
95681>                    Integer iIndex
95681>                    // create and bind  proxy control
95681>                    Get CreateProxyControl vCommandBarControl to hoCombo
95682>                    // get the current selection
95682>                    Get ComListIndex of hoCombo to iIndex
95683>                    // note the index selections are 1 based
95683>                    If (iIndex > 0) Begin
95685>                        // get the ItemData for the selected item and send that message
95685>                        Get ComItemData of hoCombo iIndex to hMessage
95686>                        Function_Return hMessage
95687>                    End
95687>                    // dispose of the proxy control
95687>                    Send Destroy of hoCombo
95688>                    Function_Return 0
95689>                End_Function
95690>
95690>                Procedure OnExecute Variant vCommandBarControl
95693>                    Integer eTheme
95693>                    Integer iColor
95693>                    Get CurrentTheme vCommandBarControl to eTheme
95694>                    Set peVisualTheme of ghoCommandBars to eTheme
95695>                    Send ComRecalcLayout of ghoCommandBars
95696>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
95697>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
95699>                End_Procedure
95700>
95700>                Procedure SetTheTheme Integer eTheme
95703>                    Integer iColor
95703>                    Set peVisualTheme of ghoCommandBars to eTheme
95704>                    Send ComRecalcLayout of ghoCommandBars
95705>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
95706>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
95708>                End_Procedure
95709>
95709>                Function ConvertSystemColor Integer iColor Returns Integer
95712>                    Integer iSysColor
95712>                    If (iColor = clDefault or iColor = clNone) Begin    // If default color then use -1
95714>                        Move clNone to iColor
95715>                    End
95715>                    Else If (iColor < 0) Begin    // If it is a system color (<0) then convert this into an RGB value
95718>                        Move (iColor iand |CI$7FFFFFFF) to iSysColor    // extract the system color constant
95719>                        Move (GetSysColor(iSysColor)) to iColor
95720>                    End
95720>                    Function_Return iColor
95721>                End_Function
95722>
95722>            End_Object
95723>
95723>//            Object oSkin_tb is a cCJMenuItem
95723>//                Set peControlType to xtpControlLabel
95723>//                Set psCaption to "Skin:"
95723>//                Set pbControlBeginGroup to True
95723>//            End_Object
95723>//
95723>//            Object oSkinSelector_cf is a cSkinComboBoxCJMenuItem
95723>//                Set psToolTip to "Select a skin to change the appearance of the application. Either select a Theme OR a Skin, not both."
95723>//            End_Object
95723>//
95723>//            #IF (!@ >= 190)
95723>//            #ENDIF
95723>
95723>            Object oAbout_MenuItem is a cCJMenuItem
95725>                Set psCaption to "About"
95726>                Set psToolTip to "About Info"
95727>                Set psDescription to "About the program"
95728>                Set psImage to "ActionAbout1.ico"
95729>                Set pbControlBeginGroup to True
95730>                Procedure OnExecute Variant vCommandBarControl
95733>                    Forward Send OnExecute vCommandBarControl
95735>                    Send Activate_About of (Client_Id(ghoCommandBars))
95736>                End_Procedure
95737>            End_Object
95738>
95738>            Object oHelpMenuItem is a cCJHelpMenuItem
95740>                Set peControlType to xtpControlSplitButtonPopup
95741>                Set psImage to "ActionHelp1.ico"
95742>
95742>                Procedure OnExecute Variant vCommandBarControl
95745>                    Forward Send OnExecute vCommandBarControl
95747>                    Set psHelpFile of ghoApplication to "DataFlex.chm"
95748>                    Send ShowProgramHelp
95749>                End_Procedure
95750>
95750>                Object oHelpMenuItemLocal is a cCJMenuItem
95752>                    Set psCaption to "Local HTML Help"
95753>                    Set psImage to "ActionHelp1.ico"
95754>                    Procedure OnExecute Variant vCommandBarControl
95757>                        Set psHelpFile of ghoApplication to "DataFlex.chm"
95758>                        Send ShowProgramHelp
95759>                    End_Procedure
95760>                End_Object
95761>
95761>                Object oHelpMenuItemInternetBrowser is a cCJMenuItem
95763>                    Set psCaption to "Internet Online HTML Help"
95764>                    Set psImage to "ActionHelp1.ico"
95765>                    Procedure OnExecute Variant vCommandBarControl
95768>                        Send vShellExecute "open" "http://www.rdctools.com/HTMLHelp/Developer5.htm" "" ""
95769>                    End_Procedure
95770>
95770>                End_Object
95771>            End_Object
95772>
95772>            Object oExitMenuItem is a cCJExitMenuItem
95774>                Set psImage to "ActionExit1.ico"
95775>                Set psToolTip to "Exit application"
95776>                Set psDescription to "Exit the program (Alt+F4)"
95777>                Set pbControlBeginGroup to True
95778>            End_Object
95779>        End_Object
95780>
95780>//        Object oSpacerBar is a cCJToolbar
95780>//            Set pbDockNextTo to False
95780>//            Set pbShowExpandButton to False
95780>//            Set pbGripper to False
95780>//            Set peStretched to stStretch
95780>//            Set pbCustomizable to False
95780>//            Set pbCloseable to False
95780>//            Set pbEnableDocking to False
95780>//            Set pbHideWrap to True
95780>//
95780>//            Object oFiller is a cCJMenuItem
95780>//            End_Object
95780>//
95780>//        End_Object
95780>
95780>        Object oStatusBar is a cCJStatusBar
95782>
95782>            Object oStatusPane1 is a cCJStatusBarPane
95784>                Set piID to sbpIDIdlePane
95785>                Set pbStyleStretch to True
95786>            End_Object
95787>            Object oStatusPane2 is a cCJStatusBarPane
95789>                Set phoViewPane to Self
95790>                Set pbStyleStretch to True
95791>            End_Object
95792>
95792>        End_Object
95793>
95793>    End_Object
95794>
95794>    Object oClientArea is a ClientArea
95796>
95796>//        Use Dd_debug.dg // This Provides access to dd debugger by pressing ctrl+d within any view. Good for debugging
95796>
95796>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\StdAbout.pkg)
95796>>>//************************************************************************
95796>>>// Confidential Trade Secret.
95796>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
95796>>>// as an unpublished work.  All rights reserved.
95796>>>// DataFlex is a registered trademark of Data Access Corporation.
95796>>>//
95796>>>//************************************************************************
95796>>>//************************************************************************
95796>>>//
95796>>>// $File name  : StdAbout.pkg
95796>>>// $File title : Standard about object package for VDF
95796>>>// Notice      :
95796>>>// $Author(s)  : John Tuohy
95796>>>//
95796>>>// $Rev History
95796>>>//
95796>>>// JT 06/27/97   File created
95796>>>//************************************************************************
95796>>>
95796>>>// This provides a quick and simple way to create an about package for a program.
95796>>>// You need to create a message inside you client area called Activate_About.
95796>>>// Within this message you should send the message DoAbout passing needed
95796>>>// string information.
95796>>>//
95796>>>//       Procedure Activate_About
95796>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
95796>>>//       End_Procedure
95796>>>//    where: sTitle =     Name of application. If none provided, uses caption
95796>>>//                        bar title
95796>>>//           sVersion   = Version Line. If none provided, will be blank
95796>>>//           sCopyRight = Copyright Line. If none provided, will be blank
95796>>>//           sAuthor    = Author name, blank if none provided
95796>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
95796>>>//                        is used.
95796>>>// It is expected that you will place this in your own object package. For
95796>>>// example an order about package may look like this:
95796>>>//
95796>>>//   // OrderAbout.pkg
95796>>>//   Use StdAbout.pkg
95796>>>//   Procedure Activate_About
95796>>>//      String sTitle sCopyright sVersion sAuthor
95796>>>//      Move "My Order Entry System" to sTitle
95796>>>//      Move "Version 2.1" to sVersion
95796>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
95796>>>//      Move "John Smith"  to sAuthor
95796>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
95796>>>//   end_procedure
95796>>>//   // end of file.
95796>>>
95796>>>Use DfAbout.pkg
95796>>>
95796>>>// *************************************************************************
95796>>>//  Public message. This is the default message. It is expected that you will
95796>>>//   create your own message to override this
95796>>>// *************************************************************************
95796>>>
95796>>>Procedure Activate_About
95799>>>    Send DoAbout "" "" "" "" "" "" "" "" "" ""
95800>>>End_Procedure
95801>>>
95801>>>// *************************************************************************
95801>>>//  Public message. It is expected that you will send this message (most
95801>>>//  likely from Activate_About. This creates an about object, activates it
95801>>>//  and destroys it when done. It is not exepected that you will augment this.
95801>>>// *************************************************************************
95801>>>// Sample usage:
95801>>>//   The first two params will automatically be filled from the application settings if not provided.
95801>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
95801>>>
95801>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;    String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
95804>>>    Integer hoObj hoMain iArgs
95804>>>    String sValue
95804>>>
95804>>>    // Create object
95804>>>    Object About is an AboutDialog
95806>>>    // Uncomment these two lines if you would like to have a resizable About object.
95806>>>    //            Set Border_Style to Border_Thick
95806>>>    //            Set peAnchors to anAll
95806>>>
95806>>>    // Add checking for the number of arguments passed to avoid runtime errors
95806>>>    // if one of them is not passed. This makes the interface
95806>>>    // more flexible.
95806>>>        Move num_arguments to iArgs
95807>>>
95807>>>        // If no title is passed use the label of the main panel (if a main panel exists).
95807>>>        If (iArgs > 0 and sTitle = "") Begin
95809>>>            Get Main_Window of Desktop to hoMain
95810>>>            If hoMain Begin
95812>>>                Get Label of hoMain to sValue
95813>>>            End
95813>>>>
95813>>>        End
95813>>>>
95813>>>        Else If (iArgs > 0 and sTitle <> "") Begin
95816>>>            Move sTitle to sValue
95817>>>        End
95817>>>>
95817>>>        Else If (iArgs = 0) Begin
95820>>>            Get Main_Window of Desktop to hoMain
95821>>>            If hoMain Begin
95823>>>                Get Label of hoMain to sValue
95824>>>            End
95824>>>>
95824>>>        End
95824>>>>
95824>>>
95824>>>        If (sValue <> "") Begin
95826>>>            Send Add_LineLn sValue
95827>>>        End
95827>>>>
95827>>>        Move "" to sValue
95828>>>
95828>>>        // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
95828>>>        // For this to work the Project Properties Version must have been set in the Studio.
95828>>>        If (iArgs < 2) Begin
95830>>>            Move "" to sValue
95831>>>        End
95831>>>>
95831>>>        Else Begin
95832>>>            Move sVersion to sValue
95833>>>        End
95833>>>>
95833>>>        Set Version to sValue
95834>>>
95834>>>        If (iArgs > 2 and sCopyRight <> "") Begin
95836>>>            Send Add_LineLn sCopyRight
95837>>>        End
95837>>>>
95837>>>
95837>>>        // If only the five "standard" params were passed we don't add an extra linefeed;
95837>>>        // else we do.
95837>>>        If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
95839>>>            Send Add_Line sAuthor
95840>>>        End
95840>>>>
95840>>>        Else If (iArgs > 5 and sAuthor <> "") Begin
95843>>>            Send Add_LineLn sAuthor
95844>>>        End
95844>>>>
95844>>>
95844>>>        // Square bitmaps of 80x80 works best
95844>>>        If (iArgs > 4 and sBitmap <> "") Begin
95846>>>            Set Logo to sBitMap
95847>>>        End
95847>>>>
95847>>>
95847>>>        // Here starts handling of the five optional params:
95847>>>        If (iArgs = 6 and sParam6  <> "") Begin
95849>>>            Send Add_Line sParam6
95850>>>        End
95850>>>>
95850>>>        Else If (iArgs > 6 and sParam6  <> "") Begin
95853>>>            Send Add_LineLn sParam6
95854>>>        End
95854>>>>
95854>>>
95854>>>        If (iArgs = 7 and sParam7  <> "") Begin
95856>>>            Send Add_Line sParam7
95857>>>        End
95857>>>>
95857>>>        Else If (iArgs > 7 and sParam7  <> "") Begin
95860>>>            Send Add_LineLn sParam7
95861>>>        End
95861>>>>
95861>>>
95861>>>        If (iArgs = 8 and sParam8  <> "") Begin
95863>>>            Send Add_Line sParam8
95864>>>        End
95864>>>>
95864>>>        Else If (iArgs > 8 and sParam8  <> "") Begin
95867>>>            Send Add_LineLn sParam8
95868>>>        End
95868>>>>
95868>>>
95868>>>        If (iArgs = 9 and sParam9  <> "") Begin
95870>>>            Send Add_Line sParam9
95871>>>        End
95871>>>>
95871>>>        Else If (iArgs > 9 and sParam9  <> "") Begin
95874>>>            Send Add_LineLn sParam9
95875>>>        End
95875>>>>
95875>>>
95875>>>        If (iArgs = 10 and sParam10 <> "") Begin
95877>>>            Send Add_Line sParam10
95878>>>        End
95878>>>>
95878>>>
95878>>>        Move Self to hoObj
95879>>>    End_Object
95880>>>
95880>>>    Send Popup   of hoObj // Popup the about object
95881>>>    Send Destroy of hoObj // When done, it will be destroyed
95882>>>End_Procedure
95883>        Use DatabaseSelection.dg
Including file: DatabaseSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DatabaseSelection.dg)
95883>>>Use Windows.pkg
95883>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJGridPromptList.pkg)
95883>>>>>Use Windows.pkg
95883>>>>>Use cCJGrid.pkg
95883>>>>>
95883>>>>>
95883>>>>>
95883>>>>>Class cCJGridPromptList is a cCJGrid
95884>>>>>    
95884>>>>>    Procedure Construct_Object
95886>>>>>        Forward Send Construct_Object
95888>>>>>        
95888>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
95889>>>>>        Property Boolean Private_pbAutoOrdering True
95890>>>>>        Property Boolean pbAutoSearch True  // pops up search window
95891>>>>>        Property Integer peUpdateMode umPromptValue
95892>>>>>        Property Integer piUpdateColumn 0
95893>>>>>        Property Integer piInitialColumn -1
95894>>>>>        Property String  psSeedValue ''
95895>>>>>        Property Handle phmPromptUpdateCallback 0
95896>>>>>        Property Integer phoInvokingObject
95897>>>>>        
95897>>>>>        Property Boolean pbStoredAutoSeed
95898>>>>>        Property Boolean pbStoredAutoOrdering
95899>>>>>        Property Boolean pbStoredAutoSearch
95900>>>>>        Property Integer peStoredUpdateMode
95901>>>>>        Property Integer piStoredUpdateColumn
95902>>>>>        Property Integer piStoredInitialColumn
95903>>>>>        Property Handle  phmStoredPromptUpdateCallback
95904>>>>>        Property Boolean pbStoredSelectionEnable
95905>>>>>        Property Boolean pbStoredMultipleSelection
95906>>>>>        
95906>>>>>        // internally set by list
95906>>>>>        // these must be set upon closing the list and can be used for manual list updates
95906>>>>>        Property Boolean pbCanceled
95907>>>>>        Property Integer[] pSelectedRows
95908>>>>>        
95908>>>>>        Property Boolean pbNeedsNewOrdering
95909>>>>>        Property Boolean pbRequestSearch
95910>>>>>        Property tGridKeyPair[] pSearchKeys
95911>>>>>        
95911>>>>>        // these properties makes a prompt list a prompt list
95911>>>>>        // and should not be changed.
95911>>>>>        Set pbEditOnKeyNavigation to False
95912>>>>>        Set pbEditOnClick to False
95913>>>>>        Set pbReadOnly to True
95914>>>>>        Set pbFocusSubItems to True
95915>>>>>        
95915>>>>>        // these could maybe be changed
95915>>>>>        Set pbShadeSortColumn to True
95916>>>>>        Set pbHeaderReorders to True
95917>>>>>        Set pbHeaderTogglesDirection to True
95918>>>>>        Set pbHeaderSelectsColumn to True
95919>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
95920>>>>>        Set piFocusCellBackColor to clNone
95921>>>>>        Set piFocusCellForeColor to clNone
95922>>>>>        Set piFocusCellRectangleColor to clBlack
95923>>>>>        Set pbUseFocusCellRectangle to False
95924>>>>>        Set pbSelectionEnable to True
95925>>>>>        
95925>>>>>        On_Key kEnter Send Ok
95926>>>>>        On_Key kCancel Send Cancel
95927>>>>>        
95927>>>>>    End_Procedure
95928>>>>>    
95928>>>>>    // reorder list automatically on column change
95928>>>>>    // this also set pbFocusSubItems which is required to make the two states work
95928>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
95930>>>>>        Set Private_pbAutoOrdering to bAutoOrder
95931>>>>>        Set pbFocusSubItems to bAutoOrder
95932>>>>>    End_Procedure
95933>>>>>    
95933>>>>>    Function pbAutoOrdering Returns Boolean
95935>>>>>        Boolean bAutoOrder
95935>>>>>        Get Private_pbAutoOrdering to bAutoOrder
95936>>>>>        Function_Return bAutoOrder
95937>>>>>    End_Function
95938>>>>>    
95938>>>>>    // augmented to handle auto-ordering and invoking the search popup list
95938>>>>>    Procedure OnIdle
95940>>>>>        Boolean bNeedsReorder bSearch bOldToggle
95940>>>>>        Handle hoCol
95940>>>>>        Integer iKy1 iKy2 iCol
95940>>>>>        
95940>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
95941>>>>>        If bNeedsReorder Begin
95943>>>>>            Get SelectedColumn to iCol
95944>>>>>            If (iCol<>-1) Begin
95946>>>>>                
95946>>>>>                Get pbHeaderTogglesDirection to bOldToggle
95947>>>>>                Set pbHeaderTogglesDirection to False
95948>>>>>                Send HeaderReorder iCol
95949>>>>>                Set pbHeaderTogglesDirection to bOldToggle
95950>>>>>                
95950>>>>>                Set pbNeedsNewOrdering to False
95951>>>>>            End
95951>>>>>>
95951>>>>>        End
95951>>>>>>
95951>>>>>        
95951>>>>>        Get pbRequestSearch to bSearch
95952>>>>>        If bSearch Begin
95954>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
95955>>>>>        End
95955>>>>>>
95955>>>>>        
95955>>>>>        Forward Send OnIdle
95957>>>>>    End_Procedure
95958>>>>>    
95958>>>>>    Procedure OnStoreDefaults
95960>>>>>        Integer iVal
95960>>>>>        Boolean bVal
95960>>>>>        
95960>>>>>        Get pbAutoSeed to bVal
95961>>>>>        Set pbStoredAutoSeed to bVal
95962>>>>>        
95962>>>>>        Get pbAutoOrdering to bVal
95963>>>>>        Set pbStoredAutoOrdering to bVal
95964>>>>>        
95964>>>>>        Get pbAutoSearch to bVal
95965>>>>>        Set pbStoredAutoSearch to bVal
95966>>>>>        
95966>>>>>        Get peUpdateMode to iVal
95967>>>>>        Set peStoredUpdateMode to iVal
95968>>>>>        
95968>>>>>        Get piUpdateColumn to iVal
95969>>>>>        Set piStoredUpdateColumn to iVal
95970>>>>>        
95970>>>>>        Get piInitialColumn to iVal
95971>>>>>        Set piStoredInitialColumn to iVal
95972>>>>>        
95972>>>>>        Get phmPromptUpdateCallback to iVal
95973>>>>>        Set phmStoredPromptUpdateCallback to iVal
95974>>>>>        
95974>>>>>        Get pbSelectionEnable to bVal
95975>>>>>        Set pbStoredSelectionEnable to bVal
95976>>>>>        
95976>>>>>        Get pbMultipleSelection to bVal
95977>>>>>        Set pbStoredMultipleSelection to bVal
95978>>>>>        
95978>>>>>    End_Procedure
95979>>>>>    
95979>>>>>    Procedure OnRestoreDefaults
95981>>>>>        Integer iVal
95981>>>>>        Boolean bVal
95981>>>>>        
95981>>>>>        Get pbStoredAutoSeed to bVal
95982>>>>>        Set pbAutoSeed to bVal
95983>>>>>        
95983>>>>>        Get pbStoredAutoOrdering to bVal
95984>>>>>        Set pbAutoOrdering to bVal
95985>>>>>        
95985>>>>>        Get pbStoredAutoSearch to bVal
95986>>>>>        Set pbAutoSearch to bVal
95987>>>>>        
95987>>>>>        Get peStoredUpdateMode to iVal
95988>>>>>        Set peUpdateMode to iVal
95989>>>>>        
95989>>>>>        Get piStoredInitialColumn to iVal
95990>>>>>        Set piInitialColumn to iVal
95991>>>>>        
95991>>>>>        Get phmStoredPromptUpdateCallback to iVal
95992>>>>>        Set phmPromptUpdateCallback to iVal
95993>>>>>        
95993>>>>>        Get pbStoredSelectionEnable to bVal
95994>>>>>        Set pbSelectionEnable to bVal
95995>>>>>        
95995>>>>>        Get pbStoredMultipleSelection to bVal
95996>>>>>        Set pbMultipleSelection to bVal
95997>>>>>        
95997>>>>>    End_Procedure
95998>>>>>    
95998>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
95998>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
95998>>>>>    // Suitable for augmentation
95998>>>>>    Procedure OnSeedData
96000>>>>>        Integer iUpdateColumn iSortColumn
96000>>>>>        Boolean bSeed bAuto
96000>>>>>        String sValue
96000>>>>>        Handle hoCol
96000>>>>>        
96000>>>>>        Get piUpdateColumn to iUpdateColumn
96001>>>>>        Get psSeedValue to sValue
96002>>>>>        Get pbAutoSeed to bSeed
96003>>>>>        Get piSortColumn to iSortColumn
96004>>>>>        Get pbAutoOrdering to bAuto
96005>>>>>        // if not yet sorted and this is auto ordering we will
96005>>>>>        // sort the data for the search column. We do this to make the
96005>>>>>        // column search GE logic work properly.
96005>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
96007>>>>>            Get ColumnObject iUpdateColumn to hoCol
96008>>>>>            Send SortGridByColumn hoCol False
96009>>>>>        End
96009>>>>>>
96009>>>>>        
96009>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
96011>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0
96012>>>>>        End
96012>>>>>>
96012>>>>>        Else Begin
96013>>>>>            Send MovetoFirstRow
96014>>>>>        End
96014>>>>>>
96014>>>>>        
96014>>>>>    End_Procedure
96015>>>>>    
96015>>>>>    Procedure OnMoveValueOutByValue
96017>>>>>        String sValue
96017>>>>>        Handle hoInvokingObject hoCol  hoDataSource
96017>>>>>        Integer iRow iCol
96017>>>>>        Integer[] SelRowsIndexes
96018>>>>>        
96018>>>>>        Get phoInvokingObject to hoInvokingObject
96019>>>>>        Get pSelectedRows to SelRowsIndexes
96020>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
96022>>>>>            Get piUpdateColumn to iCol
96023>>>>>            Get ColumnObject iCol to hoCol
96024>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
96025>>>>>            Set Value of hoInvokingObject to sValue
96026>>>>>            Set Item_Changed_State of hoInvokingObject to True
96027>>>>>        End
96027>>>>>>
96027>>>>>    End_Procedure
96028>>>>>    
96028>>>>>    Procedure OnMoveValueOutByCustom
96030>>>>>    End_Procedure
96031>>>>>    
96031>>>>>    // augment to popup a search window when allowed
96031>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
96033>>>>>        Boolean bSubFocus bAutoSearch bChar
96033>>>>>        Integer iVal
96033>>>>>        
96033>>>>>        Get pbFocusSubItems to bSubFocus
96034>>>>>        Get pbAutoSearch to bAutoSearch
96035>>>>>        Forward Send OnComKeyDown llKeyCode llShift
96037>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
96039>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
96041>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
96042>>>>>                Move (iVal<>0) to bChar
96043>>>>>            End
96043>>>>>>
96043>>>>>            If bChar Begin
96045>>>>>                // this can get called multiple times before a search dialog pops up
96045>>>>>                Send AddToSearchKeys llKeyCode llShift
96046>>>>>            End
96046>>>>>>
96046>>>>>        End
96046>>>>>>
96046>>>>>    End_Procedure
96047>>>>>    
96047>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
96049>>>>>        Boolean bAutoSearch
96049>>>>>        Integer iKeyCode iShiftCode
96049>>>>>        Get pbAutoSearch to bAutoSearch
96050>>>>>        If bAutoSearch Begin
96052>>>>>            // this can get called multiple times before a search dialog pops up
96052>>>>>            Get piLastKey to iKeyCode
96053>>>>>            Get piLastKey2 to iShiftCode
96054>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
96055>>>>>        End
96055>>>>>>
96055>>>>>        Move True to llCancel
96056>>>>>    End_Procedure
96057>>>>>    
96057>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
96059>>>>>        Send ClearSearchRequest // kill any deferred search popup
96060>>>>>        Forward Send OnComRowDblClick llRow llItem
96062>>>>>    End_Procedure
96063>>>>>    
96063>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
96065>>>>>        Send Ok
96066>>>>>    End_Procedure
96067>>>>>    
96067>>>>>    
96067>>>>>    // we don't want a menu for prompt lists
96067>>>>>    Function CreateContextMenu Returns Handle
96069>>>>>        Function_Return 0
96070>>>>>    End_Function
96071>>>>>    
96071>>>>>    // if we use auto-ordering, change the order when the column changes
96071>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
96073>>>>>        Boolean bAutoOrder
96073>>>>>        Forward Send ColumnChanged iOld iNew
96075>>>>>        Get pbAutoOrdering to bAutoOrder
96076>>>>>        If bAutoOrder Begin
96078>>>>>            // will be reordered in idle event
96078>>>>>            Set pbNeedsNewOrdering to True
96079>>>>>        End
96079>>>>>>
96079>>>>>    End_Procedure
96080>>>>>    
96080>>>>>    
96080>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
96082>>>>>        Integer eMode
96082>>>>>        Integer[] SelRowsIndexes
96083>>>>>        Set pbCanceled to True // assume cancel unless changed
96084>>>>>        Set pSelectedRows to SelRowsIndexes // empty
96085>>>>>        Get peUpdateMode to eMode
96086>>>>>        If (eMode<>umPromptNonInvoking) Begin
96088>>>>>            Send OnStoreDefaults
96089>>>>>        End
96089>>>>>>
96089>>>>>        Send InitializePromptList
96090>>>>>        Forward Send Add_Focus hoParent
96092>>>>>        Send LoadData
96093>>>>>        Set psSeedValue to ""
96094>>>>>    End_Procedure
96095>>>>>    
96095>>>>>    // called before the list is activated.
96095>>>>>    Procedure InitializePromptList
96097>>>>>        Integer hoInvokingObject
96097>>>>>        Boolean bAutoColumn bAutoSeed
96097>>>>>        Integer i iOldMode eUpdateMode
96097>>>>>        String sValue
96097>>>>>        
96097>>>>>        Get peUpdateMode to eUpdateMode
96098>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
96100>>>>>            Get Focus of Desktop to hoInvokingObject
96101>>>>>            If (hoInvokingObject<=Desktop) Begin
96103>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
96104>>>>>>
96104>>>>>                Procedure_Return
96105>>>>>            End
96105>>>>>>
96105>>>>>            
96105>>>>>            Set phoInvokingObject to hoInvokingObject
96106>>>>>            
96106>>>>>            Send Prompt_Callback to hoInvokingObject Self
96107>>>>>            Get peUpdateMode to eUpdateMode
96108>>>>>        End
96108>>>>>>
96108>>>>>        
96108>>>>>        Send ClearSearchRequest // clear the search keys
96109>>>>>        Set pbNeedsNewOrdering to False
96110>>>>>        
96110>>>>>        Get pbAutoSeed to bAutoSeed
96111>>>>>        
96111>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
96113>>>>>            Get Value of hoInvokingObject to sValue
96114>>>>>            Set psSeedValue to sValue
96115>>>>>        End
96115>>>>>>
96115>>>>>        
96115>>>>>    End_Procedure
96116>>>>>    
96116>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
96116>>>>>    Procedure LoadData
96118>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
96118>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
96118>>>>>        Integer eUpdateMode
96118>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder
96118>>>>>        
96118>>>>>        Get phoDataSource to hoDataSource
96119>>>>>        Get peUpdateMode to eUpdateMode
96120>>>>>        Get phoInvokingObject to hoInvokingObject
96121>>>>>        Get pbAutoSeed to bAutoSeed
96122>>>>>        Get piInitialColumn to iInitialColumn
96123>>>>>        Get piUpdateColumn to iUpdateColumn
96124>>>>>        Get RowCount of hoDataSource to iRows
96125>>>>>        
96125>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
96125>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
96125>>>>>        If (iInitialColumn=-1) Begin
96127>>>>>            Move iUpdateColumn to iInitialColumn
96128>>>>>        End
96128>>>>>>
96128>>>>>        If (iInitialColumn>=0) Begin
96130>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
96131>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
96132>>>>>        End
96132>>>>>>
96132>>>>>        Send OnSeedData // find a good starting place for the row
96133>>>>>        Get pbFocusSubItems to bSubFocus
96134>>>>>        If bSubFocus Begin
96136>>>>>            // if column focus, which is normal, go to initialcolumn
96136>>>>>            If hoInitialColumn Begin
96138>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
96139>>>>>            End
96139>>>>>>
96139>>>>>            Else Begin
96140>>>>>                Send MoveToFirstEnterableColumn
96141>>>>>            End
96141>>>>>>
96141>>>>>        End
96141>>>>>>
96141>>>>>        
96141>>>>>    End_Procedure
96142>>>>>    
96142>>>>>    // This is only called in a successful close
96142>>>>>    Procedure ClosePromptList
96144>>>>>        Handle hoDataSource hoInvokingObject
96144>>>>>        Handle hmCallBack
96144>>>>>        Integer iRow eUpdateMode
96144>>>>>        Integer[] SelRowsIndexes
96145>>>>>        
96145>>>>>        Get phoDataSource to hoDataSource
96146>>>>>        Get phoInvokingObject to hoInvokingObject
96147>>>>>        
96147>>>>>        If (pbMultipleSelection(Self)) Begin
96149>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
96150>>>>>        End
96150>>>>>>
96150>>>>>        Else Begin
96151>>>>>            Get SelectedRow of hoDataSource to iRow
96152>>>>>            If (iRow<>-1) Begin
96154>>>>>                Move iRow to SelRowsIndexes[0]
96155>>>>>            End
96155>>>>>>
96155>>>>>        End
96155>>>>>>
96155>>>>>        
96155>>>>>        Set pbCanceled to False
96156>>>>>        Set pSelectedRows to SelRowsIndexes
96157>>>>>        
96157>>>>>        Get peUpdateMode to eUpdateMode
96158>>>>>        // if non-invoking there is by definition, no move value out
96158>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
96160>>>>>            
96160>>>>>            If (eUpdateMode=umPromptValue) Begin
96162>>>>>                Send OnMoveValueOutByValue
96163>>>>>            End
96163>>>>>>
96163>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
96166>>>>>                Send OnMoveValueOutByCustom
96167>>>>>            End
96167>>>>>>
96167>>>>>            Get phmPromptUpdateCallback to hmCallBack
96168>>>>>            If hmCallBack Begin
96170>>>>>                Send hmCallBack of hoInvokingObject Self
96171>>>>>            End
96171>>>>>>
96171>>>>>        End
96171>>>>>>
96171>>>>>        
96171>>>>>        Send Close_Panel
96172>>>>>    End_Procedure
96173>>>>>    
96173>>>>>    // augment to send OnRestoreDefaults.
96173>>>>>    Procedure Release_Focus
96175>>>>>        Integer eUpdateMode
96175>>>>>        Get peUpdateMode to eUpdateMode
96176>>>>>        Forward Send Release_Focus
96178>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
96180>>>>>            Send OnRestoreDefaults
96181>>>>>        End
96181>>>>>>
96181>>>>>    End_Procedure
96182>>>>>    
96182>>>>>    Function SelectedRowIds Returns RowID[]
96184>>>>>        RowID[] SelectedRowids
96185>>>>>        Integer[] SelectedRows
96186>>>>>        Integer i iRows
96186>>>>>        Handle hoDataSource
96186>>>>>        Get phoDataSource to hoDataSource
96187>>>>>        Get pSelectedRows to SelectedRows
96188>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
96189>>>>>        For i from 0 to (iRows-1)
96195>>>>>>
96195>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
96196>>>>>        Loop
96197>>>>>>
96197>>>>>        Function_Return SelectedRowids
96198>>>>>    End_Function
96199>>>>>    
96199>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
96201>>>>>        String[] SelectedValues
96202>>>>>        Integer[] SelectedRows
96203>>>>>        Integer i iRows
96203>>>>>        Handle hoCol
96203>>>>>        Get ColumnObject iCol to hoCol
96204>>>>>        Get pSelectedRows to SelectedRows
96205>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
96206>>>>>        For i from 0 to (iRows-1)
96212>>>>>>
96212>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
96213>>>>>        Loop
96214>>>>>>
96214>>>>>        Function_Return SelectedValues
96215>>>>>    End_Function
96216>>>>>    
96216>>>>>    Procedure Ok Returns Integer
96218>>>>>        Send ClosePromptList
96219>>>>>    End_Procedure
96220>>>>>    
96220>>>>>    Procedure Cancel Returns Integer
96222>>>>>        Send Close_Panel
96223>>>>>    End_Procedure
96224>>>>>    
96224>>>>>    Procedure Search
96226>>>>>        Send Activate // give focus back to list so focus things are correct
96227>>>>>        Send Request_Search 0 0
96228>>>>>    End_Procedure
96229>>>>>    
96229>>>>>    // do a search using the current keys in the search key buffer for the sort column.
96229>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
96229>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
96229>>>>>    Procedure Request_SearchEx
96231>>>>>        tGridKeyPair[] Keys
96231>>>>>        tGridKeyPair[] Keys
96232>>>>>        Integer iCol
96232>>>>>        Handle hoCol hoSearchDialog
96232>>>>>        Boolean bOk
96232>>>>>        String sValue
96232>>>>>        
96232>>>>>        Get piSortColumn to iCol
96233>>>>>        If (iCol<>-1) Begin
96235>>>>>            Get ColumnObject iCol to hoCol
96236>>>>>            Get pSearchKeys to Keys
96237>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
96238>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
96239>>>>>            If bOk Begin
96241>>>>>                Send RequestFindColumnValue iCol sValue True 0
96242>>>>>            End
96242>>>>>>
96242>>>>>            Send Destroy of hoSearchDialog
96243>>>>>        End
96243>>>>>>
96243>>>>>        Send ClearSearchRequest // clear the search keys
96244>>>>>    End_Procedure
96245>>>>>    
96245>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
96245>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
96247>>>>>        tGridKeyPair[] Keys
96247>>>>>        tGridKeyPair[] Keys
96248>>>>>        tGridKeyPair KeyPair
96248>>>>>        tGridKeyPair KeyPair
96248>>>>>        Set pbRequestSearch to True
96249>>>>>        Move iKeyCode to KeyPair.KeyCode
96250>>>>>        Move iShiftCode to KeyPair.ShiftCode
96251>>>>>        Get pSearchKeys to Keys
96252>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
96253>>>>>        Set pSearchKeys to Keys
96254>>>>>    End_Procedure
96255>>>>>    
96255>>>>>    Procedure ClearSearchRequest
96257>>>>>        tGridKeyPair[] SearchKeys
96257>>>>>        tGridKeyPair[] SearchKeys
96258>>>>>        Set pSearchKeys to SearchKeys
96259>>>>>        Set pbRequestSearch to False
96260>>>>>    End_Procedure
96261>>>>>    
96261>>>>>End_Class
96262>>>>>
96262>>>Use cDbUpdateFunctionLibrary.pkg
96262>>>Use MSSqldrv.pkg
96262>>>Use db2_drv.pkg
96262>>>Use odbc_drv.pkg
96262>>>Use cRDCModalPanel.pkg
Including file: cRDCModalPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\cRDCModalPanel.pkg)
96262>>>>>//****************************************************************************
96262>>>>>// $Module type: Class
96262>>>>>// $Module name: cRDCModalPanel
96262>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
96262>>>>>// Created     : 2014-03-17 @ 12:33
96262>>>>>//
96262>>>>>// Description :
96262>>>>>//
96262>>>>>// $Rev History:
96262>>>>>//    2014-03-17  Module header created
96262>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
96262>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
96262>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
96262>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
96262>>>>>// in the help folder for more details.
96262>>>>>//
96262>>>>>//****************************************************************************
96262>>>>>Use Windows.pkg
96262>>>>>Use cCJCommandBarSystem.pkg   
96262>>>>>Use cCJSkinFramework.pkg
96262>>>>>
96262>>>>>Class cRDCModalPanel is a ModalPanel
96263>>>>>
96263>>>>>    Procedure Construct_Object
96265>>>>>        Forward Send Construct_Object
96267>>>>>
96267>>>>>        Set Maximize_Icon to True
96268>>>>>        Set Minimize_Icon to False
96269>>>>>        Set Border_Style to Border_Thick
96270>>>>>        Set Locate_Mode to Center_On_Parent
96271>>>>>
96271>>>>>        Property String Private_Icon
96272>>>>>        Property Handle phoDialogCommandbar
96273>>>>>    End_Procedure
96274>>>>>
96274>>>>>    Procedure Set Icon String sIcon
96276>>>>>        Forward Set Icon to sIcon
96278>>>>>        Set Private_Icon to sIcon
96279>>>>>    End_Procedure
96280>>>>>
96280>>>>>    Function Icon Returns String
96282>>>>>        String sIcon
96282>>>>>        Get Private_Icon to sIcon
96283>>>>>        Function_Return sIcon
96284>>>>>    End_Function
96285>>>>>
96285>>>>>    Procedure Page Integer iPageObject
96287>>>>>        String sIcon
96287>>>>>        Integer hWnd
96287>>>>>        
96287>>>>>        Forward Send Page iPageObject
96289>>>>>        Get Private_Icon to sIcon
96290>>>>>        If (sIcon <> "") Begin
96292>>>>>            Set Icon to sIcon
96293>>>>>        End
96293>>>>>>
96293>>>>>
96293>>>>>        Get Window_Handle to hWnd
96294>>>>>
96294>>>>>        If ((ghoSkinFramework <> 0) and (hWnd <> 0)) Begin
96296>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
96297>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
96298>>>>>        End
96298>>>>>>
96298>>>>>    End_Procedure
96299>>>>>
96299>>>>>    // Put a status bar at the bottom of the panel, which makes
96299>>>>>    // status_help work and puts a gripper in the lower right corner.
96299>>>>>    Procedure End_Construct_Object
96301>>>>>        Integer iStyle iSize iOffset
96301>>>>>
96301>>>>>        Forward Send End_Construct_Object
96303>>>>>
96303>>>>>        Get Border_Style to iStyle
96304>>>>>        Move 8 to iOffset
96305>>>>>        If (iStyle = Border_Thick) Begin
96307>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
96309>>>>>                Object oStatusBar is a cCJStatusBar
96311>>>>>                    Set phoDialogCommandbar to Self
96312>>>>>                    Object oStatusIdle is a cCJStatusBarPane
96314>>>>>                        Set piId to sbpIDIdlePane
96315>>>>>                        Set pbStyleStretch to True
96316>>>>>                    End_Object
96317>>>>>                End_Object
96318>>>>>            End_Object
96319>>>>>            Get Size to iSize
96320>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
96321>>>>>            Set piMinSize to (Hi(iSize) + iOffset) (Low(iSize))
96322>>>>>        End
96322>>>>>>
96322>>>>>
96322>>>>>    End_Procedure
96323>>>>>
96323>>>>>    Procedure Popup
96325>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
96326>>>>>        Forward Send Popup
96328>>>>>    End_Procedure
96329>>>>>
96329>>>>>End_Class
96330>>>
96330>>>Object oDatabaseSelection_sl is a cRDCModalPanel
96332>>>    Set Label to "SQL Database Selection"
96333>>>    Set Size to 119 183
96334>>>    Set piMinSize to 89 170
96335>>>    Set Location to 2 2
96336>>>    Set Border_Style to Border_Thick
96337>>>    Set Icon to "DatabaseLookup1.ico"
96338>>>
96338>>>    Property String[] psTheData
96340>>>
96340>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
96342>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
96344>>>        End_Object
96345>>>    End
96345>>>>
96345>>>
96345>>>    Object oSelList is a cCJGridPromptList
96347>>>        Set Size to 89 167
96348>>>        Set Location to 6 6
96349>>>        Set peAnchors to anAll
96350>>>        Set pbAllowColumnRemove to False
96351>>>        Set pbUseAlternateRowBackgroundColor to True
96352>>>        Set pbGrayIfDisable to False
96353>>>        Set pbHeaderReorders to False
96354>>>        Set pbHeaderSelectsColumn to False
96355>>>        Set pbHeaderTogglesDirection to False
96356>>>        Set pbShadeSortColumn to False
96357>>>        Set piFocusCellBackColor to clDkGray
96358>>>
96358>>>        Object oName is a cCJGridColumn
96360>>>            Set piWidth to 334
96361>>>            Set psCaption to "Database Name"
96362>>>        End_Object
96363>>>
96363>>>        Procedure Activating
96366>>>            tDataSourceRow[] MyData
96366>>>            tDataSourceRow[] MyData
96367>>>            Handle hoDataSource
96367>>>            String[] sTheData
96368>>>            Integer iCount iSize
96368>>>
96368>>>            Send Cursor_Wait of Cursor_Control
96369>>>            Forward Send Activating
96371>>>
96371>>>            Get psTheData to sTheData
96372>>>            Move (SizeOfArray(sTheData)) to iSize
96373>>>            Decrement iSize
96374>>>            For iCount from 0 to iSize
96380>>>>
96380>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
96381>>>            Loop
96382>>>>
96382>>>
96382>>>            Get phoDataSource to hoDataSource
96383>>>            Send InitializeData of hoDataSource MyData
96384>>>            Send Cursor_Ready of Cursor_Control
96385>>>        End_Procedure
96386>>>
96386>>>    End_Object
96387>>>
96387>>>    Object oOK_Btn is a Button
96389>>>        Set Size to 14 50
96390>>>        Set Label    to "&OK"
96391>>>        Set Location to 98 68
96392>>>        Set peAnchors To anBottomRight
96393>>>
96393>>>        Procedure OnClick
96396>>>            Send Ok of oSelList
96397>>>        End_Procedure
96398>>>
96398>>>    End_Object
96399>>>
96399>>>    Object oCancel_Btn is a Button
96401>>>        Set Size to 14 50
96402>>>        Set Label    to "&Cancel"
96403>>>        Set Location to 98 123
96404>>>        Set peAnchors to anBottomRight
96405>>>
96405>>>        Procedure OnClick
96408>>>            Send Close_Panel
96409>>>        End_Procedure
96410>>>
96410>>>    End_Object
96411>>>
96411>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96412>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96413>>>End_Object
96414>        Use SQLDatabaseBackup.dg
Including file: SQLDatabaseBackup.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLDatabaseBackup.dg)
96414>>>// Note: At the bottom of this package there's a general purpose access method for this dialog.
96414>>>Use Windows.pkg
96414>>>Use vWin32fh.pkg
96414>>>
96414>>>Object oSQLDatabaseBackup_dg is a ModalPanel
96416>>>    Set Size to 104 298
96417>>>    Set Label to "SQL Database Backup"
96418>>>    Set piMinSize to 89 211
96419>>>    Set Location to 2 4
96420>>>    Set Border_Style To Border_Thick
96421>>>
96421>>>    Property Boolean pbOK False
96423>>>    Property String  psDatabase
96425>>>    Property String  psPath
96427>>>    Property String  psBackupName
96429>>>
96429>>>    Object oDatabase_fm is a Form
96431>>>        Set Size to 13 204
96432>>>        Set Location to 14 71
96433>>>        Set Label_Justification_Mode to JMode_Right
96434>>>        Set Label_Col_Offset to 2
96435>>>        Set Label to "Database Name"
96436>>>        Set Enabled_State to False
96437>>>        Set peAnchors to anTopLeftRight
96438>>>
96438>>>        Procedure Page Integer iPageObject
96441>>>            String sValue
96441>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sValue
96442>>>            Set Value to sValue
96443>>>            Set psDatabase to sValue
96444>>>            Forward Send Page iPageObject
96446>>>        End_Procedure
96447>>>
96447>>>    End_Object
96448>>>
96448>>>    Object oBackupName_fm is a Form
96450>>>        Set Size to 13 204
96451>>>        Set Location to 29 71
96452>>>        Set Label_Justification_Mode to JMode_Right
96453>>>        Set Label_Col_Offset to 2
96454>>>        Set Label to "Backup Name"
96455>>>        Set peAnchors to anTopLeftRight
96456>>>
96456>>>        Procedure Page Integer iPageObject
96459>>>            String sValue
96459>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sValue
96460>>>            Set Value to sValue
96461>>>            Forward Send Page iPageObject
96463>>>        End_Procedure
96464>>>
96464>>>        Procedure OnChange
96467>>>            String sValue
96467>>>            Get Value to sValue
96468>>>            Set psBackupName to sValue
96469>>>        End_Procedure
96470>>>
96470>>>    End_Object
96471>>>
96471>>>    Object oUseDefaultBackupFolder_cb is a CheckBox
96473>>>        Set Size to 10 50
96474>>>        Set Location to 50 71
96475>>>        Set Label to "Use Default SQL Backup Folder"
96476>>>        Set Checked_State to True
96477>>>
96477>>>        Procedure OnChange
96480>>>            Boolean bChecked
96480>>>            Get Checked_State to bChecked
96481>>>            Set Enabled_State of oPath_fm to (bChecked = False)
96482>>>        End_Procedure
96483>>>
96483>>>    End_Object
96484>>>
96484>>>    Object oPath_fm is a Form
96486>>>        Set Size to 13 204
96487>>>        Set Location to 62 71
96488>>>        Set Label_Justification_Mode to JMode_Right
96489>>>        Set Label_Col_Offset to 2
96490>>>        Set Label to "Path"
96491>>>        Set Prompt_Button_Mode to PB_PromptOn
96492>>>        Set peAnchors to anTopLeftRight
96493>>>        Set Enabled_State to False
96494>>>
96494>>>        Procedure Page Integer iPageObject
96497>>>            String sValue
96497>>>            Get psDataPathFirstPart of ghoDbUpdateFunctionLibrary to sValue
96498>>>            Get vFolderFormat sValue to sValue
96499>>>            Move (sValue + "Backup") to sValue
96500>>>            Set Value to sValue
96501>>>            Forward Send Page iPageObject
96503>>>        End_Procedure
96504>>>
96504>>>        Procedure Prompt
96507>>>            String sPath sFileMask sRetval
96507>>>
96507>>>            Get Value to sPath
96508>>>            Move "Database Backup files (*.bak)|*.bak" to sFileMask
96509>>>            Get vSelect_File sFileMask "Please select a .bak file" sPath to sRetval
96510>>>            If (sRetval <> "") Begin
96512>>>                Get ParseFolderName sRetval to sPath
96513>>>                If (Right(sPath, 1) ="\") Begin
96515>>>                    Move (Left(sPath, Length(sPath) -1)) to sPath
96516>>>                End
96516>>>>
96516>>>                Set Value to sPath
96517>>>            End
96517>>>>
96517>>>        End_Procedure
96518>>>
96518>>>        Procedure OnChange
96521>>>            String sValue
96521>>>            Get Value to sValue
96522>>>            Set psPath to sValue
96523>>>        End_Procedure
96524>>>
96524>>>    End_Object
96525>>>
96525>>>    Object oOK_Btn is a Button
96527>>>        Set Label    to "&OK"
96528>>>        Set Location to 81 169
96529>>>        Set peAnchors to anBottomRight
96530>>>
96530>>>        Procedure OnClick
96533>>>            Set pbOK to True
96534>>>            Send Close_Panel
96535>>>        End_Procedure
96536>>>
96536>>>    End_Object
96537>>>
96537>>>    Object oCancel_Btn is a Button
96539>>>        Set Label    to "&Cancel"
96540>>>        Set Location to 81 224
96541>>>        Set peAnchors to anBottomRight
96542>>>
96542>>>        Procedure OnClick
96545>>>            Set pbOK to False
96546>>>            Send Close_Panel
96547>>>        End_Procedure
96548>>>
96548>>>    End_Object
96549>>>
96549>>>    Object oButton1 is a Button
96551>>>        Set Size to 14 96
96552>>>        Set Location to 80 32
96553>>>        Set Label to "Enum table types"
96554>>>
96554>>>        Procedure OnClick
96557>>>            String sDriverID
96557>>>            tSQLConnection SQLConnection
96557>>>            tSQLConnection SQLConnection
96557>>>            Get pSQLConnection of ghoDbUpdateFunctionLibrary to SQLConnection
96558>>>            Send ShowAllTablesAndColumns SQLConnection.sDriverID SQLConnection.sConnectionString
96559>>>        End_Procedure
96560>>>
96560>>>        Procedure ShowAllTablesAndColumns String sDriver String sLogin
96563>>>            Handle hoCLIHandler
96563>>>            Integer iNumTables iTableCount
96563>>>
96563>>>            Get Create U_cCLIHandler to hoCLIhandler
96564>>>            If (hoCLIHandler > 0) Begin
96566>>>                Set psDriverID of hoCLIHandler to sDriver
96567>>>                Get EnumerateTables of hoCLIHandler sLogin to iNumTables
96568>>>                For iTableCount from 1 to iNumTables
96574>>>>
96574>>>                    Show (TableName(hoCLIHandler, iTableCount)) "; "
96576>>>                    Show (SchemaName(hoCLIHandler, iTableCount)) "; "
96578>>>                    Show (TableType(hoCLIHandler, iTableCount)) "; "
96580>>>                    Showln (TableComment(hoCLIHandler, iTableCount))
96582>>>//                    Get EnumerateColumns of hoCLIHandler sLogin (TableName(hoCLIHandler, iTableCount)) to iNumColumns
96582>>>//                    For iColumnCount from 1 to iNumColumns
96582>>>//                        Showln " " (ColumnName(hoCLIHandler, iColumnCount))
96582>>>//                    Loop
96582>>>                    Showln
96583>>>                Loop
96584>>>>
96584>>>                Send Destroy of hoCLIHandler
96585>>>            End
96585>>>>
96585>>>        End_Procedure
96586>>>
96586>>>    End_Object
96587>>>
96587>>>    Procedure Page Integer iPageObject
96590>>>        Set Icon to "DbBackup1.ico"
96591>>>        Forward Send Page iPageObject
96593>>>    End_Procedure
96594>>>
96594>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96595>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96596>>>
96596>>>End_Object
96597>>>
96597>>>// *** General purpose access method for this dialog ***
96597>>>Function MakeSQLDatabaseBackup Returns Boolean
96600>>>    Handle ho
96600>>>    Boolean bOK bDefault
96600>>>    String sDatabase sPath sBackupName
96600>>>
96600>>>    Move (oSQLDatabaseBackup_dg(Self)) to ho
96601>>>    Set pbOK of ho to False
96602>>>    Send Popup of ho
96603>>>
96603>>>    Get pbOk of ho to bOK
96604>>>    If (bOK = True) Begin
96606>>>        Get Value of (oDatabase_fm(ho))   to sDatabase
96607>>>        Get Value of (oBackupName_fm(ho)) to sBackupName
96608>>>        Get Checked_State of (oUseDefaultBackupFolder_cb(ho)) to bDefault
96609>>>        If (bDefault = False) Begin
96611>>>            Get Value of (oPath_fm(ho)) to sPath
96612>>>        End
96612>>>>
96612>>>        Get SqlDatabaseBackupToDisk of ghoDbUpdateFunctionLibrary sDatabase sBackupName sPath True to bOK
96613>>>    End
96613>>>>
96613>>>
96613>>>    Function_Return bOK
96614>>>End_Function
96615>        Use SQLConnections.vw
Including file: SQLConnections.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLConnections.vw)
96615>>>Use Windows.pkg
96615>>>Use DFClient.pkg
96615>>>Use cDbScrollingContainer.pkg
Including file: cDbScrollingContainer.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cDbScrollingContainer.pkg)
96615>>>>>// Provides support for db aware scrolling containers.
96615>>>>>// Scrolling containers is provided by creating two objects,
96615>>>>>// a host (dbScrollingContainer) and a scrolling clientarea (dbScrollingClientArea)
96615>>>>>// The host has no public interface, you just drop the object. It should have only one child object
96615>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
96615>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
96615>>>>>
96615>>>>>Use DFClient.pkg
96615>>>>>Use cScrollingContainerMixin.pkg
Including file: cScrollingContainerMixin.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cScrollingContainerMixin.pkg)
96615>>>>>>>// Mixin classes for scrolling container support:
96615>>>>>>>// cScrollingContainerMixin & cScrollingClientAreaMixin
96615>>>>>>>// These are used by cSrollingContainer / cScrollingClientArea and
96615>>>>>>>// dbScrollingContainer / dbScrollingClientArea.
96615>>>>>>>// The scrolling container has no public interface, you just drop the object. It should have only one child object
96615>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
96615>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
96615>>>>>>>
96615>>>>>>>Use Windows.pkg
96615>>>>>>>Use Winuser.pkg
96615>>>>>>>Use tWinStructs.pkg
96615>>>>>>>
96615>>>>>>>Register_Function pbTabbedWorkspaces Returns Boolean
96615>>>>>>>Register_Function pbCenterTabbedViews Returns Boolean
96615>>>>>>>// support for the scrolling client area mixin object.
96615>>>>>>>
96615>>>>>>>Class cScrollingClientAreaMixin is a Mixin
96616>>>>>>>    
96616>>>>>>>    Procedure Define_cScrollingClientAreaMixin
96618>>>>>>>        
96618>>>>>>>        Set pbSizeToClientArea to False // should already be set to this, but just in case.
96619>>>>>>>        Set Border_Style to Border_None
96620>>>>>>>        
96620>>>>>>>        Property Boolean pbAutoScroll True
96621>>>>>>>        Property Boolean pbAutoScrollFocus True
96622>>>>>>>        Property Integer piAutoScrollMarginX 5
96623>>>>>>>        Property Integer piAutoScrollMarginY 5
96624>>>>>>>        Property Integer piAutoScrollMinX 0
96625>>>>>>>        Property Integer piAutoScrollMinY 0
96626>>>>>>>        Property Boolean pbShowDisabledScrollBar False
96627>>>>>>>        
96627>>>>>>>        
96627>>>>>>>        Property Integer piLineScrollUnit  5 // minimum scrolling unit for line up/down and mouse wheel
96628>>>>>>>        Property Integer piMinimumHeight 0 // the minimum height that doesn't need scrolling
96629>>>>>>>        Property Integer piMinimumWidth 0 //(the minimum width that doesn't need scrolling
96630>>>>>>>        // keeps track of scrolling
96630>>>>>>>        Property Integer piCurrentVertScrolled 0
96631>>>>>>>        Property Integer piCurrentHorzScrolled 0
96632>>>>>>>        Property Integer piWheelDelta 0               // internal, accumulates mouse wheel clicks
96633>>>>>>>        Delegate Set phoScrollingClientArea to Self
96635>>>>>>>        
96635>>>>>>>        // set this true to make this a tabbed workspace view (design time)
96635>>>>>>>        Property Boolean pbTabWorkspaceView False
96636>>>>>>>        // set this false to stop auto-determination of pbTabWorkspaceView (design time)
96636>>>>>>>        Property Boolean pbAutoSetTabWorkspaceView True
96637>>>>>>>    End_Procedure
96638>>>>>>>    
96638>>>>>>>    // low level event sent from windows.
96638>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
96640>>>>>>>        Integer iWheelDelta iKeys iDelta iClicks
96640>>>>>>>        Move (low(abs(wParam))) to iKeys           // any keys down when pressed
96641>>>>>>>        Move (hi(abs(wParam))) to iDelta           // number of click units
96642>>>>>>>        If (wParam<0) Begin
96644>>>>>>>            Move (-iDelta) to iDelta     // can be up or down
96645>>>>>>>        End
96645>>>>>>>>
96645>>>>>>>        Get  piWheelDelta to iWheelDelta           // Current accumulated micro clicks
96646>>>>>>>        Move (iWheelDelta+iDelta) to iWheelDelta
96647>>>>>>>        // C_WHEELDATA is 120 as defined by MS as the delta to react to. Once click is usually 120
96647>>>>>>>        Move (iWheelDelta/C_WHEELDELTA) to iClicks // Number of clicks to react to
96648>>>>>>>        Set  piWheelDelta to (mod(iWheelDelta,C_WHEELDELTA)) // remainder unused microclicks
96649>>>>>>>        // If we have enough Clicks send OnMouseWheel
96649>>>>>>>        If (iClicks<>0) Begin
96651>>>>>>>            Send OnMouseWheel iClicks iKeys
96652>>>>>>>        End
96652>>>>>>>>
96652>>>>>>>        // tell windows that we've handled the event.
96652>>>>>>>        Set Windows_Override_State to True
96653>>>>>>>    End_Procedure
96654>>>>>>>    
96654>>>>>>>    
96654>>>>>>>    // should be sent by DF message OnWMMouseWheel , which is sent by WM_MOUSEWHEEL
96654>>>>>>>    Procedure OnMouseWheel Integer iClicks Integer iKey
96656>>>>>>>        Integer iLineScrollUnit
96656>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96657>>>>>>>        Send VScroll (-iClicks*iLineScrollUnit*2) // (If(iClicks>0,False,True)) (abs(iClicks))
96658>>>>>>>    End_Procedure
96659>>>>>>>    
96659>>>>>>>    // should be sent by WM_VSCROLL
96659>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
96661>>>>>>>        Boolean bOk
96661>>>>>>>        tWinScrollInfo ScrollInfo
96661>>>>>>>        tWinScrollInfo ScrollInfo
96661>>>>>>>        Integer iLineScrollUnit
96661>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96662>>>>>>>        Get GetScrollBarInfo True (&ScrollInfo) to bOk
96663>>>>>>>        If bOk Begin
96665>>>>>>>            
96665>>>>>>>            Case Begin
96665>>>>>>>                Case (iType=SB_PAGEDOWN)
96667>>>>>>>                    Send VScroll ScrollInfo.nPage
96668>>>>>>>                    Case Break
96669>>>>>>>                
96669>>>>>>>                Case (iType=SB_PAGEUP)
96672>>>>>>>                    Send VScroll (-Integer(ScrollInfo.nPage))
96673>>>>>>>                    Case Break
96674>>>>>>>                
96674>>>>>>>                Case (iType=SB_LINEDOWN)
96677>>>>>>>                    Send VScroll iLineScrollUnit
96678>>>>>>>                    Case Break
96679>>>>>>>                
96679>>>>>>>                Case (iType=SB_LINEUP)
96682>>>>>>>                    Send VScroll (-iLineScrollUnit)
96683>>>>>>>                    Case Break
96684>>>>>>>                
96684>>>>>>>                Case (iType=SB_BOTTOM)
96687>>>>>>>                    Send VScroll (ScrollInfo.nMax-ScrollInfo.nPos)
96688>>>>>>>                    Case Break
96689>>>>>>>                
96689>>>>>>>                Case (iType=SB_Top)
96692>>>>>>>                    Send VScroll (-ScrollInfo.nPos)
96693>>>>>>>                    Case Break
96694>>>>>>>                
96694>>>>>>>                Case (iType=SB_THUMBPOSITION)
96697>>>>>>>                    Case Break
96698>>>>>>>                
96698>>>>>>>                Case (iType=SB_THUMBTRACK)
96701>>>>>>>                    Send VScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
96702>>>>>>>                    Case Break
96703>>>>>>>            Case End
96703>>>>>>>        End
96703>>>>>>>>
96703>>>>>>>    End_Procedure
96704>>>>>>>    
96704>>>>>>>    // should be sent by WM_HSCROLL
96704>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
96706>>>>>>>        Boolean bOk
96706>>>>>>>        tWinScrollInfo ScrollInfo
96706>>>>>>>        tWinScrollInfo ScrollInfo
96706>>>>>>>        Integer iLineScrollUnit
96706>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96707>>>>>>>        Get GetScrollBarInfo False (&ScrollInfo) to bOk
96708>>>>>>>        If bOk Begin
96710>>>>>>>            
96710>>>>>>>            Case Begin
96710>>>>>>>                Case (iType=SB_PAGEDOWN)
96712>>>>>>>                    Send hScroll ScrollInfo.nPage
96713>>>>>>>                    Case Break
96714>>>>>>>                
96714>>>>>>>                Case (iType=SB_PAGEUP)
96717>>>>>>>                    Send hScroll (-Integer(ScrollInfo.nPage))
96718>>>>>>>                    Case Break
96719>>>>>>>                
96719>>>>>>>                Case (iType=SB_LINEDOWN)
96722>>>>>>>                    Send hScroll iLineScrollUnit
96723>>>>>>>                    Case Break
96724>>>>>>>                
96724>>>>>>>                Case (iType=SB_LINEUP)
96727>>>>>>>                    Send hScroll (-iLineScrollUnit)
96728>>>>>>>                    Case Break
96729>>>>>>>                
96729>>>>>>>                Case (iType=SB_BOTTOM)
96732>>>>>>>                    Send hScroll (ScrollInfo.nMax-ScrollInfo.nPos)
96733>>>>>>>                    Case Break
96734>>>>>>>                
96734>>>>>>>                Case (iType=SB_Top)
96737>>>>>>>                    Send hScroll (-ScrollInfo.nPos)
96738>>>>>>>                    Case Break
96739>>>>>>>                
96739>>>>>>>                Case (iType=SB_THUMBPOSITION)
96742>>>>>>>                    Case Break
96743>>>>>>>                
96743>>>>>>>                Case (iType=SB_THUMBTRACK)
96746>>>>>>>                    Send hScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
96747>>>>>>>                    Case Break
96748>>>>>>>            Case End
96748>>>>>>>        End
96748>>>>>>>>
96748>>>>>>>    End_Procedure
96749>>>>>>>    
96749>>>>>>>    
96749>>>>>>>    // this calls SetScrollInfo with proper info
96749>>>>>>>    Procedure SetScrollBarInfo Boolean bVert Integer iRangeMin Integer iRangeMax Integer iPageSize
96751>>>>>>>        tWinScrollInfo ScrollInfo
96751>>>>>>>        tWinScrollInfo ScrollInfo
96751>>>>>>>        Integer iVoid
96751>>>>>>>        Handle hWnd
96751>>>>>>>        Boolean bShow
96751>>>>>>>        
96751>>>>>>>        Delegate Get Window_Handle to hWnd
96753>>>>>>>        If (hWnd <> 0) Begin
96755>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
96756>>>>>>>            
96756>>>>>>>            Move (SIF_RANGE ior SIF_POS ior SIF_PAGE ) to ScrollInfo.fMask
96757>>>>>>>            Get pbShowDisabledScrollBar to bShow
96758>>>>>>>            If bShow Begin
96760>>>>>>>                Move (ScrollInfo.fMask ior SIF_DISABLENOSCROLL) to ScrollInfo.fMask
96761>>>>>>>            End
96761>>>>>>>>
96761>>>>>>>            Move iRangeMin to ScrollInfo.nMin
96762>>>>>>>            Move iRangeMax to ScrollInfo.nMax
96763>>>>>>>            Move iPageSize to ScrollInfo.nPage
96764>>>>>>>            Move 0 to ScrollInfo.nPos
96765>>>>>>>            Move (SetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo), True)) to iVoid
96766>>>>>>>            
96766>>>>>>>        End
96766>>>>>>>>
96766>>>>>>>    End_Procedure
96767>>>>>>>    
96767>>>>>>>    // this wraps GetScrollInfo
96767>>>>>>>    Function GetScrollBarInfo Boolean bVert tWinScrollInfo ByRef ScrollInfo Returns Boolean
96769>>>>>>>        Boolean bOk
96769>>>>>>>        Handle hWnd
96769>>>>>>>        
96769>>>>>>>        Delegate Get Window_Handle to hWnd
96771>>>>>>>        If (hWnd <> 0) Begin
96773>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
96774>>>>>>>            Move (SIF_ALL) to ScrollInfo.fMask
96775>>>>>>>            Move (GetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo))) to bOk
96776>>>>>>>        End
96776>>>>>>>>
96776>>>>>>>        Function_Return bOk
96777>>>>>>>    End_Function
96778>>>>>>>    
96778>>>>>>>    // this wraps SetScrollPos
96778>>>>>>>    Procedure SetScrollBarPosInfo Boolean bVert Integer iPos
96780>>>>>>>        Integer iVoid
96780>>>>>>>        Handle hWnd
96780>>>>>>>        
96780>>>>>>>        Delegate Get Window_Handle to hWnd
96782>>>>>>>        If (hWnd <> 0) Begin
96784>>>>>>>            Move (SetScrollPos(hWnd, If(bVert,SB_VERT,SB_HORZ), iPos, True)) to iVoid
96785>>>>>>>        End
96785>>>>>>>>
96785>>>>>>>    End_Procedure
96786>>>>>>>    
96786>>>>>>>    // scrolling containers don't do anhcors. However, this gets called every time the parent's
96786>>>>>>>    // guiSize changes. We can use that to scroll or resize the scrolling client as needed.
96786>>>>>>>    Procedure DoapplyAnchors Integer Arg1 Integer Arg2
96788>>>>>>>        Send ScrollClientArea
96789>>>>>>>    End_Procedure
96790>>>>>>>    
96790>>>>>>>    // augment to handle the scrolling area initialization.
96790>>>>>>>    Procedure Add_Focus Handle hoParent
96792>>>>>>>        Forward Send Add_Focus hoParent
96794>>>>>>>        // at this the scrolling container and client area should both be paged.
96794>>>>>>>        // child objects ae also paged with initial anchors applied
96794>>>>>>>        Send CalculateAutoScrollMinimums
96795>>>>>>>    End_Procedure
96796>>>>>>>    
96796>>>>>>>    Procedure Page Integer iPage
96798>>>>>>>        Forward Send Page iPage
96800>>>>>>>        If iPage Begin
96802>>>>>>>            // at this the scrolling container and client area should both be paged
96802>>>>>>>            // but the child controls are not paged. We don't want scrollbars when
96802>>>>>>>            // the child items are paged (else they may get anchored oddly)
96802>>>>>>>            // Prior to 19.0 these were set in Add_focus which meant that the child objects were
96802>>>>>>>            // already paged with scrollbars present. This would result in scrollbars appearing
96802>>>>>>>            // before they were really needed. This should be more accurate
96802>>>>>>>            Send SetScrollBarInfo True 0 0 0
96803>>>>>>>            Send SetScrollBarInfo False 0 0 0
96804>>>>>>>        End
96804>>>>>>>>
96804>>>>>>>    End_Procedure
96805>>>>>>>    
96805>>>>>>>    // determine scrolling minimums and set the client area as required.
96805>>>>>>>    
96805>>>>>>>    Procedure CalculateAutoScrollMinimums
96807>>>>>>>        Integer iMinX iMinY iSiz iLoc iMargin
96807>>>>>>>        Integer iAutoMinX iAutoMinY
96807>>>>>>>        Boolean bAutoScroll
96807>>>>>>>        Handle hoNext hoFirst
96807>>>>>>>        
96807>>>>>>>        Get pbAutoScroll to bAutoScroll
96808>>>>>>>        Get piAutoScrollMinX to iAutoMinX
96809>>>>>>>        Get piAutoScrollMinY to iAutoMinY
96810>>>>>>>        Get DialogToGui iAutoMinY iAutoMinX to iSiz
96811>>>>>>>        Move (Hi(iSiz)) to iAutoMinY
96812>>>>>>>        Move (Low(iSiz)) to iAutoMinX
96813>>>>>>>        Set piMinimumHeight to iAutoMinY
96814>>>>>>>        Set piMinimumWidth to iAutoMinX
96815>>>>>>>        
96815>>>>>>>        If (bAutoScroll and (iAutoMinX=0 or iAutoMinY=0)) Begin
96817>>>>>>>            
96817>>>>>>>            Get Next_Level to hoFirst
96818>>>>>>>            Move hoFirst to hoNext
96819>>>>>>>            If (hoFirst) Begin
96821>>>>>>>                Repeat
96821>>>>>>>>
96821>>>>>>>                    Get GuiWindowSize of hoNext to iSiz
96822>>>>>>>                    Get GuiLocation of hoNext to iLoc
96823>>>>>>>                    Move (Hi(iLoc)+Hi(iSiz) max iMinY) to iMinY
96824>>>>>>>                    Move (Low(iLoc)+Low(iSiz) max iMinX) to iMinx
96825>>>>>>>                    Get Next_Focus of hoNext to hoNext
96826>>>>>>>                Until (hoNext=0 or hoNext=hoFirst)
96828>>>>>>>                
96828>>>>>>>                If (iAutoMinY=0) Begin
96830>>>>>>>                    Get piAutoScrollMarginY to iMargin
96831>>>>>>>                    Set piMinimumHeight to (iMinY+iMargin)
96832>>>>>>>                End
96832>>>>>>>>
96832>>>>>>>                
96832>>>>>>>                If (iAutoMinX=0) Begin
96834>>>>>>>                    Get piAutoScrollMarginX to iMargin
96835>>>>>>>                    Set piMinimumWidth to (iMinX+iMargin)
96836>>>>>>>                    
96836>>>>>>>                End
96836>>>>>>>>
96836>>>>>>>            End
96836>>>>>>>>
96836>>>>>>>        End
96836>>>>>>>>
96836>>>>>>>        
96836>>>>>>>        // before setting the client area, unset all anchors so DoApplyAnchors will not do anything
96836>>>>>>>        Broadcast Set pbAnchorCreated to False
96838>>>>>>>        Send ScrollClientArea
96839>>>>>>>        // after the scroll set up, reinitialize all anchors.
96839>>>>>>>        Broadcast Send DoCreateAnchors
96841>>>>>>>    End_Procedure
96842>>>>>>>    
96842>>>>>>>    // Scroll the client area and adjust the client area size as needed. This does all the
96842>>>>>>>    // work of scrolling.
96842>>>>>>>    
96842>>>>>>>    Procedure ScrollClientArea
96844>>>>>>>        Integer iSiz
96844>>>>>>>        Integer iHeight iHCur iHCuriDelta iOrig iRange bOk
96844>>>>>>>        Integer iWidth iWCur iWDelta iWOrig
96844>>>>>>>        Integer iSzY iSzX iLocX iLocY
96844>>>>>>>        
96844>>>>>>>        Delegate Get GuiClientSize to iSiz
96846>>>>>>>        Move (Hi(iSiz)) to iHeight
96847>>>>>>>        Move (Low(iSiz)) to iWidth
96848>>>>>>>        
96848>>>>>>>        // Vertical scrolling
96848>>>>>>>        
96848>>>>>>>        Get piMinimumHeight to iOrig
96849>>>>>>>        Get piMinimumWidth to iWOrig
96850>>>>>>>        
96850>>>>>>>        If (iOrig<>0 or iWOrig<>0) Begin
96852>>>>>>>            
96852>>>>>>>            If (iOrig<>0) Begin
96854>>>>>>>                Get piCurrentVertScrolled to iHCur
96855>>>>>>>                // If the size got bigger and we've scrolled, we want to scroll up
96855>>>>>>>                If (iHCur<>0 and (iHCur+iHeight>iOrig)) Begin
96857>>>>>>>                    Move (iOrig-iHeight max 0) to iHCur
96858>>>>>>>                    Set piCurrentVertScrolled to iHCur
96859>>>>>>>                End
96859>>>>>>>>
96859>>>>>>>                If (iHCur<>0 or iOrig>iHeight) Begin
96861>>>>>>>                    Send SetScrollBarInfo True 0 iOrig (iHeight min iOrig)
96862>>>>>>>                    Send SetScrollBarPosInfo True iHCur
96863>>>>>>>                End
96863>>>>>>>>
96863>>>>>>>                Else Begin
96864>>>>>>>                    Send SetScrollBarInfo True 0 0 0 //iOrig (iHeight min iOrig)
96865>>>>>>>                End
96865>>>>>>>>
96865>>>>>>>            End
96865>>>>>>>>
96865>>>>>>>            
96865>>>>>>>            // Horiz scrolling
96865>>>>>>>            
96865>>>>>>>            Get piCurrentHorzScrolled to iWCur
96866>>>>>>>            // If the size got bigger and we've scrolled, we want to scroll left
96866>>>>>>>            If (iWCur<>0 and (iWCur+iWidth>iWOrig)) Begin
96868>>>>>>>                Move (iWOrig-iWidth max 0) to iWCur
96869>>>>>>>                Set piCurrentHorzScrolled to iWCur
96870>>>>>>>            End
96870>>>>>>>>
96870>>>>>>>            If (iWCur<>0 or iWOrig>iWidth) Begin
96872>>>>>>>                Send SetScrollBarInfo False 0 iWOrig (iWidth min iWOrig)
96873>>>>>>>                Send SetScrollBarPosInfo False iWCur
96874>>>>>>>            End
96874>>>>>>>>
96874>>>>>>>            Else Begin
96875>>>>>>>                Send SetScrollBarInfo False 0 0 0
96876>>>>>>>            End
96876>>>>>>>>
96876>>>>>>>        End
96876>>>>>>>>
96876>>>>>>>        
96876>>>>>>>        // this could change depending on scrollbars appearing or not
96876>>>>>>>        Delegate Get GuiClientSize to iSiz
96878>>>>>>>        
96878>>>>>>>        // size of container is the the minimum allowed size (if scrolling is needed)
96878>>>>>>>        // or it is the actual size of the container (if scrolling not needed and it is bigger)
96878>>>>>>>        // This is required to make anchors work sensibly
96878>>>>>>>        Move (hi(iSiz) max iOrig) to iSzY
96879>>>>>>>        Move (low(iSiz) max iWOrig) to iSzX
96880>>>>>>>        Move (-iHCur) to iLocY
96881>>>>>>>        Move (-iWCur) to iLocX
96882>>>>>>>        
96882>>>>>>>        // Allow chance to make modifications
96882>>>>>>>        Send AdjustSizesLocs (&iSzY) (&iSzX) (&iLocY) (&iLocX)
96883>>>>>>>        
96883>>>>>>>        Set GuiSize to iSzY iSzX
96884>>>>>>>        // if we've scrolled, we need to reposition the container
96884>>>>>>>        Set GuiLocation to iLocY iLocX
96885>>>>>>>    End_Procedure
96886>>>>>>>    
96886>>>>>>>    // note that scrolling never changes the size of the scrolling client.
96886>>>>>>>    // this way, it does not interfere with anchors.
96886>>>>>>>    
96886>>>>>>>    Procedure VScroll Integer iDelta
96888>>>>>>>        Integer iHeight iCur iOrig iSiz
96888>>>>>>>        Delegate Get GuiClientSize to iSiz
96890>>>>>>>        Move (hi(iSiz)) to iHeight
96891>>>>>>>        Get piCurrentVertScrolled to iCur
96892>>>>>>>        Get piMinimumHeight to iOrig
96893>>>>>>>        If (iOrig=0 or  Hi(iSiz)>=iOrig) Begin
96895>>>>>>>            Procedure_Return
96896>>>>>>>        End
96896>>>>>>>>
96896>>>>>>>        // make sure delta is within range
96896>>>>>>>        If (iDelta+iCur<0) Begin
96898>>>>>>>            Move (-iCur) to iDelta
96899>>>>>>>        End
96899>>>>>>>>
96899>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
96902>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
96903>>>>>>>        End
96903>>>>>>>>
96903>>>>>>>        If (iDelta=0) ;            Procedure_Return
96906>>>>>>>        
96906>>>>>>>        Move (iCur + iDelta) to iCur
96907>>>>>>>        Set piCurrentVertScrolled to iCur
96908>>>>>>>        Send SetScrollBarPosInfo True iCur
96909>>>>>>>        Get GuiLocation to iSiz
96910>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Integer)-iDelta) (cast(low(iSiz),Integer))
96911>>>>>>>        Send ScrollClientArea
96912>>>>>>>    End_Procedure
96913>>>>>>>    
96913>>>>>>>    
96913>>>>>>>    Procedure HScroll Integer iDelta
96915>>>>>>>        Integer iHeight iCur iOrig iSiz
96915>>>>>>>        Delegate Get GuiClientSize to iSiz
96917>>>>>>>        Move (low(iSiz)) to iHeight
96918>>>>>>>        Get piCurrentHorzScrolled to iCur
96919>>>>>>>        Get piMinimumWidth to iOrig
96920>>>>>>>        If (iOrig=0 or  low(iSiz)>=iOrig) Begin
96922>>>>>>>            Procedure_Return
96923>>>>>>>        End
96923>>>>>>>>
96923>>>>>>>        If (iDelta+iCur<0) Begin
96925>>>>>>>            Move (-iCur) to iDelta
96926>>>>>>>        End
96926>>>>>>>>
96926>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
96929>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
96930>>>>>>>        End
96930>>>>>>>>
96930>>>>>>>        If (iDelta=0) ;            Procedure_Return
96933>>>>>>>        
96933>>>>>>>        Move (iCur + iDelta) to iCur
96934>>>>>>>        Set piCurrentHorzScrolled to iCur
96935>>>>>>>        Send SetScrollBarPosInfo False iCur
96936>>>>>>>        Get GuiLocation to iSiz
96937>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)) (cast(low(iSiz),Short) -iDelta)
96938>>>>>>>        Send ScrollClientArea
96939>>>>>>>    End_Procedure
96940>>>>>>>    
96940>>>>>>>    // make sure client is a 0,0
96940>>>>>>>    Procedure ScrollHome
96942>>>>>>>        Send SetVScrollbox SB_TOP 0
96943>>>>>>>        Send SetHScrollbox SB_TOP 0
96944>>>>>>>    End_Procedure
96945>>>>>>>    
96945>>>>>>>    // get relative GUI location of this object to the parent one passed.
96945>>>>>>>    Procedure LocationRelativeTo Handle hoContainer Handle hoControl Integer ByRef iLocY Integer ByRef iLocX
96947>>>>>>>        Integer ivoid
96947>>>>>>>        tWinRect Rect0 Rect1
96947>>>>>>>        tWinRect Rect0 Rect1
96947>>>>>>>        Move (GetWindowRect(window_handle(hoContainer),addressof(Rect0))) to ivoid
96948>>>>>>>        Move (GetWindowRect(window_handle(hoControl),addressof(Rect1))) to ivoid
96949>>>>>>>        Move ((Rect1.top) - (Rect0.top)) to iLocY
96950>>>>>>>        Move ((rect1.left) - (rect0.left)) to iLocX
96951>>>>>>>    End_Procedure
96952>>>>>>>    
96952>>>>>>>    // This scrolls this object into visual range.
96952>>>>>>>    Procedure ScrollObjectInRange Handle hoControl
96954>>>>>>>        Handle hoScrollingContainer
96954>>>>>>>        Integer iCurrentVertScrolled iCurrentHorzScrolled
96954>>>>>>>        Integer iViewHeight iViewWidth
96954>>>>>>>        Integer iRelLocHeight iRelLocWidth
96954>>>>>>>        Integer iSize iControlHeight iControlWidth
96954>>>>>>>        Integer iScroll
96954>>>>>>>        Integer iMarginX iMarginY
96954>>>>>>>        Integer iScrollingContainerWindowSize iScrollingContainerClientSize
96954>>>>>>>        
96954>>>>>>>        Get piAutoScrollMarginX to iMarginX
96955>>>>>>>        Get piAutoScrollMarginY to iMarginY
96956>>>>>>>        
96956>>>>>>>        // the scrolling container
96956>>>>>>>        Move Self to hoScrollingContainer
96957>>>>>>>        // the amount the SC is currently scrolled
96957>>>>>>>        Get piCurrentVertScrolled of hoScrollingContainer to iCurrentVertScrolled
96958>>>>>>>        Get piCurrentHorzScrolled of hoScrollingContainer to iCurrentHorzScrolled
96959>>>>>>>        
96959>>>>>>>        // size of view's client area (this is the viewport area)
96959>>>>>>>        Get GuiClientSize of (Parent(hoScrollingContainer)) to iSize
96960>>>>>>>        Move (hi(iSize)) to iViewHeight
96961>>>>>>>        Move (low(iSize)) to iViewWidth
96962>>>>>>>        
96962>>>>>>>        // get this object's location relative to the scrolling container
96962>>>>>>>        Send LocationRelativeTo hoScrollingContainer hoControl (&iRelLocHeight) (&iRelLocWidth)
96963>>>>>>>        
96963>>>>>>>        // we expect that the client size is the window size but just in case
96963>>>>>>>        Get GuiWindowSize of hoScrollingContainer to iScrollingContainerWindowSize
96964>>>>>>>        Get GuiClientSize of hoScrollingContainer to iScrollingContainerClientSize
96965>>>>>>>        Move (iRelLocHeight - (Hi(iScrollingContainerWindowSize)-Hi(iScrollingContainerClientSize))) to iRelLocHeight
96966>>>>>>>        Move (iRelLocWidth - (Low(iScrollingContainerWindowSize)-Low(iScrollingContainerClientSize))) to iRelLocWidth
96967>>>>>>>        
96967>>>>>>>        // the outer size of the control object
96967>>>>>>>        Get GUIWindowSize of hoControl to iSize
96968>>>>>>>        Move (hi(iSize)) to iControlHeight
96969>>>>>>>        Move (low(iSize)) to iControlWidth
96970>>>>>>>        
96970>>>>>>>        // the general idea is to make the control fully visible but to scroll as little as possible.
96970>>>>>>>        
96970>>>>>>>        // Vertical Scroll
96970>>>>>>>        
96970>>>>>>>        // Vertical Scroll down
96970>>>>>>>        // if the bottom of the control plus a bottom margin does not fit make it fit at the bottom
96970>>>>>>>        If (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled >iViewHeight) Begin
96972>>>>>>>            
96972>>>>>>>            // set scroll amount so that the bottom of the control is visible
96972>>>>>>>            Move (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled - iViewHeight ) to iScroll
96973>>>>>>>            
96973>>>>>>>            // See if this amount, scrolls the top out of range. If so just scroll enough so that the
96973>>>>>>>            // top of the object appears at the bottom
96973>>>>>>>            If (iRelLocHeight - iCurrentVertScrolled < iScroll) Begin
96975>>>>>>>                Move (iRelLocHeight + iMarginY  - iCurrentVertScrolled - iViewHeight  ) to iScroll
96976>>>>>>>            End
96976>>>>>>>>
96976>>>>>>>            // if the scroll amnt is negative it's best to just keep it where it is.
96976>>>>>>>            If (iScroll>0) Begin
96978>>>>>>>                Send VScroll of hoScrollingContainer iScroll
96979>>>>>>>            End
96979>>>>>>>>
96979>>>>>>>        End
96979>>>>>>>>
96979>>>>>>>        // else vertical scroll up
96979>>>>>>>        // We scroll if the top of the object is not visible.
96979>>>>>>>        Else If (iRelLocHeight + iMarginY < iCurrentVertScrolled) Begin
96982>>>>>>>            // if we scroll we will scroll enough to see the top of the object.
96982>>>>>>>            Move (iRelLocHeight -iMarginY - iCurrentVertScrolled ) to iScroll
96983>>>>>>>            If (iScroll<0) Begin
96985>>>>>>>                Send VScroll of hoScrollingContainer (iScroll max (-iCurrentVertScrolled))
96986>>>>>>>            End
96986>>>>>>>>
96986>>>>>>>        End
96986>>>>>>>>
96986>>>>>>>        
96986>>>>>>>        // Horizonal Scroll
96986>>>>>>>        
96986>>>>>>>        // if the right side of the control does not fit, scroll it so it fits
96986>>>>>>>        If (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled >iViewWidth) Begin
96988>>>>>>>            Move (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled - iViewWidth ) to iScroll
96989>>>>>>>            If (iRelLocWidth - iCurrentHorzScrolled - iScroll<0) Begin
96991>>>>>>>                Move (iRelLocWidth  - iCurrentHorzScrolled - iMarginX ) to iScroll
96992>>>>>>>            End
96992>>>>>>>>
96992>>>>>>>            If (iScroll>0) Begin
96994>>>>>>>                Send HScroll of hoScrollingContainer iScroll
96995>>>>>>>            End
96995>>>>>>>>
96995>>>>>>>        End
96995>>>>>>>>
96995>>>>>>>        If (iRelLocWidth - iMarginX  - iCurrentHorzScrolled <0) Begin
96997>>>>>>>            // if this can fit by moving all the way to left, do so.
96997>>>>>>>            If (iRelLocWidth + iControlWidth + iMarginX <= iViewWidth) Begin
96999>>>>>>>                Move (-iCurrentHorzScrolled) to iScroll
97000>>>>>>>            End
97000>>>>>>>>
97000>>>>>>>            Else Begin
97001>>>>>>>                Move (iRelLocWidth - iCurrentHorzScrolled - iMarginX) to iScroll
97002>>>>>>>            End
97002>>>>>>>>
97002>>>>>>>            If (iScroll<0) Begin
97004>>>>>>>                Send HScroll of hoScrollingContainer (iScroll max (-iCurrentHorzScrolled))
97005>>>>>>>            End
97005>>>>>>>>
97005>>>>>>>        End
97005>>>>>>>>
97005>>>>>>>        
97005>>>>>>>        
97005>>>>>>>    End_Procedure
97006>>>>>>>    
97006>>>>>>>    // when we receive this message, we might need to scroll to bring the new focus in to view.
97006>>>>>>>    Procedure NotifyFocusSetInContainer Handle hoControl
97008>>>>>>>        Boolean bScrollOnFocus
97008>>>>>>>        Get pbAutoScrollFocus to bScrollOnFocus
97009>>>>>>>        If bScrollOnFocus Begin
97011>>>>>>>            Send ScrollObjectInRange hoControl
97012>>>>>>>        End
97012>>>>>>>>
97012>>>>>>>        Delegate Send NotifyFocusSetInContainer hoControl
97014>>>>>>>    End_Procedure
97015>>>>>>>    
97015>>>>>>>    
97015>>>>>>>    Function CenterTabWorkspaceView Returns Boolean
97017>>>>>>>        Boolean bCenter
97017>>>>>>>        Get pbCenterTabbedViews of ghoCommandBars to bCenter
97018>>>>>>>        Function_Return bCenter
97019>>>>>>>    End_Function
97020>>>>>>>    
97020>>>>>>>    Procedure AdjustSizesLocs Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
97022>>>>>>>        Boolean bTabWorkspaceView
97022>>>>>>>        Get pbTabWorkspaceView to bTabWorkspaceView
97023>>>>>>>        If bTabWorkspaceView Begin
97025>>>>>>>            Send AdjustTabWorkspaceView (&iHeight) (&iWidth) (&iLocY) (&iLocX)
97026>>>>>>>        End
97026>>>>>>>>
97026>>>>>>>    End_Procedure
97027>>>>>>>    
97027>>>>>>>    Function ParentView Returns Handle
97029>>>>>>>        Function_Return (Parent(Parent(Self)))
97030>>>>>>>    End_Function
97031>>>>>>>    
97031>>>>>>>    Procedure AdjustTabWorkspaceView Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
97033>>>>>>>        Integer iSize iMax iDiff
97033>>>>>>>        Handle hoView
97033>>>>>>>        Boolean bCenter bModal
97033>>>>>>>        Get ParentView to hoView
97034>>>>>>>        Get Block_Mouse_State of hoView to bModal
97035>>>>>>>        If not bModal Begin
97037>>>>>>>            Get CenterTabWorkspaceView to bCenter
97038>>>>>>>            Get GuiSize of hoView to iSize
97039>>>>>>>            Get piMaxSize of hoView to iMax
97040>>>>>>>            Get DialogToGui (Hi(iMax)) (Low(iMax)) to iMax
97041>>>>>>>            If (Low(iMax) and Low(iMax)<=Low(isize)) Begin
97043>>>>>>>                If bCenter Begin
97045>>>>>>>                    Move ((Low(iSize)-Low(iMax))/2) to iLocX
97046>>>>>>>                End
97046>>>>>>>>
97046>>>>>>>                Move (Low(iMax)) to iWidth
97047>>>>>>>            End
97047>>>>>>>>
97047>>>>>>>            If (Hi(iMax) and Hi(iMax)<=Hi(iSize)) Begin
97049>>>>>>>                If bCenter Begin
97051>>>>>>>                    Move ((Hi(iSize)-Hi(iMax))/2) to iLocY
97052>>>>>>>                    Move (iLocy min 25) to  iLocY
97053>>>>>>>                End
97053>>>>>>>>
97053>>>>>>>                Move (Hi(imax)) to iHeight
97054>>>>>>>            End
97054>>>>>>>>
97054>>>>>>>        End
97054>>>>>>>>
97054>>>>>>>    End_Procedure
97055>>>>>>>    
97055>>>>>>>    // Automatically determine if this is a scrolling tabbed workspace view
97055>>>>>>>    // If determines this by checking pbAutoSetTabWorkspaceView is set (it can be
97055>>>>>>>    // set to stop this), if we have a global commandbar object and we are using tabbed
97055>>>>>>>    // workspaces. We also make sure that the expected view object is a framework view class
97055>>>>>>>    // This should almost always yield the right answer.
97055>>>>>>>    // This is called by the scrolling container's end_constructor
97055>>>>>>>    Procedure AutoSetTabWorkspaceView
97057>>>>>>>        Boolean bTabView bIsView bAutoSetTabWorkspaceView
97057>>>>>>>        Handle hoParent
97057>>>>>>>        Integer iSize
97057>>>>>>>        Get pbAutoSetTabWorkspaceView to bAutoSetTabWorkspaceView
97058>>>>>>>        If (ghoCommandBars and bAutoSetTabWorkspaceView) Begin
97060>>>>>>>            Get pbTabbedWorkspaces of ghoCommandBars to bTabView
97061>>>>>>>            // not that pbTabbedWorkspaces is a designtime only property. You can not
97061>>>>>>>            // change this after the commandbar is paged.
97061>>>>>>>            If (bTabView) Begin
97063>>>>>>>                Get ParentView to hoParent
97064>>>>>>>                Get IsObjectOfClass of hoParent (RefClass(MdiDialog)) to bIsView
97065>>>>>>>                If (bIsView) Begin
97067>>>>>>>                    // set this as a tab workspace view
97067>>>>>>>                    Set pbTabWorkspaceView to True
97068>>>>>>>                    // when tab workspaces are enabled we always enable auto-scrolling
97068>>>>>>>                    // when tab workspaces are not enabled, pbScroll is whatever it is
97068>>>>>>>                    Set pbAutoScroll to True
97069>>>>>>>                    
97069>>>>>>>                End
97069>>>>>>>>
97069>>>>>>>            End
97069>>>>>>>>
97069>>>>>>>        End
97069>>>>>>>>
97069>>>>>>>    End_Procedure
97070>>>>>>>    
97070>>>>>>>End_Class
97071>>>>>>>
97071>>>>>>>// Container scrolling class support. Nothing in here is public
97071>>>>>>>Class cScrollingContainerMixin is a Mixin
97072>>>>>>>    
97072>>>>>>>    Procedure Define_cScrollingContainerMixin
97074>>>>>>>        Forward Set Border_Style to Border_None
97076>>>>>>>        Set pbSizeToClientArea to False // scrollbars and clientsize do not mix
97077>>>>>>>        Forward Set peAnchors to anAll
97079>>>>>>>        
97079>>>>>>>        // forcing scrollbars right away seems to make painting better
97079>>>>>>>        Set Window_Style WS_HSCROLL to True
97080>>>>>>>        Set Window_Style WS_VSCROLL to True
97081>>>>>>>        
97081>>>>>>>        Property Handle phoScrollingClientArea 0
97082>>>>>>>    End_Procedure
97083>>>>>>>    
97083>>>>>>>    // if anchors are changed, it will not work. We won't let that happen
97083>>>>>>>    Procedure Set peAnchors Integer eAnchors
97085>>>>>>>    End_Procedure
97086>>>>>>>    
97086>>>>>>>    // if a border style is set, it will not work. We won't let that happen
97086>>>>>>>    Procedure Set Border_Style Integer eStyle
97088>>>>>>>    End_Procedure
97089>>>>>>>    
97089>>>>>>>    // redirect scrollbar events and wheel events to the scrolling client area
97089>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
97091>>>>>>>        Handle hoClient
97091>>>>>>>        Get phoScrollingClientArea to hoClient
97092>>>>>>>        If hoClient Begin
97094>>>>>>>            Send OnMouseWheel of hoClient wParam lParam
97095>>>>>>>        End
97095>>>>>>>>
97095>>>>>>>    End_Procedure
97096>>>>>>>    
97096>>>>>>>    // should be sent by WM_VSCROLL
97096>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
97098>>>>>>>        Handle hoClient
97098>>>>>>>        Get phoScrollingClientArea to hoClient
97099>>>>>>>        If hoClient Begin
97101>>>>>>>            Send SetVScrollbox of hoClient iType iNewPos
97102>>>>>>>        End
97102>>>>>>>>
97102>>>>>>>    End_Procedure
97103>>>>>>>    
97103>>>>>>>    // should be sent by WM_HSCROLL
97103>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
97105>>>>>>>        Handle hoClient
97105>>>>>>>        Get phoScrollingClientArea to hoClient
97106>>>>>>>        If hoClient Begin
97108>>>>>>>            Send SetHScrollbox of hoClient iType iNewPos
97109>>>>>>>        End
97109>>>>>>>>
97109>>>>>>>    End_Procedure
97110>>>>>>>    
97110>>>>>>>    // augmented to adjust its size to the size of the parent client area.
97110>>>>>>>    // After this is set, anchors will handle any further resizing.
97110>>>>>>>    Procedure Page Integer iState
97112>>>>>>>        Integer iSiz iHeight iWidth
97112>>>>>>>        Integer iTop iBottom iLeft iRight iFontSize
97112>>>>>>>        Boolean bGroup
97112>>>>>>>        Handle hoClient
97112>>>>>>>        If (iState =1) Begin
97114>>>>>>>            Delegate Get Window_Style BS_GROUPBOX to bGroup
97116>>>>>>>            // We have special code to support groups because they
97116>>>>>>>            // draw a border inside of the client rectangle
97116>>>>>>>            If bGroup Begin
97118>>>>>>>                Get Physical_FontSize to iFontSize
97119>>>>>>>                Move (Hi(iFontSize)) to iTop
97120>>>>>>>                Move 2 to iLeft
97121>>>>>>>                Move 2 to iRight
97122>>>>>>>                Move 2 to iBottom
97123>>>>>>>            End
97123>>>>>>>>
97123>>>>>>>            // We use GetContainerClientSize instead of GuiClientSize because
97123>>>>>>>            // GetContainerClientSize has a special augmentation in tab pages that
97123>>>>>>>            // makes anchors work properly with unpaged tab-pages
97123>>>>>>>            Delegate Get GetContainerClientSize to iSiz
97125>>>>>>>            Set GuiSize to (Hi(iSiz)-(iTop+iBottom)) (Low(iSiz)-(iLeft+iRight))
97126>>>>>>>            Set GuiLocation to iTop iLeft
97127>>>>>>>            Send Adjust_Logicals
97128>>>>>>>        End
97128>>>>>>>>
97128>>>>>>>        Forward Send Page iState
97130>>>>>>>    End_Procedure
97131>>>>>>>    
97131>>>>>>>    Procedure End_Construct_Object
97133>>>>>>>        Handle hoClient
97133>>>>>>>        Forward Send End_Construct_Object
97135>>>>>>>        Get phoScrollingClientArea to hoClient
97136>>>>>>>        If (hoClient) Begin
97138>>>>>>>            Send AutoSetTabWorkspaceView of hoClient
97139>>>>>>>        End
97139>>>>>>>>
97139>>>>>>>    End_Procedure
97140>>>>>>>    
97140>>>>>>>End_Class
97141>>>>>
97141>>>>>Class cDbScrollingClientArea is a dbContainer3d
97142>>>>>    Import_Class_Protocol cScrollingClientAreaMixin
97143>>>>>    Procedure Construct_Object
97145>>>>>        Forward Send Construct_Object
97147>>>>>        Send Define_cScrollingClientAreaMixin
97148>>>>>    End_Procedure
97149>>>>>End_Class
97150>>>>>
97150>>>>>
97150>>>>>
97150>>>>>Class cDbScrollingContainer is a dbContainer3d
97151>>>>>    Import_Class_Protocol cScrollingContainerMixin
97152>>>>>    Procedure Construct_Object
97154>>>>>        Forward Send Construct_Object
97156>>>>>        Send Define_cScrollingContainerMixin
97157>>>>>    End_Procedure
97158>>>>>End_Class
97159>>>Use cDbUpdateFunctionLibrary.pkg
97159>>>Use cRDCButtonDPI.pkg
Including file: cRDCButtonDPI.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButtonDPI.pkg)
97159>>>>>//****************************************************************************
97159>>>>>// $Module type: Package
97159>>>>>// $Module name: cRDCButtonDPI.pkg
97159>>>>>//
97159>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
97159>>>>>// Copyright (c) 2013 RDC Tools International
97159>>>>>// E-mail      : support@rdctools.com
97159>>>>>// Web-site    : http://www.rdctools.com
97159>>>>>//
97159>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
97159>>>>>//
97159>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
97159>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
97159>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
97159>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
97159>>>>>// in the help folder for more details.
97159>>>>>//
97159>>>>>//****************************************************************************
97159>>>>>Use cRDCButton.pkg
Including file: cRDCButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButton.pkg)
97159>>>>>>>//****************************************************************************
97159>>>>>>>// $Module type: Package
97159>>>>>>>// $Module name: cRDCButton.pkg
97159>>>>>>>//
97159>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
97159>>>>>>>// Copyright (c) 2013 RDC Tools International
97159>>>>>>>// E-mail      : support@rdctools.com
97159>>>>>>>// Web-site    : http://www.rdctools.com
97159>>>>>>>//
97159>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
97159>>>>>>>//
97159>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
97159>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
97159>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
97159>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
97159>>>>>>>// in the help folder for more details.
97159>>>>>>>//
97159>>>>>>>//****************************************************************************
97159>>>>>>>Use Windows.pkg
97159>>>>>>>Use Enclient.pkg
97159>>>>>>>Use errornum.inc
97159>>>>>>>
97159>>>>>>>Class cButtonIdleHandler is a cIdleHandler
97160>>>>>>>    Procedure Construct_Object
97162>>>>>>>        Forward Send Construct_Object
97164>>>>>>>
97164>>>>>>>    End_Procedure
97165>>>>>>>
97165>>>>>>>    Procedure OnIdle
97167>>>>>>>        Delegate Send DoUpdate
97169>>>>>>>    End_Procedure
97170>>>>>>>
97170>>>>>>>End_Class
97171>>>>>>>
97171>>>>>>>Class cRDCButton is a Button
97172>>>>>>>
97172>>>>>>>    Procedure Construct_Object
97174>>>>>>>        Forward Send Construct_Object
97176>>>>>>>
97176>>>>>>>        Property Boolean pbAutoEnable False
97177>>>>>>>
97177>>>>>>>        Property Boolean pbEnabled True
97178>>>>>>>
97178>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cButtonIdleHandler)))
97179>>>>>>>
97179>>>>>>>        On_Key kCancel Send CancelIfPopupObject
97180>>>>>>>    End_Procedure
97181>>>>>>>
97181>>>>>>>    Procedure CancelIfPopupObject
97183>>>>>>>        Boolean bIsInPopupObject
97183>>>>>>>        Delegate Get Popup_State to bIsInPopupObject
97185>>>>>>>        If (bIsInPopupObject = True) Begin
97187>>>>>>>            Send Close_Panel
97188>>>>>>>        End
97188>>>>>>>>
97188>>>>>>>    End_Procedure
97189>>>>>>>
97189>>>>>>>    Procedure End_Construct_Object
97191>>>>>>>        String sTooltip sStatus_Help
97191>>>>>>>
97191>>>>>>>        Forward Send End_Construct_Object
97193>>>>>>>
97193>>>>>>>        Get psToolTip   to sTooltip
97194>>>>>>>        Get Status_Help to sStatus_Help
97195>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
97197>>>>>>>            Set psToolTip to sStatus_Help
97198>>>>>>>        End
97198>>>>>>>>
97198>>>>>>>        If (sTooltip <> "" and sStatus_Help = "") Begin
97200>>>>>>>            Set Status_Help to sToolTip
97201>>>>>>>        End
97201>>>>>>>>
97201>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
97202>>>>>>>    End_Procedure
97203>>>>>>>
97203>>>>>>>    Procedure DoUpdate
97205>>>>>>>        If (pbAutoEnable(Self) = False) Begin
97207>>>>>>>            Procedure_Return
97208>>>>>>>        End
97208>>>>>>>>
97208>>>>>>>        Set Enabled_State to (IsEnabled(Self))
97209>>>>>>>    End_Procedure
97210>>>>>>>
97210>>>>>>>    Function IsEnabled Returns Boolean
97212>>>>>>>        Boolean bEnabled
97212>>>>>>>        Get pbEnabled to bEnabled
97213>>>>>>>        Function_Return bEnabled
97214>>>>>>>    End_Function
97215>>>>>>>
97215>>>>>>>    // Enable the idle handler timer when the button is activated
97215>>>>>>>    Procedure Activating
97217>>>>>>>        Forward Send Activating
97219>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
97220>>>>>>>    End_Procedure
97221>>>>>>>
97221>>>>>>>    // Disable the idle handler when the button is deactivated
97221>>>>>>>    Procedure Deactivating
97223>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
97224>>>>>>>        Forward Send Deactivating
97226>>>>>>>    End_Procedure
97227>>>>>>>
97227>>>>>>>End_Class
97228>>>>>
97228>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
97228>>>>>Class cRDCButtonDPI is a cRDCButton
97229>>>>>    Procedure Construct_Object
97231>>>>>        Integer iIconSize
97231>>>>>        Forward Send Construct_Object
97233>>>>>        Set piImageMarginLeft to 10
97234>>>>>    End_Procedure
97235>>>>>
97235>>>>>    // Returns: DPI setting as an integer.
97235>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
97235>>>>>    //                      iDPI=120 is "Medium setting" 125%
97235>>>>>    //                      iDPI= 144 is "Large setting" 150%
97235>>>>>    Function GetCurrentDPI Returns Integer
97237>>>>>        Handle hDC
97237>>>>>        Integer iPixelsX
97237>>>>>        Move (GetDC(0)) to hDC
97238>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
97239>>>>>        Move (ReleaseDC(0, hDC)) to hDC
97240>>>>>        Function_Return iPixelsX
97241>>>>>    End_Function
97242>>>>>
97242>>>>>    Function GetCorrectIconSize Returns Integer
97244>>>>>        Integer iPixelsX iIndex iSize
97244>>>>>        Integer[] iaSizes
97245>>>>>
97245>>>>>        Move 16 to iaSizes[0]
97246>>>>>        Move 24 to iaSizes[1]
97247>>>>>        Move 32 to iaSizes[2]
97248>>>>>        Move 48 to iaSizes[3]
97249>>>>>        Move 64 to iaSizes[4]
97250>>>>>
97250>>>>>        Get piImageSize to iSize  // the "100%" size
97251>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
97252>>>>>        Move (0 max iIndex) to iIndex
97253>>>>>        Get GetCurrentDPI to iPixelsX
97254>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
97254>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
97254>>>>>        // will increment iIndex as many times as we need here.
97254>>>>>        Case Begin
97254>>>>>            Case (iPixelsX > 144)
97256>>>>>                Increment iIndex
97257>>>>>            Case (iPixelsX = 144)
97260>>>>>                Increment iIndex
97261>>>>>            Case (iPixelsX = 120)
97264>>>>>                Increment iIndex
97265>>>>>        Case End
97265>>>>>        Move (iIndex min 4) to iIndex
97266>>>>>        Function_Return iaSizes[iIndex]
97267>>>>>    End_Function
97268>>>>>
97268>>>>>    Procedure Set psToolTip String sToolTip
97270>>>>>        String sStatusHelp
97270>>>>>
97270>>>>>        Get Status_Help to sStatusHelp
97271>>>>>        If (sStatusHelp = "") Begin
97273>>>>>            Set Status_Help to sToolTip
97274>>>>>        End
97274>>>>>>
97274>>>>>
97274>>>>>        Forward Set psToolTip to sToolTip
97276>>>>>    End_Procedure
97277>>>>>
97277>>>>>End_Class
97278>>>Use DatabaseSelection.dg
97278>>>Use ServerSelection.dg
Including file: ServerSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ServerSelection.dg)
97278>>>>>Use Windows.pkg
97278>>>>>Use cCJGridPromptList.pkg
97278>>>>>Use MSSqldrv.pkg
97278>>>>>Use db2_drv.pkg
97278>>>>>Use odbc_drv.pkg    
97278>>>>>Use cRDCModalPanel.pkg
97278>>>>>Use cDbUpdateFunctionLibrary.pkg
97278>>>>>
97278>>>>>Object oServerSelection_sl is a cRDCModalPanel
97280>>>>>    Set Size to 105 225
97281>>>>>    Set Label to "Database Server/DSN Selection"
97282>>>>>    Set piMinSize to 89 211
97283>>>>>    Set Location to 2 2
97284>>>>>    Set Icon to "ServerLookup1.ico"
97285>>>>>
97285>>>>>    Property String[] psTheData
97287>>>>>
97287>>>>>    Object oSelList is a cCJGridPromptList
97289>>>>>        Set Size to 72 215
97290>>>>>        Set Location to 6 6
97291>>>>>        Set peAnchors to anAll
97292>>>>>        Set pbAllowColumnRemove to False
97293>>>>>        Set pbUseAlternateRowBackgroundColor to True
97294>>>>>        Set pbGrayIfDisable to False
97295>>>>>        Set pbHeaderReorders to False
97296>>>>>        Set pbHeaderSelectsColumn to False
97297>>>>>        Set pbHeaderTogglesDirection to False
97298>>>>>        Set pbShadeSortColumn to False
97299>>>>>        Set piFocusCellBackColor to clDkGray
97300>>>>>
97300>>>>>        Object oName is a cCJGridColumn
97302>>>>>            Set piWidth to 358
97303>>>>>            Set psCaption to "Name"
97304>>>>>        End_Object
97305>>>>>
97305>>>>>        Procedure Activating
97308>>>>>            tDataSourceRow[] MyData
97308>>>>>            tDataSourceRow[] MyData
97309>>>>>            Handle hoDataSource
97309>>>>>            String[] sTheData
97310>>>>>            Integer iCount iSize
97310>>>>>
97310>>>>>            Send Cursor_Wait of Cursor_Control
97311>>>>>            Get psTheData to sTheData
97312>>>>>            Move (SizeOfArray(sTheData)) to iSize
97313>>>>>            Decrement iSize
97314>>>>>            For iCount from 0 to iSize
97320>>>>>>
97320>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
97321>>>>>            Loop
97322>>>>>>
97322>>>>>
97322>>>>>            Forward Send Activating
97324>>>>>
97324>>>>>            Get phoDataSource to hoDataSource
97325>>>>>            Send InitializeData of hoDataSource MyData
97326>>>>>            Send Cursor_Ready of Cursor_Control
97327>>>>>        End_Procedure
97328>>>>>
97328>>>>>    End_Object
97329>>>>>
97329>>>>>    Object oOK_Btn is a Button
97331>>>>>        Set Size to 14 50
97332>>>>>        Set Label    to "&OK"
97333>>>>>        Set Location to 85 116
97334>>>>>        Set peAnchors To anBottomRight
97335>>>>>
97335>>>>>        Procedure OnClick
97338>>>>>            Send Ok of oSelList
97339>>>>>        End_Procedure
97340>>>>>
97340>>>>>    End_Object
97341>>>>>
97341>>>>>    Object oCancel_Btn is a Button
97343>>>>>        Set Size to 14 50
97344>>>>>        Set Label    to "&Cancel"
97345>>>>>        Set Location to 85 171
97346>>>>>        Set peAnchors to anBottomRight
97347>>>>>
97347>>>>>        Procedure OnClick
97350>>>>>            Send Close_Panel
97351>>>>>        End_Procedure
97352>>>>>
97352>>>>>    End_Object
97353>>>>>
97353>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
97354>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
97355>>>>>End_Object
97356>>>Use SQLConnections.dg
Including file: SQLConnections.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLConnections.dg)
97356>>>>>Use Windows.pkg
97356>>>>>Use cCJGridPromptList.pkg
97356>>>>>Use cDbUpdateFunctionLibrary.pkg
97356>>>>>Use MSSqldrv.pkg
97356>>>>>Use db2_drv.pkg
97356>>>>>Use odbc_drv.pkg
97356>>>>>Use cCJGridColumn.pkg
97356>>>>>
97356>>>>>Object oSQLConnections is a ModalPanel
97358>>>>>    Set Label to "SQL Connections"
97359>>>>>    Set Size to 121 397
97360>>>>>    Set piMinSize to 89 185
97361>>>>>    Set Location to 2 2
97362>>>>>    Set Border_Style to Border_Thick
97363>>>>>
97363>>>>>    Property tSQLConnection[] psTheData
97365>>>>>
97365>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
97367>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
97369>>>>>        End_Object
97370>>>>>    End
97370>>>>>>
97370>>>>>
97370>>>>>    Object oSelListSQLConnections is a cCJGridPromptList
97372>>>>>        Set Size to 90 377
97373>>>>>        Set Location to 6 6
97374>>>>>        Set peAnchors to anAll
97375>>>>>        Set pbAllowColumnRemove to False
97376>>>>>        Set pbUseAlternateRowBackgroundColor to True
97377>>>>>        Set pbGrayIfDisable to False
97378>>>>>        Set pbHeaderReorders to False
97379>>>>>        Set pbHeaderSelectsColumn to False
97380>>>>>        Set pbHeaderTogglesDirection to False
97381>>>>>        Set pbShadeSortColumn to False
97382>>>>>        Set piFocusCellBackColor to clDkGray  
97383>>>>>        Set pbRestoreLayout to True
97384>>>>>        Set psLayoutSection to "oSQLConnections_oSelListSQLConnections"
97385>>>>>
97385>>>>>        Object oID_Col is a cCJGridColumn
97387>>>>>            Set piWidth to 132
97388>>>>>            Set psCaption to "ID"
97389>>>>>        End_Object
97390>>>>>
97390>>>>>        Object oDbType_Col is a cCJGridColumn
97392>>>>>            Set piWidth to 182
97393>>>>>            Set psCaption to "Database Type"
97394>>>>>        End_Object
97395>>>>>
97395>>>>>        Object oServer_Col is a cCJGridColumn
97397>>>>>            Set piWidth to 296
97398>>>>>            Set psCaption to "Server/DSN"
97399>>>>>        End_Object
97400>>>>>
97400>>>>>        Object oDatabase_Col is a cCJGridColumn
97402>>>>>            Set piWidth to 211
97403>>>>>            Set psCaption to "Database"
97404>>>>>        End_Object
97405>>>>>
97405>>>>>        Object oDriverID_Col is a cCJGridColumn
97407>>>>>            Set piWidth to 121
97408>>>>>            Set psCaption to "Driver ID"
97409>>>>>        End_Object
97410>>>>>
97410>>>>>        Procedure Activating
97413>>>>>            tDataSourceRow[] MyData
97413>>>>>            tDataSourceRow[] MyData
97414>>>>>            Handle hoDataSource
97414>>>>>            Integer iCount iSize iPos
97414>>>>>            String sDriverID sConnectionID sValue
97414>>>>>            tSQLConnection[] sTheData
97414>>>>>            tSQLConnection[] sTheData
97415>>>>>
97415>>>>>            Send Cursor_Wait of Cursor_Control
97416>>>>>            Forward Send Activating
97418>>>>>
97418>>>>>            Get psTheData to sTheData
97419>>>>>            Move (SizeOfArray(sTheData)) to iSize
97420>>>>>            Decrement iSize
97421>>>>>            For iCount from 0 to iSize
97427>>>>>>
97427>>>>>                Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary sTheData[iCount].iDbType to sValue
97428>>>>>                Move sTheData[iCount].sConnectionID to MyData[iCount].sValue[0]
97429>>>>>                Move sValue                         to MyData[iCount].sValue[1]
97430>>>>>                Move sTheData[iCount].sServer       to MyData[iCount].sValue[2]
97431>>>>>                Move sTheData[iCount].sDatabase     to MyData[iCount].sValue[3]
97432>>>>>                Move sTheData[iCount].sDriverID     to MyData[iCount].sValue[4]
97433>>>>>            Loop
97434>>>>>>
97434>>>>>
97434>>>>>            Get phoDataSource to hoDataSource
97435>>>>>            Send InitializeData of hoDataSource MyData
97436>>>>>            Send Cursor_Ready of Cursor_Control
97437>>>>>        End_Procedure
97438>>>>>
97438>>>>>    End_Object
97439>>>>>
97439>>>>>    Object oOK_Btn is a Button
97441>>>>>        Set Label    to "&OK"
97442>>>>>        Set Location to 101 280
97443>>>>>        Set peAnchors to anBottomRight
97444>>>>>
97444>>>>>        Procedure OnClick
97447>>>>>            Send Ok of oSelListSQLConnections
97448>>>>>        End_Procedure
97449>>>>>
97449>>>>>    End_Object
97450>>>>>
97450>>>>>    Object oCancel_Btn is a Button
97452>>>>>        Set Label    to "&Cancel"
97453>>>>>        Set Location to 101 335
97454>>>>>        Set peAnchors to anBottomRight
97455>>>>>
97455>>>>>        Procedure OnClick
97458>>>>>            Send Close_Panel
97459>>>>>        End_Procedure
97460>>>>>
97460>>>>>    End_Object
97461>>>>>
97461>>>>>    Procedure Page Integer iPageObject
97464>>>>>        Set Icon to "SQLConnections1.ico"
97465>>>>>        Forward Send Page iPageObject
97467>>>>>    End_Procedure
97468>>>>>
97468>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
97469>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
97470>>>>>End_Object
97471>>>
97471>>>Activate_View Activate_oSQLConnections_vw for oSQLConnections_vw
97481>>>>
97481>>>Object oSQLConnections_vw is a dbView
97483>>>    Set Border_Style to Border_Thick
97484>>>    Set Size to 251 427
97485>>>    Set Location to 2 2
97486>>>    Set Label to "SQL Connections"
97487>>>    Set pbAutoActivate to True
97488>>>    Set Icon to "SQLConnections1.ico"
97489>>>
97489>>>    Object oScrollingContainer1 is a cDbScrollingContainer
97491>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
97493>>>
97493>>>            Object oCurrentSettings_grp is a Group
97495>>>                Set Size to 232 402
97496>>>                Set Location to 6 12
97497>>>                Set Label to "Current Connection Settings"
97498>>>                Set peAnchors to anAll
97499>>>
97499>>>                Object oConnectionID_fm is a Form
97501>>>                    Set Size to 12 100
97502>>>                    Set Location to 12 68
97503>>>                    Set Label to "Connection ID"
97504>>>                    Set Label_Col_Offset to 2
97505>>>                    Set Label_Justification_Mode to JMode_Right
97506>>>                    Set Prompt_Button_Mode to PB_PromptOn
97507>>>                    Set Prompt_Object to (oSQLConnections(Self))
97508>>>
97508>>>                    Procedure Prompt
97511>>>                        String[] sTheData
97512>>>                        String sCurrentVal sNewVal
97512>>>                        Handle hoIniFile ho
97512>>>                        Integer iSize iCount
97512>>>                        tSQLConnection[] SQLConnectionArray
97512>>>                        tSQLConnection[] SQLConnectionArray
97513>>>
97513>>>                        Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to hoIniFile
97514>>>                        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
97515>>>                        Get Value to sCurrentVal
97516>>>                        Get Prompt_Object to ho
97517>>>                        Set psTheData of ho to SQLConnectionArray
97518>>>
97518>>>                        Forward Send Prompt
97520>>>                        Get Value to sNewVal
97521>>>                        If (sCurrentVal <> sNewVal) Begin
97523>>>                            Send Cursor_Wait of Cursor_Control
97524>>>                            Set psConnectionID of ghoSQLConnectionHandler to sNewVal
97525>>>                            Broadcast Recursive Send Refresh of (phoMainPanel(ghoApplication))
97527>>>                            Send Cursor_Ready of Cursor_Control
97528>>>                            Send KeyAction of oTestLogin_btn
97529>>>                        End
97529>>>>
97529>>>                    End_Procedure   
97530>>>                    
97530>>>                    Procedure PromptUpdate Handle hoPrompt
97533>>>                        String[] sSelectedNames                    
97534>>>                
97534>>>                        Get SelectedColumnValues of hoPrompt 2 to sSelectedNames // Col 2 = Server column
97535>>>                        If (SizeOfArray(sSelectedNames)) Begin
97537>>>                            Set psServer of ghoSQLConnectionHandler to sSelectedNames[0] 
97538>>>                            Delegate Send Page True // Broadcast sends refresh
97540>>>                        End
97540>>>>
97540>>>                    End_Procedure   
97541>>>
97541>>>                    Procedure Prompt_Callback Handle hoPrompt
97544>>>                        String sServer
97544>>>                        Set peUpdateMode of hoPrompt to umPromptCustom
97545>>>                        Set piUpdateColumn of hoPrompt to 2 // The server column
97546>>>                        Get Value of oServer_fm to sServer
97547>>>                        Set psSeedValue of hoPrompt to sServer
97548>>>                        Set phmPromptUpdateCallback of hoPrompt to (RefProc(PromptUpdate))
97549>>>                    End_Procedure
97550>>>
97550>>>                    Procedure Refresh
97553>>>                        String sValue
97553>>>                        Get psConnectionID of ghoSQLConnectionHandler to sValue
97554>>>                        Set Value to sValue
97555>>>                    End_Procedure
97556>>>
97556>>>                End_Object
97557>>>
97557>>>                Object oDriverID_cf is a ComboForm
97559>>>                    Set Size to 12 91
97560>>>                    Set Location to 12 222
97561>>>                    Set Label_Col_Offset to 2
97562>>>                    Set Label_Justification_Mode to JMode_Right
97563>>>                    Set Label to "Driver ID"
97564>>>                    Set Entry_State to False
97565>>>                    Set Enabled_State to False
97566>>>
97566>>>                    Procedure Combo_Fill_List
97569>>>                        Send Combo_Add_Item MSSQLDRV_ID
97570>>>                        Send Combo_Add_Item DB2_DRV_ID
97571>>>                        Send Combo_Add_Item ODBC_DRV_ID
97572>>>                    End_Procedure
97573>>>
97573>>>                    Procedure OnChange
97576>>>                        String sValue sOrgValue
97576>>>                        Boolean bEnabled bChecked
97576>>>
97576>>>                        Get Value to sValue
97577>>>                        Get psDriverID of ghoSQLConnectionHandler to sOrgValue
97578>>>                        If (sValue <> "" and sValue <> sOrgValue and sValue <> "None") Begin
97580>>>                            Set psDriverID of ghoSQLConnectionHandler to sValue
97581>>>                        End
97581>>>>
97581>>>                        Move (sValue <> "None") to bEnabled
97582>>>                        Broadcast Set Enabled_State of (Parent(Self)) to bEnabled
97584>>>                        Set Enabled_State to False
97585>>>                        Set Enabled_State of oConnectionString_fm to False
97586>>>                        Set Enabled_State of oDatabase_fm to (sValue <> DB2_DRV_ID)
97587>>>
97587>>>                        Get Checked_State of oTrusted_cb  to bChecked
97588>>>                        Set Enabled_State of oUserID_fm   to (bChecked = False)
97589>>>                        Set Enabled_State of oPassword_fm to (bChecked = False)
97590>>>                    End_Procedure
97591>>>
97591>>>                    Procedure Refresh
97594>>>                        String sValue
97594>>>
97594>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
97595>>>                        Set Value to sValue
97596>>>                    End_Procedure
97597>>>
97597>>>                End_Object
97598>>>
97598>>>                Object oServer_fm is a Form
97600>>>                    Set Size to 12 100
97601>>>                    Set Location to 26 68
97602>>>                    Set Label to "Server"
97603>>>                    Set Label_Col_Offset to 2
97604>>>                    Set Label_Justification_Mode to JMode_Right
97605>>>                    Set Prompt_Button_Mode to PB_PromptOn
97606>>>                    Set Prompt_Object to (oServerSelection_sl(Self))
97607>>>
97607>>>                    Procedure Refresh
97610>>>                        String sValue
97610>>>                        Get psServer of ghoSQLConnectionHandler to sValue
97611>>>                        Set Value to sValue
97612>>>                    End_Procedure
97613>>>
97613>>>                    Procedure Prompt
97616>>>                        String[] sTheData
97617>>>                        String sDriverID
97617>>>                        Handle ho
97617>>>
97617>>>                        Send Cursor_Wait of Cursor_Control
97618>>>                        Get Prompt_Object to ho
97619>>>                        Get Value of oDriverID_cf to sDriverID
97620>>>                        Get SqlUtilEnumerateServers of ghoDbUpdateFunctionLibrary sDriverID 2 to sTheData
97621>>>                        Set psTheData of ho to sTheData
97622>>>                        Send Cursor_Ready of Cursor_Control
97623>>>
97623>>>                        Forward Send Prompt
97625>>>                    End_Procedure
97626>>>
97626>>>                End_Object
97627>>>
97627>>>                Object oDatabase_fm is a Form
97629>>>                    Set Size to 12 91
97630>>>                    Set Location to 26 222
97631>>>                    Set Label to "Database"
97632>>>                    Set Label_Col_Offset to 2
97633>>>                    Set Label_Justification_Mode to JMode_Right
97634>>>                    Set Prompt_Button_Mode to PB_PromptOn
97635>>>                    Set Prompt_Object to (oDatabaseSelection_sl(Self))
97636>>>                    Set peAnchors to anNone
97637>>>                    Set Entry_State to False
97638>>>
97638>>>                    Procedure Refresh
97641>>>                        String sDatabase
97641>>>
97641>>>                        Get psDatabase of ghoSQLConnectionHandler to sDatabase
97642>>>                        Set Value to sDatabase
97643>>>                    End_Procedure
97644>>>
97644>>>                    Procedure Prompt
97647>>>                        String[] sTheData
97648>>>                        Handle ho
97648>>>                        String sDriverID
97648>>>
97648>>>                        Get Value of oDriverID_cf to sDriverID
97649>>>                        Get SqlUtilEnumerateDatabases of ghoDbUpdateFunctionLibrary sDriverID to sTheData
97650>>>
97650>>>                        Get Prompt_Object to ho
97651>>>                        Set psTheData of ho to sTheData
97652>>>
97652>>>                        Forward Send Prompt
97654>>>                    End_Procedure
97655>>>
97655>>>                    Procedure OnChange
97658>>>                        String sValue sOrgValue
97658>>>                        Get Value to sValue
97659>>>                        Get psDatabase of ghoSQLConnectionHandler to sOrgValue
97660>>>                        If (Uppercase(Trim(sValue)) <> Uppercase(Trim(sOrgValue))) Begin
97662>>>                            Set psDatabase of ghoSQLConnectionHandler to sValue
97663>>>                            Get psConnectionString of ghoSQLConnectionHandler to sValue
97664>>>                            Set Value of oConnectionString_fm to sValue
97665>>>                        End
97665>>>>
97665>>>                    End_Procedure
97666>>>
97666>>>                End_Object
97667>>>
97667>>>                Object oTrusted_cb is a CheckBox
97669>>>                    Set Size to 10 50
97670>>>                    Set Location to 45 68
97671>>>                    Set Label to "Use Trusted Connection"
97672>>>
97672>>>                    Procedure Refresh
97675>>>                        Boolean bValue
97675>>>                        Get pbTrusted of ghoSQLConnectionHandler to bValue
97676>>>                        Set Checked_State to bValue
97677>>>                    End_Procedure
97678>>>
97678>>>                    Procedure OnChange
97681>>>                        Boolean bChecked
97681>>>
97681>>>                        Get Checked_State to bChecked
97682>>>                        Set Enabled_State of oUserID_fm   to (bChecked = False)
97683>>>                        Set Enabled_State of oPassword_fm to (bChecked = False)
97684>>>                    End_Procedure
97685>>>
97685>>>                End_Object
97686>>>
97686>>>                Object oUserID_fm is a Form
97688>>>                    Set Size to 12 100
97689>>>                    Set Location to 57 68
97690>>>                    Set Label to "UserID"
97691>>>                    Set Label_Col_Offset to 2
97692>>>                    Set Label_Justification_Mode to JMode_Right
97693>>>
97693>>>                    Procedure Refresh
97696>>>                        String sValue
97696>>>                        Get psUserID of ghoSQLConnectionHandler to sValue
97697>>>                        Set Value to sValue
97698>>>                    End_Procedure
97699>>>
97699>>>                End_Object
97700>>>
97700>>>                Object oPassword_fm is a Form
97702>>>                    Set Size to 12 91
97703>>>                    Set Location to 57 222
97704>>>                    Set Label to "Password"
97705>>>                    Set Label_Col_Offset to 2
97706>>>                    Set Label_Justification_Mode to JMode_Right
97707>>>                    // Set psToolTip to "Note: The password form does _not_ have it's password state set to True because the view is for testing purposes only. And we can see the password - if set - from the connection string as well."
97707>>>                    Set psToolTip to "Press the 'Toggle Password' button to reveal the password"
97708>>>                    Set Password_State to True
97709>>>
97709>>>                    Procedure Refresh
97712>>>                        String sValue
97712>>>                        Get psPassword of ghoSQLConnectionHandler to sValue
97713>>>                        Set Value to sValue
97714>>>                    End_Procedure
97715>>>
97715>>>                End_Object
97716>>>
97716>>>                Object oViewPassword_btn is a cRDCButtonDPI
97718>>>                    Set Size to 12 19
97719>>>                    Set Location to 57 317
97720>>>                    Set psToolTip to "Toggle password"
97721>>>                    Set psImage to "ViewPassword1.ico"
97722>>>                    Set piImageMarginLeft to 0
97723>>>
97723>>>                    Procedure OnClick
97726>>>                        Boolean bState
97726>>>                        Get Password_State of oPassword_fm to bState
97727>>>                        Send Page_Object   of oPassword_fm False
97728>>>                        Set Password_State of oPassword_fm to (not(bState))
97729>>>                        Send Page_Object   of oPassword_fm True
97730>>>                    End_Procedure
97731>>>
97731>>>                End_Object
97732>>>
97732>>>                Object oTestLogin_btn is a cRDCButtonDPI
97734>>>                    Set Size to 12 56
97735>>>                    Set Location to 57 340
97736>>>                    Set Label to "Test Login"
97737>>>                    Set peAnchors to anNone
97738>>>                    Set psToolTip to "Changes the connection string with any changes made and tries to login to the server with the connection string."
97739>>>                    Set FontWeight to fw_Bold
97740>>>                    Set psImage to "ActionLogin1.ico"
97741>>>                    Set piImageMarginLeft to 0
97742>>>
97742>>>                    Procedure OnClick
97745>>>                        tSQLConnection SQLConnection
97745>>>                        tSQLConnection SQLConnection
97745>>>                        String sServer sDatabase sDriverID sUserID sPassword sConnectionID sConnectionString
97745>>>                        Boolean bTrusted bMertechDriver bLoginSuccessful
97745>>>                        Integer iDriverID
97745>>>                        Handle hoDriver
97745>>>
97745>>>                        Get Value of oDriverID_cf        to SQLConnection.sDriverID
97746>>>                        Get Value of oConnectionID_fm    to SQLConnection.sConnectionID
97747>>>                        Get Value of oServer_fm          to SQLConnection.sServer
97748>>>                        Get Value of oDatabase_fm        to SQLConnection.sDatabase
97749>>>                        Get Checked_State of oTrusted_cb to SQLConnection.bTrusted
97750>>>                        Get Value of oUserID_fm          to SQLConnection.sUserID
97751>>>                        Get Value of oPassword_fm        to SQLConnection.sPassword
97752>>>
97752>>>                        Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
97753>>>
97753>>>                        Get DriverIndex of ghoSQLConnectionHandler SQLConnection.sDriverID to iDriverID
97754>>>                        If (iDriverID = 0) Begin
97756>>>                            Send Info_Box ("The driver" * SQLConnection.sDriverID * "could not be loaded. Is the driver installed? And equally imporant; Is the corresponding database server or client software installed?")
97757>>>                            Procedure_Return
97758>>>                        End
97758>>>>
97758>>>
97758>>>                        Get IsMertechDriver of ghoSQLConnectionHandler SQLConnection.sDriverID to bMertechDriver
97759>>>                        If (bMertechDriver = False) Begin
97761>>>                            Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to True
97764>>>                        End
97764>>>>
97764>>>
97764>>>                        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
97765>>>                        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
97766>>>                        Set psDriverID of hoDriver to SQLConnection.sDriverID
97767>>>                        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bLoginSuccessful
97768>>>                        Send Destroy   of hoDriver
97769>>>
97769>>>                        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
97770>>>                        If (LastErr <> CLIERR_LOGIN_UNSUCCESSFUL) Begin
97772>>>                            Move (Replace(("PWD=" + SQLConnection.sPassword), sConnectionString, "PWD=***")) to sConnectionString
97773>>>                            Set Value of oConnectionString_fm to sConnectionString
97774>>>                            Send Info_Box "Login Successful!"
97775>>>                        End
97775>>>>
97775>>>                        Else Begin
97776>>>                            Send Info_Box "Nope, that didn't work. Login failed."
97777>>>                        End
97777>>>>
97777>>>                        Broadcast Recursive Send Combo_Fill_List of (Client_Id(phoMainPanel(ghoApplication)))
97779>>>                        Move 0 to LastErr
97780>>>                    End_Procedure
97781>>>
97781>>>                End_Object
97782>>>
97782>>>                Object oConnectionString_fm is a Form
97784>>>                    Set Size to 12 328
97785>>>                    Set Location to 82 68
97786>>>                    Set Label to "Connection String"    
97787>>>                    Set Label_Col_Offset to 2
97788>>>                    Set Label_Justification_Mode to JMode_Right
97789>>>                    Set peAnchors to anTopLeftRight
97790>>>                    Set Enabled_State to False
97791>>>
97791>>>                    Procedure Refresh
97794>>>                        String sValue
97794>>>                        tSQLConnection SQLConnection
97794>>>                        tSQLConnection SQLConnection
97794>>>
97794>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97795>>>                        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
97796>>>                        Set Value to sValue
97797>>>                    End_Procedure
97798>>>
97798>>>                End_Object
97799>>>
97799>>>                Object oInfo_tb is a TextBox
97801>>>                    Set Auto_Size_State to False
97802>>>                    Set Size to 18 303
97803>>>                    Set Location to 106 8
97804>>>                    Set Label to "Note: The above settings was read from the SQLConnections.ini file when the object was created and are properties of the 'ghoSQLConnectionHandler' object."
97805>>>                    Set Justification_Mode to JMode_Left
97806>>>                    Set FontItalics to True
97807>>>                End_Object
97808>>>
97808>>>                Object oRunSQLConnectionsProgram_btn is a cRDCButtonDPI
97810>>>                    Set Size to 21 83
97811>>>                    Set Location to 106 315
97812>>>                    Set Label to "SQL Connections"
97813>>>                    Set peAnchors to anNone
97814>>>                    Set psImage to "SQLConnections1.ico"
97815>>>
97815>>>                    Procedure OnClick
97818>>>                        Runprogram Background "SQLConnections.exe"
97819>>>                    End_Procedure
97820>>>
97820>>>                End_Object
97821>>>
97821>>>                Object oGetCollation_btn is a Button
97823>>>                    Set Size to 27 91
97824>>>                    Set Location to 154 38
97825>>>                    Set Label to 'Get Database Collation'
97826>>>                
97826>>>                    Procedure OnClick
97829>>>                        String sCollation sDatabase
97829>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase 
97830>>>                        Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary sDatabase False to sCollation 
97831>>>                        Set Value of oGetCollation_fm to sCollation
97832>>>                    End_Procedure
97833>>>                
97833>>>                End_Object
97834>>>
97834>>>                Object oGetCollation_fm is a Form
97836>>>                    Set Size to 12 148
97837>>>                    Set Location to 162 143
97838>>>                    Set Label to "Current SQL Collation Name"
97839>>>                    Set Label_Col_Offset to 0
97840>>>                    Set Label_Row_Offset to 1
97841>>>                    Set Label_Justification_Mode to JMode_Top
97842>>>                End_Object
97843>>>        
97843>>>                Object oSetCollation_btn is a Button
97845>>>                    Set Size to 27 91
97846>>>                    Set Location to 188 38
97847>>>                    Set Label to "Set Database Collation"
97848>>>                
97848>>>                    Procedure OnClick
97851>>>                        String sCollation sDatabase sErrorText
97851>>>                        Boolean bOK
97851>>>                        Integer iRetval  
97851>>>                        tSqlErrorArray aSqlErrorArray
97851>>>                        tSqlErrorArray aSqlErrorArray
97851>>>                        
97851>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase  
97852>>>                        Get Value of oSetCollation_fm to sCollation
97853>>>                        Get YesNo_Box ("This will permanently change SQL collation for the selected database:" * String(sDatabase) * "Are you sure you want to do this?") to iRetval
97854>>>                        If (iRetval <> MBR_Yes) Begin
97856>>>                            Procedure_Return
97857>>>                        End
97857>>>>
97857>>>                        Get SqlDatabaseCollationChange of ghoDbUpdateFunctionLibrary sDatabase sCollation to bOK
97858>>>                        If (bOK = True) Begin
97860>>>                            Send Info_Box ("Changing the collation for database:" * String(sDatabase) * "was successful.")
97861>>>                        End
97861>>>>
97861>>>                        Else Begin                   
97862>>>                            Get paSqlErrorArray of ghoDbUpdateFunctionLibrary to aSqlErrorArray
97863>>>                            Move ("Embedded SQL Statement:" * String(aSqlErrorArray.sSqlStatementArray[0])) to sErrorText
97864>>>                            Move (sErrorText + "\n")                  to sErrorText
97865>>>                            Move (sErrorText + "\n" + "SQL Error:" * String(aSqlErrorArray.sSqlErrorArray[0])) to sErrorText
97866>>>                            Send Info_Box ("Changing the collation for database:" * String(sDatabase) * "failed." + "\n" + sErrorText)
97867>>>                        End
97867>>>>
97867>>>
97867>>>                    End_Procedure
97868>>>                
97868>>>                End_Object
97869>>>
97869>>>                Object oSetCollation_fm is a Form
97871>>>                    Set Size to 12 148
97872>>>                    Set Location to 197 143
97873>>>                    Set Label to "New SQL Collation Name"
97874>>>                    Set Label_Col_Offset to 0
97875>>>                    Set Label_Row_Offset to 1
97876>>>                    Set Label_Justification_Mode to JMode_Top
97877>>>                End_Object
97878>>>
97878>>>                Procedure Page Integer iPageObject
97881>>>                    Broadcast Recursive Send Refresh of (phoMainPanel(ghoApplication))
97883>>>                    Forward Send Page iPageObject
97885>>>                End_Procedure
97886>>>
97886>>>            End_Object
97887>>>
97887>>>        End_Object
97888>>>        
97888>>>    End_Object
97889>>>
97889>>>End_Object
97890>        Use SQLFunctions.vw
Including file: SQLFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLFunctions.vw)
97890>>>Use Windows.pkg
97890>>>Use DFClient.pkg
97890>>>Use Dfspnfrm.pkg
97890>>>Use cDbScrollingContainer.pkg
97890>>>Use cRDCButtonDPI.pkg
97890>>>Use cDbUpdateFunctionLibrary.pkg
97890>>>Use SQLDatabaseBackup.dg
97890>>>
97890>>>Activate_View Activate_oSQLFunctions_vw for oSQLFunctions_vw
97900>>>>
97900>>>Object oSQLFunctions_vw is a dbView
97902>>>    Set Border_Style to Border_Thick
97903>>>    Set Size to 260 426
97904>>>    Set Location to -4 2
97905>>>    Set Label to "Functions"
97906>>>    Set pbAutoActivate to True
97907>>>    Set Icon to "Sql1.ico"
97908>>>
97908>>>    Procedure OnSetFocus
97911>>>        String sValue
97911>>>        tSQLConnection SQLConnection
97911>>>        tSQLConnection SQLConnection
97911>>>
97911>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97912>>>        Set Value of oSQLDatabase_fm to SQLConnection.sDatabase
97913>>>        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
97914>>>        Set Value of oSQLConnectionString_fm to sValue
97915>>>    End_Procedure
97916>>>
97916>>>    Object oScrollingContainer1 is a cDbScrollingContainer
97918>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
97920>>>
97920>>>            Object oSQLFunctionTests_grp is a Group
97922>>>                Set Size to 243 402
97923>>>                Set Location to 7 12
97924>>>                Set Label to "Tests: Change SQL Database with Specialized SQL Functions"
97925>>>                Set peAnchors to anAll
97926>>>
97926>>>                Object oSQLConnectionString_fm is a Form
97928>>>                    Set Size to 12 375
97929>>>                    Set Location to 23 14
97930>>>                    Set Label to "Current Connection String Settings:"
97931>>>                    Set Label_Col_Offset to 0
97932>>>                    Set Label_Justification_Mode to JMode_Top
97933>>>                    Set peAnchors to anTopLeftRight
97934>>>                    Set Enabled_State to False
97935>>>                    Set Label_Row_Offset to 1
97936>>>                End_Object
97937>>>
97937>>>                Object oSQLDatabase_fm is a Form
97939>>>                    Set Size to 12 86
97940>>>                    Set Location to 50 14
97941>>>                    Set Label to "Database:"
97942>>>                    Set Label_Col_Offset to 0
97943>>>                    Set Label_Justification_Mode to JMode_Top
97944>>>                    Set Label_Row_Offset to 1
97945>>>                    Set FontWeight to fw_Bold
97946>>>                    Set Enabled_State to False
97947>>>                End_Object
97948>>>
97948>>>                Object oDriverID2_cf is a ComboForm
97950>>>                    Set Size to 12 91
97951>>>                    Set Location to 50 121
97952>>>                    Set Label_Col_Offset to 0
97953>>>                    Set Label_Justification_Mode to JMode_Top
97954>>>                    Set Label to "Driver ID:"
97955>>>                    Set Entry_State to False
97956>>>                    Set Enabled_State to False
97957>>>                    Set Label_Row_Offset to 1
97958>>>
97958>>>                    Procedure Combo_Fill_List
97961>>>                        Send Combo_Add_Item MSSQLDRV_ID
97962>>>                        Send Combo_Add_Item DB2_DRV_ID
97963>>>                        Send Combo_Add_Item ODBC_DRV_ID
97964>>>                    End_Procedure
97965>>>
97965>>>                    Procedure Refresh
97968>>>                        String sValue
97968>>>
97968>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
97969>>>                        Set Value to sValue
97970>>>                    End_Procedure
97971>>>
97971>>>                End_Object
97972>>>
97972>>>                Object oBackupSQLDatabase_btn is a cRDCButtonDPI
97974>>>                    Set Size to 12 109
97975>>>                    Set Location to 50 220
97976>>>                    Set Label to "Backup MS-SQL Database"
97977>>>                    Set psImage to "DbBackup1.ico"
97978>>>
97978>>>                    Procedure OnClick
97981>>>                        Boolean bOK
97981>>>
97981>>>                        // SQLDatabaseBackup dialog:
97981>>>                        Get MakeSQLDatabaseBackup to bOK
97982>>>
97982>>>                        If (bOK = True) Begin
97984>>>                            Send Info_Box "The backup of the database was successful!"
97985>>>                        End
97985>>>>
97985>>>                        Else Begin
97986>>>                            Send Info_Box "The database was not backup up"
97987>>>                        End
97987>>>>
97987>>>                    End_Procedure
97988>>>
97988>>>                End_Object
97989>>>
97989>>>                Object oDatabaseInfo_tb is a TextBox
97991>>>                    Set Auto_Size_State to False
97992>>>                    Set Size to 25 96
97993>>>                    Set Location to 64 14
97994>>>                    Set Label to "(Change database on the SQL Connections tabpage)"
97995>>>                    Set Justification_Mode to JMode_Left
97996>>>                End_Object
97997>>>
97997>>>                Object oSQLInfo_tb is a TextBox
97999>>>                    Set Auto_Size_State to False
98000>>>                    Set Size to 37 270
98001>>>                    Set Location to 76 118
98002>>>                    Set Label to "Note: The DataFlex database API is NOT used here. Instead all is done with specialized embedded SQL (ESQL) funtions from the cDbUpdateFunctionLibrary. This is because an API 'Structure_End' command could drop and rebuild the whole table (!). That can take a long time..."
98003>>>                    Set Justification_Mode to JMode_Left
98004>>>                End_Object
98005>>>
98005>>>                Object oSQLTableName_cf is a ComboForm
98007>>>                    Set Size to 12 96
98008>>>                    Set Location to 106 14
98009>>>                    Set Label_Col_Offset to 0
98010>>>                    Set Label_Justification_Mode to JMode_Top
98011>>>                    Set Label to "Select Table:"
98012>>>                    Set Label_Row_Offset to 1
98013>>>                    Set Entry_State to False
98014>>>
98014>>>                    Procedure OnDropDown
98017>>>                        Send DoCombo_Fill_List
98018>>>                    End_Procedure
98019>>>
98019>>>                    Procedure OnCloseUp
98022>>>                        Send Delete_Data of oSQLColumnName_cf
98023>>>                    End_Procedure
98024>>>
98024>>>                    Procedure DoCombo_Fill_List
98027>>>                        String[] sTablesArray
98028>>>                        String sDriverID
98028>>>                        Integer iCount iSize
98028>>>
98028>>>                        Send Delete_Data
98029>>>                        Get Value of oDriverID2_cf to sDriverID
98030>>>                        Get SQLUtilEnumerateTables of ghoDbUpdateFunctionLibrary sDriverID to sTablesArray
98031>>>                        Move (SizeOfArray(sTablesArray)) to iSize
98032>>>                        Decrement iSize
98033>>>                        For iCount from 0 to iSize
98039>>>>
98039>>>                            Send Combo_Add_Item sTablesArray[iCount]
98040>>>                        Loop
98041>>>>
98041>>>                    End_Procedure
98042>>>
98042>>>                    // DataFlex bug. It has been here as long as I can remember and _never_ seems to be fixed :-(
98042>>>                    // Augmented Value function.
98042>>>                    // We need to use Wincombo_x messages. Probably due to sync reasons.
98042>>>                    // When e.g. OnCloseUp is fired the data_value still holds the old value.
98042>>>                    Function Value Integer iItem Returns String
98045>>>                        String sValue
98045>>>                        Get WinCombo_Current_Item to iItem
98046>>>                        Get WinCombo_Value iItem  to sValue
98047>>>                        Function_Return sValue
98048>>>                    End_Function
98049>>>
98049>>>                End_Object
98050>>>
98050>>>                Object oSQLColumnName_cf is a ComboForm
98052>>>                    Set Size to 12 96
98053>>>                    Set Location to 134 14
98054>>>                    Set Label_Col_Offset to 0
98055>>>                    Set Label_Justification_Mode to JMode_Top
98056>>>                    Set Label to "Select Column:"
98057>>>                    Set Label_Row_Offset to 1
98058>>>                    Set Entry_State to False
98059>>>
98059>>>                    Procedure DoCombo_Fill_List
98062>>>                        String[] sColumnsArray
98063>>>                        String sTableName sDriverID
98063>>>                        Integer iCount iSize
98063>>>
98063>>>                        Send Delete_Data
98064>>>                        Get Value of oDriverID2_cf    to sDriverID
98065>>>                        Get Value of oSQLTableName_cf to sTableName
98066>>>                        Get SQLUtilEnumerateColumns of ghoDbUpdateFunctionLibrary sDriverID sTableName to sColumnsArray
98067>>>                        Move (SizeOfArray(sColumnsArray)) to iSize
98068>>>                        Decrement iSize
98069>>>                        For iCount from 0 to iSize
98075>>>>
98075>>>                            Send Combo_Add_Item sColumnsArray[iCount]
98076>>>                        Loop
98077>>>>
98077>>>                        If (iSize > 1) Begin
98079>>>                            Set Current_Item to 1
98080>>>                        End
98080>>>>
98080>>>                    End_Procedure
98081>>>
98081>>>                    Procedure OnDropDown
98084>>>                        Send DoCombo_Fill_List
98085>>>                    End_Procedure
98086>>>                End_Object
98087>>>
98087>>>                Object oSQLRenameColumnTo_fm is a Form
98089>>>                    Set Size to 12 96
98090>>>                    Set Location to 134 116
98091>>>                    Set Label_Col_Offset to 0
98092>>>                    Set Label_Justification_Mode to JMode_Top
98093>>>                    Set Label to "Rename Column To:"
98094>>>                    Set Label_Row_Offset to 1
98095>>>                    Set Value to "NewColumnName"
98096>>>                End_Object
98097>>>
98097>>>                Object oSQLRenameColumn_btn is a cRDCButtonDPI
98099>>>                    Set Size to 12 69
98100>>>                    Set Location to 134 220
98101>>>                    Set Label to "Rename Column"
98102>>>                    Set psToolTip to "Test of SQLColumnRename function"
98103>>>                    Set MultiLineState to True
98104>>>
98104>>>                    Procedure OnClick
98107>>>                        Boolean bOk
98107>>>                        Handle hTable
98107>>>                        String sTableName sColumnName sNewColumnName sDriverID
98107>>>
98107>>>                        Get Value of oSQLTableName_cf to sTableName
98108>>>                        If (sTableName = "") Begin
98110>>>                            Send Info_Box "You need to select a table first..."
98111>>>                            Procedure_Return
98112>>>                        End
98112>>>>
98112>>>                        Get Value of oSQLColumnName_cf to sColumnName
98113>>>                        If (Uppercase(sColumnName) = "RECNUM" or sColumnName = "") Begin
98115>>>                            Send Info_Box "You need to select a column (and 'RECNUM' cannot be used)"
98116>>>                            Procedure_Return
98117>>>                        End
98117>>>>
98117>>>                        Get Value of oSQLRenameColumnTo_fm to sNewColumnName
98118>>>                        If (Trim(sNewColumnName) = "") Begin
98120>>>                            Send Info_Box "You need to enter a column name to rename to..."
98121>>>                            Procedure_Return
98122>>>                        End
98122>>>>
98122>>>
98122>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98123>>>                        If (hTable = 0) Begin
98125>>>                            Send Info_Box "Sorry, no free fileslot in filelist.cfg could be found. Cannot continue changing table."
98126>>>                            Procedure_Return
98127>>>                        End
98127>>>>
98127>>>
98127>>>                        Get Value of oDriverID2_cf to sDriverID
98128>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98129>>>                        Get SqlColumnRenameByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName sNewColumnName to bOk
98130>>>                        If (bOk = True) Begin
98132>>>                            // Better delete the combo values after a successful rename as it looks odd to show the old column name...
98132>>>                            Send Delete_Data of oSQLColumnName_cf
98133>>>                            Send Info_Box ("Column" * sColumnName + ", was successfully renamed to" * sNewColumnName * "for table:" * sTableName)
98134>>>                        End
98134>>>>
98134>>>                        Else Begin
98135>>>                            Send Info_Box "Nope, that didn't work..."
98136>>>                        End
98136>>>>
98136>>>
98136>>>                    End_Procedure
98137>>>
98137>>>                End_Object
98138>>>
98138>>>                Object oSQLRemoveColumn_btn is a cRDCButtonDPI
98140>>>                    Set Size to 12 91
98141>>>                    Set Location to 134 297
98142>>>                    Set Label to "Drop Column"
98143>>>                    Set psToolTip to "Test of SQLColumnRemove function"
98144>>>                    Set psImage to "DeleteColumn1.ico"
98145>>>
98145>>>                    Procedure OnClick
98148>>>                        Boolean bOk
98148>>>                        String sTableName sColumnName sDriverID
98148>>>                        Integer iRetval
98148>>>
98148>>>                        Get Value of oDriverID2_cf              to sDriverID
98149>>>                        Get Value of oSQLTableName_cf           to sTableName
98150>>>                        Get Value of oSQLColumnName_cf          to sColumnName
98151>>>
98151>>>                        If (sTableName = "" or sColumnName = "") Begin
98153>>>                            Send Info_Box "You first need to select a table and a column."
98154>>>                            Procedure_Return
98155>>>                        End
98155>>>>
98155>>>
98155>>>                        Get YesNo_Box ("This will remove (drop) the column named:" * sColumnName * "from table:" * sTableName + ". Are you sure?") to iRetval
98156>>>                        If (iRetval <> MBR_Yes) Begin
98158>>>                            Procedure_Return
98159>>>                        End
98159>>>>
98159>>>
98159>>>                        Get SqlColumnRemoveByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName to bOk
98160>>>
98160>>>                        If (bOk = True) Begin
98162>>>                            // Better delete the combo values after a successful operation as it looks odd to show the old column name...
98162>>>                            Send Delete_Data of oSQLColumnName_cf
98163>>>                            Send Info_Box ("Column" * sColumnName + ", was successfully removed")
98164>>>                        End
98164>>>>
98164>>>                        Else Begin
98165>>>                            Send Info_Box ("The column could NOT be removed. Either the column" * sColumnName * "doesn't exists or the current Database is incorrect?")
98166>>>                            Procedure_Return
98167>>>                        End
98167>>>>
98167>>>
98167>>>                    End_Procedure
98168>>>
98168>>>                End_Object
98169>>>
98169>>>                Object oSQLAddColumnName_fm is a Form
98171>>>                    Set Size to 12 96
98172>>>                    Set Location to 177 14
98173>>>                    Set Label_Col_Offset to 0
98174>>>                    Set Label_Justification_Mode to JMode_Top
98175>>>                    Set Label to "Column Name:"
98176>>>                    Set Label_Row_Offset to 1
98177>>>                    Set Value to "NewColumn"
98178>>>                End_Object
98179>>>
98179>>>                Object oSQLColumnType_cf is a ComboForm
98181>>>                    Set Size to 12 96
98182>>>                    Set Location to 177 116
98183>>>                    Set Label_Col_Offset to 0
98184>>>                    Set Label_Justification_Mode to JMode_Top
98185>>>                    Set Label_Row_Offset to 1
98186>>>                    Set Label to "Type:"
98187>>>                    Set Entry_State to False
98188>>>
98188>>>                    Procedure Combo_Fill_List
98191>>>                        tColumnType[] ColumnTypeArray
98191>>>                        tColumnType[] ColumnTypeArray
98192>>>                        Integer iSize iCount iDbType
98192>>>                        String sDriverID
98192>>>
98192>>>                        Send Delete_Data
98193>>>                        Get Value of oDriverID2_cf to sDriverID
98194>>>                        Get piDbType of ghoDbUpdateFunctionLibrary to iDbType
98195>>>                        Get UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary sDriverID iDbType to ColumnTypeArray
98196>>>                        Move (SizeOfArray(ColumnTypeArray)) to iSize
98197>>>                        Decrement iSize
98198>>>                        For iCount from 0 to iSize
98204>>>>
98204>>>                            Send Combo_Add_Item ColumnTypeArray[iCount].sSQLType
98205>>>                        Loop
98206>>>>
98206>>>                        If (iSize > 0) Begin
98208>>>                            Set Value to ColumnTypeArray[0].sSQLType
98209>>>                        End
98209>>>>
98209>>>                    End_Procedure
98210>>>
98210>>>                    Procedure OnChange
98213>>>                        Integer iType iSize iDec
98213>>>                        tSQLConnection SQLConnection
98213>>>                        tSQLConnection SQLConnection
98213>>>                        Boolean bFixed
98213>>>
98213>>>                        Get SelectedType to iType
98214>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98215>>>                        Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to iSize
98216>>>                        Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to iDec
98217>>>                        Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to bFixed
98218>>>
98218>>>                        Set Enabled_State of oSQLLength_sf   to (bFixed = False)
98219>>>                        Set Enabled_State of oSQLDecimals_sf to (bFixed = False)
98220>>>                        Set Value         of oSQLLength_sf   to iSize
98221>>>                        If (iDec = 0) Begin
98223>>>                            Set Value     of oSQLDecimals_sf to ""
98224>>>                        End
98224>>>>
98224>>>                        Else Begin
98225>>>                            Set Value     of oSQLDecimals_sf to iDec
98226>>>                        End
98226>>>>
98226>>>                        If (bFixed = False) Begin
98228>>>                            Set Enabled_State of oSQLDecimals_sf to (iDec <> 0)
98229>>>                        End
98229>>>>
98229>>>                    End_Procedure
98230>>>
98230>>>                    Function SelectedType Returns Integer
98233>>>                        String sValue sDriverID
98233>>>                        Integer iType iDbType
98233>>>
98233>>>                        Get Value to sValue
98234>>>                        Get psDriverID of ghoSQLConnectionHandler to sDriverID
98235>>>                        Get piDbType   of ghoSQLConnectionHandler to iDbType
98236>>>                        Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary sDriverID iDbType sValue to iType
98237>>>
98237>>>                        Function_Return iType
98238>>>                    End_Function
98239>>>
98239>>>                End_Object
98240>>>
98240>>>                Object oSQLAddColumn_btn is a cRDCButtonDPI
98242>>>                    Set Size to 12 69
98243>>>                    Set Location to 177 220
98244>>>                    Set Label to "Add Column"
98245>>>                    Set psToolTip to "Test of SQLColumnAdd function"
98246>>>                    Set psImage to "AddColumn1.ico"
98247>>>
98247>>>                    Procedure OnClick
98250>>>                        Boolean bOk bInitialize
98250>>>                        Handle hTable
98250>>>                        String sTableName sColumnName sType sColumnValue sDriverID
98250>>>                        Integer iType iLength iDecimals
98250>>>
98250>>>                        Get Value of oDriverID2_cf              to sDriverID
98251>>>                        Get Value of oSQLTableName_cf           to sTableName
98252>>>                        Get Value of oSQLAddColumnName_fm       to sColumnName
98253>>>                        Get SelectedType  of oSQLColumnType_cf  to iType
98254>>>                        Get Value         of oSQLColumnType_cf  to sType
98255>>>                        Get Checked_State of oSQLInitializeColumnValue_cb to bInitialize
98256>>>                        Get Value         of oSQLColumnValue_fm to sColumnValue
98257>>>                        Get Value         of oSQLLength_sf      to iLength
98258>>>                        Get Value         of oSQLDecimals_sf    to iDecimals
98259>>>
98259>>>                        If (sTableName <> "") Begin
98261>>>                            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98262>>>                            If (hTable = 0) Begin
98264>>>                                Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98265>>>                            End
98265>>>>
98265>>>                        End
98265>>>>
98265>>>                        If (hTable = 0) Begin
98267>>>                            Send Info_Box "You first need to select a table before you can add a column to it."
98268>>>                            Procedure_Return
98269>>>                        End
98269>>>>
98269>>>                        If (sColumnName = "") Begin
98271>>>                            Send Info_Box "You need to enter a column name"
98272>>>                            Procedure_Return
98273>>>                        End
98273>>>>
98273>>>
98273>>>                        Get SqlColumnAddByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName iType iLength iDecimals bInitialize sColumnValue to bOk
98274>>>
98274>>>                        If (bOk = True) Begin
98276>>>                            Send Info_Box ("New column" * sColumnName * sType * String(iLength) + ", was successfully added to" * sTableName)
98277>>>                        End
98277>>>>
98277>>>                        Else Begin
98278>>>                            Send Info_Box ("The column could NOT be added. Either column" * sColumnName * "already exists or the current Database is incorrect?")
98279>>>                            Procedure_Return
98280>>>                        End
98280>>>>
98280>>>
98280>>>                    End_Procedure
98281>>>
98281>>>                End_Object
98282>>>
98282>>>//                Object oTest_btn is a cRDCButtonDPI
98282>>>//                    Set Size to 13 92
98282>>>//                    Set Location to 177 298
98282>>>//                    Set Label to "Test SQL script button"
98282>>>//
98282>>>//                    Procedure OnClick
98282>>>//                        Boolean bOK
98282>>>//                        String sTableName sColumnName
98282>>>//
98282>>>//                        Get Value of oSQLTableName_cf      to sTableName
98282>>>//                        Get Value of oSQLAddColumnName_fm  to sColumnName
98282>>>////                        Get SqlUtilDefaultConstraintsMSSQL of ghoDbUpdateFunctionLibrary sTableName sColumnName to bOK
98282>>>//
98282>>>//                    End_Procedure
98282>>>//
98282>>>//                End_Object
98282>>>
98282>>>                Object oSQLLength_sf is a SpinForm
98284>>>                    Set Label to "Length:"
98285>>>                    Set Size to 12 40
98286>>>                    Set Location to 202 16
98287>>>                    Set Label_Col_Offset to 0
98288>>>                    Set Label_Justification_Mode to JMode_Top
98289>>>                    Set Label_Row_Offset to 1
98290>>>                    Set Value to "10"
98291>>>                    Set Maximum_Position to 500
98292>>>                    Set Minimum_Position to 1
98293>>>                End_Object
98294>>>
98294>>>                Object oSQLDecimals_sf is a SpinForm
98296>>>                    Set Label to "Decimals:"
98297>>>                    Set Size to 12 33
98298>>>                    Set Location to 202 60
98299>>>                    Set Label_Col_Offset to 0
98300>>>                    Set Label_Justification_Mode to JMode_Top
98301>>>                    Set Label_Row_Offset to 1
98302>>>                    Set Value to "0"
98303>>>                    Set Maximum_Position to 16
98304>>>                    Set Minimum_Position to 1
98305>>>                End_Object
98306>>>
98306>>>                Object oSQLInitializeColumnValue_cb is a CheckBox
98308>>>                    Set Size to 12 85
98309>>>                    Set Location to 202 116
98310>>>                    Set Label to "Initialize Column Value"
98311>>>
98311>>>                    Procedure OnChange
98314>>>                        Boolean bChecked
98314>>>
98314>>>                        Get Checked_State to bChecked
98315>>>                        Set Enabled_State of oSQLColumnValue_fm to bChecked
98316>>>                    End_Procedure
98317>>>
98317>>>                End_Object
98318>>>
98318>>>                Object oSQLColumnValue_fm is a Form
98320>>>                    Set Size to 12 96
98321>>>                    Set Location to 218 116
98322>>>                    Set Label_Col_Offset to 2
98323>>>                    Set Label_Justification_Mode to JMode_Right
98324>>>                    Set Label to "Column Value"
98325>>>                    Set psToolTip to "When a new column is added the new column can be initialized with a value for all existing records."
98326>>>                    Set Enabled_State to False
98327>>>                End_Object
98328>>>
98328>>>                Object oEnumRelations_btn is a cRDCButtonDPI
98330>>>                    Set Size to 12 91
98331>>>                    Set Location to 116 297
98332>>>                    Set Label to "Test Enum SQL Relations"
98333>>>
98333>>>                    Procedure OnClick
98336>>>                        tSQLRelation[] SQLRelationArray
98336>>>                        tSQLRelation[] SQLRelationArray
98337>>>                        String sTableName sDriverID
98337>>>                        Integer iSize iCount
98337>>>
98337>>>                        Get Value of oDriverID2_cf to sDriverID
98338>>>                        Get Value of oSQLTableName_cf to sTableName
98339>>>                        Get SqlUtilEnumerateRelations of ghoDbUpdateFunctionLibrary sTableName sDriverID to SQLRelationArray
98340>>>                        Move (SizeOfArray(SQLRelationArray)) to iSize
98341>>>                        Decrement iSize
98342>>>                        For iCount from 0 to iSize
98348>>>>
98348>>>                            Showln "Tablename.FieldName = " SQLRelationArray[iCount].sFileName "." SQLRelationArray[iCount].sFieldName " Number: " SQLRelationArray[iCount].iFileNumber "." SQLRelationArray[iCount].iFieldNumber
98357>>>                        Loop
98358>>>>
98358>>>                        If (iSize < 1) Begin
98360>>>                            Send Info_Box ("No SQL Foreign keys found for table:" * sTableName)
98361>>>                        End
98361>>>>
98361>>>
98361>>>                    End_Procedure
98362>>>
98362>>>                End_Object
98363>>>
98363>>>                Object oEnumerateLoggedInUsers is a cRDCButtonDPI
98365>>>                    Set Size to 12 101
98366>>>                    Set Location to 177 297
98367>>>                    Set Label to "Enumerate Logged In Users"
98368>>>
98368>>>                    Procedure OnClick
98371>>>                        tSQLLoggedInUser[] SQLLoggedInUser
98371>>>                        tSQLLoggedInUser[] SQLLoggedInUser
98372>>>                        String sDriverID sDatabase
98372>>>                        Integer iSize iCount
98372>>>
98372>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98373>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase
98374>>>                        Get SqlUtilEnumerateLoggedInUsers of ghoDbUpdateFunctionLibrary sDriverID sDatabase to SQLLoggedInUser
98375>>>                        Move (SizeOfArray(SQLLoggedInUser)) to iSize
98376>>>                        Decrement iSize
98377>>>
98377>>>                        Showln "SQL User Name" " and Program:"
98380>>>                        For iCount from 0 to iSize
98386>>>>
98386>>>                            Showln SQLLoggedInUser[iCount].sUser " " SQLLoggedInUser[iCount].sProgram
98390>>>                        Loop
98391>>>>
98391>>>                    End_Procedure
98392>>>
98392>>>                End_Object
98393>>>
98393>>>                Object oEnumerateTablesAndViews is a cRDCButtonDPI
98395>>>                    Set Size to 12 101
98396>>>                    Set Location to 193 297
98397>>>                    Set Label to "Is Table or View?"
98398>>>
98398>>>                    Procedure OnClick
98401>>>                        String sDriverID sTableName
98401>>>                        Handle hTable
98401>>>                        Boolean bViewTableType
98401>>>
98401>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98402>>>                        Get Value of oSQLTableName_cf to sTableName
98403>>>                        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98404>>>                        If (hTable = 0) Begin
98406>>>                            Procedure_Return
98407>>>                        End
98407>>>>
98407>>>                        Get SQLUtilTableIsViewType of ghoDbUpdateFunctionLibrary sDriverID hTable to bViewTableType
98408>>>                        Send Info_Box ("The table" * sTableName * "is a" * If(bViewTableType = True, "View Table Type", "Standard Table (not view)"))
98409>>>                    End_Procedure
98410>>>
98410>>>                End_Object
98411>>>
98411>>>            End_Object
98412>>>
98412>>>        End_Object
98413>>>
98413>>>    End_Object
98414>>>
98414>>>End_Object
98415>        Use APIFunctions.vw
Including file: APIFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\APIFunctions.vw)
98415>>>Use Windows.pkg
98415>>>Use DFClient.pkg
98415>>>Use Dfspnfrm.pkg
98415>>>Use Dfline.pkg
98415>>>Use cDbScrollingContainer.pkg
98415>>>Use cRDCButtonDPI.pkg
98415>>>Use cDbUpdateFunctionLibrary.pkg
98415>>>
98415>>>Define CI_Table1_FileNo for 401
98415>>>Define CI_View1_FileNo  for 402
98415>>>
98415>>>Activate_View Activate_oAPIFunctions_vw for oAPIFunctions_vw
98425>>>>
98425>>>Object oAPIFunctions_vw is a dbView
98427>>>    Set Border_Style to Border_Thick
98428>>>    Set Size to 237 424
98429>>>    Set Location to 17 2
98430>>>    Set Label to "API Functions"
98431>>>    Set pbAutoActivate to True
98432>>>    Set Icon to "APIFunctions1.ico"
98433>>>
98433>>>    Property String psTableName ""
98435>>>
98435>>>    Procedure OnSetFocus
98438>>>        String sValue
98438>>>        tSQLConnection SQLConnection
98438>>>        tSQLConnection SQLConnection
98438>>>
98438>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98439>>>        Set Value of oApiDatabase_fm to SQLConnection.sDatabase
98440>>>        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
98441>>>        Set Value of oApiConnectionString_fm to sValue
98442>>>    End_Procedure
98443>>>
98443>>>    Object oScrollingContainer1 is a cDbScrollingContainer
98445>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
98447>>>
98447>>>            Object oApiFunctions_grp is a Group
98449>>>                Set Size to 222 402
98450>>>                Set Location to 6 12
98451>>>                Set Label to "Tests: Change MS-SQL Database with Database API Functions"
98452>>>                Set peAnchors to anAll
98453>>>
98453>>>                Object oApiConnectionString_fm is a Form
98455>>>                    Set Size to 12 368
98456>>>                    Set Location to 23 14
98457>>>                    Set Label to "Current Connection String Settings:"
98458>>>                    Set Label_Col_Offset to 0
98459>>>                    Set Label_Justification_Mode to JMode_Top
98460>>>                    Set peAnchors to anTopLeftRight
98461>>>                    Set Enabled_State to False
98462>>>                    Set Label_Row_Offset to 1
98463>>>                End_Object
98464>>>
98464>>>                Object oApiDatabase_fm is a Form
98466>>>                    Set Size to 12 86
98467>>>                    Set Location to 50 14
98468>>>                    Set Label to "Database:"
98469>>>                    Set Label_Col_Offset to 0
98470>>>                    Set Label_Justification_Mode to JMode_Top
98471>>>                    Set Label_Row_Offset to 1
98472>>>                    Set Enabled_State to False
98473>>>                    Set FontWeight to fw_Bold
98474>>>//                    Set Label_FontWeight to fw_Bold
98474>>>
98474>>>                    Procedure Page Integer iPageObject
98477>>>                        String sValue
98477>>>                        Get psDatabase of ghoSQLConnectionHandler to sValue
98478>>>                        Set Value to sValue
98479>>>
98479>>>                        Forward Send Page iPageObject
98481>>>                    End_Procedure
98482>>>
98482>>>                End_Object
98483>>>
98483>>>                Object oDriverID3_cf is a ComboForm
98485>>>                    Set Size to 12 91
98486>>>                    Set Location to 51 121
98487>>>                    Set Label_Col_Offset to 0
98488>>>                    Set Label_Justification_Mode to JMode_Top
98489>>>                    Set Label to "Driver ID:"
98490>>>                    Set Entry_State to False
98491>>>                    Set Enabled_State to False
98492>>>                    Set Label_Row_Offset to 1
98493>>>                    Set Enabled_State to False
98494>>>
98494>>>                    Procedure Combo_Fill_List
98497>>>                        Send Combo_Add_Item MSSQLDRV_ID
98498>>>                        Send Combo_Add_Item DB2_DRV_ID
98499>>>                        Send Combo_Add_Item ODBC_DRV_ID
98500>>>                    End_Procedure
98501>>>
98501>>>                    Procedure Refresh
98504>>>                        String sValue
98504>>>
98504>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
98505>>>                        Set Value to sValue
98506>>>                    End_Procedure
98507>>>
98507>>>                End_Object
98508>>>
98508>>>                Object oDatabaseInfo_tb is a TextBox
98510>>>                    Set Auto_Size_State to False
98511>>>                    Set Size to 25 96
98512>>>                    Set Location to 64 14
98513>>>                    Set Label to "(Change database on the SQL Connections tabpage)"
98514>>>                    Set Justification_Mode to JMode_Left
98515>>>                End_Object
98516>>>
98516>>>                Object oApiTableName_fm is a Form
98518>>>                    Set Size to 12 77
98519>>>                    Set Location to 114 14
98520>>>                    Set Label_Col_Offset to 0
98521>>>                    Set Label_Justification_Mode to JMode_Top
98522>>>                    Set Label to "Table Name:"
98523>>>                    Set Label_Row_Offset to 1
98524>>>                    Set Value to "NewTable"
98525>>>                    Procedure OnChange
98528>>>                        String sValue
98528>>>                        Get Value to sValue
98529>>>                        Set psTableName to sValue
98530>>>                    End_Procedure
98531>>>                    Send OnChange
98532>>>                End_Object
98533>>>
98533>>>                Object oApiAddNewTable_btn is a cRDCButtonDPI
98535>>>                    Set Size to 12 69
98536>>>                    Set Location to 114 271
98537>>>                    Set Label to "Add Table"
98538>>>                    Set psImage to "ActionAddTable1.ico"
98539>>>
98539>>>                    Procedure OnClick
98542>>>                        Boolean bOk
98542>>>                        Handle hTable
98542>>>                        String sTableName sDriverID
98542>>>
98542>>>                        Get Value of oDriverID3_cf to sDriverID
98543>>>                        Get Value of oApiTableName_fm to sTableName
98544>>>                        Move (Trim(sTableName)) to sTableName
98545>>>                        If (sTableName = "") Begin
98547>>>                            Send Info_Box "You first need to enter a table name."
98548>>>                            Procedure_Return
98549>>>                        End
98549>>>>
98549>>>
98549>>>                        Send Cursor_Wait of Cursor_Control
98550>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98551>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98552>>>                        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True to bOk
98553>>>                        If (bOk = True) Begin
98555>>>                            Send Info_Box ("Test table" * sTableName * "was successfully created and put in filelist slot:" * String(hTable))
98556>>>                        End
98556>>>>
98556>>>                        Else Begin
98557>>>                            Send Cursor_Ready of Cursor_Control
98558>>>                            Send Info_Box ("Nope, the test table" * sTableName * "could not be created, or does it already exist?") "Error"
98559>>>                            Procedure_Return
98560>>>                        End
98560>>>>
98560>>>
98560>>>                    End_Procedure
98561>>>
98561>>>                End_Object
98562>>>
98562>>>                Object oApiAddColumn_fm is a Form
98564>>>                    Set Size to 12 77
98565>>>                    Set Location to 141 14
98566>>>                    Set Label_Col_Offset to 0
98567>>>                    Set Label_Justification_Mode to JMode_Top
98568>>>                    Set Label to "Column Name:"
98569>>>                    Set Label_Row_Offset to 1
98570>>>                    Set Value to "NewColumn"
98571>>>                End_Object
98572>>>
98572>>>                Object oApiColumnType_cf is a ComboForm
98574>>>                    Set Size to 12 85
98575>>>                    Set Location to 141 96
98576>>>                    Set Label_Col_Offset to 0
98577>>>                    Set Label_Justification_Mode to JMode_Top
98578>>>                    Set Label_Row_Offset to 1
98579>>>                    Set Label to "Type:"
98580>>>                    Set Entry_State to False
98581>>>
98581>>>                    Procedure Combo_Fill_List
98584>>>                        tColumnType[] ColumnTypeArray
98584>>>                        tColumnType[] ColumnTypeArray
98585>>>                        Integer iSize iCount
98585>>>
98585>>>                        Send Delete_Data
98586>>>                        Get UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex to ColumnTypeArray
98587>>>                        Move (SizeOfArray(ColumnTypeArray)) to iSize
98588>>>                        Decrement iSize
98589>>>                        For iCount from 0 to iSize
98595>>>>
98595>>>                            Send Combo_Add_Item ColumnTypeArray[iCount].sSQLType
98596>>>                        Loop
98597>>>>
98597>>>                        Set Value to ColumnTypeArray[0].sSQLType
98598>>>                    End_Procedure
98599>>>
98599>>>                    Procedure OnChange
98602>>>                        Integer iType iSize iDec
98602>>>                        tSQLConnection SQLConnection
98602>>>                        tSQLConnection SQLConnection
98602>>>                        Boolean bFixed
98602>>>
98602>>>                        Get SelectedType to iType
98603>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98604>>>                        Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to iSize
98605>>>                        Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to iDec
98606>>>                        Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to bFixed
98607>>>
98607>>>                        Set Enabled_State of oApiLength_sf   to (bFixed = False)
98608>>>                        Set Enabled_State of oApiDecimals_sf to (bFixed = False)
98609>>>                        Set Value         of oApiLength_sf   to iSize
98610>>>                        If (iDec = 0) Begin
98612>>>                            Set Value     of oApiDecimals_sf to ""
98613>>>                        End
98613>>>>
98613>>>                        Else Begin
98614>>>                            Set Value     of oApiDecimals_sf to iDec
98615>>>                        End
98615>>>>
98615>>>                        If (bFixed = False) Begin
98617>>>                            Set Enabled_State of oApiDecimals_sf to (iDec <> 0)
98618>>>                        End
98618>>>>
98618>>>                    End_Procedure
98619>>>
98619>>>                    Function SelectedType Returns Integer
98622>>>                        String sValue
98622>>>                        Integer iType
98622>>>
98622>>>                        Get Value to sValue
98623>>>                        Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex sValue to iType
98624>>>
98624>>>                        Function_Return iType
98625>>>                    End_Function
98626>>>
98626>>>                End_Object
98627>>>
98627>>>                Object oApiLength_sf is a SpinForm
98629>>>                    Set Label to "Length:"
98630>>>                    Set Size to 12 35
98631>>>                    Set Location to 141 186
98632>>>                    Set Label_Col_Offset to 0
98633>>>                    Set Label_Justification_Mode to JMode_Top
98634>>>                    Set Label_Row_Offset to 1
98635>>>                    Set Value to "10"
98636>>>                    Set Maximum_Position to 500
98637>>>                    Set Minimum_Position to 1
98638>>>                End_Object
98639>>>
98639>>>                Object oApiDecimals_sf is a SpinForm
98641>>>                    Set Label to "Decimals:"
98642>>>                    Set Size to 12 33
98643>>>                    Set Location to 141 225
98644>>>                    Set Label_Col_Offset to 0
98645>>>                    Set Label_Justification_Mode to JMode_Top
98646>>>                    Set Label_Row_Offset to 1
98647>>>                    Set Value to "0"
98648>>>                    Set Maximum_Position to 16
98649>>>                    Set Minimum_Position to 1
98650>>>                End_Object
98651>>>
98651>>>                Object oApiAddColumn_btn is a cRDCButtonDPI
98653>>>                    Set Size to 12 69
98654>>>                    Set Location to 141 271
98655>>>                    Set Label to "Add Column"
98656>>>                    Set psToolTip to "ApiColumnAdd function"
98657>>>                    Set psImage to "ActionAddColumn1.ico"
98658>>>
98658>>>                    Procedure OnClick
98661>>>                        Boolean bOk
98661>>>                        Handle hTable
98661>>>                        String sTableName sColumnName sType sDriverID
98661>>>                        Integer iType iLength iDecimals
98661>>>
98661>>>                        Get Value of oDriverID3_cf            to sDriverID
98662>>>                        Get Value of oApiTableName_fm         to sTableName
98663>>>                        Get Value of oApiAddColumn_fm         to sColumnName
98664>>>                        Get SelectedType of oApiColumnType_cf to iType
98665>>>                        Get Value        of oApiLength_sf     to iLength
98666>>>                        Get Value        of oApiDecimals_sf   to iDecimals
98667>>>
98667>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98668>>>                        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98669>>>                        If (hTable = 0) Begin
98671>>>                            Send Info_Box "You first need to create the new table by pressing the 'Create New Table...' button, before you can add a column to it."
98672>>>                            Procedure_Return
98673>>>                        End
98673>>>>
98673>>>                        If (sColumnName = "") Begin
98675>>>                            Send Info_Box "You need to enter a column name"
98676>>>                            Procedure_Return
98677>>>                        End
98677>>>>
98677>>>
98677>>>                        Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable sColumnName iType iLength iDecimals to bOk
98678>>>                        If (bOk = True) Begin
98680>>>                            Send Info_Box ("Column" * sColumnName * sType * String(iLength) + ", was successfully added to" * sTableName * "(at filelist slot:" * String(hTable) + ")")
98681>>>                        End
98681>>>>
98681>>>                        Else Begin
98682>>>                            Send Info_Box ("The column could NOT be added. Either column" * sColumnName * "already exists or the current Database is incorrect?")
98683>>>                            Procedure_Return
98684>>>                        End
98684>>>>
98684>>>
98684>>>                    End_Procedure
98685>>>
98685>>>                End_Object
98686>>>
98686>>>                Object oApiAddTableAndColumns_btn is a cRDCButtonDPI
98688>>>                    Set Size to 26 77
98689>>>                    Set Location to 184 14
98690>>>                    Set Label to "Create 'New' Table with Three Columns"
98691>>>                    Set MultiLineState to True
98692>>>                    Set psImage to "ActionAddTable1.ico"
98693>>>
98693>>>                    Procedure OnClick
98696>>>                        Boolean bOk
98696>>>                        Handle hTable
98696>>>                        String sTableName sDriverID
98696>>>
98696>>>                        Get Value of oDriverID3_cf to sDriverID
98697>>>                        Get Value of oApiTableName_fm to sTableName
98698>>>                        Move (Trim(sTableName)) to sTableName
98699>>>                        If (sTableName = "") Begin
98701>>>                            Send Info_Box "You first need to enter a table name."
98702>>>                            Procedure_Return
98703>>>                        End
98703>>>>
98703>>>
98703>>>                        Send Cursor_Wait of Cursor_Control
98704>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98705>>>
98705>>>                        Set psDriverID       of ghoDbUpdateFunctionLibrary to sDriverID
98706>>>                        Get ApiTableCreate   of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True to bOk
98707>>>                        If (bOk = True) Begin
98709>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col1Ascii"   DF_ASCII 10 0 to bOk
98710>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col2Date"    DF_DATE   6 0 to bOk
98711>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col3Numeric" DF_BCD    6 2 to bOk
98712>>>                        End
98712>>>>
98712>>>                        Send Cursor_Ready of Cursor_Control
98713>>>
98713>>>                        If (bOk = True) Begin
98715>>>                            Send Info_Box ("Test table" * sTableName * "with Columns: 'Col1 ASCII 10', 'Col2 Date' and 'Col3 Numeric 6,2' was successfully created and put in filelist slot:" * String(CI_Table1_FileNo))
98716>>>                        End
98716>>>>
98716>>>                        Else Begin
98717>>>                            Send Cursor_Ready of Cursor_Control
98718>>>                            Send Info_Box ("Nope, the test table" * sTableName * "could not be created") "Error"
98719>>>                            Procedure_Return
98720>>>                        End
98720>>>>
98720>>>
98720>>>                    End_Procedure
98721>>>
98721>>>                End_Object
98722>>>
98722>>>                Object oApiRemoveTable_btn is a cRDCButtonDPI
98724>>>                    Set Size to 26 77
98725>>>                    Set Location to 184 96
98726>>>                    Set Label to "Remove 'New' Table"
98727>>>                    Set psImage to "ActionDeleteTable1.ico"
98728>>>                    Set MultiLineState to True
98729>>>
98729>>>                    Procedure OnClick
98732>>>                        Boolean bOk
98732>>>                        Integer iRetval
98732>>>                        Handle hTable
98732>>>                        String sTableName sDriverID
98732>>>
98732>>>                        Get Value of oDriverID3_cf to sDriverID
98733>>>                        Get Value of oApiTableName_fm to sTableName
98734>>>                        Get YesNo_Box ("Are you sure you want to PERMANENTLY DELETE the table named:" * String(sTableName) + "?") to iRetval
98735>>>                        If (iRetval = MBR_Yes) Begin
98737>>>                            Send Cursor_Wait of Cursor_Control
98738>>>                            Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98739>>>                            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98740>>>                            Get ApiTableRemove of ghoDbUpdateFunctionLibrary hTable to bOk
98741>>>                            Send Cursor_Ready of Cursor_Control
98742>>>                            If (bOk = True) Begin
98744>>>                                Send Info_Box "Table removed"
98745>>>                            End
98745>>>>
98745>>>                            Else Begin
98746>>>                                Send Info_Box "Nope, that didnt' work. Either the table doesn't exist or your rights aren't sufficient."
98747>>>                            End
98747>>>>
98747>>>                        End
98747>>>>
98747>>>                    End_Procedure
98748>>>
98748>>>                End_Object
98749>>>
98749>>>                Object oLineControl1 is a LineControl
98751>>>                    Set Size to 2 387
98752>>>                    Set Location to 96 6
98753>>>                    Set peAnchors to anTopLeftRight
98754>>>                End_Object
98755>>>
98755>>>                Object oLineControl2 is a LineControl
98757>>>                    Set Size to 3 248
98758>>>                    Set Location to 171 9
98759>>>                End_Object
98760>>>
98760>>>                Object oTestError_fm is a Form
98762>>>                    Set Size to 13 64
98763>>>                    Set Location to 186 180
98764>>>                    Set Form_Datatype to 0 
98765>>>                    On_Key kEnter send KeyAction of oFindErrorText_Btn
98766>>>                End_Object
98767>>>
98767>>>Register_Function FetchErrorDescription Integer iError Returns String
98767>>>                Object oFindErrorText_Btn is a Button
98769>>>                    Set Size to 13 70
98770>>>                    Set Location to 186 248
98771>>>                    Set Label to "Find Error Text"
98772>>>                
98772>>>                    Procedure OnClick
98775>>>                        String sRetval
98775>>>                        Integer iError 
98775>>>                        Handle hoLogFile
98775>>>                        
98775>>>                        Get phoLogFile of ghoDbUpdateFunctionLibrary to hoLogFile
98776>>>                        Get Value of oTestError_fm to iError
98777>>>                        Get FetchErrorDescription of hoLogFile iError to sRetval 
98778>>>                        Set Value of oErrorText_fm to sRetval    
98779>>>                    End_Procedure
98780>>>                
98780>>>                End_Object
98781>>>
98781>>>                Object oErrorText_fm is a Form
98783>>>                    Set Size to 13 213
98784>>>                    Set Location to 202 180
98785>>>                End_Object
98786>>>
98786>>>            End_Object
98787>>>
98787>>>        End_Object
98788>>>
98788>>>    End_Object
98789>>>
98789>>>End_Object
98790>        Use UtilFunctions.vw
Including file: UtilFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\UtilFunctions.vw)
98790>>>Use Windows.pkg
98790>>>Use DFClient.pkg
98790>>>Use Dfline.pkg
98790>>>Use cDbScrollingContainer.pkg
98790>>>Use cRDCButtonDPI.pkg
98790>>>Use cDbUpdateFunctionLibrary.pkg
98790>>>Use Dftreevw.pkg
98790>>>Use Working.pkg
Including file: Working.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Working.pkg)
98790>>>>>// COPYRIGHT (c) 2003-2017 RDC Tools International
98790>>>>>//
98790>>>>>// This program is free software; you can redistribute it and/or
98790>>>>>// modify it under the terms of the GNU General Public License
98790>>>>>// as published by the Free Software Foundation; version 2
98790>>>>>// of the License.
98790>>>>>
98790>>>>>// This program is distributed in the hope that it will be useful,
98790>>>>>// but WITHOUT ANY WARRANTY; without even the implied warranty of
98790>>>>>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
98790>>>>>// GNU General Public License for more details.
98790>>>>>
98790>>>>>// You should have received a copy of the GNU General Public License
98790>>>>>// along with this program; (See the GPL.txt file in the Help directory) if not, write to the Free Software
98790>>>>>// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
98790>>>>>Use Windows.pkg
98790>>>>>
98790>>>>>Object oWorkingMessagePanel is a ToolPanel
98792>>>>>    Set Label    to "Working"
98793>>>>>    Set Size to 48 150
98794>>>>>    Set Locate_Mode to CENTER_ON_PARENT
98795>>>>>    Set Popup_State to True
98796>>>>>
98796>>>>>    Object oWorkingMessage is a Textbox
98798>>>>>        Set Label to "Working message..."
98799>>>>>        Set Location to 15 5
98800>>>>>        Set Size to 27 123
98801>>>>>        Set Auto_Size_State to False
98802>>>>>        Set Justification_Mode to JMode_Center
98803>>>>>        Set FontWeight to fw_Bold
98804>>>>>    End_Object
98805>>>>>
98805>>>>>End_Object
98806>>>>>
98806>>>>>Procedure StartWorkingMessage Global String sText
98808>>>>>    Send Close_Panel of (oWorkingMessagePanel(Self))
98809>>>>>    Set Label  of (oWorkingMessage(oWorkingMessagePanel(Self))) to sText
98810>>>>>    Send Popup of (oWorkingMessagePanel(Self))
98811>>>>>End_Procedure
98812>>>>>
98812>>>>>Procedure StopWorkingMessage Global
98814>>>>>    Send Close_Panel of (oWorkingMessagePanel(Self))
98815>>>>>End_Procedure
98816>>>Use DUFStatusPanel.pkg
98816>>>Use cCharTranslate.pkg
98816>>>
98816>>>Struct tFilelistDUF
98816>>>    Integer iFileNumber
98816>>>    String sLogicalName
98816>>>    String sRootName
98816>>>    String sDisplayName
98816>>>End_Struct
98816>>>
98816>>>Activate_View Activate_oUtilFunctions_vw for oUtilFunctions_vw
98826>>>>
98826>>>Object oUtilFunctions_vw is a dbView
98828>>>    Set Border_Style to Border_Thick
98829>>>    Set Size to 291 428
98830>>>    Set Location to 2 1
98831>>>    Set Label to "Utility Functions"
98832>>>    Set pbAutoActivate to True
98833>>>    Set Icon to "TestTools1.ico"
98834>>>    Set pbAcceptDropFiles to True
98835>>>
98835>>>    Object oScrollingContainer1 is a cDbScrollingContainer
98837>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
98839>>>
98839>>>            Object oSQL_grp is a Group
98841>>>                Set Size to 88 402
98842>>>                Set Location to 7 12
98843>>>                Set Label to "Run SQL Database Scripts Embedded as Resources"
98844>>>                Set peAnchors to anTopLeftRight
98845>>>
98845>>>                Object oCreateOrderEntry_btn is a cRDCButtonDPI
98847>>>                    Set Size to 14 219
98848>>>                    Set Location to 13 13
98849>>>                    Set Label to "Create New SQL Database [OrderEntry] Complete with Data"
98850>>>                    Set psToolTip to "Creates the full Order Entry Sample database from the DataFlex samples complete with data with the name: [OrderEntry]"
98851>>>                    Set psImage to "ActionCreateDatabase1.ico"
98852>>>
98852>>>                    Procedure OnClick
98855>>>                        String sInfoText sDriverID
98855>>>                        Boolean bOK
98855>>>                        TimeSpan tsTotalQueryTime
98855>>>                        Integer iRetval
98855>>>
98855>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98855>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98855>>>                        SQLIncludeScriptFile ..\Scripts\CreateOrderEntry.sql as CreateOrderEntry.sql
98855>>>                        Get YesNo_Box "This will run the 'CreateOrderEntry.sql' script from the 'Script' workspace folder which will create the [OrderEntry] database from the DataFlex samples for Microsoft SQL Server, complete with data. If it exists it will first be dropped, then re-created and populated with new data. Continue?" to iRetval
98856>>>                        If (iRetval <> MBR_Yes) Begin
98858>>>                            Procedure_Return
98859>>>                        End
98859>>>>
98859>>>
98859>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98860>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
98862>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
98863>>>                            Procedure_Return
98864>>>                        End
98864>>>>
98864>>>
98864>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
98865>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateOrderEntry.sql" MSSQLDRV_ID False to bOK
98866>>>                        Send StopWorkingMessage
98867>>>
98867>>>                        If (bOK = True) Begin
98869>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98870>>>                            Move ("Success! DataFlex Order Entry Sample Database was created as [OrderEntry]. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98871>>>                        End
98871>>>>
98871>>>
98871>>>                        Else Begin
98872>>>                            Send UtilShowErrorList of ghoDbUpdateFunctionLibrary
98873>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98874>>>                        End
98874>>>>
98874>>>
98874>>>                        Send Info_Box sInfoText
98875>>>                    End_Procedure
98876>>>
98876>>>                End_Object
98877>>>
98877>>>                Object oCreateNorthWind_btn is a cRDCButtonDPI
98879>>>                    Set Size to 14 219
98880>>>                    Set Location to 33 13
98881>>>                    Set Label to "Create New SQL Database [NorthWind] Complete with Data"
98882>>>                    Set psToolTip to "Creates the full NorthWind Sample database from the DataFlex samples complete with data with the name: [NorthWind]"
98883>>>                    Set psImage to "ActionCreateDatabase1.ico"
98884>>>
98884>>>                    Procedure OnClick
98887>>>                        String sInfoText sDriverID
98887>>>                        Boolean bOK
98887>>>                        TimeSpan tsTotalQueryTime
98887>>>                        Integer iRetval
98887>>>
98887>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98887>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98887>>>                        SQLIncludeScriptFile ..\Scripts\CreateNorthWindDatabase.sql as CreateNorthWindDatabase.sql
98887>>>
98887>>>                        Get YesNo_Box "This will run the 'CreateNorthWindDatabase.sql' script from the 'Script' workspace folder and it will create the [NorthWind] sample database in Microsoft SQL Server, complete with data. If it exists it will first be dropped, then re-created and populated with new data. Continue?" to iRetval
98888>>>                        If (iRetval <> MBR_Yes) Begin
98890>>>                            Procedure_Return
98891>>>                        End
98891>>>>
98891>>>
98891>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98892>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
98894>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
98895>>>                            Procedure_Return
98896>>>                        End
98896>>>>
98896>>>
98896>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
98897>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateNorthWindDatabase.sql" MSSQLDRV_ID False to bOK
98898>>>                        Send StopWorkingMessage
98899>>>
98899>>>                        If (bOK = True) Begin
98901>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98902>>>                            Move ("Success! The Northwind Sample Database was created as [NorthWind]. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98903>>>                        End
98903>>>>
98903>>>
98903>>>                        Else Begin
98904>>>                            Send UtilShowErrorList of ghoDbUpdateFunctionLibrary
98905>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98906>>>                        End
98906>>>>
98906>>>
98906>>>                        Send Info_Box sInfoText
98907>>>                    End_Procedure
98908>>>
98908>>>                End_Object
98909>>>
98909>>>                Object oCreateFullChinookDatabase_btn is a cRDCButtonDPI
98911>>>                    Set Size to 14 219
98912>>>                    Set Location to 53 13
98913>>>                    Set Label to "Create New SQL Database [Chinook] Complete with Data"
98914>>>                    Set psToolTip to "Creates the Chinook demo database complete with data in Microsoft SQL Server. Note: If it exists it will first be dropped then recreated. Note: These scripts were part of Data Access Europe's '' training class."
98915>>>                    Set psImage to "ActionCreateDatabase1.ico"
98916>>>
98916>>>                    Procedure OnClick
98919>>>                        String sInfoText sDriverID
98919>>>                        Boolean bOK
98919>>>                        TimeSpan tsTotalQueryTime
98919>>>                        Integer iRetval
98919>>>
98919>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98919>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98919>>>                        SQLIncludeScriptFile ..\Scripts\CreateChinookDatabase.sql as CreateChinookDatabase.sql
98919>>>
98919>>>                        Get YesNo_Box "This will run the 'CreateChinookDatabase.sql' script from the 'Script' workspace folder which will create the [Chinook] sample database complete with data. If it exists it will first be dropped, then re-created and populated with new data.\n\nContinue?" to iRetval
98920>>>                        If (iRetval <> MBR_Yes) Begin
98922>>>                            Procedure_Return
98923>>>                        End
98923>>>>
98923>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98924>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
98926>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
98927>>>                            Procedure_Return
98928>>>                        End
98928>>>>
98928>>>
98928>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
98929>>>
98929>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateChinookDatabase.sql" MSSQLDRV_ID False to bOK
98930>>>
98930>>>                        Send StopWorkingMessage
98931>>>                        If (bOK = True) Begin
98933>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98934>>>                            Move ("Success! The script was run OK. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98935>>>                        End
98935>>>>
98935>>>
98935>>>                        Else Begin
98936>>>                            Send UtilShowErrorList of ghoDbUpdateFunctionLibrary
98937>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98938>>>                        End
98938>>>>
98938>>>
98938>>>                        Send Info_Box sInfoText
98939>>>                    End_Procedure
98940>>>
98940>>>                End_Object
98941>>>
98941>>>                Object oInfo_tb is a TextBox
98943>>>                    Set Auto_Size_State to False
98944>>>                    Set Size to 25 158
98945>>>                    Set Location to 53 238
98946>>>                    Set Label to "Note: The Chinook script was provided by Data Access Europe as part of their 'Web Touch Training' course."
98947>>>                    Set Justification_Mode to JMode_Left
98948>>>                    Set peAnchors to anTopLeftRight
98949>>>                End_Object
98950>>>
98950>>>        //  This will choke the computer so don't try it!
98950>>>        //        Object oCreateAdventureWorksDatabase_btn is a cRDCButtonDPI
98950>>>        //            Set Size to 14 312
98950>>>        //            Set Location to 97 45
98950>>>        //            Set Label to "Create [AdventureWorks] Database and Populate with Data"
98950>>>        //            Set psToolTip to "Creates the Adenture Works database complete with data in Microsoft SQL Server. Note: If it exists it will first be dropped then recreated."
98950>>>        //
98950>>>        //            Procedure OnClick
98950>>>        //                String sInfoText
98950>>>        //                Boolean bOK
98950>>>        //                TimeSpan tsTotalQueryTime
98950>>>        //                Integer iRetval
98950>>>        //
98950>>>        //                // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98950>>>        //                // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98950>>>        ////                SQLIncludeScriptFile ..\Scripts\CreateAdventureWorks.sql as CreateAdventureWorks.sql
98950>>>        //Procedure_Return
98950>>>        //                Get YesNo_Box "This will create the [AdventurWorks] sample database complete with data. If it exists it will first be dropped, then re-created and populated with new data.\n\nContinue?" to iRetval
98950>>>        //                If (iRetval <> MBR_Yes) Begin
98950>>>        //                    Procedure_Return
98950>>>        //                End
98950>>>        //
98950>>>        //                Send StartWorkingMessage "Executing SQL Script. Please wait..."
98950>>>        //                Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateAdventureWorks.sql" MSSQLDRV_ID False to bOK
98950>>>        //                Send StopWorkingMessage
98950>>>        //
98950>>>        //                If (bOK = True) Begin
98950>>>        //                    Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98950>>>        //                    Move ("Success! The script was run OK. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98950>>>        //                End
98950>>>        //
98950>>>        //                Else Begin
98950>>>        //                    Send UtilShowErrorList of ghoDbUpdateFunctionLibrary
98950>>>        //                    Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98950>>>        //                End
98950>>>        //
98950>>>        //                Send Info_Box sInfoText
98950>>>        //            End_Procedure
98950>>>        //
98950>>>        //        End_Object
98950>>>
98950>>>            End_Object
98951>>>
98951>>>            Object oChangeIntFiles_grp is a Group
98953>>>                Set Size to 65 402
98954>>>                Set Location to 102 12
98955>>>                Set Label to "Change Old .int files to use Connection ID's"
98956>>>                Set peAnchors to anTopLeftRight
98957>>>
98957>>>                Object oSelectDataPath_fm is a Form
98959>>>                    Set Size to 12 300
98960>>>                    Set Location to 22 13
98961>>>                    Set Label to "Select path to a Data folder with .int files (Select one '.int' file):"
98962>>>                    Set Label_Col_Offset to 0
98963>>>                    Set Label_Row_Offset to 1
98964>>>                    Set Label_Justification_Mode to JMode_Top
98965>>>
98965>>>                    // This is very strange but for some reason the tooltip is _not_ displayed if PB_PromptOn is set...
98965>>>        //            Set Prompt_Button_Mode to PB_PromptOn
98965>>>                    Set psToolTip to "You can use this if you have .int files that currently have content like; 'SERVER=xxx; DATABASE=yyy' et.al. and you need to change them to use a connection ID like; 'SERVER_NAME DFCONNID=MyConnID'"
98966>>>                    Set peAnchors to anTopLeftRight
98967>>>
98967>>>                    Procedure Prompt
98970>>>                        String sPath sFileMask sRetval
98970>>>
98970>>>                        Get psDataPathFirstPart to sPath
98971>>>                        Move "Database intermediate files (*.int)|*.int" to sFileMask
98972>>>                        Get vSelect_File sFileMask "Please select an .int file from the data folder" sPath to sRetval
98973>>>                        If (sRetval <> "") Begin
98975>>>                            Get ParseFolderName sRetval to sPath
98976>>>                            If (Right(sPath, 1) ="\") Begin
98978>>>                                Move (Left(sPath, Length(sPath) -1)) to sPath
98979>>>                            End
98979>>>>
98979>>>                            Set Value to sPath
98980>>>                        End
98980>>>>
98980>>>                    End_Procedure
98981>>>
98981>>>                    // Returns the first datapath found in the psDataPath property.
98981>>>                    // The returned path always ends with a "\"
98981>>>                    Function psDataPathFirstPart Returns String
98984>>>                        String sDataPath
98984>>>                        Integer iCount
98984>>>
98984>>>                        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
98985>>>                        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
98986>>>                        If (iCount > 1) Begin
98988>>>                            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
98989>>>                        End
98989>>>>
98989>>>                        If (sDataPath <> "") Begin
98991>>>                            Get vFolderFormat sDataPath to sDataPath
98992>>>                        End
98992>>>>
98992>>>
98992>>>                        Function_Return sDataPath
98993>>>                    End_Function
98994>>>
98994>>>                End_Object
98995>>>
98995>>>                Object oSelectFolder_btn is a cRDCButtonDPI
98997>>>                    Set Size to 13 73
98998>>>                    Set Location to 22 320
98999>>>                    Set Label to "Select Folder"
99000>>>                    Set psToolTip to "Please select an .int file from the data folder"
99001>>>                    Set peAnchors to anTopRight
99002>>>                    Set psImage to "ActionOpen1.ico"
99003>>>
99003>>>                    Procedure OnClick
99006>>>                        Send Prompt to oSelectDataPath_fm
99007>>>                    End_Procedure
99008>>>
99008>>>                End_Object
99009>>>
99009>>>                Object oConnectionID_fm is a Form
99011>>>                    Set Size to 13 111
99012>>>                    Set Location to 38 202
99013>>>                    Set Label_Col_Offset to 2
99014>>>                    Set Label_Justification_Mode to JMode_Right
99015>>>                    Set Label to "Change to DFConnID:"
99016>>>                    Set psToolTip to "Please enter your Connection ID (DFCONNID=) that should replace the SERVER_NAME settings for all .int files in the selected folder."
99017>>>                    Set peAnchors to anTopRight
99018>>>                End_Object
99019>>>
99019>>>                Object oChangeAllIntFiles_btn is a cRDCButtonDPI
99021>>>                    Set Size to 13 68
99022>>>                    Set Location to 38 320
99023>>>                    Set Label to "GO !"
99024>>>                    Set psToolTip to "Changes or updates all .int files in the selected folder - except for DAW driver .int files (MSSQL_DRV.int, DB2_DRV.int & ODBC_DRV.int) - to use 'SERVER_NAME DFCONNID=xxx'"
99025>>>                    Set FontWeight to fw_Bold
99026>>>                    Set peAnchors to anTopRight
99027>>>
99027>>>                    Procedure OnClick
99030>>>                        String sDataPath sConnectionID
99030>>>                        Boolean bExists bActive
99030>>>                        Integer iRetval
99030>>>
99030>>>                        Get Value of oSelectDataPath_fm to sDataPath
99031>>>                        Get vFolderExists sDataPath to bExists
99032>>>                        If (bExists = False) Begin
99034>>>                            Send Info_Box ("The data folder doesn't exist!\n" + sDataPath)
99035>>>                            Procedure_Return
99036>>>                        End
99036>>>>
99036>>>                        Get Value of oConnectionID_fm to sConnectionID
99037>>>                        Move (Trim(sConnectionID)) to sConnectionID
99038>>>                        If (sConnectionID = "") Begin
99040>>>                            Send Info_Box "You need to specify a Connection_ID to use for the .int files."
99041>>>                            Procedure_Return
99042>>>                        End
99042>>>>
99042>>>
99042>>>                        Get YesNo_Box ("Do you want to change all .int files in folder:\n" + sDataPath + "\n\nTo use 'DFCONNID=" + sConnectionID +"' ?") to iRetval
99043>>>                        If (iRetval <> MBR_Yes) Begin
99045>>>                            Procedure_Return
99046>>>                        End
99046>>>>
99046>>>                        Get YesNo_Box "All '.CCH' files will first be deleted. Continue?" to iRetval
99047>>>                        If (iRetval <> MBR_Yes) Begin
99049>>>                            Procedure_Return
99050>>>                        End
99050>>>>
99050>>>
99050>>>                        Get vDeleteFile (sDataPath + "\*.cch") to iRetval
99051>>>                        If (iRetval <> 0) Begin
99053>>>                            Send Info_Box "Could not delete .cch files!"
99054>>>                            Procedure_Return
99055>>>                        End
99055>>>>
99055>>>
99055>>>                        Send Initialize_StatusPanel of ghoStatusPanel "The Database Update Framework" "Changing Connection ID's in .int files" ""
99056>>>                        Send Start_StatusPanel of ghoStatusPanel
99057>>>                        Send SqlUtilChangeIntFilesToConnectionIDs of ghoDbUpdateFunctionLibrary sDataPath sConnectionID True
99058>>>
99058>>>                        Get Active_State of ghoStatusPanel to bActive
99059>>>                        If (bActive = False) Begin
99061>>>                            Send Info_Box "Process interupted..."
99062>>>                        End
99062>>>>
99062>>>                        Else Begin
99063>>>                            Send Stop_StatusPanel of ghoStatusPanel
99064>>>                            Send Info_Box "Ready! All .int files changed."
99065>>>                        End
99065>>>>
99065>>>                    End_Procedure
99066>>>
99066>>>                End_Object
99067>>>
99067>>>            End_Object
99068>>>
99068>>>            Object oRemoveFilelistDriverIDs_grp is a Group
99070>>>                Set Size to 59 402
99071>>>                Set Location to 171 12
99072>>>                Set Label to "Remove Database Identifications from Filelist.cfg"
99073>>>                Set peAnchors to anTopLeftRight
99074>>>//                Set TextColor to clGreen
99074>>>//
99074>>>//                Procedure Page Integer iPage
99074>>>//                    Integer ia iz
99074>>>//                    Forward Send Page iPage
99074>>>//                    Move 0 to iz
99074>>>//                    Move (AddressOf(iz)) to ia
99074>>>//                    Move (SetWindowTheme(Window_Handle(Self),ia,ia)) to iPage
99074>>>//                End_Procedure
99074>>>
99074>>>                Object oFilelistPath_fm is a Form
99076>>>                    Set Size to 13 299
99077>>>                    Set Location to 22 13
99078>>>                    Set Label to "Path and Filelist.cfg Name:"
99079>>>                    Set Label_Col_Offset to 0
99080>>>                    Set Label_Row_Offset to 1
99081>>>                    Set Label_Justification_Mode to JMode_Top
99082>>>
99082>>>                    // This is very strange but for some reason the tooltip is _not_ displayed if PB_PromptOn is set...
99082>>>        //            Set Prompt_Button_Mode to PB_PromptOn
99082>>>                    Set psToolTip to "You can use this if you have entries in a Filelist.cfg with driver prefixes like 'MSSQLDRV;Customer' and you need to remove them all."
99083>>>                    Set peAnchors to anTopLeftRight
99084>>>
99084>>>                    Procedure Prompt
99087>>>                        String sFileName sPath sFileMask sRetval
99087>>>
99087>>>                        Get Value to sFileName
99088>>>                        Get ParseFolderName sFileName to sPath
99089>>>                        Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
99090>>>                        Get vSelect_File sFileMask "Please select a Filelist.cft file" sPath to sRetval
99091>>>                        If (sRetval <> "") Begin
99093>>>                            Set Value to sRetval
99094>>>                            Set_Attribute DF_FILELIST_NAME to sRetval
99097>>>                        End
99097>>>>
99097>>>                    End_Procedure
99098>>>
99098>>>                    Procedure OnCreate
99101>>>                        String sFilelist
99101>>>                        Get_Attribute DF_FILELIST_NAME to sFilelist
99104>>>                        Set Value to sFilelist
99105>>>                    End_Procedure
99106>>>                    Send OnCreate
99107>>>
99107>>>                End_Object
99108>>>
99108>>>                Object oSelectFilelist_btn is a cRDCButtonDPI
99110>>>                    Set Size to 13 73
99111>>>                    Set Location to 22 319
99112>>>                    Set Label to "Select Filelist.cfg"
99113>>>                    Set psToolTip to "Please select a Filelist.cfg file to be changed"
99114>>>                    Set peAnchors to anTopRight
99115>>>
99115>>>                    Procedure OnClick
99118>>>                        Send Prompt to oFilelistPath_fm
99119>>>                    End_Procedure
99120>>>
99120>>>                End_Object
99121>>>
99121>>>                Object oInfo_tb is a TextBox
99123>>>                    Set Size to 9 207
99124>>>                    Set Location to 40 138
99125>>>                    Set Label to "Remove database driver identifications from Filelist.cfg:"
99126>>>                    Set peAnchors to anTopRight
99127>>>                End_Object
99128>>>
99128>>>                Object oChangeFilelist_btn is a cRDCButtonDPI
99130>>>                    Set Size to 13 68
99131>>>                    Set Location to 38 319
99132>>>                    Set Label to "GO !"
99133>>>                    Set FontWeight to fw_Bold
99134>>>                    Set peAnchors to anTopRight
99135>>>                    Set psToolTip to 'Removes all database driver identificatins from Filelist.cfg, such as: "MSSQLDRV:MyTable"'
99136>>>
99136>>>                    Procedure OnClick
99139>>>                        String sFileList
99139>>>                        Integer iRetval iCount
99139>>>                        Boolean bExits
99139>>>
99139>>>                        Get Value of oFilelistPath_fm to sFileList
99140>>>                        Get vFilePathExists sFileList to bExits
99141>>>                        If (bExits = False) Begin
99143>>>                            Send Info_Box ("Sorry, the Filelist.cfg does not exist;\n" + sFileList)
99144>>>                            Procedure_Return
99145>>>                        End
99145>>>>
99145>>>
99145>>>                        Get YesNo_Box ("Are you sure you want to remove all driver identifications for the following Filelist.cfg?\n" + sFileList) to iRetval
99146>>>                        If (iRetval <> MBR_Yes) Begin
99148>>>                            Procedure_Return
99149>>>                        End
99149>>>>
99149>>>                        Send Cursor_Wait of Cursor_Control
99150>>>
99150>>>                        Get SqlUtilFilelistRemoveDriverInfo of ghoDbUpdateFunctionLibrary sFileList to iCount
99151>>>
99151>>>                        Send Cursor_Ready of Cursor_Control
99152>>>                        If (iCount <> 0) Begin
99154>>>                            Send Info_Box ("Ready!" * String(iCount) * "Filelist.cfg entries adjusted.")
99155>>>                        End
99155>>>>
99155>>>                        Else Begin
99156>>>                            Send Info_Box "Ready. No driver based Filelist entries found."
99157>>>                        End
99157>>>>
99157>>>
99157>>>                    End_Procedure
99158>>>
99158>>>                End_Object
99159>>>
99159>>>            End_Object
99160>>>
99160>>>            Object oOutput_grp is a Group
99162>>>                Set Size to 47 402
99163>>>                Set Location to 234 12
99164>>>                Set Label to "Print sekected Filelist.cfg as a Text file"
99165>>>                Set peAnchors to anTopLeftRight
99166>>>
99166>>>                Object oOutput_rg is a RadioGroup
99168>>>                    Set Location to 18 13
99169>>>                    Set Size to 25 288
99170>>>                    Set Label to "Filelist Output Order"
99171>>>
99171>>>                    Object oRadio1 is a Radio
99173>>>                        Set Label to "Filelist Number"
99174>>>                        Set Size to 10 61
99175>>>                        Set Location to 10 7
99176>>>                    End_Object
99177>>>
99177>>>                    Object oRadio2 is a Radio
99179>>>                        Set Label to "Logical Name"
99180>>>                        Set Size to 10 61
99181>>>                        Set Location to 10 77
99182>>>                    End_Object
99183>>>
99183>>>                    Object oRadio3 is a Radio
99185>>>                        Set Label to "Root Name"
99186>>>                        Set Size to 10 61
99187>>>                        Set Location to 10 147
99188>>>                    End_Object
99189>>>
99189>>>                    Object oRadio4 is a Radio
99191>>>                        Set Label to "Display Name"
99192>>>                        Set Size to 10 62
99193>>>                        Set Location to 10 213
99194>>>                    End_Object
99195>>>
99195>>>                    Procedure Notify_Select_State Integer iToItem Integer iFromItem
99198>>>                        Forward Send Notify_Select_State iToItem iFromItem
99200>>>                        Set piSortOrder of oPrintFilelist_btn to iToItem
99201>>>                    End_Procedure
99202>>>
99202>>>                End_Object
99203>>>                
99203>>>                Object oPrintFilelist_btn is a cRDCButtonDPI
99205>>>                    Set Size to 13 78
99206>>>                    Set Location to 26 315
99207>>>                    Set Label to "Print to Filelist.txt"
99208>>>                    Set psToolTip to "Writes the content of Filelist.cfg to a textfile and shows the textfile in the editor program asociated with *.txt files."
99209>>>                    Set psImage to "ActionDocument1.ico"
99210>>>
99210>>>                    Property Integer piSortOrder 0 // Property gets set by the radio group object.
99212>>>
99212>>>                    // Custom array sort function.
99212>>>                    // iSortOrder = 0 -> Filelist number order
99212>>>                    // iSortOrder = 1 -> Logical name order
99212>>>                    // iSortOrder = 2 -> Root name order
99212>>>                    // iSortOrder = 3 -> Display name order
99212>>>                    Function CompareSortFilelist tFilelistDUF FilelistDUF1 tFilelistDUF FilelistDUF2 Returns Integer
99215>>>                        Integer iSortOrder
99215>>>
99215>>>                        Get piSortOrder to iSortOrder
99216>>>
99216>>>                        Case Begin
99216>>>                            Case (iSortOrder = 0)
99218>>>                                If (FilelistDUF1.iFileNumber  > FilelistDUF2.iFileNumber) Begin
99220>>>                                    Function_Return (GT)
99221>>>                                End
99221>>>>
99221>>>                                If (FilelistDUF1.iFileNumber  < FilelistDUF2.iFileNumber) Begin
99223>>>                                    Function_Return (LT)
99224>>>                                End
99224>>>>
99224>>>                                Function_Return (EQ)
99225>>>                            Case (iSortOrder = 1)
99228>>>                                If (Uppercase(FilelistDUF1.sLogicalName) > Uppercase(FilelistDUF2.sLogicalName)) Begin
99230>>>                                    Function_Return (GT)
99231>>>                                End
99231>>>>
99231>>>                                If (Uppercase(FilelistDUF1.sLogicalName) < Uppercase(FilelistDUF2.sLogicalName)) Begin
99233>>>                                    Function_Return (LT)
99234>>>                                End
99234>>>>
99234>>>                                Function_Return (EQ)
99235>>>                            Case (iSortOrder = 2)
99238>>>                                If (Uppercase(FilelistDUF1.sRootName)    > Uppercase(FilelistDUF2.sRootName)) Begin
99240>>>                                    Function_Return (GT)
99241>>>                                End
99241>>>>
99241>>>                                If (Uppercase(FilelistDUF1.sRootName)    < Uppercase(FilelistDUF2.sRootName)) Begin
99243>>>                                    Function_Return (LT)
99244>>>                                End
99244>>>>
99244>>>                                Function_Return (EQ)
99245>>>                            Case (iSortOrder = 3)
99248>>>                                If (Uppercase(FilelistDUF1.sDisplayName) > Uppercase(FilelistDUF2.sDisplayName)) Begin
99250>>>                                    Function_Return (GT)
99251>>>                                End
99251>>>>
99251>>>                                If (Uppercase(FilelistDUF1.sDisplayName) < Uppercase(FilelistDUF2.sDisplayName)) Begin
99253>>>                                    Function_Return (LT)
99254>>>                                End
99254>>>>
99254>>>                                Function_Return (EQ)
99255>>>                        Case End
99255>>>
99255>>>                    End_Function
99256>>>
99256>>>                    Procedure OnClick
99259>>>                        String sFileList sRootName sLogicalName sDisplayName sPath sOutputName sTable sExt
99259>>>                        Integer iCh iCount iSize
99259>>>                        Handle hTable
99259>>>                        tFilelistDUF[] FilelistDUFArray FilelistDUFSorted
99259>>>                        tFilelistDUF[] FilelistDUFArray FilelistDUFSorted
99261>>>
99261>>>                        Get Value of oFilelistPath_fm to sFileList
99262>>>                        Move (Trim(sFileList)) to sFileList
99263>>>                        If (sFileList = "") Begin
99265>>>                            Send Info_Box "You need to select a Filelist.cfg file first"
99266>>>                            Procedure_Return
99267>>>                        End
99267>>>>
99267>>>
99267>>>                        Get ParseFolderName sFileList to sPath
99268>>>                        Get vFolderFormat sPath to sPath
99269>>>                        Get ParseFileName sFileList to sOutputName
99270>>>                        Get ParseFileExtension sFileList to sExt
99271>>>                        Move (Replace(sExt, sOutputName, "")) to sOutputName
99272>>>                        Move (sOutputName + "txt")           to sOutputName
99273>>>                        Get Seq_Open_Output_Channel (sPath + sOutputName) to iCh
99274>>>                        If (iCh < 0) Begin
99276>>>                            Procedure_Return
99277>>>                        End
99277>>>>
99277>>>
99277>>>                        Move 0 to hTable
99278>>>                        Writeln channel iCh sFileList
99281>>>                        Writeln channel iCh "[Table No:]            [LogicalName:]        [RootName:]                             [DisplayName:]"
99284>>>                        Writeln channel iCh "==================================================================================================="
99287>>>                        Writeln channel iCh
99289>>>
99289>>>                        Move 0 to iCount
99290>>>                        Repeat
99290>>>>
99290>>>                            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
99293>>>                            If (hTable > 0) Begin
99295>>>                                Move hTable                                  to FilelistDUFArray[iCount].iFileNumber
99296>>>                                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to FilelistDUFArray[iCount].sLogicalName
99299>>>                                Get_Attribute DF_FILE_ROOT_NAME    of hTable to FilelistDUFArray[iCount].sRootName
99302>>>                                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to FilelistDUFArray[iCount].sDisplayName
99305>>>                                Increment iCount
99306>>>                            End
99306>>>>
99306>>>                        Until (hTable = 0)
99308>>>
99308>>>                        Move (SortArray(FilelistDUFArray, Self, (RefFunc(CompareSortFilelist)))) to FilelistDUFSorted
99309>>>                        Move (SizeOfArray(FilelistDUFSorted)) to iSize
99310>>>                        Decrement iSize
99311>>>
99311>>>                        For iCount from 0 to iSize
99317>>>>
99317>>>                            Move FilelistDUFSorted[iCount].iFileNumber  to hTable
99318>>>                            Move FilelistDUFSorted[iCount].sLogicalName to sLogicalName
99319>>>                            Move FilelistDUFSorted[iCount].sRootName    to sRootName
99320>>>                            Move FilelistDUFSorted[iCount].sDisplayName to sDisplayName
99321>>>
99321>>>                            Get PadLeft (String(hTable))        09 to sTable
99322>>>                            Get PadLeft (String(sLogicalName)) (27 - Length(sTable))       to sLogicalName
99323>>>                            Get PadLeft (String(sRootName))    (46 - Length(sLogicalName)) to sRootName
99324>>>                            Get PadLeft (String(sDisplayName)) (72 - Length(sRootName))    to sDisplayName
99325>>>
99325>>>                            Writeln channel iCh sTable (Utf8ToAnsi(sRootName)) (Utf8ToAnsi(sLogicalName)) (Utf8ToAnsi(sDisplayName))
99331>>>                        Loop
99332>>>>
99332>>>
99332>>>                        Writeln channel iCh "==================================================================================================="
99335>>>                        Writeln channel iCh "Total Number of Tables in Filelist.cfg: " (iSize + 1)
99339>>>                        Close_Output
99340>>>
99340>>>                        Send vShellExecute "open" sOutputName "" sPath
99341>>>                    End_Procedure
99342>>>
99342>>>                    Function PadLeft String sString Integer iLength String sOptChar Returns String
99345>>>                        String sChar
99345>>>
99345>>>                        If (Num_Arguments >= 3) Begin
99347>>>                            Move sOptChar to sChar
99348>>>                        End
99348>>>>
99348>>>                        Else Begin
99349>>>                            Move " " to sChar
99350>>>                        End
99350>>>>
99350>>>
99350>>>                        While (Length(sString) < iLength)
99354>>>                            Move (sChar + sString) to sString
99355>>>                        Loop
99356>>>>
99356>>>
99356>>>                        Function_Return sString
99357>>>                    End_Function
99358>>>
99358>>>                End_Object
99359>>>            End_Object
99360>>>
99360>>>        End_Object
99361>>>
99361>>>    End_Object
99362>>>
99362>>>    Procedure OnFileDropped String sFilename Boolean bLast
99365>>>        String sTest
99365>>>        Forward Send OnFileDropped sFilename bLast
99367>>>        If (bLast = True) Begin
99369>>>            Get ParseFileName sFilename to sTest
99370>>>            If (Uppercase(sTest) <> "FILELIST.CFG") Begin
99372>>>                Send Info_Box "Sorry, only Filist.cfg files can be dropped here..."
99373>>>                Procedure_Return
99374>>>            End
99374>>>>
99374>>>            Set Value of oFilelistPath_fm to sFilename
99375>>>        End
99375>>>>
99375>>>    End_Procedure
99376>>>
99376>>>End_Object
99377>
99377>        Procedure Activate_About
99380>            Send DoAbout "" "" ("Copyright 2016-2020" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "TestTools.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com" ("This tool was created with DataFlex" * String(C_DFVersion) * "from Data Access Worldwide. Please visit http://www.dataaccess.com for a free personal copy of DataFlex.")
99381>        End_Procedure
99382>
99382>        On_Key Key_Ctrl+Key_Tab           Send Switch_Prior_View
99383>        On_Key Key_Ctrl+Key_Shift+Key_Tab Send Switch_Next_View
99384>        On_Key Key_Ctrl+Key_W             Send Close_Panel
99385>    End_Object
99386>
99386>    // Note that we have overriden the cHtmlHelp "GetHelpFile" function
99386>    // in the oHtmlHelp object, so we need to explitetly send the message
99386>    // to that object.
99386>    Procedure ShowProgramHelp
99389>        Send DoDisplayKeyword of oHtmlHelp "DbUpdateFrameworkTests" //"cDbUpdateFunctionLibrary"
99390>    End_Procedure
99391>
99391>    On_Key Key_F1 Send ShowProgramHelp
99392>End_Object
99393>
99393>// We do this to activate the first view:
99393>//Send Activate_oSQLConnections_vw of (Client_Id(phoMainPanel(ghoApplication)))
99393>Start_UI
99394>
Including Resources...
Summary
Memory Available: 102232903680
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 52665
Total Resources: 9
Total Commands : 99393
Total Windows  : 0
Total Pages    : 0
Static Data    : 857451
Message area   : 639036
Total Blocks   : 76691
