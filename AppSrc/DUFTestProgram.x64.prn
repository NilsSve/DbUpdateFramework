Compiling Program: C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFTestProgram.src
Memory Available: 26541154304
1>    CompilerLevelWarning All On
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.x64.pkd    (C:\Program Files\DataFlex 24.0\Pkg\dfallent.x64.pkd)
73440>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJStandardCommandBarSystem.pkg)
73440>>>// these are all the packages used in a standard MDI menubar/toolbar system
73440>>>
73440>>>Use cCJCommandBarSystem.pkg
73440>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJStandardMenuItemClasses.pkg)
73440>>>>>Use Dfpanel.pkg
73440>>>>>Use cCJCommandBarSystem.pkg
73440>>>>>Use LanguageText.pkg
73440>>>>>
73440>>>>>
73440>>>>>Class cCJUndoMenuItem is a cCJMenuItem
73441>>>>>    
73441>>>>>    Procedure Construct_Object
73443>>>>>        Forward Send Construct_Object
73445>>>>>        Set psCaption   to C_$CaptionUndo
73446>>>>>        Set psToolTip to C_$ToolTipUndo
73447>>>>>        Set psDescription to C_$DescUndo
73448>>>>>        Set psImage to "ActionUndo.ico"
73449>>>>>        Set pbActiveUpdate to True
73450>>>>>        Set psCategory to C_$CategoryEdit
73451>>>>>        Set psShortcut to C_$Key_Ctrl_Z
73452>>>>>    End_Procedure
73453>>>>>    
73453>>>>>    Procedure OnExecute Variant vCommandBarControl
73455>>>>>        Send Undo of (focus(Self))
73456>>>>>    End_Procedure
73457>>>>>    
73457>>>>>    Function IsEnabled Returns Boolean
73459>>>>>        Boolean bEnabled
73459>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
73460>>>>>        Function_Return bEnabled
73461>>>>>    End_Function
73462>>>>>    
73462>>>>>End_Class
73463>>>>>
73463>>>>>
73463>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
73464>>>>>    
73464>>>>>    Procedure Construct_Object
73466>>>>>        Forward Send Construct_Object
73468>>>>>        Set psCaption   to C_$CaptionDelete
73469>>>>>        Set psToolTip to C_$ToolTipDelete
73470>>>>>        Set psDescription to C_$DescDelete
73471>>>>>        Set psImage to "actionDelete.ico"
73472>>>>>        Set psShortcut to C_$Key_Delete
73473>>>>>        Set pbActiveUpdate to True
73474>>>>>        Set psCategory to C_$CategoryEdit
73475>>>>>    End_Procedure
73476>>>>>    
73476>>>>>    
73476>>>>>    Procedure OnExecute Variant vCommandBarControl
73478>>>>>        Send Delete of (focus(Self))
73479>>>>>    End_Procedure
73480>>>>>    
73480>>>>>    Function IsEnabled Returns Boolean
73482>>>>>        Boolean bEnabled
73482>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
73483>>>>>        Function_Return bEnabled
73484>>>>>    End_Function
73485>>>>>    
73485>>>>>End_Class
73486>>>>>
73486>>>>>
73486>>>>>Class cCJCutMenuItem is a cCJMenuItem
73487>>>>>    
73487>>>>>    Procedure Construct_Object
73489>>>>>        Forward Send Construct_Object
73491>>>>>        Set psCaption   to C_$CaptionCut
73492>>>>>        Set psToolTip to C_$TooltipCut
73493>>>>>        Set psDescription to C_$DescCut
73494>>>>>        Set psImage to "actionCut.ico"
73495>>>>>        Set psShortcut to C_$Key_Ctrl_X
73496>>>>>        Set pbActiveUpdate to True
73497>>>>>        Set psCategory to C_$CategoryEdit
73498>>>>>    End_Procedure
73499>>>>>    
73499>>>>>    
73499>>>>>    Procedure OnExecute Variant vCommandBarControl
73501>>>>>        Send Cut of (focus(Self))
73502>>>>>    End_Procedure
73503>>>>>    
73503>>>>>    Function IsEnabled Returns Boolean
73505>>>>>        Boolean bEnabled
73505>>>>>        Get CanCut of (Focus(Self)) to bEnabled
73506>>>>>        Function_Return bEnabled
73507>>>>>    End_Function
73508>>>>>    
73508>>>>>End_Class
73509>>>>>
73509>>>>>
73509>>>>>Class cCJCopyMenuItem is a cCJMenuItem
73510>>>>>    
73510>>>>>    Procedure Construct_Object
73512>>>>>        Forward Send Construct_Object
73514>>>>>        Set psCaption   to C_$CaptionCopy
73515>>>>>        Set psToolTip to C_$ToolTipCopy
73516>>>>>        Set psDescription to C_$DescCopy
73517>>>>>        Set psImage to "actionCopy.ico"
73518>>>>>        Set psShortcut to C_$Key_Ctrl_C
73519>>>>>        Set pbActiveUpdate to True
73520>>>>>        Set psCategory to C_$CategoryEdit
73521>>>>>    End_Procedure
73522>>>>>    
73522>>>>>    
73522>>>>>    Procedure OnExecute Variant vCommandBarControl
73524>>>>>        Send Copy of (focus(Self))
73525>>>>>    End_Procedure
73526>>>>>    
73526>>>>>    Function IsEnabled Returns Boolean
73528>>>>>        Boolean bEnabled
73528>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
73529>>>>>        Function_Return bEnabled
73530>>>>>    End_Function
73531>>>>>    
73531>>>>>End_Class
73532>>>>>
73532>>>>>
73532>>>>>Class cCJPasteMenuItem is a cCJMenuItem
73533>>>>>    
73533>>>>>    Procedure Construct_Object
73535>>>>>        Forward Send Construct_Object
73537>>>>>        Set psCaption   to C_$CaptionPaste
73538>>>>>        Set psToolTip to C_$ToolTipPaste
73539>>>>>        Set psDescription to C_$DescPaste
73540>>>>>        Set psImage to "actionPaste.ico"
73541>>>>>        Set pbActiveUpdate to True
73542>>>>>        Set psShortcut to C_$Key_Ctrl_V
73543>>>>>        Set psCategory to C_$CategoryEdit
73544>>>>>    End_Procedure
73545>>>>>    
73545>>>>>    
73545>>>>>    Procedure OnExecute Variant vCommandBarControl
73547>>>>>        Send Paste of (focus(Self))
73548>>>>>    End_Procedure
73549>>>>>    
73549>>>>>    Function IsEnabled Returns Boolean
73551>>>>>        Boolean bEnabled
73551>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
73552>>>>>        Function_Return bEnabled
73553>>>>>    End_Function
73554>>>>>    
73554>>>>>End_Class
73555>>>>>
73555>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
73556>>>>>    
73556>>>>>    Procedure Construct_Object
73558>>>>>        Forward Send Construct_Object
73560>>>>>        Set psCaption   to C_$CaptionSelectAll
73561>>>>>        Set psToolTip to C_$ToolTipSelectAll
73562>>>>>        Set psDescription to C_$DescSelectAll
73563>>>>>        Set pbActiveUpdate to True
73564>>>>>        Set psShortcut to C_$Key_Ctrl_A
73565>>>>>        Set psCategory to C_$CategoryEdit
73566>>>>>    End_Procedure
73567>>>>>    
73567>>>>>    
73567>>>>>    Procedure OnExecute Variant vCommandBarControl
73569>>>>>        Send Select_All of (focus(Self))
73570>>>>>    End_Procedure
73571>>>>>    
73571>>>>>    Function IsEnabled Returns Boolean
73573>>>>>        Boolean bEnabled
73573>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
73574>>>>>        Function_Return bEnabled
73575>>>>>    End_Function
73576>>>>>    
73576>>>>>End_Class
73577>>>>>
73577>>>>>
73577>>>>>Class cCJExitMenuItem is a cCJMenuItem
73578>>>>>    
73578>>>>>    Procedure Construct_Object
73580>>>>>        Forward Send Construct_Object
73582>>>>>        Set psCaption to C_$CaptionExit
73583>>>>>        Set psToolTip to C_$ToolTipExit
73584>>>>>        Set psDescription to C_$ToolTipExit
73585>>>>>        Set psShortcut to C_$Key_Alt_F4
73586>>>>>        Set psCategory to C_$CategoryFile
73587>>>>>    End_Procedure
73588>>>>>    
73588>>>>>    Procedure OnExecute Variant vCommandBarControl
73590>>>>>        Send Exit_Application of Desktop
73591>>>>>    End_Procedure
73592>>>>>    
73592>>>>>End_Class
73593>>>>>
73593>>>>>Class cCJHelpMenuItem is a cCJMenuItem
73594>>>>>    
73594>>>>>    Procedure Construct_Object
73596>>>>>        Forward Send Construct_Object
73598>>>>>        Set psCaption to C_$CaptionHelp
73599>>>>>        Set psDescription to C_$ToolTipHelp
73600>>>>>        Set psToolTip to C_$DescHelp
73601>>>>>        Set psImage to "ActionHelp.ico"
73602>>>>>        Set psShortcut to "F1"
73603>>>>>        Set psCategory to C_$CategoryHelp
73604>>>>>    End_Procedure
73605>>>>>    
73605>>>>>    Procedure OnExecute Variant vCommandBarControl
73607>>>>>        Send Help of (Focus(Self))
73608>>>>>    End_Procedure
73609>>>>>    
73609>>>>>End_Class
73610>>>>>
73610>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
73611>>>>>    
73611>>>>>    Procedure Construct_Object
73613>>>>>        Forward Send Construct_Object
73615>>>>>        Set psCaption to C_$CaptionAddStatusbar
73616>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
73617>>>>>        Set psDescription to  C_$DescAddStatusbar
73618>>>>>        Set psCategory to C_$CategoryWindow
73619>>>>>    End_Procedure
73620>>>>>    
73620>>>>>    Procedure OnExecute Variant vCommandBarControl
73622>>>>>        Handle hoCommandBars hoClientArea
73622>>>>>        Get CommandBarSystemObject to hoCommandBars
73623>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73624>>>>>        If hoClientArea Begin
73626>>>>>            // the clientarea's parent panel has message
73626>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
73627>>>>>        End
73627>>>>>>
73627>>>>>    End_Procedure
73628>>>>>    
73628>>>>>    Function IsChecked Returns Boolean
73630>>>>>        Boolean bOn
73630>>>>>        Handle hoCommandBars hoClientArea
73630>>>>>        Get CommandBarSystemObject to hoCommandBars
73631>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73632>>>>>        If hoClientArea Begin
73634>>>>>            // the clientarea's parent panel has message
73634>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
73635>>>>>        End
73635>>>>>>
73635>>>>>        Function_Return bOn
73636>>>>>    End_Function
73637>>>>>End_Class
73638>>>>>
73638>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
73639>>>>>    
73639>>>>>    Procedure Construct_Object
73641>>>>>        Forward Send Construct_Object
73643>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
73644>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
73645>>>>>        Set psDescription to C_$DescAutoArrangeIcons
73646>>>>>        Set psCategory to C_$CategoryWindow
73647>>>>>    End_Procedure
73648>>>>>    
73648>>>>>    Procedure OnExecute Variant vCommandBarControl
73650>>>>>        Handle hoCommandBars hoClientArea
73650>>>>>        Get CommandBarSystemObject to hoCommandBars
73651>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73652>>>>>        If hoClientArea Begin
73654>>>>>            // the clientarea's parent panel has message
73654>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
73655>>>>>        End
73655>>>>>>
73655>>>>>    End_Procedure
73656>>>>>    
73656>>>>>    Function IsChecked Returns Boolean
73658>>>>>        Boolean bOn
73658>>>>>        Handle hoCommandBars hoClientArea
73658>>>>>        Get CommandBarSystemObject to hoCommandBars
73659>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73660>>>>>        If hoClientArea Begin
73662>>>>>            // the clientarea's parent panel has message
73662>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
73663>>>>>        End
73663>>>>>>
73663>>>>>        Function_Return bOn
73664>>>>>    End_Function
73665>>>>>End_Class
73666>>>>>
73666>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
73667>>>>>    
73667>>>>>    Procedure Construct_Object
73669>>>>>        Forward Send Construct_Object
73671>>>>>        Set psCaption to C_$CaptionRestoreMenus
73672>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
73673>>>>>        Set psDescription to C_$DescRestoreMenus
73674>>>>>        Set psCategory to C_$CategoryWindow
73675>>>>>    End_Procedure
73676>>>>>    
73676>>>>>    Procedure OnExecute Variant vCommandBarControl
73678>>>>>        Handle hoCommandBars
73678>>>>>        Get CommandBarSystemObject to hoCommandBars
73679>>>>>        Send RestoreLayout of hoCommandBars
73680>>>>>    End_Procedure
73681>>>>>    
73681>>>>>End_Class
73682>>>>>
73682>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
73683>>>>>    
73683>>>>>    Procedure Construct_Object
73685>>>>>        Forward Send Construct_Object
73687>>>>>        Set psCaption to C_$CaptionCascade
73688>>>>>        Set psToolTip to C_$ToolTipCascade
73689>>>>>        Set psDescription to  C_$DescCascade
73690>>>>>        Set psImage to "ActionCascade.ico"
73691>>>>>        Set psCategory to C_$CategoryWindow
73692>>>>>    End_Procedure
73693>>>>>    
73693>>>>>    Procedure OnExecute Variant vCommandBarControl
73695>>>>>        Handle hoCommandBars hoClientArea
73695>>>>>        Get CommandBarSystemObject to hoCommandBars
73696>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73697>>>>>        If hoClientArea Begin
73699>>>>>            Send Cascade_Windows of hoClientArea
73700>>>>>        End
73700>>>>>>
73700>>>>>    End_Procedure
73701>>>>>End_Class
73702>>>>>
73702>>>>>Class cCJTileHorizontally is a cCJMenuItem
73703>>>>>    
73703>>>>>    Procedure Construct_Object
73705>>>>>        Forward Send Construct_Object
73707>>>>>        Set psCaption to C_$CaptionTileHorizontally
73708>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
73709>>>>>        Set psDescription to  C_$DescTileHorizontally
73710>>>>>        Set psImage to "ActionTileHorizontally.ico"
73711>>>>>        Set psCategory to C_$CategoryWindow
73712>>>>>    End_Procedure
73713>>>>>    
73713>>>>>    Procedure OnExecute Variant vCommandBarControl
73715>>>>>        Handle hoCommandBars hoClientArea
73715>>>>>        Get CommandBarSystemObject to hoCommandBars
73716>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73717>>>>>        If hoClientArea Begin
73719>>>>>            Send Tile_Windows_Horizontal of hoClientArea
73720>>>>>        End
73720>>>>>>
73720>>>>>    End_Procedure
73721>>>>>End_Class
73722>>>>>
73722>>>>>Class cCJTileVertically is a cCJMenuItem
73723>>>>>    
73723>>>>>    Procedure Construct_Object
73725>>>>>        Forward Send Construct_Object
73727>>>>>        Set psCaption to C_$CaptionTileVertically
73728>>>>>        Set psToolTip to C_$ToolTipTileVertically
73729>>>>>        Set psDescription to  C_$DescTileVertically
73730>>>>>        Set psImage to "ActionTileVertically.ico"
73731>>>>>        Set psCategory to C_$CategoryWindow
73732>>>>>    End_Procedure
73733>>>>>    
73733>>>>>    Procedure OnExecute Variant vCommandBarControl
73735>>>>>        Handle hoCommandBars hoClientArea
73735>>>>>        Get CommandBarSystemObject to hoCommandBars
73736>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73737>>>>>        If hoClientArea Begin
73739>>>>>            Send Tile_Windows_Vertical of hoClientArea
73740>>>>>        End
73740>>>>>>
73740>>>>>    End_Procedure
73741>>>>>End_Class
73742>>>>>
73742>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
73743>>>>>    
73743>>>>>    Procedure Construct_Object
73745>>>>>        Forward Send Construct_Object
73747>>>>>        Set psCaption to C_$CaptionMinimizeWindows
73748>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
73749>>>>>        Set psDescription to  C_$DescMinimizeWindows
73750>>>>>        Set psCategory to C_$CategoryWindow
73751>>>>>    End_Procedure
73752>>>>>    
73752>>>>>    Procedure OnExecute Variant vCommandBarControl
73754>>>>>        Handle hoCommandBars hoClientArea
73754>>>>>        Get CommandBarSystemObject to hoCommandBars
73755>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73756>>>>>        If hoClientArea Begin
73758>>>>>            // the clientarea's parent panel has message
73758>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
73759>>>>>        End
73759>>>>>>
73759>>>>>    End_Procedure
73760>>>>>End_Class
73761>>>>>
73761>>>>>
73761>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
73762>>>>>    
73762>>>>>    Procedure Construct_Object
73764>>>>>        Forward Send Construct_Object
73766>>>>>        Set psCaption to C_$CaptionRestoreWindows
73767>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
73768>>>>>        Set psDescription to  C_$DescRestoreWindows
73769>>>>>        Set psCategory to C_$CategoryWindow
73770>>>>>    End_Procedure
73771>>>>>    
73771>>>>>    Procedure OnExecute Variant vCommandBarControl
73773>>>>>        Handle hoCommandBars hoClientArea
73773>>>>>        Get CommandBarSystemObject to hoCommandBars
73774>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73775>>>>>        If hoClientArea Begin
73777>>>>>            // the clientarea's parent panel has message
73777>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
73778>>>>>        End
73778>>>>>>
73778>>>>>    End_Procedure
73779>>>>>End_Class
73780>>>>>
73780>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
73781>>>>>    
73781>>>>>    Procedure Construct_Object
73783>>>>>        Forward Send Construct_Object
73785>>>>>        Set psCaption to C_$CaptionArrangeIcons
73786>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
73787>>>>>        Set psDescription to  C_$DescArrangeIcons
73788>>>>>        Set psCategory to C_$CategoryWindow
73789>>>>>    End_Procedure
73790>>>>>    
73790>>>>>    Procedure OnExecute Variant vCommandBarControl
73792>>>>>        Handle hoCommandBars hoClientArea
73792>>>>>        Get CommandBarSystemObject to hoCommandBars
73793>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73794>>>>>        If hoClientArea Begin
73796>>>>>            Send Arrange_Icons of hoClientArea
73797>>>>>        End
73797>>>>>>
73797>>>>>    End_Procedure
73798>>>>>    
73798>>>>>End_Class
73799>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJAboutMenuItem.pkg)
73799>>>>>Use cCJCommandBarSystem.pkg
73799>>>>>Use LanguageText.pkg
73799>>>>>
73799>>>>>// It is expected that if you use this class that you provide an about object that is
73799>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
73799>>>>>// because you may wish to create your own custom about package.
73799>>>>>
73799>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
73800>>>>>
73800>>>>>    Procedure Construct_Object
73802>>>>>        Forward Send Construct_Object
73804>>>>>        Set psCaption to C_$CaptionAbout
73805>>>>>        Set psDescription to C_$ToolTipAbout
73806>>>>>        Set psToolTip to C_$DescAbout
73807>>>>>        Set psImage to "ActionAbout.ico"
73808>>>>>        Set psCategory to C_$CategoryHelp
73809>>>>>    End_Procedure
73810>>>>>    
73810>>>>>    Procedure OnExecute Variant vCommandBarControl
73812>>>>>        Handle hoCommandBars hoClientArea
73812>>>>>        Get CommandBarSystemObject to hoCommandBars
73813>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73814>>>>>        If hoClientArea Begin
73816>>>>>            Send Activate_About of hoClientArea
73817>>>>>        End
73817>>>>>>
73817>>>>>    End_Procedure
73818>>>>>
73818>>>>>End_Class
73819>>>>>
73819>>>>>
73819>>>Use cCJDeoMenuItemClasses.pkg
73819>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJMDIWindowsMenuItem.pkg)
73819>>>>>Use cCJCommandBarSystem.pkg
73819>>>>>
73819>>>>>Register_Function Client_ID Returns Integer
73819>>>>>
73819>>>>>// only used by cCJMDIWIndowsMenuItem
73819>>>>>Class cCJMDIWindowItem is a cCJMenuItem
73820>>>>>    
73820>>>>>    Procedure Construct_Object
73822>>>>>        Forward Send Construct_Object
73824>>>>>        Property Handle phWindow 0 // object id of view
73825>>>>>        Set pbControlFlagNoMovable to True
73826>>>>>        Set pbActiveUpdate to True
73827>>>>>    End_Procedure
73828>>>>>    
73828>>>>>    Procedure OnExecute Variant vCommandBarControl
73830>>>>>        Handle hWindow
73830>>>>>        Get phWindow to hWindow
73831>>>>>        Send Activate_View of hWindow
73832>>>>>    End_Procedure
73833>>>>>    
73833>>>>>End_Class
73834>>>>>
73834>>>>>
73834>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
73835>>>>>    
73835>>>>>    Procedure Construct_Object
73837>>>>>        Forward Send Construct_Object
73839>>>>>        Property Handle[] phArrayOfWindows
73840>>>>>        Set peControlType to xtpControlPopup
73841>>>>>        Set psCategory to C_$CategoryWindow
73842>>>>>    End_Procedure
73843>>>>>    
73843>>>>>    // This adds MDI windows to the existing menu items.
73843>>>>>    // This removes any existing windows menus and always adds a new set to the end
73843>>>>>    
73843>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
73845>>>>>        Handle  hClientArea hView
73845>>>>>        String  sLabel
73845>>>>>        Integer i iWindows
73845>>>>>        Handle[] hArrayOfWindows
73846>>>>>        Variant vItem
73846>>>>>        
73846>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
73846>>>>>        // also assume that destroying an action removes all menu instances of that action
73846>>>>>        Get phArrayOfWindows to hArrayOfWindows
73847>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
73848>>>>>        For i from 0 to (iWindows-1)
73854>>>>>>
73854>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
73855>>>>>        Loop
73856>>>>>>
73856>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
73857>>>>>        
73857>>>>>        // Add all views to this menu. Create the action and add the item
73857>>>>>        Move 0 to i
73858>>>>>        Get Client_Id to hClientArea // object id of client area
73859>>>>>        If (hClientArea > 0) Begin
73861>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
73862>>>>>            While (hView <> 0)
73866>>>>>                If (Active_State(hView)) Begin
73868>>>>>                    // create the action
73868>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
73869>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
73870>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
73871>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
73872>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
73874>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
73875>>>>>                    End
73875>>>>>>
73875>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
73876>>>>>                    If (i=0) Begin
73878>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
73879>>>>>                    End
73879>>>>>>
73879>>>>>                    // Create a menu item for this action
73879>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
73880>>>>>                    Increment i
73881>>>>>                End
73881>>>>>>
73881>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
73882>>>>>            Loop
73883>>>>>>
73883>>>>>        End
73883>>>>>>
73883>>>>>        
73883>>>>>        Set phArrayOfWindows to hArrayOfWindows
73884>>>>>        
73884>>>>>    End_Procedure
73885>>>>>    
73885>>>>>End_Class
73886>Use cCJCommandBarSystem.pkg
73886>Use cDbUpdateHandler.pkg
Including file: cDbUpdateHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.pkg)
73886>>>//****************************************************************************
73886>>>// $Module type: Class
73886>>>// $Module name: cDbUpdateHandler
73886>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
73886>>>// Web-site    : http://www.rdctools.com
73886>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
73886>>>//
73886>>>// Purpose     : A framework for doing automated code based updates of a database from within
73886>>>//               a program, when it is started.
73886>>>//
73886>>>// Description : Place _one_ object of this class right after the cApplication object.
73886>>>//               Then inside this object place a series of cDbUpdateVersion objects
73886>>>//               as childs. One child object for each new database update.
73886>>>//
73886>>>//               - OnPreUpdate is a pre-processing event called
73886>>>//               before any database changes are started.
73886>>>//               - OnPostUpdate is a post-processing event called after all
73886>>>//               database changes have taken place.
73886>>>//
73886>>>// Note        : If tables have been opened prior to an object of this class
73886>>>//               (e.g. in the cApplication object), those tables will be closed.
73886>>>//               In that case you need to use the OnPostUpdate hook event to re-open
73886>>>//               tables after the last update has finished.
73886>>>//
73886>>>// Security    : Before an update is attempted; three things are checked to ensure the
73886>>>//               database is not in use. Aka nobody else is running the application.
73886>>>//               - All tables are tested for "Open in Exclusive_Mode"
73886>>>//               - The DataFlex license User Count is checked - cannot be more than 1, unless the
73886>>>//                 pbCheckDataFlexUserCount is set to False (Default = True)
73886>>>//               - A special user count file ("DbUpdateUserCount.ucf") is created in the Programs
73886>>>//                 folder and a bit-lock is performed for each start of the application and this
73886>>>//                 user counter is checked before an update is attempted.
73886>>>//                 Important: Even if it seems like both garters & suspenders are used to guard
73886>>>//                            against the database being "in use", there is no such guarantee! The
73886>>>//                            database could e.g. be open in "Microsoft SQL Server Management Studio"
73886>>>//                            and there is no way of telling. SO BE CAUTIOUS before attempting an update!
73886>>>//                 A second "user count file" is also used - "DbUpdateLock.ucf". It is used to
73886>>>//                 lock everybody else out (with a Stop box) while the database is being updated. The lock will
73886>>>//                 automatically be released after the update is completed.
73886>>>//
73886>>>//
73886>>>// Usage       :  Use cDbUpdateHandler.pkg
73886>>>//                Object oDatabaseUpdateHandler is a cDbUpdateHandler
73886>>>//                    // Declare the table that contains a "database version" field.
73886>>>//                    Declare_Datafile Sys
73886>>>//                    // Either one of these syntaxes is fine:
73886>>>//                    Set Data_File_Field to File_Field Sys.DbUpdateVersion
73886>>>//                    Set Data_File_Field to (RefTable(Sys)) (RefTable(Sys.DbUpdateVersion))
73886>>>//
73886>>>//                    // Don't forget to increase the pnVersionNumber property for each
73886>>>//                    // cDbUpdateVersion object!
73886>>>//                    // The VersionTableColumn field/column specified above will be updated automatically
73886>>>//                    // with the value of pnVersionNumber after each update has been finished.
73886>>>//                    Object oVersionUpdate1.1 is a cDbUpdateVersion
73886>>>//                        Set pnVersionNumber to 1.1
73886>>>//                        Use VersionUpdate1_1.pkg
73886>>>//                    End_Object
73886>>>//
73886>>>//                    Object oVersionUpdate1.2 is a cDbUpdateVersion
73886>>>//                        Set pnVersionNumber to 1.2
73886>>>//                        Use VersionUpdate1_2.pkg
73886>>>//                    End_Object
73886>>>//
73886>>>//                End_Object
73886>>>//
73886>>>// *** To use the pbRestoreIntFilesNow & pbSaveIntFilesNow properties, the pbUseIntFilesBackup property needs to be True.
73886>>>//     Sample Code:
73886>>>//                Object oApplication is a cApplication
73886>>>//                    Set peHelpType to htHtmlHelp
73886>>>//                
73886>>>//                    Object oConnection is a cConnection
73886>>>//                        Use LoginEncryption.pkg
73886>>>//                        Use DatabaseLoginDialog.dg
73886>>>//                    End_Object
73886>>>//                
73886>>>//                    Property Boolean pbRestoreIntFilesNow False
73886>>>//                    Property Boolean pbSaveIntFilesNow False
73886>>>//                    // This allows the program to have the parameter "-restore" passed on the command line.
73886>>>//                    // If found, it will call the "RestoreIntFiles" of the cDbUpdateHandler object.
73886>>>//                    Procedure OnCreate
73886>>>//                        Handle hoCmdLine
73886>>>//                        Integer iSize iCount
73886>>>//                        String sParam
73886>>>//                        
73886>>>//                        Get phoCommandLine to hoCmdLine
73886>>>//                        Get CountOfArgs of hoCmdLine to iSize
73886>>>//                        For iCount from 1 to iSize
73886>>>//                            Get Argument of hoCmdLine iCount to sParam
73886>>>//                            If (Lowercase(sParam) contains "restore") Begin
73886>>>//                                Set pbRestoreIntFilesNow to True
73886>>>//                            End
73886>>>//                            Else If (Lowercase(sParam) contains "save") Begin
73886>>>//                                Set pbSaveIntFilesNow to True
73886>>>//                            End
73886>>>//                        Loop
73886>>>//                    End_Procedure
73886>>>//                
73886>>>//                End_Object
73886>>>//
73886>>>//                Object oDbUpdateHandler is a cDbUpdateHandler
73886>>>//                    Set piDbVersionFileNumber  to 255
73886>>>//                    Set piDbVersionFieldNumber to 1
73886>>>//                    Set phIntFilesTable to 256
73886>>>//                    Set pbUseIntFilesBackup to True
73886>>>//                    Set pbExitIfDebuggerActive to False
73886>>>//                
73886>>>//                    Procedure OnCreate
73886>>>//                        String sVersionInfo sErrorText
73886>>>//                        Boolean bRestoreIntFilesNow bSaveIntFilesNow bOK
73886>>>//                        
73886>>>//                        Get pbRestoreIntFilesNow of ghoApplication to bRestoreIntFilesNow
73886>>>//                        If (bRestoreIntFilesNow = True) Begin
73886>>>//                            Send RestoreIntFiles
73886>>>//                        End
73886>>>//                        Get pbSaveIntFilesNow of ghoApplication to bSaveIntFilesNow
73886>>>//                        If (bSaveIntFilesNow = True) Begin
73886>>>//                            Get SaveUpdateIntFiles (&sErrorText) to bOK
73886>>>//                        End 
73886>>>//                        
73886>>>//                        // To check for correct the driver and db client versions, when the program starts (each-Time it is started!)
73886>>>//                        Get MinMSSQLDRV_And_ClientVersion "24.0.29.10" SQLSERVER2019CLIENT True True to sVersionInfo
73886>>>//                    End_Procedure
73886>>>// ******************
73886>>>
73886>>>
73886>>>
73886>>>//
73886>>>// $Rev History:
73886>>>//    2016-09-27  Module header created
73886>>>//    2016-09-28  Removed the Master/Alias logic. All update code must
73886>>>//                take place before any tables have been opened, or errors
73886>>>//                could occur if the client database is out of sync with the
73886>>>//                compiled program.
73886>>>//                Added user counting checks + lockout while database is being
73886>>>//                updated.
73886>>>//    2016-10-03  Changed the class name from cDatabaseUpdateHandler to cDbUpdateHandler,
73886>>>//                as it is more in line with the child class cDbUpdateVersion name.
73886>>>//    2016-10-06  Moved constant declarations, structs etc. to separate cDbUpdateHandler.inc file
73886>>>//****************************************************************************
73886>>>Use VdfBase.pkg
73886>>>Use Dferror.pkg
73886>>>Use seq_chnl.pkg
73886>>>Use Datadict.pkg
73886>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
73886>>>>>// *** The Database Update Framework Include file for Languages ***
73886>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
73886>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
73886>>>>>//
73886>>>>>Use LanguageText.Pkg
73886>>>>>
73886>>>>>    // *** cSQLConnectionsIniFile.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
73886>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
73886>>>>>    // *** cSQLConnectionsHandler.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_SetupErrorcConnection     for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
73886>>>>>    Define CS_DUF_CannotLoginToServer       for "Could not login to the database server. Can't continue. Program will now exit."
73886>>>>>    Define CS_DUF_ErrorText                 for "\n\nError Text:"
73886>>>>>    // *** cDbUpdateFunctionLibrary.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_ConnectError              for "SQL error. Could not connect to the SQL database manager"
73886>>>>>    Define CS_DUF_AttachError               for "Could not attach to the database:"
73886>>>>>    Define CS_DUF_DeletingIndex             for "Deleting index"
73886>>>>>    Define CS_DUF_CopyingData               for "Copying data"
73886>>>>>    Define CS_DUF_CreatingIndex             for "Creating index"
73886>>>>>    Define CS_DUF_LoginToDbServerFailed     for  "Login failed to the database server. The following connect string was used:\n"
73886>>>>>    Define CS_DUF_DoYouWantToExit           for "Do you want to stop the database update and exit?"  
73886>>>>>    Define CS_DUF_NoIntFilesFound           for "No .int files found! Nothing was changed."
73886>>>>>    // *** cDbUpdateVersion.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_UpdateVersion             for "Updating database"
73886>>>>>    Define CS_DUF_UpdateFromVersion         for "from version"
73886>>>>>    Define CS_DUF_UpdateToVersion           for "to version:"
73886>>>>>    Define CS_DUF_DbUpdateTableMissing      for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
73886>>>>>    // *** cDbUpdateHandler.inc Language Constants ***
73886>>>>>    Define CS_DUF_DatabaseInUseShort        for "There are others using the application/database. Are you sure you still want to update the database?"
73886>>>>>    Define CS_DUF_DatabaseNeedsUpdate       for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
73886>>>>>    Define CS_DUF_HeaderUpdateText          for "Important!"
73886>>>>>    Define CS_DUF_DatabaseInUseText         for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
73886>>>>>    Define CS_DUF_WorkingHeaderText         for "Working!"
73886>>>>>    Define CS_DUF_WorkingUpdateText         for "The database is being updated. Please wait..."
73886>>>>>    Define CS_DUF_DatabaseUpdatedText       for "Ready! The database was updated."
73886>>>>>    Define CS_DUF_DatabaseCheckedText       for "Ready! The database was checked but no updates was needed."
73886>>>>>    Define CS_DUF_DbUpdatedErrorText        for "One or more errors occured while the database was updated. Please check the logfile in the data-folder.\n\nThe program will now close."
73886>>>>>    Define CS_DUF_UpdateInProgressTxt       for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
73886>>>>>    // *** cDbUpdateHandler.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_DatabaseConnStringSpec    for "The database specified in the connection string: '"
73886>>>>>    Define CS_DUF_DatabaseDoesntExist       for "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit."
73886>>>>>    // *** cDbUpdateLogFile.pkg Class Language Constants ***   
73886>>>>>    Define CS_DUF_LogFileNotFound           for "Could not locate the log file:\n\n"
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
73886>>>>>// StatPnl.pkg - creates the standard status_panel object.
73886>>>>>//
73886>>>>>//
73886>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
73886>>>>>// invoke the standard status panel. The standard has always been that the package name
73886>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
73886>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
73886>>>>>// prior revisions has been replace with status panel that is part of the application.
73886>>>>>// This should work much better and faster than the old sentinel based solution.
73886>>>>>// While the way this operates has changed, the interface has not and therefore this should work
73886>>>>>// with most applications.
73886>>>>>//
73886>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
73886>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
73886>>>>>// a cleaner more robust interface.
73886>>>>>//
73886>>>>>//
73886>>>>>// Compatibility Note:
73886>>>>>//
73886>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
73886>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
73886>>>>>//
73886>>>>>// If for some reason you application will not work using this as a replacement for the old status
73886>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
73886>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
73886>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
73886>>>>>//
73886>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
73886>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
73886>>>>>//
73886>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
73886>>>>>// can still access the new object via the ghoStatusPanel handle.
73886>>>>>//
73886>>>>>//
73886>>>>>// Creating your own Status Panel objects
73886>>>>>//
73886>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
73886>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
73886>>>>>// with a different file and object name and direct your status panel request to the new object.
73886>>>>>//
73886>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
73886>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
73886>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
73886>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
73886>>>>>// e.g.
73886>>>>>//       Procedure UpdateStatusBar
73886>>>>>//           Send DoAdvance of oProgressBar
73886>>>>>//           Send ProcessEvents
73886>>>>>//       End_Procedure
73886>>>>>//
73886>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
73886>>>>>// messages this will be done for you.
73886>>>>>//
73886>>>>>// the standard Interface for status panels are:
73886>>>>>//
73886>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
73886>>>>>// Send Start_StatusPanel      - start the status panel
73886>>>>>// Send Stop_StatusPanel       - stop the status panel
73886>>>>>// Send Update_StatusPanel     - update the status panel's action area
73886>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
73886>>>>>//
73886>>>>>// Get/Set Caption_Text - updates the caption bar
73886>>>>>// Get/Set Title_Text   - updates the title area
73886>>>>>// Get/Set Message_Text - updates the Message area
73886>>>>>// Get/Set Action_Text  - updates the action area
73886>>>>>// Get/Set Button_Text  - updates the button area
73886>>>>>//
73886>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
73886>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
73886>>>>>//
73886>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
73886>>>>>Use cProcessStatusPanel.pkg
73886>>>>>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJSkinFramework.pkg)
73886>>>>>>>Use windows.pkg
73886>>>>>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJComSkinFramework.pkg)
73886>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v22.0.0\Bin\Codejock.SkinFramework.Unicode.x64.v22.0.0.ocx
73886>>>>>>>>>Use FlexCom20.pkg
73886>>>>>>>>>
73886>>>>>>>>>// Changes to Imported package
73886>>>>>>>>>//     OLEXTPxx to XTPxx
73886>>>>>>>>>//     OLExtpxx to xtpxx
73886>>>>>>>>>//     OLESkinFramework to SkinFramework
73886>>>>>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
73886>>>>>>>>>//     cCom classes to cCJ
73886>>>>>>>>>//     cCJAutomationObject back to cComAutomationObject
73886>>>>>>>>>//     cCJActiveXControl back to cComActiveXControl
73886>>>>>>>>>//     cCJSkinFramework to cCJComSkinFramework
73886>>>>>>>>>//     Use statements as noted below (classes moved to these files)
73886>>>>>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
73886>>>>>>>>>
73886>>>>>>>>>// These have been extracted from this class and moved into seperate packages
73886>>>>>>>>>// because other Codejock classes use these.
73886>>>>>>>>>Use cCJColorManager.pkg     // cCJColorManager
73886>>>>>>>>>
73886>>>>>>>>>
73886>>>>>>>>>Define SkinFrameworkApplyOptions for Integer
73886>>>>>>>>>    Define xtpSkinApplyMetrics for 1
73886>>>>>>>>>    Define xtpSkinApplyFrame for 2
73886>>>>>>>>>    Define xtpSkinApplyColors for 4
73886>>>>>>>>>    Define xtpSkinApplyMenus for 8
73886>>>>>>>>>
73886>>>>>>>>>// CLSID: {C0DE2200-28D7-4F2C-87A7-7266367B4655}
73886>>>>>>>>>// Dispatch interface for SkinFramework Control
73886>>>>>>>>>Class cCJ_DSkinFramework is a Mixin
73887>>>>>>>>>
73887>>>>>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
73889>>>>>>>>>        SkinFrameworkApplyOptions retVal
73889>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
73890>>>>>>>>>        Function_Return retVal
73891>>>>>>>>>    End_Function
73892>>>>>>>>>
73892>>>>>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
73894>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
73895>>>>>>>>>    End_Procedure
73896>>>>>>>>>
73896>>>>>>>>>    Function ComAutoApplyNewWindows Returns Boolean
73898>>>>>>>>>        Boolean retVal
73898>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
73899>>>>>>>>>        Function_Return retVal
73900>>>>>>>>>    End_Function
73901>>>>>>>>>
73901>>>>>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
73903>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
73904>>>>>>>>>    End_Procedure
73905>>>>>>>>>
73905>>>>>>>>>    Function ComAutoApplyNewThreads Returns Boolean
73907>>>>>>>>>        Boolean retVal
73907>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
73908>>>>>>>>>        Function_Return retVal
73909>>>>>>>>>    End_Function
73910>>>>>>>>>
73910>>>>>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
73912>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
73913>>>>>>>>>    End_Procedure
73914>>>>>>>>>
73914>>>>>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
73916>>>>>>>>>        Handle hDispatchDriver
73916>>>>>>>>>        Boolean retVal
73916>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73917>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73918>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
73919>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
73920>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
73921>>>>>>>>>        Function_Return retVal
73922>>>>>>>>>    End_Function
73923>>>>>>>>>
73923>>>>>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
73925>>>>>>>>>        Handle hDispatchDriver
73925>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73926>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73927>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73928>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
73929>>>>>>>>>    End_Procedure
73930>>>>>>>>>
73930>>>>>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
73932>>>>>>>>>        Handle hDispatchDriver
73932>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73933>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73934>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73935>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
73936>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
73937>>>>>>>>>    End_Procedure
73938>>>>>>>>>
73938>>>>>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
73940>>>>>>>>>        Handle hDispatchDriver
73940>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73941>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73942>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73943>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
73944>>>>>>>>>    End_Procedure
73945>>>>>>>>>
73945>>>>>>>>>    Procedure ComRemoveAllWindows
73947>>>>>>>>>        Handle hDispatchDriver
73947>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73948>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
73949>>>>>>>>>    End_Procedure
73950>>>>>>>>>
73950>>>>>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
73952>>>>>>>>>        Handle hDispatchDriver
73952>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73953>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73954>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
73955>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
73956>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
73957>>>>>>>>>    End_Procedure
73958>>>>>>>>>
73958>>>>>>>>>    Procedure ComRemoveWindowClass String llClassName
73960>>>>>>>>>        Handle hDispatchDriver
73960>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73961>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73962>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
73963>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
73964>>>>>>>>>    End_Procedure
73965>>>>>>>>>
73965>>>>>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
73967>>>>>>>>>        Handle hDispatchDriver
73967>>>>>>>>>        Variant retVal
73967>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73968>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73969>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
73970>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
73971>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
73972>>>>>>>>>        Function_Return retVal
73973>>>>>>>>>    End_Function
73974>>>>>>>>>
73974>>>>>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
73976>>>>>>>>>        Handle hDispatchDriver
73976>>>>>>>>>        Variant retVal
73976>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73977>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73978>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
73979>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
73980>>>>>>>>>        Function_Return retVal
73981>>>>>>>>>    End_Function
73982>>>>>>>>>
73982>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
73984>>>>>>>>>        Handle hDispatchDriver
73984>>>>>>>>>        OLE_COLOR retVal
73984>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73985>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73986>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
73987>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
73988>>>>>>>>>        Function_Return retVal
73989>>>>>>>>>    End_Function
73990>>>>>>>>>
73990>>>>>>>>>    Procedure ComExcludeModule String llModuleName
73992>>>>>>>>>        Handle hDispatchDriver
73992>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73993>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73994>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
73995>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
73996>>>>>>>>>    End_Procedure
73997>>>>>>>>>
73997>>>>>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
73999>>>>>>>>>        Handle hDispatchDriver
73999>>>>>>>>>        Variant retVal
73999>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74000>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74001>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
74002>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
74003>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
74004>>>>>>>>>        Function_Return retVal
74005>>>>>>>>>    End_Function
74006>>>>>>>>>
74006>>>>>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
74008>>>>>>>>>        Handle hDispatchDriver
74008>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74009>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74010>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74011>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
74012>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
74013>>>>>>>>>    End_Procedure
74014>>>>>>>>>
74014>>>>>>>>>    Procedure ComAboutBox
74016>>>>>>>>>        Handle hDispatchDriver
74016>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74017>>>>>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
74018>>>>>>>>>    End_Procedure
74019>>>>>>>>>End_Class
74020>>>>>>>>>
74020>>>>>>>>>// CLSID: {C0DE2200-4463-4030-B324-AC6A8075FEC8}
74020>>>>>>>>>// Event interface for SkinFramework Control
74020>>>>>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
74021>>>>>>>>>
74021>>>>>>>>>    Procedure RegisterComEvents
74023>>>>>>>>>    End_Procedure
74024>>>>>>>>>End_Class
74025>>>>>>>>>
74025>>>>>>>>>// CoClass
74025>>>>>>>>>// ProgID: Codejock.SkinFramework.22.0.0
74025>>>>>>>>>// CLSID: {C0DE2200-2217-42EE-B1B0-82C890431F17}
74025>>>>>>>>>// SkinFramework Control
74025>>>>>>>>>Class cCJComSkinFramework is a cComActiveXControl
74026>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFramework
74027>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
74028>>>>>>>>>
74028>>>>>>>>>    Procedure Construct_Object
74030>>>>>>>>>        Forward Send Construct_Object
74032>>>>>>>>>        Set psProgID to "{C0DE2200-2217-42EE-B1B0-82C890431F17}"
74033>>>>>>>>>        Set psEventId to "{C0DE2200-4463-4030-B324-AC6A8075FEC8}"
74034>>>>>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2022 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v22.0"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
74035>>>>>>>>>        Set peAutoCreate to acAutoCreate
74036>>>>>>>>>    End_Procedure
74037>>>>>>>>>End_Class
74038>>>>>>>>>
74038>>>>>>>>>// CLSID: {C0DE2200-CA9A-4AA9-8601-0AB7F551AA3D}
74038>>>>>>>>>// SkinFramework Global Settings
74038>>>>>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
74039>>>>>>>>>
74039>>>>>>>>>    Function ComLicense Returns String
74041>>>>>>>>>        String retVal
74041>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
74042>>>>>>>>>        Function_Return retVal
74043>>>>>>>>>    End_Function
74044>>>>>>>>>
74044>>>>>>>>>    Procedure Set ComLicense String value
74046>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
74047>>>>>>>>>    End_Procedure
74048>>>>>>>>>
74048>>>>>>>>>    Function ComTitle Returns String
74050>>>>>>>>>        String retVal
74050>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
74051>>>>>>>>>        Function_Return retVal
74052>>>>>>>>>    End_Function
74053>>>>>>>>>
74053>>>>>>>>>    Procedure Set ComTitle String value
74055>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
74056>>>>>>>>>    End_Procedure
74057>>>>>>>>>
74057>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74057>>>>>>>>>    Function ComUseLegacyCore Returns Boolean
74059>>>>>>>>>        Boolean retVal
74059>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to retVal
74060>>>>>>>>>        Function_Return retVal
74061>>>>>>>>>    End_Function
74062>>>>>>>>>
74062>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74062>>>>>>>>>    Procedure Set ComUseLegacyCore Boolean value
74064>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to value
74065>>>>>>>>>    End_Procedure
74066>>>>>>>>>
74066>>>>>>>>>    Function ComVersion Returns String
74068>>>>>>>>>        Handle hDispatchDriver
74068>>>>>>>>>        String retVal
74068>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74069>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
74070>>>>>>>>>        Function_Return retVal
74071>>>>>>>>>    End_Function
74072>>>>>>>>>
74072>>>>>>>>>    Function ComUnicode Returns Boolean
74074>>>>>>>>>        Handle hDispatchDriver
74074>>>>>>>>>        Boolean retVal
74074>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74075>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
74076>>>>>>>>>        Function_Return retVal
74077>>>>>>>>>    End_Function
74078>>>>>>>>>
74078>>>>>>>>>    Function ComOcxPath Returns String
74080>>>>>>>>>        Handle hDispatchDriver
74080>>>>>>>>>        String retVal
74080>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74081>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
74082>>>>>>>>>        Function_Return retVal
74083>>>>>>>>>    End_Function
74084>>>>>>>>>End_Class
74085>>>>>>>>>
74085>>>>>>>>>// CoClass
74085>>>>>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.22.0.0
74085>>>>>>>>>// CLSID: {C0DE2200-F744-4373-B38D-29CE83EF0EE5}
74085>>>>>>>>>// SkinFramework Global Settings
74085>>>>>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
74086>>>>>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
74087>>>>>>>>>
74087>>>>>>>>>    Procedure Construct_Object
74089>>>>>>>>>        Forward Send Construct_Object
74091>>>>>>>>>        Set psProgID to "{C0DE2200-F744-4373-B38D-29CE83EF0EE5}"
74092>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
74093>>>>>>>>>    End_Procedure
74094>>>>>>>>>End_Class
74095>>>>>>>>>
74095>>>>>>>>>// CLSID: {C0DE2200-1038-498E-A936-361F08B4C4AA}
74095>>>>>>>>>Class cCJSkinIniFile is a cComAutomationObject
74096>>>>>>>>>
74096>>>>>>>>>    Function ComColorScheme Returns String
74098>>>>>>>>>        String retVal
74098>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74099>>>>>>>>>        Function_Return retVal
74100>>>>>>>>>    End_Function
74101>>>>>>>>>
74101>>>>>>>>>    Procedure Set ComColorScheme String value
74103>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74104>>>>>>>>>    End_Procedure
74105>>>>>>>>>
74105>>>>>>>>>    Function ComFontSize Returns String
74107>>>>>>>>>        String retVal
74107>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74108>>>>>>>>>        Function_Return retVal
74109>>>>>>>>>    End_Function
74110>>>>>>>>>
74110>>>>>>>>>    Procedure Set ComFontSize String value
74112>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74113>>>>>>>>>    End_Procedure
74114>>>>>>>>>
74114>>>>>>>>>    Function ComIniFileName Returns String
74116>>>>>>>>>        String retVal
74116>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
74117>>>>>>>>>        Function_Return retVal
74118>>>>>>>>>    End_Function
74119>>>>>>>>>
74119>>>>>>>>>    Procedure Set ComIniFileName String value
74121>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
74122>>>>>>>>>    End_Procedure
74123>>>>>>>>>End_Class
74124>>>>>>>>>
74124>>>>>>>>>// CLSID: {C0DE2200-4834-499E-95B4-30E0C3F43A10}
74124>>>>>>>>>Class cCJSkinDescription is a cComAutomationObject
74125>>>>>>>>>
74125>>>>>>>>>    Function ComName Returns String
74127>>>>>>>>>        String retVal
74127>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74128>>>>>>>>>        Function_Return retVal
74129>>>>>>>>>    End_Function
74130>>>>>>>>>
74130>>>>>>>>>    Procedure Set ComName String value
74132>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74133>>>>>>>>>    End_Procedure
74134>>>>>>>>>
74134>>>>>>>>>    Function ComPath Returns String
74136>>>>>>>>>        String retVal
74136>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74137>>>>>>>>>        Function_Return retVal
74138>>>>>>>>>    End_Function
74139>>>>>>>>>
74139>>>>>>>>>    Procedure Set ComPath String value
74141>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74142>>>>>>>>>    End_Procedure
74143>>>>>>>>>
74143>>>>>>>>>    Function ComCount Returns Integer
74145>>>>>>>>>        Handle hDispatchDriver
74145>>>>>>>>>        Integer retVal
74145>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74146>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74147>>>>>>>>>        Function_Return retVal
74148>>>>>>>>>    End_Function
74149>>>>>>>>>
74149>>>>>>>>>    Function ComIniFile Integer llIndex Returns Variant
74151>>>>>>>>>        Handle hDispatchDriver
74151>>>>>>>>>        Variant retVal
74151>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74152>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74153>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74154>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74155>>>>>>>>>        Function_Return retVal
74156>>>>>>>>>    End_Function
74157>>>>>>>>>
74157>>>>>>>>>    Function Com_NewEnum Returns Variant
74159>>>>>>>>>        Handle hDispatchDriver
74159>>>>>>>>>        Variant retVal
74159>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74160>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74161>>>>>>>>>        Function_Return retVal
74162>>>>>>>>>    End_Function
74163>>>>>>>>>End_Class
74164>>>>>>>>>
74164>>>>>>>>>// CLSID: {C0DE2200-FB37-4B08-A2B9-F6F8B253D697}
74164>>>>>>>>>Class cCJSkinDescriptions is a cComAutomationObject
74165>>>>>>>>>
74165>>>>>>>>>    Function ComCount Returns Integer
74167>>>>>>>>>        Handle hDispatchDriver
74167>>>>>>>>>        Integer retVal
74167>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74168>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74169>>>>>>>>>        Function_Return retVal
74170>>>>>>>>>    End_Function
74171>>>>>>>>>
74171>>>>>>>>>    Function ComSkin Integer llIndex Returns Variant
74173>>>>>>>>>        Handle hDispatchDriver
74173>>>>>>>>>        Variant retVal
74173>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74174>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74175>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74176>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74177>>>>>>>>>        Function_Return retVal
74178>>>>>>>>>    End_Function
74179>>>>>>>>>
74179>>>>>>>>>    Function Com_NewEnum Returns Variant
74181>>>>>>>>>        Handle hDispatchDriver
74181>>>>>>>>>        Variant retVal
74181>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74182>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74183>>>>>>>>>        Function_Return retVal
74184>>>>>>>>>    End_Function
74185>>>>>>>>>End_Class
74186>>>>>>>>>
74186>>>>>>>>>// CLSID: {C0DE2200-C56F-43C0-BCF1-8193B35FE4C4}
74186>>>>>>>>>Class cCJSkinSchema is a cComAutomationObject
74187>>>>>>>>>
74187>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
74189>>>>>>>>>        Handle hDispatchDriver
74189>>>>>>>>>        OLE_COLOR retVal
74189>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74190>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74191>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74192>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
74193>>>>>>>>>        Function_Return retVal
74194>>>>>>>>>    End_Function
74195>>>>>>>>>End_Class
74196>>>>>>>Use cApplication.pkg
74196>>>>>>>
74196>>>>>>>Struct tSkinInformation
74196>>>>>>>    String sName     // description of the skin
74196>>>>>>>    String sSkinfile // file path. Can be relative or full
74196>>>>>>>    String sSkinIni  // section name
74196>>>>>>>End_Struct
74196>>>>>>>
74196>>>>>>>
74196>>>>>>>Class cCJSkinFramework is a cCJComSkinFramework
74197>>>>>>>    
74197>>>>>>>    Procedure Construct_Object
74199>>>>>>>        Forward Send Construct_Object
74201>>>>>>>        
74201>>>>>>>        Property String psSkinFile ""
74202>>>>>>>        Property String psSkinIni ""
74203>>>>>>>        Property Boolean pbLoadPreference False
74204>>>>>>>        
74204>>>>>>>        Set peAutoCreate to acAutoCreate
74205>>>>>>>        
74205>>>>>>>        Move Self to ghoSkinFramework
74206>>>>>>>    End_Procedure
74207>>>>>>>    
74207>>>>>>>    // return the default skin path, which is the programs directory.
74207>>>>>>>    // This requires an application object.
74207>>>>>>>    // If you want to different skin path, override this.
74207>>>>>>>    Function SkinPath Returns String
74209>>>>>>>        String sPath sPaths
74209>>>>>>>        Handle hoWorkspace
74209>>>>>>>        If ghoApplication Begin
74211>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
74212>>>>>>>            Get psProgramPath of hoWorkspace to sPaths
74213>>>>>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
74214>>>>>>>        End
74214>>>>>>>>
74214>>>>>>>        Else Begin
74215>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74216>>>>>>>>
74216>>>>>>>        End
74216>>>>>>>>
74216>>>>>>>        Function_Return sPath
74217>>>>>>>    End_Function
74218>>>>>>>    
74218>>>>>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
74218>>>>>>>    // returns itself. If it is not, it uses SkinPath to get the path.
74218>>>>>>>    Function SkinQFile Returns String
74220>>>>>>>        String sFile sPath sSep
74220>>>>>>>        Boolean bQualified
74220>>>>>>>        Get psSkinFile to sFile
74221>>>>>>>        If not (IsFileNameQualified(sFile)) Begin
74223>>>>>>>            Get SkinPath to sPath
74224>>>>>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74225>>>>>>>            Move (sPath - sSep - sFile) to sFile
74226>>>>>>>        End
74226>>>>>>>>
74226>>>>>>>        Function_Return sFile
74227>>>>>>>    End_Function
74228>>>>>>>    
74228>>>>>>>    // defines the default VDF window class mapping.
74228>>>>>>>    Procedure OnAddVDFWindowClasses
74230>>>>>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
74231>>>>>>>        Send ComAddWindowClass "DFentry"                 "Edit"
74232>>>>>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
74233>>>>>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
74234>>>>>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
74235>>>>>>>        Send ComAddWindowClass "DFformlist"              "Edit"
74236>>>>>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
74237>>>>>>>        Send ComAddWindowClass "DFbutton"                "Button"
74238>>>>>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
74239>>>>>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
74240>>>>>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
74241>>>>>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
74242>>>>>>>        Send ComAddWindowClass "DFedit"                  "edit"
74243>>>>>>>        Send ComAddWindowClass "DFlistedit"              "edit"
74244>>>>>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
74245>>>>>>>        Send ComAddWindowClass "DFgroup"                 "Button"
74246>>>>>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
74247>>>>>>>        // External class
74247>>>>>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
74248>>>>>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
74249>>>>>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
74250>>>>>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
74251>>>>>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
74252>>>>>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
74253>>>>>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
74254>>>>>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
74255>>>>>>>    End_Procedure
74256>>>>>>>    
74256>>>>>>>    // Used to support developer designed class mappings (e.g. COM controls)
74256>>>>>>>    Procedure OnAddCustomWindowClasses
74258>>>>>>>    End_Procedure
74259>>>>>>>    
74259>>>>>>>    // called when object is created during end_construct_object.
74259>>>>>>>    Procedure OnCreate
74261>>>>>>>        Integer iOpts
74261>>>>>>>        Boolean bUseWindowsFont
74261>>>>>>>        Forward Send OnCreate
74263>>>>>>>        
74263>>>>>>>        // if we are using the windows fonts we will disable the apply metrics which
74263>>>>>>>        // never really looked good anyway. This test only exists or legacy purposes
74263>>>>>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
74264>>>>>>>        If bUseWindowsFont Begin
74266>>>>>>>            Get ComApplyOptions to iOpts
74267>>>>>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
74268>>>>>>>        End
74268>>>>>>>>
74268>>>>>>>        
74268>>>>>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
74268>>>>>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
74268>>>>>>>        // and this was the suggested workaround.
74268>>>>>>>        Set ComAutoApplyNewThreads to False
74269>>>>>>>        
74269>>>>>>>        Send OnAddVDFWindowClasses
74270>>>>>>>        Send OnAddCustomWindowClasses
74271>>>>>>>        
74271>>>>>>>        // if preferences are used, it will set psSkinFile and psSkinIni
74271>>>>>>>        If (pbLoadPreference(Self)) Begin
74273>>>>>>>            Send LoadSkinPreference
74274>>>>>>>        End
74274>>>>>>>>
74274>>>>>>>        // if a skin file name exists, we apply the skin.
74274>>>>>>>        If (psSkinFile(Self)<>"") Begin
74276>>>>>>>            Send ApplySkin
74277>>>>>>>        End
74277>>>>>>>>
74277>>>>>>>    End_Procedure
74278>>>>>>>    
74278>>>>>>>    // called by framework as part of application exit.
74278>>>>>>>    Procedure Broadcast_Notify_Exit_Application
74280>>>>>>>        Send Notify_Exit_Application
74281>>>>>>>    End_Procedure
74282>>>>>>>    
74282>>>>>>>    Procedure Notify_Exit_Application
74284>>>>>>>        If (pbLoadPreference(Self)) Begin
74286>>>>>>>            Send SaveSkinPreference
74287>>>>>>>        End
74287>>>>>>>>
74287>>>>>>>    End_Procedure
74288>>>>>>>    
74288>>>>>>>    Procedure NotifyPreApplySkin
74290>>>>>>>        Broadcast Send OnPreApplySkin of Desktop True
74292>>>>>>>    End_Procedure
74293>>>>>>>    
74293>>>>>>>    Procedure NotifyPostApplySkin
74295>>>>>>>        Broadcast Send OnPostApplySkin of Desktop True
74297>>>>>>>    End_Procedure
74298>>>>>>>    
74298>>>>>>>    // returns an array of all skins in the path. If path is "", use the default path.
74298>>>>>>>    // If the default path is used, returns the file names as relative names, else use full path.
74298>>>>>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
74300>>>>>>>        tSkinInformation[] Skins
74300>>>>>>>        tSkinInformation[] Skins
74301>>>>>>>        String sSkinName sSkinFile sDefaultPath sSep
74301>>>>>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
74301>>>>>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
74301>>>>>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
74301>>>>>>>        Integer iPos iDfltLen
74301>>>>>>>        Boolean bUseRelativePath
74301>>>>>>>        
74301>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74302>>>>>>>        
74302>>>>>>>        Get SkinPath to sDefaultPath
74303>>>>>>>        If (sPath="") Begin
74305>>>>>>>            Move sDefaultPath to sPath
74306>>>>>>>        End
74306>>>>>>>>
74306>>>>>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
74307>>>>>>>        Move (Length(sDefaultPath)) to iDfltLen
74308>>>>>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
74309>>>>>>>        
74309>>>>>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
74310>>>>>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
74312>>>>>>>            
74312>>>>>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
74313>>>>>>>            Get Create U_cCJSkinDescription to hSkinDescription
74314>>>>>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
74315>>>>>>>            
74315>>>>>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
74316>>>>>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
74317>>>>>>>            
74317>>>>>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
74323>>>>>>>>
74323>>>>>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
74324>>>>>>>                Set pvComObject of hSkinDescription to vSkinDescription
74325>>>>>>>                
74325>>>>>>>                Get ComCount of hSkinDescription to iNumSkins
74326>>>>>>>                
74326>>>>>>>                For iSkinsCount from 0 to (iNumSkins-1)
74332>>>>>>>>
74332>>>>>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
74333>>>>>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
74334>>>>>>>                    
74334>>>>>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
74335>>>>>>>                    Get ComPath of hSkinDescription to sSkinFile
74336>>>>>>>                    If bUseRelativePath Begin
74338>>>>>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
74339>>>>>>>                        If iPos Begin
74341>>>>>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
74342>>>>>>>                            While (Left(sSkinFile,1)=sSep)
74346>>>>>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
74347>>>>>>>                            Loop
74348>>>>>>>>
74348>>>>>>>                        End
74348>>>>>>>>
74348>>>>>>>                    End
74348>>>>>>>>
74348>>>>>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
74349>>>>>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
74350>>>>>>>                    
74350>>>>>>>                    Increment iArrayItem
74351>>>>>>>                Loop
74352>>>>>>>>
74352>>>>>>>            Loop
74353>>>>>>>>
74353>>>>>>>            
74353>>>>>>>            Send Destroy of hSkinDescriptions
74354>>>>>>>            Send Destroy of hSkinDescription
74355>>>>>>>            Send Destroy of hSkinIniFile
74356>>>>>>>            
74356>>>>>>>        End
74356>>>>>>>>
74356>>>>>>>        Function_Return Skins
74357>>>>>>>    End_Function
74358>>>>>>>    
74358>>>>>>>    // Save the skin preference. This requires an application object.
74358>>>>>>>    // Only do this if the application object allows it.
74358>>>>>>>    // This is called during startup if pbLoadPreference is True
74358>>>>>>>    // Suitable for override
74358>>>>>>>    Procedure SaveSkinPreference
74360>>>>>>>        String sSkin sIni
74360>>>>>>>        If ghoApplication Begin
74362>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74364>>>>>>>                Get psSkinFile to sSkin
74365>>>>>>>                Get psSkinIni to sIni
74366>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
74367>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
74368>>>>>>>            End
74368>>>>>>>>
74368>>>>>>>        End
74368>>>>>>>>
74368>>>>>>>        Else Begin
74369>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74370>>>>>>>>
74370>>>>>>>        End
74370>>>>>>>>
74370>>>>>>>    End_Procedure
74371>>>>>>>    
74371>>>>>>>    // Load the skin preference. This requires an application object.
74371>>>>>>>    // Only do this if the application object allows it.
74371>>>>>>>    // This is called during startup if pbLoadPreference is True
74371>>>>>>>    // Suitable for override
74371>>>>>>>    Procedure LoadSkinPreference
74373>>>>>>>        String sSkin sIni
74373>>>>>>>        Boolean bExists
74373>>>>>>>        If ghoApplication Begin
74375>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74377>>>>>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
74378>>>>>>>                If bExists Begin
74380>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
74381>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
74382>>>>>>>                    Set psSkinFile to sSkin
74383>>>>>>>                    Set psSkinIni to sIni
74384>>>>>>>                End
74384>>>>>>>>
74384>>>>>>>            End
74384>>>>>>>>
74384>>>>>>>        End
74384>>>>>>>>
74384>>>>>>>        Else Begin
74385>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74386>>>>>>>>
74386>>>>>>>        End
74386>>>>>>>>
74386>>>>>>>    End_Procedure
74387>>>>>>>    
74387>>>>>>>    // Can be called to apply the current skin.
74387>>>>>>>    Procedure ApplySkin
74389>>>>>>>        Boolean bOk
74389>>>>>>>        String sSkin sIni
74389>>>>>>>        If (IsComObjectCreated(Self)) Begin
74391>>>>>>>            Get SkinQFile to sSkin
74392>>>>>>>            Get psSkinIni to sIni
74393>>>>>>>            
74393>>>>>>>            Send NotifyPreApplySkin
74394>>>>>>>            // when skins are used we don't want to use built in Visual Styles
74394>>>>>>>            Send EnableVisualStyles of Desktop (sSkin="")
74395>>>>>>>            Get ComLoadSkin sSkin sIni to bOK
74396>>>>>>>            If (sSkin<>"" and not(bOk)) Begin
74398>>>>>>>                // if not ok, no skin was appied. Enable visual styles
74398>>>>>>>                Send EnableVisualStyles of Desktop True
74399>>>>>>>            End
74399>>>>>>>>
74399>>>>>>>            Send NotifyPostApplySkin
74400>>>>>>>        End
74400>>>>>>>>
74400>>>>>>>    End_Procedure
74401>>>>>>>    
74401>>>>>>>    
74401>>>>>>>End_Class
74402>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cProgressBar.pkg)
74402>>>>>>>Use Windows.pkg
74402>>>>>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cWinControl.pkg)
74402>>>>>>>>>Use Windows.pkg
74402>>>>>>>>>
74402>>>>>>>>>// Key State Masks for Mouse Messages
74402>>>>>>>>>
74402>>>>>>>>>Define MK_LBUTTON  for |CI$0001
74402>>>>>>>>>Define MK_RBUTTON  for |CI$0002
74402>>>>>>>>>Define MK_SHIFT    for |CI$0004
74402>>>>>>>>>Define MK_CONTROL  for |CI$0008
74402>>>>>>>>>Define MK_MBUTTON  for |CI$0010
74402>>>>>>>>>Define MK_XBUTTON1 for |CI$0020
74402>>>>>>>>>Define MK_XBUTTON2 for |CI$0040
74402>>>>>>>>>
74402>>>>>>>>>Enum_List // Mouse Key Flags
74402>>>>>>>>>    Define mkLeft    for MK_LBUTTON
74402>>>>>>>>>    Define mkMiddle  for MK_MBUTTON
74402>>>>>>>>>    Define mkRight   for MK_RBUTTON
74402>>>>>>>>>    Define mkX1      for MK_XBUTTON1
74402>>>>>>>>>    Define mkX2      for MK_XBUTTON2
74402>>>>>>>>>    Define mkShift   for MK_SHIFT
74402>>>>>>>>>    Define mkControl for MK_CONTROL
74402>>>>>>>>>End_Enum_List
74402>>>>>>>>>
74402>>>>>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
74402>>>>>>>>>    Define mbLeft
74402>>>>>>>>>    Define mbMiddle
74402>>>>>>>>>    Define mbRight
74402>>>>>>>>>    Define mbX1
74402>>>>>>>>>    Define mbX2
74402>>>>>>>>>End_Enum_List
74402>>>>>>>>>
74402>>>>>>>>>Class cWinControl is a DfBaseControl
74403>>>>>>>>>    Procedure Construct_Object
74405>>>>>>>>>        Forward Send Construct_Object
74407>>>>>>>>>        Property Integer private_pbEnabled True
74408>>>>>>>>>        Property Integer private_pbVisible True
74409>>>>>>>>>    End_Procedure
74410>>>>>>>>>    
74410>>>>>>>>>    Procedure End_Construct_Object
74412>>>>>>>>>        Forward Send End_Construct_Object
74414>>>>>>>>>        
74414>>>>>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
74415>>>>>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
74416>>>>>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
74417>>>>>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
74418>>>>>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
74419>>>>>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
74420>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
74421>>>>>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
74422>>>>>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
74423>>>>>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
74424>>>>>>>>>    End_Procedure
74425>>>>>>>>>    
74425>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
74427>>>>>>>>>        //Intentionally cancelled
74427>>>>>>>>>    End_Procedure
74428>>>>>>>>>    
74428>>>>>>>>>    Procedure Command Longptr wParam Longptr lParam
74430>>>>>>>>>        //Intentionally cancelled
74430>>>>>>>>>    End_Procedure
74431>>>>>>>>>    
74431>>>>>>>>>    Procedure DoRecreateWindow
74433>>>>>>>>>        // Recreates the window
74433>>>>>>>>>        If (Window_Handle(Self)) Begin
74435>>>>>>>>>            // attempt to do this without disturbing the focus tree.
74435>>>>>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
74436>>>>>>>>>            Send Page 1      //                       Send Page_Object 1
74437>>>>>>>>>        End
74437>>>>>>>>>>
74437>>>>>>>>>    End_Procedure
74438>>>>>>>>>    
74438>>>>>>>>>    Procedure DoUpdateWindow
74440>>>>>>>>>        // Forces windows to update the window by bypassing WM_PAINT
74440>>>>>>>>>        Handle hWnd
74440>>>>>>>>>        
74440>>>>>>>>>        Get Window_Handle to hWnd
74441>>>>>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
74444>>>>>>>>>    End_Procedure
74445>>>>>>>>>    
74445>>>>>>>>>    Procedure Page Integer iState
74447>>>>>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
74448>>>>>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
74449>>>>>>>>>        Forward Send Page iState
74451>>>>>>>>>    End_Procedure
74452>>>>>>>>>    
74452>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
74454>>>>>>>>>        Integer x y eButton
74454>>>>>>>>>        
74454>>>>>>>>>        Move (Hi(lParam))  to y
74455>>>>>>>>>        Move (Low(lParam)) to x
74456>>>>>>>>>        
74456>>>>>>>>>        Send OnMouseUp mbLeft x y wParam
74457>>>>>>>>>    End_Procedure
74458>>>>>>>>>    
74458>>>>>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
74460>>>>>>>>>        Integer x y eButton
74460>>>>>>>>>        
74460>>>>>>>>>        Move (Hi(lParam))  to y
74461>>>>>>>>>        Move (Low(lParam)) to x
74462>>>>>>>>>        
74462>>>>>>>>>        Send OnMouseUp mbMiddle x y wParam
74463>>>>>>>>>    End_Procedure
74464>>>>>>>>>    
74464>>>>>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
74466>>>>>>>>>        Integer x y eButton
74466>>>>>>>>>        
74466>>>>>>>>>        Move (Hi(lParam))  to y
74467>>>>>>>>>        Move (Low(lParam)) to x
74468>>>>>>>>>        
74468>>>>>>>>>        Send OnMouseUp mbRight x y wParam
74469>>>>>>>>>    End_Procedure
74470>>>>>>>>>    
74470>>>>>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
74472>>>>>>>>>        Integer x y eButton fKeys
74472>>>>>>>>>        
74472>>>>>>>>>        Move (Hi(lParam))  to y
74473>>>>>>>>>        Move (Low(lParam)) to x
74474>>>>>>>>>        
74474>>>>>>>>>        Send OnMouseDown mbLeft x y wParam
74475>>>>>>>>>    End_Procedure
74476>>>>>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
74478>>>>>>>>>        Integer x y eButton
74478>>>>>>>>>        
74478>>>>>>>>>        Move (Hi(lParam))  to y
74479>>>>>>>>>        Move (Low(lParam)) to x
74480>>>>>>>>>        
74480>>>>>>>>>        Send OnMouseDown mbMiddle x y wParam
74481>>>>>>>>>    End_Procedure
74482>>>>>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
74484>>>>>>>>>        Integer x y eButton
74484>>>>>>>>>        
74484>>>>>>>>>        Move (Hi(lParam))  to y
74485>>>>>>>>>        Move (Low(lParam)) to x
74486>>>>>>>>>        
74486>>>>>>>>>        Send OnMouseDown mbRight x y wParam
74487>>>>>>>>>    End_Procedure
74488>>>>>>>>>    
74488>>>>>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
74490>>>>>>>>>        Integer x y eButton
74490>>>>>>>>>        
74490>>>>>>>>>        Move (Hi(lParam))  to y
74491>>>>>>>>>        Move (Low(lParam)) to x
74492>>>>>>>>>        
74492>>>>>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
74493>>>>>>>>>    End_Procedure
74494>>>>>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
74496>>>>>>>>>        Integer x y eButton
74496>>>>>>>>>        
74496>>>>>>>>>        Move (Hi(lParam))  to y
74497>>>>>>>>>        Move (Low(lParam)) to x
74498>>>>>>>>>        
74498>>>>>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
74499>>>>>>>>>    End_Procedure
74500>>>>>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
74502>>>>>>>>>        Integer x y eButton
74502>>>>>>>>>        
74502>>>>>>>>>        Move (Hi(lParam))  to y
74503>>>>>>>>>        Move (Low(lParam)) to x
74504>>>>>>>>>        
74504>>>>>>>>>        Send OnMouseDoubleClick mbRight x y wParam
74505>>>>>>>>>    End_Procedure
74506>>>>>>>>>    
74506>>>>>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
74508>>>>>>>>>        Integer x y eButton
74508>>>>>>>>>        
74508>>>>>>>>>        Move (Hi(lParam))  to y
74509>>>>>>>>>        Move (Low(lParam)) to x
74510>>>>>>>>>        
74510>>>>>>>>>        Send OnMouseMove x y wParam
74511>>>>>>>>>    End_Procedure
74512>>>>>>>>>    
74512>>>>>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
74514>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74514>>>>>>>>>        //String sButton
74514>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74514>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74514>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74514>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74514>>>>>>>>>        
74514>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74514>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74514>>>>>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74514>>>>>>>>>    End_Procedure
74515>>>>>>>>>    
74515>>>>>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
74517>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74517>>>>>>>>>        //String sButton
74517>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74517>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74517>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74517>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74517>>>>>>>>>        
74517>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74517>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74517>>>>>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74517>>>>>>>>>    End_Procedure
74518>>>>>>>>>    
74518>>>>>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
74520>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74520>>>>>>>>>        //String sButton
74520>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74520>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74520>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74520>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74520>>>>>>>>>        
74520>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74520>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74520>>>>>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74520>>>>>>>>>    End_Procedure
74521>>>>>>>>>    
74521>>>>>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
74523>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74523>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74523>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74523>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74523>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74523>>>>>>>>>        
74523>>>>>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74523>>>>>>>>>    End_Procedure
74524>>>>>>>>>    
74524>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
74526>>>>>>>>>        Handle hWnd
74526>>>>>>>>>        
74526>>>>>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
74528>>>>>>>>>            Set private_pbEnabled to bEnabled
74529>>>>>>>>>            Get Window_Handle to hWnd
74530>>>>>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
74533>>>>>>>>>        End
74533>>>>>>>>>>
74533>>>>>>>>>    End_Procedure
74534>>>>>>>>>    Function pbEnabled Returns Boolean
74536>>>>>>>>>        Function_Return (private_pbEnabled(Self))
74537>>>>>>>>>    End_Function
74538>>>>>>>>>    
74538>>>>>>>>>    Procedure Set pbVisible Boolean bVisible
74540>>>>>>>>>        Handle  hWnd
74540>>>>>>>>>        Integer iVoid
74540>>>>>>>>>        
74540>>>>>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
74542>>>>>>>>>            Set private_pbVisible to bVisible
74543>>>>>>>>>            Get Window_Handle to hWnd
74544>>>>>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
74547>>>>>>>>>        End
74547>>>>>>>>>>
74547>>>>>>>>>    End_Procedure
74548>>>>>>>>>    Function pbVisible Returns Boolean
74550>>>>>>>>>        Function_Return (private_pbVisible(Self))
74551>>>>>>>>>    End_Function
74552>>>>>>>>>    
74552>>>>>>>>>End_Class
74553>>>>>>>Use CommCtrl.pkg
74553>>>>>>>
74553>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
74553>>>>>>>Class cProgressBar is a cWinControl
74554>>>>>>>    
74554>>>>>>>    Procedure Construct_Object
74556>>>>>>>        Forward Send Construct_Object
74558>>>>>>>        Property Integer private_piMinimum
74559>>>>>>>        Property Integer private_piMaximum   100
74560>>>>>>>        Property Integer private_piAdvanceBy 10
74561>>>>>>>        Property Integer private_piPosition
74562>>>>>>>        Property Integer private_pbVertical  False
74563>>>>>>>        Property Integer private_pbSmooth    False
74564>>>>>>>        Property Integer private_piBackColor clDefault
74565>>>>>>>        Property Integer private_piBarColor  clDefault
74566>>>>>>>        
74566>>>>>>>        Send Define_ToolTip_Support_Mixin
74567>>>>>>>        
74567>>>>>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
74568>>>>>>>        Set Focus_Mode to NonFocusable
74569>>>>>>>        Set Skip_State to True
74570>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
74571>>>>>>>    End_Procedure
74572>>>>>>>    
74572>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
74573>>>>>>>    
74573>>>>>>>    Procedure Set piMinimum Integer iMin
74575>>>>>>>        Integer iMax
74575>>>>>>>        
74575>>>>>>>        Set private_piMinimum to iMin
74576>>>>>>>        Get private_piMaximum to iMax
74577>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74578>>>>>>>    End_Procedure
74579>>>>>>>    Function piMinimum Returns Integer
74581>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
74584>>>>>>>        Else;            Function_Return (private_piMinimum(Self))
74586>>>>>>>    End_Function
74587>>>>>>>    
74587>>>>>>>    Procedure Set piMaximum Integer iMax
74589>>>>>>>        Integer iMin
74589>>>>>>>        
74589>>>>>>>        Set private_piMaximum to iMax
74590>>>>>>>        Get private_piMinimum to iMin
74591>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74592>>>>>>>    End_Procedure
74593>>>>>>>    Function piMaximum Returns Integer
74595>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
74598>>>>>>>        Else;            Function_Return (private_piMaximum(Self))
74600>>>>>>>    End_Function
74601>>>>>>>    
74601>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
74603>>>>>>>        Set private_piAdvanceBy to iAdvanceBy
74604>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
74605>>>>>>>    End_Procedure
74606>>>>>>>    Function piAdvanceBy Returns Integer
74608>>>>>>>        Function_Return (private_piAdvanceBy(Self))
74609>>>>>>>    End_Function
74610>>>>>>>    
74610>>>>>>>    Procedure Set piPosition Integer iPos
74612>>>>>>>        Set private_piPosition to iPos
74613>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
74614>>>>>>>    End_Procedure
74615>>>>>>>    
74615>>>>>>>    Function piPosition Returns Integer
74617>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
74620>>>>>>>        Else;            Function_Return (private_piPosition(Self))
74622>>>>>>>    End_Function
74623>>>>>>>    
74623>>>>>>>    Procedure Set pbVertical Boolean bVertical
74625>>>>>>>        If (private_pbVertical(Self) <> bVertical) Begin
74627>>>>>>>            Set private_pbVertical to bVertical
74628>>>>>>>            Send DoRecreateWindow
74629>>>>>>>        End
74629>>>>>>>>
74629>>>>>>>    End_Procedure
74630>>>>>>>    
74630>>>>>>>    Function pbVertical Returns Boolean
74632>>>>>>>        Function_Return (private_pbVertical(Self))
74633>>>>>>>    End_Function
74634>>>>>>>    
74634>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
74636>>>>>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
74638>>>>>>>            Set private_pbSmooth to bSmooth
74639>>>>>>>            Send DoRecreateWindow
74640>>>>>>>        End
74640>>>>>>>>
74640>>>>>>>    End_Procedure
74641>>>>>>>    Function pbSmooth Returns Boolean
74643>>>>>>>        Function_Return (private_pbSmooth(Self))
74644>>>>>>>    End_Function
74645>>>>>>>    
74645>>>>>>>    Procedure Set piBackColor Integer rgbColor
74647>>>>>>>        Set private_piBackColor to rgbColor
74648>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
74649>>>>>>>    End_Procedure
74650>>>>>>>    Function piBackColor Returns Integer
74652>>>>>>>        Function_Return (private_piBackColor(Self))
74653>>>>>>>    End_Function
74654>>>>>>>    
74654>>>>>>>    Procedure Set piBarColor Integer rgbColor
74656>>>>>>>        Set private_piBarColor to rgbColor
74657>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
74658>>>>>>>    End_Procedure
74659>>>>>>>    Function piBarColor Returns Integer
74661>>>>>>>        Function_Return (private_piBarColor(Self))
74662>>>>>>>    End_Function
74663>>>>>>>    
74663>>>>>>>    Procedure DoAdvance
74665>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
74666>>>>>>>    End_Procedure
74667>>>>>>>    
74667>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
74669>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
74670>>>>>>>    End_Procedure
74671>>>>>>>    
74671>>>>>>>    Procedure private_DoInitWindow
74673>>>>>>>        Set piBarColor  to (private_piBarColor(Self))
74674>>>>>>>        Set piBackColor to (private_piBackColor(Self))
74675>>>>>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
74676>>>>>>>        Set piMinimum   to (private_piMinimum(Self))
74677>>>>>>>        Set piMaximum   to (private_piMaximum(Self))
74678>>>>>>>        Set piPosition  to (private_piPosition(Self))
74679>>>>>>>    End_Procedure
74680>>>>>>>    
74680>>>>>>>    Procedure Page_Object Integer iState
74682>>>>>>>        Handle hWnd
74682>>>>>>>        
74682>>>>>>>        Get Window_Handle to hWnd
74683>>>>>>>        If (hWnd=0 and iState) Begin
74685>>>>>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
74686>>>>>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
74687>>>>>>>            Forward Send Page_Object True
74689>>>>>>>        End
74689>>>>>>>>
74689>>>>>>>        Else ;            Forward Send Page_Object iState
74692>>>>>>>        
74692>>>>>>>        // Handle tooltip support....
74692>>>>>>>        If (iState = 0) Begin
74694>>>>>>>            Send RequestDeleteToolTip
74695>>>>>>>        End
74695>>>>>>>>
74695>>>>>>>        Else Begin
74696>>>>>>>            Send RequestAddToolTip
74697>>>>>>>        End
74697>>>>>>>>
74697>>>>>>>    End_Procedure
74698>>>>>>>    
74698>>>>>>>    Procedure Page Integer iState
74700>>>>>>>        Forward Send Page iState
74702>>>>>>>        If (iState =1);            Send private_DoInitWindow
74705>>>>>>>    End_Procedure
74706>>>>>>>    
74706>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
74706>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
74706>>>>>>>    // is implemented in a mixin class.
74706>>>>>>>    Procedure RequestAddToolTip
74708>>>>>>>        Send AddToolTip
74709>>>>>>>    End_Procedure
74710>>>>>>>    
74710>>>>>>>    
74710>>>>>>>    // Called by Page_Object. Handles tooltip removal.
74710>>>>>>>    Procedure RequestDeleteToolTip
74712>>>>>>>        Send DeleteToolTip
74713>>>>>>>    End_Procedure
74714>>>>>>>End_Class
74715>>>>>Use Windows.pkg
74715>>>>>Use DUFLanguageConstants.inc
74715>>>>>Use Statpnl.pkg
74715>>>>>
74715>>>>>
74715>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
74715>>>>>
74715>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
74715>>>>>
74715>>>>>Object Status_Panel is a cProcessStatusPanel
74717>>>>>    Set Size to 152 222
74718>>>>>    Set Border_Style to Border_Dialog
74719>>>>>    Set Icon to "Default.ico"
74720>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
74721>>>>>
74721>>>>>    Property Boolean Cancel_Button_Visible_State True
74723>>>>>
74723>>>>>    Procedure Activate
74726>>>>>        Integer iSizeBefore
74726>>>>>        Get GuiSize to iSizeBefore
74727>>>>>        Forward Send Activate
74729>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
74730>>>>>    End_Procedure
74731>>>>>
74731>>>>>    Procedure End_Construct_Object
74734>>>>>        Forward Send End_Construct_Object
74736>>>>>        Set Label of oTitleTxt      to ""
74737>>>>>        Set Label of oTableNameTxt  to ""
74738>>>>>        Set Label of oMessageTxt    to ""
74739>>>>>        Set Label of oActionTxt     to ""
74740>>>>>    End_Procedure
74741>>>>>
74741>>>>>    Object oTitleTxt is a TextBox
74743>>>>>        Set Location to 5 21
74744>>>>>        Set Size to 8 179
74745>>>>>        Set Auto_Size_State to False
74746>>>>>        Set Justification_Mode  to jMode_Center
74747>>>>>        Set Label to "This is the Title Text"
74748>>>>>    End_Object
74749>>>>>
74749>>>>>    Object oTableNameTxt is a TextBox
74751>>>>>        Set Size to 19 204
74752>>>>>        Set Location to 18 9
74753>>>>>        Set Auto_Size_State to False
74754>>>>>        Set Justification_Mode to JMode_Left
74755>>>>>        Set Label to "This is the TableName Text"
74756>>>>>    End_Object
74757>>>>>
74757>>>>>    Object oMessageTxt is a TextBox
74759>>>>>        Set Location to 39 9
74760>>>>>        Set Size to 19 204
74761>>>>>        Set Auto_Size_State to False
74762>>>>>        Set Justification_Mode to JMode_Left
74763>>>>>        Set Label to "This is the Message text"
74764>>>>>    End_Object
74765>>>>>
74765>>>>>    Object oActionTxt is a TextBox
74767>>>>>        Set Size to 16 204
74768>>>>>        Set Location to 60 9
74769>>>>>        Set Auto_Size_State to False
74770>>>>>        Set Justification_Mode to JMode_Left
74771>>>>>        Set Label to "This is the Action Text"
74772>>>>>    End_Object
74773>>>>>
74773>>>>>    Object oStopButton is a Button
74775>>>>>        Set Location to 123 82
74776>>>>>        Set Label to C_$Cancel
74777>>>>>
74777>>>>>        Procedure OnClick 
74780>>>>>            Integer iRetval
74780>>>>>            Get YesNo_Box CS_DUF_DoYouWantToExit to iRetval
74781>>>>>            If (iRetval = MBR_Yes) Begin
74783>>>>>                Send Exit_Application
74784>>>>>            End
74784>>>>>>
74784>>>>>        End_Procedure
74785>>>>>
74785>>>>>    End_Object
74786>>>>>
74786>>>>>    Object oPercentage_tb is a TextBox
74788>>>>>        Set Location to 74 196
74789>>>>>        Set Size to 10 25
74790>>>>>//        Set Label to "% Done"
74790>>>>>    End_Object
74791>>>>>
74791>>>>>    Object oCopyRight is a TextBox
74793>>>>>        Set Location to 140 21
74794>>>>>        Set Size to 9 197
74795>>>>>        Set FontPointHeight to 8
74796>>>>>        Set Auto_Size_State to False
74797>>>>>        Set Justification_Mode  to jMode_Center
74798>>>>>        Set Label to "Copyright 2001-2024 RDC Tools International"
74799>>>>>    End_Object
74800>>>>>
74800>>>>>    Object oProgressBar is a cProgressBar
74802>>>>>        Set Size to 10 179
74803>>>>>        Set Location to 83 22
74804>>>>>        Set pbVisible to True // default
74805>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
74806>>>>>    End_Object
74807>>>>>
74807>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
74810>>>>>        Set pbVisible of ghoProgressBar to bVisible
74811>>>>>    End_Procedure
74812>>>>>
74812>>>>>    Function Progress_Bar_Visible_State Returns Boolean
74815>>>>>        Boolean bVisible
74815>>>>>        Get pbVisible of ghoProgressBar to bVisible
74816>>>>>        Function_Return (bVisible)
74817>>>>>    End_Function
74818>>>>>
74818>>>>>    Object oProgressBarOverall is a cProgressBar
74820>>>>>        Set Size to 10 179
74821>>>>>        Set Location to 107 22
74822>>>>>        Set pbVisible to True // default
74823>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
74824>>>>>    End_Object
74825>>>>>
74825>>>>>    Object oOverallProgress_tb is a TextBox
74827>>>>>        Set Size to 10 65
74828>>>>>        Set Location to 95 24
74829>>>>>        Set Label to "Overall Progress"
74830>>>>>    End_Object
74831>>>>>
74831>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
74834>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible 
74835>>>>>        Set Visible_State of oOverallProgress_tb to bVisible
74836>>>>>    End_Procedure
74837>>>>>
74837>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
74840>>>>>        Boolean bVisible
74840>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
74841>>>>>        Function_Return (bVisible)
74842>>>>>    End_Function
74843>>>>>
74843>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
74843>>>>>    // objects defined within this instance of the status panel.
74843>>>>>
74843>>>>>    // note: all of the messages that change text should be forwarded
74843>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
74843>>>>>
74843>>>>>    Procedure Set Message_Text String sText
74846>>>>>        Set Label of oMessageTxt to sText
74847>>>>>        Forward Set Message_Text to sText
74849>>>>>    End_Procedure
74850>>>>>
74850>>>>>    Function Message_Text Returns String
74853>>>>>        Function_Return (Label(oMessageTxt))
74854>>>>>    End_Function
74855>>>>>
74855>>>>>    Procedure Set Action_Text String sText
74858>>>>>        Set Label of oActionTxt to sText
74859>>>>>        Forward Set Action_Text to sText
74861>>>>>    End_Procedure
74862>>>>>
74862>>>>>    Function Action_Text Returns String
74865>>>>>        Function_Return (Label(oActionTxt))
74866>>>>>    End_Function
74867>>>>>
74867>>>>>    Procedure Set Button_Text String sText
74870>>>>>        Set Label of oStopButton to sText
74871>>>>>        Forward Set Button_Text to sText
74873>>>>>    End_Procedure
74874>>>>>
74874>>>>>    Function Button_Text Returns String
74877>>>>>        Function_Return (Label(oStopButton))
74878>>>>>    End_Function
74879>>>>>
74879>>>>>    Procedure Set Title_Text String sText
74882>>>>>        Set Label of oTitleTxt to sText
74883>>>>>        Forward Set Title_Text to sText
74885>>>>>    End_Procedure
74886>>>>>
74886>>>>>    Function Title_Text Returns String
74889>>>>>        Function_Return (Label(oTitleTxt))
74890>>>>>    End_Function
74891>>>>>
74891>>>>>    Procedure Set TableName_Text String sText
74894>>>>>        Set Label of oTableNameTxt to sText
74895>>>>>    End_Procedure
74896>>>>>
74896>>>>>    Function TableName_Text Returns String
74899>>>>>        Function_Return (Label(oTableNameTxt))
74900>>>>>    End_Function
74901>>>>>
74901>>>>>    Procedure Set License_Text String sText
74904>>>>>//        Set Label of oLicense_txt to sText
74904>>>>>    End_Procedure 
74905>>>>>    
74905>>>>>    Procedure Set piMaximum Integer iSize
74908>>>>>        Set piMaximum of ghoProgressBar to iSize
74909>>>>>    End_Procedure  
74910>>>>>    
74910>>>>>    Procedure Set piAdvanceBy Integer iCount
74913>>>>>        Set piAdvanceBy of ghoProgressBar to iCount
74914>>>>>    End_Procedure
74915>>>>>
74915>>>>>    Procedure DoAdvance
74918>>>>>        Send DoAdvance of ghoProgressBar
74919>>>>>    End_Procedure
74920>>>>>    
74920>>>>>    // gets called when status panel is activated passing whether a button
74920>>>>>    // should appear
74920>>>>>    Procedure EnableCancelButton Boolean bEnable
74923>>>>>        Boolean bVisible
74923>>>>>        Get Cancel_Button_Visible_State to bVisible
74924>>>>>        If (bEnable = False) Begin
74926>>>>>            Set Visible_State of oStopButton to bVisible
74927>>>>>        End
74927>>>>>>
74927>>>>>        Set Enabled_State of oStopButton to bEnable
74928>>>>>    End_Procedure
74929>>>>>
74929>>>>>    Procedure Reset_StatusPanel
74932>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
74933>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
74934>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
74935>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
74936>>>>>    End_Procedure
74937>>>>>
74937>>>>>//    Object oProgressBar is a cProgressBar
74937>>>>>//        Move Self to ghoProgressBar
74937>>>>>//        Set Location to 1 25
74937>>>>>//        Set Size to 9 173
74937>>>>>//        Set piMinimum        to 0
74937>>>>>//        Set piMaximum        to 2000
74937>>>>>//        Set piAdvanceBy      to 100
74937>>>>>//        Set pbSmooth to True
74937>>>>>//
74937>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
74937>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
74937>>>>>//        // color will show correctly.
74937>>>>>//        Procedure Page Integer iPageObject
74937>>>>>//            Handle hWin
74937>>>>>//            Forward Send Page iPageObject
74937>>>>>//            If (ghoSkinFramework <> 0) Begin
74937>>>>>//                Get Window_Handle to hWin
74937>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
74937>>>>>//            End
74937>>>>>//        End_Procedure
74937>>>>>//    End_Object
74937>>>>>
74937>>>>>End_Object
74938>>>>>
74938>>>Use cDbUpdateHandler.inc // Contains cDbUpdateHandler class constants, structs etc.
Including file: cDbUpdateHandler.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.inc)
74938>>>>>// Constant declarations, structs etc. for the cDbUdpateHandler class.
74938>>>>>//
74938>>>>>Use VdfBase.pkg
74938>>>>>Use cApplication.pkg
74938>>>>>Use seq_chnl.pkg
74938>>>>>Use vWin32fh.pkg
Including file: vWin32fh.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vWin32fh.pkg)
74938>>>>>>>// This code is part of VDF GUIdance
74938>>>>>>>// Visit us @ http://www.vdf-guidance.com
74938>>>>>>>// e-Mail us @ info@vdf-guidance.com
74938>>>>>>>// VDF GUIdance is a mutual project of
74938>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
74938>>>>>>>// Wil van Antwerpen  - Antwise Solutions
74938>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
74938>>>>>>>//
74938>>>>>>>//
74938>>>>>>>// *** Windows 32bit file handling wrapper class ***
74938>>>>>>>//
74938>>>>>>>
74938>>>>>>>
74938>>>>>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
74938>>>>>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\cvFileDialogs.pkg)
74938>>>>>>>>>//***************************************************************************
74938>>>>>>>>>//*
74938>>>>>>>>>//* Class:        cvSaveAsDialog
74938>>>>>>>>>//* Package Name: cvFileDialogs.pkg
74938>>>>>>>>>//*
74938>>>>>>>>>//***************************************************************************
74938>>>>>>>>>
74938>>>>>>>>>Use File_dlg.pkg
74938>>>>>>>>>
74938>>>>>>>>>// *WvA: 13-01-1999 Created
74938>>>>>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
74938>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
74938>>>>>>>>>// file_name.
74938>>>>>>>>>Class cvSelectFile_Dialog is an OpenDialog
74939>>>>>>>>>
74939>>>>>>>>>    Procedure Construct_Object Integer iImage_Id
74941>>>>>>>>>        Forward Send Construct_Object iImage_Id
74943>>>>>>>>>        Set HideReadOnly_State to True
74944>>>>>>>>>    End_Procedure
74945>>>>>>>>>
74945>>>>>>>>>    Function SelectedFileName Returns String
74947>>>>>>>>>        String sFileName
74947>>>>>>>>>        Move "" to sFileName
74948>>>>>>>>>        If (Show_Dialog(Self)) Begin
74950>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
74951>>>>>>>>>        End
74951>>>>>>>>>>
74951>>>>>>>>>        Function_Return sFileName
74952>>>>>>>>>    End_Function
74953>>>>>>>>>End_Class
74954>>>>>>>>>
74954>>>>>>>>>// *WvA: 13-01-1999 Created
74954>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
74954>>>>>>>>>// file_name. Returns '' if the user didn't make a selection.
74954>>>>>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
74954>>>>>>>>>//                   file-open dialog
74954>>>>>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
74956>>>>>>>>>    String sSelectedFile
74956>>>>>>>>>    Integer hoOpenFileDialog
74956>>>>>>>>>
74956>>>>>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
74958>>>>>>>>>
74958>>>>>>>>>        Set Dialog_Caption    to sCaptionText
74959>>>>>>>>>        Set Filter_String     to sSupportedFileTypes
74960>>>>>>>>>        Set Initial_Folder    to sInitialFolder
74961>>>>>>>>>
74961>>>>>>>>>        Move Self       to hoOpenFileDialog
74962>>>>>>>>>    End_Object
74963>>>>>>>>>
74963>>>>>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
74964>>>>>>>>>    Send Destroy_Object to hoOpenFileDialog
74965>>>>>>>>>    Function_Return sSelectedFile
74966>>>>>>>>>End_Function
74967>>>>>>>>>
74967>>>>>>>>>Class cvSaveAsDialog is a SaveAsDialog
74968>>>>>>>>>
74968>>>>>>>>>    Procedure Construct_Object
74970>>>>>>>>>        Forward Send Construct_Object
74972>>>>>>>>>        Set HideReadOnly_State to True
74973>>>>>>>>>    End_Procedure
74974>>>>>>>>>
74974>>>>>>>>>    Function SelectedFileName Returns String
74976>>>>>>>>>        String sFileName
74976>>>>>>>>>        Move "" to sFileName
74977>>>>>>>>>        If (Show_Dialog(Self)) Begin
74979>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
74980>>>>>>>>>        End
74980>>>>>>>>>>
74980>>>>>>>>>        Function_Return sFileName
74981>>>>>>>>>    End_Function
74982>>>>>>>>>
74982>>>>>>>>>End_Class
74983>>>>>>>>>
74983>>>>>>>>>// Added optional default filename as suggested by Nils
74983>>>>>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
74985>>>>>>>>>    String sSelectedFile
74985>>>>>>>>>    Integer hoDialog
74985>>>>>>>>>
74985>>>>>>>>>    Move "" to sSelectedFile
74986>>>>>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
74987>>>>>>>>>    If (hoDialog) Begin
74989>>>>>>>>>    //Set NoChangeDir_State Of hoDialog To True
74989>>>>>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
74990>>>>>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
74991>>>>>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
74992>>>>>>>>>        If (Num_Arguments = 4) Begin
74994>>>>>>>>>            Set File_Title        of hoDialog to sDefaultFileName
74995>>>>>>>>>        End
74995>>>>>>>>>>
74995>>>>>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
74996>>>>>>>>>        Send Destroy of hoDialog
74997>>>>>>>>>    End
74997>>>>>>>>>>
74997>>>>>>>>>    Function_Return sSelectedFile
74998>>>>>>>>>End_Function
74999>>>>>>>Use Seq_chnl.pkg
74999>>>>>>>
74999>>>>>>>Use windows.pkg
74999>>>>>>>Use Dll.pkg
74999>>>>>>>
74999>>>>>>>Use vWin32fhW.pkg     // WinAPI Unicode version
Including file: vwin32fhW.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fhW.pkg)
74999>>>>>>>>>// This code is part of VDF GUIdance
74999>>>>>>>>>// Visit us @ http://www.vdf-guidance.com
74999>>>>>>>>>// e-Mail us @ info@vdf-guidance.com
74999>>>>>>>>>// VDF GUIdance is a mutual project of
74999>>>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
74999>>>>>>>>>// Wil van Antwerpen  - Antwise Solutions
74999>>>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
74999>>>>>>>>>//
74999>>>>>>>>>//
74999>>>>>>>>>// *** Windows 32bit file handling wrapper class ***
74999>>>>>>>>>// Unicode variant
74999>>>>>>>>>
74999>>>>>>>>>Use vWin32fhW.h       // Header file with WinAPI Unicode declarations
Including file: vwin32fhW.h    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fhW.h)
74999>>>>>>>>>>>//TH-Header
74999>>>>>>>>>>>//*****************************************************************************************
74999>>>>>>>>>>>// Copyright (c)  2004 KURANT Project
74999>>>>>>>>>>>// All rights reserved.
74999>>>>>>>>>>>//
74999>>>>>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
74999>>>>>>>>>>>// $ProjectName : Windows 32 bits file handling
74999>>>>>>>>>>>// $Authors     : Wil van Antwerpen
74999>>>>>>>>>>>// $Created     : 19.02.2004  19:25
74999>>>>>>>>>>>// $Type        : BSD (as in do with it whatever you like)
74999>>>>>>>>>>>//
74999>>>>>>>>>>>// Contents:
74999>>>>>>>>>>>//  This file contains the Windows API external function call definitions and
74999>>>>>>>>>>>//  constants as they are used in the vWin32fh package.
74999>>>>>>>>>>>//*****************************************************************************************
74999>>>>>>>>>>>//TH-RevisionStart
74999>>>>>>>>>>>//TH-RevisionEnd
74999>>>>>>>>>>>
74999>>>>>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
74999>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
74999>>>>>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
74999>>>>>>>>>>>
74999>>>>>>>>>>>
74999>>>>>>>>>>>Define vMax_Path     For |CI260
74999>>>>>>>>>>>Define vMinChar      For |CI$80
74999>>>>>>>>>>>Define vMaxChar      For |CI$7F
74999>>>>>>>>>>>Define vMinShort     For |CI$8000
74999>>>>>>>>>>>Define vMaxShort     For |CI$7FFF
74999>>>>>>>>>>>Define vMinLong      For |CI$80000000
74999>>>>>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
74999>>>>>>>>>>>Define vMaxByte      For |CI$FF
74999>>>>>>>>>>>Define vMaxWord      For |CI$FFFF
74999>>>>>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
74999>>>>>>>>>>>
74999>>>>>>>>>>>
74999>>>>>>>>>>>
74999>>>>>>>>>>>// For FindFirstFile
74999>>>>>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
74999>>>>>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
74999>>>>>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
74999>>>>>>>>>>>
74999>>>>>>>>>>>// The defines below can be used to find out what kind of error has occurred if
74999>>>>>>>>>>>// the API-call ShellExecute is used.
74999>>>>>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
74999>>>>>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
74999>>>>>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
74999>>>>>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
74999>>>>>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
74999>>>>>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
74999>>>>>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
74999>>>>>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
74999>>>>>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
74999>>>>>>>>>>>Define vSE_ERR_FNF             For |CI0002
74999>>>>>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
74999>>>>>>>>>>>Define vSE_ERR_OOM             For |CI0008
74999>>>>>>>>>>>Define vSE_ERR_PNF             For |CI0003
74999>>>>>>>>>>>Define vSE_ERR_SHARE           For |CI0026
74999>>>>>>>>>>>
74999>>>>>>>>>>>
74999>>>>>>>>>>>// C-Structure
74999>>>>>>>>>>>//typedef struct _browseinfo {
74999>>>>>>>>>>>//    HWND hwndOwner;
74999>>>>>>>>>>>//    LPCITEMIDLIST pidlRoot;
74999>>>>>>>>>>>//    LPSTR pszDisplayName;
74999>>>>>>>>>>>//    LPCSTR lpszTitle;
74999>>>>>>>>>>>//    UINT ulFlags;
74999>>>>>>>>>>>//    BFFCALLBACK lpfn;
74999>>>>>>>>>>>//    LPARAM lParam;
74999>>>>>>>>>>>//    int iImage;
74999>>>>>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
74999>>>>>>>>>>>
74999>>>>>>>>>>>//declare C structure struct_browseinfo
74999>>>>>>>>>>>//as documented in MSDN under Windows Shell API
74999>>>>>>>>>>>Struct tvBrowseInfo
74999>>>>>>>>>>>  Handle    hWndOwner
74999>>>>>>>>>>>  Pointer   pIDLRoot
74999>>>>>>>>>>>  Pointer   pszDisplayName
74999>>>>>>>>>>>  Pointer   lpszTitle
74999>>>>>>>>>>>  DWord     ulFlags
74999>>>>>>>>>>>    DWord   BrowseInfoMissingAlignment1
74999>>>>>>>>>>>  Pointer   lpfnCallback
74999>>>>>>>>>>>  LongPtr   lParam
74999>>>>>>>>>>>  DWord     iImage
74999>>>>>>>>>>>    DWord   BrowseInfoMissingAlignment2
74999>>>>>>>>>>>End_Struct // tvBrowseInfo
74999>>>>>>>>>>>
74999>>>>>>>>>>>// Browsing for directory.
74999>>>>>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
74999>>>>>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
74999>>>>>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
74999>>>>>>>>>>>                                            // The callback function can set the status text by
74999>>>>>>>>>>>                                            // sending messages to the dialog box.
74999>>>>>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
74999>>>>>>>>>>>
74999>>>>>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
74999>>>>>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
74999>>>>>>>>>>>
74999>>>>>>>>>>>// message from browser
74999>>>>>>>>>>>//Define BFFM_INITIALIZED        1
74999>>>>>>>>>>>//Define BFFM_SELCHANGED         2
74999>>>>>>>>>>>
74999>>>>>>>>>>>// messages to browser
74999>>>>>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
74999>>>>>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
74999>>>>>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
74999>>>>>>>>>>>
74999>>>>>>>>>>>
74999>>>>>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolderW" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
75000>>>>>>>>>>>
75000>>>>>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDListW" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
75001>>>>>>>>>>>
75001>>>>>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
75002>>>>>>>>>>>
75002>>>>>>>>>>>
75002>>>>>>>>>>>
75002>>>>>>>>>>>
75002>>>>>>>>>>>Struct tvSecurity_attributes
75002>>>>>>>>>>>  DWord   nLength
75002>>>>>>>>>>>    DWord   Security_attributesMissingAlignment1
75002>>>>>>>>>>>  Pointer lpDescriptor
75002>>>>>>>>>>>  Integer bInheritHandle
75002>>>>>>>>>>>    Integer Security_attributesMissingAlignment2
75002>>>>>>>>>>>End_Struct // tvSecurity_attributes
75002>>>>>>>>>>>
75002>>>>>>>>>>>//nLength:
75002>>>>>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
75002>>>>>>>>>>>// SECURITY_ATTRIBUTES structure.
75002>>>>>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
75002>>>>>>>>>>>// value of the nLength member. However, an application should still set it properly.
75002>>>>>>>>>>>// That ensures current, future, and cross-platform compatibility.
75002>>>>>>>>>>>//
75002>>>>>>>>>>>//lpSecurityDescriptor:
75002>>>>>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
75002>>>>>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
75002>>>>>>>>>>>// descriptor of the calling process.
75002>>>>>>>>>>>//
75002>>>>>>>>>>>//bInheritHandle:
75002>>>>>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
75002>>>>>>>>>>>// If this member is TRUE, the new process inherits the handle.
75002>>>>>>>>>>>
75002>>>>>>>>>>>
75002>>>>>>>>>>>// BOOL CreateDirectory(
75002>>>>>>>>>>>//    LPCTSTR lpPathName,
75002>>>>>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
75002>>>>>>>>>>>//   );
75002>>>>>>>>>>>//
75002>>>>>>>>>>>// lpPathName
75002>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
75002>>>>>>>>>>>//  to be created.
75002>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
75002>>>>>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
75002>>>>>>>>>>>// lpSecurityAttributes
75002>>>>>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
75002>>>>>>>>>>>//  determines whether the returned handle can be inherited by child processes.
75002>>>>>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
75002>>>>>>>>>>>// Returns:
75002>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
75002>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
75002>>>>>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryW" kernel32.dll ;  WString sPathName Pointer lpSecurity_Attributes Returns Integer
75003>>>>>>>>>>>
75003>>>>>>>>>>>
75003>>>>>>>>>>>// lpPathName
75003>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
75003>>>>>>>>>>>//  to be removed.
75003>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
75003>>>>>>>>>>>// Returns:
75003>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
75003>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
75003>>>>>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryW" kernel32.dll ;  WString sPathName Returns Integer
75004>>>>>>>>>>>
75004>>>>>>>>>>>
75004>>>>>>>>>>>
75004>>>>>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
75004>>>>>>>>>>>// executable file or a document file.
75004>>>>>>>>>>>//
75004>>>>>>>>>>>// Operation can be one of the following:
75004>>>>>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
75004>>>>>>>>>>>//            The file can be an executable file or a document file.
75004>>>>>>>>>>>//            The file can be a folder to open.
75004>>>>>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
75004>>>>>>>>>>>//            The file should be a document file. If the file is an executable file,
75004>>>>>>>>>>>//            the function opens the file, as if "open" had been specified.
75004>>>>>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
75004>>>>>>>>>>>//
75004>>>>>>>>>>>// Return Values:
75004>>>>>>>>>>>//
75004>>>>>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
75004>>>>>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
75004>>>>>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
75004>>>>>>>>>>>//
75004>>>>>>>>>>>// The following table lists these error values:
75004>>>>>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
75004>>>>>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
75004>>>>>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
75004>>>>>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
75004>>>>>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
75004>>>>>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
75004>>>>>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
75004>>>>>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
75004>>>>>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
75004>>>>>>>>>>>// Public Const SE_ERR_FNF = 2
75004>>>>>>>>>>>// Public Const SE_ERR_NOASSOC = 31
75004>>>>>>>>>>>// Public Const SE_ERR_OOM = 8
75004>>>>>>>>>>>// Public Const SE_ERR_PNF = 3
75004>>>>>>>>>>>// Public Const SE_ERR_SHARE = 26
75004>>>>>>>>>>>
75004>>>>>>>>>>>
75004>>>>>>>>>>>
75004>>>>>>>>>>>// Code to open the program that is associated with the selected file.
75004>>>>>>>>>>>//
75004>>>>>>>>>>>// External function call used in Procedure DoStartDocument
75004>>>>>>>>>>>External_function vWin32_ShellExecute "ShellExecuteW" shell32.dll ;  Handle  hWnd ;  WString wsOperation ;  WString wsFile ;  WString wsParameters ;  WString wsDirectory ;  Dword   iShowCmd Returns Handle
75005>>>>>>>>>>>
75005>>>>>>>>>>>
75005>>>>>>>>>>>
75005>>>>>>>>>>>
75005>>>>>>>>>>>Define vFO_MOVE                For |CI$0001
75005>>>>>>>>>>>Define vFO_COPY                For |CI$0002
75005>>>>>>>>>>>Define vFO_DELETE              For |CI$0003
75005>>>>>>>>>>>Define vFO_RENAME              For |CI$0004
75005>>>>>>>>>>>
75005>>>>>>>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
75005>>>>>>>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
75005>>>>>>>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
75005>>>>>>>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
75005>>>>>>>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
75005>>>>>>>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
75005>>>>>>>>>>>                                          // Must be freed using SHFreeNameMappings
75005>>>>>>>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
75005>>>>>>>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
75005>>>>>>>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
75005>>>>>>>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
75005>>>>>>>>>>>
75005>>>>>>>>>>>Struct tvShFileOpStruct
75005>>>>>>>>>>>  Handle   hWnd
75005>>>>>>>>>>>  UInteger wFunc
75005>>>>>>>>>>>    UInteger ShFileOpStructMissingAlignment1
75005>>>>>>>>>>>  Pointer  pFrom
75005>>>>>>>>>>>  Pointer  pTo
75005>>>>>>>>>>>  Short    fFlags
75005>>>>>>>>>>>  Integer  fAnyOperationsAborted
75005>>>>>>>>>>>    Short  ShFileOpStructMissingAlignment2
75005>>>>>>>>>>>  Pointer  hNameMappings
75005>>>>>>>>>>>  Pointer  lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
75005>>>>>>>>>>>End_Struct // tvShFileOpStruct
75005>>>>>>>>>>>
75005>>>>>>>>>>>// hwnd
75005>>>>>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
75005>>>>>>>>>>>
75005>>>>>>>>>>>// wFunc
75005>>>>>>>>>>>//   Operation to perform. This member can be one of the following values:
75005>>>>>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
75005>>>>>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
75005>>>>>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
75005>>>>>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
75005>>>>>>>>>>>
75005>>>>>>>>>>>// pFrom
75005>>>>>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
75005>>>>>>>>>>>//   be null-separated. The list of names must be double null-terminated.
75005>>>>>>>>>>>
75005>>>>>>>>>>>// pTo
75005>>>>>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
75005>>>>>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
75005>>>>>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
75005>>>>>>>>>>>//   double null-terminated.
75005>>>>>>>>>>>
75005>>>>>>>>>>>// fAnyOperationsAborted
75005>>>>>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
75005>>>>>>>>>>>//   were completed or FALSE otherwise.
75005>>>>>>>>>>>
75005>>>>>>>>>>>
75005>>>>>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
75005>>>>>>>>>>>// This can be a file or a folder.
75005>>>>>>>>>>>// With thanks to Andrew S Kaplan
75005>>>>>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationW" Shell32.dll ;        Pointer lpFileOp Returns Integer
75006>>>>>>>>>>>
75006>>>>>>>>>>>
75006>>>>>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
75006>>>>>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryW" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
75007>>>>>>>>>>>
75007>>>>>>>>>>>
75007>>>>>>>>>>>
75007>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75007>>>>>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
75007>>>>>>>>>>>//   Pointer lpPathName ;
75007>>>>>>>>>>>//   Pointer lpPrefixString ;
75007>>>>>>>>>>>//   Integer uUnique ;
75007>>>>>>>>>>>//   Pointer lpTempFileName ;
75007>>>>>>>>>>>//   Returns Integer
75007>>>>>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
75007>>>>>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameW" kernel32.dll WString sPath ;        WString sPrefix Integer iUnique Pointer lpTempFileName Returns Integer
75008>>>>>>>>>>>
75008>>>>>>>>>>>External_function vWin32_GetTempPath "GetTempPathW" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
75009>>>>>>>>>>>
75009>>>>>>>>>>>External_function vWin32_DeleteFile "DeleteFileW" Kernel32.Dll ;   WString sFileName ;   Returns Integer
75010>>>>>>>>>>>
75010>>>>>>>>>>>// from:
75010>>>>>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
75010>>>>>>>>>>>//
75010>>>>>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
75010>>>>>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
75010>>>>>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
75010>>>>>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
75010>>>>>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
75010>>>>>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
75010>>>>>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
75010>>>>>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
75010>>>>>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
75010>>>>>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
75010>>>>>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
75010>>>>>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
75010>>>>>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
75010>>>>>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
75010>>>>>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
75010>>>>>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
75010>>>>>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
75010>>>>>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
75010>>>>>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
75010>>>>>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
75010>>>>>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
75010>>>>>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
75010>>>>>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
75010>>>>>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
75010>>>>>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
75010>>>>>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
75010>>>>>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
75010>>>>>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
75010>>>>>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
75010>>>>>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
75010>>>>>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
75010>>>>>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
75010>>>>>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
75010>>>>>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
75010>>>>>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
75010>>>>>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
75010>>>>>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
75010>>>>>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
75010>>>>>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
75010>>>>>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
75010>>>>>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
75010>>>>>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
75010>>>>>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
75010>>>>>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
75010>>>>>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
75010>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
75010>>>>>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
75010>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
75010>>>>>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
75010>>>>>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
75010>>>>>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
75010>>>>>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
75010>>>>>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
75010>>>>>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
75010>>>>>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
75010>>>>>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
75010>>>>>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
75010>>>>>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
75010>>>>>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
75010>>>>>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
75010>>>>>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
75010>>>>>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
75010>>>>>>>>>>>
75010>>>>>>>>>>>
75010>>>>>>>>>>>//HRESULT SHGetFolderPath(
75010>>>>>>>>>>>//    HWND hwndOwner,
75010>>>>>>>>>>>//    int nFolder,
75010>>>>>>>>>>>//    HANDLE hToken,
75010>>>>>>>>>>>//    DWORD dwFlags,
75010>>>>>>>>>>>//    LPTSTR pszPath
75010>>>>>>>>>>>//);
75010>>>>>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
75010>>>>>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
75010>>>>>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
75010>>>>>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
75010>>>>>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
75010>>>>>>>>>>>//
75010>>>>>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathW" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
75011>>>>>>>>>>>
75011>>>>>>>>>>>
75011>>>>>>>>>>>
75011>>>>>>>>>>>Struct tvWin32FindData
75011>>>>>>>>>>> Dword            dwFileAttributes
75011>>>>>>>>>>> Dword            ftCreationLowDateTime
75011>>>>>>>>>>> Dword            ftCreationHighDateTime
75011>>>>>>>>>>> dword            ftLastAccessLowDateTime
75011>>>>>>>>>>> Dword            ftLastAccessHighDateTime
75011>>>>>>>>>>> Dword            ftLastWriteLowDateTime
75011>>>>>>>>>>> Dword            ftLastWriteHighDateTime
75011>>>>>>>>>>> Dword            nFileSizeHigh
75011>>>>>>>>>>> Dword            nFileSizeLow
75011>>>>>>>>>>> Dword            dwReserved0
75011>>>>>>>>>>> Dword            dwReserved1
75011>>>>>>>>>>> Short[vMax_Path] cFileName
75011>>>>>>>>>>> Short[14]        cAlternateFileName
75011>>>>>>>>>>>End_Struct
75011>>>>>>>>>>>
75011>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75011>>>>>>>>>>>// lpFileName      : address of name of file to search for
75011>>>>>>>>>>>// lpFindFileData  : address of returned information
75011>>>>>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileW"  Kernel32.dll WString sFileName ;          Pointer lpFindFileData Returns Handle
75012>>>>>>>>>>>
75012>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75012>>>>>>>>>>>// hFindFile       : handle of search
75012>>>>>>>>>>>// lpFindFileData  : address of structure for data on found file
75012>>>>>>>>>>>External_function vWin32_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
75013>>>>>>>>>>>
75013>>>>>>>>>>>
75013>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75013>>>>>>>>>>>//  hFindFile      : file search handle
75013>>>>>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
75014>>>>>>>>>>>
75014>>>>>>>>>>>
75014>>>>>>>>>>>
75014>>>>>>>>>>>Struct tvFileTime
75014>>>>>>>>>>>  DWord dwLowDateTime
75014>>>>>>>>>>>  DWord dwHighDateTime
75014>>>>>>>>>>>End_Struct
75014>>>>>>>>>>>
75014>>>>>>>>>>>
75014>>>>>>>>>>>Struct tvSystemTime
75014>>>>>>>>>>>  UShort wYear
75014>>>>>>>>>>>  UShort wMonth
75014>>>>>>>>>>>  UShort wDayOfWeek
75014>>>>>>>>>>>  UShort wDay
75014>>>>>>>>>>>  UShort wHour
75014>>>>>>>>>>>  UShort wMinute
75014>>>>>>>>>>>  UShort wSecond
75014>>>>>>>>>>>  UShort wMilliSeconds
75014>>>>>>>>>>>End_Struct
75014>>>>>>>>>>>
75014>>>>>>>>>>>
75014>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75014>>>>>>>>>>>//  lpFileTime     : pointer to file time to convert
75014>>>>>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
75014>>>>>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
75015>>>>>>>>>>>
75015>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75015>>>>>>>>>>>// This function formats the time in a picture-string passed
75015>>>>>>>>>>>//
75015>>>>>>>>>>>// Picture      Meaning
75015>>>>>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
75015>>>>>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
75015>>>>>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
75015>>>>>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
75015>>>>>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
75015>>>>>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
75015>>>>>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
75015>>>>>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
75015>>>>>>>>>>>//    t         One character time marker string, such as A or P
75015>>>>>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
75015>>>>>>>>>>>//
75015>>>>>>>>>>>// For example, to get the time string  "11:29:40 PM"
75015>>>>>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
75015>>>>>>>>>>>
75015>>>>>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
75016>>>>>>>>>>>
75016>>>>>>>>>>>
75016>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75016>>>>>>>>>>>// This function formats the date in a picture-string passed
75016>>>>>>>>>>>//
75016>>>>>>>>>>>// Picture      Meaning
75016>>>>>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
75016>>>>>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
75016>>>>>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
75016>>>>>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
75016>>>>>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
75016>>>>>>>>>>>//              value associated with the specified locale.
75016>>>>>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
75016>>>>>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
75016>>>>>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
75016>>>>>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
75016>>>>>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
75016>>>>>>>>>>>//              associated with the specified locale.
75016>>>>>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
75016>>>>>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
75016>>>>>>>>>>>//    yyyy      Year represented hy full four digits.
75016>>>>>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
75016>>>>>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
75016>>>>>>>>>>>//              does not have an associated era or period string.
75016>>>>>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
75016>>>>>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
75016>>>>>>>>>>>
75016>>>>>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
75017>>>>>>>>>>>
75017>>>>>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
75017>>>>>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
75017>>>>>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
75017>>>>>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
75017>>>>>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
75017>>>>>>>>>>>
75017>>>>>>>>>>>//  Date Flags for GetDateFormatW.
75017>>>>>>>>>>>//
75017>>>>>>>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
75017>>>>>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
75017>>>>>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
75017>>>>>>>>>>>
75017>>>>>>>>>>>
75017>>>>>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
75018>>>>>>>>>>>
75018>>>>>>>>>>>
75018>>>>>>>>>>>// **WvA: 20-02-2004
75018>>>>>>>>>>>// While i was testing the format capabilities i stumbled over a very
75018>>>>>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
75018>>>>>>>>>>>// incorrectly into an unsigned integer.
75018>>>>>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
75018>>>>>>>>>>>// It does smell a bit fishy though
75018>>>>>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
75018>>>>>>>>>>>
75018>>>>>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
75018>>>>>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
75018>>>>>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
75018>>>>>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
75018>>>>>>>>>>>
75018>>>>>>>>>>>// Possible errors that can be returned by the shellformat function
75018>>>>>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
75018>>>>>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
75018>>>>>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
75018>>>>>>>>>>>
75018>>>>>>>>>>>
75018>>>>>>>>>>> // Courtesy Of Steve Walter,
75018>>>>>>>>>>> // USA Software, Inc
75018>>>>>>>>>>> // Format a disk
75018>>>>>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
75018>>>>>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
75019>>>>>>>>>>>
75019>>>>>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
75019>>>>>>>>>>>
75019>>>>>>>>>>>// SHCreateDirectoryEx
75019>>>>>>>>>>>
75019>>>>>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
75019>>>>>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
75019>>>>>>>>>>>//
75019>>>>>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
75019>>>>>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
75019>>>>>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
75019>>>>>>>>>>>//
75019>>>>>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
75019>>>>>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
75019>>>>>>>>>>>//        ERROR_CANCELLED.
75019>>>>>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
75019>>>>>>>>>>>
75019>>>>>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
75019>>>>>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
75019>>>>>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
75019>>>>>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
75019>>>>>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
75019>>>>>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
75019>>>>>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
75019>>>>>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
75019>>>>>>>>>>>
75019>>>>>>>>>>>//        int SHCreateDirectoryEx(
75019>>>>>>>>>>>//            HWND hwnd,
75019>>>>>>>>>>>//            LPCTSTR pszPath,
75019>>>>>>>>>>>//            const SECURITY_ATTRIBUTES *psa
75019>>>>>>>>>>>//        );
75019>>>>>>>>>>>
75019>>>>>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExW" shell32.dll Handle hWnd;                  WString wPath  Pointer lpSecurity_Attributes Returns Integer
75020>>>>>>>>>>>
75020>>>>>>>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryW" SHLWAPI.DLL WString wPath Returns Integer
75021>>>>>>>>>
75021>>>>>>>>>
75021>>>>>>>>>
75021>>>>>>>>>// Does the directory exist? - No = false, Yes = True
75021>>>>>>>>>// This also works with UNC path encoding and wildcards
75021>>>>>>>>>Function vFolderExists Global String sFolderName Returns Boolean
75023>>>>>>>>>    Boolean bFolderExists
75023>>>>>>>>>    Boolean bStop
75023>>>>>>>>>    String  sFolder sTmp
75023>>>>>>>>>    Integer iCh
75023>>>>>>>>>
75023>>>>>>>>>    If (sFolderName = "") Begin
75025>>>>>>>>>        Function_Return False
75026>>>>>>>>>    End
75026>>>>>>>>>>
75026>>>>>>>>>
75026>>>>>>>>>    Move True  to bFolderExists
75027>>>>>>>>>    Move False to bStop
75028>>>>>>>>>    Move "dir:" to sFolder
75029>>>>>>>>>    Append sFolder sFolderName
75030>>>>>>>>>    Get Seq_New_Channel to iCh  // get free channel for input
75031>>>>>>>>>    If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75033>>>>>>>>>        Error DFERR_PROGRAM "No I/O channel available for process (vFolderExists)"
75034>>>>>>>>>>
75034>>>>>>>>>        Function_Return False
75035>>>>>>>>>    End
75035>>>>>>>>>>
75035>>>>>>>>>    Direct_Input channel iCh sFolder
75037>>>>>>>>>    Repeat
75037>>>>>>>>>>
75037>>>>>>>>>        Readln channel iCh sTmp
75039>>>>>>>>>        Move (SeqEof) to bStop
75040>>>>>>>>>        If (Trim(sTmp)="") Begin
75042>>>>>>>>>            Move False to bFolderExists
75043>>>>>>>>>        End
75043>>>>>>>>>>
75043>>>>>>>>>        Else Begin
75044>>>>>>>>>            Move True to bFolderExists
75045>>>>>>>>>            Move True to bStop
75046>>>>>>>>>        End
75046>>>>>>>>>>
75046>>>>>>>>>    Until (bStop)
75048>>>>>>>>>    Close_Input channel iCh
75050>>>>>>>>>    Send Seq_Release_Channel iCh
75051>>>>>>>>>    Function_Return bFolderExists
75052>>>>>>>>>End_Function
75053>>>>>>>>>
75053>>>>>>>>>// returns folder name if a folder was selected, otherwise returns ""
75053>>>>>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
75055>>>>>>>>>    String  sPath
75055>>>>>>>>>    WString sFolder sTitle
75055>>>>>>>>>    Pointer lpItemIdList
75055>>>>>>>>>    Integer iFolderSelected iRetval
75055>>>>>>>>>    tvBrowseInfo BrowseInfo
75055>>>>>>>>>    tvBrowseInfo BrowseInfo
75055>>>>>>>>>
75055>>>>>>>>>    Move "" to sPath
75056>>>>>>>>>    If (sDialogTitle<>"") Begin
75058>>>>>>>>>        Move sDialogTitle to sTitle
75059>>>>>>>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
75059>>>>>>>>>        // disables showing some commonly used ascii characters like ascii 137 (ë)
75059>>>>>>>>>        // These chars are correctly shown if no toansi is used.
75059>>>>>>>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
75059>>>>>>>>>        // selected it will always be valid.
75059>>>>>>>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
75060>>>>>>>>>    End
75060>>>>>>>>>>
75060>>>>>>>>>
75060>>>>>>>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
75061>>>>>>>>>
75061>>>>>>>>>    // Torben Lund added line below. Move handle of focus object to structure before
75061>>>>>>>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
75061>>>>>>>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
75062>>>>>>>>>
75062>>>>>>>>>    // null 128 chars into var (make space)
75062>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
75063>>>>>>>>>
75063>>>>>>>>>    // select folder
75063>>>>>>>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
75064>>>>>>>>>    // get selected folder name
75064>>>>>>>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
75065>>>>>>>>>
75065>>>>>>>>>    // release memory resources that are used by the ItemIdList
75065>>>>>>>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
75066>>>>>>>>>
75066>>>>>>>>>    If (iFolderSelected<>0) Begin
75068>>>>>>>>>        Move (CString(sFolder)) to sPath
75069>>>>>>>>>    End
75069>>>>>>>>>>
75069>>>>>>>>>    Function_Return  sPath
75070>>>>>>>>>End_Function
75071>>>>>>>>>
75071>>>>>>>>>// returns 0 if the folder is created.
75071>>>>>>>>>//         1 if the API-call returned an error.
75071>>>>>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
75073>>>>>>>>>    Integer  iRetval bFolderCreated
75073>>>>>>>>>    WString  sFolder
75073>>>>>>>>>    tvSecurity_attributes SA
75073>>>>>>>>>    tvSecurity_attributes SA
75073>>>>>>>>>
75073>>>>>>>>>    Move False to bFolderCreated
75074>>>>>>>>>    If (sNewFolder <> "") Begin
75076>>>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
75077>>>>>>>>>        Move  0                                  to SA.lpDescriptor
75078>>>>>>>>>        Move  1                                  to SA.bInheritHandle
75079>>>>>>>>>        Move (sNewFolder+Character(0)) to sFolder
75080>>>>>>>>>        Move (vWin32_CreateDirectory(sFolder, AddressOf(SA))) to bFolderCreated
75081>>>>>>>>>    End
75081>>>>>>>>>>
75081>>>>>>>>>
75081>>>>>>>>>    If (bFolderCreated=false) Begin
75083>>>>>>>>>        Move 1 to iRetVal
75084>>>>>>>>>    End
75084>>>>>>>>>>
75084>>>>>>>>>    Function_Return iRetVal
75085>>>>>>>>>End_Function
75086>>>>>>>>>
75086>>>>>>>>>// **WvA: 03-02-2002 Function created.
75086>>>>>>>>>// With this function one can remove a directory.
75086>>>>>>>>>// returns 0 if the folder is removed.
75086>>>>>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
75086>>>>>>>>>//         2 if the folder did not exist
75086>>>>>>>>>//         3 if the sFolder parameter passed is equal to ""
75086>>>>>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
75088>>>>>>>>>    Boolean bRemoved
75088>>>>>>>>>    WString sPath
75088>>>>>>>>>    Integer iRetval
75088>>>>>>>>>
75088>>>>>>>>>    Move 0     to iRetVal
75089>>>>>>>>>    Move False to bRemoved
75090>>>>>>>>>    Move (Trim(sFolder)) to sFolder
75091>>>>>>>>>    If (sFolder="") Begin
75093>>>>>>>>>        Move 3 to iRetVal
75094>>>>>>>>>    End
75094>>>>>>>>>>
75094>>>>>>>>>    If (vFolderExists(sFolder)=False) Begin
75096>>>>>>>>>        Move 2 to iRetVal
75097>>>>>>>>>    End
75097>>>>>>>>>>
75097>>>>>>>>>    If (iRetVal=0) Begin
75099>>>>>>>>>        // null MAX_PATH chars into var (make space)
75099>>>>>>>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
75100>>>>>>>>>        //
75100>>>>>>>>>        Move (Insert(sFolder,sPath,1)) to sPath
75101>>>>>>>>>        Move (vWin32_RemoveDirectory(sPath)) to bRemoved
75102>>>>>>>>>    End
75102>>>>>>>>>>
75102>>>>>>>>>
75102>>>>>>>>>    If (iRetVal=0 And bRemoved=False) Begin
75104>>>>>>>>>        Move 1 to iRetVal
75105>>>>>>>>>    End
75105>>>>>>>>>>
75105>>>>>>>>>    Function_Return iRetVal
75106>>>>>>>>>End_Function
75107>>>>>>>>>
75107>>>>>>>>>// This will perform an operation on a file (e.g. open) with the application
75107>>>>>>>>>// registered in the Windows Registry to open that type of file (via its extension)
75107>>>>>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
75107>>>>>>>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
75109>>>>>>>>>    Handle  hInstance hWnd
75109>>>>>>>>>    // remove any leading/trailing spaces in the string
75109>>>>>>>>>    Move (Trim(sDocument)) to sDocument
75110>>>>>>>>>    Move (Trim(sPath))     to sPath
75111>>>>>>>>>    // Make the strings readable for windows API, by converting them to null-terminated
75111>>>>>>>>>    Append sOperation   (Character(0))
75112>>>>>>>>>    Append sDocument    (Character(0))
75113>>>>>>>>>    Append sParameters  (Character(0))
75114>>>>>>>>>    Append sPath        (Character(0))
75115>>>>>>>>>
75115>>>>>>>>>    Get Window_Handle to hWnd
75116>>>>>>>>>    Move (vWin32_ShellExecute (hWnd, sOperation, sDocument, sParameters, sPath, 1)) to hInstance
75117>>>>>>>>>    If (hInstance <= 32) Begin
75119>>>>>>>>>        Send vDDE_Error_Handler hInstance
75120>>>>>>>>>    End
75120>>>>>>>>>>
75120>>>>>>>>>End_Procedure
75121>>>>>>>>>
75121>>>>>>>>>Class cShellFileOperations is a Array
75122>>>>>>>>>
75122>>>>>>>>>    Procedure Construct_Object
75124>>>>>>>>>        Forward Send Construct_Object
75126>>>>>>>>>        Property Integer piDeleteFlags        0
75127>>>>>>>>>        Property Integer piCopyFlags          0
75128>>>>>>>>>        Property Integer piMoveFlags          0
75129>>>>>>>>>        Property Integer piRenameFlags        0
75130>>>>>>>>>
75130>>>>>>>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
75131>>>>>>>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
75132>>>>>>>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
75133>>>>>>>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
75134>>>>>>>>>    End_Procedure
75135>>>>>>>>>
75135>>>>>>>>>    // This function uses the shell API to perform a file operation on the
75135>>>>>>>>>    // files supplied.
75135>>>>>>>>>    //
75135>>>>>>>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
75137>>>>>>>>>        Integer  iRetVal
75137>>>>>>>>>        Integer  iUserAbort
75137>>>>>>>>>        WString  wsSource wsDestination
75137>>>>>>>>>        tvShFileOpStruct FOS
75137>>>>>>>>>        tvShFileOpStruct FOS
75137>>>>>>>>>
75137>>>>>>>>>        Move (sSource+Character(0)+Character(0))      to wsSource
75138>>>>>>>>>        Move (sDestination+Character(0)+Character(0)) to wsDestination
75139>>>>>>>>>
75139>>>>>>>>>        If (eOperation <> vFO_DELETE) Begin
75141>>>>>>>>>            Move (AddressOf(wsDestination)) to FOS.pTo
75142>>>>>>>>>        End
75142>>>>>>>>>>
75142>>>>>>>>>
75142>>>>>>>>>        Move eOperation            to FOS.wFunc
75143>>>>>>>>>        Move (AddressOf(wsSource)) to FOS.pFrom
75144>>>>>>>>>        Move iFlags                to FOS.fFlags
75145>>>>>>>>>
75145>>>>>>>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
75146>>>>>>>>>        Move FOS.fAnyOperationsAborted to iUserAbort
75147>>>>>>>>>        If (iUserAbort <> 0) Begin
75149>>>>>>>>>            Move 80 to iRetVal  // file Operation Aborted by USER
75150>>>>>>>>>        End
75150>>>>>>>>>>
75150>>>>>>>>>        Function_Return (iRetVal)
75151>>>>>>>>>    End_Function
75152>>>>>>>>>
75152>>>>>>>>>    Function sfoDeleteFile String sFileName Returns Integer
75154>>>>>>>>>        Integer  iRetVal
75154>>>>>>>>>        Integer  iFlags
75154>>>>>>>>>
75154>>>>>>>>>        Get piDeleteFlags to iFlags
75155>>>>>>>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
75156>>>>>>>>>        Function_Return iRetVal
75157>>>>>>>>>    End_Function
75158>>>>>>>>>
75158>>>>>>>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
75160>>>>>>>>>        Integer  iRetVal
75160>>>>>>>>>        Integer  iFlags
75160>>>>>>>>>
75160>>>>>>>>>        Get piCopyFlags to iFlags
75161>>>>>>>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
75162>>>>>>>>>        Function_Return iRetVal
75163>>>>>>>>>    End_Function
75164>>>>>>>>>
75164>>>>>>>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
75166>>>>>>>>>        Integer  iRetVal
75166>>>>>>>>>        Integer  iFlags
75166>>>>>>>>>
75166>>>>>>>>>        Get piMoveFlags to iFlags
75167>>>>>>>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
75168>>>>>>>>>        Function_Return iRetVal
75169>>>>>>>>>    End_Function
75170>>>>>>>>>
75170>>>>>>>>>    // Rename a file or folder
75170>>>>>>>>>    // Returns a nonzero value if the operation failed.
75170>>>>>>>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
75172>>>>>>>>>        Integer  iRetVal
75172>>>>>>>>>        Integer  iFlags
75172>>>>>>>>>
75172>>>>>>>>>        Get piRenameFlags to iFlags
75173>>>>>>>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
75174>>>>>>>>>        Function_Return iRetVal
75175>>>>>>>>>    End_Function
75176>>>>>>>>>
75176>>>>>>>>>
75176>>>>>>>>>    //Example:
75176>>>>>>>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
75176>>>>>>>>>    //                                          mode.
75176>>>>>>>>>
75176>>>>>>>>>End_Class
75177>>>>>>>>>
75177>>>>>>>>>Object oShellFileOperations is a cShellFileOperations
75179>>>>>>>>>End_Object
75180>>>>>>>>>
75180>>>>>>>>>// Restore to the old way of working with the shell file operations.
75180>>>>>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
75180>>>>>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
75180>>>>>>>>>Procedure vWin32fhCompatibilityMode
75182>>>>>>>>>    Integer hoSFO
75182>>>>>>>>>    Integer iFlags
75182>>>>>>>>>
75182>>>>>>>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
75183>>>>>>>>>    Move (oShellFileOperations(Self)) to hoSFO
75184>>>>>>>>>
75184>>>>>>>>>    Set piDeleteFlags of hoSFO to iFlags
75185>>>>>>>>>    Set piCopyFlags   of hoSFO to iFlags
75186>>>>>>>>>    Set piMoveFlags   of hoSFO to iFlags
75187>>>>>>>>>    Set piRenameFlags of hoSFO to iFlags
75188>>>>>>>>>End_Procedure
75189>>>>>>>>>
75189>>>>>>>>>// Delete a file or folder
75189>>>>>>>>>// Returns a nonzero value if the operation failed.
75189>>>>>>>>>Function vDeleteFile Global String sFileName Returns Integer
75191>>>>>>>>>    Integer  iRetVal
75191>>>>>>>>>
75191>>>>>>>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
75192>>>>>>>>>    Function_Return iRetVal
75193>>>>>>>>>End_Function
75194>>>>>>>>>
75194>>>>>>>>>// Copy a file or folder
75194>>>>>>>>>// Returns a nonzero value if the operation failed.
75194>>>>>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
75196>>>>>>>>>    Integer  iRetVal
75196>>>>>>>>>
75196>>>>>>>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75197>>>>>>>>>    Function_Return iRetVal
75198>>>>>>>>>End_Function
75199>>>>>>>>>
75199>>>>>>>>>// Move a file or folder
75199>>>>>>>>>// Returns a nonzero value if the operation failed.
75199>>>>>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
75201>>>>>>>>>    Integer  iRetVal
75201>>>>>>>>>
75201>>>>>>>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75202>>>>>>>>>    Function_Return iRetVal
75203>>>>>>>>>End_Function
75204>>>>>>>>>
75204>>>>>>>>>// Rename a file or folder
75204>>>>>>>>>// Returns a nonzero value if the operation failed.
75204>>>>>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
75206>>>>>>>>>    Integer  iRetVal
75206>>>>>>>>>
75206>>>>>>>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75207>>>>>>>>>    Function_Return iRetVal
75208>>>>>>>>>End_Function
75209>>>>>>>>>
75209>>>>>>>>>Function vGetWindowsDirectory Returns String
75211>>>>>>>>>    WString wDirectory
75211>>>>>>>>>    Integer iRetVal
75211>>>>>>>>>
75211>>>>>>>>>    Move (ZeroString(vMAX_PATH)) to wDirectory
75212>>>>>>>>>    Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), vMAX_PATH)) to iRetVal
75213>>>>>>>>>    If (iRetVal > vMAX_PATH) Begin
75215>>>>>>>>>        Move (ZeroString(iRetval)) to wDirectory
75216>>>>>>>>>        Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), iRetVal)) to iRetVal
75217>>>>>>>>>    End
75217>>>>>>>>>>
75217>>>>>>>>>    Function_Return (CString(wDirectory))
75218>>>>>>>>>End_Function
75219>>>>>>>>>
75219>>>>>>>>>Function vGetTempPath Returns String
75221>>>>>>>>>    Integer iRetVal
75221>>>>>>>>>    WString wTempPath
75221>>>>>>>>>
75221>>>>>>>>>    Move (ZeroString(vMAX_PATH)) to wTempPath
75222>>>>>>>>>    Move (vWin32_GetTempPath(vMAX_PATH, AddressOf(wTempPath))) to iRetVal
75223>>>>>>>>>    If (iRetVal > vMAX_PATH) Begin
75225>>>>>>>>>        Move (ZeroString(iRetval)) to wTempPath
75226>>>>>>>>>        Move (vWin32_GetTempPath(iRetVal, AddressOf(wTempPath))) to iRetVal
75227>>>>>>>>>    End
75227>>>>>>>>>>
75227>>>>>>>>>    Function_Return (CString(wTempPath))
75228>>>>>>>>>End_Function
75229>>>>>>>>>
75229>>>>>>>>>// Courtesy of Marco Kuipers
75229>>>>>>>>>Function vMakeTempFile Returns String
75231>>>>>>>>>    Integer iRetval
75231>>>>>>>>>    String  sTempPath
75231>>>>>>>>>    String  sTempFileName
75231>>>>>>>>>    String  sPrefixString
75231>>>>>>>>>    WString wsTempFileName
75231>>>>>>>>>
75231>>>>>>>>>    Get vGetTempPath to sTempPath
75232>>>>>>>>>    If (sTempPath = "") Begin
75234>>>>>>>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
75235>>>>>>>>>        If (sTempPath<>"") Begin
75237>>>>>>>>>            Move (sTempPath+"\Temp\") to sTempPath
75238>>>>>>>>>        End
75238>>>>>>>>>>
75238>>>>>>>>>    End
75238>>>>>>>>>>
75238>>>>>>>>>
75238>>>>>>>>>    If (sTempPath = "") Begin
75240>>>>>>>>>        // second fallback we really do not want to get here as to be fair using current folder as temp
75240>>>>>>>>>        // makes little sense. Leaving this in as it was old behavior.
75240>>>>>>>>>        Get_Current_Directory to sTempPath
75241>>>>>>>>>    End
75241>>>>>>>>>>
75241>>>>>>>>>
75241>>>>>>>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
75242>>>>>>>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
75244>>>>>>>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
75245>>>>>>>>>>
75245>>>>>>>>>    End
75245>>>>>>>>>>
75245>>>>>>>>>
75245>>>>>>>>>    Move (ZeroString(vMax_Path)) to wsTempFileName
75246>>>>>>>>>    Move ("tmp"+Character(0))    to sPrefixString
75247>>>>>>>>>    Move (vWin32_GetTempFileName (sTempPath, sPrefixString, 0, AddressOf(wsTempFileName))) to iRetval
75248>>>>>>>>>    If (iRetval = 0) Begin  // The api call returns 0 if an error occurs
75250>>>>>>>>>    //Get ShowLastError to iRetval
75250>>>>>>>>>        Move "" to sTempFileName
75251>>>>>>>>>    End
75251>>>>>>>>>>
75251>>>>>>>>>    Move (Cstring(wsTempFileName)) to sTempFileName
75252>>>>>>>>>    Function_Return sTempFileName
75253>>>>>>>>>End_Function
75254>>>>>>>>>
75254>>>>>>>>>// This function creates a uniquely named temporary file in folder sPath
75254>>>>>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
75254>>>>>>>>>// Note that you will have to cleanup the tempfile yourself as the function
75254>>>>>>>>>// does not take care of that.
75254>>>>>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
75256>>>>>>>>>    Integer iRetVal
75256>>>>>>>>>    String  sTempFileName
75256>>>>>>>>>    WString wTempFileName
75256>>>>>>>>>
75256>>>>>>>>>    Move (sPath+Character(0))   to sPath
75257>>>>>>>>>    Move (sPrefix+Character(0)) to sPrefix
75258>>>>>>>>>    Move (Pad("", vMAX_PATH))   to wTempFileName
75259>>>>>>>>>
75259>>>>>>>>>    Move (vWin32_GetTempFileName(sPath, sPrefix, 0, AddressOf(wTempFileName))) to iRetVal
75260>>>>>>>>>    Move (Trim(Cstring(wTempFileName))) to sTempFileName
75261>>>>>>>>>    Function_Return sTempFileName
75262>>>>>>>>>End_Function
75263>>>>>>>>>
75263>>>>>>>>>//
75263>>>>>>>>>// Get a specific shell folder for example to get the desktop folder
75263>>>>>>>>>// simply call this function and pass it vCSIDL_DESKTOP
75263>>>>>>>>>//
75263>>>>>>>>>Function vSHGetFolderPath Integer eFolder Returns String
75265>>>>>>>>>    Integer iVoid
75265>>>>>>>>>    Handle  hWnd
75265>>>>>>>>>    String  sFolder
75265>>>>>>>>>    WString wFolder
75265>>>>>>>>>
75265>>>>>>>>>    Move (Window_Handle(focus(desktop))) to hWnd
75266>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to wFolder
75267>>>>>>>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(wFolder))) To iVoid
75268>>>>>>>>>    Move (CString(wFolder)) to sFolder
75269>>>>>>>>>    Function_Return sFolder
75270>>>>>>>>>End_Function
75271>>>>>>>>>
75271>>>>>>>>>// Courtesy Of Vincent Oorsprong
75271>>>>>>>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
75273>>>>>>>>>    String  sFileDateTime
75273>>>>>>>>>    WString wFormattedTime wFormattedDate
75273>>>>>>>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
75273>>>>>>>>>    tvFileTime   FileTime
75273>>>>>>>>>    tvFileTime   FileTime
75273>>>>>>>>>    tvSystemTime SystemTime
75273>>>>>>>>>    tvSystemTime SystemTime
75273>>>>>>>>>
75273>>>>>>>>>    Move "" to sFileDateTime
75274>>>>>>>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
75275>>>>>>>>>    Move dwHighDateTime to FileTime.dwHighDateTime
75276>>>>>>>>>
75276>>>>>>>>>    Move 0 to SystemTime.wYear
75277>>>>>>>>>
75277>>>>>>>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
75278>>>>>>>>>    If (iSuccess = 1) Begin
75280>>>>>>>>>        Move (ZeroString(255))               to wFormattedTime
75281>>>>>>>>>        Move (SizeOfWString(wFormattedTime)) to iLenCcTime
75282>>>>>>>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedTime), iLenCcTime)) to iDataLength
75283>>>>>>>>>        Move (ZeroString(255))               to wFormattedDate
75284>>>>>>>>>        Move (SizeOfWString(wFormattedDate)) to iLenCcDate
75285>>>>>>>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedDate), iLenCcDate)) to iDataLength
75286>>>>>>>>>        Move (Cstring (wFormattedDate)  * Cstring (wFormattedTime)) to sFileDateTime
75287>>>>>>>>>    End
75287>>>>>>>>>>
75287>>>>>>>>>    Function_Return sFileDateTime
75288>>>>>>>>>End_Function
75289>>>>>>>>>
75289>>>>>>>>>// **WvA:
75289>>>>>>>>>// A windows replacement for the standard function FileExists.
75289>>>>>>>>>// This version will also return (true) for a file when it is open by an application.
75289>>>>>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
75289>>>>>>>>>// Example: Get vFilePathExists "C:\config.sy?"
75289>>>>>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
75289>>>>>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
75291>>>>>>>>>    String  sDirSep
75291>>>>>>>>>    Handle  hFindFile
75291>>>>>>>>>    Integer iVoid
75291>>>>>>>>>    tvWin32FindData FindData
75291>>>>>>>>>    tvWin32FindData FindData
75291>>>>>>>>>
75291>>>>>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
75292>>>>>>>>>    Move (Trim(sFilePathMask)) to sFilePathMask
75293>>>>>>>>>
75293>>>>>>>>>    If (Length(sFilePathMask)>0) Begin
75295>>>>>>>>>        // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
75295>>>>>>>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75296>>>>>>>>>        While (Right(sFilePathMask, 1) = sDirSep)
75300>>>>>>>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
75301>>>>>>>>>        Loop
75302>>>>>>>>>>
75302>>>>>>>>>
75302>>>>>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75303>>>>>>>>>        Move (vWin32_FindFirstFile (sFilePathMask, AddressOf(FindData))) to hFindFile
75304>>>>>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
75305>>>>>>>>>    End
75305>>>>>>>>>>
75305>>>>>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
75306>>>>>>>>>End_Function
75307>>>>>>>>>
75307>>>>>>>>>
75307>>>>>>>>>//
75307>>>>>>>>>// Returns the amount of files in the folder (if it exists)
75307>>>>>>>>>// Returns -1 if folder doesn't exist.
75307>>>>>>>>>// The files "." and ".." are not counted.
75307>>>>>>>>>//
75307>>>>>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
75309>>>>>>>>>    Boolean bFound
75309>>>>>>>>>    Handle  hFindFile
75309>>>>>>>>>    Integer iCount  iVoid
75309>>>>>>>>>    Integer iSuccess
75309>>>>>>>>>    String  sFileName
75309>>>>>>>>>    tvWin32FindData FindData
75309>>>>>>>>>    tvWin32FindData FindData
75309>>>>>>>>>
75309>>>>>>>>>    Move -1 to iCount
75310>>>>>>>>>    Get vFolderFormat sFolderName to sFolderName
75311>>>>>>>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
75312>>>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75313>>>>>>>>>    Move (vWin32_FindFirstFile (sFolderName, AddressOf(FindData))) to hFindFile
75314>>>>>>>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
75315>>>>>>>>>    If (bFound) Begin
75317>>>>>>>>>        Move 0 to iCount
75318>>>>>>>>>    End
75318>>>>>>>>>>
75318>>>>>>>>>    While (bFound)
75322>>>>>>>>>        Increment iCount
75323>>>>>>>>>        Move (PointerToWString(AddressOf(FindData.cFileName))) to sFileName
75324>>>>>>>>>        If (sFileName="." or sFileName="..") Begin
75326>>>>>>>>>            Decrement iCount
75327>>>>>>>>>        End
75327>>>>>>>>>>
75327>>>>>>>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
75328>>>>>>>>>        Move (iSuccess<>0) to bFound
75329>>>>>>>>>    Loop
75330>>>>>>>>>>
75330>>>>>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
75331>>>>>>>>>    Function_Return iCount
75332>>>>>>>>>End_Function
75333>>>>>>>>>
75333>>>>>>>>>// Create the folder, including intermediate directories.
75333>>>>>>>>>// Don't panic if the folder already exists.
75333>>>>>>>>>// Michael Mullan June 2009.
75333>>>>>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
75335>>>>>>>>>    String  sFolder
75335>>>>>>>>>    Integer iRetval iFolderCreated
75335>>>>>>>>>    tvSecurity_attributes SA
75335>>>>>>>>>    tvSecurity_attributes SA
75335>>>>>>>>>
75335>>>>>>>>>    Move 0 to iFolderCreated
75336>>>>>>>>>
75336>>>>>>>>>    // null MAX_PATH chars into var (make space)
75336>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
75337>>>>>>>>>    If (sNewFolder <> "") Begin
75339>>>>>>>>>
75339>>>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
75340>>>>>>>>>        Move  0  to SA.lpDescriptor
75341>>>>>>>>>        Move  1  to SA.bInheritHandle
75342>>>>>>>>>
75342>>>>>>>>>        //
75342>>>>>>>>>        Move (sNewFolder+"") to sFolder
75343>>>>>>>>>        Move (vWin32_SHCreateDirectoryEx(0,sFolder, AddressOf(SA))) to iFolderCreated
75344>>>>>>>>>    End
75344>>>>>>>>>>
75344>>>>>>>>>
75344>>>>>>>>>    If (iFolderCreated <> 0) Begin
75346>>>>>>>>>        Move 1 to iRetVal
75347>>>>>>>>>        Case Begin
75347>>>>>>>>>            Case (iFolderCreated = 161)
75349>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
75350>>>>>>>>>>
75350>>>>>>>>>                Case Break
75351>>>>>>>>>            Case (iFolderCreated = 206)
75354>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
75355>>>>>>>>>>
75355>>>>>>>>>                Case Break
75356>>>>>>>>>            Case (iFolderCreated = 3)
75359>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
75360>>>>>>>>>>
75360>>>>>>>>>                Case Break
75361>>>>>>>>>            Case (iFolderCreated = 80)
75364>>>>>>>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
75365>>>>>>>>>                Case Break
75366>>>>>>>>>            Case (iFolderCreated = 183)
75369>>>>>>>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
75370>>>>>>>>>                Case Break
75371>>>>>>>>>            Case (iFolderCreated = 1223)
75374>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
75375>>>>>>>>>>
75375>>>>>>>>>                Case Break
75376>>>>>>>>>            Case Else
75376>>>>>>>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
75377>>>>>>>>>>
75377>>>>>>>>>        Case End
75377>>>>>>>>>    End
75377>>>>>>>>>>
75377>>>>>>>>>    Function_Return iRetVal
75378>>>>>>>>>End_Function
75379>>>>>>>>>
75379>>>>>>>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
75381>>>>>>>>>    DWord   dwFileSizeHigh dwFileSizeLow
75381>>>>>>>>>    Integer iFileSize iVoid
75381>>>>>>>>>    Handle  hFindFile
75381>>>>>>>>>    tvWin32FindData FindData
75381>>>>>>>>>    tvWin32FindData FindData
75381>>>>>>>>>
75381>>>>>>>>>    Move (sFileName+"") to sFileName
75382>>>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75383>>>>>>>>>    Move (vWin32_FindFirstFile (sFileName, AddressOf(FindData))) to hFindFile
75384>>>>>>>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
75386>>>>>>>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
75387>>>>>>>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
75388>>>>>>>>>    End
75388>>>>>>>>>>
75388>>>>>>>>>    Move (vWin32_FindClose(hFindFile)) to iVoid
75389>>>>>>>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
75390>>>>>>>>>
75390>>>>>>>>>    Function_Return iFileSize
75391>>>>>>>>>End_Function
75392>>>>>>>>>
75392>>>>>>>>>//
75392>>>>>>>>>// Based on code in Peter Crook's Browse folder workspace
75392>>>>>>>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
75392>>>>>>>>>//
75392>>>>>>>>>//=============================================================================
75392>>>>>>>>>// Verifies that a path is a valid directory.
75392>>>>>>>>>//
75392>>>>>>>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
75392>>>>>>>>>//
75392>>>>>>>>>// Parameters:
75392>>>>>>>>>//      sPath - Address of the path to verify.
75392>>>>>>>>>//=============================================================================
75392>>>>>>>>>Function vPathIsDirectory Global String sPath Returns Boolean
75394>>>>>>>>>    Integer iResult
75394>>>>>>>>>    Boolean bRetVal
75394>>>>>>>>>
75394>>>>>>>>>    Move false to bRetVal
75395>>>>>>>>>    Move (sPath - Character (0)) to sPath
75396>>>>>>>>>    Move (vWin32_PathIsDirectory (sPath)) to iResult
75397>>>>>>>>>    If (iResult<>0) Begin
75399>>>>>>>>>        Move True to bRetVal
75400>>>>>>>>>    End
75400>>>>>>>>>>
75400>>>>>>>>>
75400>>>>>>>>>    Function_Return bRetVal
75401>>>>>>>>>End_Function
75402>>>>>>>>>
75402>>>>>>>
75402>>>>>>>//
75402>>>>>>>// Gets the string from the right of the last sStopChar in sFrom
75402>>>>>>>// If sStopChar has no occurences in the string an empty string is
75402>>>>>>>// returned.
75402>>>>>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
75404>>>>>>>    String  sRetVal
75404>>>>>>>    String  sChar
75404>>>>>>>    Integer iLength
75404>>>>>>>    Integer iPos
75404>>>>>>>    Boolean bStopChar
75404>>>>>>>    Move "" to sRetval
75405>>>>>>>    Move (Length(sFrom)) to iLength
75406>>>>>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
75408>>>>>>>        Move iLength   to iPos
75409>>>>>>>        Move (False)   to bStopChar
75410>>>>>>>        While Not bStopChar
75414>>>>>>>            Move (Mid(sFrom,1,iPos)) to sChar
75415>>>>>>>            Decrement iPos
75416>>>>>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
75418>>>>>>>                Move (True) to bStopChar
75419>>>>>>>            End
75419>>>>>>>>
75419>>>>>>>            Else Begin
75420>>>>>>>                Move (sChar+sRetVal) to sRetVal
75421>>>>>>>            End
75421>>>>>>>>
75421>>>>>>>        Loop
75422>>>>>>>>
75422>>>>>>>    End
75422>>>>>>>>
75422>>>>>>>    Function_Return sRetVal
75423>>>>>>>End_Function
75424>>>>>>>
75424>>>>>>>// Pre:  sFileName contains the complete path of the file.
75424>>>>>>>// Post: returns the complete path of the file.
75424>>>>>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
75424>>>>>>>Function ParseFolderName Global String sFileName Returns String
75426>>>>>>>    String sFile
75426>>>>>>>    String sFolderName
75426>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
75426>>>>>>>
75426>>>>>>>    Move "" to sFolderName
75427>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75428>>>>>>>    If sDirSep In sFileName Begin
75430>>>>>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
75431>>>>>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
75432>>>>>>>    End
75432>>>>>>>>
75432>>>>>>>    Else If ":" In sFileName Begin
75435>>>>>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
75436>>>>>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
75437>>>>>>>    End
75437>>>>>>>>
75437>>>>>>>    Function_Return sFolderName
75438>>>>>>>End_Function
75439>>>>>>>
75439>>>>>>>// Pre:  sFileName contains the complete path of the file.
75439>>>>>>>// post: The returned filename has it's path removed, but will have a extension
75439>>>>>>>Function ParseFileName Global String sFileName Returns String
75441>>>>>>>    String sFolderName
75441>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
75441>>>>>>>
75441>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75442>>>>>>>    Get ParseFolderName sFileName to sFolderName
75443>>>>>>>    If (sFolderName <> "") Begin
75445>>>>>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
75446>>>>>>>    End
75446>>>>>>>>
75446>>>>>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
75447>>>>>>>    Function_Return sFilename
75448>>>>>>>End_Function
75449>>>>>>>
75449>>>>>>>// Pre:  sFileName may contain the complete path of the file.
75449>>>>>>>//       or contain multiple dots in the filename, so temp.gif.bak will
75449>>>>>>>//       return "bak" as the extension and not "gif"
75449>>>>>>>// Post: returns the extension only, this extension can be a valid unixlike extension
75449>>>>>>>//       such as "html" or "java"
75449>>>>>>>Function ParseFileExtension Global String sFileName Returns String
75451>>>>>>>    String  sFileExtension
75451>>>>>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
75452>>>>>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
75453>>>>>>>    Function_Return sFileExtension
75454>>>>>>>End_Function
75455>>>>>>>
75455>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
75455>>>>>>>
75455>>>>>>>Function DDE_Error_To_String Integer iErrorID Returns String
75457>>>>>>>    String sMessage
75457>>>>>>>    Case Begin
75457>>>>>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
75459>>>>>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
75460>>>>>>>            Case Break
75461>>>>>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
75464>>>>>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
75465>>>>>>>            Case Break
75466>>>>>>>        Case (iErrorID = vERROR_BAD_FORMAT)
75469>>>>>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
75470>>>>>>>            Case Break
75471>>>>>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
75474>>>>>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
75475>>>>>>>            Case Break
75476>>>>>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
75479>>>>>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
75480>>>>>>>            Case Break
75481>>>>>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
75484>>>>>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
75485>>>>>>>            Case Break
75486>>>>>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
75489>>>>>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
75490>>>>>>>            Case Break
75491>>>>>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
75494>>>>>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
75495>>>>>>>            Case Break
75496>>>>>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
75499>>>>>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
75500>>>>>>>            Case Break
75501>>>>>>>        Case (iErrorID = vSE_ERR_NOASSOC)
75504>>>>>>>            Move CS_DDE_ERR_NOASSOC to sMessage
75505>>>>>>>            Case Break
75506>>>>>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
75509>>>>>>>            Move CS_DDE_ERR_OOM to sMessage
75510>>>>>>>            Case Break
75511>>>>>>>        Case (iErrorID = vSE_ERR_PNF)
75514>>>>>>>            Move CS_DDE_ERR_PNF to sMessage
75515>>>>>>>            Case Break
75516>>>>>>>        Case (iErrorID = vSE_ERR_SHARE)
75519>>>>>>>            Move CS_DDE_ERR_SHARE to sMessage
75520>>>>>>>            Case Break
75521>>>>>>>        Case Else
75521>>>>>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
75522>>>>>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
75523>>>>>>>            Case Break
75524>>>>>>>    Case End
75524>>>>>>>    Function_Return sMessage
75525>>>>>>>End_Function
75526>>>>>>>
75526>>>>>>>Procedure vDDE_Error_Handler Integer iErrorID
75528>>>>>>>    String sMessage
75528>>>>>>>    Get DDE_Error_To_String iErrorID to sMessage
75529>>>>>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
75530>>>>>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
75531>>>>>>>End_Procedure
75532>>>>>>>
75532>>>>>>>
75532>>>>>>>// This function informs the user that he entered a yet unknown folder and
75532>>>>>>>// asks if he/she wants to create the folder (Yes/No)
75532>>>>>>>// Choice: "Yes" - this creates the folder
75532>>>>>>>//                 if successful, the function returns false
75532>>>>>>>//                 else it will be true.
75532>>>>>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
75532>>>>>>>//                 For example: to stop a save
75532>>>>>>>// Precondition: A foldername must be entered. We do not check for empty paths
75532>>>>>>>// This function returns a non-zero value if the folder isn't created afterwards
75532>>>>>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
75534>>>>>>>    Integer bIsNotValid
75534>>>>>>>    Integer iUsers_Choice
75534>>>>>>>    String  sMessage
75534>>>>>>>
75534>>>>>>>    If (vFolderExists(sFolderName) Eq 0) Begin
75536>>>>>>>        Move "The folder '" to sMessage
75537>>>>>>>        Append sMessage sFolderName
75538>>>>>>>        Append sMessage "' does not yet exist,\n"
75539>>>>>>>        Append sMessage "Do you want to create it now?"
75540>>>>>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
75541>>>>>>>        Case Begin
75541>>>>>>>            Case (iUsers_Choice = MBR_Yes)
75543>>>>>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
75544>>>>>>>                If bIsNotValid Begin
75546>>>>>>>                    Move "An error occurred while trying to create folder '" to sMessage
75547>>>>>>>                    Append sMessage sFolderName "'.\n\n"
75549>>>>>>>                    Send Info_Box sMessage "Info"
75550>>>>>>>                End
75550>>>>>>>>
75550>>>>>>>                Case Break
75551>>>>>>>            Case (iUsers_Choice = MBR_No)
75554>>>>>>>                Move dfTrue to bIsNotValid // Cancel the save
75555>>>>>>>                Case Break
75556>>>>>>>        Case End
75556>>>>>>>    End
75556>>>>>>>>
75556>>>>>>>    Function_Return bIsNotValid
75557>>>>>>>End_Function
75558>>>>>>>
75558>>>>>>>// **WvA
75558>>>>>>>// Formats a foldername by first trimming it and after that by sticking a
75558>>>>>>>// directory separator (/\) to the end if it doesn't have one there already.
75558>>>>>>>// The folder may contain a drive letter or UNC encoding.
75558>>>>>>>Function vFolderFormat Global String sFolderName Returns String
75560>>>>>>>    String sDirSep
75560>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
75561>>>>>>>    Move (Trim(sFolderName)) to sFolderName
75562>>>>>>>    If (Right(sFolderName,1)<>sDirSep) Begin
75564>>>>>>>        Move (sFolderName+sDirSep) to sFolderName
75565>>>>>>>    End
75565>>>>>>>>
75565>>>>>>>    Function_Return sFolderName
75566>>>>>>>End_Function
75567>>>>>>>
75567>>>>>>>//
75567>>>>>>>// Gets the parent path of the currently supplied path
75567>>>>>>>// Returns "" when we are at the root folder.
75567>>>>>>>//
75567>>>>>>>Function vParentPath Global String sPath Returns String
75569>>>>>>>    String sStrip sDirSep
75569>>>>>>>
75569>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75570>>>>>>>    Move (Trim(sPath)) to sPath
75571>>>>>>>    If (Right(sPath,1) = sDirSep) Begin
75573>>>>>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
75574>>>>>>>    End
75574>>>>>>>>
75574>>>>>>>    If (Pos(sDirSep, sPath)) Begin
75576>>>>>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
75577>>>>>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
75578>>>>>>>    End
75578>>>>>>>>
75578>>>>>>>    Else Begin
75579>>>>>>>        Move "" to sPath
75580>>>>>>>    End
75580>>>>>>>>
75580>>>>>>>    Function_Return sPath
75581>>>>>>>End_Function
75582>>>>>Use DUFLanguageConstants.inc
75582>>>>>
75582>>>>>Define CS_IntFilesTableLogicalName for "IntFilesTable"
75582>>>>>// Do *not* change this name as it is used by the CheckIntFilesIntegrity
75582>>>>>// procedure and the explicit file name is used with the Include_Resource command.
75582>>>>>Define CS_FilelistBackupFile    for "FilelistBackupFile.cfg"
75582>>>>>
75582>>>>>Struct tDUFIntFile
75582>>>>>    Integer iID
75582>>>>>    String sIntFileName
75582>>>>>    String sIntLineText
75582>>>>>End_Struct
75582>>>>>
75582>>>>>Struct tDbVersionInfo
75582>>>>>    Number nVersionNumber
75582>>>>>    Handle hObject
75582>>>>>End_Struct
75582>>>>>
75582>>>>>Struct tDbUpdateError
75582>>>>>    Number nUpdateVersion
75582>>>>>    Integer iError
75582>>>>>    String  sOrgErrorText
75582>>>>>    String  sErrorText
75582>>>>>    Integer iErrorLine
75582>>>>>    Boolean bError  
75582>>>>>    Handle  hTable 
75582>>>>>    String  sTableRootName
75582>>>>>    Integer iField
75582>>>>>    Boolean bShortFormat
75582>>>>>End_Struct
75582>>>>>
75582>>>>>//  DF_FILE_ALIAS_DEFAULT if no master or alias
75582>>>>>//  DF_FILE_IS_MASTER if master
75582>>>>>//  DF_FILE_IS_ALIAS if alias
75582>>>>>Struct tDbUpdateHandlerMasterAlias
75582>>>>>    Handle hTable
75582>>>>>    Integer iMode
75582>>>>>End_Struct
75582>>>>>
75582>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
75582>>>>>Enumeration_List
75582>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
75582>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
75582>>>>>End_Enumeration_List
75582>>>>>
75582>>>>>    Define DATAFLEX_ID for "DATAFLEX"
75582>>>>>
75582>>>>>// Global handle to a cDatabaseUpdateHandler object that can be used to
75582>>>>>// communicate with the object from anywhere in a program.
75582>>>>>    Global_Variable Handle ghoDbUpdateHandler
75582>>>>>    Move 0 to ghoDbUpdateHandler
75583>>>>>
75583>>>>>// NOTE: If the DbVersion table should _not_ be used and you
75583>>>>>// instead set the "Set Data_File_Field to (RefTable(MyTable)) (RefTable(MyTable.DbUpdateVersion))"
75583>>>>>// in the cDbUpdateHandler object; Add a "Define DUF_Use_DbVersion" to your code,
75583>>>>>// _before_ the "Use cDbUpdateHandler.pkg" line.
75583>>>>>//#IFNDEF DUF_Use_Custom_DbVersion
75583>>>>>//    Declare_Datafile DbVersion
75583>>>>>//#ENDIF
75583>>>Use cDbUpdateLogFile.pkg
Including file: cDbUpdateLogFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateLogFile.pkg)
75583>>>>>//****************************************************************************
75583>>>>>// $Module type: Class
75583>>>>>// $Module name: cDbUpdateLogFile
75583>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75583>>>>>// Web-site    : http://www.rdctools.com
75583>>>>>// Created     : 2016-10-05 @ 18:58 (Military date format: YY-MM-DD)
75583>>>>>//
75583>>>>>// Description : This logic was moved from the cDbUpdateHandler class so that it would
75583>>>>>//               be easier to change to where errors/status messages are written/saved. As it is less likely
75583>>>>>//               that this class is to change; each developer can decide if the errors instead
75583>>>>>//               should be saved to a database table, or something entirely different.
75583>>>>>//               The default is to write the errors to a Ascii-file in the Data folder.
75583>>>>>//
75583>>>>>// $Rev History:
75583>>>>>//    2016-10-05  Module header created
75583>>>>>//****************************************************************************
75583>>>>>Use UI
75583>>>>>Use vWin32fh.pkg
75583>>>>>
75583>>>>>
75583>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
75583>>>>>
75583>>>>>Define CS_SuccessfulUpdate for "The database was updated successfully!"
75583>>>>>
75583>>>>>Class cDbUpdateLogFile is a cObject
75584>>>>>
75584>>>>>    Procedure Construct_Object
75586>>>>>        Forward Send Construct_Object
75588>>>>>
75588>>>>>        // Error handling:
75588>>>>>        Property tDbUpdateError[] paDbUpdateErrorArray
75589>>>>>        Property Integer piChannel -1
75590>>>>>
75590>>>>>        // This property is set by the cDbUpdateHandler object,
75590>>>>>        // when the update process starts.
75590>>>>>        Property DateTime pdtUpdateStart
75591>>>>>
75591>>>>>        // Gets set to False if the log contains data
75591>>>>>        Property Boolean pbEmptyLogFile True
75592>>>>>
75592>>>>>        // Gets set to True after the error log header text
75592>>>>>        // has been written.
75592>>>>>        Property Boolean pbHeaderWritten False
75593>>>>>
75593>>>>>        // If all activities should be logged- not just errors.
75593>>>>>        Property Boolean pbVerboseState False
75594>>>>>
75594>>>>>        // File name for the error log where all errors
75594>>>>>        // after a run is written to (appended).
75594>>>>>        // It is saved in the Data folder.
75594>>>>>        Property String psLogTextFile   "DUFUpdateLog.txt"
75595>>>>>        // If this property is set to "" in object code, the
75595>>>>>        // "shell" command parameter will be used to let Windows decide
75595>>>>>        // with which program to open the logfile.
75595>>>>>        Property String psEditorProgram ""
75596>>>>>
75596>>>>>        Property Boolean pbUseDataTableLog False
75597>>>>>
75597>>>>>        // If true an error will be written to file immediately when
75597>>>>>        // it occurs. This can be handy if a large update generates a lots
75597>>>>>        // of errors and the application crasches before finished, thus
75597>>>>>        // the errors will not be written.
75597>>>>>        Property Boolean pbQuickWrite True
75598>>>>>    End_Procedure
75599>>>>>
75599>>>>>    Procedure End_Construct_Object
75601>>>>>        Forward Send End_Construct_Object
75603>>>>>
75603>>>>>    End_Procedure
75604>>>>>
75604>>>>>    Procedure LogError Number nVersion Integer iError String sErrorText Integer iErrorLine Boolean bError Boolean bShortFormatIn
75606>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
75606>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
75608>>>>>        Boolean bShortFormat
75608>>>>>        Integer iSize
75608>>>>>        Handle hCurrentTable
75608>>>>>        Integer iCurrentField           
75608>>>>>        String sOrgErrorText sTableRootName
75608>>>>>        
75608>>>>>        Move False to bShortFormat
75609>>>>>        If (num_arguments > 5) Begin
75611>>>>>            Move bShortFormatIn to bShortFormat
75612>>>>>        End
75612>>>>>>
75612>>>>>        // Only do once.
75612>>>>>        If (pbHeaderWritten(Self) = False) Begin
75614>>>>>            Send WriteHeaderData
75615>>>>>            Set pbHeaderWritten to True
75616>>>>>        End
75616>>>>>>
75616>>>>>
75616>>>>>        Get Private.phCurrentTable to hCurrentTable  
75617>>>>>        Get Private.piCurrentField to iCurrentField  
75618>>>>>        If (iError > 0) Begin
75620>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hCurrentTable to sTableRootName
75623>>>>>            Get FetchErrorDescription iError to sOrgErrorText 
75624>>>>>        End
75624>>>>>>
75624>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
75625>>>>>        Move (SizeOfArray(DbUpdateErrorArray)) to iSize
75626>>>>>        Move nVersion       to DbUpdateErrorArray[iSize].nUpdateVersion
75627>>>>>        Move iError         to DbUpdateErrorArray[iSize].iError
75628>>>>>        Move iErrorLine     to DbUpdateErrorArray[iSize].iErrorLine
75629>>>>>        Move True           to DbUpdateErrorArray[iSize].bError  
75630>>>>>        Move sOrgErrorText  to DbUpdateErrorArray[iSize].sOrgErrorText
75631>>>>>        Move sErrorText     to DbUpdateErrorArray[iSize].sErrorText
75632>>>>>        Move hCurrentTable  to DbUpdateErrorArray[iSize].hTable            
75633>>>>>        Move sTableRootName to DbUpdateErrorArray[iSize].sTableRootName
75634>>>>>        Move iCurrentField  to DbUpdateErrorArray[iSize].iField  
75635>>>>>        Move bShortFormat   to DbUpdateErrorArray[iSize].bShortFormat
75636>>>>>
75636>>>>>        If (bError = False) Begin
75638>>>>>            Move False to DbUpdateErrorArray[iSize].bError
75639>>>>>        End
75639>>>>>>
75639>>>>>        Set paDbUpdateErrorArray to DbUpdateErrorArray
75640>>>>>
75640>>>>>        If (pbUseDataTableLog(Self) = True) Begin
75642>>>>>            If (pbQuickWrite(Self) = True) Begin
75644>>>>>                Send OnWriteRow_DataTable
75645>>>>>                // If we are writing error for error flush the
75645>>>>>                // error array when latest error has been written.
75645>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
75646>>>>>            End
75646>>>>>>
75646>>>>>            Procedure_Return
75647>>>>>        End
75647>>>>>>
75647>>>>>        Else Begin
75648>>>>>            If (pbQuickWrite(Self) = True) Begin
75650>>>>>                Send WriteErrorLog
75651>>>>>                // Flush the error log array
75651>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty 
75652>>>>>            End
75652>>>>>>
75652>>>>>        End
75652>>>>>>
75652>>>>>    End_Procedure   
75653>>>>>    
75653>>>>>    Function FetchErrorDescription Integer iError Returns String
75655>>>>>        String sErrorText         
75655>>>>>        Move "" to sErrorText
75656>>>>>        If (iError > 0) Begin
75658>>>>>            Move (Error_Text(Desktop, iError)) to sErrorText 
75659>>>>>        End
75659>>>>>>
75659>>>>>        Function_Return sErrorText
75660>>>>>    End_Function
75661>>>>>
75661>>>>>    // Hook procedure for writing header text prior starting the update work to
75661>>>>>    // a database table. This does nothing by default.
75661>>>>>    // Don't forget to Open your "error log table" first (!) as all
75661>>>>>    // tables have been closed at this stage. Put anything
75661>>>>>    // you want to indicate that the update process is just started.
75661>>>>>    Procedure OnWriteHeader_DataTable DateTime dtUpdateStart
75663>>>>>        Delegate Send OnErrorWriteHeader_DataTable dtUpdateStart
75665>>>>>    End_Procedure
75666>>>>>
75666>>>>>    Procedure OnWriteRow_DataTable
75668>>>>>        tDbUpdateError[] DbUpdateErrorArray
75668>>>>>        tDbUpdateError[] DbUpdateErrorArray
75669>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
75670>>>>>        If (SizeOfArray(DbUpdateErrorArray) > 0) Begin
75672>>>>>            Delegate Send OnErrorWriteRow_DataTable DbUpdateErrorArray
75674>>>>>        End
75674>>>>>>
75674>>>>>    End_Procedure
75675>>>>>
75675>>>>>    Function psLogTextFileWithPath Returns String
75677>>>>>        String sPath sFileName sFullFileName
75677>>>>>        
75677>>>>>        Get psDataPathFirstPart to sPath
75678>>>>>        Get psLogTextFile to sFileName
75679>>>>>        Move (sPath + sFileName) to sFullFileName
75680>>>>>        Function_Return sFullFileName
75681>>>>>    End_Function                     
75682>>>>>    
75682>>>>>    Procedure WriteHeaderData
75684>>>>>        String sFileName
75684>>>>>        Integer iCh iSize
75684>>>>>        Boolean bQuickWrite
75684>>>>>        DateTime dtUpdateStart
75684>>>>>
75684>>>>>        Move (CurrentDateTime()) to dtUpdateStart
75685>>>>>        If (pbUseDataTableLog(Self) = True) Begin
75687>>>>>            Send OnWriteHeader_DataTable dtUpdateStart
75688>>>>>            Procedure_Return
75689>>>>>        End
75689>>>>>>
75689>>>>>
75689>>>>>        Get piChannel to iCh
75690>>>>>        If (iCh < 0) Begin
75692>>>>>            Get Seq_New_Channel to iCh
75693>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75695>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
75696>>>>>>
75696>>>>>                Procedure_Return
75697>>>>>            End
75697>>>>>>
75697>>>>>            Set piChannel to iCh
75698>>>>>        End
75698>>>>>>
75698>>>>>
75698>>>>>        Get psLogTextFileWithPath to sFileName
75699>>>>>        Get vWin32_APIFileSize sFileName to iSize
75700>>>>>        Get pbQuickWrite to bQuickWrite
75701>>>>>        
75701>>>>>        If (bQuickWrite = True) Begin
75703>>>>>            Append_Output channel iCh sFileName
75705>>>>>                If (bQuickWrite = True) Begin
75707>>>>>                    If (iSize = 0) Begin
75709>>>>>                        Write channel iCh C_BOM_UTF8
75711>>>>>                        Writeln channel iCh CS_DatabaseUpdateFramework
75714>>>>>                        Set pbEmptyLogFile to False
75715>>>>>                    End
75715>>>>>>
75715>>>>>                    Writeln channel iCh
75717>>>>>                    Writeln channel iCh ("*** Database Update Started:      " + String(dtUpdateStart))
75720>>>>>                End
75720>>>>>>
75720>>>>>            Close_Output channel iCh
75722>>>>>        End
75722>>>>>>
75722>>>>>    End_Procedure
75723>>>>>
75723>>>>>    // Returns the first datapath found in the psDataPath property.
75723>>>>>    // The returned path always ends with a "\"
75723>>>>>    Function psDataPathFirstPart Returns String
75725>>>>>        String sDataPath
75725>>>>>        Integer iCount
75725>>>>>
75725>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
75726>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
75727>>>>>        If (iCount > 1) Begin
75729>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
75730>>>>>        End
75730>>>>>>
75730>>>>>        If (sDataPath <> "") Begin
75732>>>>>            Get vFolderFormat sDataPath to sDataPath
75733>>>>>        End
75733>>>>>>
75733>>>>>
75733>>>>>        Function_Return sDataPath
75734>>>>>    End_Function
75735>>>>>
75735>>>>>    // Called from the cDbUpdateHandler object after all updates have been done.
75735>>>>>    Procedure WriteErrorLog
75737>>>>>        tDbUpdateError[] aDbUpdateErrorArray
75737>>>>>        tDbUpdateError[] aDbUpdateErrorArray
75738>>>>>        String sFileName sErrorNo sVersion sErrorText sText sRootName sOrgErrorText
75738>>>>>        Integer iCount iSize iCh iError iErrorLine iField
75738>>>>>        Boolean bUseDataTable bQuickWrite
75738>>>>>        DateTime dtUpdateStart dtUpdateEnd
75738>>>>>        TimeSpan tsElapsed
75738>>>>>        Number nVersion                                  
75738>>>>>        Handle hTable
75738>>>>>
75738>>>>>        If (pbHeaderWritten(Self) = False) Begin
75740>>>>>            Send WriteHeaderData
75741>>>>>            Set pbHeaderWritten to True
75742>>>>>        End
75742>>>>>>
75742>>>>>
75742>>>>>        Get pbUseDataTableLog to bUseDataTable
75743>>>>>        If (bUseDataTable = True) Begin
75745>>>>>            Send OnWriteRow_DataTable
75746>>>>>            Procedure_Return
75747>>>>>        End
75747>>>>>>
75747>>>>>
75747>>>>>        Get piChannel to iCh
75748>>>>>        If (iCh < 0) Begin
75750>>>>>            Get Seq_New_Channel to iCh
75751>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75753>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
75754>>>>>>
75754>>>>>                Procedure_Return
75755>>>>>            End
75755>>>>>>
75755>>>>>            Set piChannel to iCh
75756>>>>>        End
75756>>>>>>
75756>>>>>
75756>>>>>        Get psLogTextFileWithPath to sFileName
75757>>>>>
75757>>>>>        Get paDbUpdateErrorArray to aDbUpdateErrorArray
75758>>>>>        Move (SizeOfArray(aDbUpdateErrorArray)) to iSize
75759>>>>>        Decrement iSize
75760>>>>>
75760>>>>>        Get pdtUpdateStart to dtUpdateStart
75761>>>>>        If (IsNullDateTime(dtUpdateStart) = False) Begin
75763>>>>>            Move (CurrentDateTime()) to dtUpdateEnd
75764>>>>>            Move (dtUpdateEnd - dtUpdateStart) to tsElapsed
75765>>>>>        End
75765>>>>>>
75765>>>>>        Get pbQuickWrite to bQuickWrite
75766>>>>>
75766>>>>>        Append_Output channel iCh sFileName
75768>>>>>        If (bQuickWrite = True and iSize < 0) Begin
75770>>>>>            Writeln channel iCh ("*** Database Update Finished:  " + String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
75773>>>>>        End
75773>>>>>>
75773>>>>>        Else If (bQuickWrite = False) Begin
75776>>>>>            Writeln channel iCh
75778>>>>>            Writeln channel iCh ("*** Database Update Started:" * String(dtUpdateStart) * "and finished at:" * String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
75781>>>>>        End   
75781>>>>>>
75781>>>>>        If (iSize >= 0) Begin
75783>>>>>            If (aDbUpdateErrorArray[0].bShortFormat = False) Begin
75785>>>>>//                Writeln channel iCh "[Err No:] [pnVersionNumber:] [Status Text:]"
75785>>>>>                Writeln channel iCh "[Err No:] [Version:] [Status Text:]"
75788>>>>>            End
75788>>>>>>
75788>>>>>        End
75788>>>>>>
75788>>>>>
75788>>>>>        For iCount from 0 to iSize  
75794>>>>>>
75794>>>>>            Move aDbUpdateErrorArray[iCount].iError         to iError
75795>>>>>            Move aDbUpdateErrorArray[iCount].nUpdateVersion to nVersion
75796>>>>>            Move aDbUpdateErrorArray[iCount].sErrorText     to sErrorText
75797>>>>>            Move aDbUpdateErrorArray[iCount].iErrorLine     to iErrorLine  
75798>>>>>            Move aDbUpdateErrorArray[iCount].hTable         to hTable
75799>>>>>            Move aDbUpdateErrorArray[iCount].sTableRootName to sRootName
75800>>>>>            Move aDbUpdateErrorArray[iCount].iField         to iField
75801>>>>>            
75801>>>>>            Get PadLeft (String(iError)) 8 to sErrorNo
75802>>>>>            If (iError = 0) Begin
75804>>>>>                Move " Info  " to sErrorNo
75805>>>>>            End
75805>>>>>>
75805>>>>>            If (aDbUpdateErrorArray[iCount].bError = True) Begin
75807>>>>>                Get PadLeft (String(nVersion)) (19 - Length(sErrorNo)) to sVersion
75808>>>>>//                Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
75808>>>>>                Move (sErrorNo + sVersion + "   " + sErrorText * "[ErrLine:" * String(iErrorLine) + "]" + "    (Table:" * sRootName * String(hTable) + "." + String(iField) + ")") to sText
75809>>>>>            End
75809>>>>>>
75809>>>>>            Else Begin
75810>>>>>                Get PadLeft (String(nVersion)) (19 - Length(sErrorNo)) to sVersion
75811>>>>>//                Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
75811>>>>>                Move (sErrorNo + sVersion + "   " + sErrorText) to sText
75812>>>>>            End
75812>>>>>>
75812>>>>>            Writeln channel iCh sText
75815>>>>>            If (aDbUpdateErrorArray[iCount].sOrgErrorText <> "") Begin
75817>>>>>                Move ("   (" + aDbUpdateErrorArray[iCount].sOrgErrorText + ")") to sOrgErrorText
75818>>>>>                Move (Utf8ToAnsi(sOrgErrorText)) to sOrgErrorText       
75819>>>>>                Writeln channel iCh sOrgErrorText
75822>>>>>            End
75822>>>>>>
75822>>>>>            If (sText contains CS_SuccessfulUpdate) Begin
75824>>>>>                Writeln channel iCh
75826>>>>>            End
75826>>>>>>
75826>>>>>        Loop
75827>>>>>>
75827>>>>>        Close_Output channel iCh
75829>>>>>
75829>>>>>        Send Seq_Release_Channel iCh
75830>>>>>        Set piChannel to -1
75831>>>>>
75831>>>>>    End_Procedure
75832>>>>>
75832>>>>>    // The character to pad is optional. If nothing, spaces are used.
75832>>>>>    // Example:
75832>>>>>    // Move (PadLeft(45672,10,"0")) to sString -> "0000045672"
75832>>>>>    //  or:
75832>>>>>    // Move (PadLeft("Test",10)) to sString -> " Test"
75832>>>>>    // Courtesy of Pieter van Dieren. Collected from DAWs' Newsgroups.
75832>>>>>    Function PadLeft String sString Integer iLength String sOptChar Returns String
75834>>>>>        String sChar
75834>>>>>
75834>>>>>        If (Num_Arguments >= 3) Begin
75836>>>>>            Move sOptChar to sChar
75837>>>>>        End
75837>>>>>>
75837>>>>>        Else Begin
75838>>>>>            Move " " to sChar
75839>>>>>        End
75839>>>>>>
75839>>>>>
75839>>>>>        While (Length(sString) < iLength)
75843>>>>>            Move (sChar + sString) to sString
75844>>>>>        Loop
75845>>>>>>
75845>>>>>
75845>>>>>        Function_Return sString
75846>>>>>    End_Function
75847>>>>>
75847>>>>>    Procedure ShowErrorLog
75849>>>>>        String sPath sFileName sEditorProgram
75849>>>>>        Boolean bExists
75849>>>>>
75849>>>>>        Get psLogTextFileWithPath to sFileName
75850>>>>>        Get vFilePathExists sFileName to bExists
75851>>>>>        If (bExists = True) Begin
75853>>>>>            Get psEditorProgram to sEditorProgram
75854>>>>>            If (sEditorProgram <> "") Begin
75856>>>>>                Runprogram Background (psEditorProgram(Self)) (sPath + sFileName)
75857>>>>>            End
75857>>>>>>
75857>>>>>            Else Begin
75858>>>>>                Runprogram Shell Background sFileName
75859>>>>>            End
75859>>>>>>
75859>>>>>        End
75859>>>>>>
75859>>>>>        Else Begin
75860>>>>>            Send Info_Box (CS_DUF_LogFileNotFound + String(sFileName))
75861>>>>>        End
75861>>>>>>
75861>>>>>    End_Procedure
75862>>>>>
75862>>>>>End_Class
75863>>>Use cDbUpdateVersion.pkg
Including file: cDbUpdateVersion.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateVersion.pkg)
75863>>>>>//****************************************************************************
75863>>>>>// $Module type: Class
75863>>>>>// $Module name: cDbUpdateVersion
75863>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75863>>>>>// Web-site    : http://www.rdctools.com
75863>>>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
75863>>>>>//
75863>>>>>// Description : Child class to cDbUpdateHandler.
75863>>>>>//               Put an object of this class inside the global ghoDbUpdateHandler object.
75863>>>>>//               Set the pnVersionNumber to a version number.
75863>>>>>//               Inside the cDbUpdateVersion object put a "Use MyNewDbUpdatePackage.pkg"
75863>>>>>//               Add one cVersion object for each update of the database to the ghoDbUpdateHandler object.
75863>>>>>//               Place your code in the "OnUpdate" event that alters the database.
75863>>>>>//
75863>>>>>// $Rev History:
75863>>>>>//    2016-09-27  Module header created
75863>>>>>//****************************************************************************
75863>>>>>Use UI
75863>>>>>Use DUFLanguageConstants.inc
75863>>>>>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
75863>>>>>>>//****************************************************************************
75863>>>>>>>// $Module type: Class
75863>>>>>>>// $Module name: cDbUpdateFunctionLibrary
75863>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75863>>>>>>>// Web-site    : http://www.rdctools.com
75863>>>>>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
75863>>>>>>>//
75863>>>>>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
75863>>>>>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
75863>>>>>>>//               functions to make db changes to Sql databases with DAW drivers,
75863>>>>>>>//               with the help of Sql-scripts.
75863>>>>>>>//
75863>>>>>>>// $Rev History:
75863>>>>>>>//    2014-09-05  Module header created
75863>>>>>>>//
75863>>>>>>>//****************************************************************************
75863>>>>>>>//
75863>>>>>>>// Martin Moleman on SQL Server and DateTime2 (Don't use DataTime any longer !)
75863>>>>>>>// One remark about your change: I would not change to datetime2(7) (7 decimals) but to
75863>>>>>>>// datetime2(3) (3 decimals = milliseconds) or If you don't need the milliseconds datetime2(0).
75863>>>>>>>// The reason is that the DataFlex DateTime type only allows 3 decimals. When using 7
75863>>>>>>>// decimals you may Get truncation that again may cause problems with finding.
75863>>>>>>>//
75863>>>>>>>// Important! The conversion from DateTime to Date or datetime2 will also convert all dummy zero Date values from 1753-01-01 to 0001-01-01.
75863>>>>>>>// This is important to realize. The conversion will actually change the data in the database (done by the driver)
75863>>>>>>>
75863>>>>>>>
75863>>>>>>>// DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA
75863>>>>>>>// Determines for all DataFlex data types, which SQL native types will be used when creating new columns.
75863>>>>>>>// Set_Attribute DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA of {driverNumber} {databaseHandle} ;
75863>>>>>>>// to {MAP_DF_TO_SQL_TYPE_SQL2000|MAP_DF_TO_SQL_TYPE_SQL2005|MAP_DF_TO_SQL_TYPE_SQL2008|MAP_DF_TO_SQL_TYPE_SQL2012}
75863>>>>>>>//
75863>>>>>>>Use cBaseDbUpdateFuncLib.pkg
Including file: cBaseDbUpdateFuncLib.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cBaseDbUpdateFuncLib.pkg)
75863>>>>>>>>>//****************************************************************************
75863>>>>>>>>>// $Module type: Class
75863>>>>>>>>>// $Module name: cBaseDbUpdateFuncLib
75863>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75863>>>>>>>>>// Web-site    : http://www.rdctools.com
75863>>>>>>>>>// Created     : 2023-11-06 @ 09:50 (Military date format: YY-MM-DD)
75863>>>>>>>>>//
75863>>>>>>>>>// Description : The class consists of the basis/parent for the cDbUpdateFunctionLibrary class
75863>>>>>>>>>//               It contains helper functions for the cDbUpdateFunctionLibrary class
75863>>>>>>>>>//
75863>>>>>>>>>// $Rev History:
75863>>>>>>>>>//    2023-11-06  Module header created
75863>>>>>>>>>//
75863>>>>>>>>>//****************************************************************************
75863>>>>>>>>>Use cApplication.pkg
75863>>>>>>>>>Use seq_chnl.pkg
75863>>>>>>>>>Use GlobalFunctionsProcedures.pkg
75863>>>>>>>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
75863>>>>>>>>>Use Dfcursor.pkg
75863>>>>>>>>>Use DUFStatusPanel.pkg
75863>>>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
75863>>>>>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
75863>>>>>>>>>>>//
75863>>>>>>>>>>>// We need to create a mixin class for the library.
75863>>>>>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
75863>>>>>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
75863>>>>>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
75863>>>>>>>>>>>// Note: This class should _not_ have a construct_object defined.
75863>>>>>>>>>>>//
75863>>>>>>>>>>>Use VdfBase.pkg
75863>>>>>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files\DataFlex 24.0\Pkg\WinUuid.pkg)
75863>>>>>>>>>>>>>Use Unicode.Pkg
75863>>>>>>>>>>>>>
75863>>>>>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll ;    Pointer Uuid ;    Returns Integer
75864>>>>>>>>>>>>>
75864>>>>>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringW" Rpcrt4.dll ;    Pointer pUuid ;    Pointer lpUUIDString ;    Returns Integer
75865>>>>>>>>>>>>>
75865>>>>>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll ;    Pointer pUuid ;    Returns Integer
75866>>>>>>>>>>>>>
75866>>>>>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeW" Rpcrt4.dll ;    Pointer pStr ;    Returns Integer
75867>>>>>>>>>>>>>
75867>>>>>>>>>>>>>
75867>>>>>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
75867>>>>>>>>>>>>>Function RandomHexUUID Global Returns String
75869>>>>>>>>>>>>>    Pointer pUUID pUUIDStr
75869>>>>>>>>>>>>>    Integer iRetval iOffset iChar
75869>>>>>>>>>>>>>    String sUUID
75869>>>>>>>>>>>>>    
75869>>>>>>>>>>>>>    Move (Alloc(16)) to pUUID
75870>>>>>>>>>>>>>    
75870>>>>>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
75871>>>>>>>>>>>>>    
75871>>>>>>>>>>>>>    If (iRetval = 0) Begin
75873>>>>>>>>>>>>>        Move 0 to pUUIDStr
75874>>>>>>>>>>>>>        
75874>>>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75875>>>>>>>>>>>>>        If (iRetval = 0) Begin
75877>>>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75878>>>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75879>>>>>>>>>>>>>            
75879>>>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75880>>>>>>>>>>>>>        End
75880>>>>>>>>>>>>>>
75880>>>>>>>>>>>>>    End
75880>>>>>>>>>>>>>>
75880>>>>>>>>>>>>>    
75880>>>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
75881>>>>>>>>>>>>>    
75881>>>>>>>>>>>>>    Function_Return sUUID
75882>>>>>>>>>>>>>End_Function
75883>>>>>>>>>>>>>
75883>>>>>>>>>>>>>
75883>>>>>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
75883>>>>>>>>>>>>>Function SeqHexUUID Global Returns String
75885>>>>>>>>>>>>>    Pointer pUUID pUUIDStr
75885>>>>>>>>>>>>>    Integer iRetval iOffset iChar
75885>>>>>>>>>>>>>    String sUUID
75885>>>>>>>>>>>>>    
75885>>>>>>>>>>>>>    Move (Alloc(16)) to pUUID
75886>>>>>>>>>>>>>    
75886>>>>>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
75887>>>>>>>>>>>>>    
75887>>>>>>>>>>>>>    If (iRetval = 0) Begin
75889>>>>>>>>>>>>>        Move 0 to pUUIDStr
75890>>>>>>>>>>>>>        
75890>>>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75891>>>>>>>>>>>>>        If (iRetval = 0) Begin
75893>>>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75894>>>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75895>>>>>>>>>>>>>            
75895>>>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75896>>>>>>>>>>>>>        End
75896>>>>>>>>>>>>>>
75896>>>>>>>>>>>>>    End
75896>>>>>>>>>>>>>>
75896>>>>>>>>>>>>>    
75896>>>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
75897>>>>>>>>>>>>>    
75897>>>>>>>>>>>>>    Function_Return sUUID
75898>>>>>>>>>>>>>End_Function
75899>>>>>>>>>>>Use cli.pkg
75899>>>>>>>>>>>Use sql.pkg
75899>>>>>>>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSqldrv.pkg)
75899>>>>>>>>>>>>>//     Package that declares MS SQL driver constants and functions.
75899>>>>>>>>>>>>>//     This package can be used by developers who want to add Data Access
75899>>>>>>>>>>>>>//     MS SQL Client specific code to a DataFlex application.
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>Use Cli.pkg
75899>>>>>>>>>>>>>Use SQL.pkg
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>//   Driver Indentification
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>//   Error number constants
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>// SQL Server spcific types.
75899>>>>>>>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
75899>>>>>>>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
75899>>>>>>>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
75899>>>>>>>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>// SQL Server spcific types.
75899>>>>>>>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
75899>>>>>>>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
75899>>>>>>>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
75899>>>>>>>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
75899>>>>>>>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
75899>>>>>>>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
75899>>>>>>>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
75899>>>>>>>>>>>>>//
75899>>>>>>>>>>>>>//     Setup a constraint for a file.
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>
75899>>>>>>>>>>>>>Class cMSSQLHandler is a cCLIHandler
75900>>>>>>>>>>>>>    
75900>>>>>>>>>>>>>    Procedure Construct_Object
75902>>>>>>>>>>>>>        Forward Send Construct_Object
75904>>>>>>>>>>>>>        
75904>>>>>>>>>>>>>        Set psDriverID to MSSQLDRV_ID
75905>>>>>>>>>>>>>    End_Procedure
75906>>>>>>>>>>>>>    
75906>>>>>>>>>>>>>    
75906>>>>>>>>>>>>>    
75906>>>>>>>>>>>>>    //   Extract the list from the out connect string.
75906>>>>>>>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
75908>>>>>>>>>>>>>        String  sItem
75908>>>>>>>>>>>>>        Integer iStart
75908>>>>>>>>>>>>>        Integer iEnd
75908>>>>>>>>>>>>>        
75908>>>>>>>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
75911>>>>>>>>>>>>>        
75911>>>>>>>>>>>>>        Send Delete_Data to hoStore
75912>>>>>>>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
75913>>>>>>>>>>>>>        While (iStart > 0)
75917>>>>>>>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
75918>>>>>>>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
75921>>>>>>>>>>>>>            Else Begin
75922>>>>>>>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
75923>>>>>>>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
75924>>>>>>>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
75927>>>>>>>>>>>>>                
75927>>>>>>>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
75930>>>>>>>>>>>>>                
75930>>>>>>>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
75933>>>>>>>>>>>>>            End
75933>>>>>>>>>>>>>>
75933>>>>>>>>>>>>>        Loop
75934>>>>>>>>>>>>>>
75934>>>>>>>>>>>>>        
75934>>>>>>>>>>>>>        Function_Return (Item_Count(hoStore))
75935>>>>>>>>>>>>>    End_Procedure
75936>>>>>>>>>>>>>    
75936>>>>>>>>>>>>>    
75936>>>>>>>>>>>>>    
75936>>>>>>>>>>>>>    //   Call the driver's browse connect function
75936>>>>>>>>>>>>>    Function BrowseConnect String sInConnStr Returns String
75938>>>>>>>>>>>>>        String  sDriver
75938>>>>>>>>>>>>>        String  sOutConnStr
75938>>>>>>>>>>>>>        Integer iArg
75938>>>>>>>>>>>>>        Integer iRetval
75938>>>>>>>>>>>>>        
75938>>>>>>>>>>>>>        Get psDriverID to sDriver
75939>>>>>>>>>>>>>        If (sDriver <> "") Begin
75941>>>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75942>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75947>>>>>>>>>>>>>        End
75947>>>>>>>>>>>>>>
75947>>>>>>>>>>>>>        
75947>>>>>>>>>>>>>        Function_Return sOutConnStr
75948>>>>>>>>>>>>>    End_Function// BrowseConnect
75949>>>>>>>>>>>>>    
75949>>>>>>>>>>>>>    
75949>>>>>>>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
75951>>>>>>>>>>>>>        String  sDriver
75951>>>>>>>>>>>>>        String  sOutConnStr
75951>>>>>>>>>>>>>        Integer iArg
75951>>>>>>>>>>>>>        Integer iRetval
75951>>>>>>>>>>>>>        
75951>>>>>>>>>>>>>        Move 1 to iArg // Browses only local
75952>>>>>>>>>>>>>        
75952>>>>>>>>>>>>>        Get psDriverID to sDriver
75953>>>>>>>>>>>>>        If (sDriver <> "") Begin
75955>>>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75956>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75961>>>>>>>>>>>>>        End
75961>>>>>>>>>>>>>>
75961>>>>>>>>>>>>>        
75961>>>>>>>>>>>>>        Function_Return sOutConnStr
75962>>>>>>>>>>>>>    End_Function// BrowseConnect
75963>>>>>>>>>>>>>    
75963>>>>>>>>>>>>>    
75963>>>>>>>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
75965>>>>>>>>>>>>>        String  sServerList
75965>>>>>>>>>>>>>        Integer iNumServers
75965>>>>>>>>>>>>>        Integer iDriver
75965>>>>>>>>>>>>>        Integer iClientVersion
75965>>>>>>>>>>>>>        String  sDriver
75965>>>>>>>>>>>>>        
75965>>>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
75966>>>>>>>>>>>>>        
75966>>>>>>>>>>>>>        If (iDriver) Begin
75968>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
75971>>>>>>>>>>>>>            
75971>>>>>>>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
75972>>>>>>>>>>>>>            
75972>>>>>>>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
75973>>>>>>>>>>>>>            If (iNetworkLocal = 0) Begin
75975>>>>>>>>>>>>>                Get BrowseConnect sDriver to sServerList
75976>>>>>>>>>>>>>            End
75976>>>>>>>>>>>>>>
75976>>>>>>>>>>>>>            Else Begin
75977>>>>>>>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
75978>>>>>>>>>>>>>            End
75978>>>>>>>>>>>>>>
75978>>>>>>>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
75979>>>>>>>>>>>>>        End
75979>>>>>>>>>>>>>>
75979>>>>>>>>>>>>>        
75979>>>>>>>>>>>>>        Function_Return iNumServers
75980>>>>>>>>>>>>>    End_Function
75981>>>>>>>>>>>>>    
75981>>>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
75981>>>>>>>>>>>>>    //   This function will return all SQL Server instances on the network.
75981>>>>>>>>>>>>>    //   This may take a long time.
75981>>>>>>>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
75981>>>>>>>>>>>>>    Function EnumerateServers Returns Integer
75983>>>>>>>>>>>>>        Integer iNumServers
75983>>>>>>>>>>>>>        Integer iNetworkLocal
75983>>>>>>>>>>>>>        
75983>>>>>>>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
75984>>>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75985>>>>>>>>>>>>>
75985>>>>>>>>>>>>>        Function_Return iNumServers
75986>>>>>>>>>>>>>    End_Function
75987>>>>>>>>>>>>>    
75987>>>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
75987>>>>>>>>>>>>>    //   This function will return only return SQL Server instance on the local machine
75987>>>>>>>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
75987>>>>>>>>>>>>>    Function EnumerateServersLocal Returns Integer
75989>>>>>>>>>>>>>        Integer iNumServers
75989>>>>>>>>>>>>>        Integer iNetworkLocal
75989>>>>>>>>>>>>>        
75989>>>>>>>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
75990>>>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75991>>>>>>>>>>>>>        
75991>>>>>>>>>>>>>        Function_Return iNumServers
75992>>>>>>>>>>>>>    End_Function
75993>>>>>>>>>>>>>    
75993>>>>>>>>>>>>>    //   Enumerate database in a given server.
75993>>>>>>>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
75995>>>>>>>>>>>>>        Integer hoSQL
75995>>>>>>>>>>>>>        String  sConnect
75995>>>>>>>>>>>>>        String  sDatabase
75995>>>>>>>>>>>>>        Integer hdbc
75995>>>>>>>>>>>>>        Integer hstmt
75995>>>>>>>>>>>>>        Integer iFetchResult iDriver iClientVersion
75995>>>>>>>>>>>>>        
75995>>>>>>>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
75998>>>>>>>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
76001>>>>>>>>>>>>>        
76001>>>>>>>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
76004>>>>>>>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
76006>>>>>>>>>>>>>
76006>>>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
76007>>>>>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
76010>>>>>>>>>>>>>        If (iClientVersion >= 18) Begin
76012>>>>>>>>>>>>>            Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
76013>>>>>>>>>>>>>            Move (Replaces(" ", sConnect, "")) to sConnect
76014>>>>>>>>>>>>>        End
76014>>>>>>>>>>>>>>
76014>>>>>>>>>>>>>        
76014>>>>>>>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
76016>>>>>>>>>>>>>            Move Current_Object to hoSQL
76017>>>>>>>>>>>>>        End_Object
76018>>>>>>>>>>>>>        
76018>>>>>>>>>>>>>        If (hoSQL <> 0) Begin
76020>>>>>>>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
76021>>>>>>>>>>>>>            If (hdbc <> 0) Begin
76023>>>>>>>>>>>>>                Get SQLOpen of hdbc to hstmt
76024>>>>>>>>>>>>>                If (hstmt <> 0) Begin
76026>>>>>>>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
76026>>>>>>>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
76026>>>>>>>>>>>>>                    //   approach in case meta data might change, the stored procedure will
76026>>>>>>>>>>>>>                    //   stay the same.
76026>>>>>>>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
76027>>>>>>>>>>>>>                    Send SQLCall to hstmt
76028>>>>>>>>>>>>>                    Repeat
76028>>>>>>>>>>>>>>
76028>>>>>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
76029>>>>>>>>>>>>>                        If (iFetchResult <> 0) Begin
76031>>>>>>>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
76032>>>>>>>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
76033>>>>>>>>>>>>>                        End
76033>>>>>>>>>>>>>>
76033>>>>>>>>>>>>>                    Until (iFetchResult = 0)
76035>>>>>>>>>>>>>                    
76035>>>>>>>>>>>>>                    Send SQLClose to hstmt
76036>>>>>>>>>>>>>                End
76036>>>>>>>>>>>>>>
76036>>>>>>>>>>>>>                Send SQLDisconnect to hdbc
76037>>>>>>>>>>>>>            End
76037>>>>>>>>>>>>>>
76037>>>>>>>>>>>>>        End
76037>>>>>>>>>>>>>>
76037>>>>>>>>>>>>>        Send Destroy_Object to hoSQL
76038>>>>>>>>>>>>>        
76038>>>>>>>>>>>>>        Function_Return (Item_Count(Current_Object))
76039>>>>>>>>>>>>>    End_Function
76040>>>>>>>>>>>>>    
76040>>>>>>>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
76042>>>>>>>>>>>>>        String  sSqlServerClientVersionName
76042>>>>>>>>>>>>>        
76042>>>>>>>>>>>>>        Case Begin
76042>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
76044>>>>>>>>>>>>>                Move SQLSERVER2019CLIENTNAME to sSqlServerClientVersionName
76045>>>>>>>>>>>>>                Case Break
76046>>>>>>>>>>>>>            
76046>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
76049>>>>>>>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
76050>>>>>>>>>>>>>                Case Break
76051>>>>>>>>>>>>>                
76051>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
76054>>>>>>>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
76055>>>>>>>>>>>>>                Case Break
76056>>>>>>>>>>>>>            
76056>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
76059>>>>>>>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
76060>>>>>>>>>>>>>                Case Break
76061>>>>>>>>>>>>>            
76061>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
76064>>>>>>>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
76065>>>>>>>>>>>>>                Case Break
76066>>>>>>>>>>>>>            
76066>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
76069>>>>>>>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
76070>>>>>>>>>>>>>                Case Break
76071>>>>>>>>>>>>>            
76071>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
76074>>>>>>>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
76075>>>>>>>>>>>>>                Case Break
76076>>>>>>>>>>>>>            
76076>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
76079>>>>>>>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
76080>>>>>>>>>>>>>                Case Break
76081>>>>>>>>>>>>>            
76081>>>>>>>>>>>>>            Case Else
76081>>>>>>>>>>>>>                Move (SFormat("%1 (version %2) ",SQLSERVERUNKNOWNCLIENTNAME,iClientVersion)) to sSqlServerClientVersionName
76082>>>>>>>>>>>>>        Case End
76082>>>>>>>>>>>>>        
76082>>>>>>>>>>>>>        Function_Return sSqlServerClientVersionName
76083>>>>>>>>>>>>>    End_Function
76084>>>>>>>>>>>>>
76084>>>>>>>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
76086>>>>>>>>>>>>>        String  sSqlServerClientDriverName
76086>>>>>>>>>>>>>        
76086>>>>>>>>>>>>>        Case Begin
76086>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
76088>>>>>>>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientDriverName
76089>>>>>>>>>>>>>                Case Break
76090>>>>>>>>>>>>>
76090>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
76093>>>>>>>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
76094>>>>>>>>>>>>>                Case Break
76095>>>>>>>>>>>>>                
76095>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
76098>>>>>>>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
76099>>>>>>>>>>>>>                Case Break
76100>>>>>>>>>>>>>            
76100>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
76103>>>>>>>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
76104>>>>>>>>>>>>>                Case Break
76105>>>>>>>>>>>>>            
76105>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
76108>>>>>>>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
76109>>>>>>>>>>>>>                Case Break
76110>>>>>>>>>>>>>            
76110>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
76113>>>>>>>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
76114>>>>>>>>>>>>>                Case Break
76115>>>>>>>>>>>>>            
76115>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
76118>>>>>>>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
76119>>>>>>>>>>>>>                Case Break
76120>>>>>>>>>>>>>            
76120>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
76123>>>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
76124>>>>>>>>>>>>>                Case Break
76125>>>>>>>>>>>>>            
76125>>>>>>>>>>>>>            Case Else
76125>>>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
76126>>>>>>>>>>>>>        Case End
76126>>>>>>>>>>>>>        
76126>>>>>>>>>>>>>        Function_Return sSqlServerClientDriverName
76127>>>>>>>>>>>>>    End_Function
76128>>>>>>>>>>>>>    
76128>>>>>>>>>>>>>End_Class
76129>>>>>>>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files\DataFlex 24.0\Pkg\db2_drv.pkg)
76129>>>>>>>>>>>>>// DB2_DRV.PKG                                                          
76129>>>>>>>>>>>>>//   Package that declares DB2 driver constants and functions.          
76129>>>>>>>>>>>>>//   This package can be used by developers who want to add DB2 driver  
76129>>>>>>>>>>>>>//   specific code to a DataFlex application.                           
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>Use Cli.pkg
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>// Driver attributes
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>// Driver Indentification
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>// Error number constants
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>// Call driver function identifiers
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>// DB2 specific data types
76129>>>>>>>>>>>>>Define SQL_CLOB           for   (-99)
76129>>>>>>>>>>>>>Define SQL_BLOB           for   (-98)
76129>>>>>>>>>>>>>Define SQL_XML            for   (-370)
76129>>>>>>>>>>>>>// DB2 Graphic types are Unicode types
76129>>>>>>>>>>>>>Define SQL_GRAPHIC        for   (-95)
76129>>>>>>>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
76129>>>>>>>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
76129>>>>>>>>>>>>>Define SQL_DBCLOB         for   (-350)
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>// Extra DB2 commands
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
76129>>>>>>>>>>>>>//   Setup a constraint for a file.                                     
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>
76129>>>>>>>>>>>>>Class cDB2Handler is a cCLIHandler
76130>>>>>>>>>>>>>    
76130>>>>>>>>>>>>>    Procedure Construct_Object
76132>>>>>>>>>>>>>        Forward Send Construct_Object
76134>>>>>>>>>>>>>        
76134>>>>>>>>>>>>>        Set psDriverID to DB2_DRV_ID
76135>>>>>>>>>>>>>    End_Procedure
76136>>>>>>>>>>>>>    
76136>>>>>>>>>>>>>    
76136>>>>>>>>>>>>>    
76136>>>>>>>>>>>>>    // Reset the datasource list to the beginning
76136>>>>>>>>>>>>>    Procedure SeedDataSources
76138>>>>>>>>>>>>>        String  sDriver
76138>>>>>>>>>>>>>        String  sVoid
76138>>>>>>>>>>>>>        Integer iRetval
76138>>>>>>>>>>>>>        
76138>>>>>>>>>>>>>        Get psDriverID to sDriver
76139>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
76146>>>>>>>>>>>>>    End_Procedure
76147>>>>>>>>>>>>>    
76147>>>>>>>>>>>>>    
76147>>>>>>>>>>>>>    
76147>>>>>>>>>>>>>    // Call the driver's data sources function
76147>>>>>>>>>>>>>    Function DataSources Returns String
76149>>>>>>>>>>>>>        String  sDriver
76149>>>>>>>>>>>>>        String  sDataSource
76149>>>>>>>>>>>>>        String  sDescription
76149>>>>>>>>>>>>>        Integer iLength
76149>>>>>>>>>>>>>        Integer iRetval
76149>>>>>>>>>>>>>        
76149>>>>>>>>>>>>>        Get psDriverID to sDriver
76150>>>>>>>>>>>>>        If (sDriver <> "") Begin
76152>>>>>>>>>>>>>            Move 8192 to iLength
76153>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
76154>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
76155>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
76160>>>>>>>>>>>>>        End
76160>>>>>>>>>>>>>>
76160>>>>>>>>>>>>>        
76160>>>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," *  sDescription, "")))
76163>>>>>>>>>>>>>        Else ;            Function_Return ""
76165>>>>>>>>>>>>>    End_Function
76166>>>>>>>>>>>>>    
76166>>>>>>>>>>>>>End_Class
76167>>>>>>>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files\DataFlex 24.0\Pkg\odbc_drv.pkg)
76167>>>>>>>>>>>>>//   Package that declares ODBC driver constants and functions.         
76167>>>>>>>>>>>>>//   This package can be used by developers who want to add Data Access 
76167>>>>>>>>>>>>>//   ODBC Client specific code to a DataFlex application.               
76167>>>>>>>>>>>>>
76167>>>>>>>>>>>>>Use Cli.pkg
76167>>>>>>>>>>>>>
76167>>>>>>>>>>>>>// Driver Indentification
76167>>>>>>>>>>>>>
76167>>>>>>>>>>>>>// Error number constants
76167>>>>>>>>>>>>>
76167>>>>>>>>>>>>>// Call driver function identifiers
76167>>>>>>>>>>>>>
76167>>>>>>>>>>>>>Class cODBCHandler is a cCLIHandler
76168>>>>>>>>>>>>>    
76168>>>>>>>>>>>>>    Procedure Construct_Object
76170>>>>>>>>>>>>>        Forward Send Construct_Object
76172>>>>>>>>>>>>>        
76172>>>>>>>>>>>>>        Set psDriverID to ODBC_DRV_ID
76173>>>>>>>>>>>>>    End_Procedure
76174>>>>>>>>>>>>>    
76174>>>>>>>>>>>>>    
76174>>>>>>>>>>>>>    
76174>>>>>>>>>>>>>    // Setup the type of data sources returned by the datasources function
76174>>>>>>>>>>>>>    Procedure Set DataSourceType Integer iNewType
76176>>>>>>>>>>>>>        String  sDriver
76176>>>>>>>>>>>>>        String  sVoid
76176>>>>>>>>>>>>>        Integer iRetval
76176>>>>>>>>>>>>>        
76176>>>>>>>>>>>>>        Get psDriverID to sDriver
76177>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
76184>>>>>>>>>>>>>    End_Procedure
76185>>>>>>>>>>>>>    
76185>>>>>>>>>>>>>    
76185>>>>>>>>>>>>>    // Call the driver's data sources function
76185>>>>>>>>>>>>>    Function DataSources Returns String
76187>>>>>>>>>>>>>        String  sDriver
76187>>>>>>>>>>>>>        String  sDataSource
76187>>>>>>>>>>>>>        String  sDescription
76187>>>>>>>>>>>>>        Integer iLength
76187>>>>>>>>>>>>>        Integer iRetval
76187>>>>>>>>>>>>>        
76187>>>>>>>>>>>>>        Get psDriverID to sDriver
76188>>>>>>>>>>>>>        If (sDriver <> "") Begin
76190>>>>>>>>>>>>>            Move 8192 to iLength
76191>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
76192>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
76193>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
76198>>>>>>>>>>>>>        End
76198>>>>>>>>>>>>>>
76198>>>>>>>>>>>>>        
76198>>>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," * sDescription, "")))
76201>>>>>>>>>>>>>        Else ;            Function_Return ""
76203>>>>>>>>>>>>>    End_Function
76204>>>>>>>>>>>>>    
76204>>>>>>>>>>>>>End_Class
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files\DataFlex 24.0\Pkg\DFBTRDRV.PKG)
76205>>>>>>>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
76205>>>>>>>>>>>>>// Notice      : This package contains constants and commands, used to call
76205>>>>>>>>>>>>>//               specific functions in the DFBTRDRV.
76205>>>>>>>>>>>>>Use Ui
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Driver Indentification
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>// Driver attributes
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Call_Driver functions ID's
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// DFBTRFN_CONVERT_FILE options
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// DFBTRFN_SET_OWNER options
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to create all vars which may be needed
76205>>>>>>>>>>>>>// in other commands.
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to set the owner of a Btrieve file.
76205>>>>>>>>>>>>>// File must have been opened.
76205>>>>>>>>>>>>>// Filenumber needs to be passed.
76205>>>>>>>>>>>>>// To clear set the owner to "".
76205>>>>>>>>>>>>>// Examples:
76205>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
76205>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
76205>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
76205>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
76205>>>>>>>>>>>>>// To clear:
76205>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to parse DFBTR_SET_OWNVER
76205>>>>>>>>>>>>>// options.
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to parse for Callback
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to clear the owner of a Btrieve file.
76205>>>>>>>>>>>>>// File must have been opened.
76205>>>>>>>>>>>>>// Filenumber needs to be passed.
76205>>>>>>>>>>>>>// Examples:
76205>>>>>>>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to add a owner name to the internal list of ownernames
76205>>>>>>>>>>>>>// which will be tries when opening files.
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to remove all owners from the internal list of ownernames
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to set the owner name to be used when opening the DDF files.
76205>>>>>>>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
76205>>>>>>>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
76205>>>>>>>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to change the transaction type.
76205>>>>>>>>>>>>>// Valid types are:
76205>>>>>>>>>>>>>//     DFBTRTT_NONE
76205>>>>>>>>>>>>>//     DFBTRTT_EXCLUSIVE
76205>>>>>>>>>>>>>//     DFBTRTT_CONCURRENT
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to get the current transaction type.
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to set explicit_locking
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to get explicit locking
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
76205>>>>>>>>>>>>>//
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>// Purpose: An instance of this class can be used as a broker object to
76205>>>>>>>>>>>>>//          call several Dfbtrdrv releated methods.
76205>>>>>>>>>>>>>
76205>>>>>>>>>>>>>Class cDFBtrDrvHandler is an Array
76206>>>>>>>>>>>>>    
76206>>>>>>>>>>>>>    Procedure Construct_Object Integer iImage
76208>>>>>>>>>>>>>        Forward Send Construct_object iImage
76210>>>>>>>>>>>>>        
76210>>>>>>>>>>>>>        Property String  psDriverID "DFBTRDRV"
76211>>>>>>>>>>>>>    End_Procedure
76212>>>>>>>>>>>>>    
76212>>>>>>>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
76212>>>>>>>>>>>>>    //
76212>>>>>>>>>>>>>    
76212>>>>>>>>>>>>>    Function CKRevision Returns String
76214>>>>>>>>>>>>>        String  sDriverID
76214>>>>>>>>>>>>>        String  sRevision
76214>>>>>>>>>>>>>        String  sVoid
76214>>>>>>>>>>>>>        Integer iRetval
76214>>>>>>>>>>>>>        
76214>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76214>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76214>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76214>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76215>>>>>>>>>>>>>        Get psDriverID to sDriverID
76216>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sRevision
76217>>>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
76222>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76223>>>>>>>>>>>>>        If (Trim(sRevision) = "") Begin
76225>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76225>>>>>>>>>>>>>            Move "0.0.0.0" to sRevision
76226>>>>>>>>>>>>>        End
76226>>>>>>>>>>>>>>
76226>>>>>>>>>>>>>        Function_Return sRevision
76227>>>>>>>>>>>>>    End_Function
76228>>>>>>>>>>>>>    
76228>>>>>>>>>>>>>    Function CkUsesUri Returns Integer
76230>>>>>>>>>>>>>        String  sDriverID
76230>>>>>>>>>>>>>        String  sVoid1
76230>>>>>>>>>>>>>        String  sVoid2
76230>>>>>>>>>>>>>        Integer iRetval
76230>>>>>>>>>>>>>        
76230>>>>>>>>>>>>>        Get psDriverID to sDriverID
76231>>>>>>>>>>>>>        
76231>>>>>>>>>>>>>        Move 0 to iRetval
76232>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76232>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76232>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
76232>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76233>>>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
76238>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76239>>>>>>>>>>>>>        
76239>>>>>>>>>>>>>        Function_Return iRetval
76240>>>>>>>>>>>>>    End_Function
76241>>>>>>>>>>>>>    
76241>>>>>>>>>>>>>    
76241>>>>>>>>>>>>>    
76241>>>>>>>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
76241>>>>>>>>>>>>>    //
76241>>>>>>>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
76241>>>>>>>>>>>>>    //
76241>>>>>>>>>>>>>    
76241>>>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
76243>>>>>>>>>>>>>        Integer iPartRev
76243>>>>>>>>>>>>>        Integer iCurrentPart
76243>>>>>>>>>>>>>        Integer iSeparatorPos
76243>>>>>>>>>>>>>        
76243>>>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
76246>>>>>>>>>>>>>        
76246>>>>>>>>>>>>>        Move 0 to iCurrentPart
76247>>>>>>>>>>>>>        Repeat
76247>>>>>>>>>>>>>>
76247>>>>>>>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
76248>>>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
76250>>>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
76251>>>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
76252>>>>>>>>>>>>>                Increment iCurrentPart
76253>>>>>>>>>>>>>            End
76253>>>>>>>>>>>>>>
76253>>>>>>>>>>>>>            Else If (sRevision <> "") Begin
76256>>>>>>>>>>>>>                Move sRevision to iPartRev
76257>>>>>>>>>>>>>                Move "" to sRevision
76258>>>>>>>>>>>>>                Increment iCurrentPart
76259>>>>>>>>>>>>>            End
76259>>>>>>>>>>>>>>
76259>>>>>>>>>>>>>            Else ;                Move -1 to iPartRev
76261>>>>>>>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
76263>>>>>>>>>>>>>        
76263>>>>>>>>>>>>>        Function_Return iPartRev
76264>>>>>>>>>>>>>    End_Function
76265>>>>>>>>>>>>>    
76265>>>>>>>>>>>>>    
76265>>>>>>>>>>>>>    
76265>>>>>>>>>>>>>    //
76265>>>>>>>>>>>>>    //  Returns the major revision of the CK
76265>>>>>>>>>>>>>    //
76265>>>>>>>>>>>>>    
76265>>>>>>>>>>>>>    Function CKMajorRevision Returns Integer
76267>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
76268>>>>>>>>>>>>>    End_Function
76269>>>>>>>>>>>>>    
76269>>>>>>>>>>>>>    
76269>>>>>>>>>>>>>    
76269>>>>>>>>>>>>>    //  Returns the minor revision of the CK
76269>>>>>>>>>>>>>    //
76269>>>>>>>>>>>>>    
76269>>>>>>>>>>>>>    Function CKMinorRevision Returns Integer
76271>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
76272>>>>>>>>>>>>>    End_Function
76273>>>>>>>>>>>>>    
76273>>>>>>>>>>>>>    
76273>>>>>>>>>>>>>    //  Returns the release revision of the CK
76273>>>>>>>>>>>>>    //
76273>>>>>>>>>>>>>    
76273>>>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
76275>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
76276>>>>>>>>>>>>>    End_Function
76277>>>>>>>>>>>>>    
76277>>>>>>>>>>>>>    
76277>>>>>>>>>>>>>    //  Returns the major revision of the CK
76277>>>>>>>>>>>>>    //
76277>>>>>>>>>>>>>    
76277>>>>>>>>>>>>>    Function CKBuildRevision Returns Integer
76279>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
76280>>>>>>>>>>>>>    End_Function
76281>>>>>>>>>>>>>    
76281>>>>>>>>>>>>>    
76281>>>>>>>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
76281>>>>>>>>>>>>>    //
76281>>>>>>>>>>>>>    
76281>>>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
76283>>>>>>>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
76286>>>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
76289>>>>>>>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
76292>>>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
76295>>>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
76298>>>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
76302>>>>>>>>>>>>>            End
76302>>>>>>>>>>>>>>
76302>>>>>>>>>>>>>        End
76302>>>>>>>>>>>>>>
76302>>>>>>>>>>>>>        
76302>>>>>>>>>>>>>        Function_Return (False)
76303>>>>>>>>>>>>>    End_Function
76304>>>>>>>>>>>>>    
76304>>>>>>>>>>>>>    //   Functions to query the Pervasive.SQL version:
76304>>>>>>>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
76304>>>>>>>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
76304>>>>>>>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
76304>>>>>>>>>>>>>    //
76304>>>>>>>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
76304>>>>>>>>>>>>>    //   in the following format:
76304>>>>>>>>>>>>>    //       <version>.<revision>.<type>
76304>>>>>>>>>>>>>    //   possible values for <type>:
76304>>>>>>>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
76304>>>>>>>>>>>>>    //         server using Workgroup authentication mode
76304>>>>>>>>>>>>>    //       C for client cache engine
76304>>>>>>>>>>>>>    //       D for DOS workstation
76304>>>>>>>>>>>>>    //       N for client Requester
76304>>>>>>>>>>>>>    //       S for NetWare server
76304>>>>>>>>>>>>>    //       T for 32-bit Windows server engine
76304>>>>>>>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
76304>>>>>>>>>>>>>    //
76304>>>>>>>>>>>>>    //   example:
76304>>>>>>>>>>>>>    //       8.50.T
76304>>>>>>>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
76304>>>>>>>>>>>>>    //   32-bits Windows server.
76304>>>>>>>>>>>>>    //
76304>>>>>>>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
76304>>>>>>>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
76304>>>>>>>>>>>>>    //
76304>>>>>>>>>>>>>    //   If the version information is not available or can not be obtained
76304>>>>>>>>>>>>>    //   the functions will return "0.0.0"
76304>>>>>>>>>>>>>    
76304>>>>>>>>>>>>>    //  Returns the version information of the
76304>>>>>>>>>>>>>    //           Pervasive.SQL Client requester.
76304>>>>>>>>>>>>>    
76304>>>>>>>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
76306>>>>>>>>>>>>>        
76306>>>>>>>>>>>>>        String  sDriverID
76306>>>>>>>>>>>>>        String  sVersion
76306>>>>>>>>>>>>>        String  sVoid
76306>>>>>>>>>>>>>        Integer iRetval
76306>>>>>>>>>>>>>        
76306>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76306>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76306>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76306>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76307>>>>>>>>>>>>>        Get psDriverID to sDriverID
76308>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76309>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76314>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76315>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76317>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76317>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76318>>>>>>>>>>>>>        End
76318>>>>>>>>>>>>>>
76318>>>>>>>>>>>>>        Function_Return sVersion
76319>>>>>>>>>>>>>    End_Function
76320>>>>>>>>>>>>>    
76320>>>>>>>>>>>>>    //           Pervasive.SQL Engine
76320>>>>>>>>>>>>>    
76320>>>>>>>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
76322>>>>>>>>>>>>>        
76322>>>>>>>>>>>>>        String  sDriverID
76322>>>>>>>>>>>>>        String  sVersion
76322>>>>>>>>>>>>>        String  sVoid
76322>>>>>>>>>>>>>        Integer iRetval
76322>>>>>>>>>>>>>        
76322>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76322>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76322>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76322>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76323>>>>>>>>>>>>>        Get psDriverID to sDriverID
76324>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76325>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76330>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76331>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76333>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76333>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76334>>>>>>>>>>>>>        End
76334>>>>>>>>>>>>>>
76334>>>>>>>>>>>>>        Function_Return sVersion
76335>>>>>>>>>>>>>    End_Function
76336>>>>>>>>>>>>>    
76336>>>>>>>>>>>>>    //  Returns the version information of the
76336>>>>>>>>>>>>>    //           Pervasive.SQL Server Engine
76336>>>>>>>>>>>>>    
76336>>>>>>>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
76338>>>>>>>>>>>>>        
76338>>>>>>>>>>>>>        String  sDriverID
76338>>>>>>>>>>>>>        String  sVersion
76338>>>>>>>>>>>>>        String  sVoid
76338>>>>>>>>>>>>>        Integer iRetval
76338>>>>>>>>>>>>>        
76338>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76338>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76338>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76338>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76339>>>>>>>>>>>>>        Get psDriverID to sDriverID
76340>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76341>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76346>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76347>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76349>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76349>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76350>>>>>>>>>>>>>        End
76350>>>>>>>>>>>>>>
76350>>>>>>>>>>>>>        Function_Return sVersion
76351>>>>>>>>>>>>>    End_Function
76352>>>>>>>>>>>>>    
76352>>>>>>>>>>>>>End_Class
76353>>>>>>>>>>>>>
76353>>>>>>>>>>>>>
76353>>>>>>>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
76353>>>>>>>>>>>>>//****************************************************************************
76353>>>>>>>>>>>>>// $Module type: Include file
76353>>>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.inc
76353>>>>>>>>>>>>>//
76353>>>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
76353>>>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
76353>>>>>>>>>>>>>// E-mail      : support@rdctools.com
76353>>>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76353>>>>>>>>>>>>>//
76353>>>>>>>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
76353>>>>>>>>>>>>>//
76353>>>>>>>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
76353>>>>>>>>>>>>>//
76353>>>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
76353>>>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
76353>>>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
76353>>>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
76353>>>>>>>>>>>>>// in the help folder for more details.
76353>>>>>>>>>>>>>//
76353>>>>>>>>>>>>>Use Winkern.pkg
76353>>>>>>>>>>>>>Use cIniFile.pkg
76353>>>>>>>>>>>>>    Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCryptographerEx.pkg)
76353>>>>>>>>>>>>>>>Use VdfBase.pkg
76353>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 24.0\Pkg\CryptographerConstants.pkg)
76353>>>>>>>>>>>>>>>>>//   Author  : Ulbe Stellema
76353>>>>>>>>>>>>>>>>>// Algorithm classes
76353>>>>>>>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
76353>>>>>>>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
76353>>>>>>>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
76353>>>>>>>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
76353>>>>>>>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
76353>>>>>>>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
76353>>>>>>>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// Algorithm types
76353>>>>>>>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
76353>>>>>>>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
76353>>>>>>>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
76353>>>>>>>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
76353>>>>>>>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
76353>>>>>>>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
76353>>>>>>>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// Generic sub-ids
76353>>>>>>>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// RSA sub-ids
76353>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
76353>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
76353>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
76353>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
76353>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// DSS sub-ids
76353>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
76353>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
76353>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// DES sub_ids
76353>>>>>>>>>>>>>>>>>Define ALG_SID_DES                      for 1
76353>>>>>>>>>>>>>>>>>Define ALG_SID_3DES                     for 3
76353>>>>>>>>>>>>>>>>>Define ALG_SID_DESX                     for 4
76353>>>>>>>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
76353>>>>>>>>>>>>>>>>>Define ALG_SID_CAST                     for 6
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
76353>>>>>>>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
76353>>>>>>>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
76353>>>>>>>>>>>>>>>>>Define ALG_SID_RC5                      for 13
76353>>>>>>>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
76353>>>>>>>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
76353>>>>>>>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
76353>>>>>>>>>>>>>>>>>Define ALG_SID_AES                      for 17
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// Fortezza sub-ids
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
76353>>>>>>>>>>>>>>>>>Define ALG_SID_TEK                      for 11
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// RC2 sub-ids
76353>>>>>>>>>>>>>>>>>Define ALG_SID_RC2                      for 2
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// Stream cipher sub-ids
76353>>>>>>>>>>>>>>>>>Define ALG_SID_RC4                      for 1
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// Diffie-Hellman sub-ids
76353>>>>>>>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
76353>>>>>>>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
76353>>>>>>>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
76353>>>>>>>>>>>>>>>>>Define ALG_SID_KEA                      for 4
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// Hash sub ids
76353>>>>>>>>>>>>>>>>>Define ALG_SID_MD2                      for 1
76353>>>>>>>>>>>>>>>>>Define ALG_SID_MD4                      for 2
76353>>>>>>>>>>>>>>>>>Define ALG_SID_MD5                      for 3
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SHA                      for 4
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
76353>>>>>>>>>>>>>>>>>Define ALG_SID_MAC                      for 5
76353>>>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
76353>>>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
76353>>>>>>>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
76353>>>>>>>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
76353>>>>>>>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// secure channel sub ids
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
76353>>>>>>>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
76353>>>>>>>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
76353>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// algorithm identifier definitions
76353>>>>>>>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
76353>>>>>>>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
76353>>>>>>>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
76353>>>>>>>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
76353>>>>>>>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
76353>>>>>>>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
76353>>>>>>>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
76353>>>>>>>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
76353>>>>>>>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
76353>>>>>>>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
76353>>>>>>>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
76353>>>>>>>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
76353>>>>>>>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
76353>>>>>>>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
76353>>>>>>>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
76353>>>>>>>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
76353>>>>>>>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
76353>>>>>>>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
76353>>>>>>>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
76353>>>>>>>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
76353>>>>>>>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
76353>>>>>>>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
76353>>>>>>>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
76353>>>>>>>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
76353>>>>>>>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
76353>>>>>>>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
76353>>>>>>>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
76353>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
76353>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
76353>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
76353>>>>>>>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
76353>>>>>>>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
76353>>>>>>>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
76353>>>>>>>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
76353>>>>>>>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
76353>>>>>>>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
76353>>>>>>>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
76353>>>>>>>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
76353>>>>>>>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
76353>>>>>>>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
76353>>>>>>>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
76353>>>>>>>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
76353>>>>>>>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
76353>>>>>>>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// Providers
76353>>>>>>>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
76353>>>>>>>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
76353>>>>>>>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
76353>>>>>>>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
76353>>>>>>>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
76353>>>>>>>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
76353>>>>>>>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
76353>>>>>>>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
76353>>>>>>>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
76353>>>>>>>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
76353>>>>>>>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
76353>>>>>>>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
76353>>>>>>>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
76353>>>>>>>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
76353>>>>>>>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
76353>>>>>>>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// dwFlag definitions for CryptGenKey
76353>>>>>>>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
76353>>>>>>>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
76353>>>>>>>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
76353>>>>>>>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
76353>>>>>>>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
76353>>>>>>>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
76353>>>>>>>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
76353>>>>>>>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
76353>>>>>>>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
76353>>>>>>>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
76353>>>>>>>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
76353>>>>>>>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
76353>>>>>>>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
76353>>>>>>>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
76353>>>>>>>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
76353>>>>>>>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// Provider types
76353>>>>>>>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
76353>>>>>>>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
76353>>>>>>>>>>>>>>>>>Define PROV_DSS                         for 3
76353>>>>>>>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
76353>>>>>>>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
76353>>>>>>>>>>>>>>>>>Define PROV_SSL                         for 6
76353>>>>>>>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
76353>>>>>>>>>>>>>>>>>Define PROV_DSS_DH                      for 13
76353>>>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
76353>>>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
76353>>>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
76353>>>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
76353>>>>>>>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
76353>>>>>>>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
76353>>>>>>>>>>>>>>>>>Define PROV_RNG                         for 21
76353>>>>>>>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
76353>>>>>>>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
76353>>>>>>>>>>>>>>>>>Define PROV_RSA_AES                     for 24
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// KP_MODE
76353>>>>>>>>>>>>>>>>>// KP_MODE
76353>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
76353>>>>>>>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
76353>>>>>>>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
76353>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
76353>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
76353>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
76353>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
76353>>>>>>>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
76353>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
76353>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
76353>>>>>>>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
76353>>>>>>>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
76353>>>>>>>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
76353>>>>>>>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
76353>>>>>>>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
76353>>>>>>>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
76353>>>>>>>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
76353>>>>>>>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
76353>>>>>>>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
76353>>>>>>>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
76353>>>>>>>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
76353>>>>>>>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
76353>>>>>>>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
76353>>>>>>>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
76353>>>>>>>>>>>>>>>>>Define KP_Y                             for 15      // Y value
76353>>>>>>>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
76353>>>>>>>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
76353>>>>>>>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
76353>>>>>>>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
76353>>>>>>>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
76353>>>>>>>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
76353>>>>>>>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
76353>>>>>>>>>>>>>>>>>Define KP_RP                            for 23
76353>>>>>>>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
76353>>>>>>>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
76353>>>>>>>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
76353>>>>>>>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
76353>>>>>>>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
76353>>>>>>>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
76353>>>>>>>>>>>>>>>>>Define KP_KEYVAL                        for 30
76353>>>>>>>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
76353>>>>>>>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
76353>>>>>>>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
76353>>>>>>>>>>>>>>>>>Define KP_PREHASH                       for 34
76353>>>>>>>>>>>>>>>>>Define KP_ROUNDS                        for 35
76353>>>>>>>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
76353>>>>>>>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
76353>>>>>>>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
76353>>>>>>>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
76353>>>>>>>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
76353>>>>>>>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
76353>>>>>>>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
76353>>>>>>>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
76353>>>>>>>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
76353>>>>>>>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
76353>>>>>>>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// key BLOB types
76353>>>>>>>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
76353>>>>>>>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
76353>>>>>>>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
76353>>>>>>>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
76353>>>>>>>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
76353>>>>>>>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
76353>>>>>>>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
76353>>>>>>>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// KP_PADDING
76353>>>>>>>>>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
76353>>>>>>>>>>>>>>>>>Define RANDOM_PADDING                   for 2
76353>>>>>>>>>>>>>>>>>Define ZERO_PADDING                     for 3
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>//  Structure cryptimportkey
76353>>>>>>>>>>>>>>>>>Struct PUBLICKEYSTRUC
76353>>>>>>>>>>>>>>>>>    UChar    bType
76353>>>>>>>>>>>>>>>>>    UChar    bVersion
76353>>>>>>>>>>>>>>>>>    UShort   reserved
76353>>>>>>>>>>>>>>>>>    UInteger aiKeyAlg
76353>>>>>>>>>>>>>>>>>End_Struct
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
76353>>>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
76353>>>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
76353>>>>>>>>>>>>>>>>>    UInteger       dwKeySize
76353>>>>>>>>>>>>>>>>>//    UChar[]        rgbKeyData
76353>>>>>>>>>>>>>>>>>End_Struct
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
76353>>>>>>>>>>>>>>>>>Struct HMAC_INFO
76353>>>>>>>>>>>>>>>>>    UInteger HashAlgid
76353>>>>>>>>>>>>>>>>>    Pointer pbInnerString
76353>>>>>>>>>>>>>>>>>    DWord cbInnerString
76353>>>>>>>>>>>>>>>>>    Pointer pbOuterString
76353>>>>>>>>>>>>>>>>>    DWord cbOuterString
76353>>>>>>>>>>>>>>>>>End_Struct
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>Struct BLOBHEADER
76353>>>>>>>>>>>>>>>>>    UChar   bType
76353>>>>>>>>>>>>>>>>>    UChar   bVersion
76353>>>>>>>>>>>>>>>>>    Short   reserved
76353>>>>>>>>>>>>>>>>>    Integer aiKeyAlg
76353>>>>>>>>>>>>>>>>>End_Struct
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>Struct CryptoBlob
76353>>>>>>>>>>>>>>>>>    BLOBHEADER  header
76353>>>>>>>>>>>>>>>>>    BLOBHEADER  header
76353>>>>>>>>>>>>>>>>>    Integer     cbKeySize
76353>>>>>>>>>>>>>>>>>    UChar[32]   rgbKeyData
76353>>>>>>>>>>>>>>>>>End_Struct
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>
76353>>>>>>>>>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
76353>>>>>>>>>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
76354>>>>>>>>>>>>>>>>>
76354>>>>>>>>>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
76354>>>>>>>>>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
76356>>>>>>>>>>>>>>>>>    
76356>>>>>>>>>>>>>>>>>    Boolean bResult
76356>>>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
76356>>>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
76356>>>>>>>>>>>>>>>>>
76356>>>>>>>>>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
76357>>>>>>>>>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
76358>>>>>>>>>>>>>>>>>    
76358>>>>>>>>>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
76359>>>>>>>>>>>>>>>>>
76359>>>>>>>>>>>>>>>>>    Function_Return bResult
76360>>>>>>>>>>>>>>>>>End_Function
76361>>>>>>>>>>>>>>>>>
76361>>>>>>>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
76362>>>>>>>>>>>>>>>>>
76362>>>>>>>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
76363>>>>>>>>>>>>>>>>>
76363>>>>>>>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
76364>>>>>>>>>>>>>>>>>
76364>>>>>>>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
76365>>>>>>>>>>>>>>>>>
76365>>>>>>>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76366>>>>>>>>>>>>>>>>>
76366>>>>>>>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
76367>>>>>>>>>>>>>>>>>
76367>>>>>>>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
76368>>>>>>>>>>>>>>>>>
76368>>>>>>>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76369>>>>>>>>>>>>>>>>>
76369>>>>>>>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
76370>>>>>>>>>>>>>>>>>    
76370>>>>>>>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
76371>>>>>>>>>>>>>>>>>
76371>>>>>>>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
76372>>>>>>>>>>>>>>>>>
76372>>>>>>>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
76373>>>>>>>>>>>>>>>>>
76373>>>>>>>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
76374>>>>>>>>>>>>>>>>>    
76374>>>>>>>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
76375>>>>>>>>>>>>>>>>>    
76375>>>>>>>>>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76376>>>>>>>>>>>>>>>>>    
76376>>>>>>>>>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
76377>>>>>>>>>>>>>>>
76377>>>>>>>>>>>>>>>Class cCryptographerEx is a cObject
76378>>>>>>>>>>>>>>>    
76378>>>>>>>>>>>>>>>    Procedure Construct_Object
76380>>>>>>>>>>>>>>>        Forward Send Construct_Object
76382>>>>>>>>>>>>>>>        
76382>>>>>>>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
76383>>>>>>>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
76384>>>>>>>>>>>>>>>        Property Integer    piCipher    CALG_RC4
76385>>>>>>>>>>>>>>>        Property Integer    piHash      CALG_MD5
76386>>>>>>>>>>>>>>>        
76386>>>>>>>>>>>>>>>        // Private properties
76386>>>>>>>>>>>>>>>        Property Handle     Private_phProv
76387>>>>>>>>>>>>>>>        
76387>>>>>>>>>>>>>>>        // Block cipher properties
76387>>>>>>>>>>>>>>>        Property UChar[]    paKey
76388>>>>>>>>>>>>>>>        Property UChar[]    paIV
76389>>>>>>>>>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
76390>>>>>>>>>>>>>>>        Property Integer    piKeyType       CALG_AES_256
76391>>>>>>>>>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
76392>>>>>>>>>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
76393>>>>>>>>>>>>>>>        Property Integer    piBlockSize     16
76394>>>>>>>>>>>>>>>    End_Procedure
76395>>>>>>>>>>>>>>>    
76395>>>>>>>>>>>>>>>    
76395>>>>>>>>>>>>>>>    // Acquire key container handle
76395>>>>>>>>>>>>>>>    Function AcquireContext Returns Handle
76397>>>>>>>>>>>>>>>        Integer iProvider
76397>>>>>>>>>>>>>>>        WString wProvider
76397>>>>>>>>>>>>>>>        Handle hProv
76397>>>>>>>>>>>>>>>        Boolean bOk
76397>>>>>>>>>>>>>>>        Pointer pProv
76397>>>>>>>>>>>>>>>        
76397>>>>>>>>>>>>>>>        Move 0 to hProv
76398>>>>>>>>>>>>>>>        Get piProvider to iProvider
76399>>>>>>>>>>>>>>>        Get psProvider to wProvider
76400>>>>>>>>>>>>>>>        
76400>>>>>>>>>>>>>>>        //  Determine address to be passed as provider
76400>>>>>>>>>>>>>>>        If (Trim(wProvider) <> "") Begin
76402>>>>>>>>>>>>>>>            Move (AddressOf(wProvider)) to pProv
76403>>>>>>>>>>>>>>>        End
76403>>>>>>>>>>>>>>>>
76403>>>>>>>>>>>>>>>        Else Begin
76404>>>>>>>>>>>>>>>            Move 0 to pProv
76405>>>>>>>>>>>>>>>        End
76405>>>>>>>>>>>>>>>>
76405>>>>>>>>>>>>>>>        
76405>>>>>>>>>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
76405>>>>>>>>>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
76406>>>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
76408>>>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
76409>>>>>>>>>>>>>>>        End
76409>>>>>>>>>>>>>>>>
76409>>>>>>>>>>>>>>>        
76409>>>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
76411>>>>>>>>>>>>>>>            // Fallback to original
76411>>>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
76412>>>>>>>>>>>>>>>            
76412>>>>>>>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
76414>>>>>>>>>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
76415>>>>>>>>>>>>>>>            End
76415>>>>>>>>>>>>>>>>
76415>>>>>>>>>>>>>>>        End
76415>>>>>>>>>>>>>>>>
76415>>>>>>>>>>>>>>>        Set Private_phProv to hProv
76416>>>>>>>>>>>>>>>        
76416>>>>>>>>>>>>>>>        Function_Return hProv
76417>>>>>>>>>>>>>>>    End_Function
76418>>>>>>>>>>>>>>>    
76418>>>>>>>>>>>>>>>    // Releases key container handle
76418>>>>>>>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
76420>>>>>>>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
76421>>>>>>>>>>>>>>>    End_Function
76422>>>>>>>>>>>>>>>    
76422>>>>>>>>>>>>>>>    // Creates hash object
76422>>>>>>>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
76424>>>>>>>>>>>>>>>        Integer iAlgorithm
76424>>>>>>>>>>>>>>>        Handle hHash
76424>>>>>>>>>>>>>>>        Boolean bOk
76424>>>>>>>>>>>>>>>        
76424>>>>>>>>>>>>>>>        Move 0 to hHash
76425>>>>>>>>>>>>>>>        Get piHash to iAlgorithm
76426>>>>>>>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
76427>>>>>>>>>>>>>>>        
76427>>>>>>>>>>>>>>>        Function_Return hHash
76428>>>>>>>>>>>>>>>    End_Function
76429>>>>>>>>>>>>>>>    
76429>>>>>>>>>>>>>>>    // Destroys the hash object
76429>>>>>>>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
76431>>>>>>>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
76432>>>>>>>>>>>>>>>    End_Function
76433>>>>>>>>>>>>>>>    
76433>>>>>>>>>>>>>>>    // Adds data to hash object
76433>>>>>>>>>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
76435>>>>>>>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
76436>>>>>>>>>>>>>>>    End_Function
76437>>>>>>>>>>>>>>>    
76437>>>>>>>>>>>>>>>    // Generates session key
76437>>>>>>>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
76439>>>>>>>>>>>>>>>        Integer iAlgorithm
76439>>>>>>>>>>>>>>>        Handle hKey
76439>>>>>>>>>>>>>>>        Boolean bOk
76439>>>>>>>>>>>>>>>        
76439>>>>>>>>>>>>>>>        Move 0 to hKey
76440>>>>>>>>>>>>>>>        Get piCipher to iAlgorithm
76441>>>>>>>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
76442>>>>>>>>>>>>>>>        
76442>>>>>>>>>>>>>>>        Function_Return hKey
76443>>>>>>>>>>>>>>>    End_Function
76444>>>>>>>>>>>>>>>    
76444>>>>>>>>>>>>>>>    // Imports a plain text key
76444>>>>>>>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
76446>>>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
76446>>>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
76446>>>>>>>>>>>>>>>        Boolean   bSuccess
76446>>>>>>>>>>>>>>>        Handle    hKey
76446>>>>>>>>>>>>>>>        Integer   iHeadSize iKeySize
76446>>>>>>>>>>>>>>>        UChar[]   ucaKeyblob
76447>>>>>>>>>>>>>>>        Integer iVoid
76447>>>>>>>>>>>>>>>        
76447>>>>>>>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
76448>>>>>>>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
76449>>>>>>>>>>>>>>>        
76449>>>>>>>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
76450>>>>>>>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
76451>>>>>>>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
76452>>>>>>>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
76453>>>>>>>>>>>>>>>        
76453>>>>>>>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
76454>>>>>>>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
76455>>>>>>>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
76456>>>>>>>>>>>>>>>        
76456>>>>>>>>>>>>>>>        Move 0 to hKey
76457>>>>>>>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
76458>>>>>>>>>>>>>>>        If (not(bSuccess)) Begin
76460>>>>>>>>>>>>>>>            Move (ShowLastError()) to iVoid
76461>>>>>>>>>>>>>>>        End
76461>>>>>>>>>>>>>>>>
76461>>>>>>>>>>>>>>>        
76461>>>>>>>>>>>>>>>        Function_Return hKey
76462>>>>>>>>>>>>>>>    End_Function
76463>>>>>>>>>>>>>>>    
76463>>>>>>>>>>>>>>>    // Destroys the key
76463>>>>>>>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
76465>>>>>>>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
76466>>>>>>>>>>>>>>>    End_Function
76467>>>>>>>>>>>>>>>    
76467>>>>>>>>>>>>>>>    // Retrieves key data
76467>>>>>>>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
76469>>>>>>>>>>>>>>>        Integer iBuffer iLen
76469>>>>>>>>>>>>>>>        Boolean bOk
76469>>>>>>>>>>>>>>>        
76469>>>>>>>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
76470>>>>>>>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
76471>>>>>>>>>>>>>>>        Function_Return iBuffer
76472>>>>>>>>>>>>>>>    End_Function
76473>>>>>>>>>>>>>>>    
76473>>>>>>>>>>>>>>>    // Retrieves a hash value
76473>>>>>>>>>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
76475>>>>>>>>>>>>>>>        UChar[] ucHash
76476>>>>>>>>>>>>>>>        Integer liResult
76476>>>>>>>>>>>>>>>        DWord   dwDataLen
76476>>>>>>>>>>>>>>>        
76476>>>>>>>>>>>>>>>        Move 0 to dwDataLen
76477>>>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
76478>>>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
76481>>>>>>>>>>>>>>>        
76481>>>>>>>>>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
76482>>>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
76483>>>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
76486>>>>>>>>>>>>>>>        
76486>>>>>>>>>>>>>>>        Function_Return ucHash
76487>>>>>>>>>>>>>>>    End_Function
76488>>>>>>>>>>>>>>>
76488>>>>>>>>>>>>>>>    // Encrypts data
76488>>>>>>>>>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
76490>>>>>>>>>>>>>>>        Handle hProv hHash hKey
76490>>>>>>>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
76490>>>>>>>>>>>>>>>        Boolean bOk
76490>>>>>>>>>>>>>>>        
76490>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76491>>>>>>>>>>>>>>>        If (hProv) Begin
76493>>>>>>>>>>>>>>>            Get CreateHash hProv to hHash
76494>>>>>>>>>>>>>>>            If (hHash) Begin
76496>>>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
76497>>>>>>>>>>>>>>>                If (bOk) Begin
76499>>>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
76500>>>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
76501>>>>>>>>>>>>>>>                End
76501>>>>>>>>>>>>>>>>
76501>>>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
76502>>>>>>>>>>>>>>>            End
76502>>>>>>>>>>>>>>>>
76502>>>>>>>>>>>>>>>            
76502>>>>>>>>>>>>>>>            If (hKey) Begin
76504>>>>>>>>>>>>>>>                //  First call to determine resulting data size
76504>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
76505>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
76506>>>>>>>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
76507>>>>>>>>>>>>>>>                
76507>>>>>>>>>>>>>>>                //  Reserve space in string
76507>>>>>>>>>>>>>>>                If (iDataLen < iCipherLen) Begin
76509>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
76510>>>>>>>>>>>>>>>                End
76510>>>>>>>>>>>>>>>>
76510>>>>>>>>>>>>>>>                
76510>>>>>>>>>>>>>>>                //  Call to really decrypt
76510>>>>>>>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
76511>>>>>>>>>>>>>>>                //If (not(bOk)) Begin
76511>>>>>>>>>>>>>>>                //Move "" to sData
76511>>>>>>>>>>>>>>>                //Move (GetLastError()) to iErr
76511>>>>>>>>>>>>>>>                //End
76511>>>>>>>>>>>>>>>                
76511>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76512>>>>>>>>>>>>>>>            End 
76512>>>>>>>>>>>>>>>>
76512>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76513>>>>>>>>>>>>>>>        End 
76513>>>>>>>>>>>>>>>>
76513>>>>>>>>>>>>>>>        Function_Return ucData
76514>>>>>>>>>>>>>>>    End_Function
76515>>>>>>>>>>>>>>>    
76515>>>>>>>>>>>>>>>    // Decrypts data
76515>>>>>>>>>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
76517>>>>>>>>>>>>>>>        Handle hProv hHash hKey
76517>>>>>>>>>>>>>>>        Integer iAlgorithm iDataLen
76517>>>>>>>>>>>>>>>        Boolean bOk
76517>>>>>>>>>>>>>>>        
76517>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76518>>>>>>>>>>>>>>>        If (hProv) Begin
76520>>>>>>>>>>>>>>>            Get CreateHash hProv to hHash
76521>>>>>>>>>>>>>>>            If (hHash) Begin
76523>>>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
76524>>>>>>>>>>>>>>>                If (bOk) Begin
76526>>>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
76527>>>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
76528>>>>>>>>>>>>>>>                End
76528>>>>>>>>>>>>>>>>
76528>>>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
76529>>>>>>>>>>>>>>>            End
76529>>>>>>>>>>>>>>>>
76529>>>>>>>>>>>>>>>            
76529>>>>>>>>>>>>>>>            If (hKey) Begin
76531>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
76532>>>>>>>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
76533>>>>>>>>>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
76533>>>>>>>>>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
76535>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
76536>>>>>>>>>>>>>>>                End
76536>>>>>>>>>>>>>>>>
76536>>>>>>>>>>>>>>>                
76536>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76537>>>>>>>>>>>>>>>            End
76537>>>>>>>>>>>>>>>>
76537>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76538>>>>>>>>>>>>>>>        End
76538>>>>>>>>>>>>>>>>
76538>>>>>>>>>>>>>>>        Function_Return ucData
76539>>>>>>>>>>>>>>>    End_Function
76540>>>>>>>>>>>>>>>    
76540>>>>>>>>>>>>>>>    // Creates a key
76540>>>>>>>>>>>>>>>    Function CreateKey Handle hProv Returns Handle
76542>>>>>>>>>>>>>>>        Integer iAlg iType iByte iLength iSize
76542>>>>>>>>>>>>>>>        CryptoBlob keyBlob
76542>>>>>>>>>>>>>>>        CryptoBlob keyBlob
76542>>>>>>>>>>>>>>>        Boolean bOk
76542>>>>>>>>>>>>>>>        Handle hKey
76542>>>>>>>>>>>>>>>        UChar[] aKey
76543>>>>>>>>>>>>>>>
76543>>>>>>>>>>>>>>>        Get paKey to aKey
76544>>>>>>>>>>>>>>>        Get piKeyAlg to iAlg
76545>>>>>>>>>>>>>>>        Get piKeyType to iType
76546>>>>>>>>>>>>>>>        Move iAlg                   to keyBlob.header.bType
76547>>>>>>>>>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
76548>>>>>>>>>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
76549>>>>>>>>>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
76550>>>>>>>>>>>>>>>        
76550>>>>>>>>>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
76551>>>>>>>>>>>>>>>        For iByte from 0 to iLength
76557>>>>>>>>>>>>>>>>
76557>>>>>>>>>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
76558>>>>>>>>>>>>>>>        Loop
76559>>>>>>>>>>>>>>>>
76559>>>>>>>>>>>>>>>        
76559>>>>>>>>>>>>>>>        Move 0 to hKey
76560>>>>>>>>>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
76561>>>>>>>>>>>>>>>        Function_Return hKey
76562>>>>>>>>>>>>>>>    End_Function
76563>>>>>>>>>>>>>>>    
76563>>>>>>>>>>>>>>>    // Sets the key parameters
76563>>>>>>>>>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
76565>>>>>>>>>>>>>>>        Integer iPadding iMode
76565>>>>>>>>>>>>>>>        Boolean bOk
76565>>>>>>>>>>>>>>>        UChar[] aIV
76566>>>>>>>>>>>>>>>        
76566>>>>>>>>>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
76566>>>>>>>>>>>>>>>        //For iByte from 0 to iLength
76566>>>>>>>>>>>>>>>        //    Move iByte to aIV[iByte]
76566>>>>>>>>>>>>>>>        //Loop
76566>>>>>>>>>>>>>>>
76566>>>>>>>>>>>>>>>        // Set initialization vector
76566>>>>>>>>>>>>>>>        Get paIV to aIV
76567>>>>>>>>>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
76568>>>>>>>>>>>>>>>        If (bOk) Begin
76570>>>>>>>>>>>>>>>            // Set padding
76570>>>>>>>>>>>>>>>            Get piKeyPadding to iPadding
76571>>>>>>>>>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
76572>>>>>>>>>>>>>>>            If (bOk) Begin
76574>>>>>>>>>>>>>>>                // Set move
76574>>>>>>>>>>>>>>>                Get piKeyMode to iMode
76575>>>>>>>>>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
76576>>>>>>>>>>>>>>>            End
76576>>>>>>>>>>>>>>>>
76576>>>>>>>>>>>>>>>        End
76576>>>>>>>>>>>>>>>>
76576>>>>>>>>>>>>>>>        Function_Return bOk        
76577>>>>>>>>>>>>>>>    End_Function
76578>>>>>>>>>>>>>>>    
76578>>>>>>>>>>>>>>>    // Encrypts using block cipher
76578>>>>>>>>>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
76580>>>>>>>>>>>>>>>        Handle hProv hKey
76580>>>>>>>>>>>>>>>        Integer iLen iSize iBlocks
76580>>>>>>>>>>>>>>>        Boolean bOk
76580>>>>>>>>>>>>>>>        
76580>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76581>>>>>>>>>>>>>>>        If (hProv) Begin
76583>>>>>>>>>>>>>>>            // Create key
76583>>>>>>>>>>>>>>>            Get CreateKey hProv to hKey
76584>>>>>>>>>>>>>>>            If (hKey) Begin
76586>>>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
76587>>>>>>>>>>>>>>>                If (bOk) Begin
76589>>>>>>>>>>>>>>>                    // Buffer for block ciphers can be up to block length larger
76589>>>>>>>>>>>>>>>                    Get piBlockSize to iSize
76590>>>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76591>>>>>>>>>>>>>>>                    
76591>>>>>>>>>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
76592>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
76593>>>>>>>>>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
76594>>>>>>>>>>>>>>>                End
76594>>>>>>>>>>>>>>>>
76594>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76595>>>>>>>>>>>>>>>            End
76595>>>>>>>>>>>>>>>>
76595>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76596>>>>>>>>>>>>>>>        End
76596>>>>>>>>>>>>>>>>
76596>>>>>>>>>>>>>>>        Function_Return ucData
76597>>>>>>>>>>>>>>>    End_Function
76598>>>>>>>>>>>>>>>    
76598>>>>>>>>>>>>>>>    // Decrypts using block cipher
76598>>>>>>>>>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
76600>>>>>>>>>>>>>>>        Handle hProv hKey
76600>>>>>>>>>>>>>>>        Integer iLen
76600>>>>>>>>>>>>>>>        Boolean bOk
76600>>>>>>>>>>>>>>>        
76600>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76601>>>>>>>>>>>>>>>        If (hProv) Begin
76603>>>>>>>>>>>>>>>            // Create key
76603>>>>>>>>>>>>>>>            Get CreateKey hProv to hKey
76604>>>>>>>>>>>>>>>            If (hKey) Begin
76606>>>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
76607>>>>>>>>>>>>>>>                If (bOk) Begin
76609>>>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76610>>>>>>>>>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
76611>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
76612>>>>>>>>>>>>>>>                End
76612>>>>>>>>>>>>>>>>
76612>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76613>>>>>>>>>>>>>>>            End
76613>>>>>>>>>>>>>>>>
76613>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76614>>>>>>>>>>>>>>>        End
76614>>>>>>>>>>>>>>>>
76614>>>>>>>>>>>>>>>        Function_Return ucData
76615>>>>>>>>>>>>>>>    End_Function
76616>>>>>>>>>>>>>>>    
76616>>>>>>>>>>>>>>>    
76616>>>>>>>>>>>>>>>    //  Generates random data.
76616>>>>>>>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
76618>>>>>>>>>>>>>>>        Handle hProv
76618>>>>>>>>>>>>>>>        UChar[] uaResult
76619>>>>>>>>>>>>>>>        Boolean bRes
76619>>>>>>>>>>>>>>>        
76619>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76620>>>>>>>>>>>>>>>        
76620>>>>>>>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
76621>>>>>>>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
76622>>>>>>>>>>>>>>>        
76622>>>>>>>>>>>>>>>        Get ReleaseContext hProv to bRes
76623>>>>>>>>>>>>>>>        
76623>>>>>>>>>>>>>>>        Function_Return uaResult
76624>>>>>>>>>>>>>>>    End_Function
76625>>>>>>>>>>>>>>>    
76625>>>>>>>>>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
76625>>>>>>>>>>>>>>>    Function GenerateRandomString Integer iLength Returns String
76627>>>>>>>>>>>>>>>        String sResult
76627>>>>>>>>>>>>>>>        UChar[] ucData
76628>>>>>>>>>>>>>>>        Pointer pBase64
76628>>>>>>>>>>>>>>>        Integer iVoid
76628>>>>>>>>>>>>>>>        
76628>>>>>>>>>>>>>>>        Get GenerateRandom iLength to ucData
76629>>>>>>>>>>>>>>>        
76629>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
76630>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76631>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76632>>>>>>>>>>>>>>>        
76632>>>>>>>>>>>>>>>        Function_Return (Left(sResult, iLength))
76633>>>>>>>>>>>>>>>    End_Function
76634>>>>>>>>>>>>>>>    
76634>>>>>>>>>>>>>>>End_Class
76635>>>>>>>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Base64Functions.pkg)
76635>>>>>>>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
76635>>>>>>>>>>>>>>>//>
76635>>>>>>>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
76635>>>>>>>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
76635>>>>>>>>>>>>>>>//>
76635>>>>>>>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
76635>>>>>>>>>>>>>>>//> strings.
76635>>>>>>>>>>>>>>>//>
76635>>>>>>>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
76635>>>>>>>>>>>>>>>//> Base64Decode) that are built into the runtime.
76635>>>>>>>>>>>>>>>//>
76635>>>>>>>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
76635>>>>>>>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
76635>>>>>>>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
76635>>>>>>>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
76635>>>>>>>>>>>>>>>
76635>>>>>>>>>>>>>>>Use VdfBase.pkg
76635>>>>>>>>>>>>>>>
76635>>>>>>>>>>>>>>>// Functions in vdfBase64.dll
76635>>>>>>>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
76636>>>>>>>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
76637>>>>>>>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
76638>>>>>>>>>>>>>>>
76638>>>>>>>>>>>>>>>// Structure
76638>>>>>>>>>>>>>>>Struct txxfBase64Buffer
76638>>>>>>>>>>>>>>>    Pointer pData
76638>>>>>>>>>>>>>>>    Integer iLength
76638>>>>>>>>>>>>>>>End_Struct 
76638>>>>>>>>>>>>>>>
76638>>>>>>>>>>>>>>>Global_Variable Integer oBase64Functions
76638>>>>>>>>>>>>>>>
76638>>>>>>>>>>>>>>>Object _oBase64Functions is a cObject
76640>>>>>>>>>>>>>>>    Move Self to oBase64Functions
76641>>>>>>>>>>>>>>>
76641>>>>>>>>>>>>>>>
76641>>>>>>>>>>>>>>>    Function EncodeString String sValue Returns String
76644>>>>>>>>>>>>>>>        Address pBase64
76644>>>>>>>>>>>>>>>        String sResult
76644>>>>>>>>>>>>>>>        Integer iVoid
76644>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
76645>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76646>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76647>>>>>>>>>>>>>>>        Function_Return sResult
76648>>>>>>>>>>>>>>>    End_Function
76649>>>>>>>>>>>>>>>
76649>>>>>>>>>>>>>>>    Function DecodeString String sValue Returns String
76652>>>>>>>>>>>>>>>        Address pBinary
76652>>>>>>>>>>>>>>>        String sBinary
76652>>>>>>>>>>>>>>>        Integer iVoid iLen
76652>>>>>>>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
76653>>>>>>>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
76654>>>>>>>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
76655>>>>>>>>>>>>>>>        Move (Free(pBinary)) to iVoid
76656>>>>>>>>>>>>>>>        Function_Return sBinary
76657>>>>>>>>>>>>>>>    End_Function
76658>>>>>>>>>>>>>>>
76658>>>>>>>>>>>>>>>End_Object
76659>>>>>>>>>>>>>Use MSSqldrv.pkg
76659>>>>>>>>>>>>>Use db2_drv.pkg
76659>>>>>>>>>>>>>Use odbc_drv.pkg
76659>>>>>>>>>>>>>Use DFBtrDrv.pkg
76659>>>>>>>>>>>>>Use vWin32fh.pkg
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>Use DUFLanguageConstants.inc
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>// Create a new PSQL identifier for the Btrieve driver.
76659>>>>>>>>>>>>>    Define PSQLDRV_ID for "DFBTRDRV"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
76659>>>>>>>>>>>>>// They can have slightly different SQL keywords.
76659>>>>>>>>>>>>>// Note: If a new type is added to the list,
76659>>>>>>>>>>>>>//       the struct array xxx must be adjusted
76659>>>>>>>>>>>>>//       so that it is filled with all SQL
76659>>>>>>>>>>>>>//       keywords for that new type.
76659>>>>>>>>>>>>>Enum_List  
76659>>>>>>>>>>>>>        Define EN_DbTypeDataFlex   for 0
76659>>>>>>>>>>>>>        Define EN_DbTypeMSSQL      for 1
76659>>>>>>>>>>>>>        Define EN_DbTypeMySQL      for 2
76659>>>>>>>>>>>>>        Define EN_DbTypeOracle     for 3
76659>>>>>>>>>>>>>        Define EN_DbTypeDB2        for 4
76659>>>>>>>>>>>>>        Define EN_DbTypePostgre    for 5
76659>>>>>>>>>>>>>        Define EN_DbTypePervasive  for 6
76659>>>>>>>>>>>>>End_Enum_List
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
76659>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
76659>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
76659>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
76659>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
76659>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
76659>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
76659>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
76659>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
76659>>>>>>>>>>>>>Define CS_DbTypePervasive   for "Pervasive.SQL (Btrieve)"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>// SQLConnection.ini constants:
76659>>>>>>>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
76659>>>>>>>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
76659>>>>>>>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
76659>>>>>>>>>>>>>Define CS_SQLIniSectionName             for "Connection"
76659>>>>>>>>>>>>>Define CS_SQLODBCIniSectionName         for "ODBC"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>// DF 19 ini-file settings:
76659>>>>>>>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
76659>>>>>>>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
76659>>>>>>>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
76659>>>>>>>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
76659>>>>>>>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
76659>>>>>>>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
76659>>>>>>>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
76659>>>>>>>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
76659>>>>>>>>>>>>>Define CS_SQLIniFileDSNKeyword          for "FILEDSN"
76659>>>>>>>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
76659>>>>>>>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection" 
76659>>>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>// Database Update Framework extended settings:
76659>>>>>>>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
76659>>>>>>>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
76659>>>>>>>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
76659>>>>>>>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
76659>>>>>>>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
76659>>>>>>>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
76659>>>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
76659>>>>>>>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
76659>>>>>>>>>>>>>Define CS_SQLIniConnectionNo            for "No"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>Struct tSQLConnection
76659>>>>>>>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
76659>>>>>>>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
76659>>>>>>>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
76659>>>>>>>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. MSSQLDRV, DB2_DRV, ODBC_DRV or PSQLDRV_ID.
76659>>>>>>>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
76659>>>>>>>>>>>>>    String sDatabase                // 6. SQL Database
76659>>>>>>>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
76659>>>>>>>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
76659>>>>>>>>>>>>>    String sUserID                  // 9. User ID
76659>>>>>>>>>>>>>    String sPassword                // 10. Password
76659>>>>>>>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
76659>>>>>>>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
76659>>>>>>>>>>>>>    String sLongTableSpace          // 13. DB2 specific
76659>>>>>>>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
76659>>>>>>>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
76659>>>>>>>>>>>>>    Boolean bError                  // 16. Set to true on error.
76659>>>>>>>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
76659>>>>>>>>>>>>>End_Struct
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>Struct tFilelist
76659>>>>>>>>>>>>>    String sRootName
76659>>>>>>>>>>>>>    String sLogicalName
76659>>>>>>>>>>>>>    String sDisplayName    
76659>>>>>>>>>>>>>    String sNoDriverRootname
76659>>>>>>>>>>>>>    String sDriver
76659>>>>>>>>>>>>>    Handle hTable
76659>>>>>>>>>>>>>    Boolean bIsSystemFile 
76659>>>>>>>>>>>>>    Boolean bErrorOpening
76659>>>>>>>>>>>>>    Boolean bIsAlias
76659>>>>>>>>>>>>>End_Struct
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>Struct tFilelistLogicalName
76659>>>>>>>>>>>>>    String sLogicalName
76659>>>>>>>>>>>>>    String sNoDriverRootname
76659>>>>>>>>>>>>>    String sRootName
76659>>>>>>>>>>>>>    String sDisplayName    
76659>>>>>>>>>>>>>    String sDriver
76659>>>>>>>>>>>>>    Handle hTable
76659>>>>>>>>>>>>>    Boolean bIsSystemFile 
76659>>>>>>>>>>>>>    Boolean bErrorOpening
76659>>>>>>>>>>>>>    Boolean bIsAlias
76659>>>>>>>>>>>>>End_Struct
76659>>>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
76659>>>>>>>>>>>>>Use DUFLanguageConstants.inc
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
76659>>>>>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_OEM_Txt for "OEM"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_SERVER for "SERVER"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
76659>>>>>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Define CS_DUFBackupDataFolder for "BackupData"
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
76659>>>>>>>>>>>>>
76659>>>>>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary  
76659>>>>>>>>>>>>>    Move 0 to ghoDbUpdateFunctionLibrary
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tSQLScriptArray
76660>>>>>>>>>>>>>    Boolean bError
76660>>>>>>>>>>>>>    Boolean bArgumentSizeChanged
76660>>>>>>>>>>>>>    Integer iOrgArgumentSize
76660>>>>>>>>>>>>>    String[] sSQLScriptArray
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tSqlErrorArray
76660>>>>>>>>>>>>>    String[]  sSqlErrorArray
76660>>>>>>>>>>>>>    String[]  sSqlStatementArray
76660>>>>>>>>>>>>>    Integer[] iSqlErrorArray
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tSqlColumnNew
76660>>>>>>>>>>>>>    String  sBaseColumnName
76660>>>>>>>>>>>>>    String  sBaseTableName
76660>>>>>>>>>>>>>    String  sLabel
76660>>>>>>>>>>>>>    Integer iSqlType
76660>>>>>>>>>>>>>    Integer iSize
76660>>>>>>>>>>>>>    Integer iPrecision
76660>>>>>>>>>>>>>    Integer iDFType
76660>>>>>>>>>>>>>    Integer iDFNativeType
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tColumnType
76660>>>>>>>>>>>>>    Integer iSQLType
76660>>>>>>>>>>>>>    String  sSQLType
76660>>>>>>>>>>>>>    Boolean bCanEditSize
76660>>>>>>>>>>>>>    Integer iDefaultSize
76660>>>>>>>>>>>>>    Integer iMinSize
76660>>>>>>>>>>>>>    Number  nMaxSize
76660>>>>>>>>>>>>>    String  sDataFlexType
76660>>>>>>>>>>>>>    Integer iDataFlexType
76660>>>>>>>>>>>>>    Boolean bNativeDataType
76660>>>>>>>>>>>>>    String  sPrecision
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
76660>>>>>>>>>>>>>// Various SQL back-ends can have slightly different
76660>>>>>>>>>>>>>// keywords.
76660>>>>>>>>>>>>>Struct tSQLKeyWords
76660>>>>>>>>>>>>>    Integer iSQLWord
76660>>>>>>>>>>>>>    Integer iSQLDbType
76660>>>>>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tSQLRelation
76660>>>>>>>>>>>>>    Integer iFileNumber
76660>>>>>>>>>>>>>    Integer iFieldNumber
76660>>>>>>>>>>>>>    String  sFileName
76660>>>>>>>>>>>>>    String  sFieldName
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tSQLLoggedInUser
76660>>>>>>>>>>>>>    String sUser
76660>>>>>>>>>>>>>    String sProgram
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
76660>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
76660>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
76660>>>>>>>>>>>>>// They can have slightly different SQL keywords.
76660>>>>>>>>>>>>>// Note: If a new type is added to the list,
76660>>>>>>>>>>>>>//       the struct array xxx must be adjusted
76660>>>>>>>>>>>>>//       so that it is filled with all SQL
76660>>>>>>>>>>>>>//       keywords for that new type.
76660>>>>>>>>>>>>>Enum_List
76660>>>>>>>>>>>>>//    Define EN_DbTypeMSSQL
76660>>>>>>>>>>>>>//    Define EN_DbTypeMySQL
76660>>>>>>>>>>>>>//    Define EN_DbTypeOracle
76660>>>>>>>>>>>>>//    Define EN_DbTypeDB2
76660>>>>>>>>>>>>>//    Define EN_DbTypePostgre
76660>>>>>>>>>>>>>//    Define EN_DbTypeDataFlex // Embedded database.
76660>>>>>>>>>>>>>End_Enum_List
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
76660>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
76660>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
76660>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
76660>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
76660>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
76660>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
76660>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
76660>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
76660>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
76660>>>>>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
76660>>>>>>>>>>>>>Enum_List
76660>>>>>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
76660>>>>>>>>>>>>>    Define DF_BCD_DUF       for -1499
76660>>>>>>>>>>>>>    Define DF_DATE_DUF      for -1498
76660>>>>>>>>>>>>>    Define DF_TEXT_DUF      for -1495
76660>>>>>>>>>>>>>    Define DF_BINARY_DUF    for -1494
76660>>>>>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
76660>>>>>>>>>>>>>End_Enum_List
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
76660>>>>>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
76660>>>>>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>// These are not defined pre DF 18:
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tSQLIntTableInfo
76660>>>>>>>>>>>>>    String sDriverName
76660>>>>>>>>>>>>>    String sServerName
76660>>>>>>>>>>>>>    String sDatabaseName
76660>>>>>>>>>>>>>    String sSchemaName
76660>>>>>>>>>>>>>    Boolean bRecnumTable
76660>>>>>>>>>>>>>    Integer iPrimaryIndex
76660>>>>>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
76660>>>>>>>>>>>>>    String sTableCharacterFormat
76660>>>>>>>>>>>>>    Boolean bUseDummyZeroDate
76660>>>>>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
76660>>>>>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
76660>>>>>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
76660>>>>>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
76660>>>>>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
76660>>>>>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
76660>>>>>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
76660>>>>>>>>>>>>>    String sFileIndexTablespace
76660>>>>>>>>>>>>>    String sFileLongTablespace
76660>>>>>>>>>>>>>    String sTableTablespace
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tSQLIntColumnInfo
76660>>>>>>>>>>>>>    Integer iFieldNumber
76660>>>>>>>>>>>>>    Integer iFieldIndex
76660>>>>>>>>>>>>>    Integer iFieldRelatedFile
76660>>>>>>>>>>>>>    Integer iFieldRelatedField
76660>>>>>>>>>>>>>    Integer iIndexNumber
76660>>>>>>>>>>>>>    Integer iIndexNumberSegments
76660>>>>>>>>>>>>>    Integer iIndexSegmentField1
76660>>>>>>>>>>>>>    Integer iIndexSegmentField2
76660>>>>>>>>>>>>>    Integer iIndexSegmentFieldn
76660>>>>>>>>>>>>>    String  sIndexName
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tAPIColumn
76660>>>>>>>>>>>>>    Integer iFieldNumber
76660>>>>>>>>>>>>>    String  sFieldName
76660>>>>>>>>>>>>>    Integer iType
76660>>>>>>>>>>>>>    String  sType
76660>>>>>>>>>>>>>    Integer iLength
76660>>>>>>>>>>>>>    Integer iPrecision
76660>>>>>>>>>>>>>    Integer iOptions
76660>>>>>>>>>>>>>    Boolean bIsSQLType
76660>>>>>>>>>>>>>    Boolean bAllowNULL
76660>>>>>>>>>>>>>    String  sDefaultValue
76660>>>>>>>>>>>>>    Boolean bShouldChange
76660>>>>>>>>>>>>>    Boolean bCancel
76660>>>>>>>>>>>>>    Boolean bError
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tAPIColumnCompare
76660>>>>>>>>>>>>>    Integer iFieldNumber
76660>>>>>>>>>>>>>    // FROM database:
76660>>>>>>>>>>>>>    Boolean bExistsFrom
76660>>>>>>>>>>>>>    String  sFieldNameFrom
76660>>>>>>>>>>>>>    Integer iTypeFrom
76660>>>>>>>>>>>>>    String  sTypeFrom
76660>>>>>>>>>>>>>    Integer iLengthFrom
76660>>>>>>>>>>>>>    Integer iPrecisionFrom
76660>>>>>>>>>>>>>    Integer iOptionsFrom
76660>>>>>>>>>>>>>    Boolean bIsSQLTypeFrom
76660>>>>>>>>>>>>>    Boolean bAllowNULLFrom
76660>>>>>>>>>>>>>    String  sDefaultValueFrom
76660>>>>>>>>>>>>>    Boolean bShouldChangeFrom
76660>>>>>>>>>>>>>    Boolean bCancelFrom
76660>>>>>>>>>>>>>    Boolean bErrorFrom
76660>>>>>>>>>>>>>    // TO database:
76660>>>>>>>>>>>>>    Boolean bExistsTo
76660>>>>>>>>>>>>>    Integer iFieldNumberTo
76660>>>>>>>>>>>>>    String  sFieldNameTo
76660>>>>>>>>>>>>>    Integer iTypeTo
76660>>>>>>>>>>>>>    String  sTypeTo
76660>>>>>>>>>>>>>    Integer iLengthTo
76660>>>>>>>>>>>>>    Integer iPrecisionTo
76660>>>>>>>>>>>>>    Integer iOptionsTo
76660>>>>>>>>>>>>>    Boolean bIsSQLTypeTo
76660>>>>>>>>>>>>>    Boolean bAllowNULLTo
76660>>>>>>>>>>>>>    String  sDefaultValueTo
76660>>>>>>>>>>>>>    Boolean bShouldChangeTo
76660>>>>>>>>>>>>>    Boolean bCancelTo
76660>>>>>>>>>>>>>    Boolean bErrorTo
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tAPIRelation
76660>>>>>>>>>>>>>    Handle  hTableFrom
76660>>>>>>>>>>>>>    Integer iColumnFrom
76660>>>>>>>>>>>>>    Handle  hTableTo
76660>>>>>>>>>>>>>    Integer iColumnTo
76660>>>>>>>>>>>>>    String  sLogicalNameFrom
76660>>>>>>>>>>>>>    String  sLogicalNameTo
76660>>>>>>>>>>>>>    String  sFieldNameFrom
76660>>>>>>>>>>>>>    String  sFieldNameTo
76660>>>>>>>>>>>>>    Boolean bShouldChange
76660>>>>>>>>>>>>>    Boolean bCancel
76660>>>>>>>>>>>>>    Boolean bError
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tAPIRelationCompare
76660>>>>>>>>>>>>>    // Common:
76660>>>>>>>>>>>>>    Handle  hTableFrom
76660>>>>>>>>>>>>>    Integer iColumnFrom
76660>>>>>>>>>>>>>    Handle  hTableTo
76660>>>>>>>>>>>>>    Integer iColumnTo
76660>>>>>>>>>>>>>    // FROM database:
76660>>>>>>>>>>>>>    Boolean bExistsFrom
76660>>>>>>>>>>>>>    String  sLogicalNameFrom_From
76660>>>>>>>>>>>>>    String  sLogicalNameTo_From
76660>>>>>>>>>>>>>    String  sFieldNameFrom_From
76660>>>>>>>>>>>>>    String  sFieldNameTo_From
76660>>>>>>>>>>>>>    Boolean bShouldChange_From
76660>>>>>>>>>>>>>    Boolean bCancel_From
76660>>>>>>>>>>>>>    Boolean bError_From
76660>>>>>>>>>>>>>    // TO database:
76660>>>>>>>>>>>>>    Boolean bExistsTo
76660>>>>>>>>>>>>>    String  sLogicalNameFrom_To
76660>>>>>>>>>>>>>    String  sLogicalNameTo_To
76660>>>>>>>>>>>>>    String  sFieldNameFrom_To
76660>>>>>>>>>>>>>    String  sFieldNameTo_To
76660>>>>>>>>>>>>>    Boolean bShouldChange_To
76660>>>>>>>>>>>>>    Boolean bCancel_To
76660>>>>>>>>>>>>>    Boolean bError_To
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tAPIIndexSegment
76660>>>>>>>>>>>>>    Integer iFieldNumber
76660>>>>>>>>>>>>>    String  sFieldName
76660>>>>>>>>>>>>>    Boolean bUppercase
76660>>>>>>>>>>>>>    Boolean bAscending
76660>>>>>>>>>>>>>    Boolean bShouldChange
76660>>>>>>>>>>>>>    Boolean bCancel
76660>>>>>>>>>>>>>    Boolean bError
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tAPIIndex
76660>>>>>>>>>>>>>    Integer iIndexNumber
76660>>>>>>>>>>>>>    Integer iPrimaryIndex
76660>>>>>>>>>>>>>    String  sSQLIndexName
76660>>>>>>>>>>>>>    Integer iSQLIndexType
76660>>>>>>>>>>>>>    Boolean bIsSQLClustered
76660>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKey
76660>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
76660>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
76660>>>>>>>>>>>>>    Boolean bShouldChange
76660>>>>>>>>>>>>>    Boolean bCancel
76660>>>>>>>>>>>>>    Boolean bError
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tAPIIndexCompare
76660>>>>>>>>>>>>>    // Common:
76660>>>>>>>>>>>>>    Integer iIndexNumber
76660>>>>>>>>>>>>>    // FROM database:
76660>>>>>>>>>>>>>    Boolean bExistsFrom
76660>>>>>>>>>>>>>    Integer iPrimaryIndexFrom
76660>>>>>>>>>>>>>    String  sSQLIndexNameFrom
76660>>>>>>>>>>>>>    Integer iSQLIndexTypeFrom
76660>>>>>>>>>>>>>    Boolean bIsSQLClusteredFrom
76660>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
76660>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
76660>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
76660>>>>>>>>>>>>>    Boolean bShouldChangeFrom
76660>>>>>>>>>>>>>    Boolean bCancelFrom
76660>>>>>>>>>>>>>    Boolean bErrorFrom
76660>>>>>>>>>>>>>    // TO database:
76660>>>>>>>>>>>>>    Boolean bExistsTo
76660>>>>>>>>>>>>>    Integer iPrimaryIndexTo
76660>>>>>>>>>>>>>    String  sSQLIndexNameTo
76660>>>>>>>>>>>>>    Integer iSQLIndexTypeTo
76660>>>>>>>>>>>>>    Boolean bIsSQLClusteredTo
76660>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
76660>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
76660>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
76660>>>>>>>>>>>>>    Boolean bShouldChangeTo
76660>>>>>>>>>>>>>    Boolean bCancelTo
76660>>>>>>>>>>>>>    Boolean bErrorTo
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tAPITableNameInfo
76660>>>>>>>>>>>>>    Integer iTableNumber
76660>>>>>>>>>>>>>    String  sRootName
76660>>>>>>>>>>>>>    String  sLogicalName
76660>>>>>>>>>>>>>    String  sDisplayName
76660>>>>>>>>>>>>>    String  sDriverID
76660>>>>>>>>>>>>>    Boolean bIsAlias
76660>>>>>>>>>>>>>    Boolean bIsSQL
76660>>>>>>>>>>>>>    Boolean bIsSystemFile
76660>>>>>>>>>>>>>    Boolean bShouldChange
76660>>>>>>>>>>>>>    Boolean bCancel
76660>>>>>>>>>>>>>    Boolean bError
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tAPITableNameInfoCompare
76660>>>>>>>>>>>>>    Integer iTableNumber
76660>>>>>>>>>>>>>    // FROM
76660>>>>>>>>>>>>>    Boolean bExistsFrom
76660>>>>>>>>>>>>>    String  sRootNameFrom
76660>>>>>>>>>>>>>    String  sLogicalNameFrom
76660>>>>>>>>>>>>>    String  sDisplayNameFrom
76660>>>>>>>>>>>>>    String  sDriverIDFrom
76660>>>>>>>>>>>>>    Boolean bIsAliasFrom
76660>>>>>>>>>>>>>    Boolean bIsSQLFrom
76660>>>>>>>>>>>>>    Boolean bIsSystemFileFrom
76660>>>>>>>>>>>>>    // TO database:
76660>>>>>>>>>>>>>    Boolean bExistsTo
76660>>>>>>>>>>>>>    String  sRootNameTo
76660>>>>>>>>>>>>>    String  sLogicalNameTo
76660>>>>>>>>>>>>>    String  sDisplayNameTo
76660>>>>>>>>>>>>>    String  sDriverIDTo
76660>>>>>>>>>>>>>    Boolean bIsAliasTo
76660>>>>>>>>>>>>>    Boolean bIsSQLTo
76660>>>>>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
76660>>>>>>>>>>>>>    Boolean bShouldChange
76660>>>>>>>>>>>>>    Boolean bCancel
76660>>>>>>>>>>>>>    Boolean bError
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tAPITable
76660>>>>>>>>>>>>>    Handle hTable
76660>>>>>>>>>>>>>    Boolean bFromTable
76660>>>>>>>>>>>>>    Boolean bToTable
76660>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
76660>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
76660>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
76660>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
76660>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
76660>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
76660>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
76660>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
76660>>>>>>>>>>>>>    Boolean bShouldChange
76660>>>>>>>>>>>>>    Boolean bCancel
76660>>>>>>>>>>>>>    Boolean bError
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tAPITableCompare
76660>>>>>>>>>>>>>    Handle hTable
76660>>>>>>>>>>>>>    // FROM database:
76660>>>>>>>>>>>>>    Boolean bExistsFrom
76660>>>>>>>>>>>>>    // TO database:
76660>>>>>>>>>>>>>    Boolean bExistsTo
76660>>>>>>>>>>>>>    // Both:
76660>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
76660>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
76660>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
76660>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
76660>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
76660>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
76660>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
76660>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
76660>>>>>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
76660>>>>>>>>>>>>>    Boolean bCancel         // User cancel
76660>>>>>>>>>>>>>    Boolean bError          // Error occured while collecting data
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Struct tAPITableBooleans
76660>>>>>>>>>>>>>    Boolean bApiTableUpdateAuto
76660>>>>>>>>>>>>>    Boolean bCompareDate_DateTime
76660>>>>>>>>>>>>>    Boolean bCompareIndexAscending
76660>>>>>>>>>>>>>    Boolean bCompareIndexUppercase
76660>>>>>>>>>>>>>    Boolean bCompareFilelistUppercase
76660>>>>>>>>>>>>>End_Struct
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>Define C_tAPIColumn_None for 0
76660>>>>>>>>>>>>>Define C_tAPIColumn_Identity for 1
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>// SQL Key-Word Constants:  CI_SQLSelect CI_SQLName CI_SQLFrom  CI_SQLSys
76660>>>>>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
76660>>>>>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
76660>>>>>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
76660>>>>>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
76660>>>>>>>>>>>>>Enum_List
76660>>>>>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"
76660>>>>>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
76660>>>>>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
76660>>>>>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
76660>>>>>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
76660>>>>>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
76660>>>>>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
76660>>>>>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
76660>>>>>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
76660>>>>>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
76660>>>>>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
76660>>>>>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
76660>>>>>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
76660>>>>>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
76660>>>>>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
76660>>>>>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
76660>>>>>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
76660>>>>>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
76660>>>>>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
76660>>>>>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
76660>>>>>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
76660>>>>>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
76660>>>>>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
76660>>>>>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
76660>>>>>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
76660>>>>>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
76660>>>>>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
76660>>>>>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
76660>>>>>>>>>>>>>    Define CI_SQLTo                    //for "TO"
76660>>>>>>>>>>>>>    Define CI_SQLGO                    //for "GO"
76660>>>>>>>>>>>>>    Define CI_SQLUse                   //for "USE"
76660>>>>>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>    Define CI_SQLName                  //for "NAME"
76660>>>>>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
76660>>>>>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
76660>>>>>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
76660>>>>>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
76660>>>>>>>>>>>>>    Define CI_SQLID                    //for "ID"
76660>>>>>>>>>>>>>    Define CI_SQLAND                   //for "AND"
76660>>>>>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
76660>>>>>>>>>>>>>    Define CI_SQLSet                   //for "SET"
76660>>>>>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
76660>>>>>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
76660>>>>>>>>>>>>>    Define CI_SQL_SAFE_UPDATES         //for "SQL_SAFE_UPDATES"  
76660>>>>>>>>>>>>>    Define CI_SQLDescription          //for "SELECT name, description from sys.fn_helpcollations()" (Enumerates all collates)
76660>>>>>>>>>>>>>End_Enum_List
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>>>
76660>>>>>>>>>>>
76660>>>>>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
76661>>>>>>>>>>>
76661>>>>>>>>>>>    Procedure CreateDbUpdateLibraryProperties
76663>>>>>>>>>>>        Handle hoSQLManagerMT
76663>>>>>>>>>>>
76663>>>>>>>>>>>        Property String private.psUseDatabase ""
76664>>>>>>>>>>>
76664>>>>>>>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
76664>>>>>>>>>>>        Property Handle  private.phCurrentTable 0
76665>>>>>>>>>>>        Property Integer private.piCurrentField 0
76666>>>>>>>>>>>
76666>>>>>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
76667>>>>>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
76668>>>>>>>>>>>
76668>>>>>>>>>>>        Property Handle phoSQLManagerMT
76669>>>>>>>>>>>
76669>>>>>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
76670>>>>>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
76671>>>>>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
76672>>>>>>>>>>>        Property Handle phoSQLConnectionHandler 0
76673>>>>>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
76674>>>>>>>>>>>
76674>>>>>>>>>>>        Property Boolean pbHandleQueryErrors True
76675>>>>>>>>>>>
76675>>>>>>>>>>>        Property tSqlColumnNew[] paQueryColumns
76676>>>>>>>>>>>        Property String[] paSQLFetchResults
76677>>>>>>>>>>>
76677>>>>>>>>>>>        // Error handling
76677>>>>>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
76678>>>>>>>>>>>        Property Boolean pbSqlError False
76679>>>>>>>>>>>        Property tSqlErrorArray paSqlErrorArray
76680>>>>>>>>>>>        Property Boolean pbProcessingError False
76681>>>>>>>>>>>
76681>>>>>>>>>>>        // Statistics on query
76681>>>>>>>>>>>        Property TimeSpan ptsTotalQueryTime
76682>>>>>>>>>>>        Property TimeSpan ptsQueryExec
76683>>>>>>>>>>>        Property TimeSpan ptsFetchResults
76684>>>>>>>>>>>        Property Integer piColumns 0
76685>>>>>>>>>>>        Property Integer piRows 0
76686>>>>>>>>>>>        Property Integer piRowType 0
76687>>>>>>>>>>>        Property String[] paQueryMessages
76688>>>>>>>>>>>        Property String psSQLStatementString
76689>>>>>>>>>>>
76689>>>>>>>>>>>        Property Integer[] paTableConvertExceptions
76690>>>>>>>>>>>
76690>>>>>>>>>>>        Property Integer[] paTableDateCorrectionExceptions
76691>>>>>>>>>>>
76691>>>>>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
76691>>>>>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
76691>>>>>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
76691>>>>>>>>>>>        Property Integer piChunkMax 500
76692>>>>>>>>>>>
76692>>>>>>>>>>>        // Fill the paSQLKeywordArray array with values;
76692>>>>>>>>>>>        Send SetupSQLKeywordArray
76693>>>>>>>>>>>    End_Procedure
76694>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
76694>>>>>>>>>>>>
76694>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
76696>>>>>>>>>>>>    Integer iStart iEnd
76696>>>>>>>>>>>>    String sRetval
76696>>>>>>>>>>>>
76696>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
76697>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
76698>>>>>>>>>>>>    If (iStart = 0) Begin
76700>>>>>>>>>>>>        Function_Return ""
76701>>>>>>>>>>>>    End
76701>>>>>>>>>>>>>
76701>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
76702>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
76703>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
76705>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
76706>>>>>>>>>>>>    End
76706>>>>>>>>>>>>>
76706>>>>>>>>>>>>    Else Begin
76707>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
76708>>>>>>>>>>>>    End
76708>>>>>>>>>>>>>
76708>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
76710>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
76711>>>>>>>>>>>>        Decrement iEnd
76712>>>>>>>>>>>>    End
76712>>>>>>>>>>>>>
76712>>>>>>>>>>>>    If (iEnd <> 0) Begin
76714>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
76715>>>>>>>>>>>>    End
76715>>>>>>>>>>>>>
76715>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
76716>>>>>>>>>>>>
76716>>>>>>>>>>>>    Function_Return (Trim(sRetval))
76717>>>>>>>>>>>>End_Function
76718>>>>>>>>>>>>
76718>>>>>>>>>>>>
76718>>>>>>>>>>>
76718>>>>>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
76718>>>>>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
76720>>>>>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
76722>>>>>>>>>>>            Function_Return (EQ)
76723>>>>>>>>>>>        End
76723>>>>>>>>>>>>
76723>>>>>>>>>>>        Function_Return (GT)
76724>>>>>>>>>>>    End_Function
76725>>>>>>>>>>>
76725>>>>>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
76725>>>>>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
76727>>>>>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
76730>>>>>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
76733>>>>>>>>>>>
76733>>>>>>>>>>>        Function_Return (EQ)
76734>>>>>>>>>>>    End_Function
76735>>>>>>>>>>>
76735>>>>>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
76737>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
76737>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
76738>>>>>>>>>>>        Integer iSize
76738>>>>>>>>>>>
76738>>>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
76739>>>>>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
76740>>>>>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
76741>>>>>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
76742>>>>>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
76743>>>>>>>>>>>
76743>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
76744>>>>>>>>>>>    End_Procedure
76745>>>>>>>>>>>
76745>>>>>>>>>>>    // Creates a struct array with all SQL keywords
76745>>>>>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
76745>>>>>>>>>>>    // have slightly different wording.
76745>>>>>>>>>>>    // If a new EN_dbTypexxx type is added; additions
76745>>>>>>>>>>>    // needs to be done for every keyword group below.
76745>>>>>>>>>>>    Procedure SetupSQLKeywordArray
76747>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
76747>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
76749>>>>>>>>>>>
76749>>>>>>>>>>>        // This should only be called once; but in case it is
76749>>>>>>>>>>>        // we delete the array first.
76749>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
76750>>>>>>>>>>>
76750>>>>>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
76750>>>>>>>>>>>        //
76750>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
76751>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
76752>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
76753>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
76754>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"
76755>>>>>>>>>>>
76755>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
76756>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
76757>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
76758>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
76759>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"
76760>>>>>>>>>>>
76760>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
76761>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
76762>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
76763>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
76764>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"
76765>>>>>>>>>>>
76765>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
76766>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
76767>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
76768>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
76769>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"
76770>>>>>>>>>>>
76770>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
76771>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
76772>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
76773>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
76774>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"
76775>>>>>>>>>>>
76775>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
76776>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
76777>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
76778>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
76779>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
76780>>>>>>>>>>>
76780>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
76781>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
76782>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
76783>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
76784>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
76785>>>>>>>>>>>
76785>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
76786>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
76787>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
76788>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
76789>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
76790>>>>>>>>>>>
76790>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
76791>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
76792>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
76793>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
76794>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
76795>>>>>>>>>>>
76795>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_DbTypeMSSQL   ""
76796>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeMySQL   "SQL_SAFE_UPDATES"
76797>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeOracle  ""
76798>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeDB2     ""
76799>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypePostgre ""
76800>>>>>>>>>>>
76800>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
76801>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
76802>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
76803>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
76804>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
76805>>>>>>>>>>>
76805>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
76806>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
76807>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
76808>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
76809>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
76810>>>>>>>>>>>
76810>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
76811>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
76812>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
76813>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
76814>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
76815>>>>>>>>>>>
76815>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
76816>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
76817>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
76818>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
76819>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
76820>>>>>>>>>>>
76820>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
76821>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
76822>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
76823>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
76824>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
76825>>>>>>>>>>>
76825>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
76826>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
76827>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
76828>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
76829>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
76830>>>>>>>>>>>
76830>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
76831>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
76832>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
76833>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
76834>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
76835>>>>>>>>>>>
76835>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
76836>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
76837>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
76838>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
76839>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
76840>>>>>>>>>>>
76840>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
76841>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
76842>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
76843>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
76844>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
76845>>>>>>>>>>>
76845>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
76846>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
76847>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
76848>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
76849>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
76850>>>>>>>>>>>
76850>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
76851>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
76852>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
76853>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
76854>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
76855>>>>>>>>>>>
76855>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
76856>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
76857>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
76858>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
76859>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
76860>>>>>>>>>>>
76860>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
76861>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
76862>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
76863>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
76864>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
76865>>>>>>>>>>>
76865>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
76866>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
76867>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
76868>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
76869>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
76870>>>>>>>>>>>
76870>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
76871>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
76872>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
76873>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
76874>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
76875>>>>>>>>>>>
76875>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
76876>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
76877>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
76878>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
76879>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
76880>>>>>>>>>>>
76880>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
76881>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
76882>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
76883>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
76884>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
76885>>>>>>>>>>>
76885>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
76886>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
76887>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
76888>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
76889>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
76890>>>>>>>>>>>
76890>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
76891>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
76892>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
76893>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
76894>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
76895>>>>>>>>>>>
76895>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
76896>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
76897>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
76898>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
76899>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
76900>>>>>>>>>>>
76900>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
76901>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
76902>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
76903>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
76904>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
76905>>>>>>>>>>>
76905>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
76906>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
76907>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
76908>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
76909>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
76910>>>>>>>>>>>
76910>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
76911>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
76912>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
76913>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
76914>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
76915>>>>>>>>>>>
76915>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
76916>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
76917>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
76918>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
76919>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
76920>>>>>>>>>>>
76920>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
76921>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
76922>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
76923>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
76924>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
76925>>>>>>>>>>>
76925>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
76926>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
76927>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
76928>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
76929>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
76930>>>>>>>>>>>
76930>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
76931>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
76932>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
76933>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
76934>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
76935>>>>>>>>>>>
76935>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
76936>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
76937>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
76938>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
76939>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
76940>>>>>>>>>>>
76940>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
76941>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
76942>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
76943>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
76944>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
76945>>>>>>>>>>>
76945>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
76946>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
76947>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
76948>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
76949>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
76950>>>>>>>>>>>
76950>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
76951>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
76952>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
76953>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
76954>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
76955>>>>>>>>>>>
76955>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
76956>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
76957>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
76958>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
76959>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
76960>>>>>>>>>>>
76960>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
76961>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
76962>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
76963>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
76964>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
76965>>>>>>>>>>>
76965>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMSSQL   "DESCRIPTION"
76966>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMySQL   "DESCRIPTION"
76967>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeOracle  "DESCRIPTION"
76968>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeDB2     "DESCRIPTION"
76969>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypePostgre "DESCRIPTION"
76970>>>>>>>>>>>
76970>>>>>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
76970>>>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
76971>>>>>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
76972>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
76973>>>>>>>>>>>
76973>>>>>>>>>>>    End_Procedure
76974>>>>>>>>>>>
76974>>>>>>>>>>>End_Class
76975>>>>>>>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
76975>>>>>>>>>>>//****************************************************************************
76975>>>>>>>>>>>// $Module type: Class
76975>>>>>>>>>>>// $Module name: cSQLConnectionHandler.pkg
76975>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
76975>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76975>>>>>>>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
76975>>>>>>>>>>>//
76975>>>>>>>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
76975>>>>>>>>>>>//
76975>>>>>>>>>>>// $Rev History:
76975>>>>>>>>>>>//    2015-08-11  Module header created
76975>>>>>>>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
76975>>>>>>>>>>>//                Added a new structure for passing connection data back & forth.
76975>>>>>>>>>>>//                Added better error handling.
76975>>>>>>>>>>>//                Added a decompose message for the connection string.
76975>>>>>>>>>>>//    2017-01-09  Added support for Mertech drivers
76975>>>>>>>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
76975>>>>>>>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
76975>>>>>>>>>>>//    2017-02-12  Reworked the whole connection property interface.
76975>>>>>>>>>>>//                Now there is one struct property that is the at cencter of a connection.
76975>>>>>>>>>>>//    2023-11-06 *** REMOVED ALL SUPPORT FOR MERTECH DRIVERS ***
76975>>>>>>>>>>>//****************************************************************************
76975>>>>>>>>>>>Use cli.pkg
76975>>>>>>>>>>>Use MSSqldrv.pkg
76975>>>>>>>>>>>Use db2_drv.pkg
76975>>>>>>>>>>>Use odbc_drv.pkg
76975>>>>>>>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
76975>>>>>>>>>>>>>//****************************************************************************
76975>>>>>>>>>>>>>// $Module type: Class
76975>>>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
76975>>>>>>>>>>>>>//
76975>>>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
76975>>>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
76975>>>>>>>>>>>>>// E-mail      : support@rdctools.com
76975>>>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76975>>>>>>>>>>>>>//
76975>>>>>>>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
76975>>>>>>>>>>>>>//
76975>>>>>>>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
76975>>>>>>>>>>>>>//               properties of that object.
76975>>>>>>>>>>>>>//
76975>>>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
76975>>>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
76975>>>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
76975>>>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
76975>>>>>>>>>>>>>// in the help folder for more details.
76975>>>>>>>>>>>>>//
76975>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
76975>>>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
76975>>>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
76975>>>>>>>>>>>>>>>
76975>>>>>>>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
76976>>>>>>>>>>>>>>>    Procedure Construct_Object
76978>>>>>>>>>>>>>>>        Forward Send Construct_Object
76980>>>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
76981>>>>>>>>>>>>>>>    End_Procedure
76982>>>>>>>>>>>>>>>
76982>>>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
76984>>>>>>>>>>>>>>>        String sRetval
76984>>>>>>>>>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
76986>>>>>>>>>>>>>>>            Move CS_SQLIniFileDSNKeyword to sRetval    
76987>>>>>>>>>>>>>>>        End                                        
76987>>>>>>>>>>>>>>>>
76987>>>>>>>>>>>>>>>        Else Begin
76988>>>>>>>>>>>>>>>            Move CS_SQLIniDSNKeyword to sRetval
76989>>>>>>>>>>>>>>>        End
76989>>>>>>>>>>>>>>>>
76989>>>>>>>>>>>>>>>            
76989>>>>>>>>>>>>>>>        Function_Return sRetval
76990>>>>>>>>>>>>>>>    End_Function
76991>>>>>>>>>>>>>>>
76991>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
76993>>>>>>>>>>>>>>>        String sConnect sServerKeyWord sDriverID
76993>>>>>>>>>>>>>>>        Integer iClientVersion
76993>>>>>>>>>>>>>>>        
76993>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
76994>>>>>>>>>>>>>>>        Get ServerKeyword sServer to sServerKeyWord
76995>>>>>>>>>>>>>>>        Move (sConnect + sServerKeyWord + "=" + sServer) to sConnect
76996>>>>>>>>>>>>>>>        If (sServerKeyWord = CS_SQLIniDSNKeyword or sServerKeyWord = CS_SQLIniFileDSNKeyword) Begin
76998>>>>>>>>>>>>>>>            Move "" to sDatabase
76999>>>>>>>>>>>>>>>        End
76999>>>>>>>>>>>>>>>>
76999>>>>>>>>>>>>>>>        
76999>>>>>>>>>>>>>>>        If (sDatabase <> "") Begin
77001>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77002>>>>>>>>>>>>>>>        End
77002>>>>>>>>>>>>>>>>
77002>>>>>>>>>>>>>>>        If (bTrusted = True) Begin
77004>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
77005>>>>>>>>>>>>>>>        End
77005>>>>>>>>>>>>>>>>
77005>>>>>>>>>>>>>>>        Else Begin
77006>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniUIDKeyword + "=" + sUserID + ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
77007>>>>>>>>>>>>>>>        End
77007>>>>>>>>>>>>>>>>
77007>>>>>>>>>>>>>>>        
77007>>>>>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
77009>>>>>>>>>>>>>>>            Get SQLClientVersionInteger MSSQLDRV_ID to iClientVersion
77010>>>>>>>>>>>>>>>            If (iClientVersion >= 18) Begin
77012>>>>>>>>>>>>>>>                Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
77013>>>>>>>>>>>>>>>                Move (Replaces(" ", sConnect, "")) to sConnect
77014>>>>>>>>>>>>>>>            End
77014>>>>>>>>>>>>>>>>
77014>>>>>>>>>>>>>>>        End
77014>>>>>>>>>>>>>>>>
77014>>>>>>>>>>>>>>>        
77014>>>>>>>>>>>>>>>        Function_Return sConnect
77015>>>>>>>>>>>>>>>    End_Function
77016>>>>>>>>>>>>>>>
77016>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77018>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77018>>>>>>>>>>>>>>>        String sDriverID
77018>>>>>>>>>>>>>>>
77018>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77019>>>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
77021>>>>>>>>>>>>>>>            Function_Return True
77022>>>>>>>>>>>>>>>        End
77022>>>>>>>>>>>>>>>>
77022>>>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
77023>>>>>>>>>>>>>>>        If (bTrusted = False and sDatabase <> "") Begin
77025>>>>>>>>>>>>>>>            Move (SFormat("SERVER=%1;DATABASE=%2", sServer, sDatabase)) to sServer
77026>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
77028>>>>>>>>>>>>>>>        End
77028>>>>>>>>>>>>>>>>
77028>>>>>>>>>>>>>>>        Else Begin
77029>>>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
77031>>>>>>>>>>>>>>>        End
77031>>>>>>>>>>>>>>>>
77031>>>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
77032>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77033>>>>>>>>>>>>>>>    End_Function
77034>>>>>>>>>>>>>>>
77034>>>>>>>>>>>>>>>    Function SQLClientVersionInteger String sDriverID Returns Integer
77036>>>>>>>>>>>>>>>        Integer iNumberOfDrivers iCount iDriver iClientVersion
77036>>>>>>>>>>>>>>>        String sDriver
77036>>>>>>>>>>>>>>>        
77036>>>>>>>>>>>>>>>        Move 0 to iDriver
77037>>>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77040>>>>>>>>>>>>>>>        If (iNumberOfDrivers = 1) Begin
77042>>>>>>>>>>>>>>>            Load_Driver sDriverID
77043>>>>>>>>>>>>>>>            Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77046>>>>>>>>>>>>>>>        End
77046>>>>>>>>>>>>>>>>
77046>>>>>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
77052>>>>>>>>>>>>>>>>
77052>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sDriver
77055>>>>>>>>>>>>>>>            If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
77057>>>>>>>>>>>>>>>                Move iCount to iDriver
77058>>>>>>>>>>>>>>>                Move iNumberOfDrivers to iCount // We're done.
77059>>>>>>>>>>>>>>>            End
77059>>>>>>>>>>>>>>>>
77059>>>>>>>>>>>>>>>        Loop
77060>>>>>>>>>>>>>>>>
77060>>>>>>>>>>>>>>>    
77060>>>>>>>>>>>>>>>        // This info is (at current) only available for the MS SQL driver:
77060>>>>>>>>>>>>>>>        If (iDriver <> 0 and sDriverID = MSSQLDRV_ID) Begin
77062>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
77065>>>>>>>>>>>>>>>        End
77065>>>>>>>>>>>>>>>>
77065>>>>>>>>>>>>>>>        Function_Return iClientVersion
77066>>>>>>>>>>>>>>>    End_Function
77067>>>>>>>>>>>>>>>    
77067>>>>>>>>>>>>>>>End_Class
77068>>>>>>>>>>>>>>>
77068>>>>>>>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
77069>>>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
77071>>>>>>>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
77072>>>>>>>>>>>>>>>    End_Function
77073>>>>>>>>>>>>>>>
77073>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77075>>>>>>>>>>>>>>>        Integer iClientVersion
77075>>>>>>>>>>>>>>>        String sConnect
77075>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77075>>>>>>>>>>>>>>>        
77075>>>>>>>>>>>>>>>        Move (sConnect * "SERVER=" + sServer) to sConnect
77076>>>>>>>>>>>>>>>        If (sDatabase <> "") Begin
77078>>>>>>>>>>>>>>>            Move (sConnect * ";DATABASE=" + sDatabase) to sConnect
77079>>>>>>>>>>>>>>>        End
77079>>>>>>>>>>>>>>>>
77079>>>>>>>>>>>>>>>        If (bTrusted = True) Begin
77081>>>>>>>>>>>>>>>            Move (sConnect * ";TRUSTED_CONNECTION=Yes") to sConnect
77082>>>>>>>>>>>>>>>        End
77082>>>>>>>>>>>>>>>>
77082>>>>>>>>>>>>>>>        Else Begin
77083>>>>>>>>>>>>>>>            Move (sConnect * ";UID=" + sUserID * ";PWD=" + sPassword) to sConnect
77084>>>>>>>>>>>>>>>        End
77084>>>>>>>>>>>>>>>>
77084>>>>>>>>>>>>>>>
77084>>>>>>>>>>>>>>>        Get SQLClientVersionInteger MSSQLDRV_ID to iClientVersion
77085>>>>>>>>>>>>>>>        If (iClientVersion >= 18) Begin
77087>>>>>>>>>>>>>>>            Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
77088>>>>>>>>>>>>>>>            Move (Replaces(" ", sConnect, "")) to sConnect
77089>>>>>>>>>>>>>>>        End
77089>>>>>>>>>>>>>>>>
77089>>>>>>>>>>>>>>>        
77089>>>>>>>>>>>>>>>        Login sConnect "" "" MSSQLDRV_ID
77091>>>>>>>>>>>>>>>
77091>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77092>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77093>>>>>>>>>>>>>>>    End_Function
77094>>>>>>>>>>>>>>>
77094>>>>>>>>>>>>>>>    Function SQLClientVersionInteger String sDriverID Returns Integer
77096>>>>>>>>>>>>>>>        Integer iNumberOfDrivers iCount iDriver iClientVersion
77096>>>>>>>>>>>>>>>        String sDriver
77096>>>>>>>>>>>>>>>        
77096>>>>>>>>>>>>>>>        Move 0 to iDriver
77097>>>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77100>>>>>>>>>>>>>>>        If (iNumberOfDrivers = 1) Begin
77102>>>>>>>>>>>>>>>            Load_Driver sDriverID
77103>>>>>>>>>>>>>>>            Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77106>>>>>>>>>>>>>>>        End
77106>>>>>>>>>>>>>>>>
77106>>>>>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
77112>>>>>>>>>>>>>>>>
77112>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sDriver
77115>>>>>>>>>>>>>>>            If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
77117>>>>>>>>>>>>>>>                Move iCount to iDriver
77118>>>>>>>>>>>>>>>                Move iNumberOfDrivers to iCount // We're done.
77119>>>>>>>>>>>>>>>            End
77119>>>>>>>>>>>>>>>>
77119>>>>>>>>>>>>>>>        Loop
77120>>>>>>>>>>>>>>>>
77120>>>>>>>>>>>>>>>    
77120>>>>>>>>>>>>>>>        // This info is (at current) only available for the MS SQL driver:
77120>>>>>>>>>>>>>>>        If (iDriver <> 0 and sDriverID = MSSQLDRV_ID) Begin
77122>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
77125>>>>>>>>>>>>>>>        End
77125>>>>>>>>>>>>>>>>
77125>>>>>>>>>>>>>>>        Function_Return iClientVersion
77126>>>>>>>>>>>>>>>    End_Function
77127>>>>>>>>>>>>>>>    
77127>>>>>>>>>>>>>>>End_Class
77128>>>>>>>>>>>>>>>
77128>>>>>>>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
77129>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77131>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77131>>>>>>>>>>>>>>>        String sDriverID
77131>>>>>>>>>>>>>>>
77131>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77132>>>>>>>>>>>>>>>        Move (Trim(sDriverID)) to sDriverID
77133>>>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
77135>>>>>>>>>>>>>>>            Function_Return True
77136>>>>>>>>>>>>>>>        End
77136>>>>>>>>>>>>>>>>
77136>>>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
77137>>>>>>>>>>>>>>>        If (bTrusted = False) Begin
77139>>>>>>>>>>>>>>>            If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
77141>>>>>>>>>>>>>>>                Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sServer
77142>>>>>>>>>>>>>>>            End
77142>>>>>>>>>>>>>>>>
77142>>>>>>>>>>>>>>>            Else If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77145>>>>>>>>>>>>>>>                Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77146>>>>>>>>>>>>>>>            End
77146>>>>>>>>>>>>>>>>
77146>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
77148>>>>>>>>>>>>>>>        End
77148>>>>>>>>>>>>>>>>
77148>>>>>>>>>>>>>>>        Else Begin
77149>>>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
77151>>>>>>>>>>>>>>>        End
77151>>>>>>>>>>>>>>>>
77151>>>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
77152>>>>>>>>>>>>>>>
77152>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77153>>>>>>>>>>>>>>>    End_Function
77154>>>>>>>>>>>>>>>End_Class
77155>>>>>>>>>>>>>>>
77155>>>>>>>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
77156>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77158>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77158>>>>>>>>>>>>>>>        String sDriverID
77158>>>>>>>>>>>>>>>
77158>>>>>>>>>>>>>>>        Move False to Err
77159>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77160>>>>>>>>>>>>>>>        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77162>>>>>>>>>>>>>>>            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77163>>>>>>>>>>>>>>>        End
77163>>>>>>>>>>>>>>>>
77163>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
77165>>>>>>>>>>>>>>>
77165>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77166>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77167>>>>>>>>>>>>>>>    End_Function
77168>>>>>>>>>>>>>>>End_Class
77169>>>>>>>>>>>>>>>
77169>>>>>>>>>>>>>>>Class cDbUpdatePSQLDriver is a cDbUpdateGenericDatabaseDriver
77170>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77172>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77172>>>>>>>>>>>>>>>        String sDriverID
77172>>>>>>>>>>>>>>>
77172>>>>>>>>>>>>>>>        Move False to Err
77173>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77174>>>>>>>>>>>>>>>//        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77174>>>>>>>>>>>>>>>//            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77174>>>>>>>>>>>>>>>//        End
77174>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
77176>>>>>>>>>>>>>>>
77176>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77177>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77178>>>>>>>>>>>>>>>    End_Function
77179>>>>>>>>>>>>>>>End_Class
77180>>>>>>>>>>>>>>>
77180>>>>>>>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
77181>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77183>>>>>>>>>>>>>>>        Function_Return ""
77184>>>>>>>>>>>>>>>    End_Function
77185>>>>>>>>>>>>>>>End_Class
77186>>>>>>>>>>>>>>>
77186>>>>>>>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
77187>>>>>>>>>>>>>>>    Procedure Construct_Object
77189>>>>>>>>>>>>>>>        Forward Send Construct_Object
77191>>>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
77192>>>>>>>>>>>>>>>        Property Handle phoDriverSpecificObject
77193>>>>>>>>>>>>>>>    End_Procedure
77194>>>>>>>>>>>>>>>
77194>>>>>>>>>>>>>>>    Function CreateDriver Returns Handle
77196>>>>>>>>>>>>>>>        String sDriverID sObjectName
77196>>>>>>>>>>>>>>>        Handle hoDriver hcDriverClass
77196>>>>>>>>>>>>>>>
77196>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77197>>>>>>>>>>>>>>>        Case Begin
77197>>>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
77199>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
77200>>>>>>>>>>>>>>>                Move "oDbUpdateMSSQLDriver" to sObjectName
77201>>>>>>>>>>>>>>>                Case Break
77202>>>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
77205>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
77206>>>>>>>>>>>>>>>                Move "oDbUpdateODBCDriver" to sObjectName
77207>>>>>>>>>>>>>>>                Case Break
77208>>>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
77211>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
77212>>>>>>>>>>>>>>>                Move "oDbUpdateDB2Driver" to sObjectName
77213>>>>>>>>>>>>>>>                Case Break               
77214>>>>>>>>>>>>>>>            Case Else
77214>>>>>>>>>>>>>>>                // DATAFLEX_ID = Default driver
77214>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
77215>>>>>>>>>>>>>>>                Move "oDbUpdateDataFlexDriver" to sObjectName
77216>>>>>>>>>>>>>>>                Move DATAFLEX_ID to sDriverID
77217>>>>>>>>>>>>>>>        Case End
77217>>>>>>>>>>>>>>>
77217>>>>>>>>>>>>>>>        Get Create hcDriverClass to hoDriver
77218>>>>>>>>>>>>>>>        Set Name of hoDriver to sObjectName
77219>>>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
77220>>>>>>>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
77221>>>>>>>>>>>>>>>
77221>>>>>>>>>>>>>>>        Function_Return hoDriver
77222>>>>>>>>>>>>>>>    End_Function
77223>>>>>>>>>>>>>>>
77223>>>>>>>>>>>>>>>    Procedure DestroyDriver
77225>>>>>>>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
77227>>>>>>>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
77228>>>>>>>>>>>>>>>        End
77228>>>>>>>>>>>>>>>>
77228>>>>>>>>>>>>>>>    End_Procedure
77229>>>>>>>>>>>>>>>
77229>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77231>>>>>>>>>>>>>>>        String sConnect
77231>>>>>>>>>>>>>>>        Handle hoDriver
77231>>>>>>>>>>>>>>>
77231>>>>>>>>>>>>>>>        Get phoDriverSpecificObject to hoDriver
77232>>>>>>>>>>>>>>>        If (hoDriver = 0) Begin
77234>>>>>>>>>>>>>>>            Get CreateDriver to hoDriver
77235>>>>>>>>>>>>>>>        End
77235>>>>>>>>>>>>>>>>
77235>>>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
77236>>>>>>>>>>>>>>>        Send DestroyDriver
77237>>>>>>>>>>>>>>>        Function_Return sConnect
77238>>>>>>>>>>>>>>>    End_Function
77239>>>>>>>>>>>>>>>
77239>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77241>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77241>>>>>>>>>>>>>>>        Handle hoDriver
77241>>>>>>>>>>>>>>>
77241>>>>>>>>>>>>>>>        Get phoDriverSpecificObject to hoDriver
77242>>>>>>>>>>>>>>>        If (hoDriver = 0) Begin
77244>>>>>>>>>>>>>>>            Get CreateDriver to hoDriver
77245>>>>>>>>>>>>>>>        End
77245>>>>>>>>>>>>>>>>
77245>>>>>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
77246>>>>>>>>>>>>>>>        Send DestroyDriver
77247>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77248>>>>>>>>>>>>>>>    End_Function
77249>>>>>>>>>>>>>>>
77249>>>>>>>>>>>>>>>End_Class
77250>>>>>>>>>>>>>
77250>>>>>>>>>>>>>    Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cLoginEncryption.pkg)
77250>>>>>>>>>>>>>>>Use cCryptographerEx.pkg
77250>>>>>>>>>>>>>>>
77250>>>>>>>>>>>>>>>Class cLoginEncryption is a cObject
77251>>>>>>>>>>>>>>>    
77251>>>>>>>>>>>>>>>    Procedure Construct_Object
77253>>>>>>>>>>>>>>>        Forward Send Construct_Object
77255>>>>>>>>>>>>>>>        // this must be set to a multi (40ish) character random key
77255>>>>>>>>>>>>>>>        Property String psEncryptPassword ""
77256>>>>>>>>>>>>>>>        
77256>>>>>>>>>>>>>>>        Object oDataCrypter is a cCryptographerEx
77258>>>>>>>>>>>>>>>            Set piHash to CALG_SHA_256
77259>>>>>>>>>>>>>>>            Set piCipher to CALG_AES_256
77260>>>>>>>>>>>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
77261>>>>>>>>>>>>>>>            Set piProvider to PROV_RSA_AES
77262>>>>>>>>>>>>>>>        End_Object
77263>>>>>>>>>>>>>>>    End_Procedure
77264>>>>>>>>>>>>>>>    
77264>>>>>>>>>>>>>>>    // This can be augmented to return a password encryption key using any
77264>>>>>>>>>>>>>>>    // hidden mechanism desired.
77264>>>>>>>>>>>>>>>    Function GetEncryptionPassword Returns String
77266>>>>>>>>>>>>>>>        String sPassword
77266>>>>>>>>>>>>>>>        Get psEncryptPassword to sPassword
77267>>>>>>>>>>>>>>>        Function_Return sPassword
77268>>>>>>>>>>>>>>>    End_Function
77269>>>>>>>>>>>>>>>    
77269>>>>>>>>>>>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
77269>>>>>>>>>>>>>>>    //
77269>>>>>>>>>>>>>>>    // Params:
77269>>>>>>>>>>>>>>>    //   sPlainText     String to encrypt.
77269>>>>>>>>>>>>>>>    // Returns:
77269>>>>>>>>>>>>>>>    //   Base64 encoded hash.
77269>>>>>>>>>>>>>>>    Function EncryptPassword String sPlainText Returns String
77271>>>>>>>>>>>>>>>        String sEncryptPassword sBase64
77271>>>>>>>>>>>>>>>        UChar[] ucBinary
77272>>>>>>>>>>>>>>>        Pointer pBase64
77272>>>>>>>>>>>>>>>        Integer iVoid
77272>>>>>>>>>>>>>>>        
77272>>>>>>>>>>>>>>>        //  Encrypt Key
77272>>>>>>>>>>>>>>>        Get GetEncryptionPassword to sEncryptPassword
77273>>>>>>>>>>>>>>>        If (sEncryptPassword = "") Begin
77275>>>>>>>>>>>>>>>            Error DFERR_PROGRAM "No encryption password set"
77276>>>>>>>>>>>>>>>>
77276>>>>>>>>>>>>>>>        End
77276>>>>>>>>>>>>>>>>
77276>>>>>>>>>>>>>>>        
77276>>>>>>>>>>>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
77277>>>>>>>>>>>>>>>        
77277>>>>>>>>>>>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
77279>>>>>>>>>>>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
77280>>>>>>>>>>>>>>>>
77280>>>>>>>>>>>>>>>            Function_Return ""
77281>>>>>>>>>>>>>>>        End
77281>>>>>>>>>>>>>>>>
77281>>>>>>>>>>>>>>>        
77281>>>>>>>>>>>>>>>        //  Encode binary hash to Base64
77281>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
77282>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sBase64
77283>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
77284>>>>>>>>>>>>>>>        
77284>>>>>>>>>>>>>>>        Function_Return sBase64
77285>>>>>>>>>>>>>>>    End_Function
77286>>>>>>>>>>>>>>>    
77286>>>>>>>>>>>>>>>    
77286>>>>>>>>>>>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
77286>>>>>>>>>>>>>>>    //
77286>>>>>>>>>>>>>>>    // Params:
77286>>>>>>>>>>>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
77286>>>>>>>>>>>>>>>    // Returns:
77286>>>>>>>>>>>>>>>    //   Readable plain text password
77286>>>>>>>>>>>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
77288>>>>>>>>>>>>>>>        String sEncryptPassword
77288>>>>>>>>>>>>>>>        UChar[] ucBinary ucPlain
77290>>>>>>>>>>>>>>>        Boolean bIsHex
77290>>>>>>>>>>>>>>>        Integer iLen iVoid
77290>>>>>>>>>>>>>>>        Pointer pBinary
77290>>>>>>>>>>>>>>>        
77290>>>>>>>>>>>>>>>        If (sBase64EncryptedPassword <> "") Begin
77292>>>>>>>>>>>>>>>            //  Decode from Base64
77292>>>>>>>>>>>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
77293>>>>>>>>>>>>>>>            
77293>>>>>>>>>>>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
77294>>>>>>>>>>>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
77295>>>>>>>>>>>>>>>                        
77295>>>>>>>>>>>>>>>            Move (Free(pBinary)) to iVoid
77296>>>>>>>>>>>>>>>            
77296>>>>>>>>>>>>>>>            //  Encrypted binary hash to string
77296>>>>>>>>>>>>>>>            Get GetEncryptionPassword to sEncryptPassword
77297>>>>>>>>>>>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
77298>>>>>>>>>>>>>>>        End
77298>>>>>>>>>>>>>>>>
77298>>>>>>>>>>>>>>>        
77298>>>>>>>>>>>>>>>        Function_Return (UCharArrayToString(ucPlain))
77299>>>>>>>>>>>>>>>    End_Function
77300>>>>>>>>>>>>>>>End_Class
77301>>>>>>>>>>>>>
77301>>>>>>>>>>>>>Class cSQLConnectionIniFile is a cIniFile
77302>>>>>>>>>>>>>    Procedure Construct_Object
77304>>>>>>>>>>>>>        Forward Send Construct_Object
77306>>>>>>>>>>>>>
77306>>>>>>>>>>>>>        Property String Private_psIniFilePath
77307>>>>>>>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
77308>>>>>>>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
77309>>>>>>>>>>>>>
77309>>>>>>>>>>>>>        Property Boolean pbDFConnId False
77310>>>>>>>>>>>>>
77310>>>>>>>>>>>>>        // *** You really want to change this value! ***
77310>>>>>>>>>>>>>        // It is used when encrypting/decrypting passwords.
77310>>>>>>>>>>>>>        Property String psHashString "zx!2139(LI0+?ips7433"
77311>>>>>>>>>>>>>
77311>>>>>>>>>>>>>    End_Procedure
77312>>>>>>>>>>>>>
77312>>>>>>>>>>>>>    Procedure End_Construct_Object
77314>>>>>>>>>>>>>        Forward Send End_Construct_Object
77316>>>>>>>>>>>>>    End_Procedure
77317>>>>>>>>>>>>>
77317>>>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
77319>>>>>>>>>>>>>        String sIniFile
77319>>>>>>>>>>>>>        Get vFolderFormat sPath to sPath
77320>>>>>>>>>>>>>        Set private_psIniFilePath to sPath
77321>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77322>>>>>>>>>>>>>        Set psFileName to (sPath + sIniFile)
77323>>>>>>>>>>>>>    End_Procedure
77324>>>>>>>>>>>>>
77324>>>>>>>>>>>>>    Function psIniFilePath Returns String
77326>>>>>>>>>>>>>        Function_Return (private_psIniFilePath(Self))
77327>>>>>>>>>>>>>    End_Function
77328>>>>>>>>>>>>>
77328>>>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
77330>>>>>>>>>>>>>        String sPath
77330>>>>>>>>>>>>>        Get psIniFilePath to sPath
77331>>>>>>>>>>>>>        Set psFileName to (sPath + sFileName)
77332>>>>>>>>>>>>>        Set private_psIniFileName to sFileName
77333>>>>>>>>>>>>>    End_Procedure
77334>>>>>>>>>>>>>
77334>>>>>>>>>>>>>    Function psIniFileName Returns String
77336>>>>>>>>>>>>>        Function_Return (private_psIniFileName(Self))
77337>>>>>>>>>>>>>    End_Function
77338>>>>>>>>>>>>>
77338>>>>>>>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
77338>>>>>>>>>>>>>    // Sets a value in the program's ini file (write)
77338>>>>>>>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
77338>>>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
77340>>>>>>>>>>>>>        String sIniFile sPath
77340>>>>>>>>>>>>>
77340>>>>>>>>>>>>>        Get psIniFilePath to sPath
77341>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77342>>>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
77343>>>>>>>>>>>>>        Set psFileName to sIniFile
77344>>>>>>>>>>>>>        Send WriteString sSection sValueName sValue
77345>>>>>>>>>>>>>    End_Procedure
77346>>>>>>>>>>>>>
77346>>>>>>>>>>>>>    // Get a value from program's ini-file (read)
77346>>>>>>>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
77346>>>>>>>>>>>>>    // Returns the value
77346>>>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
77348>>>>>>>>>>>>>        String sValue sIniFile sPath
77348>>>>>>>>>>>>>
77348>>>>>>>>>>>>>        Get psIniFilePath to sPath
77349>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77350>>>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
77351>>>>>>>>>>>>>        Set psFileName to sIniFile
77352>>>>>>>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
77353>>>>>>>>>>>>>
77353>>>>>>>>>>>>>        Function_Return sValue
77354>>>>>>>>>>>>>    End_Function
77355>>>>>>>>>>>>>
77355>>>>>>>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
77355>>>>>>>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
77357>>>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
77360>>>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
77363>>>>>>>>>>>>>
77363>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
77366>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
77369>>>>>>>>>>>>>
77369>>>>>>>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
77372>>>>>>>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
77375>>>>>>>>>>>>>
77375>>>>>>>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
77378>>>>>>>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
77381>>>>>>>>>>>>>
77381>>>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
77384>>>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
77387>>>>>>>>>>>>>
77387>>>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
77390>>>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
77393>>>>>>>>>>>>>
77393>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
77396>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
77399>>>>>>>>>>>>>
77399>>>>>>>>>>>>>        Function_Return (EQ)
77400>>>>>>>>>>>>>    End_Function
77401>>>>>>>>>>>>>
77401>>>>>>>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
77403>>>>>>>>>>>>>        Handle hoSections
77403>>>>>>>>>>>>>        Integer iItems
77403>>>>>>>>>>>>>
77403>>>>>>>>>>>>>        Send ReadSections hoSections
77404>>>>>>>>>>>>>        Move (Item_Count(hoSections)) to iItems
77405>>>>>>>>>>>>>        Function_Return iItems
77406>>>>>>>>>>>>>    End_Function
77407>>>>>>>>>>>>>
77407>>>>>>>>>>>>>    // The normal connection string looks something like this;
77407>>>>>>>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
77407>>>>>>>>>>>>>    // ...but the full connection string looks like this;
77407>>>>>>>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
77407>>>>>>>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
77407>>>>>>>>>>>>>//        String sSection
77407>>>>>>>>>>>>>//        Integer iCount
77407>>>>>>>>>>>>>//
77407>>>>>>>>>>>>>//        Move False to Err
77407>>>>>>>>>>>>>//        Get psIniSectionName to sSection
77407>>>>>>>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
77407>>>>>>>>>>>>>//        Increment iCount
77407>>>>>>>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
77407>>>>>>>>>>>>>//
77407>>>>>>>>>>>>>//        Function_Return (Err = False)
77407>>>>>>>>>>>>>//    End_Function
77407>>>>>>>>>>>>>
77407>>>>>>>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
77409>>>>>>>>>>>>>        Integer iCount
77409>>>>>>>>>>>>>        Boolean bExists
77409>>>>>>>>>>>>>        String sSection
77409>>>>>>>>>>>>>
77409>>>>>>>>>>>>>        Move False to Err
77410>>>>>>>>>>>>>        Move 1 to iCount
77411>>>>>>>>>>>>>        Get psIniSectionName to sSection
77412>>>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77413>>>>>>>>>>>>>        While (bExists = True)
77417>>>>>>>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
77418>>>>>>>>>>>>>            Increment iCount
77419>>>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77420>>>>>>>>>>>>>        Loop
77421>>>>>>>>>>>>>>
77421>>>>>>>>>>>>>        Function_Return (Err = False)
77422>>>>>>>>>>>>>    End_Function
77423>>>>>>>>>>>>>
77423>>>>>>>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
77425>>>>>>>>>>>>>        Integer iCount
77425>>>>>>>>>>>>>        String sSection
77425>>>>>>>>>>>>>        Boolean bExists
77425>>>>>>>>>>>>>
77425>>>>>>>>>>>>>        Move False to Err
77426>>>>>>>>>>>>>        Move 1 to iCount
77427>>>>>>>>>>>>>        Get psIniSectionName to sSection
77428>>>>>>>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
77429>>>>>>>>>>>>>        While (bExists = True)
77433>>>>>>>>>>>>>            If (iCount = iItem) Begin
77435>>>>>>>>>>>>>                Send DeleteSection sSection
77436>>>>>>>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
77436>>>>>>>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
77437>>>>>>>>>>>>>            End
77437>>>>>>>>>>>>>>
77437>>>>>>>>>>>>>            Increment iCount
77438>>>>>>>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
77439>>>>>>>>>>>>>        Loop
77440>>>>>>>>>>>>>>
77440>>>>>>>>>>>>>
77440>>>>>>>>>>>>>        Function_Return (Err = False)
77441>>>>>>>>>>>>>    End_Function
77442>>>>>>>>>>>>>
77442>>>>>>>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
77442>>>>>>>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
77442>>>>>>>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
77444>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77444>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77445>>>>>>>>>>>>>        tSQLConnection   SQLConnection
77445>>>>>>>>>>>>>        tSQLConnection   SQLConnection
77445>>>>>>>>>>>>>        Integer iIndex
77445>>>>>>>>>>>>>
77445>>>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
77446>>>>>>>>>>>>>        If (iIndex = -1) Begin
77448>>>>>>>>>>>>>            Move True to SQLConnection.bError
77449>>>>>>>>>>>>>            Function_Return SQLConnection
77450>>>>>>>>>>>>>        End
77450>>>>>>>>>>>>>>
77450>>>>>>>>>>>>>
77450>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77451>>>>>>>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
77452>>>>>>>>>>>>>
77452>>>>>>>>>>>>>        Function_Return SQLConnection
77453>>>>>>>>>>>>>    End_Function
77454>>>>>>>>>>>>>
77454>>>>>>>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
77454>>>>>>>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
77456>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77456>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77457>>>>>>>>>>>>>        Integer iRetval iCount iSize
77457>>>>>>>>>>>>>        String sValue
77457>>>>>>>>>>>>>        Boolean bExists
77457>>>>>>>>>>>>>
77457>>>>>>>>>>>>>        Move -1 to iRetval
77458>>>>>>>>>>>>>
77458>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77459>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77460>>>>>>>>>>>>>        Decrement iSize
77461>>>>>>>>>>>>>        For iCount from 0 to iSize
77467>>>>>>>>>>>>>>
77467>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
77468>>>>>>>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
77469>>>>>>>>>>>>>            If (bExists) Begin
77471>>>>>>>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
77472>>>>>>>>>>>>>                Move iSize to iCount         // We're done!
77473>>>>>>>>>>>>>            End
77473>>>>>>>>>>>>>>
77473>>>>>>>>>>>>>        Loop
77474>>>>>>>>>>>>>>
77474>>>>>>>>>>>>>
77474>>>>>>>>>>>>>        Function_Return iRetval
77475>>>>>>>>>>>>>    End_Function
77476>>>>>>>>>>>>>
77476>>>>>>>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
77476>>>>>>>>>>>>>    // Used to check that ConnectionID's are unique.
77476>>>>>>>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
77478>>>>>>>>>>>>>        Integer iCount iSize iItems
77478>>>>>>>>>>>>>        String sValue
77478>>>>>>>>>>>>>        Boolean bExists
77478>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77478>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77479>>>>>>>>>>>>>
77479>>>>>>>>>>>>>        Move 0 to iItems
77480>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77481>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77482>>>>>>>>>>>>>        Decrement iSize
77483>>>>>>>>>>>>>        For iCount from 0 to iSize
77489>>>>>>>>>>>>>>
77489>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
77490>>>>>>>>>>>>>            Move (sValue = sConnectionID) to bExists
77491>>>>>>>>>>>>>            If (bExists) Begin
77493>>>>>>>>>>>>>                Increment iItems
77494>>>>>>>>>>>>>            End
77494>>>>>>>>>>>>>>
77494>>>>>>>>>>>>>        Loop
77495>>>>>>>>>>>>>>
77495>>>>>>>>>>>>>
77495>>>>>>>>>>>>>        Function_Return (iItems > 1)
77496>>>>>>>>>>>>>    End_Function
77497>>>>>>>>>>>>>
77497>>>>>>>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
77497>>>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
77499>>>>>>>>>>>>>        Boolean bOK
77499>>>>>>>>>>>>>        Integer iSize iCount
77499>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77499>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77500>>>>>>>>>>>>>        tSQLConnection SQLConnection
77500>>>>>>>>>>>>>        tSQLConnection SQLConnection
77500>>>>>>>>>>>>>        String sConnectionString
77500>>>>>>>>>>>>>
77500>>>>>>>>>>>>>        Move False to Err
77501>>>>>>>>>>>>>        Get psConnectionString to sConnectionString
77502>>>>>>>>>>>>>
77502>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77503>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77504>>>>>>>>>>>>>        Decrement iSize
77505>>>>>>>>>>>>>        // Set all current connection to inactive.
77505>>>>>>>>>>>>>        For iCount from 0 to iSize
77511>>>>>>>>>>>>>>
77511>>>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
77512>>>>>>>>>>>>>        Loop
77513>>>>>>>>>>>>>>
77513>>>>>>>>>>>>>
77513>>>>>>>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
77514>>>>>>>>>>>>>        Move True              to SQLConnection.bEnabled
77515>>>>>>>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
77516>>>>>>>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
77517>>>>>>>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
77518>>>>>>>>>>>>>
77518>>>>>>>>>>>>>        Function_Return (bOK = True)
77519>>>>>>>>>>>>>    End_Function
77520>>>>>>>>>>>>>
77520>>>>>>>>>>>>>    // Used for updating an existing connection with new data.
77520>>>>>>>>>>>>>    // Returns True if successful.
77520>>>>>>>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
77522>>>>>>>>>>>>>        Boolean bOK
77522>>>>>>>>>>>>>        Integer iItem iSize iCount
77522>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77522>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77523>>>>>>>>>>>>>
77523>>>>>>>>>>>>>        Move False to Err
77524>>>>>>>>>>>>>        Move -1 to iItem
77525>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77526>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77527>>>>>>>>>>>>>        Decrement iSize
77528>>>>>>>>>>>>>        // Set all current connection to inactive.
77528>>>>>>>>>>>>>        For iCount from 0 to iSize
77534>>>>>>>>>>>>>>
77534>>>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
77535>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
77537>>>>>>>>>>>>>                Move iCount to iItem
77538>>>>>>>>>>>>>            End
77538>>>>>>>>>>>>>>
77538>>>>>>>>>>>>>        Loop
77539>>>>>>>>>>>>>>
77539>>>>>>>>>>>>>
77539>>>>>>>>>>>>>        If (iItem <> -1) Begin
77541>>>>>>>>>>>>>            Move True to SQLConnection.bEnabled
77542>>>>>>>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
77543>>>>>>>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
77544>>>>>>>>>>>>>        End
77544>>>>>>>>>>>>>>
77544>>>>>>>>>>>>>
77544>>>>>>>>>>>>>        Function_Return (bOK = True)
77545>>>>>>>>>>>>>    End_Function
77546>>>>>>>>>>>>>
77546>>>>>>>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
77548>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77548>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77549>>>>>>>>>>>>>        String sSection sValue
77549>>>>>>>>>>>>>        Integer iCount
77549>>>>>>>>>>>>>        Boolean bExists
77549>>>>>>>>>>>>>
77549>>>>>>>>>>>>>        Get psIniSectionName to sSection
77550>>>>>>>>>>>>>        Get SectionExists sSection to bExists
77551>>>>>>>>>>>>>        If (bExists = False) Begin
77553>>>>>>>>>>>>>            Function_Return SQLConnectionsArray
77554>>>>>>>>>>>>>        End
77554>>>>>>>>>>>>>>
77554>>>>>>>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
77555>>>>>>>>>>>>>        If (bExists = True) Begin
77557>>>>>>>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
77558>>>>>>>>>>>>>>
77558>>>>>>>>>>>>>        End
77558>>>>>>>>>>>>>>
77558>>>>>>>>>>>>>
77558>>>>>>>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
77559>>>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77560>>>>>>>>>>>>>
77560>>>>>>>>>>>>>        While (bExists = True)                 
77564>>>>>>>>>>>>>            // 2018-07-14 Change to allow disabling all connections in test environment.
77564>>>>>>>>>>>>>            // We always put the enabled/active connection at the top
77564>>>>>>>>>>>>>//            Move (iCount = 1) to bEnabled
77564>>>>>>>>>>>>>//            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
77564>>>>>>>>>>>>>
77564>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
77565>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
77566>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword     ""        to sValue
77567>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", False, True))                                               to SQLConnectionsArray[iCount].bEnabled
77568>>>>>>>>>>>>>
77568>>>>>>>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
77568>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
77569>>>>>>>>>>>>>            If (sValue = "99") Begin
77571>>>>>>>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
77572>>>>>>>>>>>>>            End
77572>>>>>>>>>>>>>>
77572>>>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
77573>>>>>>>>>>>>>
77573>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
77574>>>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
77575>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
77577>>>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniFileDSNKeyword +"=") to SQLConnectionsArray[iCount].sServer
77578>>>>>>>>>>>>>            End
77578>>>>>>>>>>>>>>
77578>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
77580>>>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
77581>>>>>>>>>>>>>            End
77581>>>>>>>>>>>>>>
77581>>>>>>>>>>>>>
77581>>>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
77582>>>>>>>>>>>>>
77582>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
77583>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
77584>>>>>>>>>>>>>
77584>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
77585>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
77586>>>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
77588>>>>>>>>>>>>>                Get DecryptPassword sValue to sValue
77589>>>>>>>>>>>>>            End
77589>>>>>>>>>>>>>>
77589>>>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
77590>>>>>>>>>>>>>
77590>>>>>>>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
77590>>>>>>>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
77591>>>>>>>>>>>>>
77591>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
77592>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
77593>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
77594>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
77595>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to sValue
77596>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bSilentLogin
77597>>>>>>>>>>>>>
77597>>>>>>>>>>>>>            Increment iCount
77598>>>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77599>>>>>>>>>>>>>        Loop
77600>>>>>>>>>>>>>>
77600>>>>>>>>>>>>>
77600>>>>>>>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
77600>>>>>>>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
77602>>>>>>>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
77603>>>>>>>>>>>>>        End
77603>>>>>>>>>>>>>>
77603>>>>>>>>>>>>>
77603>>>>>>>>>>>>>        Function_Return SQLConnectionsArray
77604>>>>>>>>>>>>>    End_Function
77605>>>>>>>>>>>>>
77605>>>>>>>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
77607>>>>>>>>>>>>>        Integer iCount iSize
77607>>>>>>>>>>>>>        Boolean bOK
77607>>>>>>>>>>>>>        String sSection sValue
77607>>>>>>>>>>>>>
77607>>>>>>>>>>>>>        // First we need to _remove_ all current connections from the ini-file.
77607>>>>>>>>>>>>>        Move 0 to iCount
77608>>>>>>>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
77609>>>>>>>>>>>>>        If (bOK = False) Begin
77611>>>>>>>>>>>>>            Function_Return False
77612>>>>>>>>>>>>>        End
77612>>>>>>>>>>>>>>
77612>>>>>>>>>>>>>
77612>>>>>>>>>>>>>        Move False to Err
77613>>>>>>>>>>>>>        Get psIniSectionName to sSection
77614>>>>>>>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
77614>>>>>>>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
77615>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77616>>>>>>>>>>>>>        Decrement iSize
77617>>>>>>>>>>>>>
77617>>>>>>>>>>>>>        For iCount from 0 to iSize
77623>>>>>>>>>>>>>>
77623>>>>>>>>>>>>>            // DF 19 compatible settings:
77623>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
77624>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
77625>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDisabledKeyword       to (If(SQLConnectionsArray[iCount].bEnabled = 0, "Yes", "No"))
77626>>>>>>>>>>>>>            
77626>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
77627>>>>>>>>>>>>>
77627>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
77628>>>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
77630>>>>>>>>>>>>>                Get EncryptPassword sValue to sValue
77631>>>>>>>>>>>>>            End
77631>>>>>>>>>>>>>>
77631>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
77632>>>>>>>>>>>>>
77632>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
77634>>>>>>>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
77635>>>>>>>>>>>>>            End
77635>>>>>>>>>>>>>>
77635>>>>>>>>>>>>>
77635>>>>>>>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
77636>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
77637>>>>>>>>>>>>>
77637>>>>>>>>>>>>>            // The Database Update Framework extended settings:
77637>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
77638>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
77639>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
77640>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
77641>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
77642>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to (If(SQLConnectionsArray[iCount].bSilentLogin = 1, "Yes", "No"))
77643>>>>>>>>>>>>>        Loop
77644>>>>>>>>>>>>>>
77644>>>>>>>>>>>>>
77644>>>>>>>>>>>>>        Function_Return (bOK and Err = False)
77645>>>>>>>>>>>>>    End_Function
77646>>>>>>>>>>>>>
77646>>>>>>>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
77646>>>>>>>>>>>>>    //
77646>>>>>>>>>>>>>    // SQL utility function that returns a database type (string) constant
77646>>>>>>>>>>>>>    // corresponding to the passed iDbType.
77646>>>>>>>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
77648>>>>>>>>>>>>>        String sRetval
77648>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
77650>>>>>>>>>>>>>            Move CS_dbTypeMSSQL to sRetval
77651>>>>>>>>>>>>>        End
77651>>>>>>>>>>>>>>
77651>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
77653>>>>>>>>>>>>>            Move CS_dbTypeMySQL to sRetval
77654>>>>>>>>>>>>>        End
77654>>>>>>>>>>>>>>
77654>>>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
77656>>>>>>>>>>>>>            Move CS_dbTypeOracle to sRetval
77657>>>>>>>>>>>>>        End
77657>>>>>>>>>>>>>>
77657>>>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
77659>>>>>>>>>>>>>            Move CS_dbTypeDB2 to sRetval
77660>>>>>>>>>>>>>        End
77660>>>>>>>>>>>>>>
77660>>>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
77662>>>>>>>>>>>>>            Move CS_dbTypePostgre to sRetval
77663>>>>>>>>>>>>>        End
77663>>>>>>>>>>>>>>
77663>>>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
77665>>>>>>>>>>>>>            Move CS_DbTypePervasive to sRetval
77666>>>>>>>>>>>>>        End
77666>>>>>>>>>>>>>>
77666>>>>>>>>>>>>>        Function_Return sRetval
77667>>>>>>>>>>>>>    End_Function
77668>>>>>>>>>>>>>
77668>>>>>>>>>>>>>    // SQL utility function that returns a database type constant (integer)
77668>>>>>>>>>>>>>    // corresponding to the passed sDbType string constant.
77668>>>>>>>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
77670>>>>>>>>>>>>>        Integer iRetval
77670>>>>>>>>>>>>>        If (sDbType = CS_DbTypeDataFlex) Begin
77672>>>>>>>>>>>>>            Move EN_DbTypeDataFlex to iRetval
77673>>>>>>>>>>>>>        End
77673>>>>>>>>>>>>>>
77673>>>>>>>>>>>>>        If (sDbType = CS_dbTypeMSSQL) Begin
77675>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77676>>>>>>>>>>>>>        End
77676>>>>>>>>>>>>>>
77676>>>>>>>>>>>>>        If (sDbType = CS_dbTypeMySQL) Begin
77678>>>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
77679>>>>>>>>>>>>>        End
77679>>>>>>>>>>>>>>
77679>>>>>>>>>>>>>        If (sDbType = CS_dbTypeOracle) Begin
77681>>>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
77682>>>>>>>>>>>>>        End
77682>>>>>>>>>>>>>>
77682>>>>>>>>>>>>>        If (sDbType = CS_dbTypeDB2) Begin
77684>>>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
77685>>>>>>>>>>>>>        End
77685>>>>>>>>>>>>>>
77685>>>>>>>>>>>>>        If (sDbType = CS_dbTypePostgre) Begin
77687>>>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
77688>>>>>>>>>>>>>        End
77688>>>>>>>>>>>>>>
77688>>>>>>>>>>>>>        If (sDbType = CS_DbTypePervasive) Begin
77690>>>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
77691>>>>>>>>>>>>>        End
77691>>>>>>>>>>>>>>
77691>>>>>>>>>>>>>        Function_Return iRetval
77692>>>>>>>>>>>>>    End_Function
77693>>>>>>>>>>>>>
77693>>>>>>>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
77693>>>>>>>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
77693>>>>>>>>>>>>>    // the SQL Connection program's grid.
77693>>>>>>>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
77695>>>>>>>>>>>>>        String sRetval
77695>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
77697>>>>>>>>>>>>>            Move "EN_dbTypeMSSQL" to sRetval
77698>>>>>>>>>>>>>        End
77698>>>>>>>>>>>>>>
77698>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
77700>>>>>>>>>>>>>            Move "EN_dbTypeMySQL" to sRetval
77701>>>>>>>>>>>>>        End
77701>>>>>>>>>>>>>>
77701>>>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
77703>>>>>>>>>>>>>            Move "EN_dbTypeOracle" to sRetval
77704>>>>>>>>>>>>>        End
77704>>>>>>>>>>>>>>
77704>>>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
77706>>>>>>>>>>>>>            Move "EN_dbTypeDB2" to sRetval
77707>>>>>>>>>>>>>        End
77707>>>>>>>>>>>>>>
77707>>>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
77709>>>>>>>>>>>>>            Move "EN_dbTypePostgre" to sRetval
77710>>>>>>>>>>>>>        End
77710>>>>>>>>>>>>>>
77710>>>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
77712>>>>>>>>>>>>>            Move "EN_dbTypePervasive" to sRetval
77713>>>>>>>>>>>>>        End
77713>>>>>>>>>>>>>>
77713>>>>>>>>>>>>>        Function_Return sRetval
77714>>>>>>>>>>>>>    End_Function
77715>>>>>>>>>>>>>
77715>>>>>>>>>>>>>    // Pass a driver id and the function will return
77715>>>>>>>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
77715>>>>>>>>>>>>>    // quite work and always returns "MS SQL Server"
77715>>>>>>>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
77717>>>>>>>>>>>>>        Integer iRetval
77717>>>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
77719>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77720>>>>>>>>>>>>>        End
77720>>>>>>>>>>>>>>
77720>>>>>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
77722>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77723>>>>>>>>>>>>>        End
77723>>>>>>>>>>>>>>
77723>>>>>>>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
77725>>>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
77726>>>>>>>>>>>>>        End
77726>>>>>>>>>>>>>>
77726>>>>>>>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
77728>>>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
77729>>>>>>>>>>>>>        End
77729>>>>>>>>>>>>>>
77729>>>>>>>>>>>>>        Function_Return iRetval
77730>>>>>>>>>>>>>    End_Function
77731>>>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
77731>>>>>>>>>>>>>>
77731>>>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
77733>>>>>>>>>>>>>>    Integer iStart iEnd
77733>>>>>>>>>>>>>>    String sRetval
77733>>>>>>>>>>>>>>
77733>>>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
77734>>>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
77735>>>>>>>>>>>>>>    If (iStart = 0) Begin
77737>>>>>>>>>>>>>>        Function_Return ""
77738>>>>>>>>>>>>>>    End
77738>>>>>>>>>>>>>>>
77738>>>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
77739>>>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
77740>>>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
77742>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77743>>>>>>>>>>>>>>    End
77743>>>>>>>>>>>>>>>
77743>>>>>>>>>>>>>>    Else Begin
77744>>>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
77745>>>>>>>>>>>>>>    End
77745>>>>>>>>>>>>>>>
77745>>>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
77747>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77748>>>>>>>>>>>>>>        Decrement iEnd
77749>>>>>>>>>>>>>>    End
77749>>>>>>>>>>>>>>>
77749>>>>>>>>>>>>>>    If (iEnd <> 0) Begin
77751>>>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
77752>>>>>>>>>>>>>>    End
77752>>>>>>>>>>>>>>>
77752>>>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
77753>>>>>>>>>>>>>>
77753>>>>>>>>>>>>>>    Function_Return (Trim(sRetval))
77754>>>>>>>>>>>>>>End_Function
77755>>>>>>>>>>>>>>
77755>>>>>>>>>>>>>>
77755>>>>>>>>>>>>>
77755>>>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77757>>>>>>>>>>>>>        String sConnect
77757>>>>>>>>>>>>>        Handle hoDriver
77757>>>>>>>>>>>>>
77757>>>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver 
77758>>>>>>>>>>>>>        Set Name of hoDriver to "oDbUpdateDatabaseDriver"
77759>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
77760>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
77761>>>>>>>>>>>>>        Send Destroy of hoDriver
77762>>>>>>>>>>>>>
77762>>>>>>>>>>>>>        Function_Return sConnect
77763>>>>>>>>>>>>>    End_Function
77764>>>>>>>>>>>>>
77764>>>>>>>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
77764>>>>>>>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
77766>>>>>>>>>>>>>        String sConnect
77766>>>>>>>>>>>>>
77766>>>>>>>>>>>>>        Case Begin
77766>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
77768>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
77769>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77771>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77772>>>>>>>>>>>>>                End
77772>>>>>>>>>>>>>>
77772>>>>>>>>>>>>>                Case Break
77773>>>>>>>>>>>>>
77773>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
77776>>>>>>>>>>>>>                If (Uppercase(sServer) contains ".DSN") Begin
77778>>>>>>>>>>>>>                    Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sConnect
77779>>>>>>>>>>>>>                End
77779>>>>>>>>>>>>>>
77779>>>>>>>>>>>>>                Else If (not(Uppercase(sServer) contains "DSN")) Begin
77782>>>>>>>>>>>>>                    Move (CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77783>>>>>>>>>>>>>                End
77783>>>>>>>>>>>>>>
77783>>>>>>>>>>>>>
77783>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77785>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77786>>>>>>>>>>>>>                End
77786>>>>>>>>>>>>>>
77786>>>>>>>>>>>>>                Case Break
77787>>>>>>>>>>>>>
77787>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
77790>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77791>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77793>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77794>>>>>>>>>>>>>                End
77794>>>>>>>>>>>>>>
77794>>>>>>>>>>>>>                Case Break
77795>>>>>>>>>>>>>
77795>>>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
77798>>>>>>>>>>>>>                Break
77799>>>>>>>>>>>>>
77799>>>>>>>>>>>>>            Case Else
77799>>>>>>>>>>>>>                Move "" to sConnect
77800>>>>>>>>>>>>>        Case End
77800>>>>>>>>>>>>>
77800>>>>>>>>>>>>>        Function_Return sConnect
77801>>>>>>>>>>>>>    End_Function
77802>>>>>>>>>>>>>
77802>>>>>>>>>>>>>    // Use Base64
77802>>>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
77804>>>>>>>>>>>>>        String sRetval
77804>>>>>>>>>>>>>        Handle hoLoginEncryption
77804>>>>>>>>>>>>>
77804>>>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
77805>>>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
77806>>>>>>>>>>>>>        Get EncryptPassword of hoLoginEncryption sPassword to sRetval
77807>>>>>>>>>>>>>        Send Destroy of hoLoginEncryption
77808>>>>>>>>>>>>>          
77808>>>>>>>>>>>>>        Function_Return sRetval
77809>>>>>>>>>>>>>    End_Function
77810>>>>>>>>>>>>>
77810>>>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
77812>>>>>>>>>>>>>        String sRetval
77812>>>>>>>>>>>>>        Handle hoLoginEncryption
77812>>>>>>>>>>>>>
77812>>>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
77813>>>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
77814>>>>>>>>>>>>>        Get DecryptPassword of hoLoginEncryption sPassword to sRetval
77815>>>>>>>>>>>>>        Send Destroy of hoLoginEncryption
77816>>>>>>>>>>>>>
77816>>>>>>>>>>>>>        Function_Return sRetval
77817>>>>>>>>>>>>>    End_Function
77818>>>>>>>>>>>>>
77818>>>>>>>>>>>>>    // Returns the full path of the Application (no trailing "\")
77818>>>>>>>>>>>>>    Function ApplicationPath Returns String
77820>>>>>>>>>>>>>        String sApplicationFileName sPath
77820>>>>>>>>>>>>>        Integer iNumChars iRetval
77820>>>>>>>>>>>>>
77820>>>>>>>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
77821>>>>>>>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
77822>>>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
77823>>>>>>>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
77824>>>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sPath
77825>>>>>>>>>>>>>
77825>>>>>>>>>>>>>        Function_Return sPath
77826>>>>>>>>>>>>>    End_Function
77827>>>>>>>>>>>>>
77827>>>>>>>>>>>>>    // Pass a filename including the extension. The return value
77827>>>>>>>>>>>>>    // will be the path of of the first found "sSearchFileName in the workspace.
77827>>>>>>>>>>>>>    // If not found in the workspace it will be search "globally" by the Get_File_Path command.
77827>>>>>>>>>>>>>    Function SearchLocallyThenGloballyForFile String sSearchFileName Returns String
77829>>>>>>>>>>>>>        Boolean bExists
77829>>>>>>>>>>>>>        Handle hoPaths hoIniFile
77829>>>>>>>>>>>>>        String[] asWorkSpaceFiles
77830>>>>>>>>>>>>>        String sProgramsPath sSection sFileName sRelativePath sRelativePaths sPath sDirSep sProgramsDir
77830>>>>>>>>>>>>>        Integer iSize iCount iPath iNoOfPaths iCountPath
77830>>>>>>>>>>>>>        
77830>>>>>>>>>>>>>        Get psIniFilePath to sProgramsPath
77831>>>>>>>>>>>>>        Get vFolderFormat sProgramsPath to sProgramsPath 
77832>>>>>>>>>>>>>        Move (Lowercase(sSearchFileName)) to sSearchFileName
77833>>>>>>>>>>>>>        Get vFilePathExists (sProgramsPath + sSearchFileName) to bExists   
77834>>>>>>>>>>>>>        If (bExists = True) Begin
77836>>>>>>>>>>>>>            Function_Return sProgramsPath
77837>>>>>>>>>>>>>        End                      
77837>>>>>>>>>>>>>>
77837>>>>>>>>>>>>>    
77837>>>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
77838>>>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
77840>>>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
77841>>>>>>>>>>>>>        End                                              
77841>>>>>>>>>>>>>>
77841>>>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sProgramsDir
77842>>>>>>>>>>>>>        
77842>>>>>>>>>>>>>        Move False to bExists
77843>>>>>>>>>>>>>        Get Create (RefClass(Array)) to hoPaths
77844>>>>>>>>>>>>>        Get WorkspaceIniFiles sProgramsPath to asWorkspaceFiles
77845>>>>>>>>>>>>>        Move (SizeOfArray(asWorkspaceFiles)) to iSize
77846>>>>>>>>>>>>>        Decrement iSize       
77847>>>>>>>>>>>>>        
77847>>>>>>>>>>>>>        For iCount from 0 to iSize
77853>>>>>>>>>>>>>>
77853>>>>>>>>>>>>>            Move asWorkspaceFiles[iCount] to sFileName
77854>>>>>>>>>>>>>            Get Create (Refclass(cIniFile)) to hoIniFile
77855>>>>>>>>>>>>>            Set psFileName of hoIniFile to sFileName
77856>>>>>>>>>>>>>            Send ReadSection of hoIniFile "Workspace" hoPaths
77857>>>>>>>>>>>>>            For iPath from 0 to (Item_Count(hoPaths) -1)
77863>>>>>>>>>>>>>>
77863>>>>>>>>>>>>>                Get Value of hoPaths iPath to sSection    
77864>>>>>>>>>>>>>                Get ReadString of hoIniFile "Workspace" sSection "" to sRelativePath 
77865>>>>>>>>>>>>>                // Check if there are more than one path specified;
77865>>>>>>>>>>>>>                Get CountOfPaths of (phoWorkspace(ghoApplication)) sRelativePath to iNoOfPaths
77866>>>>>>>>>>>>>                If (iNoOfPaths > 1) Begin         
77868>>>>>>>>>>>>>                    Move sRelativePath to sRelativePaths
77869>>>>>>>>>>>>>                    For iCountPath from 1 to iNoOfPaths
77875>>>>>>>>>>>>>>
77875>>>>>>>>>>>>>                        Get PathAtIndex of (phoWorkspace(ghoApplication)) sRelativePaths iCountPath to sRelativePath
77876>>>>>>>>>>>>>                        Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
77877>>>>>>>>>>>>>                        Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
77878>>>>>>>>>>>>>                        Get vFolderFormat sPath to sPath
77879>>>>>>>>>>>>>                        Get vFilePathExists (sPath + sSearchFileName) to bExists
77880>>>>>>>>>>>>>                        If (bExists = True) Begin
77882>>>>>>>>>>>>>                            Move iNoOfPaths to iCountPath
77883>>>>>>>>>>>>>                            Move (Item_Count(hoPaths)) to iPath // We're done.
77884>>>>>>>>>>>>>                            Move iSize to iCount
77885>>>>>>>>>>>>>                        End                                                    
77885>>>>>>>>>>>>>>
77885>>>>>>>>>>>>>                    Loop
77886>>>>>>>>>>>>>>
77886>>>>>>>>>>>>>                End
77886>>>>>>>>>>>>>>
77886>>>>>>>>>>>>>                Else Begin
77887>>>>>>>>>>>>>                    Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
77888>>>>>>>>>>>>>                    Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
77889>>>>>>>>>>>>>                    Get vFolderFormat sPath to sPath
77890>>>>>>>>>>>>>                    Get vFilePathExists (sPath + sSearchFileName) to bExists
77891>>>>>>>>>>>>>                    If (bExists = True) Begin
77893>>>>>>>>>>>>>                        Move (Item_Count(hoPaths)) to iPath // We're done.
77894>>>>>>>>>>>>>                        Move iSize to iCount
77895>>>>>>>>>>>>>                    End                                                    
77895>>>>>>>>>>>>>>
77895>>>>>>>>>>>>>                End
77895>>>>>>>>>>>>>>
77895>>>>>>>>>>>>>            Loop
77896>>>>>>>>>>>>>>
77896>>>>>>>>>>>>>            If (bExists = False) Begin
77898>>>>>>>>>>>>>                Move "" to sPath    
77899>>>>>>>>>>>>>            End
77899>>>>>>>>>>>>>>
77899>>>>>>>>>>>>>            Send Destroy of hoIniFile          
77900>>>>>>>>>>>>>        Loop        
77901>>>>>>>>>>>>>>
77901>>>>>>>>>>>>>        Send Destroy of hoPaths
77902>>>>>>>>>>>>>        
77902>>>>>>>>>>>>>        // Then not found in workspace, look for the file in DFSysPath;
77902>>>>>>>>>>>>>        If (sPath = "") Begin
77904>>>>>>>>>>>>>            Get_File_Path sSearchFileName to sFileName   
77905>>>>>>>>>>>>>            Get ParseFolderName sFileName to sPath
77906>>>>>>>>>>>>>        End                  
77906>>>>>>>>>>>>>>
77906>>>>>>>>>>>>>        
77906>>>>>>>>>>>>>        Function_Return sPath    
77907>>>>>>>>>>>>>    End_Function
77908>>>>>>>>>>>>>    
77908>>>>>>>>>>>>>    // Pass the path to the workspace Programs folder - returns a string array
77908>>>>>>>>>>>>>    // with one or more .ws file names.
77908>>>>>>>>>>>>>    // First checks if there is a .sws file - and if so reads the name of the
77908>>>>>>>>>>>>>    // workspace file (.ws) and returns it as a string array.
77908>>>>>>>>>>>>>    // If _no_ .sws file is found, enumerates the passed sProgramsPath variable
77908>>>>>>>>>>>>>    Function WorkspaceIniFiles String sProgramsPath Returns String[]
77910>>>>>>>>>>>>>        String[] asSWSFiles asWorkspaceFiles   
77912>>>>>>>>>>>>>        String sFile sHomePath sDirSep
77912>>>>>>>>>>>>>        Integer iCh iSize
77912>>>>>>>>>>>>>        Boolean bExists      
77912>>>>>>>>>>>>>        Handle hoIniFile 
77912>>>>>>>>>>>>>        
77912>>>>>>>>>>>>>        Move (ResizeArray(asSWSFiles, 0)) to asSWSFiles
77913>>>>>>>>>>>>>        Move (ResizeArray(asWorkspaceFiles, 0)) to asWorkspaceFiles
77914>>>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
77916>>>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
77917>>>>>>>>>>>>>        End                                              
77917>>>>>>>>>>>>>>
77917>>>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
77918>>>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sHomePath
77919>>>>>>>>>>>>>        Move (Replace(sHomePath, sProgramsPath, "")) to sHomePath
77920>>>>>>>>>>>>>        Get vFolderFormat sHomePath to sHomePath 
77921>>>>>>>>>>>>>        
77921>>>>>>>>>>>>>        // First check if theres an .sws file. If there is we will open it and
77921>>>>>>>>>>>>>        // read the name of the .ws file name.
77921>>>>>>>>>>>>>        File_Exist (sHomePath + "*.sws") bExists
77922>>>>>>>>>>>>>        If (bExists = True) Begin
77924>>>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sHomePath + "*.sws") to iCh
77925>>>>>>>>>>>>>            If (iCh < 0) Begin
77927>>>>>>>>>>>>>                Function_Return asSWSFiles
77928>>>>>>>>>>>>>            End                                 
77928>>>>>>>>>>>>>>
77928>>>>>>>>>>>>>            
77928>>>>>>>>>>>>>            Repeat
77928>>>>>>>>>>>>>>
77928>>>>>>>>>>>>>                Readln channel iCh sFile
77930>>>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
77932>>>>>>>>>>>>>                    Move sFile to asSWSFiles[SizeOfArray(asSWSFiles)]
77933>>>>>>>>>>>>>                End
77933>>>>>>>>>>>>>>
77933>>>>>>>>>>>>>            Until (SeqEof = True)
77935>>>>>>>>>>>>>            Send Seq_Close_Channel iCh    
77936>>>>>>>>>>>>>            
77936>>>>>>>>>>>>>            Move (SizeOfArray(asSWSFiles)) to iSize
77937>>>>>>>>>>>>>            If (iSize <> 0) Begin
77939>>>>>>>>>>>>>                Get Create (RefClass(cIniFile)) to hoIniFile  
77940>>>>>>>>>>>>>                // Use the file with that is last as it might have the DataFlex version in it,
77940>>>>>>>>>>>>>                // and thus is the latest one and it is more likely it is accurate (?)...
77940>>>>>>>>>>>>>                Move asSWSFiles[SizeOfArray(asSWSFiles) -1] to sFile
77941>>>>>>>>>>>>>                Set psFileName of hoIniFile to (sHomePath + sFile)
77942>>>>>>>>>>>>>                Get ReadString of hoIniFile "WorkspacePaths" "ConfigFile" "" to sFile
77943>>>>>>>>>>>>>                If (sFile <> "") Begin
77945>>>>>>>>>>>>>                    Move (Replace(".", sFile, sHomePath)) to sFile
77946>>>>>>>>>>>>>                    Move (Replace((sDirSep + String(sDirSep)), sFile, sDirSep)) to sFile
77947>>>>>>>>>>>>>                    File_Exist sFile bExists
77948>>>>>>>>>>>>>                    If (bExists = True) Begin
77950>>>>>>>>>>>>>                        Move sFile to asWorkspaceFiles[0] 
77951>>>>>>>>>>>>>                    End
77951>>>>>>>>>>>>>>
77951>>>>>>>>>>>>>                End
77951>>>>>>>>>>>>>>
77951>>>>>>>>>>>>>                Send Destroy of hoIniFile
77952>>>>>>>>>>>>>            End
77952>>>>>>>>>>>>>>
77952>>>>>>>>>>>>>        End
77952>>>>>>>>>>>>>>
77952>>>>>>>>>>>>>        
77952>>>>>>>>>>>>>        // If no .sws file exists, enumerate the .ws files from the Programs folder:    
77952>>>>>>>>>>>>>        If (SizeOfArray(asWorkspaceFiles) = 0) Begin
77954>>>>>>>>>>>>>            Get vFolderFormat sProgramsPath to sProgramsPath 
77955>>>>>>>>>>>>>            File_Exist (sProgramsPath + "*.ws") bExists
77956>>>>>>>>>>>>>            If (bExists = False) Begin
77958>>>>>>>>>>>>>                Function_Return asWorkspaceFiles
77959>>>>>>>>>>>>>            End
77959>>>>>>>>>>>>>>
77959>>>>>>>>>>>>>        
77959>>>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sProgramsPath + "*.ws") to iCh
77960>>>>>>>>>>>>>            If (iCh < 0) Begin
77962>>>>>>>>>>>>>                Function_Return asWorkspaceFiles
77963>>>>>>>>>>>>>            End                                 
77963>>>>>>>>>>>>>>
77963>>>>>>>>>>>>>            
77963>>>>>>>>>>>>>            Repeat
77963>>>>>>>>>>>>>>
77963>>>>>>>>>>>>>                Readln channel iCh sFile
77965>>>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
77967>>>>>>>>>>>>>                    Move sFile to asWorkspaceFiles[SizeOfArray(asWorkspaceFiles)]
77968>>>>>>>>>>>>>                End
77968>>>>>>>>>>>>>>
77968>>>>>>>>>>>>>            Until (SeqEof = True)
77970>>>>>>>>>>>>>            Send Seq_Close_Channel iCh
77971>>>>>>>>>>>>>        End
77971>>>>>>>>>>>>>>
77971>>>>>>>>>>>>>        
77971>>>>>>>>>>>>>        Function_Return asWorkspaceFiles
77972>>>>>>>>>>>>>    End_Function
77973>>>>>>>>>>>>>
77973>>>>>>>>>>>>>End_Class
77974>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
77974>>>>>>>>>>>Use vWin32fh.pkg
77974>>>>>>>>>>>
77974>>>>>>>>>>>// The cConnection class is the new SQL connections class for DF 19.
77974>>>>>>>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
77974>>>>>>>>>>>
77974>>>>>>>>>>>// We're making references to this object handle so we need it defined
77974>>>>>>>>>>>// here as well as for the cDbUpdateHandler class
77974>>>>>>>>>>>
77974>>>>>>>>>>>    Global_Variable Handle ghoSQLConnectionHandler
77974>>>>>>>>>>>    Move 0 to ghoSQLConnectionHandler
77975>>>>>>>>>>>
77975>>>>>>>>>>>Class cSQLConnectionHandler is a cObject
77976>>>>>>>>>>>
77976>>>>>>>>>>>    Procedure Construct_Object
77978>>>>>>>>>>>        Handle ho
77978>>>>>>>>>>>        Forward Send Construct_Object
77980>>>>>>>>>>>        Move Self to ghoSQLConnectionHandler
77981>>>>>>>>>>>
77981>>>>>>>>>>>        Property Handle phoSQLConnectionIniFile 
77982>>>>>>>>>>>        Get  Create (RefClass(cSQLConnectionIniFile)) to ho
77983>>>>>>>>>>>        Set Name of ho to "oSQLConnectionIniFile"
77984>>>>>>>>>>>        Set phoSQLConnectionIniFile to ho
77985>>>>>>>>>>>        
77985>>>>>>>>>>>
77985>>>>>>>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
77985>>>>>>>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
77985>>>>>>>>>>>        // methods to this class.
77985>>>>>>>>>>>        Property Boolean pbUseConnectionID True
77986>>>>>>>>>>>        Property Boolean pbToANSI          True
77987>>>>>>>>>>>        Property Boolean pbRecnum          True
77988>>>>>>>>>>>        Property Boolean pbCopyData        True
77989>>>>>>>>>>>        Property Boolean pbApiTableUpdateAuto    False
77990>>>>>>>>>>>        Property Boolean pbCompareDate_DateTime  False
77991>>>>>>>>>>>        Property Boolean pbCompareIndexAscending False
77992>>>>>>>>>>>        Property Boolean pbCompareIndexUppercase False
77993>>>>>>>>>>>
77993>>>>>>>>>>>        // Driver default value settings:
77993>>>>>>>>>>>        // Note: When the object is created the corresponding values
77993>>>>>>>>>>>        // from the driver .int files are read.
77993>>>>>>>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
77993>>>>>>>>>>>        Property String psDriverDefaultValueASCII    ""
77994>>>>>>>>>>>        Property String psDriverDefaultValueBinary   ""
77995>>>>>>>>>>>        Property String psDriverDefaultValueDate     ""
77996>>>>>>>>>>>        Property String psDriverDefaultValueDateTime ""
77997>>>>>>>>>>>        Property String psDriverDefaultValueNumeric  ""
77998>>>>>>>>>>>        Property String psDriverDefaultValueText     ""
77999>>>>>>>>>>>
77999>>>>>>>>>>>        // Driver "nullability" settings:
77999>>>>>>>>>>>        // Note: When the object is created the corresponding values
77999>>>>>>>>>>>        // from the driver .int files are read.
77999>>>>>>>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
77999>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
78000>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
78001>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableDate     False
78002>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
78003>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
78004>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableText     False
78005>>>>>>>>>>>
78005>>>>>>>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
78005>>>>>>>>>>>        //     It is private because the get/set version also updates the DAW
78005>>>>>>>>>>>        //     driver interfaces.
78005>>>>>>>>>>>        //     There are also procedure/function pairs to set/get individual data members
78005>>>>>>>>>>>        //     of the struct they are all routed throu this struct property.
78005>>>>>>>>>>>        Property tSQLConnection Private.pSQLConnection
78006>>>>>>>>>>>
78006>>>>>>>>>>>    End_Procedure
78007>>>>>>>>>>>
78007>>>>>>>>>>>    Procedure End_Construct_Object
78009>>>>>>>>>>>        tSQLConnection SQLConnection
78009>>>>>>>>>>>        tSQLConnection SQLConnection
78009>>>>>>>>>>>
78009>>>>>>>>>>>        Forward Send End_Construct_Object
78011>>>>>>>>>>>
78011>>>>>>>>>>>        // Now is the time to read and apply SQL connection settings.
78011>>>>>>>>>>>        Get SetupSQLConnection True True to SQLConnection
78012>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78013>>>>>>>>>>>    End_Procedure
78014>>>>>>>>>>>
78014>>>>>>>>>>>    // *** Properties ***
78014>>>>>>>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
78014>>>>>>>>>>>    // private.pSQLConnection struct connection property. These "properties" are
78014>>>>>>>>>>>    // merely here for conveniance.
78014>>>>>>>>>>>    //
78014>>>>>>>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
78014>>>>>>>>>>>    // where we update data to/from the DAW driver interfaces and this framework.
78014>>>>>>>>>>>    // This struct property contains all the connection data.
78014>>>>>>>>>>>    //
78014>>>>>>>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
78016>>>>>>>>>>>        Boolean bOK
78016>>>>>>>>>>>
78016>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78017>>>>>>>>>>>
78017>>>>>>>>>>>        // When starting a program we might not have a connection id yet:
78017>>>>>>>>>>>        If (SQLConnection.sDriverID = DATAFLEX_ID) Begin
78019>>>>>>>>>>>//        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
78019>>>>>>>>>>>            Procedure_Return
78020>>>>>>>>>>>        End
78020>>>>>>>>>>>>
78020>>>>>>>>>>>
78020>>>>>>>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
78020>>>>>>>>>>>        // be logged in already and don't want to do it again.
78020>>>>>>>>>>>        If (SQLConnection.bDAWConnection = False) Begin
78022>>>>>>>>>>>            // After we have set the class property we need to tell the DAW
78022>>>>>>>>>>>            // driver interfaces about the change & make a new login.
78022>>>>>>>>>>>            Get SQLLogin SQLConnection to bOK
78023>>>>>>>>>>>            If (bOK = False) Begin
78025>>>>>>>>>>>                Error DFERR_PROGRAM "Login error."
78026>>>>>>>>>>>>
78026>>>>>>>>>>>            End
78026>>>>>>>>>>>>
78026>>>>>>>>>>>        End
78026>>>>>>>>>>>>
78026>>>>>>>>>>>
78026>>>>>>>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
78026>>>>>>>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
78027>>>>>>>>>>>
78027>>>>>>>>>>>    End_Procedure
78028>>>>>>>>>>>
78028>>>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
78028>>>>>>>>>>>    // attempt to load the driver.
78028>>>>>>>>>>>    // Returns true if the passed driver is SQL based.
78028>>>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
78030>>>>>>>>>>>        Boolean bOK
78030>>>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
78031>>>>>>>>>>>        Function_Return bOK
78032>>>>>>>>>>>    End_Function
78033>>>>>>>>>>>
78033>>>>>>>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
78033>>>>>>>>>>>    Procedure SetupDriverDefaults String sDriverID
78035>>>>>>>>>>>        String sAttributeValue sServer
78035>>>>>>>>>>>        Integer iDriverID
78035>>>>>>>>>>>        Boolean bNULL bSQLDriver
78035>>>>>>>>>>>        Handle hDatabase
78035>>>>>>>>>>>        
78035>>>>>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
78036>>>>>>>>>>>        If (bSQLDriver = False) Begin
78038>>>>>>>>>>>            Procedure_Return
78039>>>>>>>>>>>        End                                      
78039>>>>>>>>>>>>
78039>>>>>>>>>>>        
78039>>>>>>>>>>>        Get DriverIndex sDriverID to iDriverID  
78040>>>>>>>>>>>        
78040>>>>>>>>>>>        // ToDo: Testing!
78040>>>>>>>>>>>//        Get psServer of ghoDbUpdateFunctionLibrary to sServer
78040>>>>>>>>>>>//        Get SqlUtilDatabaseHandle of ghoDbUpdateFunctionLibrary sDriverID sServer to hDatabase
78040>>>>>>>>>>>//        Set_Attribute DF_DATABASE_IGNORE_WARNINGS of iDriverID hDatabase to True 
78040>>>>>>>>>>>
78040>>>>>>>>>>>        // Driver default values for various data types:
78040>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
78043>>>>>>>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
78044>>>>>>>>>>>
78044>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
78047>>>>>>>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
78048>>>>>>>>>>>
78048>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
78051>>>>>>>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
78052>>>>>>>>>>>
78052>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
78055>>>>>>>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
78056>>>>>>>>>>>
78056>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
78059>>>>>>>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
78060>>>>>>>>>>>
78060>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
78063>>>>>>>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
78064>>>>>>>>>>>
78064>>>>>>>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
78064>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
78067>>>>>>>>>>>        Set pbDriverDefaultNullableASCII to bNULL
78068>>>>>>>>>>>
78068>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
78071>>>>>>>>>>>        Set pbDriverDefaultNullableBinary to bNULL
78072>>>>>>>>>>>
78072>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
78075>>>>>>>>>>>        Set pbDriverDefaultNullableDate to bNULL
78076>>>>>>>>>>>
78076>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
78079>>>>>>>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
78080>>>>>>>>>>>
78080>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
78083>>>>>>>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
78084>>>>>>>>>>>
78084>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
78087>>>>>>>>>>>        Set pbDriverDefaultNullableText to bNULL
78088>>>>>>>>>>>
78088>>>>>>>>>>>    End_Procedure
78089>>>>>>>>>>>
78089>>>>>>>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
78091>>>>>>>>>>>        Boolean bOK bIsDaw
78091>>>>>>>>>>>        String sConnectionString
78091>>>>>>>>>>>        Handle hoErrorObj hoDriver hoIniFile
78091>>>>>>>>>>>        Integer iDriverID
78091>>>>>>>>>>>
78091>>>>>>>>>>>        Move False to bOK
78092>>>>>>>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
78093>>>>>>>>>>>
78093>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78094>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
78095>>>>>>>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
78096>>>>>>>>>>>        If (iDriverID = 0) Begin
78098>>>>>>>>>>>            Move hoErrorObj to Error_Object_Id
78099>>>>>>>>>>>            Function_Return False
78100>>>>>>>>>>>        End
78100>>>>>>>>>>>>
78100>>>>>>>>>>>
78100>>>>>>>>>>>        Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
78103>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
78104>>>>>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
78105>>>>>>>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
78106>>>>>>>>>>>        Send Destroy   of hoDriver
78107>>>>>>>>>>>
78107>>>>>>>>>>>        Function_Return bOK
78108>>>>>>>>>>>    End_Function
78109>>>>>>>>>>>
78109>>>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
78111>>>>>>>>>>>        tSQLConnection SQLConnection
78111>>>>>>>>>>>        tSQLConnection SQLConnection
78111>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78112>>>>>>>>>>>        Function_Return SQLConnection
78113>>>>>>>>>>>    End_Function
78114>>>>>>>>>>>
78114>>>>>>>>>>>    Procedure Set psConnectionID String sValue
78116>>>>>>>>>>>        tSQLConnection SQLConnection
78116>>>>>>>>>>>        tSQLConnection SQLConnection
78116>>>>>>>>>>>
78116>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78117>>>>>>>>>>>        If (SQLConnection.sConnectionID = "") Begin
78119>>>>>>>>>>>            Move sValue to SQLConnection.sConnectionID
78120>>>>>>>>>>>        End
78120>>>>>>>>>>>>
78120>>>>>>>>>>>
78120>>>>>>>>>>>        // Else we might want to change the current connection ID
78120>>>>>>>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
78123>>>>>>>>>>>            Move False to Err
78124>>>>>>>>>>>            Logout SQLConnection.sDriverID
78125>>>>>>>>>>>            // This will also make a login to the new server.
78125>>>>>>>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
78126>>>>>>>>>>>        End
78126>>>>>>>>>>>>
78126>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78127>>>>>>>>>>>    End_Procedure
78128>>>>>>>>>>>
78128>>>>>>>>>>>    Function psConnectionID Returns String
78130>>>>>>>>>>>        tSQLConnection SQLConnection
78130>>>>>>>>>>>        tSQLConnection SQLConnection
78130>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78131>>>>>>>>>>>        Function_Return SQLConnection.sConnectionID
78132>>>>>>>>>>>    End_Function
78133>>>>>>>>>>>
78133>>>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
78133>>>>>>>>>>>    //       the psDriverID *must* be the first property that is changed!
78133>>>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
78133>>>>>>>>>>>    //       for a connection string has the wrong format for that driver.
78133>>>>>>>>>>>    Procedure Set psDriverID String sValue
78135>>>>>>>>>>>        tSQLConnection SQLConnection
78135>>>>>>>>>>>        tSQLConnection SQLConnection
78135>>>>>>>>>>>        Get pSQLConnection to SQLConnection
78136>>>>>>>>>>>        Move sValue        to SQLConnection.sDriverID
78137>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78138>>>>>>>>>>>        If (sValue <> DATAFLEX_ID) Begin
78140>>>>>>>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78141>>>>>>>>>>>        End
78141>>>>>>>>>>>>
78141>>>>>>>>>>>    End_Procedure
78142>>>>>>>>>>>
78142>>>>>>>>>>>    Function psDriverID Returns String
78144>>>>>>>>>>>        tSQLConnection SQLConnection
78144>>>>>>>>>>>        tSQLConnection SQLConnection
78144>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78145>>>>>>>>>>>        If (SQLConnection.sDriverID = "") Begin
78147>>>>>>>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
78148>>>>>>>>>>>        End
78148>>>>>>>>>>>>
78148>>>>>>>>>>>        Function_Return SQLConnection.sDriverID
78149>>>>>>>>>>>    End_Function
78150>>>>>>>>>>>
78150>>>>>>>>>>>    Procedure Set psConnectionString String sValue
78152>>>>>>>>>>>        tSQLConnection SQLConnection
78152>>>>>>>>>>>        tSQLConnection SQLConnection
78152>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78153>>>>>>>>>>>        Move sValue        to SQLConnection.sConnectionString
78154>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78155>>>>>>>>>>>    End_Procedure
78156>>>>>>>>>>>
78156>>>>>>>>>>>    Function psConnectionString Returns String
78158>>>>>>>>>>>        tSQLConnection SQLConnection
78158>>>>>>>>>>>        tSQLConnection SQLConnection
78158>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78159>>>>>>>>>>>        Function_Return SQLConnection.sConnectionString
78160>>>>>>>>>>>    End_Function
78161>>>>>>>>>>>
78161>>>>>>>>>>>    Procedure Set psServer String sValue
78163>>>>>>>>>>>        tSQLConnection SQLConnection
78163>>>>>>>>>>>        tSQLConnection SQLConnection
78163>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78164>>>>>>>>>>>        Move sValue        to SQLConnection.sServer
78165>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78166>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78167>>>>>>>>>>>    End_Procedure
78168>>>>>>>>>>>
78168>>>>>>>>>>>    Function psServer Returns String
78170>>>>>>>>>>>        tSQLConnection SQLConnection
78170>>>>>>>>>>>        tSQLConnection SQLConnection
78170>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78171>>>>>>>>>>>        Function_Return SQLConnection.sServer
78172>>>>>>>>>>>    End_Function
78173>>>>>>>>>>>
78173>>>>>>>>>>>    Procedure Set psDatabase String sValue
78175>>>>>>>>>>>        tSQLConnection SQLConnection
78175>>>>>>>>>>>        tSQLConnection SQLConnection
78175>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78176>>>>>>>>>>>        Move sValue        to SQLConnection.sDatabase
78177>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78178>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78179>>>>>>>>>>>    End_Procedure
78180>>>>>>>>>>>
78180>>>>>>>>>>>    Function psDatabase Returns String
78182>>>>>>>>>>>        tSQLConnection SQLConnection
78182>>>>>>>>>>>        tSQLConnection SQLConnection
78182>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78183>>>>>>>>>>>        Function_Return SQLConnection.sDatabase
78184>>>>>>>>>>>    End_Function
78185>>>>>>>>>>>
78185>>>>>>>>>>>    Procedure Set psUserID String sValue
78187>>>>>>>>>>>        tSQLConnection SQLConnection
78187>>>>>>>>>>>        tSQLConnection SQLConnection
78187>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78188>>>>>>>>>>>        Move sValue        to SQLConnection.sUserID
78189>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78190>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78191>>>>>>>>>>>    End_Procedure
78192>>>>>>>>>>>
78192>>>>>>>>>>>    Function psUserID Returns String
78194>>>>>>>>>>>        tSQLConnection SQLConnection
78194>>>>>>>>>>>        tSQLConnection SQLConnection
78194>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78195>>>>>>>>>>>        Function_Return SQLConnection.sUserID
78196>>>>>>>>>>>    End_Function
78197>>>>>>>>>>>
78197>>>>>>>>>>>    // This is the uncrypted password
78197>>>>>>>>>>>    Procedure Set psPassword String sValue
78199>>>>>>>>>>>        tSQLConnection SQLConnection
78199>>>>>>>>>>>        tSQLConnection SQLConnection
78199>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78200>>>>>>>>>>>        Move sValue        to SQLConnection.sPassword
78201>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78202>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78203>>>>>>>>>>>    End_Procedure
78204>>>>>>>>>>>
78204>>>>>>>>>>>    Function psPassword Returns String
78206>>>>>>>>>>>        tSQLConnection SQLConnection
78206>>>>>>>>>>>        tSQLConnection SQLConnection
78206>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78207>>>>>>>>>>>        Function_Return SQLConnection.sPassword
78208>>>>>>>>>>>    End_Function
78209>>>>>>>>>>>
78209>>>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
78211>>>>>>>>>>>        tSQLConnection SQLConnection
78211>>>>>>>>>>>        tSQLConnection SQLConnection
78211>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78212>>>>>>>>>>>        Move bValue        to SQLConnection.bTrusted
78213>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78214>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78215>>>>>>>>>>>    End_Procedure
78216>>>>>>>>>>>
78216>>>>>>>>>>>    Function pbTrusted Returns Boolean
78218>>>>>>>>>>>        tSQLConnection SQLConnection
78218>>>>>>>>>>>        tSQLConnection SQLConnection
78218>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78219>>>>>>>>>>>        Function_Return SQLConnection.bTrusted
78220>>>>>>>>>>>    End_Function
78221>>>>>>>>>>>
78221>>>>>>>>>>>    // *** All of these properties are special to the Database Update Framework ***
78221>>>>>>>>>>>    //     Thus they are not propagated to the DAW classes and that is why
78221>>>>>>>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
78221>>>>>>>>>>>    //     the central pSQLConnection "hub".
78221>>>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
78223>>>>>>>>>>>        tSQLConnection SQLConnection
78223>>>>>>>>>>>        tSQLConnection SQLConnection
78223>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78224>>>>>>>>>>>        Move bValue to SQLConnection.bTrusted
78225>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78226>>>>>>>>>>>    End_Procedure
78227>>>>>>>>>>>
78227>>>>>>>>>>>    Function pbSilentLogin Returns Boolean
78229>>>>>>>>>>>        tSQLConnection SQLConnection
78229>>>>>>>>>>>        tSQLConnection SQLConnection
78229>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78230>>>>>>>>>>>        Function_Return SQLConnection.bSilentLogin
78231>>>>>>>>>>>    End_Function
78232>>>>>>>>>>>
78232>>>>>>>>>>>    Procedure Set piDbType Integer iValue
78234>>>>>>>>>>>        tSQLConnection SQLConnection
78234>>>>>>>>>>>        tSQLConnection SQLConnection
78234>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78235>>>>>>>>>>>        Move iValue to SQLConnection.iDbType
78236>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78237>>>>>>>>>>>    End_Procedure
78238>>>>>>>>>>>
78238>>>>>>>>>>>    Function piDbType Returns Integer
78240>>>>>>>>>>>        tSQLConnection SQLConnection
78240>>>>>>>>>>>        tSQLConnection SQLConnection
78240>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78241>>>>>>>>>>>        Function_Return SQLConnection.iDbType
78242>>>>>>>>>>>    End_Function
78243>>>>>>>>>>>
78243>>>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
78245>>>>>>>>>>>        tSQLConnection SQLConnection
78245>>>>>>>>>>>        tSQLConnection SQLConnection
78245>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78246>>>>>>>>>>>        Move sValue to SQLConnection.sBaseTableSpace
78247>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78248>>>>>>>>>>>    End_Procedure
78249>>>>>>>>>>>
78249>>>>>>>>>>>    Function psBaseTableSpace Returns String
78251>>>>>>>>>>>        tSQLConnection SQLConnection
78251>>>>>>>>>>>        tSQLConnection SQLConnection
78251>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78252>>>>>>>>>>>        Function_Return SQLConnection.sBaseTableSpace
78253>>>>>>>>>>>    End_Function
78254>>>>>>>>>>>
78254>>>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
78256>>>>>>>>>>>        tSQLConnection SQLConnection
78256>>>>>>>>>>>        tSQLConnection SQLConnection
78256>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78257>>>>>>>>>>>        Move sValue to SQLConnection.sIndexTableSpace
78258>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78259>>>>>>>>>>>    End_Procedure
78260>>>>>>>>>>>
78260>>>>>>>>>>>    Function psIndexTableSpace Returns String
78262>>>>>>>>>>>        tSQLConnection SQLConnection
78262>>>>>>>>>>>        tSQLConnection SQLConnection
78262>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78263>>>>>>>>>>>        Function_Return SQLConnection.sIndexTableSpace
78264>>>>>>>>>>>    End_Function
78265>>>>>>>>>>>
78265>>>>>>>>>>>    Procedure Set psLongTableSpace String sValue
78267>>>>>>>>>>>        tSQLConnection SQLConnection
78267>>>>>>>>>>>        tSQLConnection SQLConnection
78267>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78268>>>>>>>>>>>        Move sValue to SQLConnection.sLongTableSpace
78269>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78270>>>>>>>>>>>    End_Procedure
78271>>>>>>>>>>>
78271>>>>>>>>>>>    Function psLongTableSpace Returns String
78273>>>>>>>>>>>        tSQLConnection SQLConnection
78273>>>>>>>>>>>        tSQLConnection SQLConnection
78273>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78274>>>>>>>>>>>        Function_Return SQLConnection.sLongTableSpace
78275>>>>>>>>>>>    End_Function
78276>>>>>>>>>>>
78276>>>>>>>>>>>    Procedure Set psSchema String sValue
78278>>>>>>>>>>>        tSQLConnection SQLConnection
78278>>>>>>>>>>>        tSQLConnection SQLConnection
78278>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78279>>>>>>>>>>>        Move sValue to SQLConnection.sSchema
78280>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78281>>>>>>>>>>>    End_Procedure
78282>>>>>>>>>>>
78282>>>>>>>>>>>    Function psSchema Returns String
78284>>>>>>>>>>>        tSQLConnection SQLConnection
78284>>>>>>>>>>>        tSQLConnection SQLConnection
78284>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78285>>>>>>>>>>>        Function_Return SQLConnection.sSchema
78286>>>>>>>>>>>    End_Function
78287>>>>>>>>>>>
78287>>>>>>>>>>>    Procedure Set pbEnabled Boolean bValue
78289>>>>>>>>>>>        tSQLConnection SQLConnection
78289>>>>>>>>>>>        tSQLConnection SQLConnection
78289>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78290>>>>>>>>>>>        Move bValue to SQLConnection.bEnabled
78291>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78292>>>>>>>>>>>    End_Procedure
78293>>>>>>>>>>>
78293>>>>>>>>>>>    Function pbEnabled Returns Boolean
78295>>>>>>>>>>>        tSQLConnection SQLConnection
78295>>>>>>>>>>>        tSQLConnection SQLConnection
78295>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78296>>>>>>>>>>>        Function_Return SQLConnection.bEnabled
78297>>>>>>>>>>>    End_Function
78298>>>>>>>>>>>
78298>>>>>>>>>>>
78298>>>>>>>>>>>    // ************************************
78298>>>>>>>>>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
78300>>>>>>>>>>>        tSQLConnection SQLConnection
78300>>>>>>>>>>>        tSQLConnection SQLConnection
78300>>>>>>>>>>>
78300>>>>>>>>>>>        // If this object was created by the cDbUpdateHandler class we will
78300>>>>>>>>>>>        // deferr reading SQL connection values until later.
78300>>>>>>>>>>>        If (bReadDFConnSettings = True) Begin
78302>>>>>>>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
78302>>>>>>>>>>>            If (ghoConnection > 0) Begin
78304>>>>>>>>>>>                Get ReadcConnections to SQLConnection
78305>>>>>>>>>>>            End
78305>>>>>>>>>>>>
78305>>>>>>>>>>>
78305>>>>>>>>>>>            // In addition to the above; there might be other values set even if a cConnection
78305>>>>>>>>>>>            // object is used.
78305>>>>>>>>>>>            If (bReadSQLConnections = True) Begin
78307>>>>>>>>>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
78308>>>>>>>>>>>            End
78308>>>>>>>>>>>>
78308>>>>>>>>>>>        End
78308>>>>>>>>>>>>
78308>>>>>>>>>>>
78308>>>>>>>>>>>        Function_Return SQLConnection
78309>>>>>>>>>>>    End_Function
78310>>>>>>>>>>>
78310>>>>>>>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
78310>>>>>>>>>>>    Function ReadcConnections Returns tSQLConnection
78312>>>>>>>>>>>        tConnection Connection
78312>>>>>>>>>>>        tConnection Connection
78312>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78312>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78312>>>>>>>>>>>        Integer iRetval iDbType
78312>>>>>>>>>>>        Boolean bOK bConnected
78312>>>>>>>>>>>        String sConnectionID
78312>>>>>>>>>>>
78312>>>>>>>>>>>            tConnection[] Connections
78312>>>>>>>>>>>            tConnection[] Connections
78313>>>>>>>>>>>            // - If the DF 19 cConnection class has been used in the cApplication object
78313>>>>>>>>>>>            // - and there are multiple connection id's defined for the same driver. This is
78313>>>>>>>>>>>            //   because otherwise we can't possibly know which connection id to use... So
78313>>>>>>>>>>>            //   we then generate an error and abort the program...
78313>>>>>>>>>>>            Get IsSinglecConnection (&sConnectionID) to bOK
78314>>>>>>>>>>>            If (bOK = False) Begin
78316>>>>>>>>>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
78317>>>>>>>>>>>>
78317>>>>>>>>>>>                Abort
78318>>>>>>>>>>>>
78318>>>>>>>>>>>            End
78318>>>>>>>>>>>>
78318>>>>>>>>>>>            If (sConnectionID = "") Begin
78320>>>>>>>>>>>                Get ConnectionIDs of ghoConnection to Connections
78321>>>>>>>>>>>                If (SizeOfArray(Connections) > 0) Begin
78323>>>>>>>>>>>                    Move Connections[0].sId to sConnectionID
78324>>>>>>>>>>>                End
78324>>>>>>>>>>>>
78324>>>>>>>>>>>            End
78324>>>>>>>>>>>>
78324>>>>>>>>>>>
78324>>>>>>>>>>>            Move 0 to iRetval
78325>>>>>>>>>>>            // DAW DF19 connection info:
78325>>>>>>>>>>>            // We first check that the connection is OK:
78325>>>>>>>>>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
78326>>>>>>>>>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
78326>>>>>>>>>>>            If (iRetval = -1) Begin
78328>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78329>>>>>>>>>>>            End
78329>>>>>>>>>>>>
78329>>>>>>>>>>>
78329>>>>>>>>>>>            If (sConnectionID <> "") Begin
78331>>>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
78332>>>>>>>>>>>            End
78332>>>>>>>>>>>>
78332>>>>>>>>>>>            If (Connection.sId = "") Begin
78334>>>>>>>>>>>                Move True to SQLConnectionEmpty.bError
78335>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78336>>>>>>>>>>>            End
78336>>>>>>>>>>>>
78336>>>>>>>>>>>
78336>>>>>>>>>>>            // DUF connection info struct property:
78336>>>>>>>>>>>            Get Private.pSQLConnection                       to SQLConnection
78337>>>>>>>>>>>
78337>>>>>>>>>>>            Move Connection.sId to sConnectionID
78338>>>>>>>>>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
78339>>>>>>>>>>>
78339>>>>>>>>>>>            If (bConnected = False) Begin
78341>>>>>>>>>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
78342>>>>>>>>>>>                If (iRetval <> 0) Begin
78344>>>>>>>>>>>                    Send UserError CS_DUF_CannotLoginToServer
78345>>>>>>>>>>>                    Send Exit_Application
78346>>>>>>>>>>>                End
78346>>>>>>>>>>>>
78346>>>>>>>>>>>                Move True                                   to SQLConnection.bDAWConnection
78347>>>>>>>>>>>                // We need to get the DAW connection info again as it might have
78347>>>>>>>>>>>                // been changed in the DAW db login dialog.
78347>>>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
78348>>>>>>>>>>>            End
78348>>>>>>>>>>>>
78348>>>>>>>>>>>
78348>>>>>>>>>>>            Move True                                        to SQLConnection.bEnabled
78349>>>>>>>>>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
78350>>>>>>>>>>>
78350>>>>>>>>>>>            // Not used in DUF:
78350>>>>>>>>>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
78350>>>>>>>>>>>
78350>>>>>>>>>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
78351>>>>>>>>>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
78352>>>>>>>>>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
78353>>>>>>>>>>>            Move Connection.sId                              to SQLConnection.sConnectionID
78354>>>>>>>>>>>            Move Connection.sUID                             to SQLConnection.sUserID
78355>>>>>>>>>>>            Move Connection.sPWD                             to SQLConnection.sPassword
78356>>>>>>>>>>>
78356>>>>>>>>>>>            // Not used in DUF:
78356>>>>>>>>>>>            // Move Connection.sSection to SQLConnection.xxx
78356>>>>>>>>>>>
78356>>>>>>>>>>>            // The rest of the properties of the SQLConnection struct should have been
78356>>>>>>>>>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
78356>>>>>>>>>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
78358>>>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniServerKeyword + "=")       to SQLConnection.sServer
78359>>>>>>>>>>>            End
78359>>>>>>>>>>>>
78359>>>>>>>>>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
78361>>>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniDSNKeyword + "=")          to SQLConnection.sServer
78362>>>>>>>>>>>                If (SQLConnection.sServer = "") Begin
78364>>>>>>>>>>>                    Get ParseKeyWord Connection.sString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78365>>>>>>>>>>>                End
78365>>>>>>>>>>>>
78365>>>>>>>>>>>            End
78365>>>>>>>>>>>>
78365>>>>>>>>>>>
78365>>>>>>>>>>>            Get ParseKeyWord Connection.sString (CS_SQLIniDatabaseKeyword  + "=")        to SQLConnection.sDatabase
78366>>>>>>>>>>>
78366>>>>>>>>>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
78366>>>>>>>>>>>            // the value from the driver id:
78366>>>>>>>>>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
78367>>>>>>>>>>>            If (SQLConnection.iDbType = 0) Begin
78369>>>>>>>>>>>            // ...but in case it has been explicitly set in the object we use that value.
78369>>>>>>>>>>>            Get piDbType                                     to iDbType
78370>>>>>>>>>>>            End
78370>>>>>>>>>>>>
78370>>>>>>>>>>>            If (iDbType > 0 and SQLConnection.iDbType = 0) Begin
78372>>>>>>>>>>>                Move iDbType to SQLConnection.iDbType
78373>>>>>>>>>>>            End
78373>>>>>>>>>>>>
78373>>>>>>>>>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
78374>>>>>>>>>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
78375>>>>>>>>>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
78376>>>>>>>>>>>            Get psSchema                                     to SQLConnection.sSchema
78377>>>>>>>>>>>
78377>>>>>>>>>>>            // We finally set the struct property to the newly fetched values.
78377>>>>>>>>>>>            Set pSQLConnection to SQLConnection
78378>>>>>>>>>>>
78378>>>>>>>>>>>        Function_Return SQLConnection
78379>>>>>>>>>>>    End_Function
78380>>>>>>>>>>>
78380>>>>>>>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
78380>>>>>>>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
78380>>>>>>>>>>>    // connection id for a particular driver.
78380>>>>>>>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
78380>>>>>>>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
78380>>>>>>>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
78380>>>>>>>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
78380>>>>>>>>>>>    // connections of the DAW cConnect class.
78380>>>>>>>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
78382>>>>>>>>>>>        tConnection[] ConnIdArray
78382>>>>>>>>>>>        tConnection[] ConnIdArray
78383>>>>>>>>>>>        Integer iCount iSize iConnectionIDCounter
78383>>>>>>>>>>>        Boolean bEnabled bFound
78383>>>>>>>>>>>        String sConnectionID2 sDriverID sDriverConn
78383>>>>>>>>>>>
78383>>>>>>>>>>>        Move False to bFound
78384>>>>>>>>>>>        If (ghoConnection > 0) Begin
78386>>>>>>>>>>>
78386>>>>>>>>>>>            // The property of the cDbUpdateHandler container object
78386>>>>>>>>>>>            Get psDriverID to sDriverID
78387>>>>>>>>>>>
78387>>>>>>>>>>>            Move 0 to iConnectionIDCounter
78388>>>>>>>>>>>            // This is the the DAW cConnect array with all registered connection id's.
78388>>>>>>>>>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
78389>>>>>>>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
78390>>>>>>>>>>>            Decrement iSize
78391>>>>>>>>>>>            For iCount from 0 to iSize
78397>>>>>>>>>>>>
78397>>>>>>>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
78398>>>>>>>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
78399>>>>>>>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
78400>>>>>>>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
78400>>>>>>>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
78400>>>>>>>>>>>                If (sConnectionID = "") Begin
78402>>>>>>>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
78403>>>>>>>>>>>                End
78403>>>>>>>>>>>>
78403>>>>>>>>>>>                Else Begin
78404>>>>>>>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
78406>>>>>>>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
78407>>>>>>>>>>>                    End
78407>>>>>>>>>>>>
78407>>>>>>>>>>>                End
78407>>>>>>>>>>>>
78407>>>>>>>>>>>
78407>>>>>>>>>>>                If (bFound = True) Begin
78409>>>>>>>>>>>                    Increment iConnectionIDCounter
78410>>>>>>>>>>>                End
78410>>>>>>>>>>>>
78410>>>>>>>>>>>            Loop
78411>>>>>>>>>>>>
78411>>>>>>>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
78412>>>>>>>>>>>            If (bFound = True) Begin
78414>>>>>>>>>>>                Move sConnectionID2 to sConnectionID
78415>>>>>>>>>>>            End
78415>>>>>>>>>>>>
78415>>>>>>>>>>>        End
78415>>>>>>>>>>>>
78415>>>>>>>>>>>
78415>>>>>>>>>>>        // Special case; a cConnection object has been setup in the cApplication,
78415>>>>>>>>>>>        // but no DFConn.ini record has been created.
78415>>>>>>>>>>>        If (iSize = -1) Begin
78417>>>>>>>>>>>            Move True to bFound
78418>>>>>>>>>>>        End
78418>>>>>>>>>>>>
78418>>>>>>>>>>>
78418>>>>>>>>>>>        Function_Return bFound
78419>>>>>>>>>>>    End_Function
78420>>>>>>>>>>>
78420>>>>>>>>>>>    // Send on object creation to read the default connection string settings, and
78420>>>>>>>>>>>    // create a connection to the server.
78420>>>>>>>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
78422>>>>>>>>>>>        String sPath sFileName
78422>>>>>>>>>>>        Boolean bExists bActive
78422>>>>>>>>>>>        tSQLConnection[] SQLConnectionArray
78422>>>>>>>>>>>        tSQLConnection[] SQLConnectionArray
78423>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78423>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78423>>>>>>>>>>>        Handle hoIniFile
78423>>>>>>>>>>>        Integer iSize iCount iRetval
78423>>>>>>>>>>>
78423>>>>>>>>>>>        Get psIniFilePath to sPath
78424>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78425>>>>>>>>>>>        If (sPath = "") Begin
78427>>>>>>>>>>>            Get ApplicationPath of hoIniFile to sPath
78428>>>>>>>>>>>            Set psIniFilePath   of hoIniFile to sPath
78429>>>>>>>>>>>        End
78429>>>>>>>>>>>>
78429>>>>>>>>>>>        Get vFolderFormat sPath to sPath
78430>>>>>>>>>>>        Get psIniFileName to sFileName
78431>>>>>>>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
78432>>>>>>>>>>>
78432>>>>>>>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
78433>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
78434>>>>>>>>>>>        If (iSize = 0) Begin
78436>>>>>>>>>>>            // This may have been set by the "ReadcConnections" function,
78436>>>>>>>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
78436>>>>>>>>>>>            // in the cApplication object.
78436>>>>>>>>>>>            Get pSQLConnection to SQLConnection
78437>>>>>>>>>>>            If (SQLConnection.sConnectionID = "") Begin
78439>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78440>>>>>>>>>>>            End
78440>>>>>>>>>>>>
78440>>>>>>>>>>>            Move SQLConnection to SQLConnectionArray[0] 
78441>>>>>>>>>>>            Move 1 to iSize
78442>>>>>>>>>>>        End
78442>>>>>>>>>>>>
78442>>>>>>>>>>>
78442>>>>>>>>>>>        Move False to bActive
78443>>>>>>>>>>>        // The first connection should be the one that is active, but all connections might have been disabled.
78443>>>>>>>>>>>        Decrement iSize
78444>>>>>>>>>>>        For iCount from 0 to iSize
78450>>>>>>>>>>>>
78450>>>>>>>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
78451>>>>>>>>>>>            If (SQLConnection.bEnabled = True) Begin
78453>>>>>>>>>>>                Move True to bActive
78454>>>>>>>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
78455>>>>>>>>>>>            End
78455>>>>>>>>>>>>
78455>>>>>>>>>>>        Loop
78456>>>>>>>>>>>>
78456>>>>>>>>>>>
78456>>>>>>>>>>>        // In case all connections have been disabled, we're out of here.
78456>>>>>>>>>>>        If (bActive = False) Begin
78458>>>>>>>>>>>            Function_Return SQLConnectionEmpty
78459>>>>>>>>>>>        End
78459>>>>>>>>>>>>
78459>>>>>>>>>>>
78459>>>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin False
78460>>>>>>>>>>>
78460>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78461>>>>>>>>>>>        Get AutoSetConnectionID to iRetval
78462>>>>>>>>>>>
78462>>>>>>>>>>>        Function_Return SQLConnection
78463>>>>>>>>>>>    End_Function
78464>>>>>>>>>>>
78464>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
78466>>>>>>>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
78467>>>>>>>>>>>    End_Procedure
78468>>>>>>>>>>>
78468>>>>>>>>>>>    Function psIniFilePath Returns String
78470>>>>>>>>>>>        String sRetval
78470>>>>>>>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
78471>>>>>>>>>>>        Function_Return sRetval
78472>>>>>>>>>>>    End_Function
78473>>>>>>>>>>>
78473>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
78475>>>>>>>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
78476>>>>>>>>>>>    End_Procedure
78477>>>>>>>>>>>
78477>>>>>>>>>>>    Function psIniFileName Returns String
78479>>>>>>>>>>>        String sRetval
78479>>>>>>>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
78480>>>>>>>>>>>        Function_Return sRetval
78481>>>>>>>>>>>    End_Function
78482>>>>>>>>>>>
78482>>>>>>>>>>>    Procedure Set psIniSectionName String sSection
78484>>>>>>>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
78485>>>>>>>>>>>    End_Procedure
78486>>>>>>>>>>>
78486>>>>>>>>>>>    Function psIniSectionName Returns String
78488>>>>>>>>>>>        String sRetval
78488>>>>>>>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
78489>>>>>>>>>>>        Function_Return sRetval
78490>>>>>>>>>>>    End_Function
78491>>>>>>>>>>>
78491>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
78493>>>>>>>>>>>        Handle ho
78493>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78494>>>>>>>>>>>        Set IniFileValue of ho to sSection sValueName sValue
78495>>>>>>>>>>>    End_Procedure
78496>>>>>>>>>>>
78496>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
78498>>>>>>>>>>>        Handle ho
78498>>>>>>>>>>>        String sRetval
78498>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78499>>>>>>>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
78500>>>>>>>>>>>        Function_Return sRetval
78501>>>>>>>>>>>    End_Function
78502>>>>>>>>>>>
78502>>>>>>>>>>>    Function SectionExists String sSection Returns Boolean
78504>>>>>>>>>>>        Handle ho
78504>>>>>>>>>>>        Boolean bRetval
78504>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78505>>>>>>>>>>>        Get SectionExists of ho sSection to bRetval
78506>>>>>>>>>>>        Function_Return bRetval
78507>>>>>>>>>>>    End_Function
78508>>>>>>>>>>>
78508>>>>>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
78510>>>>>>>>>>>        Handle ho
78510>>>>>>>>>>>        Boolean bRetval
78510>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78511>>>>>>>>>>>        Get KeyExists of ho sSection sKey to bRetval
78512>>>>>>>>>>>        Function_Return bRetval
78513>>>>>>>>>>>    End_Function
78514>>>>>>>>>>>
78514>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
78516>>>>>>>>>>>        Handle ho
78516>>>>>>>>>>>        String sRetval
78516>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78517>>>>>>>>>>>        Get EncryptPassword of ho sPassword to sRetval
78518>>>>>>>>>>>        Function_Return sRetval
78519>>>>>>>>>>>    End_Function
78520>>>>>>>>>>>
78520>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
78522>>>>>>>>>>>        Handle ho
78522>>>>>>>>>>>        String sRetval
78522>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78523>>>>>>>>>>>        Get DecryptPassword of ho sPassword to sRetval
78524>>>>>>>>>>>        Function_Return sRetval
78525>>>>>>>>>>>    End_Function
78526>>>>>>>>>>>
78526>>>>>>>>>>>    // *** Main Connection Message ***
78526>>>>>>>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent Boolean bExitProgram
78528>>>>>>>>>>>        Handle hoDriver
78528>>>>>>>>>>>        String sConnectionString sError
78528>>>>>>>>>>>        Boolean bLoginSuccessful
78528>>>>>>>>>>>
78528>>>>>>>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
78529>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
78530>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
78531>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
78532>>>>>>>>>>>        If (bLoginSuccessful = False) Begin
78534>>>>>>>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)   
78535>>>>>>>>>>>>
78535>>>>>>>>>>>            If (bExitProgram = True) Begin
78537>>>>>>>>>>>                Send Exit_Application
78538>>>>>>>>>>>            End
78538>>>>>>>>>>>>
78538>>>>>>>>>>>        End
78538>>>>>>>>>>>>
78538>>>>>>>>>>>        Send Destroy of hoDriver
78539>>>>>>>>>>>    End_Procedure
78540>>>>>>>>>>>
78540>>>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
78542>>>>>>>>>>>        Integer iRetval
78542>>>>>>>>>>>        Handle hoCLI
78542>>>>>>>>>>>        String sDriverID
78542>>>>>>>>>>>
78542>>>>>>>>>>>        Get psDriverID to sDriverID
78543>>>>>>>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
78544>>>>>>>>>>>        If (hoCLI <> 0) Begin
78546>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78547>>>>>>>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
78548>>>>>>>>>>>            Send Destroy of hoCLI
78549>>>>>>>>>>>        End
78549>>>>>>>>>>>>
78549>>>>>>>>>>>
78549>>>>>>>>>>>        Function_Return iRetval
78550>>>>>>>>>>>    End_Function
78551>>>>>>>>>>>
78551>>>>>>>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
78553>>>>>>>>>>>        tSQLConnection SQLConnection
78553>>>>>>>>>>>        tSQLConnection SQLConnection
78553>>>>>>>>>>>
78553>>>>>>>>>>>        Set psDriverID to sDriverID
78554>>>>>>>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
78555>>>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted False
78556>>>>>>>>>>>    End_Procedure
78557>>>>>>>>>>>
78557>>>>>>>>>>>    // This is needed when e.g. the connection id we have specified in the program code
78557>>>>>>>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
78557>>>>>>>>>>>    // or the one in the DataFlex Bin folder.)
78557>>>>>>>>>>>    // We then need to delete the current one before creating a new one.
78557>>>>>>>>>>>    // This is because the parameters may differ between the program code and the
78557>>>>>>>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
78557>>>>>>>>>>>    // when one tries to create a Connection ID that already exists.
78557>>>>>>>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
78559>>>>>>>>>>>        Integer iResult iDriver iNumConn iConn
78559>>>>>>>>>>>        Handle hoCLI
78559>>>>>>>>>>>        String sID
78559>>>>>>>>>>>
78559>>>>>>>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
78561>>>>>>>>>>>            Procedure_Return
78562>>>>>>>>>>>        End
78562>>>>>>>>>>>>
78562>>>>>>>>>>>
78562>>>>>>>>>>>        Move 0 to iResult
78563>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78564>>>>>>>>>>>        If (hoCLI <> 0) Begin
78566>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78567>>>>>>>>>>>            Get DriverIndex sDriverID to iDriver
78568>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78571>>>>>>>>>>>            Decrement iNumConn
78572>>>>>>>>>>>            For iConn from 0 to iNumConn
78578>>>>>>>>>>>>
78578>>>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78581>>>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78583>>>>>>>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
78584>>>>>>>>>>>                End
78584>>>>>>>>>>>>
78584>>>>>>>>>>>            Loop
78585>>>>>>>>>>>>
78585>>>>>>>>>>>            Send Destroy of hoCLI
78586>>>>>>>>>>>        End
78586>>>>>>>>>>>>
78586>>>>>>>>>>>
78586>>>>>>>>>>>    End_Procedure
78587>>>>>>>>>>>
78587>>>>>>>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
78589>>>>>>>>>>>        Integer iResult iDriver iNumConn iConn
78589>>>>>>>>>>>        Handle hoCLI
78589>>>>>>>>>>>        String sID sConnectionString sVal sDatabase
78589>>>>>>>>>>>        tSQLConnection SQLConnection
78589>>>>>>>>>>>        tSQLConnection SQLConnection
78589>>>>>>>>>>>        Boolean bTrusted
78589>>>>>>>>>>>
78589>>>>>>>>>>>        Move 0 to iResult
78590>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78591>>>>>>>>>>>        If (hoCLI <> 0) Begin
78593>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78594>>>>>>>>>>>            Get DriverIndex sDriverID to iDriver
78595>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78598>>>>>>>>>>>            Decrement iNumConn
78599>>>>>>>>>>>            For iConn from 0 to iNumConn
78605>>>>>>>>>>>>
78605>>>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78608>>>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78610>>>>>>>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
78611>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
78614>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
78617>>>>>>>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
78618>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
78621>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
78622>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
78623>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
78624>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
78625>>>>>>>>>>>
78625>>>>>>>>>>>                    Case Begin
78625>>>>>>>>>>>                        Case (sDriverID = MSSQLDRV_ID)
78627>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
78628>>>>>>>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
78629>>>>>>>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
78630>>>>>>>>>>>                            Case Break
78631>>>>>>>>>>>                        Case (sDriverID = DB2_DRV_ID)
78634>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78635>>>>>>>>>>>                            Case Break
78636>>>>>>>>>>>                        Case (sDriverID = ODBC_DRV_ID)
78639>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78640>>>>>>>>>>>                            If (SQLConnection.sServer = "") Begin
78642>>>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78643>>>>>>>>>>>                            End
78643>>>>>>>>>>>>
78643>>>>>>>>>>>                            Case Break
78644>>>>>>>>>>>                        Case Else
78644>>>>>>>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
78645>>>>>>>>>>>>
78645>>>>>>>>>>>                            Case Break
78646>>>>>>>>>>>                    Case End
78646>>>>>>>>>>>                End
78646>>>>>>>>>>>>
78646>>>>>>>>>>>            Loop
78647>>>>>>>>>>>>
78647>>>>>>>>>>>            Send Destroy of hoCLI
78648>>>>>>>>>>>        End
78648>>>>>>>>>>>>
78648>>>>>>>>>>>
78648>>>>>>>>>>>        Function_Return SQLConnection
78649>>>>>>>>>>>    End_Function
78650>>>>>>>>>>>
78650>>>>>>>>>>>    Function DriverIndex String sDriverID Returns Integer
78652>>>>>>>>>>>        String  sCurrentDriver
78652>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
78652>>>>>>>>>>>
78652>>>>>>>>>>>        Move 0 to iDriver
78653>>>>>>>>>>>        Move 0 to iCount
78654>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
78657>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
78663>>>>>>>>>>>>
78663>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
78666>>>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
78668>>>>>>>>>>>                Function_Return iCount
78669>>>>>>>>>>>            End
78669>>>>>>>>>>>>
78669>>>>>>>>>>>        Loop
78670>>>>>>>>>>>>
78670>>>>>>>>>>>
78670>>>>>>>>>>>        // If driver not previously loaded; attempt to do so now.
78670>>>>>>>>>>>        If (iDriver = 0) Begin
78672>>>>>>>>>>>            Move 0 to LastErr
78673>>>>>>>>>>>            Load_Driver sDriverID
78674>>>>>>>>>>>            // If driver could not be loaded.
78674>>>>>>>>>>>            If (LastErr = DFERR_CANT_LOAD_DLL) Begin
78676>>>>>>>>>>>                Move -1 to iCount
78677>>>>>>>>>>>            End
78677>>>>>>>>>>>>
78677>>>>>>>>>>>        End
78677>>>>>>>>>>>>
78677>>>>>>>>>>>        Function_Return iCount
78678>>>>>>>>>>>    End_Function
78679>>>>>>>>>>>
78679>>>>>>>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
78679>>>>>>>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
78681>>>>>>>>>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
78681>>>>>>>>>>>        Boolean bTrusted bSilent
78681>>>>>>>>>>>        Integer iRetval
78681>>>>>>>>>>>
78681>>>>>>>>>>>        Move SQLConnection.sDriverID     to sDriverID
78682>>>>>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
78683>>>>>>>>>>>        Move SQLConnection.sServer       to sServer
78684>>>>>>>>>>>        Move SQLConnection.sDatabase     to sDatabase
78685>>>>>>>>>>>        Move SQLConnection.bTrusted      to bTrusted
78686>>>>>>>>>>>        Move SQLConnection.sUserID       to sUserID
78687>>>>>>>>>>>        Move SQLConnection.sPassword     to sPassword
78688>>>>>>>>>>>        Move SQLConnection.bSilentLogin  to bSilent
78689>>>>>>>>>>>
78689>>>>>>>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent False
78690>>>>>>>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
78690>>>>>>>>>>>        Get AutoSetConnectionID to iRetval
78691>>>>>>>>>>>    End_Procedure
78692>>>>>>>>>>>
78692>>>>>>>>>>>    // Called when the object is constructed.
78692>>>>>>>>>>>    // It will check the psDriverID for a ConnectionID and save it
78692>>>>>>>>>>>    // as psConnectionID property. It is later used whenever a login to
78692>>>>>>>>>>>    // the database is needed.
78692>>>>>>>>>>>    Function AutoSetConnectionID Returns Boolean
78694>>>>>>>>>>>        String sConnectionID sDriverID sConnectionString
78694>>>>>>>>>>>        Integer iDriver iRetval
78694>>>>>>>>>>>        Handle hoCLI
78694>>>>>>>>>>>        Boolean bOK bSilent
78694>>>>>>>>>>>
78694>>>>>>>>>>>        Get pbSilentLogin      to bSilent
78695>>>>>>>>>>>        Get psConnectionID     to sConnectionID
78696>>>>>>>>>>>        Get psConnectionString to sConnectionString
78697>>>>>>>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
78697>>>>>>>>>>>        Get psDriverID to sDriverID
78698>>>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78699>>>>>>>>>>>        If (bOK = False) Begin
78701>>>>>>>>>>>            Function_Return False
78702>>>>>>>>>>>        End
78702>>>>>>>>>>>>
78702>>>>>>>>>>>
78702>>>>>>>>>>>        Get DriverIndex sDriverID          to iDriver
78703>>>>>>>>>>>        // If driver not loaded; load it.
78703>>>>>>>>>>>        If (iDriver = 0) Begin
78705>>>>>>>>>>>            Load_Driver sDriverID
78706>>>>>>>>>>>            Get DriverIndex sDriverID      to iDriver
78707>>>>>>>>>>>        End
78707>>>>>>>>>>>>
78707>>>>>>>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
78707>>>>>>>>>>>        If (iDriver = 0) Begin
78709>>>>>>>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
78710>>>>>>>>>>>>
78710>>>>>>>>>>>            Function_Return False
78711>>>>>>>>>>>        End           
78711>>>>>>>>>>>>
78711>>>>>>>>>>>            Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to True
78714>>>>>>>>>>>        
78714>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78715>>>>>>>>>>>        Set psDriverID of hoCLI            to sDriverID
78716>>>>>>>>>>>        // Delete the connection first; in case it exists
78716>>>>>>>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
78717>>>>>>>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval 
78718>>>>>>>>>>>        Send Destroy of hoCLI
78719>>>>>>>>>>>
78719>>>>>>>>>>>        Function_Return (iRetval = 0)
78720>>>>>>>>>>>    End_Function
78721>>>>>>>>>>>
78721>>>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
78723>>>>>>>>>>>        Boolean bOK
78723>>>>>>>>>>>
78723>>>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
78724>>>>>>>>>>>
78724>>>>>>>>>>>        If (bOK = False) Begin
78726>>>>>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
78727>>>>>>>>>>>>
78727>>>>>>>>>>>            Function_Return False
78728>>>>>>>>>>>        End
78728>>>>>>>>>>>>
78728>>>>>>>>>>>
78728>>>>>>>>>>>        Function_Return True
78729>>>>>>>>>>>    End_Function
78730>>>>>>>>>>>
78730>>>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
78732>>>>>>>>>>>        Boolean bOK
78732>>>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
78733>>>>>>>>>>>        Function_Return bOK
78734>>>>>>>>>>>    End_Function
78735>>>>>>>>>>>
78735>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
78737>>>>>>>>>>>        Handle hoIniFile
78737>>>>>>>>>>>        String sConnect
78737>>>>>>>>>>>
78737>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78738>>>>>>>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
78739>>>>>>>>>>>
78739>>>>>>>>>>>        Function_Return sConnect
78740>>>>>>>>>>>    End_Function
78741>>>>>>>>>>>
78741>>>>>>>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
78741>>>>>>>>>>>    // Pass a complete driver connection string
78741>>>>>>>>>>>    // Returns the following as a struct:
78741>>>>>>>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
78741>>>>>>>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
78741>>>>>>>>>>>    //
78741>>>>>>>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
78743>>>>>>>>>>>        tSQLConnection SQLConnection
78743>>>>>>>>>>>        tSQLConnection SQLConnection
78743>>>>>>>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
78743>>>>>>>>>>>        Boolean bTrusted bSilent bOK
78743>>>>>>>>>>>        Integer iPos
78743>>>>>>>>>>>
78743>>>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78744>>>>>>>>>>>        If (bOK = False) Begin
78746>>>>>>>>>>>            Function_Return SQLConnection
78747>>>>>>>>>>>        End
78747>>>>>>>>>>>>
78747>>>>>>>>>>>
78747>>>>>>>>>>>        Move False to bTrusted
78748>>>>>>>>>>>        Move False to bSilent
78749>>>>>>>>>>>
78749>>>>>>>>>>>        Case Begin
78749>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
78751>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
78752>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
78753>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78754>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78755>>>>>>>>>>>                If (bTrusted = False) Begin
78757>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78758>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78759>>>>>>>>>>>                End
78759>>>>>>>>>>>>
78759>>>>>>>>>>>                Case Break
78760>>>>>>>>>>>
78760>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
78763>>>>>>>>>>>                If (uppercase(sConnectionString) contains ("." + CS_SQLIniDSNKeyword)) Begin
78765>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword + "=")  to sServer
78766>>>>>>>>>>>                End
78766>>>>>>>>>>>>
78766>>>>>>>>>>>                Else Begin
78767>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78768>>>>>>>>>>>                End
78768>>>>>>>>>>>>
78768>>>>>>>>>>>
78768>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78769>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78770>>>>>>>>>>>                If (bTrusted = False) Begin
78772>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78773>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78774>>>>>>>>>>>                End
78774>>>>>>>>>>>>
78774>>>>>>>>>>>                Case Break
78775>>>>>>>>>>>
78775>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
78778>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78779>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
78780>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
78781>>>>>>>>>>>                Case Break
78782>>>>>>>>>>>
78782>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
78785>>>>>>>>>>>                Break
78786>>>>>>>>>>>        Case End
78786>>>>>>>>>>>
78786>>>>>>>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
78787>>>>>>>>>>>
78787>>>>>>>>>>>        // bSilent?
78787>>>>>>>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
78788>>>>>>>>>>>        If (iPos = 0) Begin
78790>>>>>>>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
78791>>>>>>>>>>>        End
78791>>>>>>>>>>>>
78791>>>>>>>>>>>        If (iPos = 0) Begin
78793>>>>>>>>>>>            Move "0"                                                            to sValue
78794>>>>>>>>>>>        End
78794>>>>>>>>>>>>
78794>>>>>>>>>>>        Else Begin
78795>>>>>>>>>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
78796>>>>>>>>>>>        End
78796>>>>>>>>>>>>
78796>>>>>>>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
78797>>>>>>>>>>>
78797>>>>>>>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
78798>>>>>>>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
78799>>>>>>>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
78800>>>>>>>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
78801>>>>>>>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
78802>>>>>>>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
78803>>>>>>>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
78804>>>>>>>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
78805>>>>>>>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
78806>>>>>>>>>>>
78806>>>>>>>>>>>        Function_Return SQLConnection
78807>>>>>>>>>>>    End_Function
78808>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
78808>>>>>>>>>>>>
78808>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
78810>>>>>>>>>>>>    Integer iStart iEnd
78810>>>>>>>>>>>>    String sRetval
78810>>>>>>>>>>>>
78810>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
78811>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
78812>>>>>>>>>>>>    If (iStart = 0) Begin
78814>>>>>>>>>>>>        Function_Return ""
78815>>>>>>>>>>>>    End
78815>>>>>>>>>>>>>
78815>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
78816>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
78817>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
78819>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78820>>>>>>>>>>>>    End
78820>>>>>>>>>>>>>
78820>>>>>>>>>>>>    Else Begin
78821>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
78822>>>>>>>>>>>>    End
78822>>>>>>>>>>>>>
78822>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
78824>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78825>>>>>>>>>>>>        Decrement iEnd
78826>>>>>>>>>>>>    End
78826>>>>>>>>>>>>>
78826>>>>>>>>>>>>    If (iEnd <> 0) Begin
78828>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
78829>>>>>>>>>>>>    End
78829>>>>>>>>>>>>>
78829>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
78830>>>>>>>>>>>>
78830>>>>>>>>>>>>    Function_Return (Trim(sRetval))
78831>>>>>>>>>>>>End_Function
78832>>>>>>>>>>>>
78832>>>>>>>>>>>>
78832>>>>>>>>>>>
78832>>>>>>>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
78832>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
78834>>>>>>>>>>>        Handle ho
78834>>>>>>>>>>>        Integer iIndex
78834>>>>>>>>>>>        Boolean bRetval bOK
78834>>>>>>>>>>>        tSQLConnection SQLConnection
78834>>>>>>>>>>>        tSQLConnection SQLConnection
78834>>>>>>>>>>>
78834>>>>>>>>>>>        Get pSQLConnection to SQLConnection
78835>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78836>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
78837>>>>>>>>>>>        If (iIndex = -1) Begin
78839>>>>>>>>>>>            Function_Return False
78840>>>>>>>>>>>        End
78840>>>>>>>>>>>>
78840>>>>>>>>>>>
78840>>>>>>>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
78841>>>>>>>>>>>        Send UpdateConnectionString SQLConnection
78842>>>>>>>>>>>        If (ghoConnection > 0) Begin
78844>>>>>>>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
78845>>>>>>>>>>>            If (iIndex <> -1) Begin
78847>>>>>>>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
78848>>>>>>>>>>>            End
78848>>>>>>>>>>>>
78848>>>>>>>>>>>        End
78848>>>>>>>>>>>>
78848>>>>>>>>>>>
78848>>>>>>>>>>>        Function_Return bRetval
78849>>>>>>>>>>>    End_Function
78850>>>>>>>>>>>
78850>>>>>>>>>>>    Procedure Set pbDFConnid Boolean bState
78852>>>>>>>>>>>        Set pbDFConnid of (phoSQLConnectionIniFile(Self)) to bState
78853>>>>>>>>>>>    End_Procedure
78854>>>>>>>>>>>    
78854>>>>>>>>>>>    Function pbDFConnid Returns Boolean
78856>>>>>>>>>>>        Boolean bState
78856>>>>>>>>>>>        Get pbDFConnid of (phoSQLConnectionIniFile(Self)) to bState
78857>>>>>>>>>>>        Function_Return bState
78858>>>>>>>>>>>    End_Function
78859>>>>>>>>>>>
78859>>>>>>>>>>>End_Class
78860>>>>>>>>>Use vWin32fh.pkg
78860>>>>>>>>>Use Dfabout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\DfAbout.pkg)
78860>>>>>>>>>>>Use LanguageText.pkg
78860>>>>>>>>>>>Use Windows.pkg
78860>>>>>>>>>>>Use Dfclient.pkg
78860>>>>>>>>>>>Use DFbitmap.pkg
78860>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
78860>>>>>>>>>>>Use cRichEdit.pkg
78860>>>>>>>>>>>Use cTextEdit.pkg
78860>>>>>>>>>>>Use cRichEdit.pkg
78860>>>>>>>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files\DataFlex 24.0\Pkg\gFormatNumbers.pkg)
78860>>>>>>>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cFormatter.pkg)
78860>>>>>>>>>>>>>>>Use VDFBase.pkg
78860>>>>>>>>>>>>>>>
78860>>>>>>>>>>>>>>>Class cFormatter is an cObject
78861>>>>>>>>>>>>>>>    
78861>>>>>>>>>>>>>>>    Procedure Construct_object
78863>>>>>>>>>>>>>>>        Integer iCh
78863>>>>>>>>>>>>>>>        Forward Send construct_object
78865>>>>>>>>>>>>>>>        Property String  psCurrencySymbol
78866>>>>>>>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
78867>>>>>>>>>>>>>>>        
78867>>>>>>>>>>>>>>>        Property String  psLeft
78868>>>>>>>>>>>>>>>        Property String  psright
78869>>>>>>>>>>>>>>>        Property Integer pbThousandsSep
78870>>>>>>>>>>>>>>>        Property Integer piPoints
78871>>>>>>>>>>>>>>>        
78871>>>>>>>>>>>>>>>        Property String  psCurPosLeft
78872>>>>>>>>>>>>>>>        Property String  psCurPosright
78873>>>>>>>>>>>>>>>        Property Integer pbCurPosThousandsSep
78874>>>>>>>>>>>>>>>        Property Integer piCurPosPoints
78875>>>>>>>>>>>>>>>        
78875>>>>>>>>>>>>>>>        Property String  psCurNegLeft
78876>>>>>>>>>>>>>>>        Property String  psCurNegright
78877>>>>>>>>>>>>>>>        Property Integer pbCurNegThousandsSep
78878>>>>>>>>>>>>>>>        Property Integer piCurNegPoints
78879>>>>>>>>>>>>>>>        
78879>>>>>>>>>>>>>>>        Property String  psNumPosLeft
78880>>>>>>>>>>>>>>>        Property String  psNumPosright
78881>>>>>>>>>>>>>>>        Property Integer pbNumPosThousandsSep
78882>>>>>>>>>>>>>>>        Property Integer piNumPosPoints
78883>>>>>>>>>>>>>>>        
78883>>>>>>>>>>>>>>>        Property String  psNumNegLeft
78884>>>>>>>>>>>>>>>        Property String  psNumNegright
78885>>>>>>>>>>>>>>>        Property Integer pbNumNegThousandsSep
78886>>>>>>>>>>>>>>>        Property Integer piNumNegPoints
78887>>>>>>>>>>>>>>>        
78887>>>>>>>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
78888>>>>>>>>>>>>>>>        Send SetFormat  ",#.*"           False // numeric
78889>>>>>>>>>>>>>>>        
78889>>>>>>>>>>>>>>>    End_Procedure
78890>>>>>>>>>>>>>>>    
78890>>>>>>>>>>>>>>>    // internal
78890>>>>>>>>>>>>>>>    // parse passed format string and set temporary properties with result
78890>>>>>>>>>>>>>>>    Procedure ParseFormat String sFmt
78892>>>>>>>>>>>>>>>        
78892>>>>>>>>>>>>>>>        String sLeft sRight sDigit
78892>>>>>>>>>>>>>>>        Integer bSep iPos i iDigits
78892>>>>>>>>>>>>>>>        
78892>>>>>>>>>>>>>>>        // replace any literals. A "/" followed by anything.
78892>>>>>>>>>>>>>>>        // some literals are special. $ . , / #
78892>>>>>>>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
78893>>>>>>>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
78894>>>>>>>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
78895>>>>>>>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
78896>>>>>>>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
78897>>>>>>>>>>>>>>>        Move (Character(9)) to sDigit
78898>>>>>>>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
78899>>>>>>>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
78900>>>>>>>>>>>>>>>        
78900>>>>>>>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
78901>>>>>>>>>>>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
78904>>>>>>>>>>>>>>>        
78904>>>>>>>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
78905>>>>>>>>>>>>>>>        
78905>>>>>>>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
78906>>>>>>>>>>>>>>>        
78906>>>>>>>>>>>>>>>        // Move all the special literals back into place before parsing
78906>>>>>>>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
78907>>>>>>>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
78908>>>>>>>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
78909>>>>>>>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
78910>>>>>>>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
78911>>>>>>>>>>>>>>>        
78911>>>>>>>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
78913>>>>>>>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
78914>>>>>>>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
78916>>>>>>>>>>>>>>>                Move -2 to iDigits
78917>>>>>>>>>>>>>>>                Increment i
78918>>>>>>>>>>>>>>>            End
78918>>>>>>>>>>>>>>>>
78918>>>>>>>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
78922>>>>>>>>>>>>>>>                Increment i
78923>>>>>>>>>>>>>>>            Loop
78924>>>>>>>>>>>>>>>>
78924>>>>>>>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
78925>>>>>>>>>>>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
78928>>>>>>>>>>>>>>>            //
78928>>>>>>>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
78929>>>>>>>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
78933>>>>>>>>>>>>>>>                Increment i
78934>>>>>>>>>>>>>>>            Loop
78935>>>>>>>>>>>>>>>>
78935>>>>>>>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
78936>>>>>>>>>>>>>>>        End
78936>>>>>>>>>>>>>>>>
78936>>>>>>>>>>>>>>>        Else Begin                             // we have no decinal
78937>>>>>>>>>>>>>>>            Move 0 to iDigits                  // so points is none
78938>>>>>>>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
78939>>>>>>>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
78941>>>>>>>>>>>>>>>                Move sFmt to sLeft
78942>>>>>>>>>>>>>>>                Move ""   to sRight
78943>>>>>>>>>>>>>>>            End
78943>>>>>>>>>>>>>>>>
78943>>>>>>>>>>>>>>>            Else Begin
78944>>>>>>>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
78945>>>>>>>>>>>>>>>                Move 1 to i
78946>>>>>>>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
78950>>>>>>>>>>>>>>>                    Increment i
78951>>>>>>>>>>>>>>>                Loop
78952>>>>>>>>>>>>>>>>
78952>>>>>>>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
78953>>>>>>>>>>>>>>>            End
78953>>>>>>>>>>>>>>>>
78953>>>>>>>>>>>>>>>        End
78953>>>>>>>>>>>>>>>>
78953>>>>>>>>>>>>>>>        // set temporary format properties and exit
78953>>>>>>>>>>>>>>>        Set pbThousandsSep to bSep
78954>>>>>>>>>>>>>>>        Set psLeft         to sLeft
78955>>>>>>>>>>>>>>>        Set psRight        to sRight
78956>>>>>>>>>>>>>>>        Set piPoints       to iDigits
78957>>>>>>>>>>>>>>>    End_Procedure
78958>>>>>>>>>>>>>>>    
78958>>>>>>>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
78958>>>>>>>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
78958>>>>>>>>>>>>>>>    //
78958>>>>>>>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
78958>>>>>>>>>>>>>>>    Procedure SetFormat String sFmt Integer bCurrency
78960>>>>>>>>>>>>>>>        String sPos sNeg
78960>>>>>>>>>>>>>>>        Integer iPos
78960>>>>>>>>>>>>>>>        
78960>>>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
78961>>>>>>>>>>>>>>>        If iPos Begin
78963>>>>>>>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
78964>>>>>>>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
78965>>>>>>>>>>>>>>>        End
78965>>>>>>>>>>>>>>>>
78965>>>>>>>>>>>>>>>        Else Begin
78966>>>>>>>>>>>>>>>            Move sFmt         to sPos
78967>>>>>>>>>>>>>>>            Move ("-" + sFmt) to sNeg
78968>>>>>>>>>>>>>>>        End
78968>>>>>>>>>>>>>>>>
78968>>>>>>>>>>>>>>>        Send ParseFormat sPos
78969>>>>>>>>>>>>>>>        If bCurrency Begin
78971>>>>>>>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
78972>>>>>>>>>>>>>>>            Set psCurPosLeft         to (psLeft(Self))
78973>>>>>>>>>>>>>>>            Set psCurPosRight        to (psRight(Self))
78974>>>>>>>>>>>>>>>            Set piCurPosPoints       to (piPoints(Self))
78975>>>>>>>>>>>>>>>        End
78975>>>>>>>>>>>>>>>>
78975>>>>>>>>>>>>>>>        Else Begin
78976>>>>>>>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
78977>>>>>>>>>>>>>>>            Set psNumPosLeft         to (psLeft(Self))
78978>>>>>>>>>>>>>>>            Set psNumPosRight        to (psRight(Self))
78979>>>>>>>>>>>>>>>            Set piNumPosPoints       to (piPoints(Self))
78980>>>>>>>>>>>>>>>        End
78980>>>>>>>>>>>>>>>>
78980>>>>>>>>>>>>>>>        
78980>>>>>>>>>>>>>>>        Send ParseFormat sNeg
78981>>>>>>>>>>>>>>>        If bCurrency Begin
78983>>>>>>>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
78984>>>>>>>>>>>>>>>            Set psCurNegLeft         to (psLeft(Self))
78985>>>>>>>>>>>>>>>            Set psCurNegRight        to (psRight(Self))
78986>>>>>>>>>>>>>>>            Set piCurNegPoints       to (piPoints(Self))
78987>>>>>>>>>>>>>>>        End
78987>>>>>>>>>>>>>>>>
78987>>>>>>>>>>>>>>>        Else Begin
78988>>>>>>>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
78989>>>>>>>>>>>>>>>            Set psNumNegLeft         to (psLeft(Self))
78990>>>>>>>>>>>>>>>            Set psNumNegRight        to (psRight(Self))
78991>>>>>>>>>>>>>>>            Set piNumNegPoints       to (piPoints(Self))
78992>>>>>>>>>>>>>>>        End
78992>>>>>>>>>>>>>>>>
78992>>>>>>>>>>>>>>>    End_Procedure
78993>>>>>>>>>>>>>>>    
78993>>>>>>>>>>>>>>>    // low level formatting. Pass parameters
78993>>>>>>>>>>>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
78995>>>>>>>>>>>>>>>        String  sLeft sRight sNumber sSep sDec
78995>>>>>>>>>>>>>>>        Integer iDec iLen iCh
78995>>>>>>>>>>>>>>>        
78995>>>>>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
78998>>>>>>>>>>>>>>>        Move (Character(iCh)) to sDec
78999>>>>>>>>>>>>>>>        
78999>>>>>>>>>>>>>>>        Move (abs(nNumber)) to sNumber
79000>>>>>>>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
79001>>>>>>>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
79002>>>>>>>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
79003>>>>>>>>>>>>>>>        // format for decimal separator
79003>>>>>>>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
79006>>>>>>>>>>>>>>>        
79006>>>>>>>>>>>>>>>        // format for thousand sep.
79006>>>>>>>>>>>>>>>        If bSep Begin
79008>>>>>>>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
79011>>>>>>>>>>>>>>>            Move (Character(iCh)) to sSep
79012>>>>>>>>>>>>>>>            Move (Length(sLeft)) to iLen
79013>>>>>>>>>>>>>>>            While (iLen>3)
79017>>>>>>>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
79018>>>>>>>>>>>>>>>                Move (iLen-3) to iLen
79019>>>>>>>>>>>>>>>            Loop
79020>>>>>>>>>>>>>>>>
79020>>>>>>>>>>>>>>>        End
79020>>>>>>>>>>>>>>>>
79020>>>>>>>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
79020>>>>>>>>>>>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
79023>>>>>>>>>>>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
79024>>>>>>>>>>>>>>>    End_Function
79025>>>>>>>>>>>>>>>    
79025>>>>>>>>>>>>>>>    // Public: Format for currency
79025>>>>>>>>>>>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
79027>>>>>>>>>>>>>>>        String  sLeft sRight
79027>>>>>>>>>>>>>>>        Integer bSep
79027>>>>>>>>>>>>>>>        If (nNumber<0) Begin
79029>>>>>>>>>>>>>>>            Get pbCurNegThousandsSep to bSep
79030>>>>>>>>>>>>>>>            Get psCurNegLeft         to sLeft
79031>>>>>>>>>>>>>>>            Get psCurNegRight        to sRight
79032>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
79035>>>>>>>>>>>>>>>        End
79035>>>>>>>>>>>>>>>>
79035>>>>>>>>>>>>>>>        Else Begin
79036>>>>>>>>>>>>>>>            Get pbCurPosThousandsSep to bSep
79037>>>>>>>>>>>>>>>            Get psCurPosLeft         to sLeft
79038>>>>>>>>>>>>>>>            Get psCurPosRight        to sRight
79039>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
79042>>>>>>>>>>>>>>>        End
79042>>>>>>>>>>>>>>>>
79042>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79043>>>>>>>>>>>>>>>    End_Function
79044>>>>>>>>>>>>>>>    
79044>>>>>>>>>>>>>>>    // Public: Format for numeric
79044>>>>>>>>>>>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
79046>>>>>>>>>>>>>>>        String  sLeft sRight
79046>>>>>>>>>>>>>>>        Integer bSep
79046>>>>>>>>>>>>>>>        If (nNumber<0) Begin
79048>>>>>>>>>>>>>>>            Get pbNumNegThousandsSep to bSep
79049>>>>>>>>>>>>>>>            Get psNumNegLeft         to sLeft
79050>>>>>>>>>>>>>>>            Get psNumNegRight        to sRight
79051>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
79054>>>>>>>>>>>>>>>        End
79054>>>>>>>>>>>>>>>>
79054>>>>>>>>>>>>>>>        Else Begin
79055>>>>>>>>>>>>>>>            Get pbNumPosThousandsSep to bSep
79056>>>>>>>>>>>>>>>            Get psNumPosLeft         to sLeft
79057>>>>>>>>>>>>>>>            Get psNumPosRight        to sRight
79058>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
79061>>>>>>>>>>>>>>>        End
79061>>>>>>>>>>>>>>>>
79061>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79062>>>>>>>>>>>>>>>    End_Function
79063>>>>>>>>>>>>>>>    
79063>>>>>>>>>>>>>>>    
79063>>>>>>>>>>>>>>>    // Public: Format passing format string
79063>>>>>>>>>>>>>>>    Function FormatVal Number nNumber String sFmt Returns String
79065>>>>>>>>>>>>>>>        Integer iPos bIsNeg
79065>>>>>>>>>>>>>>>        String  sLeft sRight
79065>>>>>>>>>>>>>>>        Integer iPoints bSep
79065>>>>>>>>>>>>>>>        Move (nNumber<0) to bIsNeg
79066>>>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
79067>>>>>>>>>>>>>>>        Case Begin
79067>>>>>>>>>>>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
79070>>>>>>>>>>>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
79074>>>>>>>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
79078>>>>>>>>>>>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
79080>>>>>>>>>>>>>>>        Case End
79080>>>>>>>>>>>>>>>        Send ParseFormat sFmt
79081>>>>>>>>>>>>>>>        Get pbThousandsSep to bSep
79082>>>>>>>>>>>>>>>        Get psLeft         to sLeft
79083>>>>>>>>>>>>>>>        Get psRight        to sRight
79084>>>>>>>>>>>>>>>        Get piPoints       to iPoints
79085>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79086>>>>>>>>>>>>>>>    End_Function
79087>>>>>>>>>>>>>>>    
79087>>>>>>>>>>>>>>>End_Class
79088>>>>>>>>>>>>>
79088>>>>>>>>>>>>>Global_Variable Handle ghoFormatter
79088>>>>>>>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
79089>>>>>>>>>>>>>
79089>>>>>>>>>>>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
79091>>>>>>>>>>>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
79092>>>>>>>>>>>>>End_Function
79093>>>>>>>>>>>>>
79093>>>>>>>>>>>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
79095>>>>>>>>>>>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
79096>>>>>>>>>>>>>End_Function
79097>>>>>>>>>>>>>
79097>>>>>>>>>>>>>Function FormatValue Global Number nNum String sFmt Returns String
79099>>>>>>>>>>>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
79100>>>>>>>>>>>>>End_Function
79101>>>>>>>>>>>>>
79101>>>>>>>>>>>>>Procedure SetCurrencyFormat Global String sFmt
79103>>>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt True
79104>>>>>>>>>>>>>End_Procedure
79105>>>>>>>>>>>>>
79105>>>>>>>>>>>>>Procedure SetNumberFormat Global String sFmt
79107>>>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt False
79108>>>>>>>>>>>>>End_Procedure
79109>>>>>>>>>>>>>
79109>>>>>>>>>>>>>
79109>>>>>>>>>>>Use tWinStructs.pkg
79109>>>>>>>>>>>
79109>>>>>>>>>>>Use cli.pkg
79109>>>>>>>>>>>Use DFBTRDRV.PKG
79109>>>>>>>>>>>Use MSSqldrv.pkg
79109>>>>>>>>>>>Use db2_drv.pkg
79109>>>>>>>>>>>Use odbc_drv.pkg
79109>>>>>>>>>>>Use seq_chnl.pkg
79109>>>>>>>>>>>
79109>>>>>>>>>>>Register_Function phoWorkspace Returns Handle
79109>>>>>>>>>>>Register_Function Help_filename Returns String
79109>>>>>>>>>>>Register_Function GetHelpFile Returns String
79109>>>>>>>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
79109>>>>>>>>>>>
79109>>>>>>>>>>>// *** Constant Declarations: ***
79109>>>>>>>>>>>//
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>// System icon menu constants. If the upper left hand
79109>>>>>>>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
79109>>>>>>>>>>>    Define SC_RESTORE  for |CI$F120
79109>>>>>>>>>>>    Define SC_MOVE     for |CI$F010
79109>>>>>>>>>>>    Define SC_SIZE     for |CI$F000
79109>>>>>>>>>>>    Define SC_MINIMIZE for |CI$F020
79109>>>>>>>>>>>    Define SC_MAXIMIZE for |CI$F030
79109>>>>>>>>>>>    Define SC_CLOSE    for |CI$F060
79109>>>>>>>>>>>    Define SC_KEYMENU  for |CI$F100
79109>>>>>>>>>>>    Define SC_NEXTWINDOW for |CI$F040
79109>>>>>>>>>>>    Define SC_PREVWINDOW for |CI$F050
79109>>>>>>>>>>>
79109>>>>>>>>>>>Define CS_SignProgram        for "signtool.exe"
79109>>>>>>>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
79109>>>>>>>>>>>Define CS_VerifyCredentials  for "verify"
79109>>>>>>>>>>>Define CS_VerifyFileParam    for "/a"
79109>>>>>>>>>>>Define CS_DefAuthVerPolicy   for "/pa"
79109>>>>>>>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
79109>>>>>>>>>>>
79109>>>>>>>>>>>// *** Struct Declarations: ***
79109>>>>>>>>>>>Struct AboutSHELLEXECUTEINFO
79109>>>>>>>>>>>    DWord   cbSize
79109>>>>>>>>>>>    Integer fMask
79109>>>>>>>>>>>    Handle  hwnd
79109>>>>>>>>>>>    Pointer lpVerb
79109>>>>>>>>>>>    Pointer lpFile
79109>>>>>>>>>>>    Pointer lpParameters
79109>>>>>>>>>>>    Pointer lpDirectory
79109>>>>>>>>>>>    Integer nShow
79109>>>>>>>>>>>    Integer iMissingAlignment1
79109>>>>>>>>>>>    Pointer hInstApp
79109>>>>>>>>>>>    Pointer lpIDList
79109>>>>>>>>>>>    Pointer lpClass
79109>>>>>>>>>>>    Handle  hkeyClass
79109>>>>>>>>>>>    DWord   dwHotKey
79109>>>>>>>>>>>    Integer iMissingAlignment2
79109>>>>>>>>>>>    Handle  hIconMonitor // Union
79109>>>>>>>>>>>    //Handle  hMonitor     // Union
79109>>>>>>>>>>>    Handle  hProcess
79109>>>>>>>>>>>End_Struct
79109>>>>>>>>>>>
79109>>>>>>>>>>>
79109>>>>>>>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
79109>>>>>>>>>>>//Type MEMORYSTATUS
79109>>>>>>>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
79109>>>>>>>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
79109>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
79109>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
79109>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
79109>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
79109>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
79109>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
79109>>>>>>>>>>>//End_Type
79109>>>>>>>>>>>
79109>>>>>>>>>>>// *** External Function calls: ***
79109>>>>>>>>>>>//
79109>>>>>>>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
79110>>>>>>>>>>>
79110>>>>>>>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
79111>>>>>>>>>>>
79111>>>>>>>>>>>// Do not call directly, use the wrapper function instead
79111>>>>>>>>>>>External_Function WNetGetUserW "WNetGetUserW" MPR.DLL ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
79112>>>>>>>>>>>
79112>>>>>>>>>>>    // Wrapper Function WNetGetUser
79112>>>>>>>>>>>    Function WNetGetUser Global ;        Pointer lpName ;        Pointer lpUser_Name ;        Pointer lpLength ;        Returns DWord
79114>>>>>>>>>>>
79114>>>>>>>>>>>        DWord   dwResult
79114>>>>>>>>>>>        UWide   uwName uwUserName
79114>>>>>>>>>>>        UWide   uwName uwUserName
79114>>>>>>>>>>>
79114>>>>>>>>>>>        Send StringToWide lpName (&uwName)
79115>>>>>>>>>>>
79115>>>>>>>>>>>        Send WideSetBuffer lpUser_Name lpLength (&uwUserName)
79116>>>>>>>>>>>
79116>>>>>>>>>>>        Move (WNetGetUserW (uwName.lpUText, uwUserName.lpUText, lpLength)) to dwResult
79117>>>>>>>>>>>
79117>>>>>>>>>>>        Send WideToString (&uwUserName) lpUser_Name
79118>>>>>>>>>>>
79118>>>>>>>>>>>        Function_Return dwResult
79119>>>>>>>>>>>    End_Function
79120>>>>>>>>>>>
79120>>>>>>>>>>>
79120>>>>>>>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
79121>>>>>>>>>>>
79121>>>>>>>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
79122>>>>>>>>>>>
79122>>>>>>>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
79123>>>>>>>>>>>
79123>>>>>>>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
79124>>>>>>>>>>>
79124>>>>>>>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
79125>>>>>>>>>>>
79125>>>>>>>>>>>// *** Global/Desktop Function Declarations: ***
79125>>>>>>>>>>>
79125>>>>>>>>>>>Function ComputerName Desktop Returns String
79127>>>>>>>>>>>    String sName
79127>>>>>>>>>>>    Get_Environment "COMPUTERNAME" to sName
79128>>>>>>>>>>>>
79128>>>>>>>>>>>    Function_Return sName
79129>>>>>>>>>>>End_Function
79130>>>>>>>>>>>
79130>>>>>>>>>>>Function Network_User_Name Desktop Returns String
79132>>>>>>>>>>>    WString wName
79132>>>>>>>>>>>    Integer iRetval iLength
79132>>>>>>>>>>>
79132>>>>>>>>>>>    Move 0 to iLength
79133>>>>>>>>>>>    Move (WNetGetUserW (0, 0, AddressOf (iLength))) to iRetval
79134>>>>>>>>>>>    Move (ZeroString(iLength)) to wName
79135>>>>>>>>>>>    Move (WNetGetUserW (0, AddressOf (wName), AddressOf (iLength))) to iRetval
79136>>>>>>>>>>>
79136>>>>>>>>>>>    If (iRetval = NO_ERROR) Begin
79138>>>>>>>>>>>        Function_Return (CString (wName))
79139>>>>>>>>>>>    End
79139>>>>>>>>>>>>
79139>>>>>>>>>>>
79139>>>>>>>>>>>    Function_Return "User Unknown"
79140>>>>>>>>>>>End_Function
79141>>>>>>>>>>>
79141>>>>>>>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
79143>>>>>>>>>>>    String sClient sDriver sClientDriver
79143>>>>>>>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
79143>>>>>>>>>>>    Handle hoMsqlDrv
79143>>>>>>>>>>>
79143>>>>>>>>>>>    Move 0 to iDriver
79144>>>>>>>>>>>    Move "" to sClient
79145>>>>>>>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
79148>>>>>>>>>>>    For iCount from 1 to iNumberOfDrivers
79154>>>>>>>>>>>>
79154>>>>>>>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
79157>>>>>>>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
79159>>>>>>>>>>>            Move iCount to iDriver
79160>>>>>>>>>>>            Move iNumberOfDrivers to iCount // We're done.
79161>>>>>>>>>>>        End
79161>>>>>>>>>>>>
79161>>>>>>>>>>>    Loop
79162>>>>>>>>>>>>
79162>>>>>>>>>>>
79162>>>>>>>>>>>    // This info is (at current) only available for the MS SQL driver:
79162>>>>>>>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
79164>>>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
79167>>>>>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
79168>>>>>>>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
79169>>>>>>>>>>>        Send Destroy of hoMsqlDrv
79170>>>>>>>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
79171>>>>>>>>>>>    End
79171>>>>>>>>>>>>
79171>>>>>>>>>>>
79171>>>>>>>>>>>    Function_Return sClient
79172>>>>>>>>>>>End_Function
79173>>>>>>>>>>>
79173>>>>>>>>>>>// *** Class Declarations: ***
79173>>>>>>>>>>>//
79173>>>>>>>>>>>Class cBitmapContainerDFLink is a BitmapContainer
79174>>>>>>>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
79176>>>>>>>>>>>        Send Mouse_Up iWindowNumber iPosition
79177>>>>>>>>>>>    End_Procedure
79178>>>>>>>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
79180>>>>>>>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
79182>>>>>>>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
79183>>>>>>>>>>>    End_Procedure
79184>>>>>>>>>>>End_Class
79185>>>>>>>>>>>
79185>>>>>>>>>>>Class cCopyEditorContentButton is a Button
79186>>>>>>>>>>>    Procedure Construct_Object
79188>>>>>>>>>>>        Forward Send Construct_Object
79190>>>>>>>>>>>        Property Handle phoEditorHandle
79191>>>>>>>>>>>        Set psToolTip to C_$DescCopy
79192>>>>>>>>>>>    End_Procedure
79193>>>>>>>>>>>
79193>>>>>>>>>>>    Procedure CopyToWindowsClipboard
79195>>>>>>>>>>>        Handle hoEditor
79195>>>>>>>>>>>        Boolean bCanCopy
79195>>>>>>>>>>>        Address aEditorAddress
79195>>>>>>>>>>>
79195>>>>>>>>>>>        Get phoEditorHandle to hoEditor
79196>>>>>>>>>>>        Send Select_All of hoEditor
79197>>>>>>>>>>>        Get CanCopy of hoEditor to bCanCopy
79198>>>>>>>>>>>        If (bCanCopy = True) Begin
79200>>>>>>>>>>>            Get paValue of hoEditor to aEditorAddress
79201>>>>>>>>>>>            Send Copy   of hoEditor
79202>>>>>>>>>>>            // Remove the selection after text is copied to the clipboard.
79202>>>>>>>>>>>            Send Beginning_of_Data of hoEditor
79203>>>>>>>>>>>            Send Info_Box C_$CopyToClipboard_Text
79204>>>>>>>>>>>        End
79204>>>>>>>>>>>>
79204>>>>>>>>>>>    End_Procedure
79205>>>>>>>>>>>End_Class
79206>>>>>>>>>>>
79206>>>>>>>>>>>Class SysinfoDisplay is a cTextEdit
79207>>>>>>>>>>>    Procedure Construct_Object
79209>>>>>>>>>>>        Forward Send Construct_Object
79211>>>>>>>>>>>
79211>>>>>>>>>>>        Set Size to 100 245
79212>>>>>>>>>>>        Set Location to 6 6
79213>>>>>>>>>>>        Set Border_Style to Border_None
79214>>>>>>>>>>>        Set Read_Only_State to True
79215>>>>>>>>>>>        Set pbWrap to True
79216>>>>>>>>>>>        Set peAnchors to anAll
79217>>>>>>>>>>>    End_Procedure
79218>>>>>>>>>>>
79218>>>>>>>>>>>    // Augmented class message to adjust certain text strings that are wrong...
79218>>>>>>>>>>>
79218>>>>>>>>>>>    Procedure AppendTextLn String sText
79220>>>>>>>>>>>        String sWorkspaceWSFile
79220>>>>>>>>>>>
79220>>>>>>>>>>>        // Only works for English:
79220>>>>>>>>>>>        If (ghoApplication > 0) Begin
79222>>>>>>>>>>>            If (sText contains "Workspace Name") Begin
79224>>>>>>>>>>>                Move "Workspace Config Filename:" to sText
79225>>>>>>>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
79226>>>>>>>>>>>                Move (sText * sWorkspaceWSFile) to sText
79227>>>>>>>>>>>            End
79227>>>>>>>>>>>>
79227>>>>>>>>>>>        End
79227>>>>>>>>>>>>
79227>>>>>>>>>>>        Send AppendText sText
79228>>>>>>>>>>>        Send AppendText (character(10))
79229>>>>>>>>>>>    End_Procedure
79230>>>>>>>>>>>
79230>>>>>>>>>>>    //    This method will show the name Of the current directory in the system
79230>>>>>>>>>>>    //    information box
79230>>>>>>>>>>>    Procedure Show_Current_Directory
79232>>>>>>>>>>>        String sDir
79232>>>>>>>>>>>
79232>>>>>>>>>>>        Get_Current_Directory To sDir
79233>>>>>>>>>>>
79233>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
79234>>>>>>>>>>>    End_Procedure
79235>>>>>>>>>>>
79235>>>>>>>>>>>    Procedure Show_Windows_Directory
79237>>>>>>>>>>>        String sWindir
79237>>>>>>>>>>>
79237>>>>>>>>>>>        Get_Windows_Directory To sWindir
79238>>>>>>>>>>>
79238>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
79239>>>>>>>>>>>    End_Procedure
79240>>>>>>>>>>>
79240>>>>>>>>>>>    Procedure Show_Current_User
79242>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
79243>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
79244>>>>>>>>>>>    End_Procedure
79245>>>>>>>>>>>
79245>>>>>>>>>>>    Procedure Show_Number_Format
79247>>>>>>>>>>>        Integer iFormat
79247>>>>>>>>>>>        String sFormatText
79247>>>>>>>>>>>
79247>>>>>>>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
79250>>>>>>>>>>>        Move (Character (iFormat)) To sFormatText
79251>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
79252>>>>>>>>>>>
79252>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
79255>>>>>>>>>>>        Move (Character (iFormat)) to sFormatText
79256>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
79257>>>>>>>>>>>    End_Procedure
79258>>>>>>>>>>>
79258>>>>>>>>>>>    Procedure Show_Filelist_Name
79260>>>>>>>>>>>        String sFilename
79260>>>>>>>>>>>
79260>>>>>>>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
79263>>>>>>>>>>>
79263>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
79264>>>>>>>>>>>    End_Procedure
79265>>>>>>>>>>>
79265>>>>>>>>>>>    Procedure Show_Lock_Delay
79267>>>>>>>>>>>        Integer iLockdelay
79267>>>>>>>>>>>
79267>>>>>>>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
79270>>>>>>>>>>>
79270>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
79271>>>>>>>>>>>    End_Procedure
79272>>>>>>>>>>>
79272>>>>>>>>>>>    Procedure Show_Lock_Timeout
79274>>>>>>>>>>>        Integer iLockTimeout
79274>>>>>>>>>>>
79274>>>>>>>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
79277>>>>>>>>>>>
79277>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
79278>>>>>>>>>>>    End_Procedure
79279>>>>>>>>>>>
79279>>>>>>>>>>>    Procedure Show_Screen_Size
79281>>>>>>>>>>>        Integer iYscreensize iXscreensize
79281>>>>>>>>>>>
79281>>>>>>>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
79282>>>>>>>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
79283>>>>>>>>>>>
79283>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
79284>>>>>>>>>>>    End_Procedure
79285>>>>>>>>>>>
79285>>>>>>>>>>>    Procedure Show_Page_Size
79287>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
79288>>>>>>>>>>>    End_procedure
79289>>>>>>>>>>>
79289>>>>>>>>>>>    Procedure Show_Date
79291>>>>>>>>>>>        Date dToday
79291>>>>>>>>>>>
79291>>>>>>>>>>>        Move (CurrentDateTime()) to dToday
79292>>>>>>>>>>>
79292>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
79293>>>>>>>>>>>    End_procedure
79294>>>>>>>>>>>
79294>>>>>>>>>>>    Procedure Show_Date_Format
79296>>>>>>>>>>>        Integer iDateFormat
79296>>>>>>>>>>>        String sDateFormat
79296>>>>>>>>>>>
79296>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
79299>>>>>>>>>>>        Case Begin
79299>>>>>>>>>>>            Case (iDateFormat = DF_DATE_USA)
79301>>>>>>>>>>>                Move C_$USA To sDateFormat
79302>>>>>>>>>>>                Case Break
79303>>>>>>>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
79306>>>>>>>>>>>                Move C_$European To sDateFormat
79307>>>>>>>>>>>                Case Break
79308>>>>>>>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
79311>>>>>>>>>>>                Move C_$Military To sDateFormat
79312>>>>>>>>>>>                Case Break
79313>>>>>>>>>>>            Case Else
79313>>>>>>>>>>>                Move C_$UnknownDateType To sDateFormat
79314>>>>>>>>>>>                Case Break
79315>>>>>>>>>>>        Case End
79315>>>>>>>>>>>
79315>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
79316>>>>>>>>>>>    End_Procedure
79317>>>>>>>>>>>
79317>>>>>>>>>>>    // 2013-08-14 NGS
79317>>>>>>>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
79317>>>>>>>>>>>    Procedure Show_Systemresources
79319>>>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
79319>>>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
79319>>>>>>>>>>>        Integer iRetval
79319>>>>>>>>>>>        Number nValue
79319>>>>>>>>>>>        String sValue
79319>>>>>>>>>>>
79319>>>>>>>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
79320>>>>>>>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
79321>>>>>>>>>>>        If (iRetval = 0) Begin
79323>>>>>>>>>>>            Move (ShowLastError ()) to iRetval
79324>>>>>>>>>>>            Procedure_Return
79325>>>>>>>>>>>        End
79325>>>>>>>>>>>>
79325>>>>>>>>>>>
79325>>>>>>>>>>>        Send AppendTextLn ""
79326>>>>>>>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
79327>>>>>>>>>>>
79327>>>>>>>>>>>        // Show memory in Gigabytes:
79327>>>>>>>>>>>        Move (nValue/1024/1024/1024) to nValue
79328>>>>>>>>>>>        Move (Round(nValue)) to nValue
79329>>>>>>>>>>>        Get FormatNumber nValue 2 to sValue
79330>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
79331>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
79332>>>>>>>>>>>
79332>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
79332>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
79333>>>>>>>>>>>        Move (Round(nValue)) to nValue
79334>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79335>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
79336>>>>>>>>>>>
79336>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
79336>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
79337>>>>>>>>>>>        Move (Round(nValue)) to nValue
79338>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79339>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
79340>>>>>>>>>>>
79340>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
79340>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
79341>>>>>>>>>>>        Move (Round(nValue)) to nValue
79342>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79343>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
79344>>>>>>>>>>>
79344>>>>>>>>>>>        // Add an empty row after the memory information:
79344>>>>>>>>>>>        Send AppendTextLn ""
79345>>>>>>>>>>>    End_Procedure
79346>>>>>>>>>>>
79346>>>>>>>>>>>    Procedure Show_Registration
79348>>>>>>>>>>>        String sRegName
79348>>>>>>>>>>>        Integer iSN iUsersMax iUserCount
79348>>>>>>>>>>>
79348>>>>>>>>>>>        Registration sRegName iSN
79349>>>>>>>>>>>>
79349>>>>>>>>>>>        Get_Licensed_Max_Users to iUsersMax
79350>>>>>>>>>>>        Get_Current_User_Count to iUserCount
79351>>>>>>>>>>>
79351>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
79352>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
79353>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
79354>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
79355>>>>>>>>>>>    End_Procedure
79356>>>>>>>>>>>
79356>>>>>>>>>>>    //****************************************************************************
79356>>>>>>>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
79356>>>>>>>>>>>    // To the workspace object passing the an object and message To send back
79356>>>>>>>>>>>    // To this object. It is expected that the workspace object will send this
79356>>>>>>>>>>>    // message for every line Of information it wants displayed (passing the
79356>>>>>>>>>>>    // information To be displayed
79356>>>>>>>>>>>    //****************************************************************************
79356>>>>>>>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
79356>>>>>>>>>>>
79356>>>>>>>>>>>    Procedure Show_ServicePack
79358>>>>>>>>>>>        String sKey sVersion sDataFlex
79358>>>>>>>>>>>        Handle hoRegistry
79358>>>>>>>>>>>        Boolean bExists bOpened
79358>>>>>>>>>>>
79358>>>>>>>>>>>        Move "DataFlex"        to sDataFlex
79359>>>>>>>>>>>
79359>>>>>>>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
79360>>>>>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
79361>>>>>>>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
79362>>>>>>>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
79363>>>>>>>>>>>
79363>>>>>>>>>>>        If (bExists) Begin
79365>>>>>>>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79366>>>>>>>>>>>        End
79366>>>>>>>>>>>>
79366>>>>>>>>>>>        Else Begin
79367>>>>>>>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79368>>>>>>>>>>>        End
79368>>>>>>>>>>>>
79368>>>>>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
79369>>>>>>>>>>>        If (bExists) Begin
79371>>>>>>>>>>>            Get OpenKey of hoRegistry sKey to bOpened
79372>>>>>>>>>>>            If (bOpened) Begin
79374>>>>>>>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
79375>>>>>>>>>>>                If (bExists) Begin
79377>>>>>>>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
79378>>>>>>>>>>>                End
79378>>>>>>>>>>>>
79378>>>>>>>>>>>                Send CloseKey of hoRegistry
79379>>>>>>>>>>>            End
79379>>>>>>>>>>>>
79379>>>>>>>>>>>        End
79379>>>>>>>>>>>>
79379>>>>>>>>>>>        Send Destroy of hoRegistry
79380>>>>>>>>>>>
79380>>>>>>>>>>>        If (sVersion <> "") Begin
79382>>>>>>>>>>>           Send AppendTextLn sVersion
79383>>>>>>>>>>>           Send AppendTextLn ""
79384>>>>>>>>>>>        End
79384>>>>>>>>>>>>
79384>>>>>>>>>>>    End_Procedure
79385>>>>>>>>>>>
79385>>>>>>>>>>>    Procedure Show_WorkspaceInformation
79387>>>>>>>>>>>        Integer hoWorkspace
79387>>>>>>>>>>>
79387>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79389>>>>>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
79390>>>>>>>>>>>            If (hoWorkspace <> 0) Begin
79392>>>>>>>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
79393>>>>>>>>>>>            End
79393>>>>>>>>>>>>
79393>>>>>>>>>>>        End
79393>>>>>>>>>>>>
79393>>>>>>>>>>>    End_Procedure
79394>>>>>>>>>>>
79394>>>>>>>>>>>    //****************************************************************************
79394>>>>>>>>>>>    // If connection ids are used, we will send the message EnumerateConnections
79394>>>>>>>>>>>    // to the connection manager object passing the an object and message to send
79394>>>>>>>>>>>    // back to this object. It is expected that the connection manager object will
79394>>>>>>>>>>>    // send this message for every line Of information it wants displayed (passing
79394>>>>>>>>>>>    // the information To be displayed
79394>>>>>>>>>>>    //****************************************************************************
79394>>>>>>>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
79394>>>>>>>>>>>
79394>>>>>>>>>>>    Procedure Show_ConnectionIdInformation
79396>>>>>>>>>>>        If (ghoConnection > 0) Begin
79398>>>>>>>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
79399>>>>>>>>>>>            Send AppendTextLn ""
79400>>>>>>>>>>>        End
79400>>>>>>>>>>>>
79400>>>>>>>>>>>    End_Procedure
79401>>>>>>>>>>>
79401>>>>>>>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
79403>>>>>>>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
79404>>>>>>>>>>>    End_Function
79405>>>>>>>>>>>
79405>>>>>>>>>>>    Procedure Show_Versions
79407>>>>>>>>>>>        Integer iVersion iRevision iBuild
79407>>>>>>>>>>>
79407>>>>>>>>>>>        Version_information iVersion iRevision iBuild
79409>>>>>>>>>>>
79409>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
79410>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
79411>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
79412>>>>>>>>>>>        Send AppendTextLn "This is a 64-bit exe file"
79413>>>>>>>>>>>    End_Procedure
79414>>>>>>>>>>>
79414>>>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
79416>>>>>>>>>>>        Boolean bOK
79416>>>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
79417>>>>>>>>>>>        Function_Return bOK
79418>>>>>>>>>>>    End_Function
79419>>>>>>>>>>>
79419>>>>>>>>>>>    //***
79419>>>>>>>>>>>    //*** BW
79419>>>>>>>>>>>    //*** Procedure: Show_Drivers
79419>>>>>>>>>>>    //*** Purpose  : Show loaded database drivers
79419>>>>>>>>>>>    //***
79419>>>>>>>>>>>
79419>>>>>>>>>>>//#IF (Required_FMAC_Build > 106)
79419>>>>>>>>>>>//    #Warning -3
79419>>>>>>>>>>>//#ENDIF
79419>>>>>>>>>>>    Procedure Show_Drivers
79421>>>>>>>>>>>        String sDriverID sVersion sClient sValue
79421>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
79421>>>>>>>>>>>        Handle hoCLIHandler hoBtrvHandler
79421>>>>>>>>>>>        Boolean bStudioLicense bIsDAWDriver
79421>>>>>>>>>>>
79421>>>>>>>>>>>        Move False to bStudioLicense
79422>>>>>>>>>>>
79422>>>>>>>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
79423>>>>>>>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
79424>>>>>>>>>>>
79424>>>>>>>>>>>        // For testing purposes:
79424>>>>>>>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79424>>>>>>>>>>>//        Load_Driver MSSQLDRV_ID
79424>>>>>>>>>>>//        Load_Driver ODBC_DRV_ID
79424>>>>>>>>>>>//        Load_Driver DB2_DRV_ID
79424>>>>>>>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79424>>>>>>>>>>>//
79424>>>>>>>>>>>        Move False to Err
79425>>>>>>>>>>>
79425>>>>>>>>>>>        // Loop through all loaded drivers.
79425>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
79428>>>>>>>>>>>        If (iNumberOfDrivers > 1) Begin
79430>>>>>>>>>>>            Send AppendTextLn ""
79431>>>>>>>>>>>        End
79431>>>>>>>>>>>>
79431>>>>>>>>>>>        For iDriver from 1 to iNumberOfDrivers
79437>>>>>>>>>>>>
79437>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
79438>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
79441>>>>>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
79442>>>>>>>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
79443>>>>>>>>>>>
79443>>>>>>>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True) Begin
79445>>>>>>>>>>>
79445>>>>>>>>>>>                // Pervasive/Btrieve database
79445>>>>>>>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
79447>>>>>>>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
79448>>>>>>>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
79449>>>>>>>>>>>                    If (sClient <> "0.0.0") Begin
79451>>>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
79452>>>>>>>>>>>                    End
79452>>>>>>>>>>>>
79452>>>>>>>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
79453>>>>>>>>>>>                    If (sClient <> "0.0.0") Begin
79455>>>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
79456>>>>>>>>>>>                    End
79456>>>>>>>>>>>>
79456>>>>>>>>>>>                End
79456>>>>>>>>>>>>
79456>>>>>>>>>>>
79456>>>>>>>>>>>                Else Begin
79457>>>>>>>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
79458>>>>>>>>>>>                    Move 0 to iNumServers
79459>>>>>>>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
79461>>>>>>>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
79464>>>>>>>>>>>                    End
79464>>>>>>>>>>>>
79464>>>>>>>>>>>
79464>>>>>>>>>>>                    If (bIsDAWDriver = True) Begin
79466>>>>>>>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
79468>>>>>>>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
79469>>>>>>>>>>>                        End
79469>>>>>>>>>>>>
79469>>>>>>>>>>>                        Get CKRevision of hoCLIHandler to sVersion
79470>>>>>>>>>>>                    End
79470>>>>>>>>>>>>
79470>>>>>>>>>>>
79470>>>>>>>>>>>                    // If the serialnumber is = 0, it means that the
79470>>>>>>>>>>>                    // Studio licens is in use and there is no
79470>>>>>>>>>>>                    // number of max users defined because the driver is
79470>>>>>>>>>>>                    // relying on the info from the VDF license.
79470>>>>>>>>>>>                    If (bStudioLicense = False) Begin
79472>>>>>>>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
79473>>>>>>>>>>>                        Move (iSerialNo = 0) to bStudioLicense
79474>>>>>>>>>>>                    End
79474>>>>>>>>>>>>
79474>>>>>>>>>>>                End
79474>>>>>>>>>>>>
79474>>>>>>>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
79475>>>>>>>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
79477>>>>>>>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
79478>>>>>>>>>>>                End
79478>>>>>>>>>>>>
79478>>>>>>>>>>>                If (iNumServers <> 0) Begin
79480>>>>>>>>>>>                    For iCount from 1 to iNumServers
79486>>>>>>>>>>>>
79486>>>>>>>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
79489>>>>>>>>>>>                        If (not(sValue contains ";PWD=")) Begin
79491>>>>>>>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
79492>>>>>>>>>>>                        End
79492>>>>>>>>>>>>
79492>>>>>>>>>>>                    Loop
79493>>>>>>>>>>>>
79493>>>>>>>>>>>                End
79493>>>>>>>>>>>>
79493>>>>>>>>>>>            End
79493>>>>>>>>>>>>
79493>>>>>>>>>>>        Loop
79494>>>>>>>>>>>>
79494>>>>>>>>>>>
79494>>>>>>>>>>>        Send AppendTextLn ""
79495>>>>>>>>>>>        If (bStudioLicense = False) Begin
79497>>>>>>>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
79498>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
79499>>>>>>>>>>>        End
79499>>>>>>>>>>>>
79499>>>>>>>>>>>        Else Begin
79500>>>>>>>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
79501>>>>>>>>>>>        End
79501>>>>>>>>>>>>
79501>>>>>>>>>>>        Send Destroy of hoCLIHandler
79502>>>>>>>>>>>        Send Destroy of hoBtrvHandler
79503>>>>>>>>>>>    End_Procedure
79504>>>>>>>>>>>
79504>>>>>>>>>>>    Procedure Show_HelpFile
79506>>>>>>>>>>>        String sHelpFile
79506>>>>>>>>>>>        Integer eHelpType
79506>>>>>>>>>>>
79506>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79508>>>>>>>>>>>            Get peHelpType Of ghoApplication To eHelpType
79509>>>>>>>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
79511>>>>>>>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
79512>>>>>>>>>>>            End
79512>>>>>>>>>>>>
79512>>>>>>>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
79515>>>>>>>>>>>                Get Help_filename Of Help_object_id To sHelpFile
79516>>>>>>>>>>>            End
79516>>>>>>>>>>>>
79516>>>>>>>>>>>            Else Begin
79517>>>>>>>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
79518>>>>>>>>>>>            End
79518>>>>>>>>>>>>
79518>>>>>>>>>>>
79518>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
79519>>>>>>>>>>>        End
79519>>>>>>>>>>>>
79519>>>>>>>>>>>    End_Procedure
79520>>>>>>>>>>>
79520>>>>>>>>>>>    Procedure Show_EnterAsTab
79522>>>>>>>>>>>        Boolean bEnterKeyAsTabKey
79522>>>>>>>>>>>        String sText
79522>>>>>>>>>>>
79522>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79524>>>>>>>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
79525>>>>>>>>>>>            If (bEnterKeyAsTabKey) Begin
79527>>>>>>>>>>>                Move "True" To sText
79528>>>>>>>>>>>            End
79528>>>>>>>>>>>>
79528>>>>>>>>>>>            Else Begin
79529>>>>>>>>>>>                Move "False" To sText
79530>>>>>>>>>>>            End
79530>>>>>>>>>>>>
79530>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
79531>>>>>>>>>>>        End
79531>>>>>>>>>>>>
79531>>>>>>>>>>>    End_Procedure
79532>>>>>>>>>>>
79532>>>>>>>>>>>    //    During activation we will remove the old information and add the newly
79532>>>>>>>>>>>    //    found systeminformation
79532>>>>>>>>>>>    Procedure Add_Focus Integer hoRoot
79534>>>>>>>>>>>        Forward Send Add_Focus hoRoot
79536>>>>>>>>>>>
79536>>>>>>>>>>>        Send Delete_Data
79537>>>>>>>>>>>
79537>>>>>>>>>>>        Set Changed_State To False
79538>>>>>>>>>>>        Set Read_Only_State To True
79539>>>>>>>>>>>
79539>>>>>>>>>>>        Send Show_Registration
79540>>>>>>>>>>>        Send Show_Drivers
79541>>>>>>>>>>>        Send Show_ServicePack
79542>>>>>>>>>>>        Send Show_Versions
79543>>>>>>>>>>>        Send AppendTextLn ""
79544>>>>>>>>>>>
79544>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79546>>>>>>>>>>>            Send Show_WorkSpaceInformation
79547>>>>>>>>>>>            Send Show_HelpFile
79548>>>>>>>>>>>            Send AppendTextLn ""
79549>>>>>>>>>>>        End
79549>>>>>>>>>>>>
79549>>>>>>>>>>>        Else Begin
79550>>>>>>>>>>>            Send AppendTextLn ""
79551>>>>>>>>>>>        End
79551>>>>>>>>>>>>
79551>>>>>>>>>>>
79551>>>>>>>>>>>        If (ghoConnection <> 0) Begin
79553>>>>>>>>>>>            Send Show_ConnectionIdInformation
79554>>>>>>>>>>>        End
79554>>>>>>>>>>>>
79554>>>>>>>>>>>
79554>>>>>>>>>>>        Send Show_Current_User
79555>>>>>>>>>>>        Send Show_Windows_Directory
79556>>>>>>>>>>>        Send Show_Current_Directory
79557>>>>>>>>>>>
79557>>>>>>>>>>>        // This is already shown in the workspace details,
79557>>>>>>>>>>>        // unless no workspace object is present:
79557>>>>>>>>>>>        If (ghoApplication = 0) Begin
79559>>>>>>>>>>>            Send Show_Filelist_Name
79560>>>>>>>>>>>        End
79560>>>>>>>>>>>>
79560>>>>>>>>>>>
79560>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79562>>>>>>>>>>>            Send AppendTextLn ""
79563>>>>>>>>>>>            Send Show_EnterAsTab
79564>>>>>>>>>>>        End
79564>>>>>>>>>>>>
79564>>>>>>>>>>>
79564>>>>>>>>>>>        Send Show_Screen_Size
79565>>>>>>>>>>>        Send Show_Page_Size
79566>>>>>>>>>>>        Send Show_Number_Format
79567>>>>>>>>>>>        Send Show_Date_Format
79568>>>>>>>>>>>        Send Show_Lock_Delay
79569>>>>>>>>>>>        Send Show_Lock_Timeout
79570>>>>>>>>>>>        Send Show_Date
79571>>>>>>>>>>>        Send Show_Systemresources
79572>>>>>>>>>>>        Send Beginning_of_Data
79573>>>>>>>>>>>
79573>>>>>>>>>>>        Set Icon to 'default.ico'
79574>>>>>>>>>>>    End_Procedure
79575>>>>>>>>>>>End_Class
79576>>>>>>>>>>>
79576>>>>>>>>>>>Class SysInfoDialog is a ModalPanel
79577>>>>>>>>>>>    Procedure Construct_Object
79579>>>>>>>>>>>        Forward Send Construct_Object
79581>>>>>>>>>>>
79581>>>>>>>>>>>        Set Label to C_$SystemInformation
79582>>>>>>>>>>>        Set Size to 140 267
79583>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79584>>>>>>>>>>>        Set Border_Style to Border_Thick
79585>>>>>>>>>>>        Set Sysmenu_Icon to False
79586>>>>>>>>>>>
79586>>>>>>>>>>>        // "+1" will make the panel to paint correctly.
79586>>>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
79587>>>>>>>>>>>
79587>>>>>>>>>>>        // 2014-09-14 NGS
79587>>>>>>>>>>>        // Added a container object around the cTexteditor
79587>>>>>>>>>>>        // object to get a border around the text.
79587>>>>>>>>>>>        Object oSysinfoDisplayContainer is a Container3d
79589>>>>>>>>>>>            Set Location to 2 4
79590>>>>>>>>>>>            Set Size to 110 255
79591>>>>>>>>>>>            Set Border_Style to Border_ClientEdge
79592>>>>>>>>>>>            Set Color to clWhite
79593>>>>>>>>>>>            Set peAnchors to anAll
79594>>>>>>>>>>>
79594>>>>>>>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
79596>>>>>>>>>>>            End_Object
79597>>>>>>>>>>>
79597>>>>>>>>>>>        End_Object
79598>>>>>>>>>>>
79598>>>>>>>>>>>        Object oCloseButton is a Button
79600>>>>>>>>>>>            Set Label to C_$Close
79601>>>>>>>>>>>            Set Location to 120 210
79602>>>>>>>>>>>            CompilerWarnings Off
79602>>>>>>>>>>>            Set Message Item 0 to msg_Close_Panel
79603>>>>>>>>>>>            CompilerWarnings On
79603>>>>>>>>>>>            Set Default_State To True
79604>>>>>>>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
79604>>>>>>>>>>>            // and changes its peAnchors, we might as well prepare this object
79604>>>>>>>>>>>            // for that situation.
79604>>>>>>>>>>>            Set peAnchors to anBottomRight
79605>>>>>>>>>>>        End_Object
79606>>>>>>>>>>>
79606>>>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79608>>>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79609>>>>>>>>>>>            Set Size to 14 50
79610>>>>>>>>>>>            Set Location to 120 158
79611>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79611>>>>>>>>>>>            // we might as well prepare the object for it.
79611>>>>>>>>>>>            Set peAnchors to anBottomRight
79612>>>>>>>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
79613>>>>>>>>>>>        End_Object
79614>>>>>>>>>>>
79614>>>>>>>>>>>        On_Key kCancel Send Close_Panel
79615>>>>>>>>>>>    End_Procedure
79616>>>>>>>>>>>
79616>>>>>>>>>>>    Procedure Page Integer iPageObject
79618>>>>>>>>>>>        Handle hMenu
79618>>>>>>>>>>>        Integer iPrevState
79618>>>>>>>>>>>
79618>>>>>>>>>>>        Forward Send Page iPageObject
79620>>>>>>>>>>>
79620>>>>>>>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
79620>>>>>>>>>>>        //
79620>>>>>>>>>>>    End_Procedure
79621>>>>>>>>>>>
79621>>>>>>>>>>>End_Class
79622>>>>>>>>>>>
79622>>>>>>>>>>>Class cAboutEdit is an cRichEdit
79623>>>>>>>>>>>    Procedure Construct_Object
79625>>>>>>>>>>>        Forward Send Construct_Object
79627>>>>>>>>>>>
79627>>>>>>>>>>>        Property String psContentText
79628>>>>>>>>>>>
79628>>>>>>>>>>>        Set Size to 77 153
79629>>>>>>>>>>>        Set Location to 8 60
79630>>>>>>>>>>>        Set Read_Only_State to True
79631>>>>>>>>>>>        Set Skip_State to True
79632>>>>>>>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
79632>>>>>>>>>>>        // or 1/20 of a printer's point.
79632>>>>>>>>>>>        Set piRightMargin to (0.1 * 1440)
79633>>>>>>>>>>>        Set Border_Style  to Border_None
79634>>>>>>>>>>>    End_Procedure
79635>>>>>>>>>>>
79635>>>>>>>>>>>    // Adds a line of text to the edit object
79635>>>>>>>>>>>    Procedure Add_Line String sText
79637>>>>>>>>>>>        String sContentText
79637>>>>>>>>>>>        Get psContentText to sContentText
79638>>>>>>>>>>>        Move (sContentText + String(sText)) to sContentText
79639>>>>>>>>>>>        Set psContentText to sContentText
79640>>>>>>>>>>>    End_Procedure
79641>>>>>>>>>>>
79641>>>>>>>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
79641>>>>>>>>>>>    // Note that we use a property psContentText and add to it,
79641>>>>>>>>>>>    // because the object isn't paged yet when we add these
79641>>>>>>>>>>>    // values and the COM edit object needs to be paged
79641>>>>>>>>>>>    // for the text to become visible. See Also: Procedure Page below.
79641>>>>>>>>>>>    Procedure Add_LineLn String sText
79643>>>>>>>>>>>        String sContentText sCR
79643>>>>>>>>>>>
79643>>>>>>>>>>>        Move (Character(10) + String(Character(13))) to sCR
79644>>>>>>>>>>>        Get psContentText to sContentText
79645>>>>>>>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
79646>>>>>>>>>>>        Set psContentText to sContentText
79647>>>>>>>>>>>    End_Procedure
79648>>>>>>>>>>>
79648>>>>>>>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
79650>>>>>>>>>>>        String sLinkText
79650>>>>>>>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
79651>>>>>>>>>>>        Send Show_HomePage sLinkText
79652>>>>>>>>>>>    End_Procedure
79653>>>>>>>>>>>
79653>>>>>>>>>>>    Procedure Page Integer iPageObject
79655>>>>>>>>>>>        String sContentText
79655>>>>>>>>>>>
79655>>>>>>>>>>>        Forward Send Page iPageObject
79657>>>>>>>>>>>        Get psContentText to sContentText
79658>>>>>>>>>>>        Send AppendText sContentText
79659>>>>>>>>>>>        send Beginning_of_Data
79660>>>>>>>>>>>    End_Procedure
79661>>>>>>>>>>>
79661>>>>>>>>>>>End_Class
79662>>>>>>>>>>>
79662>>>>>>>>>>>Class AboutDialog is a ModalPanel
79663>>>>>>>>>>>    Procedure Construct_Object
79665>>>>>>>>>>>
79665>>>>>>>>>>>        Forward Send Construct_Object
79667>>>>>>>>>>>
79667>>>>>>>>>>>        Set Label to C_$About
79668>>>>>>>>>>>        Set Size to 118 230
79669>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79670>>>>>>>>>>>        Set Border_Style to Border_Thick
79671>>>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
79672>>>>>>>>>>>
79672>>>>>>>>>>>        Object oSysInfoDialog is a SysInfoDialog
79674>>>>>>>>>>>        End_Object
79675>>>>>>>>>>>
79675>>>>>>>>>>>        Object oBox is a Container3d
79677>>>>>>>>>>>            Set Border_Style to Border_Normal
79678>>>>>>>>>>>            Set Size to 90 220
79679>>>>>>>>>>>            Set Location to 4 5
79680>>>>>>>>>>>            Set Color to clWhite
79681>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79681>>>>>>>>>>>            // we might as well prepare the object for it.
79681>>>>>>>>>>>            Set peAnchors to anAll
79682>>>>>>>>>>>
79682>>>>>>>>>>>            Object oAboutGraphic is a BitmapContainer
79684>>>>>>>>>>>                Set Border_Style To Border_None
79685>>>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
79686>>>>>>>>>>>                Set Color to clWhite
79687>>>>>>>>>>>                Set Size to 45 50
79688>>>>>>>>>>>                Set Location to 0 3
79689>>>>>>>>>>>            End_Object
79690>>>>>>>>>>>
79690>>>>>>>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
79692>>>>>>>>>>>                Set Border_Style to Border_None
79693>>>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
79694>>>>>>>>>>>                Set Color to clWhite
79695>>>>>>>>>>>                Set Size to 30 55
79696>>>>>>>>>>>                Set Location to 50 3
79697>>>>>>>>>>>            End_Object
79698>>>>>>>>>>>
79698>>>>>>>>>>>            Object oInfoList_Editor is an cAboutEdit
79700>>>>>>>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
79700>>>>>>>>>>>                // we might as well prepare the object for it.
79700>>>>>>>>>>>                Set peAnchors to anAll
79701>>>>>>>>>>>            End_Object
79702>>>>>>>>>>>
79702>>>>>>>>>>>            // These objects are here for backwards compatability only.
79702>>>>>>>>>>>            // They are not used.
79702>>>>>>>>>>>            Object oProductName is a TextBox
79704>>>>>>>>>>>                Set Label To C_$ProductName
79705>>>>>>>>>>>                Set Size To 10 45
79706>>>>>>>>>>>                Set Location To 8 53
79707>>>>>>>>>>>                Set Visible_State to False
79708>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79709>>>>>>>>>>>            End_Object
79710>>>>>>>>>>>
79710>>>>>>>>>>>            Object oVersion is a TextBox
79712>>>>>>>>>>>                Set Label To C_$Version
79713>>>>>>>>>>>                Set Size To 10 25
79714>>>>>>>>>>>                Set Location To 21 53
79715>>>>>>>>>>>                Set Visible_State to False
79716>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79717>>>>>>>>>>>            End_Object
79718>>>>>>>>>>>
79718>>>>>>>>>>>            Object oCopyright is a TextBox
79720>>>>>>>>>>>                Set Label To C_$Copyright
79721>>>>>>>>>>>                Set Size To 10 31
79722>>>>>>>>>>>                Set Location To 34 53
79723>>>>>>>>>>>                Set Visible_State to False
79724>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79725>>>>>>>>>>>            End_Object
79726>>>>>>>>>>>
79726>>>>>>>>>>>            Object oAuthor is a TextBox
79728>>>>>>>>>>>                Set Label To C_$Author
79729>>>>>>>>>>>                Set Size To 10 22
79730>>>>>>>>>>>                Set Location To 46 53
79731>>>>>>>>>>>                Set Visible_State to False
79732>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79733>>>>>>>>>>>            End_Object
79734>>>>>>>>>>>
79734>>>>>>>>>>>        End_Object
79735>>>>>>>>>>>
79735>>>>>>>>>>>        Object oOKButton is a Button
79737>>>>>>>>>>>            On_Item C_$Close Send Close_Panel
79738>>>>>>>>>>>            Set Location to 98 176
79739>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79739>>>>>>>>>>>            // we might as well prepare the object for it.
79739>>>>>>>>>>>            Set peAnchors to anBottomRight
79740>>>>>>>>>>>        End_Object
79741>>>>>>>>>>>
79741>>>>>>>>>>>        Object oSysInfoButton is a Button
79743>>>>>>>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
79744>>>>>>>>>>>            Set Location to 98 123
79745>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79745>>>>>>>>>>>            // we might as well prepare the object for it.
79745>>>>>>>>>>>            Set peAnchors to anBottomRight
79746>>>>>>>>>>>        End_Object
79747>>>>>>>>>>>
79747>>>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79749>>>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79750>>>>>>>>>>>            Set Size to 14 50
79751>>>>>>>>>>>            Set Location to 98 70
79752>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79752>>>>>>>>>>>            // we might as well prepare the object for it.
79752>>>>>>>>>>>            Set peAnchors to anBottomRight
79753>>>>>>>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
79754>>>>>>>>>>>        End_Object
79755>>>>>>>>>>>
79755>>>>>>>>>>>        On_Key Kcancel Send KeyAction of oOKButton
79756>>>>>>>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
79757>>>>>>>>>>>        Set LogoDF to "DF32.bmp"
79758>>>>>>>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
79758>>>>>>>>>>>    End_Procedure
79759>>>>>>>>>>>
79759>>>>>>>>>>>    Procedure Page Integer iPageObject
79761>>>>>>>>>>>        Handle hMenu
79761>>>>>>>>>>>        Integer iPrevState
79761>>>>>>>>>>>
79761>>>>>>>>>>>        Forward Send Page iPageObject
79763>>>>>>>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
79763>>>>>>>>>>>        Set Icon to "Default.ico"
79764>>>>>>>>>>>
79764>>>>>>>>>>>        // Shadow upper left corner menu items: (icon menu items)
79764>>>>>>>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
79765>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79766>>>>>>>>>>>        // The "Move" menu command may come in handy to have.
79766>>>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79766>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79767>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79768>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79769>>>>>>>>>>>        // The "Close" menu command may be good to have.
79769>>>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79769>>>>>>>>>>>    End_Procedure
79770>>>>>>>>>>>
79770>>>>>>>>>>>    Procedure Set ProductName String sText
79772>>>>>>>>>>>        Set Value of oProductName to sText
79773>>>>>>>>>>>    End_Procedure
79774>>>>>>>>>>>
79774>>>>>>>>>>>    Procedure Set Copyright String sText
79776>>>>>>>>>>>        Set Value of oCopyright to sText
79777>>>>>>>>>>>    End_Procedure
79778>>>>>>>>>>>
79778>>>>>>>>>>>    Procedure Set Author String sText
79780>>>>>>>>>>>        Set Value of oAuthor to sText
79781>>>>>>>>>>>    End_Procedure
79782>>>>>>>>>>>
79782>>>>>>>>>>>    // This is used by the About object to display the compile date & time:
79782>>>>>>>>>>>    // Note: It relies on that each project (program) has been setup to use the "WriteDateTimeHeaderFile64.exe"
79782>>>>>>>>>>>    //       program as a pre-compile!
79782>>>>>>>>>>>    //       Add it here: "Before Compilation Process:" (See Studio's: Project - Project Properties - Compiler tab-page)
79782>>>>>>>>>>>    Include_Resource CompileHeader.h as res_CompileHeader type DF_RESOURCE_TYPE_LINE
79782>>>>>>>>>>>
79782>>>>>>>>>>>    Procedure Set Version String sVersion
79784>>>>>>>>>>>        Handle hoVersionInfo
79784>>>>>>>>>>>        Boolean bIncluded
79784>>>>>>>>>>>        Integer iMajor iMinor iRelease iBuild iPos
79784>>>>>>>>>>>        String sCertInfo sCompileDateAndTime
79784>>>>>>>>>>>
79784>>>>>>>>>>>        If (sVersion = "") Begin
79786>>>>>>>>>>>            // This automatically shows the program version of the program, if available.
79786>>>>>>>>>>>            // It will be displayed as the second item in the edit object.
79786>>>>>>>>>>>            If (ghoApplication <> 0) Begin
79788>>>>>>>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
79789>>>>>>>>>>>                If (hoVersionInfo <> 0) Begin
79791>>>>>>>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
79792>>>>>>>>>>>                    If (bIncluded) Begin
79794>>>>>>>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
79795>>>>>>>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
79796>>>>>>>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
79797>>>>>>>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
79798>>>>>>>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
79799>>>>>>>>>>>                    End
79799>>>>>>>>>>>>
79799>>>>>>>>>>>                End
79799>>>>>>>>>>>>
79799>>>>>>>>>>>            End
79799>>>>>>>>>>>>
79799>>>>>>>>>>>        End
79799>>>>>>>>>>>>
79799>>>>>>>>>>>
79799>>>>>>>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
79799>>>>>>>>>>>        Direct_Input "resource: res_CompileHeader"
79800>>>>>>>>>>>        Readln sCompileDateAndTime
79801>>>>>>>>>>>        Move (Pos('"', sCompileDateAndTime)) to iPos
79802>>>>>>>>>>>        If (iPos <> 0) Begin
79804>>>>>>>>>>>            Move (Mid(sCompileDateAndTime, Length(sCompileDateAndTime), (iPos + 1))) to sCompileDateAndTime
79805>>>>>>>>>>>            Move (Replaces('"', sCompileDateAndTime, '')) to sCompileDateAndTime
79806>>>>>>>>>>>        End
79806>>>>>>>>>>>>
79806>>>>>>>>>>>        Close_Input
79807>>>>>>>>>>>
79807>>>>>>>>>>>        If (sCompileDateAndTime <> "") Begin
79809>>>>>>>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(sCompileDateAndTime))
79810>>>>>>>>>>>        End
79810>>>>>>>>>>>>
79810>>>>>>>>>>>
79810>>>>>>>>>>>        Get IsProgramDigitallySigned to sCertInfo
79811>>>>>>>>>>>        If (sCertInfo <> "-1") Begin
79813>>>>>>>>>>>            If (sCertInfo <> "") Begin
79815>>>>>>>>>>>                Send Add_LineLn sCertInfo
79816>>>>>>>>>>>            End
79816>>>>>>>>>>>>
79816>>>>>>>>>>>            Else Begin
79817>>>>>>>>>>>                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
79818>>>>>>>>>>>            End
79818>>>>>>>>>>>>
79818>>>>>>>>>>>        End
79818>>>>>>>>>>>>
79818>>>>>>>>>>>    End_Procedure
79819>>>>>>>>>>>
79819>>>>>>>>>>>    Function IsDate String sDate Returns Boolean
79821>>>>>>>>>>>        Boolean bIsDate
79821>>>>>>>>>>>        String sGoodCharacters sChar
79821>>>>>>>>>>>        Integer iCount iLength
79821>>>>>>>>>>>
79821>>>>>>>>>>>        Move True to bIsDate
79822>>>>>>>>>>>        Move "0123456789-/" to sGoodCharacters
79823>>>>>>>>>>>        Move (Length(sDate)) to iLength
79824>>>>>>>>>>>        For iCount from 1 to iLength
79830>>>>>>>>>>>>
79830>>>>>>>>>>>            Move (Left(sDate, 1)) to sChar
79831>>>>>>>>>>>            Move (Mid(sDate, 12, 2)) to sDate
79832>>>>>>>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
79833>>>>>>>>>>>            If (bIsDate = False) Begin
79835>>>>>>>>>>>                Move iLength to iCount
79836>>>>>>>>>>>            End
79836>>>>>>>>>>>>
79836>>>>>>>>>>>        Loop
79837>>>>>>>>>>>>
79837>>>>>>>>>>>        Function_Return bIsDate
79838>>>>>>>>>>>    End_Function
79839>>>>>>>>>>>
79839>>>>>>>>>>>    Function GetCompileDate Returns Date
79841>>>>>>>>>>>        Date dCompileDate
79841>>>>>>>>>>>        String sAppFilename sProgram sData sCompileDate
79841>>>>>>>>>>>        Integer iChannel iPos iDateFormat iCount iSize
79841>>>>>>>>>>>        Boolean bIsValid   
79841>>>>>>>>>>>        
79841>>>>>>>>>>>        Move 0 to dCompileDate
79842>>>>>>>>>>>        // Get full path to the current running executable
79842>>>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
79843>>>>>>>>>>>        Get GetApplicationName     of ghoApplication to sProgram
79844>>>>>>>>>>>
79844>>>>>>>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
79844>>>>>>>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
79845>>>>>>>>>>>
79845>>>>>>>>>>>        Read_Block channel iChannel sData 9000000   // This must be big enough to reach the compile date location
79847>>>>>>>>>>>        Move (Pos(sProgram, sData)) to iPos
79848>>>>>>>>>>>        If (iPos > 0) Begin
79850>>>>>>>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
79850>>>>>>>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
79851>>>>>>>>>>>
79851>>>>>>>>>>>            // If the current date format is non US, we need to temporary
79851>>>>>>>>>>>            // change the format and then move the string to the date variable.
79851>>>>>>>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
79854>>>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA  
79857>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id 16 
79858>>>>>>>>>>>            If (Left(sCompileDate, 1) = "0") Begin
79860>>>>>>>>>>>                Move ("1" + String(sCompileDate)) to sCompileDate
79861>>>>>>>>>>>            End
79861>>>>>>>>>>>>
79861>>>>>>>>>>>            Move (Date(sCompileDate))    to dCompileDate
79862>>>>>>>>>>>            Send Trap_Error of Error_Object_Id 16
79863>>>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
79866>>>>>>>>>>>        End
79866>>>>>>>>>>>>
79866>>>>>>>>>>>        Else Begin
79867>>>>>>>>>>>            Error DFERR_PROGRAM "Compile Date location in .exe not found"
79868>>>>>>>>>>>>
79868>>>>>>>>>>>        End
79868>>>>>>>>>>>>
79868>>>>>>>>>>>
79868>>>>>>>>>>>        Send Seq_Close_Channel iChannel
79869>>>>>>>>>>>
79869>>>>>>>>>>>        Function_Return dCompileDate
79870>>>>>>>>>>>    End_Function
79871>>>>>>>>>>>
79871>>>>>>>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
79871>>>>>>>>>>>    // (the passed program), has been finished
79871>>>>>>>>>>>    // The DOS box does also _not_ flash briefly.
79871>>>>>>>>>>>    Procedure RunProgramWait String sProgram String sParameter
79873>>>>>>>>>>>        Handle hProcess
79873>>>>>>>>>>>        Integer iVoid
79873>>>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79873>>>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79873>>>>>>>>>>>
79873>>>>>>>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
79874>>>>>>>>>>>
79874>>>>>>>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
79875>>>>>>>>>>>        Move SW_SHOW                 to sInfo.nShow
79876>>>>>>>>>>>
79876>>>>>>>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
79877>>>>>>>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
79878>>>>>>>>>>>        // This will "hide" the DOS box from showing (no flasing box):
79878>>>>>>>>>>>        Move 0                       to sInfo.nShow
79879>>>>>>>>>>>
79879>>>>>>>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
79880>>>>>>>>>>>        Move sInfo.hProcess to hProcess
79881>>>>>>>>>>>        If (hProcess) Begin
79883>>>>>>>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
79884>>>>>>>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
79885>>>>>>>>>>>        End
79885>>>>>>>>>>>>
79885>>>>>>>>>>>    End_Procedure
79886>>>>>>>>>>>
79886>>>>>>>>>>>    Function AddFolderDelimiter String sPath Returns String
79888>>>>>>>>>>>        String sDirSep
79888>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
79889>>>>>>>>>>>        Move (Trim(sPath)) to sPath
79890>>>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
79892>>>>>>>>>>>            Move (sPath + sDirSep) to sPath
79893>>>>>>>>>>>        End
79893>>>>>>>>>>>>
79893>>>>>>>>>>>        Function_Return sPath
79894>>>>>>>>>>>    End_Function
79895>>>>>>>>>>>
79895>>>>>>>>>>>    // Returns an empty string if the current program is not digitally signed,
79895>>>>>>>>>>>    // or there is a problem with the certificate.
79895>>>>>>>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
79895>>>>>>>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
79895>>>>>>>>>>>    Function IsProgramDigitallySigned Returns String
79897>>>>>>>>>>>        Boolean bExists
79897>>>>>>>>>>>        String sPath sProgram sParams sRetval
79897>>>>>>>>>>>        Integer iCh
79897>>>>>>>>>>>
79897>>>>>>>>>>>        Move "" to sRetval
79898>>>>>>>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
79899>>>>>>>>>>>        Get AddFolderDelimiter sPath to sPath
79900>>>>>>>>>>>        File_Exist (sPath + CS_SignProgram) bExists
79901>>>>>>>>>>>        If (bExists = False) Begin
79903>>>>>>>>>>>            Function_Return "-1"
79904>>>>>>>>>>>        End
79904>>>>>>>>>>>>
79904>>>>>>>>>>>
79904>>>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
79905>>>>>>>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
79906>>>>>>>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
79907>>>>>>>>>>>        Move (sParams * String("| clip"))    to sParams
79908>>>>>>>>>>>        Get Seq_New_Channel to iCh
79909>>>>>>>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
79911>>>>>>>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
79914>>>>>>>>>>>        Close_Output channel iCh
79916>>>>>>>>>>>        // New ShellExecute based message that waits for the passed process to end.
79916>>>>>>>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
79917>>>>>>>>>>>        Direct_Input channel iCh "CLIPBOARD:"
79919>>>>>>>>>>>            Readln channel iCh sRetval
79921>>>>>>>>>>>            Readln channel iCh sRetval
79923>>>>>>>>>>>            Readln channel iCh sRetval
79925>>>>>>>>>>>            Readln channel iCh sRetval
79927>>>>>>>>>>>        Close_Input channel iCh
79929>>>>>>>>>>>        Send Seq_Release_Channel iCh
79930>>>>>>>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
79932>>>>>>>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
79933>>>>>>>>>>>        End
79933>>>>>>>>>>>>
79933>>>>>>>>>>>        Else Begin
79934>>>>>>>>>>>            Move "" to sRetval
79935>>>>>>>>>>>        End
79935>>>>>>>>>>>>
79935>>>>>>>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
79935>>>>>>>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
79936>>>>>>>>>>>>
79936>>>>>>>>>>>        Function_Return sRetval
79937>>>>>>>>>>>    End_Function
79938>>>>>>>>>>>
79938>>>>>>>>>>>    Procedure Add_LineLn String sValue
79940>>>>>>>>>>>        Send Add_LineLn of oInfoList_Editor sValue
79941>>>>>>>>>>>    End_Procedure
79942>>>>>>>>>>>
79942>>>>>>>>>>>    Procedure Add_Line String sValue
79944>>>>>>>>>>>        Send Add_Line of oInfoList_Editor sValue
79945>>>>>>>>>>>    End_Procedure
79946>>>>>>>>>>>
79946>>>>>>>>>>>    Procedure Set Logo string sLogo
79948>>>>>>>>>>>        // Square bitmaps of 80x80 work best
79948>>>>>>>>>>>        Set Bitmap of oAboutGraphic to sLogo
79949>>>>>>>>>>>    End_Procedure
79950>>>>>>>>>>>
79950>>>>>>>>>>>    Procedure Set LogoDF String sLogo
79952>>>>>>>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
79953>>>>>>>>>>>    End_Procedure
79954>>>>>>>>>>>
79954>>>>>>>>>>>    Procedure Show_Sysinfo
79956>>>>>>>>>>>        Send Popup_Modal of oSysinfoDialog
79957>>>>>>>>>>>    End_Procedure
79958>>>>>>>>>>>
79958>>>>>>>>>>>    Procedure Show_HomePage String sWebpage
79960>>>>>>>>>>>        Handle hWnd
79960>>>>>>>>>>>        Get Window_Handle to hWnd
79961>>>>>>>>>>>        Runprogram Shell Background (Trim(sWebpage))
79962>>>>>>>>>>>    End_Procedure
79963>>>>>>>>>>>
79963>>>>>>>>>>>End_Class
79964>>>>>>>>>
79964>>>>>>>>>    Function piOrgErrorHandlerID Returns Integer
79966>>>>>>>>>    End_Function
79967>>>>>>>>>
79967>>>>>>>>>Register_Procedure Set Private.pbProcessingError Boolean bProcessingError
79967>>>>>>>>>
79967>>>>>>>>>Class cBaseDbUpdateFuncLib is a cObject
79968>>>>>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
79969>>>>>>>>>>
79969>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
79971>>>>>>>>>>    Integer iStart iEnd
79971>>>>>>>>>>    String sRetval
79971>>>>>>>>>>
79971>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
79972>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
79973>>>>>>>>>>    If (iStart = 0) Begin
79975>>>>>>>>>>        Function_Return ""
79976>>>>>>>>>>    End
79976>>>>>>>>>>>
79976>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
79977>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
79978>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
79980>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
79981>>>>>>>>>>    End
79981>>>>>>>>>>>
79981>>>>>>>>>>    Else Begin
79982>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
79983>>>>>>>>>>    End
79983>>>>>>>>>>>
79983>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
79985>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
79986>>>>>>>>>>        Decrement iEnd
79987>>>>>>>>>>    End
79987>>>>>>>>>>>
79987>>>>>>>>>>    If (iEnd <> 0) Begin
79989>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
79990>>>>>>>>>>    End
79990>>>>>>>>>>>
79990>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
79991>>>>>>>>>>
79991>>>>>>>>>>    Function_Return (Trim(sRetval))
79992>>>>>>>>>>End_Function
79993>>>>>>>>>>
79993>>>>>>>>>>
79993>>>>>>>>>    
79993>>>>>>>>>    Procedure Construct_Object
79995>>>>>>>>>        Handle ho
79995>>>>>>>>>        Forward Send Construct_Object
79997>>>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
79998>>>>>>>>>        
79998>>>>>>>>>        Send CreateDbUpdateLibraryProperties
79999>>>>>>>>>        Property String private.psCollation "Latin1_General_CS_AS"
80000>>>>>>>>>        Property String[] pasSQLDataTables
80001>>>>>>>>>        Property tFilelist[] pFileListArray  
80002>>>>>>>>>        Property tFilelist[] pErrorTables
80003>>>>>>>>>
80003>>>>>>>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
80003>>>>>>>>>        // we will create one as it is used for all ConnectionID, ConnectionString
80003>>>>>>>>>        // etc settings.
80003>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80005>>>>>>>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
80006>>>>>>>>>            Set Name of ho to "oSQLConnectionHandler"
80007>>>>>>>>>            Set phoSQLConnectionHandler to ho
80008>>>>>>>>>        End
80008>>>>>>>>>>
80008>>>>>>>>>
80008>>>>>>>>>    End_Procedure
80009>>>>>>>>>
80009>>>>>>>>>    Procedure End_Construct_Object
80011>>>>>>>>>        Forward Send End_Construct_Object
80013>>>>>>>>>
80013>>>>>>>>>    End_Procedure
80014>>>>>>>>>
80014>>>>>>>>>    // Latin1_General_CI_AS = General Insensitive collation
80014>>>>>>>>>    // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.
80014>>>>>>>>>    // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
80014>>>>>>>>>    // Good read about which collation to select:
80014>>>>>>>>>    // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
80014>>>>>>>>>    Procedure Set psCollation String sCollation
80016>>>>>>>>>        Set private.psCollation to sCollation
80017>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
80019>>>>>>>>>            Set psCollation of ghoDbUpdateHandler to sCollation
80020>>>>>>>>>        End
80020>>>>>>>>>>
80020>>>>>>>>>    End_Procedure
80021>>>>>>>>>
80021>>>>>>>>>    Function psCollation Returns String
80023>>>>>>>>>        String sCollation
80023>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
80025>>>>>>>>>            Get psCollation of ghoDbUpdateHandler to sCollation
80026>>>>>>>>>        End   
80026>>>>>>>>>>
80026>>>>>>>>>        Else Begin
80027>>>>>>>>>            Get private.psCollation to sCollation
80028>>>>>>>>>        End
80028>>>>>>>>>>
80028>>>>>>>>>        Function_Return sCollation
80029>>>>>>>>>    End_Function
80030>>>>>>>>>
80030>>>>>>>>>    // Array sorting helper functions:
80030>>>>>>>>>    Function __UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
80032>>>>>>>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
80034>>>>>>>>>            Function_Return (EQ)
80035>>>>>>>>>        End
80035>>>>>>>>>>
80035>>>>>>>>>
80035>>>>>>>>>        Function_Return (GT)
80036>>>>>>>>>    End_Function
80037>>>>>>>>>
80037>>>>>>>>>    Function __SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
80039>>>>>>>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
80042>>>>>>>>>
80042>>>>>>>>>        Function_Return (GT)
80043>>>>>>>>>    End_Function
80044>>>>>>>>>
80044>>>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
80044>>>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
80044>>>>>>>>>    Function _ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
80046>>>>>>>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
80046>>>>>>>>>        Handle hTable
80046>>>>>>>>>        Boolean bIsSame
80046>>>>>>>>>
80046>>>>>>>>>        Move APITableInfo.iTableNumber      to hTable
80047>>>>>>>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
80048>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
80051>>>>>>>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
80052>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
80055>>>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
80058>>>>>>>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
80059>>>>>>>>>
80059>>>>>>>>>        If (bCompareFilelistUppercase = True) Begin
80061>>>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
80062>>>>>>>>>        End
80062>>>>>>>>>>
80062>>>>>>>>>        Else Begin
80063>>>>>>>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
80064>>>>>>>>>        End
80064>>>>>>>>>>
80064>>>>>>>>>
80064>>>>>>>>>        Function_Return bIsSame
80065>>>>>>>>>    End_Function
80066>>>>>>>>>
80066>>>>>>>>>    Function AutoSetConnectionID String sConnectionID Returns Boolean
80068>>>>>>>>>        Integer iRetval
80068>>>>>>>>>        Move 1 to iRetval
80069>>>>>>>>>        If (ghoSQLConnectionHandler <> 0) Begin
80071>>>>>>>>>            Set psConnectionID of ghoSQLConnectionHandler to sConnectionID
80072>>>>>>>>>            Get AutoSetConnectionID of ghoSQLConnectionHandler to iRetval
80073>>>>>>>>>        End
80073>>>>>>>>>>
80073>>>>>>>>>        Function_Return (iRetval = 0)
80074>>>>>>>>>    End_Function
80075>>>>>>>>>
80075>>>>>>>>>    Function _AddFolderDelimiter String sPath Returns String
80077>>>>>>>>>        String sDirSep
80077>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
80078>>>>>>>>>        Move (Trim(sPath)) to sPath
80079>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
80081>>>>>>>>>            Move (sPath + sDirSep) to sPath
80082>>>>>>>>>        End
80082>>>>>>>>>>
80082>>>>>>>>>        Function_Return sPath
80083>>>>>>>>>    End_Function
80084>>>>>>>>>
80084>>>>>>>>>    Procedure _SqlColumnInfo Handle hoStmt
80086>>>>>>>>>        Integer i iCols iItem
80086>>>>>>>>>        tSqlColumnNew[] aQueryColumns
80086>>>>>>>>>        tSqlColumnNew[] aQueryColumns
80087>>>>>>>>>
80087>>>>>>>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
80088>>>>>>>>>        For i from 1 to iCols
80094>>>>>>>>>>
80094>>>>>>>>>            Move (SizeOfArray(aQueryColumns)) to iItem
80095>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
80096>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
80097>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
80098>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
80099>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
80100>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
80101>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
80102>>>>>>>>>        Loop
80103>>>>>>>>>>
80103>>>>>>>>>        Set piColumns to iCols
80104>>>>>>>>>        Set paQueryColumns to aQueryColumns
80105>>>>>>>>>    End_Procedure
80106>>>>>>>>>
80106>>>>>>>>>    // *** Property Messages ***
80106>>>>>>>>>    //
80106>>>>>>>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
80106>>>>>>>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
80106>>>>>>>>>    //
80106>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
80108>>>>>>>>>        tSQLConnection SQLConnection
80108>>>>>>>>>        tSQLConnection SQLConnection
80108>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80110>>>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
80110>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80111>>>>>>>>>>
80111>>>>>>>>>            Function_Return
80112>>>>>>>>>        End
80112>>>>>>>>>>
80112>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
80113>>>>>>>>>        Function_Return SQLConnection
80114>>>>>>>>>    End_Function
80115>>>>>>>>>
80115>>>>>>>>>    // * Dummy function for the Studio's Code Explorer *
80115>>>>>>>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
80117>>>>>>>>>        Function_Return False
80118>>>>>>>>>    End_Function
80119>>>>>>>>>
80119>>>>>>>>>    Procedure Set psServer String sValue
80121>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80123>>>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
80123>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80124>>>>>>>>>>
80124>>>>>>>>>            Procedure_Return
80125>>>>>>>>>        End
80125>>>>>>>>>>
80125>>>>>>>>>        Set psServer of ghoSQLConnectionHandler to sValue
80126>>>>>>>>>    End_Procedure
80127>>>>>>>>>
80127>>>>>>>>>    Function psServer Returns String
80129>>>>>>>>>        String sValue
80129>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80131>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80132>>>>>>>>>>
80132>>>>>>>>>            Function_Return
80133>>>>>>>>>        End
80133>>>>>>>>>>
80133>>>>>>>>>        Get psServer of ghoSQLConnectionHandler to sValue
80134>>>>>>>>>        Function_Return sValue
80135>>>>>>>>>    End_Function
80136>>>>>>>>>
80136>>>>>>>>>    Procedure Set psDatabase String sValue
80138>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80140>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80141>>>>>>>>>>
80141>>>>>>>>>            Procedure_Return
80142>>>>>>>>>        End
80142>>>>>>>>>>
80142>>>>>>>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
80143>>>>>>>>>    End_Procedure
80144>>>>>>>>>
80144>>>>>>>>>    Function psDatabase Returns String
80146>>>>>>>>>        String sValue
80146>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80148>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80149>>>>>>>>>>
80149>>>>>>>>>            Function_Return
80150>>>>>>>>>        End
80150>>>>>>>>>>
80150>>>>>>>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
80151>>>>>>>>>        Function_Return sValue
80152>>>>>>>>>    End_Function
80153>>>>>>>>>
80153>>>>>>>>>    Procedure Set psUserID String sValue
80155>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80157>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80158>>>>>>>>>>
80158>>>>>>>>>            Procedure_Return
80159>>>>>>>>>        End
80159>>>>>>>>>>
80159>>>>>>>>>        Set psUserID of ghoSQLConnectionHandler to sValue
80160>>>>>>>>>    End_Procedure
80161>>>>>>>>>
80161>>>>>>>>>    Function psUserID Returns String
80163>>>>>>>>>        String sValue
80163>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80165>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80166>>>>>>>>>>
80166>>>>>>>>>            Function_Return
80167>>>>>>>>>        End
80167>>>>>>>>>>
80167>>>>>>>>>        Get psUserID of ghoSQLConnectionHandler to sValue
80168>>>>>>>>>        Function_Return sValue
80169>>>>>>>>>    End_Function
80170>>>>>>>>>
80170>>>>>>>>>    Procedure Set psPassword String sValue
80172>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80174>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80175>>>>>>>>>>
80175>>>>>>>>>            Procedure_Return
80176>>>>>>>>>        End
80176>>>>>>>>>>
80176>>>>>>>>>        Set psPassword of ghoSQLConnectionHandler to sValue
80177>>>>>>>>>    End_Procedure
80178>>>>>>>>>
80178>>>>>>>>>    Function psPassword Returns String
80180>>>>>>>>>        String sValue
80180>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80182>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80183>>>>>>>>>>
80183>>>>>>>>>            Function_Return
80184>>>>>>>>>        End
80184>>>>>>>>>>
80184>>>>>>>>>        Get psPassword of ghoSQLConnectionHandler to sValue
80185>>>>>>>>>        Function_Return sValue
80186>>>>>>>>>    End_Function
80187>>>>>>>>>
80187>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
80189>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80191>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80192>>>>>>>>>>
80192>>>>>>>>>            Procedure_Return
80193>>>>>>>>>        End
80193>>>>>>>>>>
80193>>>>>>>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
80194>>>>>>>>>    End_Procedure
80195>>>>>>>>>
80195>>>>>>>>>    Function pbTrusted Returns Boolean
80197>>>>>>>>>        Boolean bValue
80197>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80199>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80200>>>>>>>>>>
80200>>>>>>>>>            Function_Return
80201>>>>>>>>>        End
80201>>>>>>>>>>
80201>>>>>>>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
80202>>>>>>>>>        Function_Return bValue
80203>>>>>>>>>    End_Function
80204>>>>>>>>>
80204>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
80206>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80208>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80209>>>>>>>>>>
80209>>>>>>>>>            Procedure_Return
80210>>>>>>>>>        End
80210>>>>>>>>>>
80210>>>>>>>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
80211>>>>>>>>>    End_Procedure
80212>>>>>>>>>
80212>>>>>>>>>    Function pbSilentLogin Returns Boolean
80214>>>>>>>>>        Boolean bValue
80214>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80216>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80217>>>>>>>>>>
80217>>>>>>>>>            Function_Return
80218>>>>>>>>>        End
80218>>>>>>>>>>
80218>>>>>>>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
80219>>>>>>>>>        Function_Return bValue
80220>>>>>>>>>    End_Function
80221>>>>>>>>>
80221>>>>>>>>>    Procedure Set psConnectionID String sValue
80223>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80225>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80226>>>>>>>>>>
80226>>>>>>>>>            Procedure_Return
80227>>>>>>>>>        End
80227>>>>>>>>>>
80227>>>>>>>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
80228>>>>>>>>>    End_Procedure
80229>>>>>>>>>
80229>>>>>>>>>    Function psConnectionID Returns String
80231>>>>>>>>>        String sValue
80231>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80233>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80234>>>>>>>>>>
80234>>>>>>>>>            Function_Return
80235>>>>>>>>>        End
80235>>>>>>>>>>
80235>>>>>>>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
80236>>>>>>>>>        Function_Return sValue
80237>>>>>>>>>    End_Function
80238>>>>>>>>>
80238>>>>>>>>>    Procedure Set psConnectionString String sValue
80240>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80242>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80243>>>>>>>>>>
80243>>>>>>>>>            Procedure_Return
80244>>>>>>>>>        End
80244>>>>>>>>>>
80244>>>>>>>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
80245>>>>>>>>>    End_Procedure
80246>>>>>>>>>
80246>>>>>>>>>    Function psConnectionString Returns String
80248>>>>>>>>>        String sValue
80248>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80250>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80251>>>>>>>>>>
80251>>>>>>>>>            Function_Return
80252>>>>>>>>>        End
80252>>>>>>>>>>
80252>>>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
80253>>>>>>>>>        Function_Return sValue
80254>>>>>>>>>    End_Function
80255>>>>>>>>>
80255>>>>>>>>>    // The normal connection string looks something like this;
80255>>>>>>>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
80255>>>>>>>>>    // ...and the full connection string looks like this;
80255>>>>>>>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
80255>>>>>>>>>    Function psFullConnectionString Returns String
80257>>>>>>>>>        String sConnectionID sConnectionString
80257>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80259>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80260>>>>>>>>>>
80260>>>>>>>>>            Function_Return
80261>>>>>>>>>        End
80261>>>>>>>>>>
80261>>>>>>>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
80262>>>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
80263>>>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
80264>>>>>>>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
80265>>>>>>>>>    End_Function
80266>>>>>>>>>
80266>>>>>>>>>    Function piConnectionOptions Returns Integer
80268>>>>>>>>>        Integer iValue
80268>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80270>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80271>>>>>>>>>>
80271>>>>>>>>>            Function_Return
80272>>>>>>>>>        End
80272>>>>>>>>>>
80272>>>>>>>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
80273>>>>>>>>>        Function_Return iValue
80274>>>>>>>>>    End_Function
80275>>>>>>>>>
80275>>>>>>>>>    Procedure Set psSchema String sValue
80277>>>>>>>>>        tSQLConnection SQLConnection
80277>>>>>>>>>        tSQLConnection SQLConnection
80277>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80279>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80280>>>>>>>>>>
80280>>>>>>>>>            Procedure_Return
80281>>>>>>>>>        End
80281>>>>>>>>>>
80281>>>>>>>>>        Set psSchema of ghoSQLConnectionHandler to sValue
80282>>>>>>>>>    End_Procedure
80283>>>>>>>>>
80283>>>>>>>>>    Function psSchema Returns String
80285>>>>>>>>>        String sRetval
80285>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80287>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80288>>>>>>>>>>
80288>>>>>>>>>            Function_Return
80289>>>>>>>>>        End
80289>>>>>>>>>>
80289>>>>>>>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
80290>>>>>>>>>        Function_Return sRetval
80291>>>>>>>>>    End_Function
80292>>>>>>>>>
80292>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
80294>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80296>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80297>>>>>>>>>>
80297>>>>>>>>>            Procedure_Return
80298>>>>>>>>>        End
80298>>>>>>>>>>
80298>>>>>>>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
80299>>>>>>>>>    End_Procedure
80300>>>>>>>>>
80300>>>>>>>>>    Function psBaseTableSpace Returns String
80302>>>>>>>>>        String sRetval
80302>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80304>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80305>>>>>>>>>>
80305>>>>>>>>>            Function_Return
80306>>>>>>>>>        End
80306>>>>>>>>>>
80306>>>>>>>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
80307>>>>>>>>>        Function_Return sRetval
80308>>>>>>>>>    End_Function
80309>>>>>>>>>
80309>>>>>>>>>    Procedure Set psLongTableSpace String sValue
80311>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80313>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80314>>>>>>>>>>
80314>>>>>>>>>            Procedure_Return
80315>>>>>>>>>        End
80315>>>>>>>>>>
80315>>>>>>>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
80316>>>>>>>>>    End_Procedure
80317>>>>>>>>>
80317>>>>>>>>>    Function psLongTableSpace Returns String
80319>>>>>>>>>        String sRetval
80319>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80321>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80322>>>>>>>>>>
80322>>>>>>>>>            Function_Return
80323>>>>>>>>>        End
80323>>>>>>>>>>
80323>>>>>>>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
80324>>>>>>>>>        Function_Return sRetval
80325>>>>>>>>>    End_Function
80326>>>>>>>>>
80326>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
80328>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80330>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80331>>>>>>>>>>
80331>>>>>>>>>            Procedure_Return
80332>>>>>>>>>        End
80332>>>>>>>>>>
80332>>>>>>>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
80333>>>>>>>>>    End_Procedure
80334>>>>>>>>>
80334>>>>>>>>>    Function psIndexTableSpace Returns String
80336>>>>>>>>>        String sRetval
80336>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80338>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80339>>>>>>>>>>
80339>>>>>>>>>            Function_Return
80340>>>>>>>>>        End
80340>>>>>>>>>>
80340>>>>>>>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
80341>>>>>>>>>        Function_Return sRetval
80342>>>>>>>>>    End_Function
80343>>>>>>>>>
80343>>>>>>>>>    Procedure Set pbUseConnectionID Boolean bState
80345>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80347>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80348>>>>>>>>>>
80348>>>>>>>>>            Procedure_Return
80349>>>>>>>>>        End
80349>>>>>>>>>>
80349>>>>>>>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
80350>>>>>>>>>    End_Procedure
80351>>>>>>>>>
80351>>>>>>>>>    Function pbUseConnectionID Returns Boolean
80353>>>>>>>>>        Boolean bState
80353>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80355>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80356>>>>>>>>>>
80356>>>>>>>>>            Function_Return
80357>>>>>>>>>        End
80357>>>>>>>>>>
80357>>>>>>>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
80358>>>>>>>>>        Function_Return bState
80359>>>>>>>>>    End_Function
80360>>>>>>>>>
80360>>>>>>>>>    Procedure Set pbToANSI Boolean bState
80362>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80364>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80365>>>>>>>>>>
80365>>>>>>>>>            Procedure_Return
80366>>>>>>>>>        End
80366>>>>>>>>>>
80366>>>>>>>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
80367>>>>>>>>>    End_Procedure
80368>>>>>>>>>
80368>>>>>>>>>    Function pbToANSI Returns Boolean
80370>>>>>>>>>        Boolean bState
80370>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80372>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80373>>>>>>>>>>
80373>>>>>>>>>            Function_Return
80374>>>>>>>>>        End
80374>>>>>>>>>>
80374>>>>>>>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
80375>>>>>>>>>        Function_Return bState
80376>>>>>>>>>    End_Function
80377>>>>>>>>>
80377>>>>>>>>>    Procedure Set pbRecnum Boolean bState
80379>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80381>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80382>>>>>>>>>>
80382>>>>>>>>>            Procedure_Return
80383>>>>>>>>>        End
80383>>>>>>>>>>
80383>>>>>>>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
80384>>>>>>>>>    End_Procedure
80385>>>>>>>>>
80385>>>>>>>>>    Function pbRecnum Returns Boolean
80387>>>>>>>>>        Boolean bState
80387>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80389>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80390>>>>>>>>>>
80390>>>>>>>>>            Function_Return
80391>>>>>>>>>        End
80391>>>>>>>>>>
80391>>>>>>>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
80392>>>>>>>>>        Function_Return bState
80393>>>>>>>>>    End_Function
80394>>>>>>>>>
80394>>>>>>>>>    Procedure Set pbCopyData Boolean bState
80396>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80398>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80399>>>>>>>>>>
80399>>>>>>>>>            Procedure_Return
80400>>>>>>>>>        End
80400>>>>>>>>>>
80400>>>>>>>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
80401>>>>>>>>>    End_Procedure
80402>>>>>>>>>
80402>>>>>>>>>    Function pbCopyData Returns Boolean
80404>>>>>>>>>        Boolean bState
80404>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80406>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80407>>>>>>>>>>
80407>>>>>>>>>            Function_Return
80408>>>>>>>>>        End
80408>>>>>>>>>>
80408>>>>>>>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
80409>>>>>>>>>        Function_Return bState
80410>>>>>>>>>    End_Function
80411>>>>>>>>>
80411>>>>>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
80413>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80415>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80416>>>>>>>>>>
80416>>>>>>>>>            Procedure_Return
80417>>>>>>>>>        End
80417>>>>>>>>>>
80417>>>>>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
80418>>>>>>>>>    End_Procedure
80419>>>>>>>>>
80419>>>>>>>>>    Function pbApiTableUpdateAuto Returns Boolean
80421>>>>>>>>>        Boolean bState
80421>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80423>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80424>>>>>>>>>>
80424>>>>>>>>>            Function_Return
80425>>>>>>>>>        End
80425>>>>>>>>>>
80425>>>>>>>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
80426>>>>>>>>>        Function_Return bState
80427>>>>>>>>>    End_Function
80428>>>>>>>>>
80428>>>>>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
80430>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80432>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80433>>>>>>>>>>
80433>>>>>>>>>            Procedure_Return
80434>>>>>>>>>        End
80434>>>>>>>>>>
80434>>>>>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
80435>>>>>>>>>    End_Procedure
80436>>>>>>>>>
80436>>>>>>>>>    Function pbCompareDate_DateTime Returns Boolean
80438>>>>>>>>>        Boolean bState
80438>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80440>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80441>>>>>>>>>>
80441>>>>>>>>>            Function_Return
80442>>>>>>>>>        End
80442>>>>>>>>>>
80442>>>>>>>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
80443>>>>>>>>>        Function_Return bState
80444>>>>>>>>>    End_Function
80445>>>>>>>>>
80445>>>>>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
80447>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80449>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80450>>>>>>>>>>
80450>>>>>>>>>            Procedure_Return
80451>>>>>>>>>        End
80451>>>>>>>>>>
80451>>>>>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
80452>>>>>>>>>    End_Procedure
80453>>>>>>>>>
80453>>>>>>>>>    Function pbCompareIndexAscending Returns Boolean
80455>>>>>>>>>        Boolean bState
80455>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80457>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80458>>>>>>>>>>
80458>>>>>>>>>            Function_Return
80459>>>>>>>>>        End
80459>>>>>>>>>>
80459>>>>>>>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
80460>>>>>>>>>        Function_Return bState
80461>>>>>>>>>    End_Function
80462>>>>>>>>>
80462>>>>>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
80464>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80466>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80467>>>>>>>>>>
80467>>>>>>>>>            Procedure_Return
80468>>>>>>>>>        End
80468>>>>>>>>>>
80468>>>>>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
80469>>>>>>>>>    End_Procedure
80470>>>>>>>>>
80470>>>>>>>>>    Function pbCompareIndexUppercase Returns Boolean
80472>>>>>>>>>        Boolean bState
80472>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80474>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80475>>>>>>>>>>
80475>>>>>>>>>            Function_Return
80476>>>>>>>>>        End
80476>>>>>>>>>>
80476>>>>>>>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
80477>>>>>>>>>        Function_Return bState
80478>>>>>>>>>    End_Function
80479>>>>>>>>>
80479>>>>>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
80481>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80483>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80484>>>>>>>>>>
80484>>>>>>>>>            Procedure_Return
80485>>>>>>>>>        End
80485>>>>>>>>>>
80485>>>>>>>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
80486>>>>>>>>>    End_Procedure
80487>>>>>>>>>
80487>>>>>>>>>    Function psDriverDefaultValueASCII Returns String
80489>>>>>>>>>        String sRetval
80489>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80491>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80492>>>>>>>>>>
80492>>>>>>>>>            Function_Return
80493>>>>>>>>>        End
80493>>>>>>>>>>
80493>>>>>>>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
80494>>>>>>>>>        Function_Return sRetval
80495>>>>>>>>>    End_Function
80496>>>>>>>>>
80496>>>>>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
80498>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80500>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80501>>>>>>>>>>
80501>>>>>>>>>            Procedure_Return
80502>>>>>>>>>        End
80502>>>>>>>>>>
80502>>>>>>>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
80503>>>>>>>>>    End_Procedure
80504>>>>>>>>>
80504>>>>>>>>>    Function psDriverDefaultValueBinary Returns String
80506>>>>>>>>>        String sRetval
80506>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80508>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80509>>>>>>>>>>
80509>>>>>>>>>            Function_Return
80510>>>>>>>>>        End
80510>>>>>>>>>>
80510>>>>>>>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
80511>>>>>>>>>        Function_Return sRetval
80512>>>>>>>>>    End_Function
80513>>>>>>>>>
80513>>>>>>>>>    Procedure Set psDriverDefaultValueDate String sValue
80515>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80517>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80518>>>>>>>>>>
80518>>>>>>>>>            Procedure_Return
80519>>>>>>>>>        End
80519>>>>>>>>>>
80519>>>>>>>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
80520>>>>>>>>>    End_Procedure
80521>>>>>>>>>
80521>>>>>>>>>    Function psDriverDefaultValueDate Returns String
80523>>>>>>>>>        String sRetval
80523>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80525>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80526>>>>>>>>>>
80526>>>>>>>>>            Function_Return
80527>>>>>>>>>        End
80527>>>>>>>>>>
80527>>>>>>>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
80528>>>>>>>>>        Function_Return sRetval
80529>>>>>>>>>    End_Function
80530>>>>>>>>>
80530>>>>>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
80532>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80534>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80535>>>>>>>>>>
80535>>>>>>>>>            Procedure_Return
80536>>>>>>>>>        End
80536>>>>>>>>>>
80536>>>>>>>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
80537>>>>>>>>>    End_Procedure
80538>>>>>>>>>
80538>>>>>>>>>    Function psDriverDefaultValueDateTime Returns String
80540>>>>>>>>>        String sRetval
80540>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80542>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80543>>>>>>>>>>
80543>>>>>>>>>            Function_Return
80544>>>>>>>>>        End
80544>>>>>>>>>>
80544>>>>>>>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
80545>>>>>>>>>        Function_Return sRetval
80546>>>>>>>>>    End_Function
80547>>>>>>>>>
80547>>>>>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
80549>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80551>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80552>>>>>>>>>>
80552>>>>>>>>>            Procedure_Return
80553>>>>>>>>>        End
80553>>>>>>>>>>
80553>>>>>>>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
80554>>>>>>>>>    End_Procedure
80555>>>>>>>>>
80555>>>>>>>>>    Function psDriverDefaultValueNumeric Returns String
80557>>>>>>>>>        String sRetval
80557>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80559>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80560>>>>>>>>>>
80560>>>>>>>>>            Function_Return
80561>>>>>>>>>        End
80561>>>>>>>>>>
80561>>>>>>>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
80562>>>>>>>>>        Function_Return sRetval
80563>>>>>>>>>    End_Function
80564>>>>>>>>>
80564>>>>>>>>>    Procedure Set psDriverDefaultValueText String sValue
80566>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80568>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80569>>>>>>>>>>
80569>>>>>>>>>            Procedure_Return
80570>>>>>>>>>        End
80570>>>>>>>>>>
80570>>>>>>>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
80571>>>>>>>>>    End_Procedure
80572>>>>>>>>>
80572>>>>>>>>>    Function psDriverDefaultValueText Returns String
80574>>>>>>>>>        String sRetval
80574>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80576>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80577>>>>>>>>>>
80577>>>>>>>>>            Function_Return
80578>>>>>>>>>        End
80578>>>>>>>>>>
80578>>>>>>>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
80579>>>>>>>>>        Function_Return sRetval
80580>>>>>>>>>    End_Function
80581>>>>>>>>>
80581>>>>>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
80583>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80585>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80586>>>>>>>>>>
80586>>>>>>>>>            Procedure_Return
80587>>>>>>>>>        End
80587>>>>>>>>>>
80587>>>>>>>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
80588>>>>>>>>>    End_Procedure
80589>>>>>>>>>
80589>>>>>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
80591>>>>>>>>>        Boolean bState
80591>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80593>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80594>>>>>>>>>>
80594>>>>>>>>>            Function_Return
80595>>>>>>>>>        End
80595>>>>>>>>>>
80595>>>>>>>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
80596>>>>>>>>>        Function_Return bState
80597>>>>>>>>>    End_Function
80598>>>>>>>>>
80598>>>>>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
80600>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80602>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80603>>>>>>>>>>
80603>>>>>>>>>            Procedure_Return
80604>>>>>>>>>        End
80604>>>>>>>>>>
80604>>>>>>>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
80605>>>>>>>>>    End_Procedure
80606>>>>>>>>>
80606>>>>>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
80608>>>>>>>>>        Boolean bState
80608>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80610>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80611>>>>>>>>>>
80611>>>>>>>>>            Function_Return
80612>>>>>>>>>        End
80612>>>>>>>>>>
80612>>>>>>>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
80613>>>>>>>>>        Function_Return bState
80614>>>>>>>>>    End_Function
80615>>>>>>>>>
80615>>>>>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
80617>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80619>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80620>>>>>>>>>>
80620>>>>>>>>>            Procedure_Return
80621>>>>>>>>>        End
80621>>>>>>>>>>
80621>>>>>>>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
80622>>>>>>>>>    End_Procedure
80623>>>>>>>>>
80623>>>>>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
80625>>>>>>>>>        Boolean bState
80625>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80627>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80628>>>>>>>>>>
80628>>>>>>>>>            Function_Return
80629>>>>>>>>>        End
80629>>>>>>>>>>
80629>>>>>>>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
80630>>>>>>>>>        Function_Return bState
80631>>>>>>>>>    End_Function
80632>>>>>>>>>
80632>>>>>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
80634>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80636>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80637>>>>>>>>>>
80637>>>>>>>>>            Procedure_Return
80638>>>>>>>>>        End
80638>>>>>>>>>>
80638>>>>>>>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
80639>>>>>>>>>    End_Procedure
80640>>>>>>>>>
80640>>>>>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
80642>>>>>>>>>        Boolean bState
80642>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80644>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80645>>>>>>>>>>
80645>>>>>>>>>            Function_Return
80646>>>>>>>>>        End
80646>>>>>>>>>>
80646>>>>>>>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
80647>>>>>>>>>        Function_Return bState
80648>>>>>>>>>    End_Function
80649>>>>>>>>>
80649>>>>>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
80651>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80653>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80654>>>>>>>>>>
80654>>>>>>>>>            Procedure_Return
80655>>>>>>>>>        End
80655>>>>>>>>>>
80655>>>>>>>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
80656>>>>>>>>>    End_Procedure
80657>>>>>>>>>
80657>>>>>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
80659>>>>>>>>>        Boolean bState
80659>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80661>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80662>>>>>>>>>>
80662>>>>>>>>>            Function_Return
80663>>>>>>>>>        End
80663>>>>>>>>>>
80663>>>>>>>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
80664>>>>>>>>>        Function_Return bState
80665>>>>>>>>>    End_Function
80666>>>>>>>>>
80666>>>>>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
80668>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80670>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80671>>>>>>>>>>
80671>>>>>>>>>            Procedure_Return
80672>>>>>>>>>        End
80672>>>>>>>>>>
80672>>>>>>>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
80673>>>>>>>>>    End_Procedure
80674>>>>>>>>>
80674>>>>>>>>>    Function pbDriverDefaultNullableText Returns Boolean
80676>>>>>>>>>        Boolean bState
80676>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80678>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80679>>>>>>>>>>
80679>>>>>>>>>            Function_Return
80680>>>>>>>>>        End
80680>>>>>>>>>>
80680>>>>>>>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
80681>>>>>>>>>        Function_Return bState
80682>>>>>>>>>    End_Function
80683>>>>>>>>>
80683>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
80683>>>>>>>>>    //       the psDriverID *must* be the first property that gets changed!
80683>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
80683>>>>>>>>>    //       for a connection string has the wrong format for that driver.
80683>>>>>>>>>    Procedure Set psDriverID String sValue
80685>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80686>>>>>>>>>        Delegate Set psDriverID to sValue
80688>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80689>>>>>>>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
80690>>>>>>>>>    End_Procedure
80691>>>>>>>>>
80691>>>>>>>>>    Function psDriverID Returns String
80693>>>>>>>>>        String sDriverID
80693>>>>>>>>>
80693>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80694>>>>>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
80694>>>>>>>>>        Delegate Get psDriverID to sDriverID
80696>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80697>>>>>>>>>        Move False to Err
80698>>>>>>>>>
80698>>>>>>>>>        // ...and in case it didn't use property of this class. Then the library is
80698>>>>>>>>>        // probably used as "utilites" from a special made program and
80698>>>>>>>>>        // the ghoSQLConnectionHandler must have been setup
80698>>>>>>>>>        If (sDriverID = "") Begin
80700>>>>>>>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
80701>>>>>>>>>        End
80701>>>>>>>>>>
80701>>>>>>>>>        Function_Return sDriverID
80702>>>>>>>>>    End_Function
80703>>>>>>>>>
80703>>>>>>>>>    Procedure Set piDbType Integer iValue
80705>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80706>>>>>>>>>        Delegate Set piDbType to iValue
80708>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80709>>>>>>>>>        Set piDbType of ghoSQLConnectionHandler to iValue
80710>>>>>>>>>    End_Procedure
80711>>>>>>>>>
80711>>>>>>>>>    Function piDbType Returns Integer
80713>>>>>>>>>        Integer iRetval
80713>>>>>>>>>        Get piDbType of ghoSQLConnectionHandler to iRetval
80714>>>>>>>>>        Function_Return iRetval
80715>>>>>>>>>    End_Function
80716>>>>>>>>>
80716>>>>>>>>>    // Returns the index for the passed sTableName
80716>>>>>>>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
80716>>>>>>>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
80718>>>>>>>>>        Integer iIndex iSize iCount iItem
80718>>>>>>>>>        String[] asTablesArray
80719>>>>>>>>>        String sDatabase sSchema sVal sConnectionString
80719>>>>>>>>>
80719>>>>>>>>>        Move -1 to iIndex
80720>>>>>>>>>        Get psConnectionString to sConnectionString
80721>>>>>>>>>        Get psDatabase to sDatabase
80722>>>>>>>>>        Get psSchema   to sSchema
80723>>>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to asTablesArray
80724>>>>>>>>>        Move (SearchArray(sTableName, asTablesArray, Desktop, (RefFunc(DFSTRICMP)))) to iItem
80725>>>>>>>>>        If (iItem <> -1) Begin
80727>>>>>>>>>            Move iItem to iIndex
80728>>>>>>>>>        End
80728>>>>>>>>>>
80728>>>>>>>>>        Function_Return iIndex
80729>>>>>>>>>    End_Function
80730>>>>>>>>>
80730>>>>>>>>>    // Returns all schemas as a string array for the passed driver id.
80730>>>>>>>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
80732>>>>>>>>>        String[] sReturnArray
80733>>>>>>>>>        Boolean bOK
80733>>>>>>>>>
80733>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80734>>>>>>>>>        If (bOK = False) Begin
80736>>>>>>>>>            Function_Return sReturnArray
80737>>>>>>>>>        End
80737>>>>>>>>>>
80737>>>>>>>>>
80737>>>>>>>>>        Case Begin
80737>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80739>>>>>>>>>                Get _SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
80740>>>>>>>>>                Case Break
80741>>>>>>>>>
80741>>>>>>>>>            Case Else
80741>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
80742>>>>>>>>>>
80742>>>>>>>>>                Case Break
80743>>>>>>>>>        Case End
80743>>>>>>>>>
80743>>>>>>>>>        Function_Return sReturnArray
80744>>>>>>>>>    End_Function
80745>>>>>>>>>
80745>>>>>>>>>    // Returns a string array with all tables for the current database.
80745>>>>>>>>>    Function _SqlUtilEnumerateTables String sDriverID String sDatabase String sSchema Returns String[]
80747>>>>>>>>>        String[] asReturnArray
80748>>>>>>>>>        String sConnectionString sSelect
80748>>>>>>>>>        Integer iSize iCount iDbType
80748>>>>>>>>>        Boolean bOK
80748>>>>>>>>>
80748>>>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
80750>>>>>>>>>            Function_Return asReturnArray
80751>>>>>>>>>        End
80751>>>>>>>>>>
80751>>>>>>>>>
80751>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80752>>>>>>>>>        If (bOK = False) Begin
80754>>>>>>>>>            Function_Return asReturnArray
80755>>>>>>>>>        End
80755>>>>>>>>>>
80755>>>>>>>>>        If (sSchema = "") Begin
80757>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
80758>>>>>>>>>        End
80758>>>>>>>>>>
80758>>>>>>>>>
80758>>>>>>>>>        Get psConnectionString to sConnectionString
80759>>>>>>>>>
80759>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
80759>>>>>>>>>        // the dbType.
80759>>>>>>>>>        Get piDbType to iDbType
80760>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
80762>>>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
80764>>>>>>>>>                Move MSSQLDRV_ID to sDriverID
80765>>>>>>>>>            End
80765>>>>>>>>>>
80765>>>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
80767>>>>>>>>>                Move DB2_DRV_ID to sDriverID
80768>>>>>>>>>            End
80768>>>>>>>>>>
80768>>>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
80770>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
80771>>>>>>>>>            End
80771>>>>>>>>>>
80771>>>>>>>>>        End
80771>>>>>>>>>>
80771>>>>>>>>>
80771>>>>>>>>>        Case Begin
80771>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80773>>>>>>>>>                Get _SqlTableArrayDAW to asReturnArray
80774>>>>>>>>>                Case Break
80775>>>>>>>>>
80775>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80778>>>>>>>>>                Get _SqlTableArrayDAW to asReturnArray
80779>>>>>>>>>                Case Break
80780>>>>>>>>>
80780>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
80783>>>>>>>>>                Get _SqlTableArrayDAW to asReturnArray
80784>>>>>>>>>                Case Break
80785>>>>>>>>>
80785>>>>>>>>>            Case Else
80785>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTables function."
80786>>>>>>>>>>
80786>>>>>>>>>                Case Break
80787>>>>>>>>>        Case End
80787>>>>>>>>>
80787>>>>>>>>>        Function_Return asReturnArray
80788>>>>>>>>>    End_Function
80789>>>>>>>>>
80789>>>>>>>>>    // Returns all table spaces as a string array for the passed driver id.
80789>>>>>>>>>    Function _SqlUtilEnumerateTablespaces String sDriverID Returns String[]
80791>>>>>>>>>        String[] sReturnArray
80792>>>>>>>>>        Boolean bOK
80792>>>>>>>>>
80792>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80793>>>>>>>>>        If (bOK = False) Begin
80795>>>>>>>>>            Function_Return sReturnArray
80796>>>>>>>>>        End
80796>>>>>>>>>>
80796>>>>>>>>>
80796>>>>>>>>>        Case Begin
80796>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80798>>>>>>>>>                Get _SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
80799>>>>>>>>>                Case Break
80800>>>>>>>>>
80800>>>>>>>>>            Case Else
80800>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTablespaces function."
80801>>>>>>>>>>
80801>>>>>>>>>                Case Break
80802>>>>>>>>>        Case End
80802>>>>>>>>>
80802>>>>>>>>>        Function_Return sReturnArray
80803>>>>>>>>>    End_Function
80804>>>>>>>>>
80804>>>>>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
80804>>>>>>>>>    Function _SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
80806>>>>>>>>>        String[] sReturnArray
80807>>>>>>>>>        String sConnectionString sSelect sSchema
80807>>>>>>>>>        Boolean bOK
80807>>>>>>>>>        Integer iDbType
80807>>>>>>>>>
80807>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80808>>>>>>>>>        If (bOK = False) Begin
80810>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80811>>>>>>>>>>
80811>>>>>>>>>            Function_Return sReturnArray
80812>>>>>>>>>        End
80812>>>>>>>>>>
80812>>>>>>>>>
80812>>>>>>>>>        Get psConnectionString to sConnectionString
80813>>>>>>>>>        Get psSchema to sSchema
80814>>>>>>>>>
80814>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
80814>>>>>>>>>        // the dbType.
80814>>>>>>>>>        Get piDbType to iDbType
80815>>>>>>>>>
80815>>>>>>>>>        Case Begin
80815>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
80817>>>>>>>>>                If (iDbType = EN_DbTypeMySQL) Begin
80819>>>>>>>>>                    Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
80820>>>>>>>>>                End
80820>>>>>>>>>>
80820>>>>>>>>>                If (iDbType = EN_DbTypePostgre) Begin
80822>>>>>>>>>                    Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
80823>>>>>>>>>                End
80823>>>>>>>>>>
80823>>>>>>>>>                If (iDbType = EN_DbTypeMSSQL) Begin
80825>>>>>>>>>                    Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
80826>>>>>>>>>                End
80826>>>>>>>>>>
80826>>>>>>>>>
80826>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80827>>>>>>>>>                Case Break
80828>>>>>>>>>
80828>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80831>>>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
80832>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80833>>>>>>>>>                Case Break
80834>>>>>>>>>
80834>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80837>>>>>>>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
80838>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80839>>>>>>>>>                Case Break
80840>>>>>>>>>
80840>>>>>>>>>            Case Else
80840>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateColumns function."
80841>>>>>>>>>>
80841>>>>>>>>>                Case Break
80842>>>>>>>>>        Case End
80842>>>>>>>>>
80842>>>>>>>>>        Function_Return sReturnArray
80843>>>>>>>>>    End_Function
80844>>>>>>>>>
80844>>>>>>>>>
80844>>>>>>>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
80844>>>>>>>>>    Function _SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
80846>>>>>>>>>        String[] asReturnArray asReturnArray2
80848>>>>>>>>>        String sConnectionString sSelect sSchema
80848>>>>>>>>>        Boolean bOK
80848>>>>>>>>>        Integer iCount iSize
80848>>>>>>>>>
80848>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80849>>>>>>>>>        If (bOK = False) Begin
80851>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80852>>>>>>>>>>
80852>>>>>>>>>            Function_Return asReturnArray
80853>>>>>>>>>        End
80853>>>>>>>>>>
80853>>>>>>>>>
80853>>>>>>>>>        Get psConnectionString to sConnectionString
80854>>>>>>>>>        Get psSchema to sSchema
80855>>>>>>>>>
80855>>>>>>>>>        Case Begin
80855>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80857>>>>>>>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
80858>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to asReturnArray
80859>>>>>>>>>                Case Break
80860>>>>>>>>>
80860>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80863>>>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
80864>>>>>>>>>>
80864>>>>>>>>>//                Move () to sSelect
80864>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to asReturnArray
80864>>>>>>>>>                Case Break
80865>>>>>>>>>
80865>>>>>>>>>            Case Else
80865>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateIndexes function."
80866>>>>>>>>>>
80866>>>>>>>>>                Case Break
80867>>>>>>>>>        Case End
80867>>>>>>>>>
80867>>>>>>>>>        Move (SizeOfArray(asReturnArray)) to iSize
80868>>>>>>>>>        Decrement iSize
80869>>>>>>>>>        For iCount from 0 to iSize
80875>>>>>>>>>>
80875>>>>>>>>>            If (Trim(asReturnArray[iCount]) <> "") Begin
80877>>>>>>>>>                Move asReturnArray[iCount] to asReturnArray2[SizeOfArray(asReturnArray2)]
80878>>>>>>>>>            End
80878>>>>>>>>>>
80878>>>>>>>>>        Loop
80879>>>>>>>>>>
80879>>>>>>>>>
80879>>>>>>>>>        Function_Return asReturnArray2
80880>>>>>>>>>    End_Function
80881>>>>>>>>>
80881>>>>>>>>>    // Returns a string array with all table names the passed table handle has relation ships with.
80881>>>>>>>>>    // The format of the array is "TableName.FieldName"
80881>>>>>>>>>    Function _SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
80883>>>>>>>>>        String[] sFileNameArray sFieldNameArray
80885>>>>>>>>>        tSQLRelation[] sRelationsArray
80885>>>>>>>>>        tSQLRelation[] sRelationsArray
80886>>>>>>>>>        String sConnectionString sSelect sSchema sFileName sFieldName
80886>>>>>>>>>        Boolean bOK
80886>>>>>>>>>        Integer iCount iSize iLength
80886>>>>>>>>>
80886>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80887>>>>>>>>>        If (bOK = False) Begin
80889>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80890>>>>>>>>>>
80890>>>>>>>>>            Function_Return sRelationsArray
80891>>>>>>>>>        End
80891>>>>>>>>>>
80891>>>>>>>>>
80891>>>>>>>>>        Get psConnectionString to sConnectionString
80892>>>>>>>>>        Get psSchema to sSchema
80893>>>>>>>>>
80893>>>>>>>>>        Case Begin
80893>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80895>>>>>>>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
80896>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
80897>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
80898>>>>>>>>>                Case Break
80899>>>>>>>>>
80899>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80902>>>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
80903>>>>>>>>>>
80903>>>>>>>>>//                Move () to sSelect
80903>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80903>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
80903>>>>>>>>>                Case Break
80904>>>>>>>>>
80904>>>>>>>>>            Case Else
80904>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to the _SqlUtilEnumerateRelations function."
80905>>>>>>>>>>
80905>>>>>>>>>                Case Break
80906>>>>>>>>>        Case End
80906>>>>>>>>>
80906>>>>>>>>>        Move (Length(sTableName)) to iLength
80907>>>>>>>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
80908>>>>>>>>>        Move (SizeOfArray(sFileNameArray)) to iSize
80909>>>>>>>>>        Decrement iSize
80910>>>>>>>>>        For iCount from 0 to iSize
80916>>>>>>>>>>
80916>>>>>>>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
80918>>>>>>>>>                Move sFileNameArray[iCount]         to sFileName
80919>>>>>>>>>                Move sFieldNameArray[iCount]        to sFieldName
80920>>>>>>>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
80921>>>>>>>>>                Move sFileName  to sRelationsArray[iCount].sFileName
80922>>>>>>>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
80923>>>>>>>>>            End
80923>>>>>>>>>>
80923>>>>>>>>>        Loop
80924>>>>>>>>>>
80924>>>>>>>>>
80924>>>>>>>>>        Function_Return sRelationsArray
80925>>>>>>>>>    End_Function
80926>>>>>>>>>
80926>>>>>>>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
80928>>>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
80928>>>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
80929>>>>>>>>>        String[] sUsers sPrograms
80931>>>>>>>>>        String sSelect
80931>>>>>>>>>        Integer iSize iCount
80931>>>>>>>>>
80931>>>>>>>>>        Case Begin
80931>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80933>>>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
80934>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sUsers
80935>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sPrograms
80936>>>>>>>>>                Case Break
80937>>>>>>>>>            Case Else
80937>>>>>>>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
80938>>>>>>>>>>
80938>>>>>>>>>        Case End
80938>>>>>>>>>
80938>>>>>>>>>        Move (SizeOfArray(sUsers)) to iSize
80939>>>>>>>>>        Decrement iSize
80940>>>>>>>>>        For iCount from 0 to iSize
80946>>>>>>>>>>
80946>>>>>>>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
80947>>>>>>>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
80948>>>>>>>>>        Loop
80949>>>>>>>>>>
80949>>>>>>>>>
80949>>>>>>>>>        Function_Return SQLLoggedInUser
80950>>>>>>>>>    End_Function
80951>>>>>>>>>
80951>>>>>>>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
80951>>>>>>>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
80951>>>>>>>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
80953>>>>>>>>>        String[] sFilesData
80954>>>>>>>>>        Boolean bExists
80954>>>>>>>>>        Integer iCh
80954>>>>>>>>>        String sFileName sExt
80954>>>>>>>>>
80954>>>>>>>>>        Get vFolderExists sDataPath to bExists
80955>>>>>>>>>        If (bExists = True) Begin
80957>>>>>>>>>            Move (Utf8ToAnsi(Trim(sDataPath))) to sDataPath
80958>>>>>>>>>            Move ("dir:" + sDataPath)      to sDataPath
80959>>>>>>>>>            Get Seq_New_Channel to iCh  // get free channel for input
80960>>>>>>>>>            Direct_Input channel iCh sDataPath
80962>>>>>>>>>                Repeat
80962>>>>>>>>>>
80962>>>>>>>>>                    Readln channel iCh sFileName
80964>>>>>>>>>                    Get ParseFileExtension sFileName to sExt
80965>>>>>>>>>                    If (Uppercase(sExt) = "INT") Begin
80967>>>>>>>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
80969>>>>>>>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
80970>>>>>>>>>                        End
80970>>>>>>>>>>
80970>>>>>>>>>                    End
80970>>>>>>>>>>
80970>>>>>>>>>                Until (SeqEof = True)
80972>>>>>>>>>            Close_Input channel iCh
80974>>>>>>>>>            Send Seq_Release_Channel iCh
80975>>>>>>>>>        End
80975>>>>>>>>>>
80975>>>>>>>>>        Function_Return sFilesData
80976>>>>>>>>>    End_Function
80977>>>>>>>>>
80977>>>>>>>>>    // Only done for MSSQLDRV_ID so far...
80977>>>>>>>>>    Function _SqlEnumerateDatabaseCollations String sDriverID Returns String[]
80979>>>>>>>>>        String sSQL sConnectionID sConnectionString sSelect sName sPre
80979>>>>>>>>>        String sDescription sFrom sSys sValue sPrevious
80979>>>>>>>>>        Handle hStmt hoSQLManager hoSQLConnect
80979>>>>>>>>>        Integer iFetchResult iRows iColumn iPos
80979>>>>>>>>>        tSQLConnection SQLConnection
80979>>>>>>>>>        tSQLConnection SQLConnection
80979>>>>>>>>>        String[] asCollations
80980>>>>>>>>>        
80980>>>>>>>>>        If (sDriverID = "") Begin
80982>>>>>>>>>            Error DFERR_PROGRAM "The database driver ID was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
80983>>>>>>>>>>
80983>>>>>>>>>            Function_Return asCollations
80984>>>>>>>>>        End
80984>>>>>>>>>>
80984>>>>>>>>>
80984>>>>>>>>>        // Only done for MSSQLDRV_ID so far...
80984>>>>>>>>>        If (sDriverID <> MSSQLDRV_ID) Begin
80986>>>>>>>>>            Function_Return asCollations
80987>>>>>>>>>        End                 
80987>>>>>>>>>>
80987>>>>>>>>>
80987>>>>>>>>>        Get phoSQLManager to hoSQLManager
80988>>>>>>>>>        Get psConnectionID     to sConnectionID
80989>>>>>>>>>        Get psConnectionString to sConnectionString
80990>>>>>>>>>        Move 0 to LastErr
80991>>>>>>>>>
80991>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80992>>>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hoSQLConnect
80993>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
80994>>>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
80996>>>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
80997>>>>>>>>>>
80997>>>>>>>>>            Function_Return asCollations
80998>>>>>>>>>        End
80998>>>>>>>>>>
80998>>>>>>>>>
80998>>>>>>>>>        Get SqlOpen of hoSQLConnect to hStmt
80999>>>>>>>>>
80999>>>>>>>>>        If (hStmt = 0) Begin
81001>>>>>>>>>            Send SqlDisconnect of hoSQLManager
81002>>>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
81003>>>>>>>>>>
81003>>>>>>>>>            Function_Return asCollations
81004>>>>>>>>>        End
81004>>>>>>>>>>
81004>>>>>>>>>
81004>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect      to sSelect
81005>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName        to sName
81006>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDescription to sDescription
81007>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom        to sFrom
81008>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys         to sSys
81009>>>>>>>>>
81009>>>>>>>>>        // MS-SQL Syntax:  
81009>>>>>>>>>        // SELECT name, description
81009>>>>>>>>>        //   from sys.fn_helpcollations();
81009>>>>>>>>>        Move (sSelect  * String(sName) * String(",") * String(sDescription) * String(sFrom) * String(sSys) * String(".fn_helpcollations();")) to sSQL
81010>>>>>>>>>
81010>>>>>>>>>        Move 1 to iColumn
81011>>>>>>>>>        Send SqlExecDirect of hStmt sSQL
81012>>>>>>>>>        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
81013>>>>>>>>>        Repeat
81013>>>>>>>>>>
81013>>>>>>>>>            Get SQLFetch of hStmt to iFetchResult
81014>>>>>>>>>            If (iFetchResult <> 0) Begin
81016>>>>>>>>>                Get SQLColumnValue of hStmt iColumn to sValue 
81017>>>>>>>>>                If (sValue <> sPrevious) Begin         
81019>>>>>>>>>                    // We need to skip all collations starting with "SQL" because they
81019>>>>>>>>>                    // are obsolete and for pre-SQL Server 2000.
81019>>>>>>>>>                    Move (Pos("SQL", Uppercase(sValue))) to iPos
81020>>>>>>>>>                    If (iPos <> 1) Begin
81022>>>>>>>>>                        Move (Trim(sValue)) to asCollations[SizeOfArray(asCollations)
81023>>>>>>>>>                    End
81023>>>>>>>>>>
81023>>>>>>>>>                End
81023>>>>>>>>>>
81023>>>>>>>>>                Move sValue to sPrevious
81024>>>>>>>>>            End
81024>>>>>>>>>>
81024>>>>>>>>>        Until (iFetchResult = 0)
81026>>>>>>>>>        Send SQLClose of hStmt
81027>>>>>>>>>        Send SQLDisconnect of hoSQLConnect
81028>>>>>>>>>
81028>>>>>>>>>        Function_Return asCollations
81029>>>>>>>>>    End_Function
81030>>>>>>>>>
81030>>>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
81030>>>>>>>>>    // for DAW drivers.
81030>>>>>>>>>    // Returns: A string array.
81030>>>>>>>>>    Function _SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
81032>>>>>>>>>        String[] sReturnArray
81033>>>>>>>>>        String sValue sPrevious
81033>>>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
81033>>>>>>>>>        Integer iFetchResult iRows
81033>>>>>>>>>        tSQLConnection SQLConnection
81033>>>>>>>>>        tSQLConnection SQLConnection
81033>>>>>>>>>
81033>>>>>>>>>        Get phoSQLManager to hoSQLHandler
81034>>>>>>>>>
81034>>>>>>>>>        If (hoSQLHandler <> 0) Begin
81036>>>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81037>>>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
81038>>>>>>>>>
81038>>>>>>>>>            If (hoSQLConnect <> 0) Begin
81040>>>>>>>>>                Get SQLOpen of hoSQLConnect to hstmt
81041>>>>>>>>>                If (hstmt <> 0) Begin
81043>>>>>>>>>                    Send SqlExecDirect of hstmt sStmt
81044>>>>>>>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
81045>>>>>>>>>                    Repeat
81045>>>>>>>>>>
81045>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
81046>>>>>>>>>                        If (iFetchResult <> 0) Begin
81048>>>>>>>>>                            Get SQLColumnValue of hstmt iColumn to sValue
81049>>>>>>>>>                            If (sValue <> sPrevious) Begin
81051>>>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
81052>>>>>>>>>                            End
81052>>>>>>>>>>
81052>>>>>>>>>                            Move sValue to sPrevious
81053>>>>>>>>>                        End
81053>>>>>>>>>>
81053>>>>>>>>>                    Until (iFetchResult = 0)
81055>>>>>>>>>                    Send SQLClose of hstmt
81056>>>>>>>>>                End
81056>>>>>>>>>>
81056>>>>>>>>>                Send SQLDisconnect of hoSQLConnect
81057>>>>>>>>>            End
81057>>>>>>>>>>
81057>>>>>>>>>        End
81057>>>>>>>>>>
81057>>>>>>>>>
81057>>>>>>>>>        Function_Return sReturnArray
81058>>>>>>>>>    End_Function
81059>>>>>>>>>
81059>>>>>>>>>    Function _SqlDatabasesArrayDB2 Returns String[]
81061>>>>>>>>>        String[] sReturnArray
81062>>>>>>>>>        String sDataSource
81062>>>>>>>>>        Handle hoSQLHandler
81062>>>>>>>>>        Integer iItem
81062>>>>>>>>>
81062>>>>>>>>>        Get phoDB2SQLHandler to hoSQLHandler
81063>>>>>>>>>        Send SeedDataSources of hoSQLHandler
81064>>>>>>>>>
81064>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81065>>>>>>>>>
81065>>>>>>>>>        Repeat
81065>>>>>>>>>>
81065>>>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
81066>>>>>>>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
81067>>>>>>>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
81068>>>>>>>>>            Increment iItem
81069>>>>>>>>>        Until (sDataSource = "")
81071>>>>>>>>>
81071>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81072>>>>>>>>>
81072>>>>>>>>>        Function_Return sReturnArray
81073>>>>>>>>>    End_Function
81074>>>>>>>>>
81074>>>>>>>>>    Function _SqlDatabaseSourcesArrayODBC Returns String[]
81076>>>>>>>>>        String[] sReturnArray
81077>>>>>>>>>        String sDataSource
81077>>>>>>>>>        Handle hoSQLHandler
81077>>>>>>>>>        Integer iItem
81077>>>>>>>>>
81077>>>>>>>>>        Get phoODBCSQLHandler to hoSQLHandler
81078>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81079>>>>>>>>>
81079>>>>>>>>>        Send SeedDataSources of hoSQLHandler
81080>>>>>>>>>
81080>>>>>>>>>        Repeat
81080>>>>>>>>>>
81080>>>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
81081>>>>>>>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
81083>>>>>>>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
81084>>>>>>>>>                Increment iItem
81085>>>>>>>>>            End
81085>>>>>>>>>>
81085>>>>>>>>>        Until (sDataSource = "")
81087>>>>>>>>>
81087>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81088>>>>>>>>>
81088>>>>>>>>>        Function_Return sReturnArray
81089>>>>>>>>>    End_Function
81090>>>>>>>>>
81090>>>>>>>>>    Function _SqlDatabasesArrayODBC Returns tSQLIntTableInfo[]
81092>>>>>>>>>        String[] sDataSources
81093>>>>>>>>>        tSQLConnection SQLConnection
81093>>>>>>>>>        tSQLConnection SQLConnection
81093>>>>>>>>>        tSQLIntTableInfo[] sReturnArray
81093>>>>>>>>>        tSQLIntTableInfo[] sReturnArray
81094>>>>>>>>>        Integer iDataSources iCount iItem
81094>>>>>>>>>        String sConnection sServer sDatabase sKey sSubKey
81094>>>>>>>>>        Handle hoIniFile hoRegistry hoODBCDataSources
81094>>>>>>>>>        Boolean bExists bKeyOpened
81094>>>>>>>>>
81094>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81095>>>>>>>>>        Move SQLConnection.sConnectionString to sConnection
81096>>>>>>>>>        Move SQLConnection.sServer           to sServer
81097>>>>>>>>>
81097>>>>>>>>>        // FileDSN - read DATABASE name from DSN ini-file
81097>>>>>>>>>        If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
81099>>>>>>>>>            Get Create (RefClass(cIniFile)) to hoIniFile
81100>>>>>>>>>            Set psFileName of hoIniFile to sServer
81101>>>>>>>>>            Get ReadString of hoIniFile CS_SQLODBCIniSectionName CS_SQLIniDatabaseKeyword "" to sDatabase
81102>>>>>>>>>            Move sDatabase to sReturnArray[0].sDatabaseName
81103>>>>>>>>>            Send Destroy of hoIniFile
81104>>>>>>>>>        End
81104>>>>>>>>>>
81104>>>>>>>>>
81104>>>>>>>>>        // DSN - read DATABASE name from the registry
81104>>>>>>>>>        Else Begin
81105>>>>>>>>>            Get Create (RefClass(cRegistry)) to hoRegistry
81106>>>>>>>>>
81106>>>>>>>>>            // We start with checking the "System DNS" area in the registry as it is the
81106>>>>>>>>>            // most probably place the info is kept that we're after.
81106>>>>>>>>>            Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
81107>>>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
81108>>>>>>>>>            Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
81109>>>>>>>>>            If (bExists = True) Begin
81111>>>>>>>>>                Move "SOFTWARE\Wow6432Node\ODBC\ODBC.INI" to sKey
81112>>>>>>>>>            End
81112>>>>>>>>>>
81112>>>>>>>>>            Else Begin
81113>>>>>>>>>                Move "SOFTWARE\ODBC\ODBC.INI" to sKey
81114>>>>>>>>>            End
81114>>>>>>>>>>
81114>>>>>>>>>
81114>>>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
81115>>>>>>>>>            If (bExists) Begin
81117>>>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
81118>>>>>>>>>                If (bKeyOpened) Begin
81120>>>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
81121>>>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
81122>>>>>>>>>                    If (iDataSources > 0) Begin
81124>>>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
81125>>>>>>>>>                        Decrement iDataSources
81126>>>>>>>>>                        for iCount from 0 to iDataSources
81132>>>>>>>>>>
81132>>>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
81133>>>>>>>>>                        Loop
81134>>>>>>>>>>
81134>>>>>>>>>                        Move 0 to iItem
81135>>>>>>>>>                        for iCount from 0 to iDataSources
81141>>>>>>>>>>
81141>>>>>>>>>                            Move sDataSources[iCount] to sSubKey
81142>>>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
81143>>>>>>>>>                            If (bKeyOpened = True) Begin
81145>>>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
81146>>>>>>>>>                                If (bExists = True) Begin
81148>>>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
81149>>>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
81150>>>>>>>>>                                    Increment iItem
81151>>>>>>>>>                                End
81151>>>>>>>>>>
81151>>>>>>>>>                            End
81151>>>>>>>>>>
81151>>>>>>>>>                        Loop
81152>>>>>>>>>>
81152>>>>>>>>>                    End
81152>>>>>>>>>>
81152>>>>>>>>>                    Send CloseKey of hoRegistry
81153>>>>>>>>>                    Send Destroy of hoODBCDataSources
81154>>>>>>>>>                End
81154>>>>>>>>>>
81154>>>>>>>>>            End
81154>>>>>>>>>>
81154>>>>>>>>>
81154>>>>>>>>>            // We then check the "User DNS" area in the registry.
81154>>>>>>>>>            Set phRootKey of hoRegistry to HKEY_CURRENT_USER
81155>>>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
81156>>>>>>>>>            Move "SOFTWARE\ODBC\ODBC.INI" to sKey
81157>>>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
81158>>>>>>>>>
81158>>>>>>>>>            If (bExists) Begin
81160>>>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
81161>>>>>>>>>                If (bKeyOpened) Begin
81163>>>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
81164>>>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
81165>>>>>>>>>                    If (iDataSources > 0) Begin
81167>>>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
81168>>>>>>>>>                        Decrement iDataSources
81169>>>>>>>>>                        for iCount from 0 to iDataSources
81175>>>>>>>>>>
81175>>>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
81176>>>>>>>>>                        Loop
81177>>>>>>>>>>
81177>>>>>>>>>                        for iCount from 0 to iDataSources
81183>>>>>>>>>>
81183>>>>>>>>>                            Move sDataSources[iCount] to sSubKey
81184>>>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
81185>>>>>>>>>                            If (bKeyOpened = True) Begin
81187>>>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
81188>>>>>>>>>                                If (bExists = True) Begin
81190>>>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
81191>>>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
81192>>>>>>>>>                                    Increment iItem
81193>>>>>>>>>                                End
81193>>>>>>>>>>
81193>>>>>>>>>                            End
81193>>>>>>>>>>
81193>>>>>>>>>                        Loop
81194>>>>>>>>>>
81194>>>>>>>>>                    End
81194>>>>>>>>>>
81194>>>>>>>>>                    Send CloseKey of hoRegistry
81195>>>>>>>>>                    Send Destroy of hoODBCDataSources
81196>>>>>>>>>                End
81196>>>>>>>>>>
81196>>>>>>>>>            End
81196>>>>>>>>>>
81196>>>>>>>>>
81196>>>>>>>>>            Send Destroy of hoRegistry
81197>>>>>>>>>        End
81197>>>>>>>>>>
81197>>>>>>>>>
81197>>>>>>>>>        Function_Return sReturnArray
81198>>>>>>>>>    End_Function
81199>>>>>>>>>
81199>>>>>>>>>    // We might have a split Sql script where the info about which database to use is
81199>>>>>>>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
81199>>>>>>>>>    // insert it for scriplets to come after the first one.
81199>>>>>>>>>    Function _SqlFormatStatement String sStmt Returns String
81201>>>>>>>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
81201>>>>>>>>>        Integer iStart iEnd iDbType
81201>>>>>>>>>        Boolean bOK
81201>>>>>>>>>
81201>>>>>>>>>        Get piDbType to iDbType
81202>>>>>>>>>        Get psDriverID to sDriverID
81203>>>>>>>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
81204>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
81205>>>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
81206>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
81207>>>>>>>>>        Move (Replaces(" ", sStmt, "")) to sTmp
81208>>>>>>>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
81210>>>>>>>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
81211>>>>>>>>>            Move (Pos("]", sTmp)) to iEnd
81212>>>>>>>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
81213>>>>>>>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
81214>>>>>>>>>            Set Private.psUseDatabase to sUseDatabase
81215>>>>>>>>>        End
81215>>>>>>>>>>
81215>>>>>>>>>        Else Begin
81216>>>>>>>>>            Move (Uppercase(sStmt)) to sTmp
81217>>>>>>>>>
81217>>>>>>>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
81217>>>>>>>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
81219>>>>>>>>>                Get Private.psUseDatabase to sUseDatabase
81220>>>>>>>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
81221>>>>>>>>>            End
81221>>>>>>>>>>
81221>>>>>>>>>
81221>>>>>>>>>            // This is a bit special to place here but was done so because it was easier that way.
81221>>>>>>>>>            // We will get an error when trying to create a view if it already exists.
81221>>>>>>>>>            // So to avoid such errors; we first remove it & then recreate it.
81221>>>>>>>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
81224>>>>>>>>>                // Make sure we only have one space between statements/words.
81224>>>>>>>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
81225>>>>>>>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
81226>>>>>>>>>                Move (Trim(sTmp)) to sTmp
81227>>>>>>>>>                Move (Pos(" ", sTmp)) to iEnd
81228>>>>>>>>>                Move (Left(sTmp, iEnd)) to sTmp
81229>>>>>>>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
81231>>>>>>>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
81232>>>>>>>>>                End
81232>>>>>>>>>>
81232>>>>>>>>>                Move (Trim(sTmp)) to sTmp
81233>>>>>>>>>                // Remove data view as it already exists!
81233>>>>>>>>>                Get _SqlViewRemove sDriverID sTmp to bOK
81234>>>>>>>>>            End
81234>>>>>>>>>>
81234>>>>>>>>>        End
81234>>>>>>>>>>
81234>>>>>>>>>
81234>>>>>>>>>        Function_Return sStmt
81235>>>>>>>>>    End_Function
81236>>>>>>>>>
81236>>>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
81236>>>>>>>>>    Function _SqlViewRemove String sDataView Returns Boolean
81238>>>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
81238>>>>>>>>>        Integer iRetval
81238>>>>>>>>>        Boolean bOK
81238>>>>>>>>>
81238>>>>>>>>>        Get psDriverID to sDriverID
81239>>>>>>>>>        Get _UtilDeleteCacheFile sDataView to iRetval
81240>>>>>>>>>
81240>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
81241>>>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
81242>>>>>>>>>        Set psSQLStatementString to sSQLString
81243>>>>>>>>>
81243>>>>>>>>>        // As we don't check if the view exist or not, it might happen
81243>>>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
81243>>>>>>>>>        Move False to Err
81244>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
81245>>>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
81246>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
81247>>>>>>>>>        Move 0 to LastErr
81248>>>>>>>>>
81248>>>>>>>>>        // We also need to remove the cache-file since the table has been changed
81248>>>>>>>>>        Get _UtilDeleteCacheFile sDataView to bOK
81249>>>>>>>>>
81249>>>>>>>>>        Function_Return (Err = False)
81250>>>>>>>>>    End_Function
81251>>>>>>>>>
81251>>>>>>>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
81251>>>>>>>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
81253>>>>>>>>>        String sRetval
81253>>>>>>>>>        Integer iDbType iIndex
81253>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
81253>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
81254>>>>>>>>>        tSQLKeyWords   SQLKeyWords
81254>>>>>>>>>        tSQLKeyWords   SQLKeyWords
81254>>>>>>>>>
81254>>>>>>>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
81254>>>>>>>>>        Move "" to sRetval
81255>>>>>>>>>        Get piDbType to iDbType
81256>>>>>>>>>        Move iDbType             to SQLKeyWords.iSQLDbType
81257>>>>>>>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
81258>>>>>>>>>
81258>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
81259>>>>>>>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
81260>>>>>>>>>        If (iIndex >= 0) Begin
81262>>>>>>>>>            Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
81263>>>>>>>>>        End
81263>>>>>>>>>>
81263>>>>>>>>>
81263>>>>>>>>>        Function_Return sRetval
81264>>>>>>>>>    End_Function
81265>>>>>>>>>
81265>>>>>>>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
81265>>>>>>>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
81267>>>>>>>>>        String[] sSQLScriptArray
81268>>>>>>>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
81268>>>>>>>>>        Integer iSize iCount
81268>>>>>>>>>        Boolean bCommentStart bCommentEnd bDashComment
81268>>>>>>>>>
81268>>>>>>>>>        Move False to bCommentStart
81269>>>>>>>>>        Move False to bCommentEnd
81270>>>>>>>>>        Move False to bDashComment
81271>>>>>>>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
81272>>>>>>>>>        Move "*/"  to sCommentEnd
81273>>>>>>>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
81274>>>>>>>>>
81274>>>>>>>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
81275>>>>>>>>>        Decrement iSize
81276>>>>>>>>>        Move "" to sText
81277>>>>>>>>>
81277>>>>>>>>>        for iCount from 0 to iSize
81283>>>>>>>>>>
81283>>>>>>>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
81284>>>>>>>>>            Move (Trim(sLine)) to sTmp
81285>>>>>>>>>            If (sTmp <> "") Begin
81287>>>>>>>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
81288>>>>>>>>>                If (bCommentStart = False) Begin
81290>>>>>>>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
81291>>>>>>>>>                    If (bCommentStart = False) Begin
81293>>>>>>>>>                    End
81293>>>>>>>>>>
81293>>>>>>>>>                End
81293>>>>>>>>>>
81293>>>>>>>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
81294>>>>>>>>>                If (bCommentEnd = True) Begin
81296>>>>>>>>>                    Move False to bCommentStart
81297>>>>>>>>>                End
81297>>>>>>>>>>
81297>>>>>>>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
81299>>>>>>>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
81300>>>>>>>>>                End
81300>>>>>>>>>>
81300>>>>>>>>>            End
81300>>>>>>>>>>
81300>>>>>>>>>        Loop
81301>>>>>>>>>>
81301>>>>>>>>>
81301>>>>>>>>>        // Update the retval struct array:
81301>>>>>>>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
81302>>>>>>>>>        Function_Return SqlScriptArray
81303>>>>>>>>>    End_Function
81304>>>>>>>>>
81304>>>>>>>>>    // Helper function that builds a string like;
81304>>>>>>>>>    // "SELECT name from [Master].[sys].[databases] where name"
81304>>>>>>>>>    Function _SqlSelectFromWhereName Returns String
81306>>>>>>>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
81306>>>>>>>>>
81306>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
81307>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName         to sName
81308>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
81309>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
81310>>>>>>>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
81311>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
81312>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
81313>>>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
81314>>>>>>>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
81315>>>>>>>>>        Function_Return sRetval
81316>>>>>>>>>    End_Function
81317>>>>>>>>>
81317>>>>>>>>>    // Helper function to create a SQL statement like;
81317>>>>>>>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
81317>>>>>>>>>    // Used for checking if an index exists.
81317>>>>>>>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
81319>>>>>>>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
81319>>>>>>>>>
81319>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
81320>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
81321>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
81322>>>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
81323>>>>>>>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
81324>>>>>>>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
81325>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName to sName
81326>>>>>>>>>
81326>>>>>>>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
81327>>>>>>>>>
81327>>>>>>>>>        Function_Return sRetval
81328>>>>>>>>>    End_Function
81329>>>>>>>>>
81329>>>>>>>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
81329>>>>>>>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
81329>>>>>>>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
81331>>>>>>>>>        String sRetval
81331>>>>>>>>>        If (iLength <> 0) Begin
81333>>>>>>>>>            Move ("(" + String(iLength)) to sRetval
81334>>>>>>>>>            If (iDecimals <> 0) Begin
81336>>>>>>>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
81337>>>>>>>>>            End
81337>>>>>>>>>>
81337>>>>>>>>>            Move (sRetval + ")") to sRetval
81338>>>>>>>>>        End
81338>>>>>>>>>>
81338>>>>>>>>>        Function_Return sRetval
81339>>>>>>>>>    End_Function
81340>>>>>>>>>
81340>>>>>>>>>    // Checks that the passed sDriverID is defined.
81340>>>>>>>>>    // Also checks if the driver has been loaded; else it gets loaded.
81340>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
81342>>>>>>>>>        Boolean bOK
81342>>>>>>>>>        Integer iDriver
81342>>>>>>>>>
81342>>>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
81344>>>>>>>>>            Function_Return False
81345>>>>>>>>>        End
81345>>>>>>>>>>
81345>>>>>>>>>
81345>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
81346>>>>>>>>>
81346>>>>>>>>>        If (bOK = False) Begin
81348>>>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, or ODBC_DRV"
81349>>>>>>>>>>
81349>>>>>>>>>            Function_Return False
81350>>>>>>>>>        End
81350>>>>>>>>>>
81350>>>>>>>>>
81350>>>>>>>>>        Get DriverIndex sDriverID to iDriver
81351>>>>>>>>>        If (iDriver = 0) Begin
81353>>>>>>>>>            Load_Driver sDriverID
81354>>>>>>>>>        End
81354>>>>>>>>>>
81354>>>>>>>>>
81354>>>>>>>>>        Function_Return True
81355>>>>>>>>>    End_Function
81356>>>>>>>>>
81356>>>>>>>>>    // Checks that the length parameter has been passed correctly.
81356>>>>>>>>>    // This is only of concern for certain SQL data types.
81356>>>>>>>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
81358>>>>>>>>>        Integer iLength
81358>>>>>>>>>        Boolean bOK bCheckTypeLength
81358>>>>>>>>>
81358>>>>>>>>>        If (num_arguments > 1) Begin
81360>>>>>>>>>            Move iLen to iLength
81361>>>>>>>>>        End
81361>>>>>>>>>>
81361>>>>>>>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
81362>>>>>>>>>
81362>>>>>>>>>        If (bCheckTypeLength = True) Begin
81364>>>>>>>>>            Move (iLength > 0) to bOK
81365>>>>>>>>>        End
81365>>>>>>>>>>
81365>>>>>>>>>
81365>>>>>>>>>        Function_Return (bOK = True)
81366>>>>>>>>>    End_Function
81367>>>>>>>>>
81367>>>>>>>>>    Function _SqlProperTableName String sTableName Returns String
81369>>>>>>>>>        String sVal sSchema sDriverID
81369>>>>>>>>>        Integer iDbType
81369>>>>>>>>>
81369>>>>>>>>>        If (Trim(sTableName) = "") Begin
81371>>>>>>>>>            Function_Return ""
81372>>>>>>>>>        End
81372>>>>>>>>>>
81372>>>>>>>>>
81372>>>>>>>>>        Get psDriverID to sDriverID
81373>>>>>>>>>        Get piDbType   to iDbType
81374>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
81376>>>>>>>>>            Get psUserID to sSchema
81377>>>>>>>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
81377>>>>>>>>>            Move (Uppercase(sSchema)) to sSchema
81378>>>>>>>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
81379>>>>>>>>>            Function_Return sTableName
81380>>>>>>>>>        End
81380>>>>>>>>>>
81380>>>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
81382>>>>>>>>>            Get psDatabase to sVal
81383>>>>>>>>>            Move (sVal + "." + sTableName) to sTableName
81384>>>>>>>>>            Function_Return sTableName
81385>>>>>>>>>        End
81385>>>>>>>>>>
81385>>>>>>>>>        If (iDbType = EN_DbTypePostgre) Begin
81387>>>>>>>>>            Move ('"' + sTableName + '"') to sTableName
81388>>>>>>>>>            Function_Return sTableName
81389>>>>>>>>>        End
81389>>>>>>>>>>
81389>>>>>>>>>
81389>>>>>>>>>        Get psSchema to sSchema
81390>>>>>>>>>        If (sSchema = "") Begin
81392>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
81393>>>>>>>>>        End
81393>>>>>>>>>>
81393>>>>>>>>>
81393>>>>>>>>>        Move (Uppercase(sTableName)) to sVal
81394>>>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
81396>>>>>>>>>            If (iDbType = EN_dbTypeDB2) Begin
81398>>>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
81399>>>>>>>>>            End
81399>>>>>>>>>>
81399>>>>>>>>>            Else Begin
81400>>>>>>>>>                Move (sSchema + "." + sTableName) to sTableName
81401>>>>>>>>>            End
81401>>>>>>>>>>
81401>>>>>>>>>        End
81401>>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>        Function_Return sTableName
81402>>>>>>>>>    End_Function
81403>>>>>>>>>
81403>>>>>>>>>    // SQL column names can be case-sensitive. This function is used to check that
81403>>>>>>>>>    // the passed sFieldName has the correct spelling.
81403>>>>>>>>>    // Used with Embedded SQL statement calls.
81403>>>>>>>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
81403>>>>>>>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
81405>>>>>>>>>        String sRetval sValue sDriverID
81405>>>>>>>>>        String[] sColumnNamesArray
81406>>>>>>>>>        Integer iCount iColumns
81406>>>>>>>>>
81406>>>>>>>>>        Move "" to sRetval
81407>>>>>>>>>        Get psDriverID to sDriverID
81408>>>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
81409>>>>>>>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
81410>>>>>>>>>        Decrement iColumns
81411>>>>>>>>>
81411>>>>>>>>>        For iCount from 0 to iColumns
81417>>>>>>>>>>
81417>>>>>>>>>            Move sColumnNamesArray[iCount] to sValue
81418>>>>>>>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
81420>>>>>>>>>                Move sValue to sRetval
81421>>>>>>>>>                Move iColumns to iCount // We're done.
81422>>>>>>>>>            End
81422>>>>>>>>>>
81422>>>>>>>>>        Loop
81423>>>>>>>>>>
81423>>>>>>>>>
81423>>>>>>>>>        Function_Return sRetval
81424>>>>>>>>>    End_Function
81425>>>>>>>>>
81425>>>>>>>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
81427>>>>>>>>>        String[] sReturnArray
81428>>>>>>>>>        Handle hoSQLHandler
81428>>>>>>>>>        Integer iCount iSize iItem
81428>>>>>>>>>        String sServer
81428>>>>>>>>>        tSQLConnection SQLConnection
81428>>>>>>>>>        tSQLConnection SQLConnection
81428>>>>>>>>>
81428>>>>>>>>>        Get phoMSSQLHandler to hoSQLHandler
81429>>>>>>>>>        Send Delete_Data    of hoSQLHandler
81430>>>>>>>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
81431>>>>>>>>>
81431>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81432>>>>>>>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
81433>>>>>>>>>        Decrement iSize
81434>>>>>>>>>
81434>>>>>>>>>        For iCount from 0 to iSize
81440>>>>>>>>>>
81440>>>>>>>>>            Get String_Value of hoSQLHandler iCount to sServer
81441>>>>>>>>>            Move (Trim(sServer)) to sReturnArray[iItem]
81442>>>>>>>>>            Increment iItem
81443>>>>>>>>>        Loop
81444>>>>>>>>>>
81444>>>>>>>>>
81444>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81445>>>>>>>>>
81445>>>>>>>>>        Function_Return sReturnArray
81446>>>>>>>>>    End_Function
81447>>>>>>>>>
81447>>>>>>>>>    Function _SqlTableArrayDAW Returns String[]
81449>>>>>>>>>        String[] sReturnArray
81450>>>>>>>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord sConnectionString
81450>>>>>>>>>        Handle hoSQLHandler
81450>>>>>>>>>        Integer iCount iSize iItem iPos
81450>>>>>>>>>        Boolean bOK
81450>>>>>>>>>        tSQLConnection SQLConnection
81450>>>>>>>>>        tSQLConnection SQLConnection
81450>>>>>>>>>
81450>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81451>>>>>>>>>        If (SQLConnection.sConnectionString = "") Begin
81453>>>>>>>>>            Function_Return sReturnArray
81454>>>>>>>>>        End
81454>>>>>>>>>>
81454>>>>>>>>>
81454>>>>>>>>>        Move SQLConnection.sSchema      to sDefSchema
81455>>>>>>>>>        Move (Uppercase(sDefSchema))    to sDefSchema
81456>>>>>>>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
81457>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
81458>>>>>>>>>
81458>>>>>>>>>        Get phoCLIHandler to hoSQLHandler
81459>>>>>>>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
81460>>>>>>>>>        Send Delete_Data  of hoSQLHandler
81461>>>>>>>>>
81461>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81462>>>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
81463>>>>>>>>>        // 2020-03-14 This was not correct when testing a MS-SQL ODBC driver connection from CMOS.
81463>>>>>>>>>//        If (SQLConnection.sDriverID = ODBC_DRV_ID) Begin
81463>>>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
81463>>>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
81463>>>>>>>>>//                If (iPos > 0) Begin
81463>>>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
81463>>>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
81463>>>>>>>>>//                End
81463>>>>>>>>>//            End
81463>>>>>>>>>//        End
81463>>>>>>>>>
81463>>>>>>>>>        Get EnumerateTables of hoSQLHandler sConnectionString to iSize
81464>>>>>>>>>        Move False to Err
81465>>>>>>>>>        Move 0 to iItem
81466>>>>>>>>>
81466>>>>>>>>>        // Note that the enumeration starts from table no 1. (not zero)
81466>>>>>>>>>        For iCount from 1 to iSize
81472>>>>>>>>>>
81472>>>>>>>>>            Get TableName    of hoSQLHandler iCount to sTable
81473>>>>>>>>>            Get TableType    of hoSQLHandler iCount to sTableType
81474>>>>>>>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
81475>>>>>>>>>            If (sSchema = "") Begin
81477>>>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
81478>>>>>>>>>            End
81478>>>>>>>>>>
81478>>>>>>>>>            Get TableComment of hoSQLHandler iCount to sComment
81479>>>>>>>>>            Move (Trim(sTable)) to sTable
81480>>>>>>>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
81482>>>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
81483>>>>>>>>>            End
81483>>>>>>>>>>
81483>>>>>>>>>            Else Begin
81484>>>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
81485>>>>>>>>>            End
81485>>>>>>>>>>
81485>>>>>>>>>            If (bOK = True) Begin
81487>>>>>>>>>                Move sTable to sReturnArray[iItem]
81488>>>>>>>>>                Increment iItem
81489>>>>>>>>>            End
81489>>>>>>>>>>
81489>>>>>>>>>        Loop
81490>>>>>>>>>>
81490>>>>>>>>>
81490>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81491>>>>>>>>>
81491>>>>>>>>>        Function_Return sReturnArray
81492>>>>>>>>>    End_Function
81493>>>>>>>>>
81493>>>>>>>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
81495>>>>>>>>>        String[] sReturnArray
81496>>>>>>>>>        String sValue
81496>>>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
81496>>>>>>>>>        Integer iRetval iCols iFetchResult
81496>>>>>>>>>        tSQLConnection SQLConnection
81496>>>>>>>>>        tSQLConnection SQLConnection
81496>>>>>>>>>
81496>>>>>>>>>        Get phoSQLManager to hoSQLHandler
81497>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81498>>>>>>>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
81499>>>>>>>>>
81499>>>>>>>>>        If (hoSQLConnect <> 0) Begin
81501>>>>>>>>>            Get SqlOpen of hoSQLConnect to hStmt
81502>>>>>>>>>            If (hStmt <> 0) Begin
81504>>>>>>>>>                Send SqlSetProcedurename of hStmt sStmt
81505>>>>>>>>>                If (sArgument <> "") Begin
81507>>>>>>>>>                    Send SqlSetArgument  of hStmt 1 sArgument
81508>>>>>>>>>                End
81508>>>>>>>>>>
81508>>>>>>>>>
81508>>>>>>>>>                Send SqlCall             of hStmt
81509>>>>>>>>>                Get SqlReturnValue       of hStmt to iRetval
81510>>>>>>>>>                If (iRetval = 0) Begin
81512>>>>>>>>>                    Repeat
81512>>>>>>>>>>
81512>>>>>>>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
81513>>>>>>>>>                        If (iCols > 0) Begin
81515>>>>>>>>>                            Repeat
81515>>>>>>>>>>
81515>>>>>>>>>                                Get SqlFetch of hStmt to iFetchResult
81516>>>>>>>>>                                If (iFetchResult <> 0) Begin
81518>>>>>>>>>                                    Get SqlColumnValue of hStmt 1 to sValue
81519>>>>>>>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
81520>>>>>>>>>                                End
81520>>>>>>>>>>
81520>>>>>>>>>                            Until (iFetchResult = 0)
81522>>>>>>>>>                        End
81522>>>>>>>>>>
81522>>>>>>>>>                        Get SqlNextResultSet of hStmt to iRetval
81523>>>>>>>>>                    Until (iRetval = 0)
81525>>>>>>>>>                    Send SqlClose of hStmt
81526>>>>>>>>>                End
81526>>>>>>>>>>
81526>>>>>>>>>            End
81526>>>>>>>>>>
81526>>>>>>>>>            Send SqlDisconnect of hoSQLConnect
81527>>>>>>>>>        End
81527>>>>>>>>>>
81527>>>>>>>>>        Function_Return sReturnArray
81528>>>>>>>>>    End_Function
81529>>>>>>>>>
81529>>>>>>>>>    Function _SqlUtilUpdateIntFile Integer hTable Returns Boolean
81531>>>>>>>>>        String sOrgFormat sNewFormat sRootName hTableName sPhysicalFileName sDriverID sDataPath
81531>>>>>>>>>        Boolean bOpened bOK
81531>>>>>>>>>
81531>>>>>>>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
81531>>>>>>>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
81531>>>>>>>>>        // which makes the program unable to run because they can't be opened.
81531>>>>>>>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
81531>>>>>>>>>        // proper .int files for the two tables.
81531>>>>>>>>>//        If (Uppercase(hTableName) = "CODETYPE" or Uppercase(hTableName) = "CODEMAST") Begin
81531>>>>>>>>>//            Function_Return True
81531>>>>>>>>>//        End
81531>>>>>>>>>
81531>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81534>>>>>>>>>        Get _TableNameOnly sRootName to hTableName
81535>>>>>>>>>        Move CS_OEM_Txt  to sOrgFormat
81536>>>>>>>>>        Move CS_ANSI_Txt to sNewFormat
81537>>>>>>>>>        Get AutoConnectionIDLogin to bOK
81538>>>>>>>>>
81538>>>>>>>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
81538>>>>>>>>>//        Sleep 1  
81538>>>>>>>>>        Get _UtilDeleteCacheFile hTableName to bOK
81539>>>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
81542>>>>>>>>>        If (bOpened = False) Begin
81544>>>>>>>>>            Open hTable
81546>>>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
81549>>>>>>>>>        End
81549>>>>>>>>>>
81549>>>>>>>>>        If (bOpened = False) Begin
81551>>>>>>>>>            Function_Return False
81552>>>>>>>>>        End
81552>>>>>>>>>>
81552>>>>>>>>>
81552>>>>>>>>>        Get psDriverID to sDriverID
81553>>>>>>>>>
81553>>>>>>>>>        Move False to Err
81554>>>>>>>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81557>>>>>>>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
81558>>>>>>>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
81558>>>>>>>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
81558>>>>>>>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
81559>>>>>>>>>
81559>>>>>>>>>        Move False to Err
81560>>>>>>>>>
81560>>>>>>>>>        If (hTable > 0) Begin
81562>>>>>>>>>            Structure_Start hTable
81563>>>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81566>>>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81569>>>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
81571>>>>>>>>>        End
81571>>>>>>>>>>
81571>>>>>>>>>        Else Begin
81572>>>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81575>>>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81578>>>>>>>>>        End
81578>>>>>>>>>>
81578>>>>>>>>>        Function_Return (Err = False)
81579>>>>>>>>>    End_Function
81580>>>>>>>>>
81580>>>>>>>>>    // Subfunction to the ApiTableUpdate function (et al)
81580>>>>>>>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
81582>>>>>>>>>        Handle hTable
81582>>>>>>>>>        String sConnectionID sRootName sLogicalName sDisplayName
81582>>>>>>>>>        Boolean bTableExists bSameTableNames bANSI bOK
81582>>>>>>>>>
81582>>>>>>>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
81583>>>>>>>>>        If (bSameTableNames = True) Begin
81585>>>>>>>>>            Function_Return True
81586>>>>>>>>>        End
81586>>>>>>>>>>
81586>>>>>>>>>
81586>>>>>>>>>        Move True to bOK
81587>>>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
81588>>>>>>>>>        Set Private.phCurrentTable              to hTable
81589>>>>>>>>>        
81589>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME         of hTable to sRootName
81592>>>>>>>>>        If (sRootName <> APITableNameInfoFrom.sRootName) Begin
81594>>>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to APITableNameInfoFrom.sRootName
81597>>>>>>>>>        End
81597>>>>>>>>>>
81597>>>>>>>>>        
81597>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME      of hTable to sLogicalName
81600>>>>>>>>>        If (sLogicalName <> APITableNameInfoFrom.sLogicalName) Begin
81602>>>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to APITableNameInfoFrom.sLogicalName
81605>>>>>>>>>        End
81605>>>>>>>>>>
81605>>>>>>>>>        
81605>>>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME      of hTable to sDisplayName
81608>>>>>>>>>        If (sDisplayName <> APITableNameInfoFrom.sDisplayName) Begin
81610>>>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to APITableNameInfoFrom.sDisplayName
81613>>>>>>>>>        End
81613>>>>>>>>>>
81613>>>>>>>>>
81613>>>>>>>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
81615>>>>>>>>>            Get psConnectionID to sConnectionID
81616>>>>>>>>>            Get _UtilTableExists hTable to bTableExists
81617>>>>>>>>>            If (bTableExists = True) Begin
81619>>>>>>>>>                Get _SqlUtilUpdateIntFile hTable to bOK
81620>>>>>>>>>            End
81620>>>>>>>>>>
81620>>>>>>>>>            Else Begin
81621>>>>>>>>>                Get pbToANSI to bANSI
81622>>>>>>>>>                Get _SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
81623>>>>>>>>>            End
81623>>>>>>>>>>
81623>>>>>>>>>        End
81623>>>>>>>>>>
81623>>>>>>>>>
81623>>>>>>>>>        Function_Return bOK
81624>>>>>>>>>    End_Function
81625>>>>>>>>>
81625>>>>>>>>>    // The table must already exist in the filelist for this function to work.
81625>>>>>>>>>    // It creates an .int file in the first Data folder of the psDataPath property. 
81625>>>>>>>>>    // It is important that the hTable can be opened.
81625>>>>>>>>>    Function _SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
81627>>>>>>>>>        Boolean bOK bExists bUseConnectionID 
81627>>>>>>>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString hTableName sSchemaName sANSI_OEM sNoDriverRootName
81627>>>>>>>>>        String[] asIndexArray
81628>>>>>>>>>        Integer iCount iCh iSize iPos
81628>>>>>>>>>
81628>>>>>>>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
81629>>>>>>>>>        Get psConnectionString to sConnectionString
81630>>>>>>>>>
81630>>>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
81631>>>>>>>>>        If (bANSI = False) Begin
81633>>>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
81634>>>>>>>>>        End
81634>>>>>>>>>>
81634>>>>>>>>>
81634>>>>>>>>>        Get psDataPathFirstPart to sDataPath
81635>>>>>>>>>        Get vFolderExists sDataPath to bOK
81636>>>>>>>>>        If (bOK = False) Begin
81638>>>>>>>>>            Error DFERR_PROGRAM "Function _SqlUtilCreateIntFile; psDataPath not found!"
81639>>>>>>>>>>
81639>>>>>>>>>            Function_Return False
81640>>>>>>>>>        End
81640>>>>>>>>>>
81640>>>>>>>>>        Get vFolderFormat sDataPath to sDataPath
81641>>>>>>>>>
81641>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName 
81644>>>>>>>>>        Move (Pos(":", sRootName)) to iPos
81645>>>>>>>>>        If (iPos <> 0) Begin
81647>>>>>>>>>            Move (Mid(sRootName, Length(sRootName), iPos +1)) to sNoDriverRootName
81648>>>>>>>>>        End
81648>>>>>>>>>>
81648>>>>>>>>>        Else Begin
81649>>>>>>>>>            Move sRootName to sNoDriverRootName
81650>>>>>>>>>        End
81650>>>>>>>>>>
81650>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
81653>>>>>>>>>        Get _TableNameOnly sRootName to hTableName
81654>>>>>>>>>        Move sLogicalName  to sPhysicalFileName
81655>>>>>>>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
81656>>>>>>>>>
81656>>>>>>>>>        Get psSchema hTable to sSchemaName
81657>>>>>>>>>        If (sSchemaName = "") Begin
81659>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
81660>>>>>>>>>        End
81660>>>>>>>>>>
81660>>>>>>>>>
81660>>>>>>>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
81660>>>>>>>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
81661>>>>>>>>>        If (bExists = True) Begin
81663>>>>>>>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
81664>>>>>>>>>        End
81664>>>>>>>>>>
81664>>>>>>>>>
81664>>>>>>>>>        Get _UtilDeleteCacheFile sNoDriverRootName to bOK
81665>>>>>>>>>        Get _SqlUtilEnumerateIndexes sNoDriverRootName sDriverID to asIndexArray
81666>>>>>>>>>
81666>>>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
81667>>>>>>>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
81672>>>>>>>>>            If (bUseConnectionID = True) Begin
81674>>>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
81681>>>>>>>>>            End
81681>>>>>>>>>>
81681>>>>>>>>>            Else Begin
81682>>>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
81689>>>>>>>>>            End
81689>>>>>>>>>>
81689>>>>>>>>>            Writeln channel iCh CS_DATABASE_NAME          " " hTableName
81694>>>>>>>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
81699>>>>>>>>>            // There seems to be a new order how these are set from DF19.
81699>>>>>>>>>            If (bSysFile = True) Begin
81701>>>>>>>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
81706>>>>>>>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
81711>>>>>>>>>            End
81711>>>>>>>>>>
81711>>>>>>>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
81716>>>>>>>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
81721>>>>>>>>>
81721>>>>>>>>>            If (bSysFile = False) Begin
81723>>>>>>>>>                Move (SizeOfArray(asIndexArray)) to iSize
81724>>>>>>>>>                Move (SortArray(asIndexArray)) to asIndexArray
81725>>>>>>>>>                If (iSize > 0) Begin
81727>>>>>>>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
81730>>>>>>>>>                    Writeln channel iCh // Just an empty line
81732>>>>>>>>>                End
81732>>>>>>>>>>
81732>>>>>>>>>                Decrement iSize
81733>>>>>>>>>                for iCount from 0 to iSize
81739>>>>>>>>>>
81739>>>>>>>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
81742>>>>>>>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(asIndexArray[iCount]))
81745>>>>>>>>>                    Writeln channel iCh
81747>>>>>>>>>                Loop
81748>>>>>>>>>>
81748>>>>>>>>>            End
81748>>>>>>>>>>
81748>>>>>>>>>        Send Seq_Close_Channel iCh 
81749>>>>>>>>>        
81749>>>>>>>>>        Open hTable
81751>>>>>>>>>        Structure_Start hTable sDriverID
81752>>>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_FORCE
81754>>>>>>>>>
81754>>>>>>>>>        // Wait a sec for Windows to finish writing the file:
81754>>>>>>>>>//        Sleep 1
81754>>>>>>>>>
81754>>>>>>>>>        Function_Return (bOK = True)
81755>>>>>>>>>    End_Function 
81756>>>>>>>>>    
81756>>>>>>>>>    // Simplier version of the _SqlUtilCreateIntFile. It can be used if there is something wrong with the .int file and it needs
81756>>>>>>>>>    // to be refreshed by the driver. 
81756>>>>>>>>>    Function _SqlUtilRefreshIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean        
81758>>>>>>>>>        String sOrgFormat sNewFormat
81758>>>>>>>>>        
81758>>>>>>>>>        Move False to Err
81759>>>>>>>>>        Open hTable
81761>>>>>>>>>        If (Err = True) Begin
81763>>>>>>>>>            Function_Return False
81764>>>>>>>>>        End
81764>>>>>>>>>>
81764>>>>>>>>>        
81764>>>>>>>>>        Structure_Start hTable
81765>>>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
81767>>>>>>>>>    End_Function
81768>>>>>>>>>
81768>>>>>>>>>    Function _UtilDeleteCacheFile String sTableName Returns Boolean
81770>>>>>>>>>        String sDataPath sDriverID
81770>>>>>>>>>        Boolean bOK
81770>>>>>>>>>        Integer iPos
81770>>>>>>>>>
81770>>>>>>>>>        If (sTableName contains ".") Begin
81772>>>>>>>>>            Move (Pos(".", sTableName)) to iPos
81773>>>>>>>>>            Move (Mid(sTableName, Length(sTableName), (iPos +1))) to sTableName
81774>>>>>>>>>        End
81774>>>>>>>>>>
81774>>>>>>>>>
81774>>>>>>>>>        Get psDriverID to sDriverID
81775>>>>>>>>>        Get psDataPathFirstPart to sDataPath
81776>>>>>>>>>        // First delete the cache file:
81776>>>>>>>>>        Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
81777>>>>>>>>>
81777>>>>>>>>>        Function_Return bOK
81778>>>>>>>>>    End_Function
81779>>>>>>>>>
81779>>>>>>>>>    // Collects all tables from the SQL Database backend and sets the pasSQLTables property.
81779>>>>>>>>>    Procedure UtilFillSQLTables
81781>>>>>>>>>        String[] asSQLTables
81782>>>>>>>>>        String sDataBase
81782>>>>>>>>>        Integer iSize iCount
81782>>>>>>>>>
81782>>>>>>>>>        Get psDatabase to sDataBase
81783>>>>>>>>>        Get _SqlUtilEnumerateTables MSSQLDRV_ID sDataBase "" to asSQLTables
81784>>>>>>>>>        Set pasSQLDataTables to asSQLTables
81785>>>>>>>>>    End_Procedure 
81786>>>>>>>>>    
81786>>>>>>>>>    // This collects *all* filelist entries and sets the pFileListArray struct property.
81786>>>>>>>>>    Procedure UtilFillFileListStruct
81788>>>>>>>>>        tFilelist[] Tables
81788>>>>>>>>>        tFilelist[] Tables
81789>>>>>>>>>        String sRootName sLogicalName sDisplayName sDriver sNoDriverRootname
81789>>>>>>>>>        Handle hTable
81789>>>>>>>>>        Integer iItem iCount
81789>>>>>>>>>        Boolean bIsSystem bIsAlias bOpened
81789>>>>>>>>>        
81789>>>>>>>>>        Move 0 to iItem
81790>>>>>>>>>        Move 0 to hTable 
81791>>>>>>>>>        Repeat
81791>>>>>>>>>>
81791>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81794>>>>>>>>>            // 0 = no more table in Filelist.cfg, 50 = Flexerrs.
81794>>>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin  
81796>>>>>>>>>                Move False to Err
81797>>>>>>>>>                Move False to bIsSystem
81798>>>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
81801>>>>>>>>>                Get _DriverIDFromRootName sRootName to sDriver
81802>>>>>>>>>                Set Message_Text of ghoStatusPanel to ("Reading table" * String(hTable) * "RootName =" * sRootName)
81803>>>>>>>>>                Send DoAdvance of ghoProgressBar
81804>>>>>>>>>                Send Ignore_All of Error_Object_Id
81805>>>>>>>>>                Open hTable
81807>>>>>>>>>                Get_Attribute DF_FILE_OPENED         of hTable to bOpened
81810>>>>>>>>>                Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bIsSystem
81813>>>>>>>>>                Send Trap_All of Error_Object_Id
81814>>>>>>>>>                Close hTable
81815>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
81818>>>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
81821>>>>>>>>>                Get _TableNameOnly sRootName to sNoDriverRootname
81822>>>>>>>>>                Move hTable              to Tables[iItem].hTable
81823>>>>>>>>>                Move sRootName           to Tables[iItem].sRootName
81824>>>>>>>>>                Move sLogicalName        to Tables[iItem].sLogicalName
81825>>>>>>>>>                Move sDisplayName        to Tables[iItem].sDisplayName
81826>>>>>>>>>                Move sNoDriverRootname   to Tables[iItem].sNoDriverRootname
81827>>>>>>>>>                Move sDriver             to Tables[iItem].sDriver 
81828>>>>>>>>>                Move bIsSystem           to Tables[iItem].bIsSystemFile
81829>>>>>>>>>                Move (bOpened = False)   to Tables[iItem].bErrorOpening
81830>>>>>>>>>                Get _IsAliasTable hTable to Tables[iItem].bIsAlias 
81831>>>>>>>>>                Move False to Err
81832>>>>>>>>>                Increment iItem
81833>>>>>>>>>            End
81833>>>>>>>>>>
81833>>>>>>>>>        Until (hTable = 0)
81835>>>>>>>>>        
81835>>>>>>>>>        Set Message_Text of ghoStatusPanel to ""
81836>>>>>>>>>        Set pFileListArray to Tables
81837>>>>>>>>>    End_Procedure   
81838>>>>>>>>>    
81838>>>>>>>>>    // Special array search function for the tFilelistLogicalName struct.
81838>>>>>>>>>    // Used by e.g. UtilAliasToMasterTableHandle
81838>>>>>>>>>    Function CompareFileListTable tFilelistLogicalName FileListTable1 tFilelistLogicalName FileListTable2 Returns Integer
81840>>>>>>>>>        If (Lowercase(FileListTable1.sLogicalName) < Lowercase(FileListTable2.sLogicalName)) ;            Function_Return (LT)
81843>>>>>>>>>        If (Lowercase(FileListTable1.sLogicalName) > Lowercase(FileListTable2.sLogicalName)) ;            Function_Return (GT)
81846>>>>>>>>>
81846>>>>>>>>>        If (Lowercase(FileListTable1.sNoDriverRootname) < Lowercase(FileListTable2.sNoDriverRootname)) ;            Function_Return (LT)
81849>>>>>>>>>        If (Lowercase(FileListTable1.sNoDriverRootname) > Lowercase(FileListTable2.sNoDriverRootname)) ;            Function_Return (GT)
81852>>>>>>>>>            
81852>>>>>>>>>        Function_Return (EQ)
81853>>>>>>>>>    End_Function
81854>>>>>>>>>
81854>>>>>>>>>    // Finds the corresponding Master table for the passed Alias handle
81854>>>>>>>>>    Function UtilAliasToMasterTableHandle Handle hTable Returns Handle
81856>>>>>>>>>        Handle hMasterTable
81856>>>>>>>>>        String sDriver sRootNameAlias sNoDriverRootnameAlias
81856>>>>>>>>>        Boolean bIsAlias bFound bIsIntTable
81856>>>>>>>>>        Integer iSize iCount iItem 
81856>>>>>>>>>        tFilelistLogicalName[] FilelistLogicalTables
81856>>>>>>>>>        tFilelistLogicalName[] FilelistLogicalTables
81857>>>>>>>>>        tFilelistLogicalName FileListTable
81857>>>>>>>>>        tFilelistLogicalName FileListTable
81857>>>>>>>>>        
81857>>>>>>>>>        Get _IsAliasTable hTable to bIsAlias
81858>>>>>>>>>        If (bIsAlias = False) Begin
81860>>>>>>>>>            Function_Return 0
81861>>>>>>>>>        End
81861>>>>>>>>>>
81861>>>>>>>>>        
81861>>>>>>>>>        Move 0 to hMasterTable
81862>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameAlias 
81865>>>>>>>>>        Get _TableNameOnly sRootNameAlias to sNoDriverRootnameAlias
81866>>>>>>>>>        Get _IsIntEntry hTable to bIsIntTable
81867>>>>>>>>>        Get pFilelistLogicalTables  to FilelistLogicalTables
81868>>>>>>>>>        Move sNoDriverRootnameAlias to FileListTable.sLogicalName
81869>>>>>>>>>        Move sNoDriverRootnameAlias to FileListTable.sNoDriverRootname
81870>>>>>>>>>        Move (SearchArray(FileListTable, FilelistLogicalTables, Self, (RefFunc(CompareFileListTable)))) to iItem
81871>>>>>>>>>        If (iItem = -1) Begin
81873>>>>>>>>>            Function_Return 0
81874>>>>>>>>>        End
81874>>>>>>>>>>
81874>>>>>>>>>        Move (Lowercase(sNoDriverRootnameAlias) = Lowercase(FilelistLogicalTables[iItem].sNoDriverRootname) and Lowercase(FilelistLogicalTables[iItem].sNoDriverRootname) = Lowercase(FilelistLogicalTables[iItem].sLogicalName)) to bFound
81875>>>>>>>>>        If (bFound = True) Begin
81877>>>>>>>>>            Move FilelistLogicalTables[iItem].hTable to hMasterTable
81878>>>>>>>>>            Function_Return hMasterTable
81879>>>>>>>>>        End
81879>>>>>>>>>>
81879>>>>>>>>>        
81879>>>>>>>>>        Function_Return hMasterTable
81880>>>>>>>>>    End_Function
81881>>>>>>>>>     
81881>>>>>>>>>    Function pFilelistLogicalTables Returns tFilelistLogicalName
81883>>>>>>>>>        tFilelistLogicalName[] FilelistLogicalTables
81883>>>>>>>>>        tFilelistLogicalName[] FilelistLogicalTables
81884>>>>>>>>>        tFilelist[] FileListTables
81884>>>>>>>>>        tFilelist[] FileListTables
81885>>>>>>>>>        Integer iSize iCount
81885>>>>>>>>>        
81885>>>>>>>>>        Get pFileListArray to FileListTables
81886>>>>>>>>>        Move (SizeOfArray(FileListTables)) to iSize
81887>>>>>>>>>        Decrement iSize
81888>>>>>>>>>        for iCount from 0 to iSize
81894>>>>>>>>>>
81894>>>>>>>>>            Move FileListTables[iCount].bErrorOpening       to FilelistLogicalTables[iCount].bErrorOpening    
81895>>>>>>>>>            Move FileListTables[iCount].bIsAlias            to FilelistLogicalTables[iCount].bIsAlias
81896>>>>>>>>>            Move FileListTables[iCount].bIsSystemFile       to FilelistLogicalTables[iCount].bIsSystemFile
81897>>>>>>>>>            Move FileListTables[iCount].hTable              to FilelistLogicalTables[iCount].hTable
81898>>>>>>>>>            Move FileListTables[iCount].sDisplayName        to FilelistLogicalTables[iCount].sDisplayName
81899>>>>>>>>>            Move FileListTables[iCount].sDriver             to FilelistLogicalTables[iCount].sDriver
81900>>>>>>>>>            Move FileListTables[iCount].sLogicalName        to FilelistLogicalTables[iCount].sLogicalName
81901>>>>>>>>>            Move FileListTables[iCount].sNoDriverRootname   to FilelistLogicalTables[iCount].sNoDriverRootname
81902>>>>>>>>>            Move FileListTables[iCount].sRootName           to FilelistLogicalTables[iCount].sRootName
81903>>>>>>>>>        Loop
81904>>>>>>>>>>
81904>>>>>>>>>        Move (SortArray(FilelistLogicalTables)) to FilelistLogicalTables
81905>>>>>>>>>        Function_Return FilelistLogicalTables
81906>>>>>>>>>    End_Function 
81907>>>>>>>>>    
81907>>>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
81907>>>>>>>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
81907>>>>>>>>>    // if it is an SQL table
81907>>>>>>>>>    Function _UtilTableExists Handle hTable Returns Boolean
81909>>>>>>>>>        Boolean bExists bIsSQLTable
81909>>>>>>>>>        String sDataPath sRootName
81909>>>>>>>>>
81909>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
81910>>>>>>>>>        If (bExists = False) Begin
81912>>>>>>>>>            Function_Return False
81913>>>>>>>>>        End
81913>>>>>>>>>>
81913>>>>>>>>>
81913>>>>>>>>>        Move False to bIsSQLTable
81914>>>>>>>>>        If (hTable > 0) Begin
81916>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81919>>>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
81920>>>>>>>>>        End
81920>>>>>>>>>>
81920>>>>>>>>>        If (bIsSQLTable = True) Begin
81922>>>>>>>>>            Get _UtilTableIsSql hTable to bExists
81923>>>>>>>>>            Function_Return bExists
81924>>>>>>>>>        End
81924>>>>>>>>>>
81924>>>>>>>>>        Else Begin
81925>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
81926>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
81927>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
81928>>>>>>>>>        End
81928>>>>>>>>>>
81928>>>>>>>>>
81928>>>>>>>>>        Function_Return bExists
81929>>>>>>>>>    End_Function
81930>>>>>>>>>
81930>>>>>>>>>    // Note: This variant uses the pasSQLDataTables property!
81930>>>>>>>>>    //       Thus, that property needs to have been initialized before
81930>>>>>>>>>    //       calling.
81930>>>>>>>>>    // It checks that the SQL table exists on the SQL end, *or*
81930>>>>>>>>>    // if embedded database, that the .dat file exists on disk.
81930>>>>>>>>>    Function _UtilTableExists_Ex Handle hTable Returns Boolean
81932>>>>>>>>>        Boolean bExists bIsSQLTable
81932>>>>>>>>>        String sDataPath sRootName
81932>>>>>>>>>
81932>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
81933>>>>>>>>>        If (bExists = False) Begin
81935>>>>>>>>>            Function_Return False
81936>>>>>>>>>        End
81936>>>>>>>>>>
81936>>>>>>>>>
81936>>>>>>>>>        Move False to bIsSQLTable
81937>>>>>>>>>        If (hTable > 0) Begin
81939>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81942>>>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
81943>>>>>>>>>        End
81943>>>>>>>>>>
81943>>>>>>>>>        If (bIsSQLTable = True) Begin
81945>>>>>>>>>            Get _UtilTableIsSql_Ex hTable to bExists
81946>>>>>>>>>            Function_Return bExists
81947>>>>>>>>>        End
81947>>>>>>>>>>
81947>>>>>>>>>        Else Begin
81948>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
81949>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
81950>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
81951>>>>>>>>>        End
81951>>>>>>>>>>
81951>>>>>>>>>
81951>>>>>>>>>        Function_Return bExists
81952>>>>>>>>>    End_Function
81953>>>>>>>>>
81953>>>>>>>>>    // Pass a table handle
81953>>>>>>>>>    // Returns True if the table exists in filelist.cfg.
81953>>>>>>>>>    Function _UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
81955>>>>>>>>>        Handle hTable
81955>>>>>>>>>        Boolean bFound
81955>>>>>>>>>
81955>>>>>>>>>        Move False to bFound
81956>>>>>>>>>        Move 0 to hTable
81957>>>>>>>>>        Repeat
81957>>>>>>>>>>
81957>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81960>>>>>>>>>            If (hTable > 0) Begin
81962>>>>>>>>>                If (hTable = hCheckTable) Begin
81964>>>>>>>>>                    Move True to bFound
81965>>>>>>>>>                End
81965>>>>>>>>>>
81965>>>>>>>>>            End
81965>>>>>>>>>>
81965>>>>>>>>>            If (bFound = True) ;                Break
81968>>>>>>>>>        Until (hTable = 0)
81970>>>>>>>>>
81970>>>>>>>>>        Function_Return bFound
81971>>>>>>>>>    End_Function
81972>>>>>>>>>
81972>>>>>>>>>    // Returns number of tables in filelist.cfg.
81972>>>>>>>>>    Function _UtilNumberOfFileListTables Returns Boolean
81974>>>>>>>>>        Handle hTable
81974>>>>>>>>>        Integer iCount
81974>>>>>>>>>
81974>>>>>>>>>        Move 0 to iCount
81975>>>>>>>>>        Move 0 to hTable
81976>>>>>>>>>        Repeat
81976>>>>>>>>>>
81976>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81979>>>>>>>>>            If (hTable > 0) Begin
81981>>>>>>>>>                Increment iCount
81982>>>>>>>>>            End
81982>>>>>>>>>>
81982>>>>>>>>>        Until (hTable = 0)
81984>>>>>>>>>
81984>>>>>>>>>        Function_Return iCount
81985>>>>>>>>>    End_Function
81986>>>>>>>>>
81986>>>>>>>>>    // DataFlex Embedded Database Data Types:
81986>>>>>>>>>    // Helper function for _UtilEnumerateColumnTypes
81986>>>>>>>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
81988>>>>>>>>>        tColumnType[] ColumnType
81988>>>>>>>>>        tColumnType[] ColumnType
81989>>>>>>>>>        Integer i
81989>>>>>>>>>
81989>>>>>>>>>        Move DF_ASCII           to ColumnType[i].iSQLType
81990>>>>>>>>>        Move "ASCII"            to ColumnType[i].sSQLType
81991>>>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
81992>>>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
81993>>>>>>>>>        Move "254"              to ColumnType[i].sPrecision
81994>>>>>>>>>        Increment i
81995>>>>>>>>>
81995>>>>>>>>>        Move DF_BCD             to ColumnType[i].iSQLType
81996>>>>>>>>>        Move "Numeric"          to ColumnType[i].sSQLType
81997>>>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
81998>>>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
81999>>>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
82000>>>>>>>>>        Increment i
82001>>>>>>>>>
82001>>>>>>>>>        Move DF_DATE            to ColumnType[i].iSQLType
82002>>>>>>>>>        Move "Date"             to ColumnType[i].sSQLType
82003>>>>>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
82004>>>>>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
82005>>>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
82006>>>>>>>>>        Move True               to ColumnType[i].bCanEditSize
82007>>>>>>>>>        Increment i
82008>>>>>>>>>
82008>>>>>>>>>        Move DF_TEXT            to ColumnType[i].iSQLType
82009>>>>>>>>>        Move "Text"             to ColumnType[i].sSQLType
82010>>>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
82011>>>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
82012>>>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
82013>>>>>>>>>        Increment i
82014>>>>>>>>>
82014>>>>>>>>>        Move DF_BINARY          to ColumnType[i].iSQLType
82015>>>>>>>>>        Move "Binary"           to ColumnType[i].sSQLType
82016>>>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
82017>>>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
82018>>>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
82019>>>>>>>>>        Increment i
82020>>>>>>>>>
82020>>>>>>>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
82021>>>>>>>>>        Move "DateTime"         to ColumnType[i].sSQLType
82022>>>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82023>>>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
82024>>>>>>>>>        Move "23"               to ColumnType[i].sPrecision
82025>>>>>>>>>        Move True               to ColumnType[i].bCanEditSize
82026>>>>>>>>>        Increment i
82027>>>>>>>>>
82027>>>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
82028>>>>>>>>>        Move "Overlap"          to ColumnType[i].sSQLType
82029>>>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
82030>>>>>>>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
82031>>>>>>>>>        Move "0.0"              to ColumnType[i].sPrecision
82032>>>>>>>>>
82032>>>>>>>>>        Function_Return ColumnType
82033>>>>>>>>>    End_Function
82034>>>>>>>>>
82034>>>>>>>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
82036>>>>>>>>>        tColumnType[] aColumnType
82036>>>>>>>>>        tColumnType[] aColumnType
82037>>>>>>>>>        Integer i
82037>>>>>>>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DB2_DRV_DriverDef.inc)
82037>>>>>>>>>>// Generated By The Database Update Framework
82037>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.1\bin\MSSQLDRV_DriverDef.xml
82037>>>>>>>>>>// Driver COLUMN DATA TYPES
82037>>>>>>>>>>//
82037>>>>>>>>>>// Created: 2019-07-18 18:57:13.935
82037>>>>>>>>>>
82037>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82038>>>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
82039>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82040>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82041>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82042>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82043>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82044>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82045>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82046>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82047>>>>>>>>>>            Increment i
82048>>>>>>>>>>
82048>>>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
82049>>>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
82050>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82051>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82052>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82053>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82054>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82055>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82056>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82057>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82058>>>>>>>>>>            Increment i
82059>>>>>>>>>>
82059>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82060>>>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
82061>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82062>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82063>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82064>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82065>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82066>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82067>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82068>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82069>>>>>>>>>>            Increment i
82070>>>>>>>>>>
82070>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82071>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82072>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82073>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82074>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82075>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82076>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82077>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82078>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82079>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82080>>>>>>>>>>            Increment i
82081>>>>>>>>>>
82081>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82082>>>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
82083>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82084>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82085>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82086>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82087>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82088>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82089>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82090>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82091>>>>>>>>>>            Increment i
82092>>>>>>>>>>
82092>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
82093>>>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
82094>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82095>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82096>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82097>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82098>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82099>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82100>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82101>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82102>>>>>>>>>>            Increment i
82103>>>>>>>>>>
82103>>>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
82104>>>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
82105>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82106>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82107>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82108>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
82109>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82110>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82111>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82112>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82113>>>>>>>>>>            Increment i
82114>>>>>>>>>>
82114>>>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
82115>>>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
82116>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82117>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82118>>>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
82119>>>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
82120>>>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
82121>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82122>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82123>>>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
82124>>>>>>>>>>            Increment i
82125>>>>>>>>>>
82125>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82126>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82127>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82128>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82129>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82130>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82131>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82132>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82133>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82134>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82135>>>>>>>>>>            Increment i
82136>>>>>>>>>>
82136>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82137>>>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
82138>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82139>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82140>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82141>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82142>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82143>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82144>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82145>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82146>>>>>>>>>>            Increment i
82147>>>>>>>>>>
82147>>>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
82148>>>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
82149>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82150>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82151>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82152>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82153>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82154>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82155>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82156>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82157>>>>>>>>>>            Increment i
82158>>>>>>>>>>
82158>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82159>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82160>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82161>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82162>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82163>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82164>>>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
82165>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82166>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82167>>>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
82168>>>>>>>>>>            Increment i
82169>>>>>>>>>>
82169>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
82170>>>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
82171>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82172>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82173>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82174>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82175>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82176>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82177>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82178>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82179>>>>>>>>>>            Increment i
82180>>>>>>>>>>
82180>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
82181>>>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
82182>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82183>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82184>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82185>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82186>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82187>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82188>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82189>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82190>>>>>>>>>>            Increment i
82191>>>>>>>>>>
82191>>>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
82192>>>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
82193>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82194>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82195>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82196>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82197>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82198>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82199>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82200>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82201>>>>>>>>>>            Increment i
82202>>>>>>>>>>
82202>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
82203>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82204>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82205>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82206>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82207>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82208>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82209>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82210>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82211>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82212>>>>>>>>>>            Increment i
82213>>>>>>>>>>
82213>>>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
82214>>>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
82215>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82216>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82217>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82218>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82219>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82220>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82221>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82222>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82223>>>>>>>>>>            Increment i
82224>>>>>>>>>>
82224>>>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
82225>>>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
82226>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82227>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82228>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82229>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82230>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82231>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82232>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82233>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82234>>>>>>>>>>            Increment i
82235>>>>>>>>>>
82235>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
82236>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82237>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82238>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82239>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82240>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82241>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82242>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82243>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82244>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82245>>>>>>>>>>            Increment i
82246>>>>>>>>>>
82246>>>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
82247>>>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
82248>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82249>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82250>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82251>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82252>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82253>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82254>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82255>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82256>>>>>>>>>>            Increment i
82257>>>>>>>>>>
82257>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82258>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82259>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82260>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82261>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82262>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82263>>>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
82264>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82265>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82266>>>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
82267>>>>>>>>>>            Increment i
82268>>>>>>>>>>
82268>>>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
82269>>>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
82270>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82271>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82272>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82273>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82274>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82275>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82276>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82277>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82278>>>>>>>>>>            Increment i
82279>>>>>>>>>>
82279>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82280>>>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
82281>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82282>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82283>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82284>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82285>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82286>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82287>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82288>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82289>>>>>>>>>>            Increment i
82290>>>>>>>>>>
82290>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82291>>>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
82292>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82293>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82294>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82295>>>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
82296>>>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
82297>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82298>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82299>>>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
82300>>>>>>>>>>            Increment i
82301>>>>>>>>>>
82301>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82302>>>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
82303>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82304>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82305>>>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
82306>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82307>>>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
82308>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82309>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82310>>>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
82311>>>>>>>>>>            Increment i
82312>>>>>>>>>>
82312>>>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
82313>>>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
82314>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82315>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82316>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82317>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82318>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82319>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82320>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82321>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82322>>>>>>>>>>            Increment i
82323>>>>>>>>>>
82323>>>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
82324>>>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
82325>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82326>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82327>>>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
82328>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82329>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82330>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82331>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82332>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82333>>>>>>>>>>            Increment i
82334>>>>>>>>>>
82334>>>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
82335>>>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
82336>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82337>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82338>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82339>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82340>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82341>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82342>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82343>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82344>>>>>>>>>>            Increment i
82345>>>>>>>>>>
82345>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82346>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82347>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82348>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82349>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82350>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82351>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82352>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82353>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82354>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82355>>>>>>>>>>            Increment i
82356>>>>>>>>>>
82356>>>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
82357>>>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
82358>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82359>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82360>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82361>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82362>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82363>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82364>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82365>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82366>>>>>>>>>>            Increment i
82367>>>>>>>>>>
82367>>>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
82368>>>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
82369>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82370>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82371>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82372>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82373>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82374>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82375>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82376>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82377>>>>>>>>>>            Increment i
82378>>>>>>>>>>
82378>>>>>>>>>>
82378>>>>>>>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
82378>>>>>>>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
82378>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82378>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82378>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82378>>>>>>>>>//        Increment i
82378>>>>>>>>>//
82378>>>>>>>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
82378>>>>>>>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
82378>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82378>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82378>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82378>>>>>>>>>//        Increment i
82378>>>>>>>>>//
82378>>>>>>>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
82378>>>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
82378>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82378>>>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
82378>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82378>>>>>>>>>//        Increment i
82378>>>>>>>>>//
82378>>>>>>>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
82378>>>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
82378>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82378>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82378>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82378>>>>>>>>>//        Increment i
82378>>>>>>>>>//
82378>>>>>>>>>//        // ToDo: We need to change the sType when using this!
82378>>>>>>>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
82378>>>>>>>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
82378>>>>>>>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
82378>>>>>>>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
82378>>>>>>>>>//        Move "254"                  to ColumnType[i].sPrecision
82378>>>>>>>>>//        Increment i
82378>>>>>>>>>//
82378>>>>>>>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
82378>>>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
82378>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
82378>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82378>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82378>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82378>>>>>>>>>//        Increment i
82378>>>>>>>>>//
82378>>>>>>>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
82378>>>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
82378>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82378>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82378>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82378>>>>>>>>>//        Increment i
82378>>>>>>>>>//
82378>>>>>>>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
82378>>>>>>>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
82378>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82378>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82378>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82378>>>>>>>>>//        Increment i
82378>>>>>>>>>//
82378>>>>>>>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
82378>>>>>>>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
82378>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82378>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82378>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82378>>>>>>>>>//        Increment i
82378>>>>>>>>>//
82378>>>>>>>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
82378>>>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
82378>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82378>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82378>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82378>>>>>>>>>//        Increment i
82378>>>>>>>>>//
82378>>>>>>>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
82378>>>>>>>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
82378>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82378>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82378>>>>>>>>>//        Move "255"              to ColumnType[i].sPrecision
82378>>>>>>>>>//        Increment i
82378>>>>>>>>>//
82378>>>>>>>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
82378>>>>>>>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
82378>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82378>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82378>>>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
82378>>>>>>>>>//        Increment i
82378>>>>>>>>>//
82378>>>>>>>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
82378>>>>>>>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
82378>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82378>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82378>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82378>>>>>>>>>//        Increment i
82378>>>>>>>>>//
82378>>>>>>>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
82378>>>>>>>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
82378>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82378>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82378>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82378>>>>>>>>>//        Increment i
82378>>>>>>>>>//
82378>>>>>>>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
82378>>>>>>>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
82378>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82378>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82378>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82378>>>>>>>>>//        Increment i
82378>>>>>>>>>//
82378>>>>>>>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
82378>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
82378>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82378>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82378>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82378>>>>>>>>>//        Increment i
82378>>>>>>>>>//
82378>>>>>>>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
82378>>>>>>>>>//        Move "REAL"             to ColumnType[i].sSQLType
82378>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82378>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82378>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82378>>>>>>>>>//        Increment i
82378>>>>>>>>>//
82378>>>>>>>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
82378>>>>>>>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
82378>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82378>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82378>>>>>>>>>//        Move "5.0"              to ColumnType[i].sPrecision
82378>>>>>>>>>//        Increment i
82378>>>>>>>>>//
82378>>>>>>>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
82378>>>>>>>>>//        Move "TIME"             to ColumnType[i].sSQLType
82378>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82378>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82378>>>>>>>>>//        Move "19.0"             to ColumnType[i].sPrecision
82378>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82378>>>>>>>>>//        Increment i
82378>>>>>>>>>//
82378>>>>>>>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
82378>>>>>>>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
82378>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82378>>>>>>>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
82378>>>>>>>>>//        Move "23.6"             to ColumnType[i].sPrecision
82378>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82378>>>>>>>>>//        Increment i
82378>>>>>>>>>//
82378>>>>>>>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
82378>>>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
82378>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82378>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82378>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82378>>>>>>>>>//        Increment i
82378>>>>>>>>>//
82378>>>>>>>>>//        // ToDo: We need to change the sType when using this!
82378>>>>>>>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
82378>>>>>>>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
82378>>>>>>>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
82378>>>>>>>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
82378>>>>>>>>>//        Move "16384"                to ColumnType[i].sPrecision
82378>>>>>>>>>//        Increment i
82378>>>>>>>>>//
82378>>>>>>>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
82378>>>>>>>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
82378>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82378>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82378>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82378>>>>>>>>>//
82378>>>>>>>>>//        Move SQL_XML            to ColumnType[i].iSQLType
82378>>>>>>>>>//        Move "XML"              to ColumnType[i].sSQLType
82378>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82378>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82378>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82378>>>>>>>>>
82378>>>>>>>>>        Function_Return aColumnType
82379>>>>>>>>>    End_Function
82380>>>>>>>>>
82380>>>>>>>>>    // Microsoft SQL Server Database Data Types:
82380>>>>>>>>>    // Helper function for _UtilEnumerateColumnTypes
82380>>>>>>>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
82382>>>>>>>>>        tColumnType[] aColumnType
82382>>>>>>>>>        tColumnType[] aColumnType
82383>>>>>>>>>        Integer i
82383>>>>>>>>>
82383>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSQLDRV_DriverDef.inc)
82385>>>>>>>>>>// Generated By The Database Update Framework
82385>>>>>>>>>>// Driver XML File: C:\Program Files\DataFlex 20.0\Lib\MSSQLDRV_DriverDef.xml
82385>>>>>>>>>>// Driver COLUMN DATA TYPES
82385>>>>>>>>>>//
82385>>>>>>>>>>// Created: 2019-11-15 21:57:51.001
82385>>>>>>>>>>
82385>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82386>>>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
82387>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82388>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82389>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82390>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82391>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82392>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82393>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82394>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82395>>>>>>>>>>            Increment i
82396>>>>>>>>>>
82396>>>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
82397>>>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
82398>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82399>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82400>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82401>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82402>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82403>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82404>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82405>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82406>>>>>>>>>>            Increment i
82407>>>>>>>>>>
82407>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82408>>>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
82409>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82410>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82411>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82412>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82413>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82414>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82415>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82416>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82417>>>>>>>>>>            Increment i
82418>>>>>>>>>>
82418>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82419>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82420>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82421>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82422>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82423>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82424>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82425>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82426>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82427>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82428>>>>>>>>>>            Increment i
82429>>>>>>>>>>
82429>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82430>>>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
82431>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82432>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82433>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82434>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82435>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82436>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82437>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82438>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82439>>>>>>>>>>            Increment i
82440>>>>>>>>>>
82440>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
82441>>>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
82442>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82443>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82444>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82445>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82446>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82447>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82448>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82449>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82450>>>>>>>>>>            Increment i
82451>>>>>>>>>>
82451>>>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
82452>>>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
82453>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82454>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82455>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82456>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
82457>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82458>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82459>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82460>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82461>>>>>>>>>>            Increment i
82462>>>>>>>>>>
82462>>>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
82463>>>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
82464>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82465>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82466>>>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
82467>>>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
82468>>>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
82469>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82470>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82471>>>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
82472>>>>>>>>>>            Increment i
82473>>>>>>>>>>
82473>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82474>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82475>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82476>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82477>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82478>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82479>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82480>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82481>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82482>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82483>>>>>>>>>>            Increment i
82484>>>>>>>>>>
82484>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82485>>>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
82486>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82487>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82488>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82489>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82490>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82491>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82492>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82493>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82494>>>>>>>>>>            Increment i
82495>>>>>>>>>>
82495>>>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
82496>>>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
82497>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82498>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82499>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82500>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82501>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82502>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82503>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82504>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82505>>>>>>>>>>            Increment i
82506>>>>>>>>>>
82506>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82507>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82508>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82509>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82510>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82511>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82512>>>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
82513>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82514>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82515>>>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
82516>>>>>>>>>>            Increment i
82517>>>>>>>>>>
82517>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
82518>>>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
82519>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82520>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82521>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82522>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82523>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82524>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82525>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82526>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82527>>>>>>>>>>            Increment i
82528>>>>>>>>>>
82528>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
82529>>>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
82530>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82531>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82532>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82533>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82534>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82535>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82536>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82537>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82538>>>>>>>>>>            Increment i
82539>>>>>>>>>>
82539>>>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
82540>>>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
82541>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82542>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82543>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82544>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82545>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82546>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82547>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82548>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82549>>>>>>>>>>            Increment i
82550>>>>>>>>>>
82550>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
82551>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82552>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82553>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82554>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82555>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82556>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82557>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82558>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82559>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82560>>>>>>>>>>            Increment i
82561>>>>>>>>>>
82561>>>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
82562>>>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
82563>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82564>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82565>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82566>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82567>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82568>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82569>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82570>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82571>>>>>>>>>>            Increment i
82572>>>>>>>>>>
82572>>>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
82573>>>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
82574>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82575>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82576>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82577>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82578>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82579>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82580>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82581>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82582>>>>>>>>>>            Increment i
82583>>>>>>>>>>
82583>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
82584>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82585>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82586>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82587>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82588>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82589>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82590>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82591>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82592>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82593>>>>>>>>>>            Increment i
82594>>>>>>>>>>
82594>>>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
82595>>>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
82596>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82597>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82598>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82599>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82600>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82601>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82602>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82603>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82604>>>>>>>>>>            Increment i
82605>>>>>>>>>>
82605>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82606>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82607>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82608>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82609>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82610>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82611>>>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
82612>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82613>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82614>>>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
82615>>>>>>>>>>            Increment i
82616>>>>>>>>>>
82616>>>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
82617>>>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
82618>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82619>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82620>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82621>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82622>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82623>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82624>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82625>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82626>>>>>>>>>>            Increment i
82627>>>>>>>>>>
82627>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82628>>>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
82629>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82630>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82631>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82632>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82633>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82634>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82635>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82636>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82637>>>>>>>>>>            Increment i
82638>>>>>>>>>>
82638>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82639>>>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
82640>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82641>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82642>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82643>>>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
82644>>>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
82645>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82646>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82647>>>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
82648>>>>>>>>>>            Increment i
82649>>>>>>>>>>
82649>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82650>>>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
82651>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82652>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82653>>>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
82654>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82655>>>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
82656>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82657>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82658>>>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
82659>>>>>>>>>>            Increment i
82660>>>>>>>>>>
82660>>>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
82661>>>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
82662>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82663>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82664>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82665>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82666>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82667>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82668>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82669>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82670>>>>>>>>>>            Increment i
82671>>>>>>>>>>
82671>>>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
82672>>>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
82673>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82674>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82675>>>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
82676>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82677>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82678>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82679>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82680>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82681>>>>>>>>>>            Increment i
82682>>>>>>>>>>
82682>>>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
82683>>>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
82684>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82685>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82686>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82687>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82688>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82689>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82690>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82691>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82692>>>>>>>>>>            Increment i
82693>>>>>>>>>>
82693>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82694>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82695>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82696>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82697>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82698>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82699>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82700>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82701>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82702>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82703>>>>>>>>>>            Increment i
82704>>>>>>>>>>
82704>>>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
82705>>>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
82706>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82707>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82708>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82709>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82710>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82711>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82712>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82713>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82714>>>>>>>>>>            Increment i
82715>>>>>>>>>>
82715>>>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
82716>>>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
82717>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82718>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82719>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82720>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82721>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82722>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82723>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82724>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82725>>>>>>>>>>            Increment i
82726>>>>>>>>>>
82726>>>>>>>>>>
82726>>>>>>>>>
82726>>>>>>>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "bigint"           to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
82726>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "binary"           to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "bit"              to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
82726>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "char"             to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "date"             to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
82726>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "23.3"             to ColumnType[i].sPrecision
82726>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "datetime2"         to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "23.6"              to ColumnType[i].sPrecision
82726>>>>>>>>>//            Move True                to ColumnType[i].bCanEditSize
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "34.0"                 to ColumnType[i].sPrecision
82726>>>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "decimal"          to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "float"            to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "int"              to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "8.0"              to ColumnType[i].sPrecision
82726>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "money"            to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "nchar"            to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "ntext"            to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "numeric"          to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82726>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "real"             to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "23.0"                 to ColumnType[i].sPrecision
82726>>>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "smallint"         to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "4.0"              to ColumnType[i].sPrecision
82726>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "10.0"              to ColumnType[i].sPrecision
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "text"             to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82726>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "19.0"             to ColumnType[i].sPrecision
82726>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "tinyint"          to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "2.0"              to ColumnType[i].sPrecision
82726>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "36"               to ColumnType[i].sPrecision
82726>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "varbinary"        to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82726>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "varchar"          to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
82726>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82726>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "xml"              to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "DATE"             to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "date"             to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
82726>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "8.7"              to ColumnType[i].sPrecision
82726>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>//
82726>>>>>>>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
82726>>>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
82726>>>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
82726>>>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
82726>>>>>>>>>//            Move "23.6"             to ColumnType[i].sPrecision
82726>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82726>>>>>>>>>//            Increment i
82726>>>>>>>>>
82726>>>>>>>>>        End
82726>>>>>>>>>>
82726>>>>>>>>>
82726>>>>>>>>>        Function_Return aColumnType
82727>>>>>>>>>    End_Function
82728>>>>>>>>>
82728>>>>>>>>>    // MySQL Data Types
82728>>>>>>>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
82730>>>>>>>>>        tColumnType[] aColumnType
82730>>>>>>>>>        tColumnType[] aColumnType
82731>>>>>>>>>        Integer i
82731>>>>>>>>>
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdsmysql_DriverDef.inc)
82731>>>>>>>>>>// Generated By The Database Update Framework
82731>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
82731>>>>>>>>>>// Driver COLUMN DATA TYPES
82731>>>>>>>>>>//
82731>>>>>>>>>>// Created: 2018-03-14 23:46:49.593
82731>>>>>>>>>>
82731>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82732>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
82733>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82734>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82735>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82736>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82737>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82738>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82739>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82740>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82741>>>>>>>>>>            Increment i
82742>>>>>>>>>>
82742>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82743>>>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
82744>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82745>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82746>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82747>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82748>>>>>>>>>>            Move 64                                      to aColumnType[i].nMaxSize
82749>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82750>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82751>>>>>>>>>>            Move 64                                      to aColumnType[i].sPrecision
82752>>>>>>>>>>            Increment i
82753>>>>>>>>>>
82753>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
82754>>>>>>>>>>            Move 252                                     to aColumnType[i].iSQLType
82755>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82756>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82757>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82758>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82759>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82760>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82761>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82762>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82763>>>>>>>>>>            Increment i
82764>>>>>>>>>>
82764>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82765>>>>>>>>>>            Move 254                                     to aColumnType[i].iSQLType
82766>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82767>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82768>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82769>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82770>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82771>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82772>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82773>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82774>>>>>>>>>>            Increment i
82775>>>>>>>>>>
82775>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82776>>>>>>>>>>            Move 10                                      to aColumnType[i].iSQLType
82777>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82778>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82779>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82780>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82781>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82782>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82783>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82784>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82785>>>>>>>>>>            Increment i
82786>>>>>>>>>>
82786>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
82787>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82788>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82789>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82790>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82791>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82792>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82793>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82794>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82795>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82796>>>>>>>>>>            Increment i
82797>>>>>>>>>>
82797>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82798>>>>>>>>>>            Move 246                                     to aColumnType[i].iSQLType
82799>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82800>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82801>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82802>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82803>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82804>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82805>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82806>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82807>>>>>>>>>>            Increment i
82808>>>>>>>>>>
82808>>>>>>>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
82809>>>>>>>>>>            Move 0                                       to aColumnType[i].iSQLType
82810>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82811>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82812>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82813>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82814>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82815>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82816>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82817>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82818>>>>>>>>>>            Increment i
82819>>>>>>>>>>
82819>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
82820>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82821>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82822>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82823>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82824>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82825>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82826>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82827>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82828>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82829>>>>>>>>>>            Increment i
82830>>>>>>>>>>
82830>>>>>>>>>>            Move "enum"                                  to aColumnType[i].sSQLType
82831>>>>>>>>>>            Move 247                                     to aColumnType[i].iSQLType
82832>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82833>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82834>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82835>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82836>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82837>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82838>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82839>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82840>>>>>>>>>>            Increment i
82841>>>>>>>>>>
82841>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82842>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82843>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82844>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82845>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82846>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82847>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82848>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82849>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82850>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82851>>>>>>>>>>            Increment i
82852>>>>>>>>>>
82852>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82853>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82854>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82855>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82856>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82857>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82858>>>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
82859>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82860>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82861>>>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
82862>>>>>>>>>>            Increment i
82863>>>>>>>>>>
82863>>>>>>>>>>            Move "longblob"                              to aColumnType[i].sSQLType
82864>>>>>>>>>>            Move 251                                     to aColumnType[i].iSQLType
82865>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82866>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82867>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82868>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82869>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82870>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82871>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82872>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82873>>>>>>>>>>            Increment i
82874>>>>>>>>>>
82874>>>>>>>>>>            Move "longtext"                              to aColumnType[i].sSQLType
82875>>>>>>>>>>            Move -251                                    to aColumnType[i].iSQLType
82876>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82877>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82878>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82879>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82880>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82881>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82882>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82883>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82884>>>>>>>>>>            Increment i
82885>>>>>>>>>>
82885>>>>>>>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
82886>>>>>>>>>>            Move 250                                     to aColumnType[i].iSQLType
82887>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82888>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82889>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82890>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82891>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82892>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82893>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82894>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82895>>>>>>>>>>            Increment i
82896>>>>>>>>>>
82896>>>>>>>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
82897>>>>>>>>>>            Move 9                                       to aColumnType[i].iSQLType
82898>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82899>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82900>>>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
82901>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82902>>>>>>>>>>            Move 9                                       to aColumnType[i].nMaxSize
82903>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82904>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82905>>>>>>>>>>            Move 9                                       to aColumnType[i].sPrecision
82906>>>>>>>>>>            Increment i
82907>>>>>>>>>>
82907>>>>>>>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
82908>>>>>>>>>>            Move -250                                    to aColumnType[i].iSQLType
82909>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82910>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82911>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82912>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82913>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82914>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82915>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82916>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82917>>>>>>>>>>            Increment i
82918>>>>>>>>>>
82918>>>>>>>>>>            Move "set"                                   to aColumnType[i].sSQLType
82919>>>>>>>>>>            Move 248                                     to aColumnType[i].iSQLType
82920>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82921>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82922>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82923>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82924>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82925>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82926>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82927>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82928>>>>>>>>>>            Increment i
82929>>>>>>>>>>
82929>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82930>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82931>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82932>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82933>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82934>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82935>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
82936>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82937>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82938>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82939>>>>>>>>>>            Increment i
82940>>>>>>>>>>
82940>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82941>>>>>>>>>>            Move -252                                    to aColumnType[i].iSQLType
82942>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82943>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82944>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82945>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82946>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82947>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82948>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82949>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82950>>>>>>>>>>            Increment i
82951>>>>>>>>>>
82951>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82952>>>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
82953>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82954>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82955>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82956>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82957>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82958>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82959>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82960>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82961>>>>>>>>>>            Increment i
82962>>>>>>>>>>
82962>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
82963>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82964>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82965>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82966>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82967>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82968>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82969>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82970>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82971>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82972>>>>>>>>>>            Increment i
82973>>>>>>>>>>
82973>>>>>>>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
82974>>>>>>>>>>            Move 249                                     to aColumnType[i].iSQLType
82975>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82976>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82977>>>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
82978>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82979>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82980>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82981>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82982>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82983>>>>>>>>>>            Increment i
82984>>>>>>>>>>
82984>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82985>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82986>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82987>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82988>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82989>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82990>>>>>>>>>>            Move 4                                       to aColumnType[i].nMaxSize
82991>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82992>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82993>>>>>>>>>>            Move 4                                       to aColumnType[i].sPrecision
82994>>>>>>>>>>            Increment i
82995>>>>>>>>>>
82995>>>>>>>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
82996>>>>>>>>>>            Move -249                                    to aColumnType[i].iSQLType
82997>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82998>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82999>>>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
83000>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83001>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
83002>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83003>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83004>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
83005>>>>>>>>>>            Increment i
83006>>>>>>>>>>
83006>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
83007>>>>>>>>>>            Move 253                                     to aColumnType[i].iSQLType
83008>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83009>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83010>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
83011>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83012>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83013>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83014>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83015>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83016>>>>>>>>>>            Increment i
83017>>>>>>>>>>
83017>>>>>>>>>>            Move "year"                                  to aColumnType[i].sSQLType
83018>>>>>>>>>>            Move 13                                      to aColumnType[i].iSQLType
83019>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83020>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83021>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
83022>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83023>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83024>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83025>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83026>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83027>>>>>>>>>>            Increment i
83028>>>>>>>>>>
83028>>>>>>>>>>
83028>>>>>>>>>
83028>>>>>>>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
83028>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "blob"             to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83028>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "datetime"         to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
83028>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "enum"             to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "float"            to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "int"              to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "longblob"         to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "longtext"         to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "mediumint"        to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "set"              to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "10.0"             to ColumnType[i].sPrecision
83028>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
83028>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "tinyint"          to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "tinytext"         to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>//
83028>>>>>>>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
83028>>>>>>>>>//        Move "year"             to ColumnType[i].sSQLType
83028>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83028>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
83028>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
83028>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83028>>>>>>>>>//        Increment i
83028>>>>>>>>>
83028>>>>>>>>>        Function_Return aColumnType
83029>>>>>>>>>    End_Function
83030>>>>>>>>>
83030>>>>>>>>>    // Oracle Data Types
83030>>>>>>>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
83032>>>>>>>>>        tColumnType[] aColumnType
83032>>>>>>>>>        tColumnType[] aColumnType
83033>>>>>>>>>        Integer i
83033>>>>>>>>>
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ora_drv_DriverDef.inc)
83033>>>>>>>>>>// Generated By The Database Update Framework
83033>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
83033>>>>>>>>>>// Driver COLUMN DATA TYPES
83033>>>>>>>>>>//
83033>>>>>>>>>>// Created: 2018-03-14 23:47:34.82
83033>>>>>>>>>>
83033>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
83034>>>>>>>>>>            Move 113                                     to aColumnType[i].iSQLType
83035>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83036>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83037>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83038>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83039>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83040>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83041>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83042>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83043>>>>>>>>>>            Increment i
83044>>>>>>>>>>
83044>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
83045>>>>>>>>>>            Move 96                                      to aColumnType[i].iSQLType
83046>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83047>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83048>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83049>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83050>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
83051>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83052>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83053>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
83054>>>>>>>>>>            Increment i
83055>>>>>>>>>>
83055>>>>>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
83056>>>>>>>>>>            Move 112                                     to aColumnType[i].iSQLType
83057>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83058>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83059>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83060>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83061>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83062>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
83063>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
83064>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83065>>>>>>>>>>            Increment i
83066>>>>>>>>>>
83066>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
83067>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
83068>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83069>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83070>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83071>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
83072>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
83073>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
83074>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
83075>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83076>>>>>>>>>>            Increment i
83077>>>>>>>>>>
83077>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
83078>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
83079>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83080>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83081>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83082>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83083>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83084>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83085>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83086>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83087>>>>>>>>>>            Increment i
83088>>>>>>>>>>
83088>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
83089>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
83090>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83091>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83092>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83093>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83094>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83095>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83096>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83097>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83098>>>>>>>>>>            Increment i
83099>>>>>>>>>>
83099>>>>>>>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
83100>>>>>>>>>>            Move 190                                     to aColumnType[i].iSQLType
83101>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83102>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83103>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83104>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83105>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83106>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83107>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83108>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83109>>>>>>>>>>            Increment i
83110>>>>>>>>>>
83110>>>>>>>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
83111>>>>>>>>>>            Move 189                                     to aColumnType[i].iSQLType
83112>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83113>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83114>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83115>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83116>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83117>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83118>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83119>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83120>>>>>>>>>>            Increment i
83121>>>>>>>>>>
83121>>>>>>>>>>            Move "long"                                  to aColumnType[i].sSQLType
83122>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
83123>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83124>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83125>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83126>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83127>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83128>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83129>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83130>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83131>>>>>>>>>>            Increment i
83132>>>>>>>>>>
83132>>>>>>>>>>            Move "longraw"                               to aColumnType[i].sSQLType
83133>>>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
83134>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83135>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83136>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83137>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83138>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83139>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83140>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83141>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83142>>>>>>>>>>            Increment i
83143>>>>>>>>>>
83143>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
83144>>>>>>>>>>            Move 286                                     to aColumnType[i].iSQLType
83145>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83146>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83147>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83148>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83149>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
83150>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83151>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83152>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
83153>>>>>>>>>>            Increment i
83154>>>>>>>>>>
83154>>>>>>>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
83155>>>>>>>>>>            Move 288                                     to aColumnType[i].iSQLType
83156>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83157>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83158>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83159>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83160>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83161>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
83162>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
83163>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83164>>>>>>>>>>            Increment i
83165>>>>>>>>>>
83165>>>>>>>>>>            Move "number"                                to aColumnType[i].sSQLType
83166>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
83167>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83168>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83169>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83170>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83171>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83172>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83173>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83174>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83175>>>>>>>>>>            Increment i
83176>>>>>>>>>>
83176>>>>>>>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
83177>>>>>>>>>>            Move 287                                     to aColumnType[i].iSQLType
83178>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83179>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83180>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83181>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83182>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
83183>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83184>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83185>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
83186>>>>>>>>>>            Increment i
83187>>>>>>>>>>
83187>>>>>>>>>>            Move "raw"                                   to aColumnType[i].sSQLType
83188>>>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
83189>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83190>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83191>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83192>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83193>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
83194>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83195>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83196>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
83197>>>>>>>>>>            Increment i
83198>>>>>>>>>>
83198>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
83199>>>>>>>>>>            Move 187                                     to aColumnType[i].iSQLType
83200>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83201>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83202>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83203>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83204>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83205>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83206>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83207>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83208>>>>>>>>>>            Increment i
83209>>>>>>>>>>
83209>>>>>>>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
83210>>>>>>>>>>            Move 232                                     to aColumnType[i].iSQLType
83211>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83212>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83213>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83214>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83215>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83216>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83217>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83218>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83219>>>>>>>>>>            Increment i
83220>>>>>>>>>>
83220>>>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
83221>>>>>>>>>>            Move 188                                     to aColumnType[i].iSQLType
83222>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83223>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83224>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83225>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83226>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83227>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83228>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83229>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83230>>>>>>>>>>            Increment i
83231>>>>>>>>>>
83231>>>>>>>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
83232>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
83233>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83234>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83235>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83236>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83237>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
83238>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83239>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83240>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
83241>>>>>>>>>>            Increment i
83242>>>>>>>>>>
83242>>>>>>>>>>
83242>>>>>>>>>
83242>>>>>>>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
83242>>>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
83242>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83242>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83242>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83242>>>>>>>>>//        Increment i
83242>>>>>>>>>//
83242>>>>>>>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
83242>>>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
83242>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83242>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83242>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83242>>>>>>>>>//        Increment i
83242>>>>>>>>>//
83242>>>>>>>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
83242>>>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
83242>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83242>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83242>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83242>>>>>>>>>//        Increment i
83242>>>>>>>>>//
83242>>>>>>>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
83242>>>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
83242>>>>>>>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
83242>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
83242>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83242>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83242>>>>>>>>>//        Increment i
83242>>>>>>>>>//
83242>>>>>>>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
83242>>>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
83242>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83242>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
83242>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83242>>>>>>>>>//        Increment i
83242>>>>>>>>>//
83242>>>>>>>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
83242>>>>>>>>>//        Move "INT"              to ColumnType[i].sSQLType
83242>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83242>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
83242>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
83242>>>>>>>>>//        Increment i
83242>>>>>>>>>//
83242>>>>>>>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
83242>>>>>>>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
83242>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83242>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83242>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
83242>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83242>>>>>>>>>//        Increment i
83242>>>>>>>>>//
83242>>>>>>>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
83242>>>>>>>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
83242>>>>>>>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
83242>>>>>>>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
83242>>>>>>>>>//        Move "23.0"              to ColumnType[i].sPrecision
83242>>>>>>>>>//        Move True                to ColumnType[i].bCanEditSize
83242>>>>>>>>>//        Increment i
83242>>>>>>>>>//
83242>>>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
83242>>>>>>>>>//        Move "LONG"             to ColumnType[i].sSQLType
83242>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83242>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83242>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83242>>>>>>>>>//        Increment i
83242>>>>>>>>>//
83242>>>>>>>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
83242>>>>>>>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
83242>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83242>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83242>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83242>>>>>>>>>//        Increment i
83242>>>>>>>>>//
83242>>>>>>>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
83242>>>>>>>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
83242>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83242>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83242>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83242>>>>>>>>>//        Increment i
83242>>>>>>>>>//
83242>>>>>>>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
83242>>>>>>>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
83242>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83242>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83242>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83242>>>>>>>>>//        Increment i
83242>>>>>>>>>//
83242>>>>>>>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
83242>>>>>>>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
83242>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83242>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
83242>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83242>>>>>>>>>//        Increment i
83242>>>>>>>>>//
83242>>>>>>>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
83242>>>>>>>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
83242>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83242>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83242>>>>>>>>>//        Move "4000"             to ColumnType[i].sPrecision
83242>>>>>>>>>//        Increment i
83242>>>>>>>>>//
83242>>>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
83242>>>>>>>>>//        Move "RAW"              to ColumnType[i].sSQLType
83242>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83242>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83242>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83242>>>>>>>>>//        Increment i
83242>>>>>>>>>//
83242>>>>>>>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
83242>>>>>>>>>//        Move "ROWID"            to ColumnType[i].sSQLType
83242>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83242>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83242>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83242>>>>>>>>>//        Increment i
83242>>>>>>>>>//
83242>>>>>>>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
83242>>>>>>>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
83242>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83242>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83242>>>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
83242>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83242>>>>>>>>>//        Increment i
83242>>>>>>>>>//
83242>>>>>>>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
83242>>>>>>>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
83242>>>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
83242>>>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
83242>>>>>>>>>//        Move "13.0"                 to ColumnType[i].sPrecision
83242>>>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
83242>>>>>>>>>//        Increment i
83242>>>>>>>>>//
83242>>>>>>>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
83242>>>>>>>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
83242>>>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
83242>>>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
83242>>>>>>>>>//        Move "11.0"                 to ColumnType[i].sPrecision
83242>>>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
83242>>>>>>>>>//        Increment i
83242>>>>>>>>>//
83242>>>>>>>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
83242>>>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
83242>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83242>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83242>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83242>>>>>>>>>
83242>>>>>>>>>        Function_Return aColumnType
83243>>>>>>>>>    End_Function
83244>>>>>>>>>
83244>>>>>>>>>    // PostgreSQL Data Types
83244>>>>>>>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
83246>>>>>>>>>        tColumnType[] aColumnType
83246>>>>>>>>>        tColumnType[] aColumnType
83247>>>>>>>>>        Integer i
83247>>>>>>>>>
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdspgsql_DriverDef.inc)
83247>>>>>>>>>>// Generated By The Database Update Framework
83247>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
83247>>>>>>>>>>// Driver COLUMN DATA TYPES
83247>>>>>>>>>>//
83247>>>>>>>>>>// Created: 2018-03-14 23:47:02.984
83247>>>>>>>>>>
83247>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
83248>>>>>>>>>>            Move 20                                      to aColumnType[i].iSQLType
83249>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83250>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83251>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83252>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83253>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83254>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83255>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83256>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83257>>>>>>>>>>            Increment i
83258>>>>>>>>>>
83258>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
83259>>>>>>>>>>            Move 1560                                    to aColumnType[i].iSQLType
83260>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83261>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83262>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83263>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83264>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83265>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83266>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83267>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83268>>>>>>>>>>            Increment i
83269>>>>>>>>>>
83269>>>>>>>>>>            Move "boolean"                               to aColumnType[i].sSQLType
83270>>>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
83271>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83272>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83273>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83274>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83275>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83276>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83277>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83278>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83279>>>>>>>>>>            Increment i
83280>>>>>>>>>>
83280>>>>>>>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
83281>>>>>>>>>>            Move 17                                      to aColumnType[i].iSQLType
83282>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83283>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83284>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83285>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83286>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83287>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83288>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83289>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83290>>>>>>>>>>            Increment i
83291>>>>>>>>>>
83291>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
83292>>>>>>>>>>            Move 18                                      to aColumnType[i].iSQLType
83293>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83294>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83295>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83296>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83297>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83298>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83299>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83300>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83301>>>>>>>>>>            Increment i
83302>>>>>>>>>>
83302>>>>>>>>>>            Move "citext"                                to aColumnType[i].sSQLType
83303>>>>>>>>>>            Move -25                                     to aColumnType[i].iSQLType
83304>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83305>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83306>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83307>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83308>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83309>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83310>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83311>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83312>>>>>>>>>>            Increment i
83313>>>>>>>>>>
83313>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
83314>>>>>>>>>>            Move 1082                                    to aColumnType[i].iSQLType
83315>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83316>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83317>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83318>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83319>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83320>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
83321>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
83322>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83323>>>>>>>>>>            Increment i
83324>>>>>>>>>>
83324>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
83325>>>>>>>>>>            Move 701                                     to aColumnType[i].iSQLType
83326>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83327>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83328>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83329>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83330>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83331>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83332>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83333>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83334>>>>>>>>>>            Increment i
83335>>>>>>>>>>
83335>>>>>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
83336>>>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
83337>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83338>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83339>>>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
83340>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83341>>>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
83342>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83343>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83344>>>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
83345>>>>>>>>>>            Increment i
83346>>>>>>>>>>
83346>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
83347>>>>>>>>>>            Move 790                                     to aColumnType[i].iSQLType
83348>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83349>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83350>>>>>>>>>>            Move 30                                      to aColumnType[i].iDefaultSize
83351>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83352>>>>>>>>>>            Move 30                                      to aColumnType[i].nMaxSize
83353>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83354>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83355>>>>>>>>>>            Move 30                                      to aColumnType[i].sPrecision
83356>>>>>>>>>>            Increment i
83357>>>>>>>>>>
83357>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
83358>>>>>>>>>>            Move 1700                                    to aColumnType[i].iSQLType
83359>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83360>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83361>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83362>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83363>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83364>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83365>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83366>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83367>>>>>>>>>>            Increment i
83368>>>>>>>>>>
83368>>>>>>>>>>            Move "oid"                                   to aColumnType[i].sSQLType
83369>>>>>>>>>>            Move 26                                      to aColumnType[i].iSQLType
83370>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83371>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83372>>>>>>>>>>            Move 20                                      to aColumnType[i].iDefaultSize
83373>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83374>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83375>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83376>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83377>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83378>>>>>>>>>>            Increment i
83379>>>>>>>>>>
83379>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
83380>>>>>>>>>>            Move 700                                     to aColumnType[i].iSQLType
83381>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83382>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83383>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83384>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83385>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
83386>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83387>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83388>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83389>>>>>>>>>>            Increment i
83390>>>>>>>>>>
83390>>>>>>>>>>            Move "regproc"                               to aColumnType[i].sSQLType
83391>>>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
83392>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83393>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83394>>>>>>>>>>            Move 64                                      to aColumnType[i].iDefaultSize
83395>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83396>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83397>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83398>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83399>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83400>>>>>>>>>>            Increment i
83401>>>>>>>>>>
83401>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
83402>>>>>>>>>>            Move 21                                      to aColumnType[i].iSQLType
83403>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83404>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83405>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83406>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83407>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
83408>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83409>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83410>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83411>>>>>>>>>>            Increment i
83412>>>>>>>>>>
83412>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
83413>>>>>>>>>>            Move 25                                      to aColumnType[i].iSQLType
83414>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83415>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83416>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83417>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83418>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83419>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83420>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83421>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83422>>>>>>>>>>            Increment i
83423>>>>>>>>>>
83423>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
83424>>>>>>>>>>            Move 1083                                    to aColumnType[i].iSQLType
83425>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83426>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83427>>>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
83428>>>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
83429>>>>>>>>>>            Move 15                                      to aColumnType[i].nMaxSize
83430>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83431>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83432>>>>>>>>>>            Move 15                                      to aColumnType[i].sPrecision
83433>>>>>>>>>>            Increment i
83434>>>>>>>>>>
83434>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
83435>>>>>>>>>>            Move 1114                                    to aColumnType[i].iSQLType
83436>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83437>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83438>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83439>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83440>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83441>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83442>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83443>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83444>>>>>>>>>>            Increment i
83445>>>>>>>>>>
83445>>>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
83446>>>>>>>>>>            Move 1184                                    to aColumnType[i].iSQLType
83447>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83448>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83449>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83450>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83451>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83452>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83453>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83454>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83455>>>>>>>>>>            Increment i
83456>>>>>>>>>>
83456>>>>>>>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
83457>>>>>>>>>>            Move 2950                                    to aColumnType[i].iSQLType
83458>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83459>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83460>>>>>>>>>>            Move 40                                      to aColumnType[i].iDefaultSize
83461>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83462>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83463>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83464>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83465>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83466>>>>>>>>>>            Increment i
83467>>>>>>>>>>
83467>>>>>>>>>>            Move "varbit"                                to aColumnType[i].sSQLType
83468>>>>>>>>>>            Move 1562                                    to aColumnType[i].iSQLType
83469>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83470>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83471>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83472>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83473>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83474>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83475>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83476>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83477>>>>>>>>>>            Increment i
83478>>>>>>>>>>
83478>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
83479>>>>>>>>>>            Move 1043                                    to aColumnType[i].iSQLType
83480>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83481>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83482>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83483>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83484>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83485>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83486>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83487>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83488>>>>>>>>>>            Increment i
83489>>>>>>>>>>
83489>>>>>>>>>>
83489>>>>>>>>>
83489>>>>>>>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
83489>>>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
83489>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83489>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83489>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
83489>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83489>>>>>>>>>//        Increment i
83489>>>>>>>>>//
83489>>>>>>>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
83489>>>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
83489>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83489>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83489>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83489>>>>>>>>>//        Increment i
83489>>>>>>>>>//
83489>>>>>>>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
83489>>>>>>>>>//        Move "boolean"          to ColumnType[i].sSQLType
83489>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83489>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83489>>>>>>>>>//        Move "1"                to ColumnType[i].sPrecision
83489>>>>>>>>>//        Increment i
83489>>>>>>>>>//
83489>>>>>>>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
83489>>>>>>>>>//        Move "bytea"            to ColumnType[i].sSQLType
83489>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83489>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83489>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83489>>>>>>>>>//        Increment i
83489>>>>>>>>>//
83489>>>>>>>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
83489>>>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
83489>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83489>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83489>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83489>>>>>>>>>//        Increment i
83489>>>>>>>>>//
83489>>>>>>>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
83489>>>>>>>>>//        Move "citext"           to ColumnType[i].sSQLType
83489>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83489>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83489>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
83489>>>>>>>>>//        Increment i
83489>>>>>>>>>//
83489>>>>>>>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
83489>>>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
83489>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
83489>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
83489>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83489>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83489>>>>>>>>>//        Increment i
83489>>>>>>>>>//
83489>>>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
83489>>>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
83489>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83489>>>>>>>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
83489>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83489>>>>>>>>>//        Increment i
83489>>>>>>>>>//
83489>>>>>>>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
83489>>>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
83489>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83489>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83489>>>>>>>>>//        Move "22"               to ColumnType[i].sPrecision
83489>>>>>>>>>//        Increment i
83489>>>>>>>>>//
83489>>>>>>>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
83489>>>>>>>>>//        Move "integer"          to ColumnType[i].sSQLType
83489>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83489>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83489>>>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
83489>>>>>>>>>//        Increment i
83489>>>>>>>>>//
83489>>>>>>>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
83489>>>>>>>>>//        Move "money"            to ColumnType[i].sSQLType
83489>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83489>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83489>>>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
83489>>>>>>>>>//        Increment i
83489>>>>>>>>>//
83489>>>>>>>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
83489>>>>>>>>>//        Move "oid"              to ColumnType[i].sSQLType
83489>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83489>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83489>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83489>>>>>>>>>//        Increment i
83489>>>>>>>>>//
83489>>>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
83489>>>>>>>>>//        Move "real"             to ColumnType[i].sSQLType
83489>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83489>>>>>>>>>//        Move "Real"             to ColumnType[i].sDataFlexType
83489>>>>>>>>>//        Move "6.6"              to ColumnType[i].sPrecision
83489>>>>>>>>>//        Increment i
83489>>>>>>>>>//
83489>>>>>>>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
83489>>>>>>>>>//        Move "regproc"          to ColumnType[i].sSQLType
83489>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83489>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83489>>>>>>>>>//        Move "64"               to ColumnType[i].sPrecision
83489>>>>>>>>>//        Increment i
83489>>>>>>>>>//
83489>>>>>>>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
83489>>>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
83489>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83489>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83489>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83489>>>>>>>>>//        Increment i
83489>>>>>>>>>//
83489>>>>>>>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
83489>>>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
83489>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83489>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83489>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83489>>>>>>>>>//        Increment i
83489>>>>>>>>>//
83489>>>>>>>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
83489>>>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
83489>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83489>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83489>>>>>>>>>//        Move "15.0"             to ColumnType[i].sPrecision
83489>>>>>>>>>//        Increment i
83489>>>>>>>>>//
83489>>>>>>>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
83489>>>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
83489>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83489>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83489>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
83489>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83489>>>>>>>>>//        Increment i
83489>>>>>>>>>//
83489>>>>>>>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
83489>>>>>>>>>//        Move "uuid"             to ColumnType[i].sSQLType
83489>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83489>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83489>>>>>>>>>//        Move "40"               to ColumnType[i].sPrecision
83489>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83489>>>>>>>>>//        Increment i
83489>>>>>>>>>//
83489>>>>>>>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
83489>>>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
83489>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83489>>>>>>>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
83489>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83489>>>>>>>>>//        Increment i
83489>>>>>>>>>
83489>>>>>>>>>        Function_Return aColumnType
83490>>>>>>>>>    End_Function
83491>>>>>>>>>
83491>>>>>>>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
83491>>>>>>>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
83493>>>>>>>>>        Integer iValue iSize iCount iStart iItem
83493>>>>>>>>>        tColumnType[] ColumnTypeArray
83493>>>>>>>>>        tColumnType[] ColumnTypeArray
83494>>>>>>>>>        tColumnType RetvalType
83494>>>>>>>>>        tColumnType RetvalType
83494>>>>>>>>>        String sValue
83494>>>>>>>>>        Boolean bFrameworkDataFlexType
83494>>>>>>>>>
83494>>>>>>>>>        Move "Undefined" to RetvalType.sSQLType
83495>>>>>>>>>        Move -1999       to RetvalType.iSQLType
83496>>>>>>>>>
83496>>>>>>>>>        Move 0 to iStart
83497>>>>>>>>>        Move (Uppercase(sType)) to sType
83498>>>>>>>>>        Move (iType <= -1490) to bFrameworkDataFlexType
83499>>>>>>>>>        If (bFrameworkDataFlexType = True) Begin
83501>>>>>>>>>            Get _UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
83502>>>>>>>>>            Function_Return RetvalType
83503>>>>>>>>>        End
83503>>>>>>>>>>
83503>>>>>>>>>
83503>>>>>>>>>        Get _UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
83504>>>>>>>>>        Move iType to RetvalType.iSQLType
83505>>>>>>>>>        Move sType to RetvalType.sSQLType 
83506>>>>>>>>>        Move (SearchArray(RetvalType, ColumnTypeArray)) to iItem
83507>>>>>>>>>        
83507>>>>>>>>>        If (iItem = -1) Begin
83509>>>>>>>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
83510>>>>>>>>>            Move (SearchArray(RetvalType, ColumnTypeArray)) to iItem
83511>>>>>>>>>        End
83511>>>>>>>>>>
83511>>>>>>>>>        If (iItem <> -1) Begin
83513>>>>>>>>>            Move ColumnTypeArray[iItem].sSQLType       to RetvalType.sSQLType
83514>>>>>>>>>            Move ColumnTypeArray[iItem].iSQLType       to RetvalType.iSQLType
83515>>>>>>>>>            Move ColumnTypeArray[iItem].sDataFlexType  to RetvalType.sDataFlexType
83516>>>>>>>>>            Move ColumnTypeArray[iItem].iDataFlexType  to RetvalType.iDataFlexType
83517>>>>>>>>>            Move ColumnTypeArray[iItem].sPrecision     to RetvalType.sPrecision
83518>>>>>>>>>            Move ColumnTypeArray[iItem].bCanEditSize   to RetvalType.bCanEditSize
83519>>>>>>>>>        End
83519>>>>>>>>>>
83519>>>>>>>>>
83519>>>>>>>>>        Function_Return RetvalType
83520>>>>>>>>>    End_Function
83521>>>>>>>>>
83521>>>>>>>>>    // Returns a struct array with all data types for the passed driver & dbtype.
83521>>>>>>>>>    Function _UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
83523>>>>>>>>>        tColumnType[] ColumnType
83523>>>>>>>>>        tColumnType[] ColumnType
83524>>>>>>>>>
83524>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
83524>>>>>>>>>        // the dbType.
83524>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83526>>>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
83528>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
83529>>>>>>>>>            End
83529>>>>>>>>>>
83529>>>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
83531>>>>>>>>>                Move MSSQLDRV_ID to sDriverID
83532>>>>>>>>>            End
83532>>>>>>>>>>
83532>>>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
83534>>>>>>>>>                Move DB2_DRV_ID to sDriverID
83535>>>>>>>>>            End
83535>>>>>>>>>>
83535>>>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
83537>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
83538>>>>>>>>>            End
83538>>>>>>>>>>
83538>>>>>>>>>        End
83538>>>>>>>>>>
83538>>>>>>>>>
83538>>>>>>>>>        Case Begin
83538>>>>>>>>>            Case (iDbType = EN_dbTypeDataFlex)
83540>>>>>>>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
83541>>>>>>>>>                Case Break
83542>>>>>>>>>
83542>>>>>>>>>            Case (iDbType = EN_DbTypeDB2)
83545>>>>>>>>>                Get _UtilEnumerateDB2Types to ColumnType
83546>>>>>>>>>                Case Break
83547>>>>>>>>>
83547>>>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
83550>>>>>>>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
83551>>>>>>>>>                Case Break
83552>>>>>>>>>        Case End
83552>>>>>>>>>
83552>>>>>>>>>        Function_Return ColumnType
83553>>>>>>>>>    End_Function
83554>>>>>>>>>
83554>>>>>>>>>    // Returns a struct with the default column types for the SQL back-end and how they
83554>>>>>>>>>    // are mapped to a DUF data type.
83554>>>>>>>>>    Function _UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
83556>>>>>>>>>        tColumnType ColumnType
83556>>>>>>>>>        tColumnType ColumnType
83556>>>>>>>>>        String sDataType
83556>>>>>>>>>        Integer iDriverID iCount
83556>>>>>>>>>
83556>>>>>>>>>        Move 0 to iCount
83557>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
83558>>>>>>>>>
83558>>>>>>>>>        Case Begin
83558>>>>>>>>>            // DF_ASCII
83558>>>>>>>>>            Case (iType = DF_ASCII_DUF)
83560>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83562>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
83565>>>>>>>>>                End
83565>>>>>>>>>>
83565>>>>>>>>>                Else Begin
83566>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
83569>>>>>>>>>                End
83569>>>>>>>>>>
83569>>>>>>>>>                Move DF_ASCII    to ColumnType.iDataFlexType
83570>>>>>>>>>                Move "ASCII"     to ColumnType.sDataFlexType
83571>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83572>>>>>>>>>                Move DF_ASCII    to ColumnType.iSQLType
83573>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83574>>>>>>>>>                Case Break
83575>>>>>>>>>
83575>>>>>>>>>            // DF_BINARY
83575>>>>>>>>>            Case (iType = DF_BINARY_DUF)
83578>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83580>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
83583>>>>>>>>>                End
83583>>>>>>>>>>
83583>>>>>>>>>                Else Begin
83584>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
83587>>>>>>>>>                End
83587>>>>>>>>>>
83587>>>>>>>>>                Move DF_BINARY   to ColumnType.iDataFlexType
83588>>>>>>>>>                Move "Binary"    to ColumnType.sDataFlexType
83589>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83590>>>>>>>>>                Move DF_BINARY   to ColumnType.iSQLType
83591>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83592>>>>>>>>>                Case Break
83593>>>>>>>>>
83593>>>>>>>>>            // DF_DATE
83593>>>>>>>>>            Case (iType = DF_DATE_DUF)
83596>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83598>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83601>>>>>>>>>                End
83601>>>>>>>>>>
83601>>>>>>>>>                Else Begin
83602>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83605>>>>>>>>>                End
83605>>>>>>>>>>
83605>>>>>>>>>                Move DF_DATE     to ColumnType.iDataFlexType
83606>>>>>>>>>                Move "Date"      to ColumnType.sDataFlexType
83607>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83608>>>>>>>>>                Move DF_DATE     to ColumnType.iSQLType
83609>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83610>>>>>>>>>                Case Break
83611>>>>>>>>>
83611>>>>>>>>>            // DF_DATETIME
83611>>>>>>>>>            Case (iType = DF_DATETIME_DUF)
83614>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83616>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
83619>>>>>>>>>                End
83619>>>>>>>>>>
83619>>>>>>>>>                Else Begin
83620>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
83623>>>>>>>>>                End
83623>>>>>>>>>>
83623>>>>>>>>>                Move DF_DATETIME to ColumnType.iDataFlexType
83624>>>>>>>>>                Move "DateTime"  to ColumnType.sDataFlexType
83625>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83626>>>>>>>>>                Move DF_DATETIME to ColumnType.iSQLType
83627>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83628>>>>>>>>>                Case Break
83629>>>>>>>>>
83629>>>>>>>>>            // DF_NUMERIC
83629>>>>>>>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
83629>>>>>>>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
83629>>>>>>>>>            // we make them here all "Numeric"...
83629>>>>>>>>>            // If (sDriverID = ODBC_DRV_ID) Begin
83629>>>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83629>>>>>>>>>            // End
83629>>>>>>>>>            // Else Begin
83629>>>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83629>>>>>>>>>            // End
83629>>>>>>>>>            // ToDo: How should we find the best "Numeric" data type here?
83629>>>>>>>>>            Case (iType = DF_BCD_DUF)
83632>>>>>>>>>                Move DF_BCD      to ColumnType.iDataFlexType
83633>>>>>>>>>                Move "Numeric"   to ColumnType.sDataFlexType
83634>>>>>>>>>                Move "Numeric"   to ColumnType.sSQLType
83635>>>>>>>>>                Move SQL_NUMERIC to ColumnType.iSQLType
83636>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83637>>>>>>>>>                Case Break
83638>>>>>>>>>
83638>>>>>>>>>            // DF_TEXT
83638>>>>>>>>>            Case (iType = DF_TEXT_DUF)
83641>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83643>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
83646>>>>>>>>>                End
83646>>>>>>>>>>
83646>>>>>>>>>                Else Begin
83647>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
83650>>>>>>>>>                End
83650>>>>>>>>>>
83650>>>>>>>>>                Move DF_TEXT     to ColumnType.iDataFlexType
83651>>>>>>>>>                Move "Text"      to ColumnType.sDataFlexType
83652>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83653>>>>>>>>>                Move DF_TEXT     to ColumnType.iSQLType
83654>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83655>>>>>>>>>                Case Break
83656>>>>>>>>>
83656>>>>>>>>>            Case Else
83656>>>>>>>>>                Move -1999       to ColumnType.iDataFlexType
83657>>>>>>>>>                Move "Undefined" to ColumnType.sDataFlexType
83658>>>>>>>>>                Move "Undefined" to ColumnType.sSQLType
83659>>>>>>>>>                Move -1999       to ColumnType.iSQLType
83660>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83661>>>>>>>>>
83661>>>>>>>>>        Case End
83661>>>>>>>>>
83661>>>>>>>>>        Function_Return ColumnType
83662>>>>>>>>>    End_Function
83663>>>>>>>>>
83663>>>>>>>>>    Function _AllTablesToConvert Returns Integer[]
83665>>>>>>>>>        Integer[] aTableConvertExceptions iTablesArray
83667>>>>>>>>>        Handle hTable
83667>>>>>>>>>        Integer iIndex
83667>>>>>>>>>        String sTableName
83667>>>>>>>>>        Boolean bFlexErrs
83667>>>>>>>>>
83667>>>>>>>>>        // a) Get the exception table array the developer has specified
83667>>>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
83668>>>>>>>>>
83668>>>>>>>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
83668>>>>>>>>>        Repeat
83668>>>>>>>>>>
83668>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83671>>>>>>>>>            If (hTable <> 0) Begin
83673>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83676>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83677>>>>>>>>>                If (bFlexErrs = False) Begin
83679>>>>>>>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
83681>>>>>>>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
83682>>>>>>>>>                        If (iIndex = -1) Begin
83684>>>>>>>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
83685>>>>>>>>>                        End
83685>>>>>>>>>>
83685>>>>>>>>>                    End
83685>>>>>>>>>>
83685>>>>>>>>>                End
83685>>>>>>>>>>
83685>>>>>>>>>            End
83685>>>>>>>>>>
83685>>>>>>>>>        Until (hTable = 0)
83687>>>>>>>>>
83687>>>>>>>>>        Move 0 to hTable
83688>>>>>>>>>
83688>>>>>>>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
83688>>>>>>>>>        Repeat
83688>>>>>>>>>>
83688>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83691>>>>>>>>>            If (hTable > 0) Begin
83693>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83696>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83697>>>>>>>>>                If (bFlexErrs = False) Begin
83699>>>>>>>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
83700>>>>>>>>>                    If (iIndex = -1) Begin
83702>>>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
83703>>>>>>>>>                    End
83703>>>>>>>>>>
83703>>>>>>>>>                End
83703>>>>>>>>>>
83703>>>>>>>>>            End
83703>>>>>>>>>>
83703>>>>>>>>>        Until (hTable = 0)
83705>>>>>>>>>
83705>>>>>>>>>        Function_Return iTablesArray
83706>>>>>>>>>    End_Function
83707>>>>>>>>>
83707>>>>>>>>>    Function _AllTablesDateCorrections Returns Integer[]
83709>>>>>>>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
83711>>>>>>>>>        Handle hTable
83711>>>>>>>>>        Integer iIndex
83711>>>>>>>>>        String sTableName
83711>>>>>>>>>        Boolean bFlexErrs
83711>>>>>>>>>
83711>>>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
83712>>>>>>>>>        Move 0 to hTable
83713>>>>>>>>>
83713>>>>>>>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
83713>>>>>>>>>        Repeat
83713>>>>>>>>>>
83713>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83716>>>>>>>>>            If (hTable > 0) Begin
83718>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83721>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83722>>>>>>>>>                If (bFlexErrs = False) Begin
83724>>>>>>>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
83725>>>>>>>>>                    If (iIndex = -1) Begin
83727>>>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
83728>>>>>>>>>                    End
83728>>>>>>>>>>
83728>>>>>>>>>                End
83728>>>>>>>>>>
83728>>>>>>>>>            End
83728>>>>>>>>>>
83728>>>>>>>>>        Until (hTable = 0)
83730>>>>>>>>>
83730>>>>>>>>>        Function_Return iTablesArray
83731>>>>>>>>>    End_Function
83732>>>>>>>>>
83732>>>>>>>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
83734>>>>>>>>>        tAPIColumn NewAPIColumn
83734>>>>>>>>>        tAPIColumn NewAPIColumn
83734>>>>>>>>>
83734>>>>>>>>>        Move sFieldName to NewAPIColumn.sFieldName
83735>>>>>>>>>        Move iType      to NewAPIColumn.iType
83736>>>>>>>>>        Move iLength    to NewAPIColumn.iLength
83737>>>>>>>>>        Move iPrecision to NewAPIColumn.iPrecision
83738>>>>>>>>>        Move iOptions   to NewAPIColumn.iOptions
83739>>>>>>>>>
83739>>>>>>>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
83740>>>>>>>>>
83740>>>>>>>>>        Function_Return aCurrent
83741>>>>>>>>>    End_Function
83742>>>>>>>>>
83742>>>>>>>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
83744>>>>>>>>>        String sRetval sFieldName
83744>>>>>>>>>        Integer iCount iSize
83744>>>>>>>>>
83744>>>>>>>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
83745>>>>>>>>>        Decrement iSize
83746>>>>>>>>>        For iCount from 0 to iSize
83752>>>>>>>>>>
83752>>>>>>>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
83753>>>>>>>>>            Move (sRetval * (String(sFieldName))) to sRetval
83754>>>>>>>>>        Loop
83755>>>>>>>>>>
83755>>>>>>>>>        Move (Trim(sRetval)) to sRetval
83756>>>>>>>>>
83756>>>>>>>>>        Function_Return sRetval
83757>>>>>>>>>    End_Function
83758>>>>>>>>>
83758>>>>>>>>>    // *** Miscellaneous other functions ***
83758>>>>>>>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
83758>>>>>>>>>    //
83758>>>>>>>>>
83758>>>>>>>>>    // Callback functionality used when e.g. calling driver functions directly.
83758>>>>>>>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
83760>>>>>>>>>        Integer iPerc
83760>>>>>>>>>        Number nReady nTotal
83760>>>>>>>>>
83760>>>>>>>>>        Send DoAdvance of ghoProgressBar
83761>>>>>>>>>
83761>>>>>>>>>        If (sCallback_Text contains "Copy records") Begin
83763>>>>>>>>>            Move CS_DUF_CopyingData to sCallback_Text
83764>>>>>>>>>        End
83764>>>>>>>>>>
83764>>>>>>>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
83766>>>>>>>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
83767>>>>>>>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
83768>>>>>>>>>        End
83768>>>>>>>>>>
83768>>>>>>>>>        If (sCallback_Text contains "Creating index") Begin
83770>>>>>>>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
83771>>>>>>>>>        End
83771>>>>>>>>>>
83771>>>>>>>>>
83771>>>>>>>>>        Case Begin
83771>>>>>>>>>            Case (iCallback_Type = DF_Message_Text)
83773>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83774>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83775>>>>>>>>>                Case Break
83776>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_1)
83779>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83780>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83781>>>>>>>>>                Case Break
83782>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_2)
83785>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83786>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83787>>>>>>>>>                Case Break
83788>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_3)
83791>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83792>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83793>>>>>>>>>                Case Break
83794>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_4)
83797>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83798>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83799>>>>>>>>>                Case Break
83800>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_5)
83803>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83804>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83805>>>>>>>>>                Case Break
83806>>>>>>>>>            Case (iCallback_Type = DF_Message_Warning)
83809>>>>>>>>>                Send None
83810>>>>>>>>>                Case Break
83811>>>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Title)
83814>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83815>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83816>>>>>>>>>                Case Break
83817>>>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Value)
83820>>>>>>>>>                //*** Interpret numbers
83820>>>>>>>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
83821>>>>>>>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
83822>>>>>>>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
83823>>>>>>>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
83824>>>>>>>>>                Case Break
83825>>>>>>>>>            Case Else
83825>>>>>>>>>                Set Message_Text to ""
83826>>>>>>>>>                Set Action_Text  to ""
83827>>>>>>>>>        Case End
83827>>>>>>>>>
83827>>>>>>>>>        Send ProcessEvents of ghoStatusPanel
83828>>>>>>>>>        Function_Return False
83829>>>>>>>>>    End_Function
83830>>>>>>>>>
83830>>>>>>>>>    // * Dummy function for the Studio's Code Explorer *
83830>>>>>>>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
83832>>>>>>>>>        Function_Return False
83833>>>>>>>>>    End_Function
83834>>>>>>>>>
83834>>>>>>>>>    // *** Helper functions with compiled sql script code ***
83834>>>>>>>>>    //
83834>>>>>>>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
83834>>>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
83834>>>>>>>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
83834>>>>>>>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
83834>>>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
83834>>>>>>>>>    //   ALTER TABLE MyTable
83834>>>>>>>>>    //       REBUILD
83834>>>>>>>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
83836>>>>>>>>>        Boolean bOK
83836>>>>>>>>>
83836>>>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
83838>>>>>>>>>            Function_Return False
83839>>>>>>>>>        End
83839>>>>>>>>>>
83839>>>>>>>>>
83839>>>>>>>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
83839>>>>>>>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
83840>>>>>>>>>
83840>>>>>>>>>        Function_Return (bOK = True)
83841>>>>>>>>>    End_Function
83842>>>>>>>>>
83842>>>>>>>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
83842>>>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
83842>>>>>>>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
83842>>>>>>>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
83842>>>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
83842>>>>>>>>>    //   ALTER TABLE MyTable
83842>>>>>>>>>    //       REBUILD
83842>>>>>>>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
83844>>>>>>>>>        tSQLScriptArray SQLScriptArray
83844>>>>>>>>>        tSQLScriptArray SQLScriptArray
83844>>>>>>>>>        String sDriverID
83844>>>>>>>>>        Boolean bOK
83844>>>>>>>>>        Integer iSize iCount
83844>>>>>>>>>
83844>>>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
83846>>>>>>>>>            Function_Return False
83847>>>>>>>>>        End
83847>>>>>>>>>>
83847>>>>>>>>>
83847>>>>>>>>>        Get psDriverID to sDriverID
83848>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83849>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
83851>>>>>>>>>            Function_Return False
83852>>>>>>>>>        End
83852>>>>>>>>>>
83852>>>>>>>>>
83852>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83853>>>>>>>>>        Decrement iSize
83854>>>>>>>>>
83854>>>>>>>>>        For iCount from 0 to iSize
83860>>>>>>>>>>
83860>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
83862>>>>>>>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
83863>>>>>>>>>            End
83863>>>>>>>>>>
83863>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
83865>>>>>>>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
83866>>>>>>>>>            End
83866>>>>>>>>>>
83866>>>>>>>>>        Loop
83867>>>>>>>>>>
83867>>>>>>>>>
83867>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83868>>>>>>>>>
83868>>>>>>>>>        Function_Return (bOK = True)
83869>>>>>>>>>    End_Function
83870>>>>>>>>>
83870>>>>>>>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
83870>>>>>>>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
83870>>>>>>>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
83870>>>>>>>>>    Function _SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
83872>>>>>>>>>        Integer iChannel iArgumentSize iCount
83872>>>>>>>>>        Number nByteCount
83872>>>>>>>>>        String sSQLScript
83872>>>>>>>>>        tSQLScriptArray SqlScriptArray
83872>>>>>>>>>        tSQLScriptArray SqlScriptArray
83872>>>>>>>>>        UChar[] uCharData
83873>>>>>>>>>
83873>>>>>>>>>        Move False to Err
83874>>>>>>>>>        Get Seq_New_Channel to iChannel
83875>>>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83877>>>>>>>>>            Error DFERR_PROGRAM 'No channel available...'
83878>>>>>>>>>>
83878>>>>>>>>>            Move True to SqlScriptArray.bError
83879>>>>>>>>>            Function_Return SqlScriptArray
83880>>>>>>>>>        End
83880>>>>>>>>>>
83880>>>>>>>>>
83880>>>>>>>>>        // First decide the size of the script
83880>>>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83882>>>>>>>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
83884>>>>>>>>>        Close_Input channel iChannel
83886>>>>>>>>>
83886>>>>>>>>>        Move (SizeOfArray(uCharData)) to nByteCount
83887>>>>>>>>>        If (nByteCount  < 1) Begin
83889>>>>>>>>>            Send Seq_Release_Channel iChannel
83890>>>>>>>>>            Move True to SqlScriptArray.bError
83891>>>>>>>>>            Function_Return SqlScriptArray
83892>>>>>>>>>        End
83892>>>>>>>>>>
83892>>>>>>>>>
83892>>>>>>>>>        // If necessary change the string argument_size
83892>>>>>>>>>        // Read the script file from memory line-by-line
83892>>>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83894>>>>>>>>>            Move 0 to iCount
83895>>>>>>>>>            Repeat
83895>>>>>>>>>>
83895>>>>>>>>>                Readln channel iChannel sSQLScript
83897>>>>>>>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
83898>>>>>>>>>                Increment iCount
83899>>>>>>>>>            Until (SeqEof = True)
83901>>>>>>>>>        Close_Input channel iChannel
83903>>>>>>>>>        Send Seq_Release_Channel iChannel
83904>>>>>>>>>
83904>>>>>>>>>        // Finally "sanitize" the script by removing all comments.
83904>>>>>>>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
83905>>>>>>>>>
83905>>>>>>>>>        Function_Return SqlScriptArray
83906>>>>>>>>>    End_Function
83907>>>>>>>>>
83907>>>>>>>>>    Function _SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
83909>>>>>>>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
83909>>>>>>>>>        Handle hoSql hoSQLConnect hoStmt hoError
83909>>>>>>>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage iPos
83909>>>>>>>>>        String[] sMsg aSQLQueryMessages
83911>>>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd
83911>>>>>>>>>        TimeSpan tsQuery
83911>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83911>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83911>>>>>>>>>        tSQLConnection SQLConnection
83911>>>>>>>>>        tSQLConnection SQLConnection
83911>>>>>>>>>        Boolean bShowProgress
83911>>>>>>>>>
83911>>>>>>>>>        If (num_arguments > 4) Begin
83913>>>>>>>>>            Move bShowProgr to bShowProgress
83914>>>>>>>>>        End
83914>>>>>>>>>>
83914>>>>>>>>>        Get phoSQLManager to hoSql
83915>>>>>>>>>
83915>>>>>>>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
83916>>>>>>>>>        // There seems to be a problem to pass strings when their value gets really big, aka
83916>>>>>>>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
83916>>>>>>>>>        // or later SqlExecDirect stops working correctly with no error messages!
83916>>>>>>>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
83916>>>>>>>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
83916>>>>>>>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
83916>>>>>>>>>        Get piChunkMax to iChunkMax
83917>>>>>>>>>        Move 0 to iChunkCounter
83918>>>>>>>>>        Move "" to sStmt
83919>>>>>>>>>
83919>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
83920>>>>>>>>>        Move (Character(13) + Character(10)) to sCR
83921>>>>>>>>>
83921>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
83922>>>>>>>>>
83922>>>>>>>>>        Get phoSQLManager  to hoSQL
83923>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83925>>>>>>>>>            If (Uppercase(SQLConnection.sConnectionString) contains CS_SQLIniDSNKeyword) Begin
83927>>>>>>>>>                Move (Pos(";", SQLConnection.sConnectionString)) to iPos
83928>>>>>>>>>                If (iPos > 0) Begin
83930>>>>>>>>>                    Move (Left(SQLConnection.sConnectionString, (iPos - 1))) to SQLConnection.sConnectionString
83931>>>>>>>>>                    Move (Trim(SQLConnection.sConnectionString)) to SQLConnection.sConnectionString
83932>>>>>>>>>                End
83932>>>>>>>>>>
83932>>>>>>>>>            End
83932>>>>>>>>>>
83932>>>>>>>>>        End
83932>>>>>>>>>>
83932>>>>>>>>>        Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
83933>>>>>>>>>        Get SqlConnect     of hoSQL "" "" to hoSQLConnect
83934>>>>>>>>>
83934>>>>>>>>>        If (hoSQLConnect <> 0) Begin
83936>>>>>>>>>            Move False to Err
83937>>>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
83938>>>>>>>>>            If (hoStmt <> 0) Begin
83940>>>>>>>>>
83940>>>>>>>>>                // If the embedded resource should be written as a script file to disk:
83940>>>>>>>>>                If (bCreateScriptFile = True) Begin
83942>>>>>>>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
83943>>>>>>>>>                    Get vFolderFormat sExportFile to sExportFile
83944>>>>>>>>>                    Move (sExportFile + sMemFileName) to sExportFile
83945>>>>>>>>>                    Get Seq_New_Channel to iOut
83946>>>>>>>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83948>>>>>>>>>                        Direct_Output channel iOut sExportFile
83950>>>>>>>>>                    End
83950>>>>>>>>>>
83950>>>>>>>>>                End
83950>>>>>>>>>>
83950>>>>>>>>>
83950>>>>>>>>>                // Record starting date/time stamp
83950>>>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
83951>>>>>>>>>                // Turn on error handling if enabled
83951>>>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
83953>>>>>>>>>                    Set pbSqlError to False
83954>>>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
83955>>>>>>>>>                    Move Error_Object_Id to hoError
83956>>>>>>>>>                    Move Self to Error_Object_Id
83957>>>>>>>>>                End
83957>>>>>>>>>>
83957>>>>>>>>>
83957>>>>>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
83958>>>>>>>>>                Decrement iRows
83959>>>>>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
83961>>>>>>>>>                    Move (sNoCountKeyWord + sCR) to sStmt
83962>>>>>>>>>                End
83962>>>>>>>>>>
83962>>>>>>>>>
83962>>>>>>>>>                for iCount from 0 to iRows
83968>>>>>>>>>>
83968>>>>>>>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
83969>>>>>>>>>
83969>>>>>>>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
83971>>>>>>>>>                        If (sSQLVal <> "") Begin
83973>>>>>>>>>                            Move (sSQLVal + sCR) to sSQLVal
83974>>>>>>>>>                        End
83974>>>>>>>>>>
83974>>>>>>>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
83975>>>>>>>>>                    End
83975>>>>>>>>>>
83975>>>>>>>>>
83975>>>>>>>>>                    // - Each time we encounter a "GO" statement we execute it,
83975>>>>>>>>>                    // or if at the very end of the script.
83975>>>>>>>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
83977>>>>>>>>>
83977>>>>>>>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
83977>>>>>>>>>                        // instead of all in one go.
83977>>>>>>>>>                        Send SqlExecDirect of hoStmt sStmt
83978>>>>>>>>>
83978>>>>>>>>>                        If (bCreateScriptFile = True) Begin
83980>>>>>>>>>                            Write channel iOut sStmt
83982>>>>>>>>>                        End
83982>>>>>>>>>>
83982>>>>>>>>>                        Move "" to sStmt
83983>>>>>>>>>                        Move 0 to iChunkCounter
83984>>>>>>>>>                    End
83984>>>>>>>>>>
83984>>>>>>>>>                    Increment iChunkCounter
83985>>>>>>>>>                Loop
83986>>>>>>>>>>
83986>>>>>>>>>
83986>>>>>>>>>                Repeat
83986>>>>>>>>>>
83986>>>>>>>>>                    If (pbHandleQueryErrors(Self)) Begin
83988>>>>>>>>>                        Move hoError to Error_Object_Id
83989>>>>>>>>>                    End
83989>>>>>>>>>>
83989>>>>>>>>>                    Move (CurrentDateTime()) to dtQueryExecEnd
83990>>>>>>>>>
83990>>>>>>>>>                    Send _SqlColumnInfo hoStmt
83991>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
83992>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
83993>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
83994>>>>>>>>>                    Set piRows    to iRows
83995>>>>>>>>>                    Set piRowType to iRowType
83996>>>>>>>>>
83996>>>>>>>>>                    If (iMsgs <> 0) Begin
83998>>>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
84000>>>>>>>>>                            Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
84001>>>>>>>>>                        End
84001>>>>>>>>>>
84001>>>>>>>>>                        for i from 1 to iMsgs
84007>>>>>>>>>>
84007>>>>>>>>>                            Get SqlGetMessage of hoStmt i to sMessage
84008>>>>>>>>>                            Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
84009>>>>>>>>>                            If (bShowProgress = True) Begin
84011>>>>>>>>>                                If (Active_State(ghoStatusPanel)) Begin
84013>>>>>>>>>                                    Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
84014>>>>>>>>>                                End
84014>>>>>>>>>>
84014>>>>>>>>>                                Else Begin
84015>>>>>>>>>                                    Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
84017>>>>>>>>>                                End
84017>>>>>>>>>>
84017>>>>>>>>>                            End
84017>>>>>>>>>>
84017>>>>>>>>>                            Move sMessage to sMsg[SizeOfArray(sMsg)]
84018>>>>>>>>>                            Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
84019>>>>>>>>>                        Loop
84020>>>>>>>>>>
84020>>>>>>>>>
84020>>>>>>>>>
84020>>>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
84022>>>>>>>>>                            Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
84023>>>>>>>>>                        End
84023>>>>>>>>>>
84023>>>>>>>>>                        Set paQueryMessages to sMsg
84024>>>>>>>>>                    End
84024>>>>>>>>>>
84024>>>>>>>>>
84024>>>>>>>>>                    Get SQLNextResultSet of hoStmt to iNextSet
84025>>>>>>>>>                Until (iNextSet = 0)
84027>>>>>>>>>
84027>>>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
84028>>>>>>>>>            End
84028>>>>>>>>>>
84028>>>>>>>>>
84028>>>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
84029>>>>>>>>>            Set ptsQueryExec to tsQuery
84030>>>>>>>>>            Send SqlClose of hoStmt
84031>>>>>>>>>
84031>>>>>>>>>            If (bCreateScriptFile = True) Begin
84033>>>>>>>>>                Close_Output channel iOut
84035>>>>>>>>>                Send Seq_Release_Channel iOut
84036>>>>>>>>>            End
84036>>>>>>>>>>
84036>>>>>>>>>        End
84036>>>>>>>>>>
84036>>>>>>>>>        Send SqlDisconnect of hoSQLConnect
84037>>>>>>>>>
84037>>>>>>>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
84038>>>>>>>>>    End_Function
84039>>>>>>>>>
84039>>>>>>>>>    Function _SqlUtilCreatePostGreSQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
84041>>>>>>>>>        tSQLScriptArray SQLScriptArray
84041>>>>>>>>>        tSQLScriptArray SQLScriptArray
84041>>>>>>>>>        String sDriverID sCollation
84041>>>>>>>>>        Boolean bOK
84041>>>>>>>>>        Integer iSize iCount
84041>>>>>>>>>
84041>>>>>>>>>        If (Trim(sDatabaseName) = "") Begin
84043>>>>>>>>>            Function_Return False
84044>>>>>>>>>        End
84044>>>>>>>>>>
84044>>>>>>>>>
84044>>>>>>>>>        Get psDriverID  to sDriverID
84045>>>>>>>>>        Get psCollation to sCollation
84046>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
84047>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
84049>>>>>>>>>            Function_Return False
84050>>>>>>>>>        End
84050>>>>>>>>>>
84050>>>>>>>>>
84050>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
84051>>>>>>>>>        Decrement iSize
84052>>>>>>>>>
84052>>>>>>>>>        For iCount from 0 to iSize
84058>>>>>>>>>>
84058>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
84060>>>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
84061>>>>>>>>>            End
84061>>>>>>>>>>
84061>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
84063>>>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
84064>>>>>>>>>            End
84064>>>>>>>>>>
84064>>>>>>>>>        Loop
84065>>>>>>>>>>
84065>>>>>>>>>
84065>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
84066>>>>>>>>>
84066>>>>>>>>>        Function_Return (bOK = True)
84067>>>>>>>>>    End_Function
84068>>>>>>>>>
84068>>>>>>>>>    Function _SqlUtilCreateMySQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
84070>>>>>>>>>        tSQLScriptArray SQLScriptArray
84070>>>>>>>>>        tSQLScriptArray SQLScriptArray
84070>>>>>>>>>        String sDriverID sCollation
84070>>>>>>>>>        Boolean bOK
84070>>>>>>>>>        Integer iSize iCount
84070>>>>>>>>>
84070>>>>>>>>>        If (Trim(sDatabaseName) = "") Begin
84072>>>>>>>>>            Function_Return False
84073>>>>>>>>>        End
84073>>>>>>>>>>
84073>>>>>>>>>
84073>>>>>>>>>        Get psDriverID  to sDriverID
84074>>>>>>>>>        Get psCollation to sCollation
84075>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
84076>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
84078>>>>>>>>>            Function_Return False
84079>>>>>>>>>        End
84079>>>>>>>>>>
84079>>>>>>>>>
84079>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
84080>>>>>>>>>        Decrement iSize
84081>>>>>>>>>
84081>>>>>>>>>        For iCount from 0 to iSize
84087>>>>>>>>>>
84087>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
84089>>>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
84090>>>>>>>>>            End
84090>>>>>>>>>>
84090>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
84092>>>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
84093>>>>>>>>>            End
84093>>>>>>>>>>
84093>>>>>>>>>        Loop
84094>>>>>>>>>>
84094>>>>>>>>>        // ToDo: THIS FAILS BUT THE SQL SCRIPT WORKS IN MYSQL!
84094>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
84095>>>>>>>>>
84095>>>>>>>>>        Function_Return (bOK = True)
84096>>>>>>>>>    End_Function
84097>>>>>>>>>
84097>>>>>>>>>    Function _StrToFieldNumber Integer iFile String sField Returns Integer
84099>>>>>>>>>        Integer iMax iPos
84099>>>>>>>>>        String sName
84099>>>>>>>>>
84099>>>>>>>>>        Move (Lowercase(sField)) to sField
84100>>>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
84103>>>>>>>>>        For iPos from 0 to iMax
84109>>>>>>>>>>
84109>>>>>>>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
84112>>>>>>>>>            Move (Lowercase(sName)) to sName
84113>>>>>>>>>            If (sName = sField) Begin
84115>>>>>>>>>                Function_Return iPos
84116>>>>>>>>>            End
84116>>>>>>>>>>
84116>>>>>>>>>        Loop
84117>>>>>>>>>>
84117>>>>>>>>>        Function_Return -1
84118>>>>>>>>>    End_Function
84119>>>>>>>>>
84119>>>>>>>>>    // Checks if the passed connection id exists in the CLI interface.
84119>>>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
84119>>>>>>>>>    // the connection id hasn't been established with the driver's CLI interface.
84119>>>>>>>>>    // NOTE: Only applicable for DAW drivers.
84119>>>>>>>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
84121>>>>>>>>>        String sID sConnString
84121>>>>>>>>>        Integer iDriver iNumConn iCount
84121>>>>>>>>>        Handle hoCLI
84121>>>>>>>>>        Boolean bOK
84121>>>>>>>>>
84121>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
84122>>>>>>>>>        If (bOK = False) Begin
84124>>>>>>>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers."
84125>>>>>>>>>>
84125>>>>>>>>>            Function_Return False
84126>>>>>>>>>        End
84126>>>>>>>>>>
84126>>>>>>>>>
84126>>>>>>>>>        Move False to bOK
84127>>>>>>>>>        Get phoCLIHandler to hoCLI
84128>>>>>>>>>        If (hoCLI <> 0) Begin
84130>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
84131>>>>>>>>>            Get DriverIndex of hoCLI sDriverID to iDriver
84132>>>>>>>>>
84132>>>>>>>>>            // If driver not loaded; load it.
84132>>>>>>>>>            If (iDriver = 0) Begin
84134>>>>>>>>>                Load_Driver sDriverID
84135>>>>>>>>>                Get DriverIndex sDriverID to iDriver
84136>>>>>>>>>            End
84136>>>>>>>>>>
84136>>>>>>>>>            If (iDriver <> 0) Begin
84138>>>>>>>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
84141>>>>>>>>>                Decrement iNumConn
84142>>>>>>>>>                For iCount from 0 to iNumConn
84148>>>>>>>>>>
84148>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
84151>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
84154>>>>>>>>>                    If (sID = sConnectionID) Begin
84156>>>>>>>>>                        Move True to bOK
84157>>>>>>>>>                    End
84157>>>>>>>>>>
84157>>>>>>>>>                Loop
84158>>>>>>>>>>
84158>>>>>>>>>            End
84158>>>>>>>>>>
84158>>>>>>>>>        End
84158>>>>>>>>>>
84158>>>>>>>>>
84158>>>>>>>>>        Function_Return bOK
84159>>>>>>>>>    End_Function
84160>>>>>>>>>
84160>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
84162>>>>>>>>>        Boolean bOK
84162>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
84163>>>>>>>>>        Function_Return bOK
84164>>>>>>>>>    End_Function
84165>>>>>>>>>
84165>>>>>>>>>    Function IsMSSQLDriver Returns Boolean
84167>>>>>>>>>        Integer iDriverIndex
84167>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
84168>>>>>>>>>        Function_Return (iDriverIndex <> 0)
84169>>>>>>>>>    End_Function
84170>>>>>>>>>
84170>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
84170>>>>>>>>>    // attempt to load the driver.
84170>>>>>>>>>    // Returns true if the passed driver is SQL based.
84170>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
84172>>>>>>>>>        Boolean bOK
84172>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
84173>>>>>>>>>        Function_Return bOK
84174>>>>>>>>>    End_Function
84175>>>>>>>>>
84175>>>>>>>>>    // *** Error Handler ***
84175>>>>>>>>>    //
84175>>>>>>>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
84175>>>>>>>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
84175>>>>>>>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
84177>>>>>>>>>        Integer iSize iErrorMode
84177>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84177>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84177>>>>>>>>>
84177>>>>>>>>>        If (pbProcessingError(Self)) Begin
84179>>>>>>>>>            Procedure_Return
84180>>>>>>>>>        End
84180>>>>>>>>>>
84180>>>>>>>>>
84180>>>>>>>>>        Get Error_Report_Mode to iErrorMode
84181>>>>>>>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
84183>>>>>>>>>            Set Private.pbProcessingError to False
84184>>>>>>>>>            Procedure_Return
84185>>>>>>>>>        End
84185>>>>>>>>>>
84185>>>>>>>>>
84185>>>>>>>>>        Set pbProcessingError to True
84186>>>>>>>>>        Set pbSqlError to True
84187>>>>>>>>>        Get paSqlErrorArray      to aSqlErrorArray
84188>>>>>>>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
84189>>>>>>>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
84190>>>>>>>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
84191>>>>>>>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
84192>>>>>>>>>        Set paSqlErrorArray      to aSqlErrorArray
84193>>>>>>>>>        Set pbProcessingError to False
84194>>>>>>>>>    End_Procedure
84195>>>>>>>>>
84195>>>>>>>>>    // *** Miscellanous Helper Functions ***
84195>>>>>>>>>    //
84195>>>>>>>>>    // Helper function. Takes a DF_FILE_ROOT_NAME value as parameter and
84195>>>>>>>>>    // returns the table name only; stripped of any prefix, path or filename extension.
84195>>>>>>>>>    Function _TableNameOnly String sTableName Returns String
84197>>>>>>>>>        Integer iPos
84197>>>>>>>>>        Move (Pos(":", sTableName)) to iPos
84198>>>>>>>>>        If (iPos <> 0) Begin
84200>>>>>>>>>            Move (Mid(sTableName, Length(sTableName), (iPos +1))) to sTableName
84201>>>>>>>>>        End  
84201>>>>>>>>>>
84201>>>>>>>>>        Move (Pos(".int", Lowercase(sTableName))) to iPos
84202>>>>>>>>>        If (iPos <> 0) Begin
84204>>>>>>>>>            Move (Left(sTableName, (iPos -1))) to sTableName
84205>>>>>>>>>        End  
84205>>>>>>>>>>
84205>>>>>>>>>        Function_Return sTableName
84206>>>>>>>>>    End_Function
84207>>>>>>>>>
84207>>>>>>>>>    // Removes any prefix from a table name.
84207>>>>>>>>>    // Example mssqldrv:mytable returns mytable
84207>>>>>>>>>    //         dbo.mytable returns mytable
84207>>>>>>>>>    Function _TableNoPrefix String sName Returns String
84209>>>>>>>>>        Integer iPos
84209>>>>>>>>>        Move (Pos(":", sName)) to iPos
84210>>>>>>>>>        If (iPos <> 0) Begin
84212>>>>>>>>>            Move (Mid(sName, Length(sName), (iPos + 1))) to sName
84213>>>>>>>>>        End
84213>>>>>>>>>>
84213>>>>>>>>>        Move (Pos(".", sName)) to iPos
84214>>>>>>>>>        If (iPos <> 0) Begin
84216>>>>>>>>>            Move (Mid(sName, Length(sName), (iPos + 1))) to sName
84217>>>>>>>>>        End
84217>>>>>>>>>>
84217>>>>>>>>>        Function_Return sName
84218>>>>>>>>>    End_Function
84219>>>>>>>>>    
84219>>>>>>>>>    Function _DriverIDFromRootName String sRootName Returns String
84221>>>>>>>>>        String sDriverID
84221>>>>>>>>>        Integer iPos
84221>>>>>>>>>        Move DATAFLEX_ID to sDriverID
84222>>>>>>>>>        Move (Pos(":", sRootName)) to iPos
84223>>>>>>>>>        If (iPos <> 0) Begin
84225>>>>>>>>>            Move (Left(sRootName, (iPos -1))) to sDriverID
84226>>>>>>>>>        End
84226>>>>>>>>>>
84226>>>>>>>>>        Function_Return sDriverID
84227>>>>>>>>>    End_Function
84228>>>>>>>>>    // Does the Rootname points to a .dat file?
84228>>>>>>>>>    Function _IsDatEntry Handle hTable Returns Boolean
84230>>>>>>>>>        Boolean bFound bIsIntEntry
84230>>>>>>>>>        String sRootName sNoDriverRootname sDriver
84230>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84233>>>>>>>>>        Get _DriverIDFromRootName sRootName to sDriver
84234>>>>>>>>>        Get _TableNameOnly sRootName to sNoDriverRootname
84235>>>>>>>>>        Get _IsIntEntry hTable to bIsIntEntry
84236>>>>>>>>>        Move (bIsIntEntry = False and sDriver = DATAFLEX_ID) to bFound
84237>>>>>>>>>        Function_Return bFound
84238>>>>>>>>>    End_Function
84239>>>>>>>>>
84239>>>>>>>>>    // Checks that the RootName points to a .dat file and that the .dat file exists on disk.
84239>>>>>>>>>    Function _DatFileExists Handle hTable Returns Boolean
84241>>>>>>>>>        Boolean bExists
84241>>>>>>>>>        String sDataPath sRootName sNoDriverRootname
84241>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84244>>>>>>>>>        Get _TableNameOnly sRootName to sNoDriverRootname
84245>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84246>>>>>>>>>        File_Exist (sDataPath + "\" + sNoDriverRootname + ".dat") bExists
84247>>>>>>>>>        Function_Return bExists
84248>>>>>>>>>    End_Function
84249>>>>>>>>>    
84249>>>>>>>>>    // Does the Rootname contain a ".int" suffix.
84249>>>>>>>>>    Function _IsIntEntry Handle hTable Returns Boolean
84251>>>>>>>>>        Boolean bFound
84251>>>>>>>>>        String sRootName
84251>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84254>>>>>>>>>        Move (Lowercase(sRootName) contains ".int") to bFound
84255>>>>>>>>>        Function_Return bFound
84256>>>>>>>>>    End_Function
84257>>>>>>>>>
84257>>>>>>>>>    // Checks to see if the .int file actually exists in the Data folder.
84257>>>>>>>>>    Function _IntFileExists Handle hTable Returns Boolean
84259>>>>>>>>>        Boolean bExists bIsIntFile
84259>>>>>>>>>        String sDataPath sIntFileName
84259>>>>>>>>>        Integer iPos
84259>>>>>>>>>        
84259>>>>>>>>>        Move False to bExists
84260>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84261>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName
84264>>>>>>>>>        Get _TableNameOnly sIntFileName to sIntFileName
84265>>>>>>>>>        Move (Pos(".int", Lowercase(sIntFileName))) to iPos
84266>>>>>>>>>        If (iPos = 0) Begin
84268>>>>>>>>>            Move (sIntFileName + ".int") to sIntFileName
84269>>>>>>>>>        End
84269>>>>>>>>>>
84269>>>>>>>>>        File_Exist (sDataPath + "\" + sIntFileName) bExists
84270>>>>>>>>>        Function_Return bExists    
84271>>>>>>>>>    End_Function
84272>>>>>>>>>        
84272>>>>>>>>>    // Returns True if the hTable's RootName has a driver <> DataFlex
84272>>>>>>>>>    Function _IsSQLEntry Handle hTable Returns Boolean
84274>>>>>>>>>        Boolean bFound bIsIntFile
84274>>>>>>>>>        String sLogicalName sRootName sNoDriverRootname sDriver
84274>>>>>>>>>        
84274>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84277>>>>>>>>>        Get _DriverIDFromRootName sRootName to sDriver
84278>>>>>>>>>        Get _IsIntEntry hTable to bIsIntFile
84279>>>>>>>>>        Get _TableNameOnly sRootName to sNoDriverRootname
84280>>>>>>>>>        Move (bIsIntFile = True or sDriver <> DATAFLEX_ID) to bFound
84281>>>>>>>>>        Function_Return bFound
84282>>>>>>>>>    End_Function
84283>>>>>>>>>
84283>>>>>>>>>    // This is used in place of the DF_FILE_OPENED table attribute, because
84283>>>>>>>>>    // the table then needs to be open, which takes time.
84283>>>>>>>>>    Function _IsAliasTable Handle hTable Returns Boolean
84285>>>>>>>>>        Boolean bFound bIsIntTable
84285>>>>>>>>>        String sLogicalName sRootName sNoDriverRootname
84285>>>>>>>>>        
84285>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
84288>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84291>>>>>>>>>        Get _TableNameOnly sRootName to sNoDriverRootname
84292>>>>>>>>>        Get _IsIntEntry hTable to bIsIntTable
84293>>>>>>>>>        // Do we have an Alias table?
84293>>>>>>>>>        Move (Lowercase(sLogicalName) <> Lowercase(sNoDriverRootname)) to bFound
84294>>>>>>>>>        Function_Return bFound
84295>>>>>>>>>    End_Function
84296>>>>>>>>>
84296>>>>>>>>>    // If the SQL table cannot be opened, we do this checking a bit different.
84296>>>>>>>>>    Function _IsSystemFile Handle hTable Returns Boolean
84298>>>>>>>>>        Boolean bIsSystem bIsSQL bExists
84298>>>>>>>>>        String sRootName sDataPath sDriver
84298>>>>>>>>>        String[] asIndexes
84299>>>>>>>>>        Move False to bIsSystem
84300>>>>>>>>>        
84300>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84303>>>>>>>>>        Get _DriverIDFromRootName sRootName to sDriver
84304>>>>>>>>>        Get _TableNameOnly sRootName to sRootName
84305>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84306>>>>>>>>>        Get _IsSQLEntry hTable to bIsSQL
84307>>>>>>>>>        If (bIsSQL = False) Begin
84309>>>>>>>>>            File_Exist (sDataPath + "\" + sRootName + ".dat") bExists
84310>>>>>>>>>            If (bExists = True) Begin
84312>>>>>>>>>                Open (sDataPath + "\" + sRootName + ".dat") as hTable
84314>>>>>>>>>                Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bIsSystem 
84317>>>>>>>>>                Close hTable
84318>>>>>>>>>            End
84318>>>>>>>>>>
84318>>>>>>>>>        End 
84318>>>>>>>>>>
84318>>>>>>>>>        Else Begin
84319>>>>>>>>>            Get _SqlUtilEnumerateIndexes sRootName sDriver to asIndexes
84320>>>>>>>>>            Move (SizeOfArray(asIndexes) = 0) to bIsSystem
84321>>>>>>>>>        End
84321>>>>>>>>>>
84321>>>>>>>>>        Function_Return bIsSystem
84322>>>>>>>>>    End_Function
84323>>>>>>>>>                          
84323>>>>>>>>>    // Removes any driver prefix and any .int suffix from the Rootname
84323>>>>>>>>>    // If any driver found, it will be placed in the ByRef param: sDriver.
84323>>>>>>>>>    Function _RemoveDriverFromRootName String sRootname String ByRef sDriver Returns String
84325>>>>>>>>>        String sNoDriverRootname
84325>>>>>>>>>        Integer iPos
84325>>>>>>>>>        
84325>>>>>>>>>        Move sRootname to sNoDriverRootname
84326>>>>>>>>>        Move (Pos(":", sRootname)) to iPos
84327>>>>>>>>>        If (iPos <> 0) Begin
84329>>>>>>>>>            Move (Left(sRootname, iPos -1)) to sDriver
84330>>>>>>>>>            Move (Mid(sRootname, Length(sRootname), iPos +1)) to sNoDriverRootname    
84331>>>>>>>>>        End
84331>>>>>>>>>>
84331>>>>>>>>>        Else Begin
84332>>>>>>>>>            Move DATAFLEX_ID to sDriver
84333>>>>>>>>>        End
84333>>>>>>>>>>
84333>>>>>>>>>        Move (Pos(".int", Lowercase(sNoDriverRootname))) to iPos
84334>>>>>>>>>        If (iPos <> 0) Begin
84336>>>>>>>>>            Move (Left(sNoDriverRootname, iPos -1)) to sNoDriverRootname
84337>>>>>>>>>        End
84337>>>>>>>>>>
84337>>>>>>>>>        Function_Return sNoDriverRootname    
84338>>>>>>>>>    End_Function
84339>>>>>>>>>
84339>>>>>>>>>    Function _CountFilelistSystemTables Returns Integer
84341>>>>>>>>>        tFilelist[] FileListTables
84341>>>>>>>>>        tFilelist[] FileListTables
84342>>>>>>>>>        Integer iCount iSize iItems
84342>>>>>>>>>        
84342>>>>>>>>>        Move 0 to iItems
84343>>>>>>>>>        Get pFileListArray to FileListTables
84344>>>>>>>>>        Move (SizeOfArray(FileListTables)) to iSize
84345>>>>>>>>>        If (iSize <> 0) Begin
84347>>>>>>>>>            Decrement iSize
84348>>>>>>>>>            for iCount from 0 to iSize
84354>>>>>>>>>>
84354>>>>>>>>>                If (FileListTables[iCount].bIsSystemFile = True) Begin
84356>>>>>>>>>                    Increment iItems
84357>>>>>>>>>                End
84357>>>>>>>>>>
84357>>>>>>>>>            Loop
84358>>>>>>>>>>
84358>>>>>>>>>        End
84358>>>>>>>>>>
84358>>>>>>>>>        Function_Return iItems    
84359>>>>>>>>>    End_Function
84360>>>>>>>>>
84360>>>>>>>>>    Function _CountFileListAliasTables Returns Integer
84362>>>>>>>>>        tFilelist[] FileListTables
84362>>>>>>>>>        tFilelist[] FileListTables
84363>>>>>>>>>        Integer iCount iSize iItems
84363>>>>>>>>>        
84363>>>>>>>>>        Move 0 to iItems
84364>>>>>>>>>        Get pFileListArray to FileListTables
84365>>>>>>>>>        Move (SizeOfArray(FileListTables)) to iSize
84366>>>>>>>>>        If (iSize <> 0) Begin
84368>>>>>>>>>            Decrement iSize
84369>>>>>>>>>            for iCount from 0 to iSize
84375>>>>>>>>>>
84375>>>>>>>>>                If (FileListTables[iCount].bIsAlias = True) Begin
84377>>>>>>>>>                    Increment iItems
84378>>>>>>>>>                End
84378>>>>>>>>>>
84378>>>>>>>>>            Loop
84379>>>>>>>>>>
84379>>>>>>>>>        End
84379>>>>>>>>>>
84379>>>>>>>>>        Function_Return iItems    
84380>>>>>>>>>    End_Function
84381>>>>>>>>>
84381>>>>>>>>>    Function _CountFileListMasterTables Returns Integer
84383>>>>>>>>>        String sRootName sLogicalName sDriver sNoDriverRootname
84383>>>>>>>>>        Handle hTable
84383>>>>>>>>>        Integer iSize iItems
84383>>>>>>>>>        Boolean bIsAlias bIsIntTable
84383>>>>>>>>>        
84383>>>>>>>>>        Move 0 to iItems
84384>>>>>>>>>        Move 0 to hTable 
84385>>>>>>>>>        Repeat
84385>>>>>>>>>>
84385>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
84388>>>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin
84390>>>>>>>>>                Get _IsAliasTable hTable to bIsAlias
84391>>>>>>>>>                If (bIsAlias = False) Begin
84393>>>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84396>>>>>>>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName                    
84399>>>>>>>>>                    Get _RemoveDriverFromRootName sRootName (&sDriver) to sNoDriverRootname
84400>>>>>>>>>                    Get _IsIntEntry hTable to bIsIntTable
84401>>>>>>>>>                    If (sDriver <> DATAFLEX_ID and Lowercase(sNoDriverRootname) = Lowercase(sLogicalName)) Begin
84403>>>>>>>>>                        Increment iItems
84404>>>>>>>>>                    End
84404>>>>>>>>>>
84404>>>>>>>>>                End
84404>>>>>>>>>>
84404>>>>>>>>>            End
84404>>>>>>>>>>
84404>>>>>>>>>        Until (hTable = 0)
84406>>>>>>>>>        
84406>>>>>>>>>        Function_Return iItems
84407>>>>>>>>>    End_Function
84408>>>>>>>>>
84408>>>>>>>>>    Function _CountFileListOpenErrors Returns Integer
84410>>>>>>>>>        tFilelist[] FileListTables
84410>>>>>>>>>        tFilelist[] FileListTables
84411>>>>>>>>>        Integer iCount iSize iItems
84411>>>>>>>>>        
84411>>>>>>>>>        Move 0 to iItems
84412>>>>>>>>>        Get pFileListArray to FileListTables
84413>>>>>>>>>        Move (SizeOfArray(FileListTables)) to iSize
84414>>>>>>>>>        If (iSize <> 0) Begin
84416>>>>>>>>>            Decrement iSize
84417>>>>>>>>>            for iCount from 0 to iSize
84423>>>>>>>>>>
84423>>>>>>>>>                If (FileListTables[iCount].bErrorOpening = True) Begin
84425>>>>>>>>>                    Increment iItems
84426>>>>>>>>>                End
84426>>>>>>>>>>
84426>>>>>>>>>            Loop
84427>>>>>>>>>>
84427>>>>>>>>>        End
84427>>>>>>>>>>
84427>>>>>>>>>        Function_Return iItems    
84428>>>>>>>>>    End_Function 
84429>>>>>>>>>
84429>>>>>>>>>    // Checks all Alias Filelist entries for errors,
84429>>>>>>>>>    // and return them as a string array of RootNames.
84429>>>>>>>>>    Function _CountFileListAliasErrors Returns tFilelist[]
84431>>>>>>>>>        Integer iCount iItem
84431>>>>>>>>>        Handle hTable
84431>>>>>>>>>        Boolean bIsAlias bOK
84431>>>>>>>>>        String sRootName
84431>>>>>>>>>        tFilelist[] FileListArray
84431>>>>>>>>>        tFilelist[] FileListArray
84432>>>>>>>>>        
84432>>>>>>>>>        Move 0 to iCount
84433>>>>>>>>>        Move 0 to hTable
84434>>>>>>>>>        Repeat
84434>>>>>>>>>>
84434>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
84437>>>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin
84439>>>>>>>>>                Get _IsAliasTable hTable to bIsAlias
84440>>>>>>>>>                If (bIsAlias = True) Begin
84442>>>>>>>>>                    Get _FindAliasEntryError hTable to iItem
84443>>>>>>>>>                    If (iItem <> 0) Begin
84445>>>>>>>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84448>>>>>>>>>                        Move hTable    to FileListArray[iCount].hTable
84449>>>>>>>>>                        Move sRootName to FileListArray[iCount].sRootName
84450>>>>>>>>>                    End
84450>>>>>>>>>>
84450>>>>>>>>>                    Add iItem to iCount
84451>>>>>>>>>                End
84451>>>>>>>>>>
84451>>>>>>>>>            End
84451>>>>>>>>>>
84451>>>>>>>>>        Until (hTable = 0)
84453>>>>>>>>>        
84453>>>>>>>>>        Function_Return FileListArray
84454>>>>>>>>>    End_Function
84455>>>>>>>>>
84455>>>>>>>>>    // Helper function for _CountFileListAliasErrors.
84455>>>>>>>>>    // Checks to see if an Alias Filelist entry is correct
84455>>>>>>>>>    // What it does:
84455>>>>>>>>>    //  1. Checks that the Filelist entry is an Alias table
84455>>>>>>>>>    //  2. If an Alias, checks if the RootName points to a valid Table
84455>>>>>>>>>    Function _FindAliasEntryError Handle hTable Returns Integer
84457>>>>>>>>>        Handle hMasterTable
84457>>>>>>>>>        String sDataPath sDriver sLogicalNameAlias sRootNameAlias sNoDriverRootnameAlias sLogicalNameMaster sRootNameMaster sNoDriverRootnameMaster
84457>>>>>>>>>        Boolean bOK bFound bIsAlias bIsAliasSQL bIsMasterSQL bIsIntFile
84457>>>>>>>>>        Integer iRetval
84457>>>>>>>>>        
84457>>>>>>>>>        Get _IsAliasTable hTable to bIsAlias
84458>>>>>>>>>        If (bIsAlias = False) Begin
84460>>>>>>>>>            Function_Return 0
84461>>>>>>>>>        End
84461>>>>>>>>>>
84461>>>>>>>>>        
84461>>>>>>>>>        Move 0 to iRetval
84462>>>>>>>>>        Move False to bOK
84463>>>>>>>>>        Move False to bIsAliasSQL
84464>>>>>>>>>        Move False to bIsMasterSQL
84465>>>>>>>>>
84465>>>>>>>>>        Get _IsIntEntry hTable to bIsIntFile
84466>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootNameAlias
84469>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameAlias
84472>>>>>>>>>        Get _TableNameOnly sRootNameAlias to sNoDriverRootnameAlias
84473>>>>>>>>>        Get UtilAliasToMasterTableHandle hTable to hMasterTable
84474>>>>>>>>>        Move (hMasterTable <> 0) to bOK
84475>>>>>>>>>        If (bOK = True) Begin
84477>>>>>>>>>            Get _IsSQLEntry hTable       to bIsAliasSQL
84478>>>>>>>>>            Get _IsSQLEntry hMasterTable to bIsMasterSQL 
84479>>>>>>>>>            Move (bIsAliasSQL = bIsMasterSQL) to bOK
84480>>>>>>>>>        End
84480>>>>>>>>>>
84480>>>>>>>>>        
84480>>>>>>>>>        // Checks that the .int file exists in the Data folder
84480>>>>>>>>>        If (bIsIntFile = True) Begin
84482>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84483>>>>>>>>>            File_Exist (sDataPath + "\" + sNoDriverRootnameAlias) bOK
84484>>>>>>>>>        End
84484>>>>>>>>>>
84484>>>>>>>>>
84484>>>>>>>>>        If (bOK = False) Begin
84486>>>>>>>>>            Move 1 to iRetval
84487>>>>>>>>>        End
84487>>>>>>>>>>
84487>>>>>>>>>        Function_Return iRetval
84488>>>>>>>>>    End_Function
84489>>>>>>>>>        
84489>>>>>>>>>    // Returns the first datapath found in the psDataPath property.
84489>>>>>>>>>    // The returned path always ends with a "\"
84489>>>>>>>>>    Function psDataPathFirstPart Returns String
84491>>>>>>>>>        String sDataPath
84491>>>>>>>>>        Integer iCount
84491>>>>>>>>>
84491>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84492>>>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
84493>>>>>>>>>        If (iCount > 1) Begin
84495>>>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
84496>>>>>>>>>        End
84496>>>>>>>>>>
84496>>>>>>>>>        If (sDataPath <> "") Begin
84498>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
84499>>>>>>>>>        End
84499>>>>>>>>>>
84499>>>>>>>>>
84499>>>>>>>>>        Function_Return sDataPath
84500>>>>>>>>>    End_Function
84501>>>>>>>>>
84501>>>>>>>>>    Function psLogTextFileWithPath Returns String
84503>>>>>>>>>        String sFileName
84503>>>>>>>>>        Handle hoLogFile
84503>>>>>>>>>        Get phoLogFile to hoLogFile
84504>>>>>>>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
84505>>>>>>>>>        Function_Return sFileName
84506>>>>>>>>>    End_Function
84507>>>>>>>>>
84507>>>>>>>>>    Function phoLogFile Returns Handle
84509>>>>>>>>>        Handle hoLogFile   
84509>>>>>>>>>        Boolean bErr
84509>>>>>>>>>        
84509>>>>>>>>>        Move Err to bErr
84510>>>>>>>>>        Move 0 to hoLogFile
84511>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
84512>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
84513>>>>>>>>>        Delegate Get phoLogFile to hoLogFile
84515>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
84516>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84517>>>>>>>>>        Move bErr to Err
84518>>>>>>>>>        
84518>>>>>>>>>        Function_Return hoLogFile
84519>>>>>>>>>    End_Function
84520>>>>>>>>>
84520>>>>>>>>>    Function pnCurrentVersionUpdate Returns Number
84522>>>>>>>>>        Number nCurrentVersionUpdate
84522>>>>>>>>>
84522>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84523>>>>>>>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
84525>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84526>>>>>>>>>
84526>>>>>>>>>        Function_Return nCurrentVersionUpdate
84527>>>>>>>>>    End_Function
84528>>>>>>>>>
84528>>>>>>>>>    Procedure LogError String sText Boolean bError
84530>>>>>>>>>        Handle hoLogFile
84530>>>>>>>>>        Number nCurrentVersionUpdate
84530>>>>>>>>>
84530>>>>>>>>>        Get phoLogFile to hoLogFile
84531>>>>>>>>>        If (hoLogFile = 0) Begin
84533>>>>>>>>>            Procedure_Return
84534>>>>>>>>>        End
84534>>>>>>>>>>
84534>>>>>>>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
84535>>>>>>>>>
84535>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84536>>>>>>>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
84537>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84538>>>>>>>>>    End_Procedure
84539>>>>>>>>>
84539>>>>>>>>>    Function pbContinueOnError Returns Boolean
84541>>>>>>>>>        Boolean bContinueOnError
84541>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
84543>>>>>>>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
84544>>>>>>>>>        End
84544>>>>>>>>>>
84544>>>>>>>>>        Function_Return bContinueOnError
84545>>>>>>>>>    End_Function
84546>>>>>>>>>
84546>>>>>>>>>
84546>>>>>>>>>    Function _UtilUpdateTAGFile String sFullTAGFileName String sColumnName Returns Boolean
84548>>>>>>>>>        Integer iChIn iChOut // iCount
84548>>>>>>>>>        Boolean bExists
84548>>>>>>>>>        String sExistingColumn
84548>>>>>>>>>
84548>>>>>>>>>        Move False to bExists
84549>>>>>>>>>        Get Seq_New_Channel to iChIn
84550>>>>>>>>>        Get Seq_New_Channel to iChOut
84551>>>>>>>>>        If (iChIn = DF_SEQ_CHANNEL_NOT_AVAILABLE or iChOut = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
84553>>>>>>>>>            Function_Return True
84554>>>>>>>>>        End
84554>>>>>>>>>>
84554>>>>>>>>>
84554>>>>>>>>>        Move False to Err
84555>>>>>>>>>        // The following line should also use the channel attribute. (Thank you, Hans van de Laar)
84555>>>>>>>>>        Direct_Input channel iChIn ("'" + sFullTAGFileName + "'")
84557>>>>>>>>>        While (not(SeqEof))
84561>>>>>>>>>            Readln channel iChIn sExistingColumn
84563>>>>>>>>>            If (Uppercase(sExistingColumn) = Uppercase(sColumnName)) Begin
84565>>>>>>>>>                Move True to bExists
84566>>>>>>>>>            End
84566>>>>>>>>>>
84566>>>>>>>>>            If (Trim(sExistingColumn) = "") Begin
84568>>>>>>>>>                Move True to SeqEof
84569>>>>>>>>>            End
84569>>>>>>>>>>
84569>>>>>>>>>        Loop
84570>>>>>>>>>>
84570>>>>>>>>>        Close_Input channel iChIn
84572>>>>>>>>>        Send Seq_Release_Channel iChIn
84573>>>>>>>>>
84573>>>>>>>>>        If (bExists = False) Begin
84575>>>>>>>>>            Append_Output channel iChOut sFullTAGFileName
84577>>>>>>>>>            Writeln channel iChOut sColumnName
84580>>>>>>>>>            Close_Output channel iChOut
84582>>>>>>>>>            Send Seq_Release_Channel iChOut
84583>>>>>>>>>        End
84583>>>>>>>>>>
84583>>>>>>>>>
84583>>>>>>>>>        Function_Return (Err = False)
84584>>>>>>>>>    End_Function
84585>>>>>>>>>
84585>>>>>>>>>    // Changes source code files.
84585>>>>>>>>>    // Pass a file name with full path and a value to search for, together with the value
84585>>>>>>>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
84585>>>>>>>>>    // to use a Connection ID.
84585>>>>>>>>>    // Sample: Get _UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
84585>>>>>>>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
84585>>>>>>>>>    // Returns True if no errors occured.
84585>>>>>>>>>    Function _UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
84587>>>>>>>>>        Integer iCh iRow iItems iCount
84587>>>>>>>>>        String sValue sRow
84587>>>>>>>>>        String[] sFileArray
84588>>>>>>>>>        Boolean bExists bIsActive bFileChange
84588>>>>>>>>>
84588>>>>>>>>>        Move False to Err
84589>>>>>>>>>        Move 0 to iRow
84590>>>>>>>>>        Move False to bFileChange
84591>>>>>>>>>
84591>>>>>>>>>        If (ghoStatusPanel <> 0) Begin
84593>>>>>>>>>            Get Active_state of ghoStatusPanel to bIsActive
84594>>>>>>>>>        End
84594>>>>>>>>>>
84594>>>>>>>>>
84594>>>>>>>>>        Get vFilePathExists sFileName to bExists
84595>>>>>>>>>        If (bExists = False) Begin
84597>>>>>>>>>            If (bShowResult = True) Begin
84599>>>>>>>>>                If (bIsActive = True) Begin
84601>>>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
84602>>>>>>>>>                End
84602>>>>>>>>>>
84602>>>>>>>>>                Else Begin
84603>>>>>>>>>                    Showln "File does not exist: " sFileName
84606>>>>>>>>>                End
84606>>>>>>>>>>
84606>>>>>>>>>            End
84606>>>>>>>>>>
84606>>>>>>>>>            Function_Return False
84607>>>>>>>>>        End
84607>>>>>>>>>>
84607>>>>>>>>>
84607>>>>>>>>>        Get Seq_Open_Input_Channel sFileName to iCh
84608>>>>>>>>>        If (iCh < 1) Begin
84610>>>>>>>>>            Function_Return False
84611>>>>>>>>>        End
84611>>>>>>>>>>
84611>>>>>>>>>
84611>>>>>>>>>        If (bShowResult = True) Begin
84613>>>>>>>>>            If (ghoStatusPanel <> 0) Begin
84615>>>>>>>>>                Get Active_state of ghoStatusPanel to bIsActive
84616>>>>>>>>>                If (bIsActive = True) Begin
84618>>>>>>>>>                    Set Message_Text of ghoStatusPanel to sFileName
84619>>>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
84620>>>>>>>>>                    Send DoAdvance of ghoProgressBar
84621>>>>>>>>>                End
84621>>>>>>>>>>
84621>>>>>>>>>            End
84621>>>>>>>>>>
84621>>>>>>>>>            Else Begin
84622>>>>>>>>>                Showln ""
84624>>>>>>>>>                Showln "sFileName = " sFileName
84627>>>>>>>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
84632>>>>>>>>>            End
84632>>>>>>>>>>
84632>>>>>>>>>        End
84632>>>>>>>>>>
84632>>>>>>>>>
84632>>>>>>>>>        While (not(SeqEof))
84636>>>>>>>>>            Readln channel iCh sRow
84638>>>>>>>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
84640>>>>>>>>>                // Change the whole line to the new connection id:
84640>>>>>>>>>                Move sChangeTo to sRow 
84641>>>>>>>>>                Move True to bFileChange
84642>>>>>>>>>            End
84642>>>>>>>>>>
84642>>>>>>>>>            Move sRow to sFileArray[iRow]
84643>>>>>>>>>            Increment iRow
84644>>>>>>>>>        Loop
84645>>>>>>>>>>
84645>>>>>>>>>        Send Seq_Close_Channel iCh
84646>>>>>>>>>
84646>>>>>>>>>//        Sleep 1 // Wait for Windows to close the file
84646>>>>>>>>>
84646>>>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
84647>>>>>>>>>        If (iCh < 1) Begin
84649>>>>>>>>>            Function_Return False
84650>>>>>>>>>        End
84650>>>>>>>>>>
84650>>>>>>>>>        Move (SizeOfArray(sFileArray)) to iItems
84651>>>>>>>>>        Decrement iItems
84652>>>>>>>>>
84652>>>>>>>>>        for iCount from 0 to iItems
84658>>>>>>>>>>
84658>>>>>>>>>            Move sFileArray[iCount] to sValue
84659>>>>>>>>>            Writeln channel iCh sValue
84662>>>>>>>>>        Loop
84663>>>>>>>>>>
84663>>>>>>>>>        Send Seq_Close_Channel iCh
84664>>>>>>>>>
84664>>>>>>>>>        Function_Return bFileChange
84665>>>>>>>>>    End_Function
84666>>>>>>>>>
84666>>>>>>>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
84666>>>>>>>>>    // and opens it in "notepad.exe".
84666>>>>>>>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
84666>>>>>>>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
84666>>>>>>>>>    Procedure _UtilShowErrorList
84668>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84668>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84668>>>>>>>>>        Integer iRows iCount iCh iErrorNum
84668>>>>>>>>>        String sPath sFileName sErrorTxt sStatement
84668>>>>>>>>>
84668>>>>>>>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
84669>>>>>>>>>        Get vFolderFormat sPath to sPath
84670>>>>>>>>>        Move "SQLErrorLog.txt"  to sFileName
84671>>>>>>>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
84672>>>>>>>>>            Get paSqlErrorArray to aSqlErrorArray
84673>>>>>>>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
84674>>>>>>>>>            If (iRows > 0) Begin
84676>>>>>>>>>                Decrement iRows
84677>>>>>>>>>                for iCount from 0 to iRows
84683>>>>>>>>>>
84683>>>>>>>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
84684>>>>>>>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
84685>>>>>>>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
84686>>>>>>>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
84692>>>>>>>>>                    Writeln channel iCh "SQL Statement: " sStatement
84696>>>>>>>>>                Loop
84697>>>>>>>>>>
84697>>>>>>>>>            End
84697>>>>>>>>>>
84697>>>>>>>>>        Send Seq_Close_Channel iCh
84698>>>>>>>>>
84698>>>>>>>>>        If (iRows > 0) Begin
84700>>>>>>>>>            Runprogram Shell Background (sPath + sFileName)
84701>>>>>>>>>        End
84701>>>>>>>>>>
84701>>>>>>>>>    End_Procedure
84702>>>>>>>>>
84702>>>>>>>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
84702>>>>>>>>>    // and the table needs to exist as an SQL table.
84702>>>>>>>>>    Function _UtilTableIsSql Handle hTable Returns Boolean
84704>>>>>>>>>        String sRootName sDriverID
84704>>>>>>>>>        Boolean bIsSQL
84704>>>>>>>>>
84704>>>>>>>>>        Move False to bIsSQL
84705>>>>>>>>>        If (hTable > 0) Begin
84707>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84710>>>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQL
84711>>>>>>>>>            If (bIsSQL = True) Begin
84713>>>>>>>>>                Get psDriverID to sDriverID
84714>>>>>>>>>                Get _TableNameOnly sRootName to sRootName
84715>>>>>>>>>                Get _SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
84716>>>>>>>>>            End
84716>>>>>>>>>>
84716>>>>>>>>>        End
84716>>>>>>>>>>
84716>>>>>>>>>
84716>>>>>>>>>        Function_Return bIsSQL
84717>>>>>>>>>    End_Function
84718>>>>>>>>>
84718>>>>>>>>>    // Note: This version uses the pasSQLDataTables array(!)
84718>>>>>>>>>    //       Thus that property needs to have been initialized before
84718>>>>>>>>>    //       calling this function.
84718>>>>>>>>>    Function _UtilTableIsSql_Ex Handle hTable Returns Boolean
84720>>>>>>>>>        String sRootName sDriverID
84720>>>>>>>>>        Boolean bIsSQL
84720>>>>>>>>>
84720>>>>>>>>>        Move False to bIsSQL
84721>>>>>>>>>        If (hTable > 0) Begin
84723>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84726>>>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQL
84727>>>>>>>>>            If (bIsSQL = True) Begin
84729>>>>>>>>>                Get psDriverID to sDriverID
84730>>>>>>>>>                Get _TableNameOnly sRootName to sRootName
84731>>>>>>>>>                Get _SqlUtilCheckIfTableNameExists_Ex sRootName sDriverID to bIsSQL
84732>>>>>>>>>            End
84732>>>>>>>>>>
84732>>>>>>>>>        End
84732>>>>>>>>>>
84732>>>>>>>>>
84732>>>>>>>>>        Function_Return bIsSQL
84733>>>>>>>>>    End_Function
84734>>>>>>>>>
84734>>>>>>>>>    Function _UtilTableIsSqlByRootName String sRootName Returns Boolean
84736>>>>>>>>>        Boolean bIsSQL
84736>>>>>>>>>        Move (sRootName contains ":") to bIsSQL
84737>>>>>>>>>        Function_Return bIsSQL
84738>>>>>>>>>    End_Function
84739>>>>>>>>>
84739>>>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
84739>>>>>>>>>    Function _SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
84741>>>>>>>>>        String sDatabase sSchema sVal
84741>>>>>>>>>        Boolean bExists
84741>>>>>>>>>        String[] asTablesArray
84742>>>>>>>>>        Integer iItem
84742>>>>>>>>>
84742>>>>>>>>>        Move False to bExists
84743>>>>>>>>>        Get psDatabase to sDatabase
84744>>>>>>>>>        Get psSchema   to sSchema
84745>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDatabase = "") Begin
84747>>>>>>>>>            Error DFERR_PROGRAM ("Function _SqlUtilCheckIfTableNameExists: psDatabase =" * String(sDatabase) * "psDriver =" * String(sDriverID))
84748>>>>>>>>>>
84748>>>>>>>>>            Function_Return False
84749>>>>>>>>>        End
84749>>>>>>>>>>
84749>>>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to asTablesArray
84750>>>>>>>>>        Move (SearchArray(sTableName, asTablesArray, Desktop, (RefFunc(DFSTRICMP)))) to iItem
84751>>>>>>>>>        If (iItem <> -1) Begin
84753>>>>>>>>>            Move True to bExists
84754>>>>>>>>>        End
84754>>>>>>>>>>
84754>>>>>>>>>        Function_Return bExists
84755>>>>>>>>>    End_Function
84756>>>>>>>>>
84756>>>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
84756>>>>>>>>>    // This alternative is much faster as it first enumerates all SQL tables
84756>>>>>>>>>    Function _SqlUtilCheckIfTableNameExists_Ex String sTableName String sDriverID Returns Boolean
84758>>>>>>>>>        String sDatabase sSchema sVal
84758>>>>>>>>>        Boolean bExists
84758>>>>>>>>>        String[] asTablesArray
84759>>>>>>>>>        Integer iItem
84759>>>>>>>>>
84759>>>>>>>>>        Move False to bExists
84760>>>>>>>>>        Get psDatabase to sDatabase
84761>>>>>>>>>        Get psSchema   to sSchema
84762>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDatabase = "") Begin
84764>>>>>>>>>            Error DFERR_PROGRAM ("Function _SqlUtilCheckIfTableNameExists: psDatabase =" * String(sDatabase) * "psDriver =" * String(sDriverID))
84765>>>>>>>>>>
84765>>>>>>>>>            Function_Return False
84766>>>>>>>>>        End
84766>>>>>>>>>>
84766>>>>>>>>>        Get pasSQLDataTables to asTablesArray
84767>>>>>>>>>        Move (SearchArray(sTableName, asTablesArray, Desktop, (RefFunc(DFSTRICMP)))) to iItem
84768>>>>>>>>>        If (iItem <> -1) Begin
84770>>>>>>>>>            Move True to bExists
84771>>>>>>>>>        End
84771>>>>>>>>>>
84771>>>>>>>>>        Function_Return bExists
84772>>>>>>>>>    End_Function
84773>>>>>>>>>
84773>>>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
84773>>>>>>>>>    // that the embedded .dat file exists on disk.
84773>>>>>>>>>    Function _UtilTableIsEmbedded Handle hTable Returns Boolean
84775>>>>>>>>>        Boolean bExists bIsEmbedded
84775>>>>>>>>>        String sDataPath sRootName
84775>>>>>>>>>
84775>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
84776>>>>>>>>>        If (bExists = False) Begin
84778>>>>>>>>>            Function_Return False
84779>>>>>>>>>        End
84779>>>>>>>>>>
84779>>>>>>>>>
84779>>>>>>>>>        Move False to bIsEmbedded
84780>>>>>>>>>        If (hTable > 0) Begin
84782>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84785>>>>>>>>>            Move (not(sRootName contains ":")) to bIsEmbedded
84786>>>>>>>>>        End
84786>>>>>>>>>>
84786>>>>>>>>>        If (bIsEmbedded = True) Begin
84788>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84789>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
84790>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bIsEmbedded
84791>>>>>>>>>        End
84791>>>>>>>>>>
84791>>>>>>>>>
84791>>>>>>>>>        Function_Return bIsEmbedded
84792>>>>>>>>>    End_Function
84793>>>>>>>>>
84793>>>>>>>>>    // Returns the DateTime of the passed file name was modified, with seconds (only) precision.
84793>>>>>>>>>    Function FileModTime String sFileName Returns DateTime
84795>>>>>>>>>        Date dDate
84795>>>>>>>>>        Integer iYY iHH iMM iSS
84795>>>>>>>>>        Boolean bExists
84795>>>>>>>>>        DateTime dtFileDateTime
84795>>>>>>>>>
84795>>>>>>>>>        Move (NullDateTime()) to dtFileDateTime
84796>>>>>>>>>        Get vFilePathExists sFileName to bExists
84797>>>>>>>>>        If (bExists = True) Begin
84799>>>>>>>>>            Get_File_Mod_Time sFileName to dDate iHH iMM iSS
84803>>>>>>>>>            Move dDate            to dtFileDateTime
84804>>>>>>>>>            Move (DateGetYear       (dtFileDateTime))      to iYY
84805>>>>>>>>>            Move (DateSetYear       (dtFileDateTime, iYY)) to dtFileDateTime
84806>>>>>>>>>            Move (DateSetHour       (dtFileDateTime, iHH)) to dtFileDateTime
84807>>>>>>>>>            Move (DateSetMinute     (dtFileDateTime, iMM)) to dtFileDateTime
84808>>>>>>>>>            Move (DateSetSecond     (dtFileDateTime, iSS)) to dtFileDateTime
84809>>>>>>>>>            Move (DateSetMillisecond(dtFileDateTime, 0))   to dtFileDateTime
84810>>>>>>>>>        End
84810>>>>>>>>>>
84810>>>>>>>>>
84810>>>>>>>>>        Function_Return dtFileDateTime
84811>>>>>>>>>    End_Function
84812>>>>>>>>>
84812>>>>>>>>>    // Returns True if the file passed as sFileName1 is newer than sFileName2.
84812>>>>>>>>>    Function IsFileTimeNewer String sFileName1 String sFileName2 Returns Boolean
84814>>>>>>>>>        Boolean bExists bIsNewer
84814>>>>>>>>>        DateTime dtFileDateTime1 dtFileDateTime2
84814>>>>>>>>>
84814>>>>>>>>>        Move False to bIsNewer
84815>>>>>>>>>        Get vFilePathExists sFileName1 to bExists
84816>>>>>>>>>        If (bExists = True) Begin
84818>>>>>>>>>            Get FileModTime sFileName1  to dtFileDateTime1
84819>>>>>>>>>            Get FileModTime sFileName2  to dtFileDateTime2
84820>>>>>>>>>            Move (dtFileDateTime1 > dtFileDateTime2) to bIsNewer
84821>>>>>>>>>        End
84821>>>>>>>>>>
84821>>>>>>>>>        Function_Return bIsNewer
84822>>>>>>>>>    End_Function
84823>>>>>>>>>
84823>>>>>>>>>End_Class
84824>>>>>>>
84824>>>>>>>Register_Function pbExitIfDebuggerActive Returns Boolean
84824>>>>>>>Class cDbUpdateFunctionLibrary is a cBaseDbUpdateFuncLib
84825>>>>>>>
84825>>>>>>>    Procedure Construct_Object
84827>>>>>>>        Forward Send Construct_Object
84829>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
84830>>>>>>>    End_Procedure
84831>>>>>>>
84831>>>>>>>    Procedure End_Construct_Object
84833>>>>>>>        Forward Send End_Construct_Object
84835>>>>>>>    End_Procedure
84836>>>>>>>
84836>>>>>>>    // *** SQL Messages for making changes to the SQL back-end ***
84836>>>>>>>    //
84836>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84836>>>>>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
84838>>>>>>>        Function_Return False
84839>>>>>>>    End_Function
84840>>>>>>>
84840>>>>>>>    // Function for creating a new *Database*.
84840>>>>>>>    // Note: This is for creating SQL DATABASES - not tables!
84840>>>>>>>    // Returns True if successful.
84840>>>>>>>    // ToDo: Currently only works for MS-SQL...
84840>>>>>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
84842>>>>>>>        String sSQL sSQL1 sConnectionID sConnectionString
84842>>>>>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
84842>>>>>>>        Handle hConnection hStmt hoSQLManager
84842>>>>>>>        Integer iFetchResult iDbType
84842>>>>>>>        Boolean bOK bExists
84842>>>>>>>
84842>>>>>>>        Get piDbType to iDbType
84843>>>>>>>        If (iDbType <> EN_DbTypeMSSQL and iDbType <> EN_DbTypeDB2 and iDbType <> EN_DbTypeMySQL and iDbType <> EN_DbTypePostgre) Begin
84845>>>>>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL, MySQL & PostGre and DB2 drivers"
84846>>>>>>>>
84846>>>>>>>            Function_Return False
84847>>>>>>>        End
84847>>>>>>>>
84847>>>>>>>
84847>>>>>>>        Get SqlUtilCheckIfDatabaseExists sDatabase to bExists
84848>>>>>>>        If (bExists = True) Begin
84850>>>>>>>            Function_Return True
84851>>>>>>>        End
84851>>>>>>>>
84851>>>>>>>
84851>>>>>>>        Get phoSQLManager to hoSQLManager
84852>>>>>>>
84852>>>>>>>        Get psConnectionID     to sConnectionID
84853>>>>>>>        Get psConnectionString to sConnectionString
84854>>>>>>>        Move 0 to LastErr
84855>>>>>>>
84855>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
84857>>>>>>>            // If an ODBC data source (DSN) we cannot pass the UID & PWD; so strip them from the connection string.
84857>>>>>>>            // ToDo: 2018-08-11 I think this is wrong and the uid & pw should be there.
84857>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
84857>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
84857>>>>>>>//                If (iPos > 0) Begin
84857>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
84857>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
84857>>>>>>>//                End
84857>>>>>>>//            End
84857>>>>>>>        End
84857>>>>>>>>
84857>>>>>>>
84857>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84858>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84859>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84860>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84862>>>>>>>            Error DFERR_PROGRAM (CS_DUF_LoginToDbServerFailed + "\n" + sConnectionString)
84863>>>>>>>>
84863>>>>>>>            Function_Return False
84864>>>>>>>        End
84864>>>>>>>>
84864>>>>>>>
84864>>>>>>>        Get SqlOpen of hConnection to hStmt
84865>>>>>>>
84865>>>>>>>        If (hStmt = 0) Begin
84867>>>>>>>            Send SqlDisconnect of hoSQLManager
84868>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
84869>>>>>>>>
84869>>>>>>>            Function_Return False
84870>>>>>>>        End
84870>>>>>>>>
84870>>>>>>>
84870>>>>>>>        Get psCollation to sCollation
84871>>>>>>>
84871>>>>>>>        Case Begin
84871>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
84873>>>>>>>                Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
84874>>>>>>>                Get _SqlSelectFromWhereName to sSelectFromWhereName
84875>>>>>>>                Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
84876>>>>>>>
84876>>>>>>>                // Check if database exists
84876>>>>>>>                Send SqlExecDirect of hStmt sSQL
84877>>>>>>>                Get SqlFetch of hStmt to iFetchResult
84878>>>>>>>                Send SqlClose of hStmt
84879>>>>>>>                Send SqlDisconnect of hConnection
84880>>>>>>>                // If database already exists we're out of here!
84880>>>>>>>                // Note that we return True as this is not an error.
84880>>>>>>>                If (iFetchResult > 0) Begin
84882>>>>>>>                    Function_Return True
84883>>>>>>>                End
84883>>>>>>>>
84883>>>>>>>                // Database doesn't exist, create it.
84883>>>>>>>                If (iFetchResult = 0) Begin
84885>>>>>>>                    Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
84886>>>>>>>                    Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84887>>>>>>>                    If (sCollation <> "") Begin
84889>>>>>>>                        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
84890>>>>>>>                        Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
84891>>>>>>>                    End
84891>>>>>>>>
84891>>>>>>>                    Send SqlUtilExecuteQuery sSQL1 sDriverID
84892>>>>>>>                    Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84893>>>>>>>                    If (LastErr = CLIERR_GENERAL_ERROR) Begin
84895>>>>>>>                        Function_Return False
84896>>>>>>>                    End
84896>>>>>>>>
84896>>>>>>>                    // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
84896>>>>>>>                    Sleep 1
84897>>>>>>>                    Send SqlUtilExecuteQuery sSQL sDriverID
84898>>>>>>>                End
84898>>>>>>>>
84898>>>>>>>                Case Break
84899>>>>>>>
84899>>>>>>>            Case (iDbType = EN_DbTypeMySQL and sDriverID = ODBC_DRV_ID)
84902>>>>>>>                // ToDo: How should this be set/checked?
84902>>>>>>>//                If (Lowercase(Left(sCollation, 3)) <> "utf") Begin
84902>>>>>>>//                    Set psCollation to "utf8"
84902>>>>>>>//                End
84902>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreateMySQLDatabase.sql as CreateMySQLDatabase.sql
84902>>>>>>>                Get _SqlUtilCreateMySQLDatabaseByScript "CreateMySQLDatabase.sql" sDatabase to bOK
84903>>>>>>>                Case Break
84904>>>>>>>
84904>>>>>>>            Case Else
84904>>>>>>>                Error DFERR_PROGRAM "Unsupported database type"
84905>>>>>>>>
84905>>>>>>>        Case End
84905>>>>>>>
84905>>>>>>>        If (Err = False) Begin
84907>>>>>>>            Send LogError ("The Database:" * String(sDatabase) * "was created successfully for driver:" * String(sDriverID)) False
84908>>>>>>>        End
84908>>>>>>>>
84908>>>>>>>        // If used in e.g. the cDbUpdateHandler we want to change the login database name to
84908>>>>>>>        // the one we just created.
84908>>>>>>>        If (bUpdateConnectionString = True and Err = False) Begin
84910>>>>>>>            Set psDatabase to sDatabase
84911>>>>>>>            //...and perhaps also the SQLConnections.ini file setting.
84911>>>>>>>            If (bPermanantly = True) Begin
84913>>>>>>>                If (ghoSQLConnectionHandler <> 0) Begin
84915>>>>>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
84916>>>>>>>                End
84916>>>>>>>>
84916>>>>>>>            End
84916>>>>>>>>
84916>>>>>>>        End
84916>>>>>>>>
84916>>>>>>>
84916>>>>>>>        Function_Return (Err = False)
84917>>>>>>>    End_Function
84918>>>>>>>
84918>>>>>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
84918>>>>>>>    // will be used.
84918>>>>>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
84920>>>>>>>        Boolean bOK bExists bShowProgress bErr
84920>>>>>>>        String sStatement sDriverID
84920>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84920>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84920>>>>>>>        Integer iDbType
84920>>>>>>>
84920>>>>>>>        If (sDatabase = "") Begin
84922>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84923>>>>>>>>
84923>>>>>>>            Function_Return False
84924>>>>>>>        End
84924>>>>>>>>
84924>>>>>>>        If (sBackupName = "") Begin
84926>>>>>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84927>>>>>>>>
84927>>>>>>>            Function_Return False
84928>>>>>>>        End
84928>>>>>>>>
84928>>>>>>>
84928>>>>>>>        // Create backup-folder if it doesn't exist
84928>>>>>>>        Get vFolderExists sPath to bExists
84929>>>>>>>        If (bExists = False) Begin
84931>>>>>>>            Get vCreateDirectory sPath to bErr
84932>>>>>>>            If (bErr = True) Begin
84934>>>>>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
84935>>>>>>>>
84935>>>>>>>                Function_Return False
84936>>>>>>>            End
84936>>>>>>>>
84936>>>>>>>        End
84936>>>>>>>>
84936>>>>>>>        // Make sure the path ends with a back-slash
84936>>>>>>>        If (sPath <> "") Begin
84938>>>>>>>            Get vFolderFormat sPath to sPath
84939>>>>>>>        End
84939>>>>>>>>
84939>>>>>>>
84939>>>>>>>        Get psDriverID to sDriverID
84940>>>>>>>        Get piDbType   to iDbType
84941>>>>>>>        If (num_arguments > 3) Begin
84943>>>>>>>            Move bShowProg to bShowProgress
84944>>>>>>>        End
84944>>>>>>>>
84944>>>>>>>
84944>>>>>>>        Case Begin
84944>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84946>>>>>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
84946>>>>>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
84946>>>>>>>                Get _SqlUtilReadResource  "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
84947>>>>>>>                Get _SqlUtilReadResource "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
84948>>>>>>>
84948>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84949>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
84950>>>>>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
84951>>>>>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
84952>>>>>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
84953>>>>>>>                Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" bShowProgress to bOK
84954>>>>>>>                Case Break
84955>>>>>>>            Case Else
84955>>>>>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
84956>>>>>>>        Case End
84956>>>>>>>
84956>>>>>>>        Function_Return bOK
84957>>>>>>>    End_Function
84958>>>>>>>
84958>>>>>>>    Function SqlDatabaseCollationQuery String sDatabase Boolean bSilent Returns String
84960>>>>>>>        String sStatement sDriverID sRetval //sPrevious
84960>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84960>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84960>>>>>>>        Integer iDbType iRows iFetchResult //iColumn
84960>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
84960>>>>>>>        tSQLConnection SQLConnection
84960>>>>>>>        tSQLConnection SQLConnection
84960>>>>>>>
84960>>>>>>>        If (sDatabase = "") Begin
84962>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
84963>>>>>>>>
84963>>>>>>>            Function_Return ""
84964>>>>>>>        End
84964>>>>>>>>
84964>>>>>>>
84964>>>>>>>        Move "" to sRetval
84965>>>>>>>        Get psDriverID to sDriverID
84966>>>>>>>        Get piDbType   to iDbType
84967>>>>>>>
84967>>>>>>>        Case Begin
84967>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84969>>>>>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
84969>>>>>>>                Get _SqlUtilReadResource "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
84970>>>>>>>
84970>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84971>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
84972>>>>>>>                Get phoSQLManager to hoSQLHandler
84973>>>>>>>
84973>>>>>>>                If (hoSQLHandler <> 0) Begin
84975>>>>>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
84976>>>>>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
84977>>>>>>>
84977>>>>>>>                    If (hoSQLConnect <> 0) Begin
84979>>>>>>>                        Get SQLOpen of hoSQLConnect to hstmt
84980>>>>>>>                        If (hstmt <> 0) Begin
84982>>>>>>>                            Send SqlExecDirect of hstmt sStatement
84983>>>>>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
84984>>>>>>>                            Get SQLFetch of hstmt to iFetchResult
84985>>>>>>>                            If (iFetchResult <> 0) Begin
84987>>>>>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
84988>>>>>>>                            End
84988>>>>>>>>
84988>>>>>>>                            Send SQLClose of hstmt
84989>>>>>>>                        End
84989>>>>>>>>
84989>>>>>>>                        Send SQLDisconnect of hoSQLConnect
84990>>>>>>>                    End
84990>>>>>>>>
84990>>>>>>>                End
84990>>>>>>>>
84990>>>>>>>                Case Break
84991>>>>>>>            Case Else
84991>>>>>>>                If (bSilent = False) Begin
84993>>>>>>>                    Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for this driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
84994>>>>>>>                End
84994>>>>>>>>
84994>>>>>>>        Case End
84994>>>>>>>
84994>>>>>>>        Function_Return sRetval
84995>>>>>>>    End_Function
84996>>>>>>>
84996>>>>>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
84998>>>>>>>        String sDriverID sSQL sConnectionID sConnectionString sSet sWith // sSQL1 
84998>>>>>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
84998>>>>>>>        Handle hConnection hStmt hoSQLManager
84998>>>>>>>        Integer iDbType // iFetchResult
84998>>>>>>>
84998>>>>>>>        If (sDatabase = "") Begin
85000>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
85001>>>>>>>>
85001>>>>>>>            Function_Return False
85002>>>>>>>        End
85002>>>>>>>>
85002>>>>>>>
85002>>>>>>>        If (sSQLCollation = "") Begin
85004>>>>>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
85005>>>>>>>>
85005>>>>>>>            Function_Return False
85006>>>>>>>        End
85006>>>>>>>>
85006>>>>>>>
85006>>>>>>>        Get psDriverID to sDriverID
85007>>>>>>>        Get piDbType   to iDbType
85008>>>>>>>
85008>>>>>>>        Get phoSQLManager to hoSQLManager
85009>>>>>>>        Get psConnectionID     to sConnectionID
85010>>>>>>>        Get psConnectionString to sConnectionString
85011>>>>>>>        Move 0 to LastErr
85012>>>>>>>
85012>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
85013>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
85014>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
85015>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
85017>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
85018>>>>>>>>
85018>>>>>>>            Function_Return False
85019>>>>>>>        End
85019>>>>>>>>
85019>>>>>>>
85019>>>>>>>        Get SqlOpen of hConnection to hStmt
85020>>>>>>>
85020>>>>>>>        If (hStmt = 0) Begin
85022>>>>>>>            Send SqlDisconnect of hoSQLManager
85023>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
85024>>>>>>>>
85024>>>>>>>            Function_Return False
85025>>>>>>>        End
85025>>>>>>>>
85025>>>>>>>
85025>>>>>>>        // Check if collation already exists
85025>>>>>>>        Get SqlDatabaseCollationQuery sDatabase False to sSQLCollationCheck
85026>>>>>>>        // If the current collate is the same as the new; do nothing.
85026>>>>>>>        If (sSQLCollation = sSQLCollationCheck) Begin
85028>>>>>>>            Function_Return True
85029>>>>>>>        End
85029>>>>>>>>
85029>>>>>>>
85029>>>>>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
85030>>>>>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
85031>>>>>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
85032>>>>>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
85033>>>>>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
85034>>>>>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
85035>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
85036>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
85037>>>>>>>
85037>>>>>>>        // MS-SQL Syntax:
85037>>>>>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
85037>>>>>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
85037>>>>>>>        // ALTER DATABASE [database] SET MULTI_USER;
85037>>>>>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
85038>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
85039>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
85040>>>>>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
85040>>>>>>>
85040>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85041>>>>>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
85042>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85043>>>>>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
85045>>>>>>>           Function_Return False
85046>>>>>>>        End
85046>>>>>>>>
85046>>>>>>>
85046>>>>>>>        Function_Return (Err = False)
85047>>>>>>>    End_Function
85048>>>>>>>
85048>>>>>>>
85048>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85048>>>>>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
85050>>>>>>>        Function_Return False
85051>>>>>>>    End_Function
85052>>>>>>>
85052>>>>>>>    // Converts from SQL to Embedded (DataFlex .dat files).
85052>>>>>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
85052>>>>>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
85052>>>>>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
85052>>>>>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
85052>>>>>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
85054>>>>>>>        Handle hToTable
85054>>>>>>>        Boolean bOK bExists bOpened bCopyData
85054>>>>>>>        String sDriverID sPhysicalName sRootName sDisplayName
85054>>>>>>>        tSQLConnection SQLConnection
85054>>>>>>>        tSQLConnection SQLConnection
85054>>>>>>>        Integer iPos iMaxRecords
85054>>>>>>>
85054>>>>>>>        Get psDriverID to sDriverID
85055>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
85056>>>>>>>        If (bExists = False) Begin
85058>>>>>>>            Function_Return False
85059>>>>>>>        End
85059>>>>>>>>
85059>>>>>>>
85059>>>>>>>        If (num_arguments > 1) Begin
85061>>>>>>>            Move bCpyDat to bCopyData
85062>>>>>>>        End
85062>>>>>>>>
85062>>>>>>>        Else Begin
85063>>>>>>>            Move False to bCopyData
85064>>>>>>>        End
85064>>>>>>>>
85064>>>>>>>
85064>>>>>>>        Open hTable
85066>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85069>>>>>>>        If (bOpened = False) Begin
85071>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
85072>>>>>>>>
85072>>>>>>>            Function_Return False
85073>>>>>>>        End
85073>>>>>>>>
85073>>>>>>>        Move 0 to hToTable
85074>>>>>>>
85074>>>>>>>        Move 16711679 to iMaxRecords
85075>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85078>>>>>>>        Move (Pos(".", sDisplayName)) to iPos
85079>>>>>>>        If (iPos > 0) Begin
85081>>>>>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
85082>>>>>>>        End
85082>>>>>>>>
85082>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85085>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
85086>>>>>>>        Move (sRootName + ".dat")                    to sPhysicalName
85087>>>>>>>
85087>>>>>>>        If (ghoProgressBar <> 0) Begin
85089>>>>>>>            Send DoAdvance of ghoProgressBar
85090>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
85091>>>>>>>        End
85091>>>>>>>>
85091>>>>>>>
85091>>>>>>>        Move False to Err
85092>>>>>>>
85092>>>>>>>        Structure_Start hToTable DATAFLEX_ID
85093>>>>>>>            Structure_Copy hTable to hToTable
85094>>>>>>>
85094>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
85097>>>>>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
85100>>>>>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
85103>>>>>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
85106>>>>>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
85109>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85110>>>>>>>
85110>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85112>>>>>>>
85112>>>>>>>        Set Action_Text of ghoStatusPanel to ""
85113>>>>>>>        Move (not(Err)) to bOK
85114>>>>>>>        If (bOK = True and bCopyData = True) Begin
85116>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
85117>>>>>>>        End
85117>>>>>>>>
85117>>>>>>>
85117>>>>>>>        // This must be after copying data...
85117>>>>>>>        If (Err = False) Begin
85119>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85122>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85125>>>>>>>        End
85125>>>>>>>>
85125>>>>>>>        Move (not(Err)) to bOK
85126>>>>>>>
85126>>>>>>>        Function_Return (bOK = True)
85127>>>>>>>    End_Function
85128>>>>>>>
85128>>>>>>>    // Creates an SQL Table at the SQL end by its filelist number;
85128>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
85128>>>>>>>    Function SqlTableCreate Integer hTable Returns Boolean
85130>>>>>>>        String sTableName sSQLString sPath sCreateTable sDriverID
85130>>>>>>>        Integer iDbType
85130>>>>>>>        Boolean bExists
85130>>>>>>>
85130>>>>>>>        Get psDriverID to sDriverID
85131>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85132>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
85133>>>>>>>        If (bExists = True) Begin
85135>>>>>>>            Function_Return False
85136>>>>>>>        End
85136>>>>>>>>
85136>>>>>>>
85136>>>>>>>        Get psDataPathFirstPart to sPath
85137>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
85138>>>>>>>
85138>>>>>>>        Get piDbType to iDbType
85139>>>>>>>        Get _SqlProperTableName sTableName to sTableName
85140>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
85141>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
85142>>>>>>>
85142>>>>>>>        Move False to Err
85143>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85144>>>>>>>
85144>>>>>>>        Function_Return (Err = False)
85145>>>>>>>    End_Function
85146>>>>>>>
85146>>>>>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
85146>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
85146>>>>>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
85148>>>>>>>        String sSQLString sPath sCreateTable sDriverID
85148>>>>>>>        Integer iDbType
85148>>>>>>>        Boolean bExists
85148>>>>>>>
85148>>>>>>>        Get psDriverID to sDriverID
85149>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
85150>>>>>>>        If (bExists = True) Begin
85152>>>>>>>            Function_Return False
85153>>>>>>>        End
85153>>>>>>>>
85153>>>>>>>
85153>>>>>>>        Get psDataPathFirstPart to sPath
85154>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
85155>>>>>>>        If (bExists = True) Begin
85157>>>>>>>            // ToDo: What should we do if an .int file already exists?
85157>>>>>>>        End
85157>>>>>>>>
85157>>>>>>>
85157>>>>>>>        Get piDbType to iDbType
85158>>>>>>>        Get _SqlProperTableName sTableName to sTableName
85159>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
85160>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
85161>>>>>>>
85161>>>>>>>        Move False to Err
85162>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85163>>>>>>>
85163>>>>>>>        Function_Return (Err = False)
85164>>>>>>>    End_Function
85165>>>>>>>    
85165>>>>>>>    // ToDo: 2019-09-23 This needs to be finilized 
85165>>>>>>>    // It resets SQL constraints after a Structure_End, if necessary.
85165>>>>>>>    Function SqlTableRecreateConstraints Handle hTable Returns Boolean
85167>>>>>>>        Boolean bOK                                                            
85167>>>>>>>        String sStatement
85167>>>>>>>        Move "ALTER TABLE [dbo].[THREADS] ADD  DEFAULT ((0)) FOR [SEGMENTS]" to sStatement
85168>>>>>>>        Function_Return bOK
85169>>>>>>>    End_Function
85170>>>>>>>    
85170>>>>>>>    // First deletes the data cache file and then drops the passed SQL table.
85170>>>>>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
85170>>>>>>>    //       else try using the SqlTableRemoveByTableName message.
85170>>>>>>>    Function SqlTableRemove Handle hTable Returns Boolean
85172>>>>>>>        String sSQLString sPath sDropTable sTableName sDriverID
85172>>>>>>>        Integer iRetval iDbType
85172>>>>>>>        Boolean bExists bOK
85172>>>>>>>
85172>>>>>>>        Get psDriverID to sDriverID
85173>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85174>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
85175>>>>>>>        If (bExists = False) Begin
85177>>>>>>>            Function_Return False
85178>>>>>>>        End
85178>>>>>>>>
85178>>>>>>>
85178>>>>>>>        Get psDataPathFirstPart to sPath
85179>>>>>>>        Get _UtilDeleteCacheFile sTableName to iRetval
85180>>>>>>>
85180>>>>>>>        Get piDbType to iDbType
85181>>>>>>>        Get _SqlProperTableName sTableName to sTableName
85182>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
85183>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
85184>>>>>>>
85184>>>>>>>        Move False to Err
85185>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85186>>>>>>>
85186>>>>>>>        // We also need to remove the cache-file since the table has been changed
85186>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85187>>>>>>>
85187>>>>>>>        Function_Return (Err = False)
85188>>>>>>>    End_Function
85189>>>>>>>
85189>>>>>>>    // First deletes the data cache file and then drops the passed data table.
85189>>>>>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
85191>>>>>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
85191>>>>>>>        Integer iRetval iDbType
85191>>>>>>>        Boolean bOK
85191>>>>>>>
85191>>>>>>>        Get psDriverID to sDriverID
85192>>>>>>>        Get psDataPathFirstPart to sPath
85193>>>>>>>        Get _UtilDeleteCacheFile sTableName to iRetval
85194>>>>>>>
85194>>>>>>>        Get piDbType to iDbType
85195>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
85196>>>>>>>        Get psSchema to sSchema
85197>>>>>>>        If (sSchema = "") Begin
85199>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
85200>>>>>>>        End
85200>>>>>>>>
85200>>>>>>>        Move (Uppercase(sTableName)) to sVal
85201>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
85203>>>>>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
85204>>>>>>>        End
85204>>>>>>>>
85204>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
85205>>>>>>>
85205>>>>>>>        Move False to Err
85206>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85207>>>>>>>
85207>>>>>>>        // We also need to remove the cache-file since the table has been changed
85207>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85208>>>>>>>
85208>>>>>>>        Function_Return (Err = False)
85209>>>>>>>    End_Function
85210>>>>>>>
85210>>>>>>>    // *** Sql View Messages ***
85210>>>>>>>
85210>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
85210>>>>>>>    Function SqlViewRemove String sDataView Returns Boolean
85212>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
85212>>>>>>>        Integer iRetval
85212>>>>>>>        Boolean bOK
85212>>>>>>>
85212>>>>>>>        Get psDriverID to sDriverID
85213>>>>>>>        Get _UtilDeleteCacheFile sDataView to iRetval
85214>>>>>>>
85214>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
85215>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
85216>>>>>>>        Set psSQLStatementString to sSQLString
85217>>>>>>>
85217>>>>>>>        // As we don't check if the view exist or not, it might happen
85217>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
85217>>>>>>>        Move False to Err
85218>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85219>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85220>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85221>>>>>>>        Move 0 to LastErr
85222>>>>>>>
85222>>>>>>>        // We also need to remove the cache-file since the table has been changed
85222>>>>>>>        Get _UtilDeleteCacheFile sDataView to bOK
85223>>>>>>>
85223>>>>>>>        Function_Return (Err = False)
85224>>>>>>>    End_Function
85225>>>>>>>
85225>>>>>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
85227>>>>>>>        Boolean bOK
85227>>>>>>>        Integer iDbType
85227>>>>>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
85227>>>>>>>
85227>>>>>>>        Get psDriverID to sDriverID
85228>>>>>>>        Get piDbType   to iDbType
85229>>>>>>>
85229>>>>>>>        Case Begin
85229>>>>>>>            Case (iDbType = EN_DbTypeDB2)
85231>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85232>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85233>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
85234>>>>>>>            Break
85235>>>>>>>
85235>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
85238>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85239>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85240>>>>>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - String(sNewtTableName) - "'") to sSQLString
85241>>>>>>>            Break
85242>>>>>>>
85242>>>>>>>            Case (iDbType = EN_DbTypeOracle)
85245>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85246>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85247>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
85248>>>>>>>            Break
85249>>>>>>>
85249>>>>>>>            Case (iDbType = EN_DbTypePostgre)
85252>>>>>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
85253>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85254>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85255>>>>>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * String(sNewtTableName)) to sSQLString
85256>>>>>>>            Break
85257>>>>>>>
85257>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
85260>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85261>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85262>>>>>>>                Move (Replaces("-", sNewtTableName, "_")) to sNewtTableName
85263>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
85264>>>>>>>            Break
85265>>>>>>>        Case End
85265>>>>>>>
85265>>>>>>>        Move False to Err
85266>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85267>>>>>>>        Move (Err = False) to bOK
85268>>>>>>>
85268>>>>>>>        Function_Return bOK
85269>>>>>>>    End_Function
85270>>>>>>>
85270>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85270>>>>>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
85272>>>>>>>        Function_Return False
85273>>>>>>>    End_Function
85274>>>>>>>
85274>>>>>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
85274>>>>>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
85276>>>>>>>        Integer iLength iDecimals
85276>>>>>>>        String sColumnValue
85276>>>>>>>        String sTableName sDriverID
85276>>>>>>>        Boolean bOK bInitializeValue
85276>>>>>>>
85276>>>>>>>        Get psDriverID to sDriverID
85277>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85278>>>>>>>        If (bOK = False) Begin
85280>>>>>>>            Function_Return False
85281>>>>>>>        End
85281>>>>>>>>
85281>>>>>>>
85281>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85282>>>>>>>        If (sTableName = "") Begin
85284>>>>>>>            Function_Return False
85285>>>>>>>        End
85285>>>>>>>>
85285>>>>>>>
85285>>>>>>>        If (num_arguments > 3) Begin
85287>>>>>>>            Move iLen     to iLength
85288>>>>>>>            Move iDec     to iDecimals
85289>>>>>>>            Move bInitVal to bInitializeValue
85290>>>>>>>            Move sColVal  to sColumnValue
85291>>>>>>>        End
85291>>>>>>>>
85291>>>>>>>
85291>>>>>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
85292>>>>>>>
85292>>>>>>>        Function_Return (bOK = True)
85293>>>>>>>    End_Function
85294>>>>>>>
85294>>>>>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
85294>>>>>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
85296>>>>>>>        Integer iDbType iLength iDecimals iDriver
85296>>>>>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
85296>>>>>>>        String sDriverID sNotNull
85296>>>>>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState
85296>>>>>>>        Handle hTable
85296>>>>>>>
85296>>>>>>>        Get psDriverID to sDriverID
85297>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85298>>>>>>>        If (bOK = False) Begin
85300>>>>>>>            Function_Return True
85301>>>>>>>        End
85301>>>>>>>>
85301>>>>>>>
85301>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
85302>>>>>>>        If (hTable = 0) Begin
85304>>>>>>>            Get NextFreeFilelistSlot to hTable
85305>>>>>>>        End
85305>>>>>>>>
85305>>>>>>>
85305>>>>>>>        Get piDbType to iDbType
85306>>>>>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
85306>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
85307>>>>>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
85309>>>>>>>            Function_Return True
85310>>>>>>>        End
85310>>>>>>>>
85310>>>>>>>
85310>>>>>>>        Get DriverIndex sDriverID to iDriver
85311>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85314>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
85317>>>>>>>
85317>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
85318>>>>>>>        If (num_arguments > 3) Begin
85320>>>>>>>            Move iLen     to iLength
85321>>>>>>>            Move iDec     to iDecimals
85322>>>>>>>            Move bInitVal to bInitializeValue
85323>>>>>>>            Move sColVal  to sColumnValue
85324>>>>>>>        End
85324>>>>>>>>
85324>>>>>>>
85324>>>>>>>        Get _SqlProperTableName sTableName   to sTableName
85325>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
85326>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
85327>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
85328>>>>>>>
85328>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
85329>>>>>>>        If (bFixed = False) Begin
85331>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
85332>>>>>>>        End
85332>>>>>>>>
85332>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
85333>>>>>>>
85333>>>>>>>        Move False to Err
85334>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85335>>>>>>>
85335>>>>>>>        If (bInitializeValue = True and Err = False) Begin
85337>>>>>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
85338>>>>>>>        End
85338>>>>>>>>
85338>>>>>>>
85338>>>>>>>        If (Err = False) Begin
85340>>>>>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
85341>>>>>>>        End
85341>>>>>>>>
85341>>>>>>>
85341>>>>>>>        Move (not(Err)) to bRetval
85342>>>>>>>
85342>>>>>>>        // We also need to remove the cache-file since the table has been changed
85342>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85343>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85346>>>>>>>
85346>>>>>>>        Function_Return bRetval
85347>>>>>>>    End_Function
85348>>>>>>>
85348>>>>>>>    // To update all current rows for a table column with a common value.
85348>>>>>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
85350>>>>>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sSqlSafe_Updates sStmt
85350>>>>>>>        Boolean bRetval bSQLDriver
85350>>>>>>>        Integer iCurrErr iDbType
85350>>>>>>>
85350>>>>>>>        Move False to bRetval
85351>>>>>>>        Get piDbType to iDbType
85352>>>>>>>        Get psDriverID to sDriverID
85353>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
85354>>>>>>>        If (bSQLDriver = False) Begin
85356>>>>>>>            Function_Return bRetval
85357>>>>>>>        End
85357>>>>>>>>
85357>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85358>>>>>>>
85358>>>>>>>        Move Err to iCurrErr
85359>>>>>>>        Move False to Err
85360>>>>>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
85361>>>>>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
85362>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
85363>>>>>>>        // If MySQL and DAW's ODBC driver is used we need to do it slightly different.
85363>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
85365>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
85366>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
85367>>>>>>>        End
85367>>>>>>>>
85367>>>>>>>        Else Begin
85368>>>>>>>            Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
85369>>>>>>>        End
85369>>>>>>>>
85369>>>>>>>
85369>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85370>>>>>>>        Move (Err = False) to bRetval
85371>>>>>>>        Move iCurrErr to Err
85372>>>>>>>
85372>>>>>>>        Function_Return bRetval
85373>>>>>>>    End_Function
85374>>>>>>>
85374>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
85374>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
85374>>>>>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
85376>>>>>>>        String sDriverID sTableName
85376>>>>>>>        Boolean bOK
85376>>>>>>>
85376>>>>>>>        Get psDriverID to sDriverID
85377>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85378>>>>>>>        If (bOK = False) Begin
85380>>>>>>>            Function_Return False
85381>>>>>>>        End
85381>>>>>>>>
85381>>>>>>>
85381>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85382>>>>>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
85383>>>>>>>
85383>>>>>>>        Function_Return (Err = False)
85384>>>>>>>    End_Function
85385>>>>>>>
85385>>>>>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
85385>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
85385>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
85385>>>>>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
85387>>>>>>>        Integer iDbType iLength iDecimals
85387>>>>>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
85387>>>>>>>        Boolean bExists bOK bFixed
85387>>>>>>>        Handle hTable
85387>>>>>>>
85387>>>>>>>        Get psDriverID to sDriverID
85388>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85389>>>>>>>        If (bOK = False) Begin
85391>>>>>>>            Function_Return False
85392>>>>>>>        End
85392>>>>>>>>
85392>>>>>>>
85392>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
85393>>>>>>>        If (hTable = 0) Begin
85395>>>>>>>            Get NextFreeFilelistSlot to hTable
85396>>>>>>>        End
85396>>>>>>>>
85396>>>>>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
85397>>>>>>>        If (bExists = False) Begin
85399>>>>>>>            Function_Return False
85400>>>>>>>        End
85400>>>>>>>>
85400>>>>>>>
85400>>>>>>>        If (num_arguments > 3) Begin
85402>>>>>>>            Move iLen to iLength
85403>>>>>>>        End
85403>>>>>>>>
85403>>>>>>>        If (num_arguments > 4) Begin
85405>>>>>>>            Move iDec to iDecimals
85406>>>>>>>        End
85406>>>>>>>>
85406>>>>>>>
85406>>>>>>>        Get piDbType to iDbType
85407>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
85408>>>>>>>
85408>>>>>>>        Move False to Err
85409>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
85410>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
85411>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
85412>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
85413>>>>>>>
85413>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
85414>>>>>>>        If (bFixed = False) Begin
85416>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
85417>>>>>>>        End
85417>>>>>>>>
85417>>>>>>>
85417>>>>>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
85418>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85419>>>>>>>
85419>>>>>>>        // We also need to remove the cache-file since the table has been changed
85419>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85420>>>>>>>
85420>>>>>>>        Function_Return (Err = False)
85421>>>>>>>    End_Function
85422>>>>>>>
85422>>>>>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
85424>>>>>>>        Boolean bOK bErr bIsSQLDriver
85424>>>>>>>        String sDriverID
85424>>>>>>>        Integer iDataType
85424>>>>>>>
85424>>>>>>>        Get psDriverID to sDriverID
85425>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
85426>>>>>>>        If (bIsSQLDriver = False) Begin
85428>>>>>>>            Function_Return False
85429>>>>>>>        End
85429>>>>>>>>
85429>>>>>>>
85429>>>>>>>        Move Err to bErr
85430>>>>>>>        Move False to bErr
85431>>>>>>>
85431>>>>>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
85431>>>>>>>        // inserts randomly character(10) and spaces, so we correct from that here:
85431>>>>>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
85432>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType
85435>>>>>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
85437>>>>>>>            Move ("[" + String(sValue) + "]") to sValue
85438>>>>>>>        End
85438>>>>>>>>
85438>>>>>>>
85438>>>>>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
85441>>>>>>>        Move (not(Err)) to bOK
85442>>>>>>>        Move bErr to Err
85443>>>>>>>
85443>>>>>>>        Function_Return bOK
85444>>>>>>>    End_Function
85445>>>>>>>
85445>>>>>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
85447>>>>>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
85447>>>>>>>        String sDriverID
85447>>>>>>>
85447>>>>>>>        Get psDriverID to sDriverID
85448>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
85449>>>>>>>        If (bIsSQLDriver = False) Begin
85451>>>>>>>            Function_Return False
85452>>>>>>>        End
85452>>>>>>>>
85452>>>>>>>
85452>>>>>>>        Move Err to bErr
85453>>>>>>>        Move False to bErr
85454>>>>>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
85457>>>>>>>        If (bNullable = bCurrentState) Begin
85459>>>>>>>            Function_Return True
85460>>>>>>>        End
85460>>>>>>>>
85460>>>>>>>
85460>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
85463>>>>>>>        If (bOpen = False) Begin
85465>>>>>>>            Get AutoConnectionIDLogin to bOK
85466>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
85467>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
85468>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85469>>>>>>>            Open hTable
85471>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
85472>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
85473>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85474>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
85477>>>>>>>        End
85477>>>>>>>>
85477>>>>>>>        If (bOpen = True) Begin
85479>>>>>>>            Structure_Start hTable sDriverID
85480>>>>>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
85483>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
85484>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85486>>>>>>>            Set Action_Text of ghoStatusPanel to ""
85487>>>>>>>        End
85487>>>>>>>>
85487>>>>>>>
85487>>>>>>>        Move (not(Err)) to bOK
85488>>>>>>>        Move bErr to Err
85489>>>>>>>
85489>>>>>>>        Function_Return bOK
85490>>>>>>>    End_Function
85491>>>>>>>
85491>>>>>>>    // Drop column by its table handle
85491>>>>>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
85493>>>>>>>        String sDriverID sTableName
85493>>>>>>>        Boolean bOK
85493>>>>>>>
85493>>>>>>>        Get psDriverID to sDriverID
85494>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85495>>>>>>>        If (bOK = False) Begin
85497>>>>>>>            Function_Return False
85498>>>>>>>        End
85498>>>>>>>>
85498>>>>>>>
85498>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85499>>>>>>>        If (sTableName = "") Begin
85501>>>>>>>            Function_Return False
85502>>>>>>>        End
85502>>>>>>>>
85502>>>>>>>
85502>>>>>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
85503>>>>>>>
85503>>>>>>>        Function_Return (bOK = True)
85504>>>>>>>    End_Function
85505>>>>>>>
85505>>>>>>>    // Drop column by its table name as a string.
85505>>>>>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
85507>>>>>>>        Integer iDbType iDriver
85507>>>>>>>        String sDriverID sStmt sAlterTable sDropColumn
85507>>>>>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
85507>>>>>>>        Handle hTable
85507>>>>>>>
85507>>>>>>>        Get psDriverID to sDriverID
85508>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85509>>>>>>>        If (bOK = False) Begin
85511>>>>>>>            Function_Return False
85512>>>>>>>        End
85512>>>>>>>>
85512>>>>>>>
85512>>>>>>>        Get DriverIndex sDriverID to iDriver
85513>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85516>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
85519>>>>>>>
85519>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
85520>>>>>>>        If (hTable <> 0) Begin
85522>>>>>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
85523>>>>>>>            If (bExists = False) Begin
85525>>>>>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85528>>>>>>>                Function_Return False
85529>>>>>>>            End
85529>>>>>>>>
85529>>>>>>>        End
85529>>>>>>>>
85529>>>>>>>
85529>>>>>>>        Get piDbType to iDbType
85530>>>>>>>        If (iDbType = EN_DbTypeMSSQL) Begin
85532>>>>>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
85533>>>>>>>            Get _UtilDeleteCacheFile sTableName to bOK
85534>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85537>>>>>>>            Function_Return bOK
85538>>>>>>>        End
85538>>>>>>>>
85538>>>>>>>
85538>>>>>>>        Move False to Err
85539>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
85540>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
85541>>>>>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
85542>>>>>>>
85542>>>>>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
85543>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85544>>>>>>>        Move (not(Err)) to bRetval
85545>>>>>>>
85545>>>>>>>        // We also need to remove the cache-file since the table has been changed
85545>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85546>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85549>>>>>>>
85549>>>>>>>        Function_Return bRetval
85550>>>>>>>    End_Function
85551>>>>>>>
85551>>>>>>>    // Rename a field/column by table handle (filelist number)
85551>>>>>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
85553>>>>>>>        String sDriverID sTableName
85553>>>>>>>        Boolean bOK
85553>>>>>>>
85553>>>>>>>        Get psDriverID to sDriverID
85554>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85555>>>>>>>        If (bOK = False) Begin
85557>>>>>>>            Function_Return False
85558>>>>>>>        End
85558>>>>>>>>
85558>>>>>>>
85558>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85559>>>>>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
85560>>>>>>>
85560>>>>>>>        Function_Return (Err = False)
85561>>>>>>>    End_Function
85562>>>>>>>
85562>>>>>>>    // Rename a field/column by table name.
85562>>>>>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
85564>>>>>>>        Integer iDbType iDataType
85564>>>>>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
85564>>>>>>>        Boolean bOK bRetval
85564>>>>>>>        Handle hTable
85564>>>>>>>
85564>>>>>>>        Move sTableName to sOrgTableName
85565>>>>>>>        Get psDriverID to sDriverID
85566>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85567>>>>>>>        If (bOK = False) Begin
85569>>>>>>>            Function_Return False
85570>>>>>>>        End
85570>>>>>>>>
85570>>>>>>>
85570>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
85571>>>>>>>        If (sVal = "") Begin
85573>>>>>>>            Function_Return False
85574>>>>>>>        End
85574>>>>>>>>
85574>>>>>>>
85574>>>>>>>        Get piDbType to iDbType
85575>>>>>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
85576>>>>>>>        Get _SqlProperTableName sTableName     to sTableName
85577>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
85578>>>>>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
85579>>>>>>>
85579>>>>>>>        Case Begin
85579>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
85581>>>>>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
85582>>>>>>>                Case Break
85583>>>>>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
85583>>>>>>>            Case (iDbType = EN_dbTypeOracle)
85586>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85587>>>>>>>                Case Break
85588>>>>>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
85588>>>>>>>            Case (iDbType = EN_dbTypeDB2)
85591>>>>>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85592>>>>>>>                Case Break
85593>>>>>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
85593>>>>>>>            Case (iDbType = EN_dbTypePostgre)
85596>>>>>>>                Move sOrgTableName to sTableName
85597>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85598>>>>>>>                Case Break
85599>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
85602>>>>>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
85602>>>>>>>                Move sOrgTableName to sTableName
85603>>>>>>>                Get psDatabase to sDatabase
85604>>>>>>>                Get UtilTableNameToHandle sTableName to hTable
85605>>>>>>>                If (hTable = 0) Begin
85607>>>>>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
85608>>>>>>>                    If (bOK = False) Begin
85610>>>>>>>                        Function_Return False
85611>>>>>>>                    End
85611>>>>>>>>
85611>>>>>>>                    Get NextFreeFilelistSlot to hTable
85612>>>>>>>                End
85612>>>>>>>>
85612>>>>>>>                Else Begin
85613>>>>>>>                    Open hTable
85615>>>>>>>                End
85615>>>>>>>>
85615>>>>>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
85616>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
85617>>>>>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
85618>>>>>>>                Case Break
85619>>>>>>>            Case Else
85619>>>>>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
85620>>>>>>>        Case End
85620>>>>>>>
85620>>>>>>>        Move False to Err
85621>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85622>>>>>>>        Move (Err = False) to bRetval
85623>>>>>>>        // We also need to remove the cache-file since the table has been changed
85623>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85624>>>>>>>
85624>>>>>>>        Function_Return bRetval
85625>>>>>>>    End_Function
85626>>>>>>>
85626>>>>>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
85628>>>>>>>        Handle hoSQLHandler hSQLConnect hStmt
85628>>>>>>>        Integer iNumCols iCount iDataType
85628>>>>>>>        String sValue
85628>>>>>>>
85628>>>>>>>        Get phoSQLManager to hoSQLHandler
85629>>>>>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
85630>>>>>>>        If (hSQLConnect <> 0) Begin
85632>>>>>>>            Get SQLOpen of hSQLConnect to hStmt
85633>>>>>>>            If (hStmt <> 0) Begin
85635>>>>>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
85636>>>>>>>
85636>>>>>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
85637>>>>>>>                For iCount from 1 to iNumCols
85643>>>>>>>>
85643>>>>>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
85644>>>>>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
85646>>>>>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
85647>>>>>>>                        Move iNumCols to iCount // We're out of here
85648>>>>>>>                    End
85648>>>>>>>>
85648>>>>>>>                Loop
85649>>>>>>>>
85649>>>>>>>
85649>>>>>>>                Send SQLClose of hStmt
85650>>>>>>>            End
85650>>>>>>>>
85650>>>>>>>            Send SQLDisconnect of hSQLConnect
85651>>>>>>>        End
85651>>>>>>>>
85651>>>>>>>
85651>>>>>>>        Function_Return iDataType
85652>>>>>>>    End_Function
85653>>>>>>>
85653>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85653>>>>>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
85655>>>>>>>        Function_Return False
85656>>>>>>>    End_Function
85657>>>>>>>
85657>>>>>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
85659>>>>>>>        String sMessage // sConnectionString
85659>>>>>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
85659>>>>>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
85659>>>>>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
85662>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
85662>>>>>>>        TimeSpan tsQuery tsFetch
85662>>>>>>>        tSqlErrorArray aSqlErrorArray
85662>>>>>>>        tSqlErrorArray aSqlErrorArray
85662>>>>>>>        Boolean bOK bShowProgress
85662>>>>>>>        tSQLConnection SQLConnection
85662>>>>>>>        tSQLConnection SQLConnection
85662>>>>>>>
85662>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85663>>>>>>>        If (bOK = False) Begin
85665>>>>>>>            Procedure_Return
85666>>>>>>>        End
85666>>>>>>>>
85666>>>>>>>
85666>>>>>>>        If (num_arguments > 2) Begin
85668>>>>>>>            Move bShowProgr to bShowProgress
85669>>>>>>>        End
85669>>>>>>>>
85669>>>>>>>
85669>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85670>>>>>>>        Get phoSQLManager to hoSqlHandler
85671>>>>>>>        Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
85672>>>>>>>        Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
85673>>>>>>>
85673>>>>>>>        If (hoSQLConnect <> 0) Begin
85675>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
85676>>>>>>>            If (hoStmt <> 0) Begin
85678>>>>>>>                // record starting date/time stamp
85678>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
85679>>>>>>>                // turn on error handling if enabled
85679>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85681>>>>>>>                    Set pbSqlError to False
85682>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
85683>>>>>>>                    Move Error_Object_Id to hoError
85684>>>>>>>                    If (ghoDbUpdateHandler <> 0) Begin
85686>>>>>>>                        Move ghoDbUpdateHandler to Error_Object_Id
85687>>>>>>>                    End
85687>>>>>>>>
85687>>>>>>>                    Else Begin
85688>>>>>>>                        Move Self to Error_Object_Id
85689>>>>>>>                    End
85689>>>>>>>>
85689>>>>>>>                End
85689>>>>>>>>
85689>>>>>>>
85689>>>>>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
85689>>>>>>>                Set psSQLStatementString to sStmt
85690>>>>>>>                Send Cursor_Wait of Cursor_Control
85691>>>>>>>                Send SqlExecDirect of hoStmt sStmt
85692>>>>>>>                Send Cursor_Ready of Cursor_Control
85693>>>>>>>
85693>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85695>>>>>>>                    Move hoError to Error_Object_Id
85696>>>>>>>                End
85696>>>>>>>>
85696>>>>>>>
85696>>>>>>>                Move 0 to iMsgs
85697>>>>>>>                Move Err to iErr
85698>>>>>>>                Move LastErr to iLastErr
85699>>>>>>>                Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
85700>>>>>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
85701>>>>>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
85702>>>>>>>                Send _SqlColumnInfo hoStmt
85703>>>>>>>                Send Ignore_Error of Error_Object_Id 12289
85704>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85705>>>>>>>                Repeat
85705>>>>>>>>
85705>>>>>>>                    Get SqlFetch of hoStmt to iFetchResult
85706>>>>>>>                    If (iFetchResult <> 0) Begin
85708>>>>>>>                        Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
85709>>>>>>>                    End
85709>>>>>>>>
85709>>>>>>>                Until (iFetchResult = 0)
85711>>>>>>>                Send Trap_Error of Error_Object_Id 12289
85712>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
85713>>>>>>>                Move iErr to Err
85714>>>>>>>                Move iLastErr to LastErr
85715>>>>>>>                Set paSQLFetchResults to aSQLFetchResults
85716>>>>>>>
85716>>>>>>>                Set piRows    to iRows
85717>>>>>>>                Set piRowType to iRowType
85718>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
85719>>>>>>>                Move (CurrentDateTime()) to dtFetchStart
85720>>>>>>>
85720>>>>>>>                If (iMsgs <> 0) Begin
85722>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
85724>>>>>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85725>>>>>>>                    End
85725>>>>>>>>
85725>>>>>>>                    For i from 1 to iMsgs
85731>>>>>>>>
85731>>>>>>>                        Get SqlGetMessage of hoStmt i to sMessage
85732>>>>>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
85733>>>>>>>                        If (bShowProgress = True) Begin
85735>>>>>>>                            If (Active_State(ghoStatusPanel)) Begin
85737>>>>>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85738>>>>>>>                            End
85738>>>>>>>>
85738>>>>>>>                            Else Begin
85739>>>>>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85741>>>>>>>                            End
85741>>>>>>>>
85741>>>>>>>                        End
85741>>>>>>>>
85741>>>>>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
85742>>>>>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
85743>>>>>>>                    Loop
85744>>>>>>>>
85744>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
85746>>>>>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85747>>>>>>>                    End
85747>>>>>>>>
85747>>>>>>>                    Set paQueryMessages to sMsg
85748>>>>>>>                End
85748>>>>>>>>
85748>>>>>>>                Else Begin
85749>>>>>>>                    If (bShowProgress = True) Begin
85751>>>>>>>                        Get paSqlErrorArray to aSqlErrorArray
85752>>>>>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
85754>>>>>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
85755>>>>>>>                            Decrement iMsgs
85756>>>>>>>                            For i from 0 to iMsgs
85762>>>>>>>>
85762>>>>>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
85765>>>>>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
85768>>>>>>>                            Loop
85769>>>>>>>>
85769>>>>>>>                        End
85769>>>>>>>>
85769>>>>>>>                    End
85769>>>>>>>>
85769>>>>>>>                End
85769>>>>>>>>
85769>>>>>>>                Move (CurrentDateTime()) to dtFetchEnd
85770>>>>>>>            End
85770>>>>>>>>
85770>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
85771>>>>>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
85772>>>>>>>            Set ptsQueryExec to tsQuery
85773>>>>>>>            Set ptsFetchResults to tsFetch
85774>>>>>>>            Send SqlClose of hoStmt
85775>>>>>>>        End
85775>>>>>>>>
85775>>>>>>>
85775>>>>>>>        Send SqlDisconnect of hoSQLConnect
85776>>>>>>>    End_Procedure
85777>>>>>>>
85777>>>>>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
85777>>>>>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
85777>>>>>>>    // Returns False if no error occured.
85777>>>>>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
85779>>>>>>>        Boolean bOK bShowProgress
85779>>>>>>>        tSQLScriptArray SQLScriptArray
85779>>>>>>>        tSQLScriptArray SQLScriptArray
85779>>>>>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
85779>>>>>>>        TimeSpan tsTotalTime
85779>>>>>>>
85779>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryStart
85780>>>>>>>        Get _SqlUtilReadResource sMemFileName to SQLScriptArray
85781>>>>>>>        If (SQLScriptArray.bError = True) Begin
85783>>>>>>>            Function_Return False
85784>>>>>>>        End
85784>>>>>>>>
85784>>>>>>>
85784>>>>>>>        If (num_arguments > 3) Begin
85786>>>>>>>            Move bShowProgr to bShowProgress
85787>>>>>>>        End
85787>>>>>>>>
85787>>>>>>>
85787>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85788>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
85789>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85790>>>>>>>
85790>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
85791>>>>>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
85792>>>>>>>        Set ptsTotalQueryTime to tsTotalTime
85793>>>>>>>
85793>>>>>>>        Function_Return bOK
85794>>>>>>>    End_Function
85795>>>>>>>
85795>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85795>>>>>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
85797>>>>>>>        Function_Return False
85798>>>>>>>    End_Function
85799>>>>>>>
85799>>>>>>>    // Does three things with auxilirary files;
85799>>>>>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
85799>>>>>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
85799>>>>>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
85799>>>>>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
85801>>>>>>>        String sDataPath sDDSrcPath sDriverID
85801>>>>>>>        Boolean bOK bExists
85801>>>>>>>        Integer iCount iCh iPos
85801>>>>>>>
85801>>>>>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
85801>>>>>>>        If (sTableName contains ".") Begin
85803>>>>>>>            Move (Pos(".", sTableName)) to iPos
85804>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
85805>>>>>>>        End
85805>>>>>>>>
85805>>>>>>>
85805>>>>>>>        Get psDriverID to sDriverID
85806>>>>>>>        Get psDataPathFirstPart to sDataPath
85807>>>>>>>        Get vFolderExists sDataPath to bOK
85808>>>>>>>        If (bOK = False) Begin
85810>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
85811>>>>>>>>
85811>>>>>>>            Function_Return False
85812>>>>>>>        End
85812>>>>>>>>
85812>>>>>>>
85812>>>>>>>        // First delete the cache file:
85812>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85813>>>>>>>
85813>>>>>>>        Get Seq_New_Channel to iCh
85814>>>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
85816>>>>>>>            Function_Return False
85817>>>>>>>        End
85817>>>>>>>>
85817>>>>>>>
85817>>>>>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
85818>>>>>>>        If (bExists = False) Begin
85820>>>>>>>            Function_Return False
85821>>>>>>>        End
85821>>>>>>>>
85821>>>>>>>
85821>>>>>>>        Get _SqlUtilUpdateIntFile hTable to bOK
85822>>>>>>>        // Add the new column name to the .tag filen (if it doesn't exist):
85822>>>>>>>        Get _UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sColumnName to bOK
85823>>>>>>>
85823>>>>>>>        // If in development environment; output new .fd file:
85823>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
85824>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
85825>>>>>>>        If (iCount > 1) Begin
85827>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
85828>>>>>>>        End
85828>>>>>>>>
85828>>>>>>>        Get vFolderExists sDDSrcPath to bExists
85829>>>>>>>        If (bExists = True) Begin
85831>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
85832>>>>>>>            Move False to Err
85833>>>>>>>            Get AutoConnectionIDLogin to bOK
85834>>>>>>>            If (hTable <> 0) Begin
85836>>>>>>>                Open hTable
85838>>>>>>>            End
85838>>>>>>>>
85838>>>>>>>            Else Begin
85839>>>>>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
85840>>>>>>>            End
85840>>>>>>>>
85840>>>>>>>
85840>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
85843>>>>>>>            If (bOK = True) Begin
85845>>>>>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
85847>>>>>>>            End
85847>>>>>>>>
85847>>>>>>>            If (Err = True) Begin
85849>>>>>>>                Move False to bOK
85850>>>>>>>            End
85850>>>>>>>>
85850>>>>>>>        End
85850>>>>>>>>
85850>>>>>>>
85850>>>>>>>        Function_Return (bOK = True)
85851>>>>>>>    End_Function
85852>>>>>>>
85852>>>>>>>    // Message for changing .int files to use connection ID's
85852>>>>>>>    //
85852>>>>>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
85852>>>>>>>    // OR changes an existing connection id to a new id.
85852>>>>>>>    // Pass the full path to the data folder and the name of the connection id (string value).
85852>>>>>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
85852>>>>>>>    Function SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult Returns String[] 
85854>>>>>>>        String sFileName sDriverID sDriverFile sConnectionString sPath
85854>>>>>>>        String[] sFilesData asFileChanges
85856>>>>>>>        Boolean bOK bCancel bChange
85856>>>>>>>        Integer iSize iCount
85856>>>>>>>
85856>>>>>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
85857>>>>>>>        Move (SizeOfArray(sFilesData))    to iSize
85858>>>>>>>        If (iSize = 0) Begin
85860>>>>>>>            If (ghoStatusPanel <> 0) Begin
85862>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
85864>>>>>>>                    Send Stop_StatusPanel of ghoStatusPanel
85865>>>>>>>                End
85865>>>>>>>>
85865>>>>>>>            End
85865>>>>>>>>
85865>>>>>>>            Send Info_Box CS_DUF_NoIntFilesFound
85866>>>>>>>            Function_Return 0
85867>>>>>>>        End
85867>>>>>>>>
85867>>>>>>>
85867>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
85868>>>>>>>        Get vFolderFormat sDataPath to sDataPath
85869>>>>>>>        Decrement iSize
85870>>>>>>>        For iCount from 0 to iSize
85876>>>>>>>>
85876>>>>>>>            Move sFilesData[iCount] to sFileName
85877>>>>>>>            If (Lowercase(sFileName) <> "mssqldrv.int" and Lowercase(sFileName) <> "db2_drv.int" and Lowercase(sFileName) <> "odbc_drv.int") Begin
85879>>>>>>>            // This makes sure that we also can change an existing connection id to something new:
85879>>>>>>>            Get _UtilChangeSourceCodeLine (sDataPath + sFileName) (CS_SERVER_NAME * CS_SERVER) (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bChange
85880>>>>>>>            If (bChange = True) Begin
85882>>>>>>>                Move sFileName to asFileChanges[SizeOfArray(asFileChanges)]
85883>>>>>>>            End
85883>>>>>>>>
85883>>>>>>>            If (ghoStatusPanel <> 0) Begin
85885>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
85887>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
85888>>>>>>>                    If (bCancel = True) Begin
85890>>>>>>>                        Send Deactivate of ghoStatusPanel
85891>>>>>>>                        Function_Return asFileChanges
85892>>>>>>>                        End
85892>>>>>>>>
85892>>>>>>>                    End
85892>>>>>>>>
85892>>>>>>>                End
85892>>>>>>>>
85892>>>>>>>            End
85892>>>>>>>>
85892>>>>>>>        Loop
85893>>>>>>>>
85893>>>>>>>
85893>>>>>>>         // ToDo: Not sure at all we want to do this automatically:
85893>>>>>>>//        Get psDriverID to sDriverID
85893>>>>>>>//         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
85893>>>>>>>//        Move "" to sFileName
85893>>>>>>>//        If (sDriverID = MSSQLDRV_ID) Begin
85893>>>>>>>//            Move "MSSQLDrv.int" to sFileName
85893>>>>>>>//        End
85893>>>>>>>//        If (sDriverID = DB2_DRV_ID) Begin
85893>>>>>>>//            Move "DB2_Drv.int" to sFileName
85893>>>>>>>//        End
85893>>>>>>>//        If (sDriverID = ODBC_DRV_ID) Begin
85893>>>>>>>//            Move "ODBC_Drv.int" to sFileName
85893>>>>>>>//        End
85893>>>>>>>//        If (sFileName <> "") Begin
85893>>>>>>>//            Move "" to sDriverFile
85893>>>>>>>//            Get_File_Path sFileName to sDriverFile
85893>>>>>>>//            Get ParseFolderName sDriverFile to sPath
85893>>>>>>>//            If (sDataPath <> sPath) Begin
85893>>>>>>>//                Move "" to sDriverFile
85893>>>>>>>//            End
85893>>>>>>>//            If (sDriverFile <> "") Begin
85893>>>>>>>//                Get psConnectionString to sConnectionString
85893>>>>>>>//                Get _UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
85893>>>>>>>//            End
85893>>>>>>>//        End     
85893>>>>>>>        
85893>>>>>>>        Function_Return asFileChanges
85894>>>>>>>    End_Function
85895>>>>>>>
85895>>>>>>>    // Checks if the database exists in SQL. Returns = True if it does.
85895>>>>>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
85897>>>>>>>        String[] sDatabaseArray
85898>>>>>>>        String sVal sServer sDriverID
85898>>>>>>>        Integer iCount iSize iPos
85898>>>>>>>        Boolean bExists
85898>>>>>>>        tSQLConnection SQLConnection
85898>>>>>>>        tSQLConnection SQLConnection
85898>>>>>>>
85898>>>>>>>        Move False to bExists
85899>>>>>>>        Get psDriverID to sDriverID
85900>>>>>>>        // DB2 doesn't have a "Database" name, so we always return True.
85900>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
85902>>>>>>>            Function_Return bExists
85903>>>>>>>        End
85903>>>>>>>>
85903>>>>>>>
85903>>>>>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
85904>>>>>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
85906>>>>>>>            Function_Return False
85907>>>>>>>        End
85907>>>>>>>>
85907>>>>>>>
85907>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85908>>>>>>>        Move SQLConnection.sServer to sServer
85909>>>>>>>
85909>>>>>>>        // Special code to handle a FILEDSN that also can contain "/"
85909>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
85911>>>>>>>            Move sDatabaseArray[0] to sVal  // Dummy!
85912>>>>>>>        End
85912>>>>>>>>
85912>>>>>>>        Else If (sServer contains "/") Begin
85915>>>>>>>            Move (Pos("/", sServer)) to iPos
85916>>>>>>>            Move (Mid(sServer, 999, (iPos +1))) to sDatabase
85917>>>>>>>        End
85917>>>>>>>>
85917>>>>>>>
85917>>>>>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
85918>>>>>>>        Decrement iSize
85919>>>>>>>        For iCount from 0 to iSize
85925>>>>>>>>
85925>>>>>>>            Move sDatabaseArray[iCount] to sVal
85926>>>>>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
85928>>>>>>>                Move True to bExists
85929>>>>>>>                If (bExists = True) Begin
85931>>>>>>>                    Move iSize to iCount // We're done.
85932>>>>>>>                End
85932>>>>>>>>
85932>>>>>>>            End
85932>>>>>>>>
85932>>>>>>>        Loop
85933>>>>>>>>
85933>>>>>>>
85933>>>>>>>        Function_Return bExists
85934>>>>>>>    End_Function
85935>>>>>>>
85935>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
85935>>>>>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
85937>>>>>>>        String sDatabase sSchema sTableName sVal
85937>>>>>>>        Boolean bExists
85937>>>>>>>        String[] sTablesArray
85938>>>>>>>        Integer iSize iCount
85938>>>>>>>
85938>>>>>>>        Move False to bExists
85939>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85940>>>>>>>        Get psDatabase to sDatabase
85941>>>>>>>        Get psSchema   to sSchema
85942>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
85943>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
85944>>>>>>>        Decrement iSize
85945>>>>>>>        For iCount from 0 to iSize
85951>>>>>>>>
85951>>>>>>>            Move sTablesArray[iCount] to sVal
85952>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85954>>>>>>>                Move True to bExists
85955>>>>>>>                Move iSize to iCount // We're done!
85956>>>>>>>            End
85956>>>>>>>>
85956>>>>>>>        Loop
85957>>>>>>>>
85957>>>>>>>
85957>>>>>>>        Function_Return bExists
85958>>>>>>>    End_Function
85959>>>>>>>
85959>>>>>>>    Function SqlUtilCheckIfTableNameSpelling String sDriverID String sDatabase String sTableName String sSchema Returns String
85961>>>>>>>        String sVal sTableSpelledCorrectly
85961>>>>>>>        Boolean bExists
85961>>>>>>>        String[] sTablesArray
85962>>>>>>>        Integer iSize iCount
85962>>>>>>>
85962>>>>>>>        Move False to bExists
85963>>>>>>>        Move sTableName to sTableSpelledCorrectly
85964>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
85965>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
85966>>>>>>>        Decrement iSize
85967>>>>>>>        For iCount from 0 to iSize
85973>>>>>>>>
85973>>>>>>>            Move sTablesArray[iCount] to sVal
85974>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85976>>>>>>>                Move sVal to sTableSpelledCorrectly
85977>>>>>>>                Move iSize to iCount // We're done!
85978>>>>>>>            End
85978>>>>>>>>
85978>>>>>>>        Loop
85979>>>>>>>>
85979>>>>>>>
85979>>>>>>>        Function_Return sTableSpelledCorrectly
85980>>>>>>>    End_Function
85981>>>>>>>
85981>>>>>>>    // ToDo: This index name function needs to be finished...
85981>>>>>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
85983>>>>>>>        String sSchema sTableName sDriverID
85983>>>>>>>        Boolean bExists
85983>>>>>>>
85983>>>>>>>        Get psDriverID to sDriverID
85984>>>>>>>        Get psSchema to sSchema
85985>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85986>>>>>>>
85986>>>>>>>        Function_Return bExists
85987>>>>>>>    End_Function
85988>>>>>>>
85988>>>>>>>    // Checks if a column/field name exists in a SQL table definition
85988>>>>>>>    // Returns True if it does
85988>>>>>>>    // Sample:
85988>>>>>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
85988>>>>>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
85990>>>>>>>        Integer iNumColumns iColumn
85990>>>>>>>        String sColumn sDriverID
85990>>>>>>>        String[] sColumnsArray
85991>>>>>>>        Boolean bExists bOK
85991>>>>>>>
85991>>>>>>>        Move False to bExists
85992>>>>>>>        Get AutoConnectionIDLogin to bOK
85993>>>>>>>        Get psDriverID to sDriverID
85994>>>>>>>
85994>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
85995>>>>>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
85996>>>>>>>        Decrement iNumColumns
85997>>>>>>>        For iColumn from 0 to iNumColumns
86003>>>>>>>>
86003>>>>>>>            Move sColumnsArray[iColumn] to sColumn
86004>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
86006>>>>>>>                Move True to bExists
86007>>>>>>>                Move iNumColumns to iColumn // We're out of here
86008>>>>>>>            End
86008>>>>>>>>
86008>>>>>>>        Loop
86009>>>>>>>>
86009>>>>>>>
86009>>>>>>>        Function_Return bExists
86010>>>>>>>    End_Function
86011>>>>>>>
86011>>>>>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
86013>>>>>>>        Integer iNumColumns iColumn iDFType iNativeType
86013>>>>>>>        Boolean bOpened bOK
86013>>>>>>>        String sColumnName sNativeTypeName
86013>>>>>>>
86013>>>>>>>        Get AutoConnectionIDLogin to bOK
86014>>>>>>>        Get OpenTableExclusive hTable to bOK
86015>>>>>>>        If (bOK = False) Begin
86017>>>>>>>            Function_Return False
86018>>>>>>>        End
86018>>>>>>>>
86018>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86021>>>>>>>        If (bOpened = False) Begin
86023>>>>>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
86024>>>>>>>>
86024>>>>>>>            Function_Return False
86025>>>>>>>        End
86025>>>>>>>>
86025>>>>>>>
86025>>>>>>>        Move False to Err
86026>>>>>>>
86026>>>>>>>        Structure_Start hTable
86027>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
86030>>>>>>>
86030>>>>>>>            For iColumn from 1 to iNumColumns
86036>>>>>>>>
86036>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
86039>>>>>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
86042>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
86045>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
86048>>>>>>>
86048>>>>>>>                Case Begin
86048>>>>>>>                    Case (iDFType = DF_DATE)
86050>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
86052>>>>>>>                            // Convert datetime to date
86052>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
86055>>>>>>>                        End
86055>>>>>>>>
86055>>>>>>>                        Case Break
86056>>>>>>>                    Case (iDFType = DF_DATETIME)
86059>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
86061>>>>>>>                            // Convert datetime to datetime2
86061>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
86064>>>>>>>                        End
86064>>>>>>>>
86064>>>>>>>                        Case Break
86065>>>>>>>                    Case (iDFType = DF_ASCII)
86068>>>>>>>                        If (iNativeType = SQL_CHAR) Begin
86070>>>>>>>                            // Convert char to varchar
86070>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
86073>>>>>>>                        End
86073>>>>>>>>
86073>>>>>>>                        Case Break
86074>>>>>>>                    Case (iDFType = DF_TEXT)
86077>>>>>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
86079>>>>>>>                            // Convert text to varchar(max)
86079>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
86082>>>>>>>                        End
86082>>>>>>>>
86082>>>>>>>                        Case Break
86083>>>>>>>                    Case (iDFType = DF_BINARY)
86086>>>>>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
86088>>>>>>>                            // Convert image to varbinary(max)
86088>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
86091>>>>>>>                        End
86091>>>>>>>>
86091>>>>>>>                        Case Break
86092>>>>>>>                Case End
86092>>>>>>>            Loop
86093>>>>>>>>
86093>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86094>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86096>>>>>>>
86096>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86097>>>>>>>        Function_Return (Err = False)
86098>>>>>>>    End_Function
86099>>>>>>>
86099>>>>>>>
86099>>>>>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
86099>>>>>>>    // the DbUpdateVersion database revision in.
86099>>>>>>>    // Also pass the file number of the current (embedded?) table number used in development.
86099>>>>>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
86099>>>>>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
86101>>>>>>>        Boolean bOK bOpened
86101>>>>>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
86101>>>>>>>
86101>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
86104>>>>>>>        Get _TableNameOnly sTableName to sTableName
86105>>>>>>>        If (sTableName = "") Begin
86107>>>>>>>            Function_Return False
86108>>>>>>>        End
86108>>>>>>>>
86108>>>>>>>
86108>>>>>>>        // This just creates the table and a "dummy" column.
86108>>>>>>>        Get SqlTableCreate hTable sDriverID to bOK
86109>>>>>>>        If (bOK = False) Begin
86111>>>>>>>            Function_Return False
86112>>>>>>>        End
86112>>>>>>>>
86112>>>>>>>
86112>>>>>>>        Close hTable
86113>>>>>>>        Move False to Err
86114>>>>>>>
86114>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
86115>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
86116>>>>>>>        Move "Decimal" to sDataType
86117>>>>>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
86118>>>>>>>
86118>>>>>>>        // Adds the "sColumnName" passed to the function
86118>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
86119>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
86120>>>>>>>
86120>>>>>>>        // Now we can delete the dummy column:
86120>>>>>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
86121>>>>>>>
86121>>>>>>>        // Finally, we attach to the newly created table.
86121>>>>>>>        If (Err = False) Begin
86123>>>>>>>            Get ApiTableAttachToSQL hTable True to bOK
86124>>>>>>>        End
86124>>>>>>>>
86124>>>>>>>        Open hTable
86126>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86129>>>>>>>
86129>>>>>>>        Function_Return (Err = False and bOK = True and bOpened = True)
86130>>>>>>>    End_Function
86131>>>>>>>
86131>>>>>>>    // Returns a handle to the SQL server associated with the passed driver ID.
86131>>>>>>>    // Pass e.g. the psServer property to determine the current connection server.
86131>>>>>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
86131>>>>>>>    // This handle can be used to obtain attributes about the server, such as default
86131>>>>>>>    // column types.
86131>>>>>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
86133>>>>>>>        Handle hDatabase
86133>>>>>>>        Integer iDriver iServers iCount
86133>>>>>>>        String sValue
86133>>>>>>>
86133>>>>>>>        If (sServer = "") Begin
86135>>>>>>>            Function_Return 0
86136>>>>>>>        End
86136>>>>>>>>
86136>>>>>>>
86136>>>>>>>        Get DriverIndex sDriverID to iDriver
86137>>>>>>>        If (iDriver = 0) Begin
86139>>>>>>>            Function_Return 0
86140>>>>>>>        End
86140>>>>>>>>
86140>>>>>>>
86140>>>>>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
86143>>>>>>>        For iCount from 1 to iServers
86149>>>>>>>>
86149>>>>>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
86152>>>>>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
86154>>>>>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
86157>>>>>>>            End
86157>>>>>>>>
86157>>>>>>>        Loop
86158>>>>>>>>
86158>>>>>>>
86158>>>>>>>        Function_Return hDatabase
86159>>>>>>>    End_Function
86160>>>>>>>
86160>>>>>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
86160>>>>>>>//        String sRootName
86160>>>>>>>//        Boolean bOK
86160>>>>>>>//
86160>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86160>>>>>>>//        Move (sRootName contains sDriverID) to bOK
86160>>>>>>>//
86160>>>>>>>//        Function_Return bOK
86160>>>>>>>//    End_Function
86160>>>>>>>
86160>>>>>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
86160>>>>>>>//        String sDriverID sRootName sDisplayName sSchema sVal
86160>>>>>>>//        Integer iDbType
86160>>>>>>>//        Boolean bOK
86160>>>>>>>//
86160>>>>>>>//        Get UtilIsFilelistEntryDriverBased to bOK
86160>>>>>>>//        If (bOK = True) Begin
86160>>>>>>>//            Function_Return False
86160>>>>>>>//        End
86160>>>>>>>//
86160>>>>>>>//        Get psDriverID to sDriverID
86160>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
86160>>>>>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
86160>>>>>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86160>>>>>>>//
86160>>>>>>>//        Get psDriverID to sDriverID
86160>>>>>>>//        Get piDbType   to iDbType
86160>>>>>>>//        Get psSchema   to sSchema
86160>>>>>>>//        If (sSchema = "") Begin
86160>>>>>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
86160>>>>>>>//        End
86160>>>>>>>//
86160>>>>>>>//        Move (Uppercase(sDisplayName)) to sVal
86160>>>>>>>//        If (not(sVal contains (sSchema + "."))) Begin
86160>>>>>>>//            If (iDbType = EN_dbTypeDB2) Begin
86160>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
86160>>>>>>>//            End
86160>>>>>>>//            Else Begin
86160>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
86160>>>>>>>//            End
86160>>>>>>>//        End
86160>>>>>>>//
86160>>>>>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
86160>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86160>>>>>>>//
86160>>>>>>>//        Function_Return True
86160>>>>>>>//    End_Function
86160>>>>>>>
86160>>>>>>>    // Removes all driver identifications (e.g. "MSSQLDRV:MyTable")
86160>>>>>>>    // from the passed filelist.
86160>>>>>>>    // Returns the number of tables affected.
86160>>>>>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
86162>>>>>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
86162>>>>>>>        Integer iRetval
86162>>>>>>>        Handle hTable
86162>>>>>>>
86162>>>>>>>        // We first save the current filelist as the passed filelist name
86162>>>>>>>        // may come from another workspace, to restore it when we're ready.
86162>>>>>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
86165>>>>>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
86168>>>>>>>        Move 0 to hTable
86169>>>>>>>        Move 0 to iRetval
86170>>>>>>>
86170>>>>>>>        Repeat
86170>>>>>>>>
86170>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
86173>>>>>>>            If (hTable <> 0) Begin
86175>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
86178>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86181>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86184>>>>>>>                Move (Uppercase(sRootName)) to sVal
86185>>>>>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
86187>>>>>>>                    // Prefixes:
86187>>>>>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
86188>>>>>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
86189>>>>>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
86190>>>>>>>                    // Suffixes:
86190>>>>>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
86191>>>>>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
86192>>>>>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
86193>>>>>>>
86193>>>>>>>                    // Change Filelist entry:
86193>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
86196>>>>>>>
86196>>>>>>>                    Move (Lowercase(sDisplayName)) to sVal
86197>>>>>>>                    If (sVal contains "dbo.") Begin
86199>>>>>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
86200>>>>>>>
86200>>>>>>>                        // Change Filelist entry:
86200>>>>>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
86203>>>>>>>                    End
86203>>>>>>>>
86203>>>>>>>                    Increment iRetval
86204>>>>>>>                End
86204>>>>>>>>
86204>>>>>>>            End
86204>>>>>>>>
86204>>>>>>>        Until (hTable = 0)
86206>>>>>>>
86206>>>>>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
86209>>>>>>>
86209>>>>>>>        Function_Return iRetval
86210>>>>>>>    End_Function
86211>>>>>>>
86211>>>>>>>    // To open all Sql based tables in Filelist.cfg
86211>>>>>>>    Procedure SqlUtilOpenAllTables
86213>>>>>>>        Handle hTable
86213>>>>>>>        String sRoot sDriverID
86213>>>>>>>        Boolean bOK
86213>>>>>>>
86213>>>>>>>        Move 0 to hTable
86214>>>>>>>        Move "" to sDriverID
86215>>>>>>>        Get AutoConnectionIDLogin to bOK
86216>>>>>>>
86216>>>>>>>        Repeat
86216>>>>>>>>
86216>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
86219>>>>>>>            If (hTable > 0) Begin
86221>>>>>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
86224>>>>>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
86226>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
86229>>>>>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
86231>>>>>>>                        Open hTable
86233>>>>>>>                    End
86233>>>>>>>>
86233>>>>>>>                End
86233>>>>>>>>
86233>>>>>>>            End
86233>>>>>>>>
86233>>>>>>>
86233>>>>>>>        Until (hTable = 0)
86235>>>>>>>    End_Procedure
86236>>>>>>>
86236>>>>>>>//    Function SqlUtilSchemaName Handle hTable Returns String
86236>>>>>>>//        String sRetval sDriverID
86236>>>>>>>//        String sTableName
86236>>>>>>>//        Integer iDbType iIndex
86236>>>>>>>//        Boolean bOK
86236>>>>>>>//
86236>>>>>>>//        Get psDriverID to sDriverID
86236>>>>>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
86236>>>>>>>//        If (hTable = 0 or bOK = False) Begin
86236>>>>>>>//            Function_Return ""
86236>>>>>>>//        End
86236>>>>>>>//
86236>>>>>>>//        Move False to Err
86236>>>>>>>//        Get UtilTableHandleToString hTable to sTableName
86236>>>>>>>//        Get piDbType to iDbType
86236>>>>>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
86236>>>>>>>//        If (iIndex = -1) Begin
86236>>>>>>>//            Function_Return ""
86236>>>>>>>//        End
86236>>>>>>>//
86236>>>>>>>//        Function_Return sRetval
86236>>>>>>>//    End_Function
86236>>>>>>>
86236>>>>>>>    // Checks if the passed Table;
86236>>>>>>>    // 1) Already has a Filelist entry that points to SQL and
86236>>>>>>>    // 2) It has an .int file.
86236>>>>>>>    // If both is True it should already be connected to SQL
86236>>>>>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
86238>>>>>>>        Boolean bExists bRootName
86238>>>>>>>        String sRootName sDataPath
86238>>>>>>>
86238>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86241>>>>>>>        Move (sRootName contains sDriverID) to bRootName
86242>>>>>>>
86242>>>>>>>        Get psDataPathFirstPart to sDataPath
86243>>>>>>>        Get vFolderExists sDataPath to bExists
86244>>>>>>>        If (bExists = False) Begin
86246>>>>>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
86246>>>>>>>            Function_Return False
86247>>>>>>>        End
86247>>>>>>>>
86247>>>>>>>
86247>>>>>>>        Get vFolderFormat sDataPath to sDataPath
86248>>>>>>>        Get _TableNameOnly sRootName to sRootName
86249>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
86250>>>>>>>
86250>>>>>>>        Function_Return (bRootName = True and bExists = True)
86251>>>>>>>    End_Function
86252>>>>>>>
86252>>>>>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
86254>>>>>>>        Boolean bViewTableType bOpen bOK
86254>>>>>>>        Integer iTableCount iNumTables
86254>>>>>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
86254>>>>>>>        Handle hoCliHandler
86254>>>>>>>        tSQLConnection SQLConnection
86254>>>>>>>        tSQLConnection SQLConnection
86254>>>>>>>
86254>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
86257>>>>>>>        If (bOpen = False) Begin
86259>>>>>>>            Get AutoConnectionIDLogin to bOK
86260>>>>>>>            Open hTable
86262>>>>>>>        End
86262>>>>>>>>
86262>>>>>>>
86262>>>>>>>        Get pSQLConnection to SQLConnection
86263>>>>>>>        Get phoCLIHandler to hoCliHandler
86264>>>>>>>        Set psDriverID of hoCliHandler to sDriverID
86265>>>>>>>
86265>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
86268>>>>>>>        Get _TableNameOnly sTableName to sTableName
86269>>>>>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
86272>>>>>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
86273>>>>>>>
86273>>>>>>>        For iTableCount from 1 to iNumTables
86279>>>>>>>>
86279>>>>>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
86280>>>>>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
86281>>>>>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
86283>>>>>>>                Get TableType of hoCliHandler iTableCount to sTableType
86284>>>>>>>                Move iNumTables to iTableCount // We're done.
86285>>>>>>>            End
86285>>>>>>>>
86285>>>>>>>        Loop
86286>>>>>>>>
86286>>>>>>>
86286>>>>>>>        Move (sTableType = "VIEW") to bViewTableType
86287>>>>>>>        If (bOpen = False) Begin
86289>>>>>>>            Close hTable
86290>>>>>>>        End
86290>>>>>>>>
86290>>>>>>>
86290>>>>>>>        Function_Return bViewTableType
86291>>>>>>>    End_Function
86292>>>>>>>
86292>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
86292>>>>>>>    //
86292>>>>>>>    // SQL utility function that returns a database type (string) constant
86292>>>>>>>    // corresponding to the passed iDbType.
86292>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
86294>>>>>>>        String sRetval
86294>>>>>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
86295>>>>>>>        Function_Return sRetval
86296>>>>>>>    End_Function
86297>>>>>>>
86297>>>>>>>    // SQL utility function that returns a database type constant (integer)
86297>>>>>>>    // corresponding to the passed sDbType string constant.
86297>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
86299>>>>>>>        Integer iRetval
86299>>>>>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
86300>>>>>>>        Function_Return iRetval
86301>>>>>>>    End_Function
86302>>>>>>>
86302>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
86302>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
86302>>>>>>>    // the SQL Connection program's grid.
86302>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
86304>>>>>>>        String sRetval
86304>>>>>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
86305>>>>>>>        Function_Return sRetval
86306>>>>>>>    End_Function
86307>>>>>>>
86307>>>>>>>    // Pass a driver name as a string and the function will return
86307>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
86307>>>>>>>    // quite work and always returns "MS SQL Server"
86307>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
86309>>>>>>>        Integer iRetval
86309>>>>>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
86310>>>>>>>        Function_Return iRetval
86311>>>>>>>    End_Function
86312>>>>>>>
86312>>>>>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
86312>>>>>>>    // that "fits" in the max allowed length for table names.
86312>>>>>>>    // Max number of characters allowed for table names;
86312>>>>>>>    // IBM DB2      = 128
86312>>>>>>>    // MS-SQL       = 128
86312>>>>>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
86312>>>>>>>    // MySQL        = 64
86312>>>>>>>    // PostgreSQL   = 64
86312>>>>>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
86314>>>>>>>        String sGUIDName
86314>>>>>>>        Integer iDbType iLength
86314>>>>>>>
86314>>>>>>>        Get piDbType to iDbType
86315>>>>>>>        Move (RandomHexUUID()) to sGUIDName
86316>>>>>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
86317>>>>>>>        Move (Length(sGUIDName)) to iLength
86318>>>>>>>
86318>>>>>>>        Case Begin
86318>>>>>>>            Case (iDbType = EN_DbTypeDB2)
86320>>>>>>>            If (iLength > 128) Begin
86322>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
86323>>>>>>>            End
86323>>>>>>>>
86323>>>>>>>            Case Break
86324>>>>>>>
86324>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
86327>>>>>>>            If (iLength > 128) Begin
86329>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
86330>>>>>>>            End
86330>>>>>>>>
86330>>>>>>>            Case Break
86331>>>>>>>
86331>>>>>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
86334>>>>>>>            If (iLength > 128) Begin
86336>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
86337>>>>>>>            End
86337>>>>>>>>
86337>>>>>>>            Case Break
86338>>>>>>>
86338>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
86341>>>>>>>            If (iLength > 64) Begin
86343>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
86344>>>>>>>            End
86344>>>>>>>>
86344>>>>>>>            Case Break
86345>>>>>>>
86345>>>>>>>            Case (iDbType = EN_DbTypePostgre)
86348>>>>>>>            If (iLength > 64) Begin
86350>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
86351>>>>>>>            End
86351>>>>>>>>
86351>>>>>>>        Case End
86351>>>>>>>
86351>>>>>>>        Function_Return sGUIDName
86352>>>>>>>    End_Function
86353>>>>>>>
86353>>>>>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
86353>>>>>>>    // Pass the memory resource file reference and the filename to be created,
86353>>>>>>>    // including full path.
86353>>>>>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
86355>>>>>>>        String sText
86355>>>>>>>        Integer iCh iSize iArgSize
86355>>>>>>>
86355>>>>>>>        Move ("Resource:" + sMemFileName) to sMemFileName
86356>>>>>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
86357>>>>>>>        Get_Channel_Size iCh to iSize
86358>>>>>>>        Read_Block channel iCh sText iSize
86360>>>>>>>        Send Seq_Close_Channel iCh
86361>>>>>>>
86361>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
86362>>>>>>>            Write channel iCh sText
86364>>>>>>>        Send Seq_Close_Channel iCh
86365>>>>>>>
86365>>>>>>>        // Wait for file to be written to disk.
86365>>>>>>>        Sleep 2
86366>>>>>>>    End_Procedure
86367>>>>>>>
86367>>>>>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
86369>>>>>>>        String sNotNull sRetval sDefaultValue
86369>>>>>>>        Boolean bOK
86369>>>>>>>
86369>>>>>>>        Get IsSQLDriver sDriverID to bOK
86370>>>>>>>        If (bOK = False) Begin
86372>>>>>>>            Function_Return ""
86373>>>>>>>        End
86373>>>>>>>>
86373>>>>>>>
86373>>>>>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
86374>>>>>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
86375>>>>>>>
86375>>>>>>>        Case Begin
86375>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
86377>>>>>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
86378>>>>>>>                Case Break
86379>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
86382>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
86383>>>>>>>                Case Break
86384>>>>>>>            Case (iDbType = EN_dbTypePostgre)
86387>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
86388>>>>>>>                Case Break
86389>>>>>>>            Case (iDbType = EN_dbTypeDB2)
86392>>>>>>>                Move (String(sNotNull))                                     to sRetval
86393>>>>>>>                Case Break
86394>>>>>>>
86394>>>>>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
86394>>>>>>>            // ToDo: We need to look deeper into how Oracle handles NULL
86394>>>>>>>            Case (iDbType = EN_dbTypeOracle)
86397>>>>>>>                Move  ""                                                    to sRetval
86398>>>>>>>                Case Break
86399>>>>>>>
86399>>>>>>>            Case Else
86399>>>>>>>                Move  ""                                                    to sRetval
86400>>>>>>>        Case End
86400>>>>>>>
86400>>>>>>>        Function_Return sRetval
86401>>>>>>>    End_Function
86402>>>>>>>
86402>>>>>>>    // * Dummy function for the Studio's Code Explorer *
86402>>>>>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
86404>>>>>>>        Function_Return False
86405>>>>>>>    End_Function
86406>>>>>>>
86406>>>>>>>    // Enumerate SQL Servers.
86406>>>>>>>    // Pass a driver id. Returns a string array.
86406>>>>>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
86406>>>>>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
86406>>>>>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
86408>>>>>>>        String[] sReturnArray
86409>>>>>>>        Handle hoSQLHandler
86409>>>>>>>        String sServer
86409>>>>>>>        Integer iCount iNumItems iDataSourceType
86409>>>>>>>
86409>>>>>>>        If (num_arguments > 1) Begin
86411>>>>>>>            Move iDatSrcType to iDataSourceType
86412>>>>>>>        End
86412>>>>>>>>
86412>>>>>>>
86412>>>>>>>        Case Begin
86412>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86414>>>>>>>                Get phoMSSQLHandler to hoSQLHandler 
86415>>>>>>>                Get EnumerateServersLocal of hoSQLHandler to iNumItems
86416>>>>>>>                If (iNumItems = 0) Begin
86418>>>>>>>                    Get EnumerateServers of hoSQLHandler to iNumItems 
86419>>>>>>>                End
86419>>>>>>>>
86419>>>>>>>                For iCount from 0 to (iNumItems - 1)
86425>>>>>>>>
86425>>>>>>>                    Get String_Value of hoSQLHandler iCount to sServer
86426>>>>>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
86427>>>>>>>                Loop
86428>>>>>>>>
86428>>>>>>>                Case Break
86429>>>>>>>
86429>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86432>>>>>>>                Get phoDB2SQLHandler to hoSQLHandler
86433>>>>>>>                Send SeedDataSources of hoSQLHandler
86434>>>>>>>                Move 0 to iCount
86435>>>>>>>                Repeat
86435>>>>>>>>
86435>>>>>>>                    Get DataSources of hoSQLHandler to sServer
86436>>>>>>>                    If (sServer <> "") Begin
86438>>>>>>>                        Move (Replace(",", sServer, "")) to sServer
86439>>>>>>>                        Move sServer to sReturnArray[iCount]
86440>>>>>>>                    End
86440>>>>>>>>
86440>>>>>>>                    Increment iCount
86441>>>>>>>                Until (sServer = "")
86443>>>>>>>                Case Break
86444>>>>>>>
86444>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86447>>>>>>>                Get phoODBCSQLHandler to hoSQLHandler
86448>>>>>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
86449>>>>>>>                Move 0 to iCount
86450>>>>>>>                Repeat
86450>>>>>>>>
86450>>>>>>>                    Get DataSources of hoSQLHandler to sServer
86451>>>>>>>                    If (sServer <> "") Begin
86453>>>>>>>                        Move (Replace(",", sServer, ", ")) to sServer
86454>>>>>>>                        Move sServer to sReturnArray[iCount]
86455>>>>>>>                    End
86455>>>>>>>>
86455>>>>>>>                    Increment iCount
86456>>>>>>>                Until (sServer = "")
86458>>>>>>>                Case Break
86459>>>>>>>
86459>>>>>>>            Case Else
86459>>>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
86460>>>>>>>>
86460>>>>>>>        Case End
86460>>>>>>>
86460>>>>>>>        Function_Return sReturnArray
86461>>>>>>>    End_Function
86462>>>>>>>
86462>>>>>>>    // Returns all databases as a string array for the passed driver id.
86462>>>>>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
86464>>>>>>>        String[] sReturnArray
86465>>>>>>>        String sServer sVal
86465>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
86465>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
86466>>>>>>>        tSQLConnection SQLConnection
86466>>>>>>>        tSQLConnection SQLConnection
86466>>>>>>>        Boolean bOK
86466>>>>>>>        Integer iCount iSize
86466>>>>>>>
86466>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86467>>>>>>>        If (bOK = False) Begin
86469>>>>>>>            Function_Return sReturnArray
86470>>>>>>>        End
86470>>>>>>>>
86470>>>>>>>
86470>>>>>>>        Case Begin
86470>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86472>>>>>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
86473>>>>>>>                Case Break
86474>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86477>>>>>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
86478>>>>>>>                Case Break
86479>>>>>>>
86479>>>>>>>            // This is needed to be able to check if a database exists or not.
86479>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86482>>>>>>>                Get _SqlDatabasesArrayODBC to sReturnStructArray
86483>>>>>>>                If (SizeOfArray(sReturnStructArray)) Begin
86485>>>>>>>                    If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
86487>>>>>>>                        // If a FILEDSN: (can only be one database name)
86487>>>>>>>                        Move sReturnStructArray[0].sDatabaseName to sReturnArray[0]
86488>>>>>>>                    End
86488>>>>>>>>
86488>>>>>>>                    Else Begin
86489>>>>>>>                        // Else the DSN's were read from the registry.
86489>>>>>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86490>>>>>>>                        Move SQLConnection.sServer to sServer
86491>>>>>>>                        Move (SizeOfArray(sReturnStructArray)) to iSize
86492>>>>>>>                        Decrement iSize
86493>>>>>>>                        for iCount from 0 to iSize
86499>>>>>>>>
86499>>>>>>>                            Move (sReturnStructArray[iCount].sServerName) to sVal
86500>>>>>>>                            If (Uppercase(sServer) = Uppercase(sVal)) Begin
86502>>>>>>>                                Move sReturnStructArray[iCount].sDatabaseName to sReturnArray[0]
86503>>>>>>>                                Move iSize to iCount // We're done.
86504>>>>>>>                            End
86504>>>>>>>>
86504>>>>>>>                        Loop
86505>>>>>>>>
86505>>>>>>>                    End
86505>>>>>>>>
86505>>>>>>>                End
86505>>>>>>>>
86505>>>>>>>                Case Break
86506>>>>>>>
86506>>>>>>>            Case Else
86506>>>>>>>//                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
86506>>>>>>>        Case End
86506>>>>>>>
86506>>>>>>>        Function_Return sReturnArray
86507>>>>>>>    End_Function
86508>>>>>>>
86508>>>>>>>    
86508>>>>>>>    // *** Database API Functions: ***
86508>>>>>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
86508>>>>>>>    // make changes/updates to the database.
86508>>>>>>>
86508>>>>>>>    // * Dummy function for the Studio's Code Explorer *
86508>>>>>>>    Function API_TABLE_FUNCTIONS Returns Boolean
86510>>>>>>>        Function_Return False
86511>>>>>>>    End_Function
86512>>>>>>>
86512>>>>>>>    // This might not do what you think - Here's what it does:
86512>>>>>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
86512>>>>>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
86512>>>>>>>    // to the SQL table.
86512>>>>>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
86512>>>>>>>    // already exists in SQL.
86512>>>>>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
86512>>>>>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
86512>>>>>>>    // restructuring an existing table.
86512>>>>>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
86514>>>>>>>        Boolean bExists bOpened bOK bSystemFile bUseConnectionID bIsAlias
86514>>>>>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
86514>>>>>>>        Handle hToTable
86514>>>>>>>
86514>>>>>>>        Move True to bUseConnectionID
86515>>>>>>>        If (num_arguments > 1) Begin
86517>>>>>>>            Move bUseConnID to bUseConnectionID
86518>>>>>>>        End
86518>>>>>>>>
86518>>>>>>>
86518>>>>>>>        Get psDriverID to sDriverID
86519>>>>>>>        // If the table doesn't exist on the SQL back-end we do nothing.
86519>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86520>>>>>>>        If (bExists = False) Begin
86522>>>>>>>            Function_Return False
86523>>>>>>>        End
86523>>>>>>>>
86523>>>>>>>
86523>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
86524>>>>>>>
86524>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86525>>>>>>>        If (bOK = False) Begin
86527>>>>>>>            Function_Return False
86528>>>>>>>        End
86528>>>>>>>>
86528>>>>>>>
86528>>>>>>>        // Then we need to check that the function hasn't been called before; which in case
86528>>>>>>>        // we do nothing
86528>>>>>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
86529>>>>>>>        If (bExists = True) Begin
86531>>>>>>>            Function_Return False
86532>>>>>>>        End
86532>>>>>>>>
86532>>>>>>>
86532>>>>>>>        Get psConnectionID     to sConnectionID
86533>>>>>>>        Get psConnectionString to sConnectionString
86534>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
86536>>>>>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
86537>>>>>>>>
86537>>>>>>>            Function_Return False
86538>>>>>>>        End
86538>>>>>>>>
86538>>>>>>>
86538>>>>>>>        Set Private.phCurrentTable to hTable
86539>>>>>>>        Get psSchema to sSchema
86540>>>>>>>        If (sSchema = "") Begin
86542>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
86543>>>>>>>        End
86543>>>>>>>>
86543>>>>>>>
86543>>>>>>>        // If we should use a connection id we need to check it exists;
86543>>>>>>>        // else we create it before attempting creating the table
86543>>>>>>>        If (bUseConnectionID = True) Begin
86545>>>>>>>            Get AutoConnectionIDLogin to bOK
86546>>>>>>>            If (bOk = False) Begin
86548>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
86549>>>>>>>>
86549>>>>>>>                Function_Return False
86550>>>>>>>            End
86550>>>>>>>>
86550>>>>>>>        End
86550>>>>>>>>
86550>>>>>>>
86550>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86553>>>>>>>        Get _TableNameOnly sRootName to sRootName
86554>>>>>>>        If (sRootName = "") Begin
86556>>>>>>>            Function_Return False
86557>>>>>>>        End
86557>>>>>>>>
86557>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
86558>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86561>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86564>>>>>>>
86564>>>>>>>        // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
86564>>>>>>>        //
86564>>>>>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
86564>>>>>>>        // because then the table should not be visible to users.
86564>>>>>>>//        Move (Pos("@", sDisplayName)) to iPos
86564>>>>>>>//        If (iPos <> 1) Begin
86564>>>>>>>//            If (sDisplayName contains ".") Begin
86564>>>>>>>//                Move (Pos(".", sDisplayName)) to iPos
86564>>>>>>>//                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
86564>>>>>>>//                Move (sSchema + "." + sDisplayName)       to sDisplayName
86564>>>>>>>//            End
86564>>>>>>>//            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86564>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
86564>>>>>>>//            End
86564>>>>>>>//        End
86564>>>>>>>
86564>>>>>>>        If (bIsAlias = False) Begin
86566>>>>>>>            Get OpenTableExclusive hTable to bOpened
86567>>>>>>>            If (bOpened = False) Begin
86569>>>>>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
86570>>>>>>>>
86570>>>>>>>                Function_Return False
86571>>>>>>>            End
86571>>>>>>>>
86571>>>>>>>        End
86571>>>>>>>>
86571>>>>>>>
86571>>>>>>>        If (ghoProgressBar <> 0) Begin
86573>>>>>>>            Send DoAdvance of ghoProgressBar
86574>>>>>>>            Set Message_Text of ghoStatusPanel to ""
86575>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
86576>>>>>>>        End
86576>>>>>>>>
86576>>>>>>>        // Note: The hToTable will get changed by the Structure_xxx command...
86576>>>>>>>        Move hTable to hToTable
86577>>>>>>>        Move False to Err
86578>>>>>>>
86578>>>>>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
86578>>>>>>>        // then we do a pseudo .int file change with the "_SqlUtilUpdateIntFile" function. After that we have
86578>>>>>>>        // a proper and updated .int file.
86578>>>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
86581>>>>>>>        Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
86582>>>>>>>
86582>>>>>>>        If (bIsAlias = False) Begin
86584>>>>>>>            Structure_Start hToTable sDriverID
86585>>>>>>>                Set Private.phCurrentTable to hTable
86586>>>>>>>                If (bUseConnectionID = True) Begin
86588>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
86591>>>>>>>                End
86591>>>>>>>>
86591>>>>>>>                Else Begin
86592>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
86595>>>>>>>                End
86595>>>>>>>>
86595>>>>>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
86598>>>>>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
86598>>>>>>>                Move False to Err
86599>>>>>>>                Move 0 to LastErr
86600>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
86601>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86603>>>>>>>            Set Action_Text of ghoStatusPanel to ""
86604>>>>>>>        End
86604>>>>>>>>
86604>>>>>>>
86604>>>>>>>        Move (not(Err)) to bOK
86605>>>>>>>        If (bOK = True) Begin
86607>>>>>>>            // The attributes set above will always trigger an error
86607>>>>>>>            // We also adjust the Filelist entries
86607>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
86610>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86613>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86616>>>>>>>
86616>>>>>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
86616>>>>>>>            Get _SqlUtilUpdateIntFile hTable to bOK
86617>>>>>>>        End
86617>>>>>>>>
86617>>>>>>>
86617>>>>>>>        Function_Return (bOK = True)
86618>>>>>>>    End_Function
86619>>>>>>>
86619>>>>>>>    // Sample usage:
86619>>>>>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
86619>>>>>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
86619>>>>>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
86621>>>>>>>        Boolean bOK bIsSQLTable
86621>>>>>>>
86621>>>>>>>        Get AutoConnectionIDLogin to bOK
86622>>>>>>>        Move False to Err
86623>>>>>>>        Get OpenTableExclusive hTable to bOK
86624>>>>>>>        If (bOK = False) Begin
86626>>>>>>>            Function_Return False
86627>>>>>>>        End
86627>>>>>>>>
86627>>>>>>>
86627>>>>>>>        // ToDo: Add to all table change functions!
86627>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
86628>>>>>>>            If (bIsSQLTable = True) Begin
86630>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
86633>>>>>>>            End
86633>>>>>>>>
86633>>>>>>>
86633>>>>>>>        Set Private.phCurrentTable to hTable
86634>>>>>>>        Structure_Start hTable
86635>>>>>>>            Set_Attribute iAttribute of hTable to iValue
86638>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86639>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86641>>>>>>>
86641>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86642>>>>>>>        Function_Return (Err = False)
86643>>>>>>>    End_Function
86644>>>>>>>
86644>>>>>>>    Function ApiTableMoveFileListEntry String sRootName String sLogicalName String sDisplayName Handle hFromSlot Handle hToSlot String sDriverID Returns Boolean
86646>>>>>>>        Boolean bOK
86646>>>>>>>        
86646>>>>>>>        Get ApiTableChangeFileListSlot sRootName sLogicalName sDisplayName hToSlot sDriverID to bOK
86647>>>>>>>        If (bOK = True) Begin
86649>>>>>>>            Get ApiTableChangeFileListSlot "" "" "" hFromSlot sDriverID to bOK
86650>>>>>>>        End
86650>>>>>>>>
86650>>>>>>>        
86650>>>>>>>        Function_Return (bOK = True)
86651>>>>>>>    End_Function
86652>>>>>>>    
86652>>>>>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
86652>>>>>>>    // or to change the filelist slot names.
86652>>>>>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
86654>>>>>>>        String sFileListName
86654>>>>>>>        
86654>>>>>>>        Move False to Err
86655>>>>>>>
86655>>>>>>>        If (ghoProgressBar <> 0) Begin
86657>>>>>>>            Send DoAdvance of ghoProgressBar
86658>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
86659>>>>>>>        End
86659>>>>>>>>
86659>>>>>>>        // If all strings are empty it means that we should remove this entry from filelist.
86659>>>>>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
86661>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
86664>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
86667>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
86670>>>>>>>            Function_Return (Err = False) // And we're done.
86671>>>>>>>        End
86671>>>>>>>>
86671>>>>>>>
86671>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86673>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86673>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
86674>>>>>>>        End
86674>>>>>>>>
86674>>>>>>>//        Else Begin
86674>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86674>>>>>>>//        End
86674>>>>>>>//
86674>>>>>>>//        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86674>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86674>>>>>>>
86674>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86677>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86680>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86683>>>>>>>        
86683>>>>>>>        Function_Return (Err = False)
86684>>>>>>>    End_Function
86685>>>>>>>
86685>>>>>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
86687>>>>>>>        Boolean bOK
86687>>>>>>>
86687>>>>>>>        Get AutoConnectionIDLogin to bOK
86688>>>>>>>        Move False to Err
86689>>>>>>>        Get OpenTableExclusive hTable to bOK
86690>>>>>>>        If (bOK = False) Begin
86692>>>>>>>            Function_Return False
86693>>>>>>>        End
86693>>>>>>>>
86693>>>>>>>
86693>>>>>>>        Set Private.phCurrentTable to hTable
86694>>>>>>>        Structure_Start hTable
86695>>>>>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
86698>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86699>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86701>>>>>>>
86701>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86702>>>>>>>        Function_Return (Err = False)
86703>>>>>>>    End_Function
86704>>>>>>>
86704>>>>>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
86706>>>>>>>        Boolean bOK bIsSQLTable
86706>>>>>>>
86706>>>>>>>        Move False to Err
86707>>>>>>>        Get AutoConnectionIDLogin to bOK
86708>>>>>>>        Open hToTable
86710>>>>>>>        Get OpenTableExclusive hTable to bOK
86711>>>>>>>        If (bOK = False) Begin
86713>>>>>>>            Function_Return False
86714>>>>>>>        End
86714>>>>>>>>
86714>>>>>>>
86714>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
86715>>>>>>>            If (bIsSQLTable = True) Begin
86717>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
86720>>>>>>>            End
86720>>>>>>>>
86720>>>>>>>
86720>>>>>>>        Set Private.phCurrentTable to hTable
86721>>>>>>>        Structure_Start hTable
86722>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
86725>>>>>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
86728>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86729>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86731>>>>>>>
86731>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86732>>>>>>>        Function_Return (Err = False)
86733>>>>>>>    End_Function
86734>>>>>>>
86734>>>>>>>    Procedure ApiTableConvertAllAddException Integer hTable
86736>>>>>>>        Integer[] aTableConvertExceptions
86737>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
86738>>>>>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
86739>>>>>>>        Set paTableConvertExceptions to aTableConvertExceptions
86740>>>>>>>    End_Procedure
86741>>>>>>>
86741>>>>>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
86743>>>>>>>        Integer[] aTableDateCorrectionExceptions
86744>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
86745>>>>>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
86746>>>>>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
86747>>>>>>>    End_Procedure
86748>>>>>>>
86748>>>>>>>    Procedure ApiTableConvertALLToSql
86750>>>>>>>        Integer[] iTablesArray
86751>>>>>>>        Integer iSize iCount
86751>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
86751>>>>>>>        String sDriverID
86751>>>>>>>
86751>>>>>>>        Get psDriverID to sDriverID
86752>>>>>>>        Get pbUseConnectionID to bUseConnectionID
86753>>>>>>>        Get pbToANSI          to bToANSI
86754>>>>>>>        Get pbRecnum          to bRecnum
86755>>>>>>>        Get pbCopyData        to bCopyData
86756>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
86758>>>>>>>            Get pbContinueOnError to bContinueOnError
86759>>>>>>>        End
86759>>>>>>>>
86759>>>>>>>
86759>>>>>>>        Get _AllTablesToConvert to iTablesArray
86760>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
86761>>>>>>>        Set pbVisible   of ghoProgressBarOverall to True
86762>>>>>>>        Set piPosition  of ghoProgressBarOverall to 0
86763>>>>>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
86764>>>>>>>        Set piMaximum   of ghoProgressBarOverall to iSize
86765>>>>>>>
86765>>>>>>>        Decrement iSize
86766>>>>>>>        For iCount from 0 to iSize
86772>>>>>>>>
86772>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
86773>>>>>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
86774>>>>>>>            // Probably the right logic here is to just continue trying to convert every table even
86774>>>>>>>            // if there was an error converting one table...
86774>>>>>>>            //If (bContinueOnError = False and bOK = False) Break
86774>>>>>>>        Loop
86775>>>>>>>>
86775>>>>>>>
86775>>>>>>>    End_Procedure
86776>>>>>>>
86776>>>>>>>    Procedure ApiTableAttachALLToSql
86778>>>>>>>        Integer[] iTablesArray
86779>>>>>>>        Integer iSize iCount
86779>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
86779>>>>>>>        String sDriverID
86779>>>>>>>
86779>>>>>>>        Get psDriverID to sDriverID
86780>>>>>>>        Get pbUseConnectionID to bUseConnectionID
86781>>>>>>>        Get pbToANSI          to bToANSI
86782>>>>>>>        Get pbRecnum          to bRecnum
86783>>>>>>>        Get pbCopyData        to bCopyData
86784>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
86786>>>>>>>            Get pbContinueOnError to bContinueOnError
86787>>>>>>>        End
86787>>>>>>>>
86787>>>>>>>
86787>>>>>>>        Get _AllTablesToConvert to iTablesArray
86788>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
86789>>>>>>>        Decrement iSize
86790>>>>>>>        For iCount from 0 to iSize
86796>>>>>>>>
86796>>>>>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
86797>>>>>>>        Loop
86798>>>>>>>>
86798>>>>>>>
86798>>>>>>>    End_Procedure
86799>>>>>>>
86799>>>>>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
86801>>>>>>>        Handle hToTable hoLogFile
86801>>>>>>>        Boolean bOK bExists bOpened bDAWDriver bContinueOnError bIsAlias
86801>>>>>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
86801>>>>>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
86801>>>>>>>        tSQLConnection SQLConnection
86801>>>>>>>        tSQLConnection SQLConnection
86801>>>>>>>        // ToDo: Redo logic. Instead create the new table!
86801>>>>>>>        Get _UtilTableExists hTable to bExists
86802>>>>>>>        If (bExists = False) Begin
86804>>>>>>>            Set Private.phCurrentTable to hTable
86805>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end.(Or Filelist.cfg contains a driver but the table doesn't exists on the SQL back-end)"
86806>>>>>>>>
86806>>>>>>>            Function_Return False
86807>>>>>>>        End
86807>>>>>>>>
86807>>>>>>>
86807>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
86808>>>>>>>        // If this is an Alias file there is nothing to convert to SQL.
86808>>>>>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
86808>>>>>>>        If (bIsAlias = True) Begin
86810>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86813>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
86815>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86818>>>>>>>                Get psConnectionID to sConnectionID
86819>>>>>>>                Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
86820>>>>>>>            End
86820>>>>>>>>
86820>>>>>>>            Function_Return True
86821>>>>>>>        End
86821>>>>>>>>
86821>>>>>>>
86821>>>>>>>        Set Private.phCurrentTable to hTable
86822>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
86825>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86828>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86831>>>>>>>
86831>>>>>>>        If (ghoProgressBar <> 0) Begin
86833>>>>>>>            Send DoAdvance of ghoProgressBar
86834>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
86835>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
86836>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
86837>>>>>>>        End
86837>>>>>>>>
86837>>>>>>>
86837>>>>>>>        // Marco Kuipers suggestion;
86837>>>>>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
86837>>>>>>>        // an SQL table; Instead of creating the table in SQL, attach it to the existing
86837>>>>>>>        // SQL table.
86837>>>>>>>        Get _UtilTableIsSql hTable to bOK
86838>>>>>>>        If (bOK = False) Begin
86840>>>>>>>            Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86841>>>>>>>            If (bExists = True) Begin
86843>>>>>>>//                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86843>>>>>>>//                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86843>>>>>>>                Get phoLogFile to hoLogFile
86844>>>>>>>                If (hoLogFile <> 0) Begin          
86846>>>>>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The table was NOT converted to SQL but instead ATTACHED to the existing SQL table.") to sWarning
86847>>>>>>>//                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
86847>>>>>>>                    Send LogError sWarning False
86848>>>>>>>                End
86848>>>>>>>>
86848>>>>>>>                Else Begin
86849>>>>>>>                    Error DFERR_PROGRAM sWarning
86850>>>>>>>>
86850>>>>>>>                End                                                       
86850>>>>>>>>
86850>>>>>>>                Get ApiTableAttachToSql hTable bUseConnectionID to bOK
86851>>>>>>>                Function_Return bOK // We're done (We have attached to an existing SQL table instead of converting it.
86852>>>>>>>            End
86852>>>>>>>>
86852>>>>>>>        End
86852>>>>>>>>
86852>>>>>>>
86852>>>>>>>        // Does the rootname contain a driver?
86852>>>>>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
86854>>>>>>>            // Does the table already exist as an SQL table?
86854>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86855>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
86855>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
86855>>>>>>>            If (bExists = False) Begin
86857>>>>>>>                Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86858>>>>>>>            End
86858>>>>>>>>
86858>>>>>>>            If (bExists = True) Begin
86860>>>>>>>                Set TableName_Text of ghoStatusPanel to ""
86861>>>>>>>                Function_Return False
86862>>>>>>>            End
86862>>>>>>>>
86862>>>>>>>        End
86862>>>>>>>>
86862>>>>>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
86863>>>>>>>
86863>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
86864>>>>>>>        If (bUseConnectionID = True) Begin
86866>>>>>>>            Move False to bUseConnectionID
86867>>>>>>>        End
86867>>>>>>>>
86867>>>>>>>
86867>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86868>>>>>>>        Move SQLConnection.sSchema           to sSchema
86869>>>>>>>        If (sSchema = "") Begin
86871>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
86872>>>>>>>            Move (Lowercase(sSchema))        to sSchema
86873>>>>>>>        End
86873>>>>>>>>
86873>>>>>>>
86873>>>>>>>        Move SQLConnection.sDatabase         to sDatabase
86874>>>>>>>        Move SQLConnection.sConnectionID     to sConnectionID
86875>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
86876>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
86878>>>>>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
86879>>>>>>>>
86879>>>>>>>            Function_Return False
86880>>>>>>>        End
86880>>>>>>>>
86880>>>>>>>
86880>>>>>>>        Get AutoConnectionIDLogin to bOK
86881>>>>>>>        Open hTable
86883>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86886>>>>>>>        If (bOpened = False) Begin
86888>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
86889>>>>>>>>
86889>>>>>>>            Function_Return False
86890>>>>>>>        End
86890>>>>>>>>
86890>>>>>>>
86890>>>>>>>        If (ghoProgressBar <> 0) Begin
86892>>>>>>>            Send DoAdvance of ghoProgressBar
86893>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
86894>>>>>>>        End
86894>>>>>>>>
86894>>>>>>>
86894>>>>>>>        Move 0 to hToTable
86895>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
86896>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
86897>>>>>>>
86897>>>>>>>        Case Begin
86897>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86899>>>>>>>                Case Break
86900>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86903>>>>>>>                Case Break
86904>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86907>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
86908>>>>>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
86909>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
86910>>>>>>>                Case Break
86911>>>>>>>            Case (sDriverID = DATAFLEX_ID)
86914>>>>>>>                Case Break
86915>>>>>>>            Case Else
86915>>>>>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
86916>>>>>>>>
86916>>>>>>>                Case Break
86917>>>>>>>        Case End
86917>>>>>>>
86917>>>>>>>        Move False to Err
86918>>>>>>>
86918>>>>>>>        Structure_Start hToTable sDriverID
86919>>>>>>>            Structure_Copy hTable to hToTable
86920>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
86923>>>>>>>
86923>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
86925>>>>>>>                If (bUseConnectionID = True) Begin
86927>>>>>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to (CS_DFCONNID + "=" + sConnectionID)
86930>>>>>>>                End
86930>>>>>>>>
86930>>>>>>>                Else Begin
86931>>>>>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to sConnectionString
86934>>>>>>>                End
86934>>>>>>>>
86934>>>>>>>
86934>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE of hToTable to bRecnum
86937>>>>>>>
86937>>>>>>>                If (sSchema <> "") Begin
86939>>>>>>>                    Set_Attribute DF_FILE_OWNER of hToTable to sSchema
86942>>>>>>>                End
86942>>>>>>>>
86942>>>>>>>
86942>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
86944>>>>>>>                    If (sLongTableSpace <> "") Begin
86946>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
86949>>>>>>>                    End
86949>>>>>>>>
86949>>>>>>>                    If (sBaseTableSpace <> "") Begin
86951>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
86954>>>>>>>                    End
86954>>>>>>>>
86954>>>>>>>                    If (sIndexTableSpace <> "") Begin
86956>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
86959>>>>>>>                    End
86959>>>>>>>>
86959>>>>>>>                End
86959>>>>>>>>
86959>>>>>>>            End
86959>>>>>>>>
86959>>>>>>>
86959>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86960>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86962>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86963>>>>>>>
86963>>>>>>>        Move (not(Err)) to bOK
86964>>>>>>>
86964>>>>>>>        If (bOK = True and bCopyData = True) Begin
86966>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
86967>>>>>>>
86967>>>>>>>            If (ghoDbUpdateHandler > 0) Begin
86969>>>>>>>                Get pbContinueOnError to bContinueOnError
86970>>>>>>>            End
86970>>>>>>>>
86970>>>>>>>            // If the data copy failed we will keep the newly created SQL table but
86970>>>>>>>            // rename it by adding a GUID to the end of the table name
86970>>>>>>>            // - or as much as "fit" because different SQL back-ends have
86970>>>>>>>            // different rules how long a table name can be.
86970>>>>>>>            // The new table will probably contain data but something went
86970>>>>>>>            // wrong while converting the data from embedded to SQL.
86970>>>>>>>            If (bOK = False and bContinueOnError = False) Begin
86972>>>>>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86973>>>>>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86974>>>>>>>                Error DFERR_PROGRAM ("Copying of" * sLogicalName * " data failed due to bad data. Either duplicate records and/or bad e.g Date/DateTime data. The SQL table was renamed to:" * String(sGUIDName) * "and its Filelist.cfg entry was NOT changed.")
86975>>>>>>>>
86975>>>>>>>            End
86975>>>>>>>>
86975>>>>>>>        End
86975>>>>>>>>
86975>>>>>>>
86975>>>>>>>        // This must be after copying data...
86975>>>>>>>        If (Err = False) Begin
86977>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86980>>>>>>>            // It seems the Studio does not do this any more, so commented out.
86980>>>>>>>            // We also adjust the display name by prefixing it by the schema name;
86980>>>>>>>            //            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86980>>>>>>>            //                // The max length for the display_name is 31 characters...
86980>>>>>>>            //                If (Length(sSchema + "." + sDisplayName) < 31) Begin
86980>>>>>>>            //                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
86980>>>>>>>            //                End
86980>>>>>>>            //            End
86980>>>>>>>        End
86980>>>>>>>>
86980>>>>>>>
86980>>>>>>>        Close hTable
86981>>>>>>>        Move (not(Err)) to bOK
86982>>>>>>>        Function_Return bOK
86983>>>>>>>    End_Function
86984>>>>>>>
86984>>>>>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
86984>>>>>>>    // It will first drop all indicies, copy the data and then recreate indicies.
86984>>>>>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
86984>>>>>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
86986>>>>>>>        Boolean bOpened bOK
86986>>>>>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
86986>>>>>>>        String sErrorFile sEmpty sPath
86986>>>>>>>
86986>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
86989>>>>>>>        Get AutoConnectionIDLogin to bOK
86990>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
86992>>>>>>>            Send IncreaseSortBufferSize
86993>>>>>>>//            Send SetAllIndexesToBatch hToTable
86993>>>>>>>        End
86993>>>>>>>>
86993>>>>>>>
86993>>>>>>>        Move False to Err
86994>>>>>>>        Open sPhysicalName as hToTable
86996>>>>>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
86999>>>>>>>        If (bOpened = False) Begin
87001>>>>>>>            Function_Return False
87002>>>>>>>        End
87002>>>>>>>>
87002>>>>>>>
87002>>>>>>>        If (ghoStatusPanel <> 0) Begin
87004>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
87005>>>>>>>            Set piMinimum of ghoProgressBar to 0
87006>>>>>>>            Set piMaximum of ghoProgressBar to 100 // 100%
87007>>>>>>>        End
87007>>>>>>>>
87007>>>>>>>
87007>>>>>>>        Move "" to sEmpty
87008>>>>>>>        Move False to Err
87009>>>>>>>        Move True to bOK
87010>>>>>>>        Set Private.phCurrentTable to hToTable
87011>>>>>>>
87011>>>>>>>        // No need to get the record identifier
87011>>>>>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False
87014>>>>>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87017>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87019>>>>>>>            // Remove all indices to speed up copying of data:
87019>>>>>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
87024>>>>>>>            If (iRetval <> 0) Begin       
87026>>>>>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
87027>>>>>>>>
87027>>>>>>>                Close hToTable
87028>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87031>>>>>>>                Function_Return False
87032>>>>>>>            End
87032>>>>>>>>
87032>>>>>>>        End
87032>>>>>>>>
87032>>>>>>>
87032>>>>>>>        Move (sRootName + ".err") to sErrorFile
87033>>>>>>>        Move 0 to iIndex
87034>>>>>>>        Move False to Err
87035>>>>>>>
87035>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
87037>>>>>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
87040>>>>>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
87045>>>>>>>            If (iRetval <> 0) Begin
87047>>>>>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
87048>>>>>>>>
87048>>>>>>>                Close hToTable
87049>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87052>>>>>>>                Function_Return False
87053>>>>>>>            End
87053>>>>>>>>
87053>>>>>>>        End
87053>>>>>>>>
87053>>>>>>>        Else Begin
87054>>>>>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
87057>>>>>>>        End
87057>>>>>>>>
87057>>>>>>>
87057>>>>>>>        If (Err = False) Begin
87059>>>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
87060>>>>>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
87061>>>>>>>        End
87061>>>>>>>>
87061>>>>>>>
87061>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87063>>>>>>>            // Recreate indices:
87063>>>>>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
87068>>>>>>>            If (iRetval <> 0) Begin
87070>>>>>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
87071>>>>>>>>
87071>>>>>>>                Close hToTable
87072>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87075>>>>>>>                Function_Return False
87076>>>>>>>            End
87076>>>>>>>>
87076>>>>>>>        End
87076>>>>>>>>
87076>>>>>>>
87076>>>>>>>        Close hToTable
87077>>>>>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87080>>>>>>>
87080>>>>>>>        If (bOK = True) Begin
87082>>>>>>>            Move (not(Err)) to bOK
87083>>>>>>>        End
87083>>>>>>>>
87083>>>>>>>
87083>>>>>>>        If (ghoStatusPanel <> 0) Begin
87085>>>>>>>            Set TableName_Text of ghoStatusPanel to ""
87086>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
87087>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
87088>>>>>>>        End
87088>>>>>>>>
87088>>>>>>>
87088>>>>>>>        Function_Return (bOK = True)
87089>>>>>>>    End_Function
87090>>>>>>>
87090>>>>>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
87090>>>>>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
87090>>>>>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
87092>>>>>>>        Handle hFile
87092>>>>>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
87092>>>>>>>        Integer iIdentityType iDataType iDbType iCount iSize
87092>>>>>>>        Boolean bOk bExists bSqlDriver bDeleteDummy bExistsInFilelist bSysFile
87092>>>>>>>        tSQLConnection SQLConnection
87092>>>>>>>        tSQLConnection SQLConnection
87092>>>>>>>        tAPIColumn[] aColumns
87092>>>>>>>        tAPIColumn[] aColumns
87093>>>>>>>        tColumnType ColumnType
87093>>>>>>>        tColumnType ColumnType
87093>>>>>>>
87093>>>>>>>        // First check if the passed filenumber already exists; in case we do nothing
87093>>>>>>>        Get _UtilTableExists hTable to bOk
87094>>>>>>>        If (bOk = True) Begin
87096>>>>>>>            Function_Return False
87097>>>>>>>        End
87097>>>>>>>>
87097>>>>>>>
87097>>>>>>>        Set Private.phCurrentTable to hTable
87098>>>>>>>        Move sLogicalName to sTableName
87099>>>>>>>        If (ghoProgressBar <> 0) Begin
87101>>>>>>>            Send DoAdvance of ghoProgressBar
87102>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
87103>>>>>>>        End
87103>>>>>>>>
87103>>>>>>>
87103>>>>>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
87104>>>>>>>        Get psDriverID to sDriverID
87105>>>>>>>        Get IsSQLDriver sDriverID to bSqlDriver
87106>>>>>>>        Get piDbType to iDbType
87107>>>>>>>
87107>>>>>>>        // If no columns passed in, we need to create a "dummy" column
87107>>>>>>>        Move False to bDeleteDummy
87108>>>>>>>        If (Num_Arguments = 8) Begin
87110>>>>>>>            Move aColumnIn to aColumns
87111>>>>>>>        End
87111>>>>>>>>
87111>>>>>>>        If ((SizeOfArray(aColumns)) = 0) Begin
87113>>>>>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
87114>>>>>>>            Move ColumnType.iSQLType to iDataType
87115>>>>>>>            If (bRecnum = False) Begin
87117>>>>>>>                Move C_tAPIColumn_Identity to iIdentityType
87118>>>>>>>            End
87118>>>>>>>>
87118>>>>>>>            Else Begin
87119>>>>>>>                Move C_tAPIColumn_None     to iIdentityType
87120>>>>>>>            End
87120>>>>>>>>
87120>>>>>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
87121>>>>>>>            Move True to bDeleteDummy
87122>>>>>>>        End
87122>>>>>>>>
87122>>>>>>>
87122>>>>>>>        // If columns have been passed as an array we need to check if an identity column
87122>>>>>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
87122>>>>>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
87122>>>>>>>        // two identity columns and SQL doesn't like that and throws an error.
87122>>>>>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
87124>>>>>>>            Move (SizeOfArray(aColumns)) to iSize
87125>>>>>>>            Decrement iSize
87126>>>>>>>            for iCount from 0 to iSize
87132>>>>>>>>
87132>>>>>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
87134>>>>>>>                    Move False to bRecnum
87135>>>>>>>                    Move iSize to iCount
87136>>>>>>>                End
87136>>>>>>>>
87136>>>>>>>            Loop
87137>>>>>>>>
87137>>>>>>>        End
87137>>>>>>>>
87137>>>>>>>
87137>>>>>>>        // If this is a SQL based driver we also check if the table exists
87137>>>>>>>        // in the SQL back end; in case we do nothing.
87137>>>>>>>        If (bSqlDriver = True) Begin
87139>>>>>>>            // Get all connection properties
87139>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
87140>>>>>>>            Move SQLConnection.sSchema to sSchema
87141>>>>>>>            If (sSchema = "") Begin
87143>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
87144>>>>>>>            End
87144>>>>>>>>
87144>>>>>>>
87144>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
87145>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
87145>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
87145>>>>>>>            If (bExists = False) Begin
87147>>>>>>>                Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
87148>>>>>>>            End
87148>>>>>>>>
87148>>>>>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
87148>>>>>>>            // we will just add it to Filelist.cfg
87148>>>>>>>            If (bExists = True) Begin
87150>>>>>>>                If (bExistsInFilelist = False) Begin
87152>>>>>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
87154>>>>>>>                        Move (sDriverID + ":" + sRootName) to sRootName
87155>>>>>>>                    End
87155>>>>>>>>
87155>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87158>>>>>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87161>>>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87164>>>>>>>                    Move False to bSysFile
87165>>>>>>>                    Get _SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
87166>>>>>>>                End
87166>>>>>>>>
87166>>>>>>>                Function_Return False
87167>>>>>>>            End
87167>>>>>>>>
87167>>>>>>>        End
87167>>>>>>>>
87167>>>>>>>
87167>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
87168>>>>>>>        If (num_arguments > 6) Begin
87170>>>>>>>            If (bANSI = False) Begin
87172>>>>>>>                Move CS_OEM_Txt to sANSI_OEM
87173>>>>>>>            End
87173>>>>>>>>
87173>>>>>>>        End
87173>>>>>>>>
87173>>>>>>>
87173>>>>>>>        Move False to Err
87174>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
87176>>>>>>>            Move sRootName to sPhysicalFile
87177>>>>>>>        End
87177>>>>>>>>
87177>>>>>>>
87177>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87179>>>>>>>            Move SQLConnection.sConnectionID to sConnectionID
87180>>>>>>>
87180>>>>>>>            // If DAW driver and we should use a connection id we need to
87180>>>>>>>            // check if the connection ID exists; else we create it before attempting creating the table
87180>>>>>>>            If (bUseConnectionID = True) Begin
87182>>>>>>>                Get IsConnectionID sConnectionID sDriverID to bExists
87183>>>>>>>                If (bExists = False) Begin
87185>>>>>>>                    Get AutoSetConnectionID sConnectionID to bOk
87186>>>>>>>                    If (bOk = False) Begin
87188>>>>>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
87189>>>>>>>>
87189>>>>>>>                        Function_Return False
87190>>>>>>>                    End
87190>>>>>>>>
87190>>>>>>>                End
87190>>>>>>>>
87190>>>>>>>            End
87190>>>>>>>>
87190>>>>>>>
87190>>>>>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
87192>>>>>>>                Move (sTableName + ".int") to sPhysicalFile
87193>>>>>>>            End
87193>>>>>>>>
87193>>>>>>>            Else Begin
87194>>>>>>>                Move (sRootName + ".int") to sPhysicalFile
87195>>>>>>>            End
87195>>>>>>>>
87195>>>>>>>            Move (Uppercase(sDisplayName)) to sVal
87196>>>>>>>//            If (not(sVal contains (sSchema + "."))) Begin
87196>>>>>>>//                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
87196>>>>>>>//            End
87196>>>>>>>        End
87196>>>>>>>>
87196>>>>>>>        Move False to Err
87197>>>>>>>        Move 0 to hFile
87198>>>>>>>
87198>>>>>>>        Structure_Start hFile sDriverID
87199>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
87201>>>>>>>                If (bUseConnectionID = True) Begin
87203>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
87206>>>>>>>                End
87206>>>>>>>>
87206>>>>>>>                Else Begin
87207>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
87210>>>>>>>                End
87210>>>>>>>>
87210>>>>>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
87213>>>>>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
87216>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
87219>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
87222>>>>>>>
87222>>>>>>>                If (sSchema <> "") Begin
87224>>>>>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
87227>>>>>>>                End
87227>>>>>>>>
87227>>>>>>>
87227>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
87229>>>>>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
87231>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
87234>>>>>>>                    End
87234>>>>>>>>
87234>>>>>>>                End
87234>>>>>>>>
87234>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
87236>>>>>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
87238>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
87241>>>>>>>                    End
87241>>>>>>>>
87241>>>>>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
87243>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
87246>>>>>>>                    End
87246>>>>>>>>
87246>>>>>>>                End
87246>>>>>>>>
87246>>>>>>>            End
87246>>>>>>>>
87246>>>>>>>
87246>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
87249>>>>>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
87250>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87251>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87253>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87254>>>>>>>
87254>>>>>>>        Move (not(Err)) to bOK
87255>>>>>>>        If (bOk = True) Begin
87257>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
87259>>>>>>>                Move (sDriverID + ":" + sRootName) to sRootName
87260>>>>>>>            End
87260>>>>>>>>
87260>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87263>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87266>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87269>>>>>>>
87269>>>>>>>            // Lastly we remove the temporary column we created above, if all went well.
87269>>>>>>>            If (bDeleteDummy) Begin
87271>>>>>>>                Get ApiColumnRemove hTable "temp" to bOk
87272>>>>>>>            End
87272>>>>>>>>
87272>>>>>>>        End
87272>>>>>>>>
87272>>>>>>>
87272>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
87273>>>>>>>        Close hTable
87274>>>>>>>        Function_Return bOK
87275>>>>>>>    End_Function
87276>>>>>>>
87276>>>>>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
87278>>>>>>>        Move False to Err
87279>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
87282>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
87285>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
87288>>>>>>>
87288>>>>>>>        Function_Return (Err = False)
87289>>>>>>>    End_Function
87290>>>>>>>
87290>>>>>>>    // ToDo: Needs to be revised
87290>>>>>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
87292>>>>>>>        Handle hTable
87292>>>>>>>        String sDEFName sDataPath
87292>>>>>>>        Boolean bExists
87292>>>>>>>
87292>>>>>>>        // Do nothing if MSSQL Driver.
87292>>>>>>>//        Get IsMSSQLDriver to bExists
87292>>>>>>>//        If (bExists = True) Begin
87292>>>>>>>//            Procedure_Return
87292>>>>>>>//        End
87292>>>>>>>
87292>>>>>>>        Get psDataPathFirstPart to sDataPath
87293>>>>>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
87294>>>>>>>        If (bExists = True) Begin
87296>>>>>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
87296>>>>>>>            // still be missing from the filelist and needs to be added.
87296>>>>>>>            Get _UtilTableNumberIsInUse iFilelistSlot to bExists
87297>>>>>>>            If (bExists = True) Begin
87299>>>>>>>                Procedure_Return
87300>>>>>>>            End
87300>>>>>>>>
87300>>>>>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
87300>>>>>>>            Else Begin
87301>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
87304>>>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
87307>>>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
87310>>>>>>>                Procedure_Return
87311>>>>>>>            End
87311>>>>>>>>
87311>>>>>>>        End
87311>>>>>>>>
87311>>>>>>>
87311>>>>>>>        Move (sPath + sFileName + ".def") to sDEFName
87312>>>>>>>        Move 0 to hTable
87313>>>>>>>        Move False to Err
87314>>>>>>>
87314>>>>>>>        Structure_Start hTable DATAFLEX_ID
87315>>>>>>>            Load_Def sDEFName Onto hTable
87316>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
87319>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87320>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87322>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87323>>>>>>>
87323>>>>>>>        Move iFilelistSlot to hTable
87324>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
87327>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
87330>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
87333>>>>>>>
87333>>>>>>>    End_Procedure
87334>>>>>>>
87334>>>>>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
87336>>>>>>>        Boolean bTmp bErr bOK
87336>>>>>>>        String sTableName sDisplayName sFileName
87336>>>>>>>
87336>>>>>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
87336>>>>>>>        Move Err to bTmp
87337>>>>>>>        Move False to Err
87338>>>>>>>
87338>>>>>>>        Get AutoConnectionIDLogin to bOK
87339>>>>>>>        // First get the info for the current filelist slot:
87339>>>>>>>        Open iFromFileSlot
87341>>>>>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
87344>>>>>>>        If (bOK = True) Begin
87346>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
87349>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
87352>>>>>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
87355>>>>>>>
87355>>>>>>>            //...then move it.
87355>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
87358>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
87361>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
87364>>>>>>>
87364>>>>>>>            //...and finally remove the old filelist values.
87364>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
87367>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
87370>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
87373>>>>>>>        End
87373>>>>>>>>
87373>>>>>>>        Close iFromFileSlot
87374>>>>>>>
87374>>>>>>>        Move Err to bErr
87375>>>>>>>        Move bTmp to Err
87376>>>>>>>        Function_Return (bErr = False)
87377>>>>>>>    End_Function
87378>>>>>>>
87378>>>>>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
87380>>>>>>>        Handle hTable
87380>>>>>>>        Boolean bOK
87380>>>>>>>        String sDriverID
87380>>>>>>>
87380>>>>>>>        Get _UtilTableExists hTableFrom to bOK
87381>>>>>>>        If (bOK = False) Begin
87383>>>>>>>            Set Private.phCurrentTable to hTableFrom
87384>>>>>>>            Error DFERR_PROGRAM ("Func: ApiTableRelate. From Table:" * String(hTableFrom) * "exists in Filelist.cfg but not on disk or SQL back-end.")
87385>>>>>>>>
87385>>>>>>>            Function_Return False
87386>>>>>>>        End
87386>>>>>>>>
87386>>>>>>>
87386>>>>>>>        Get _UtilTableExists hTableTo to bOK
87387>>>>>>>        If (bOK = False) Begin
87389>>>>>>>            Set Private.phCurrentTable to hTableTo
87390>>>>>>>            Error DFERR_PROGRAM ("Func: ApiTableRelate. To Table:" * String(hTableTo) * "exists in Filelist.cfg but not on disk or SQL back-end.")
87391>>>>>>>>
87391>>>>>>>            Function_Return False
87392>>>>>>>        End
87392>>>>>>>>
87392>>>>>>>
87392>>>>>>>        Get AutoConnectionIDLogin to bOK
87393>>>>>>>        Get UtilTableOpen hTableFrom "" DF_EXCLUSIVE to bOK
87394>>>>>>>        If (bOK = False) Begin
87396>>>>>>>            Function_Return False
87397>>>>>>>        End
87397>>>>>>>>
87397>>>>>>>
87397>>>>>>>        Move False to Err
87398>>>>>>>        Open hTableTo
87400>>>>>>>
87400>>>>>>>        Move hTableFrom to hTable
87401>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87404>>>>>>>        Set Private.phCurrentTable to hTable
87405>>>>>>>
87405>>>>>>>        Structure_Start hTable sDriverID
87406>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
87409>>>>>>>            If (iColumnTo <> 0) Begin
87411>>>>>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
87414>>>>>>>            End
87414>>>>>>>>
87414>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87415>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87417>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87418>>>>>>>
87418>>>>>>>        If (hTableTo > 0) Begin
87420>>>>>>>            Close hTableTo
87421>>>>>>>        End
87421>>>>>>>>
87421>>>>>>>
87421>>>>>>>        Function_Return (Err = False)
87422>>>>>>>    End_Function
87423>>>>>>>
87423>>>>>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
87423>>>>>>>    Function ApiTableRemove Handle hTable Returns Boolean
87425>>>>>>>        String sTableName sDriverID
87425>>>>>>>        Boolean bOk
87425>>>>>>>        String sDataPath
87425>>>>>>>
87425>>>>>>>        Get AutoConnectionIDLogin to bOK
87426>>>>>>>        Move False to Err
87427>>>>>>>        Get psDriverID to sDriverID
87428>>>>>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
87429>>>>>>>        If (sTableName = "") Begin
87431>>>>>>>            Function_Return False
87432>>>>>>>        End
87432>>>>>>>>
87432>>>>>>>
87432>>>>>>>        Set Private.phCurrentTable to hTable
87433>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
87434>>>>>>>        Delete_db sTableName
87435>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
87436>>>>>>>
87436>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87438>>>>>>>//            Get SqlTableRemoveByTableName sTableName to bOk  // We don't have to do this because the database is already removed by 'delete_db' above
87438>>>>>>>            Get psDataPathFirstPart to sDataPath
87439>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
87440>>>>>>>        End
87440>>>>>>>>
87440>>>>>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
87440>>>>>>>        If (hTable <> 0) Begin
87442>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
87445>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
87448>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
87451>>>>>>>        End
87451>>>>>>>>
87451>>>>>>>
87451>>>>>>>        Close hTable
87452>>>>>>>        Function_Return (hTable <> 0)
87453>>>>>>>    End_Function
87454>>>>>>>
87454>>>>>>>    Function ApiTableRemoveRelation Handle hTableFrom Integer iColumn Returns Boolean
87456>>>>>>>        Handle hTable
87456>>>>>>>        Boolean bOK
87456>>>>>>>
87456>>>>>>>        Get AutoConnectionIDLogin to bOK
87457>>>>>>>        Move False to Err
87458>>>>>>>        Open hTableFrom Mode DF_EXCLUSIVE
87460>>>>>>>        Move hTableFrom to hTable
87461>>>>>>>
87461>>>>>>>        Structure_Start hTable
87462>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
87465>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87466>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87468>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87469>>>>>>>
87469>>>>>>>        Close hTableFrom
87470>>>>>>>        Function_Return (Err = False)
87471>>>>>>>    End_Function
87472>>>>>>>
87472>>>>>>>    Function ApiTableRename Handle hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
87474>>>>>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
87474>>>>>>>        Boolean bOK bExists bOpened
87474>>>>>>>        tAPITableNameInfo APITableNameInfo
87474>>>>>>>        tAPITableNameInfo APITableNameInfo
87474>>>>>>>
87474>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
87477>>>>>>>        If (bOpened = False) Begin
87479>>>>>>>            Get OpenTableExclusive hTable to bOpened
87480>>>>>>>            If (bOpened = False) Begin
87482>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
87483>>>>>>>                Function_Return False
87484>>>>>>>            End
87484>>>>>>>>
87484>>>>>>>        End
87484>>>>>>>>
87484>>>>>>>
87484>>>>>>>        Set Private.phCurrentTable to hTable
87485>>>>>>>        Move hTable         to APITableNameInfo.iTableNumber
87486>>>>>>>        Move sRootName      to APITableNameInfo.sRootName
87487>>>>>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
87488>>>>>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
87489>>>>>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfo to bExists
87490>>>>>>>        If (bExists = True) Begin
87492>>>>>>>            Function_Return True
87493>>>>>>>        End
87493>>>>>>>>
87493>>>>>>>
87493>>>>>>>        Set Private.phCurrentTable to hTable
87494>>>>>>>        Move False to Err
87495>>>>>>>        Get psDataPathFirstPart to sDataPath
87496>>>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
87499>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
87502>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
87505>>>>>>>
87505>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87508>>>>>>>        Close hTable
87509>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
87511>>>>>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
87512>>>>>>>            If (bExists = True) Begin
87514>>>>>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
87516>>>>>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
87519>>>>>>>                    // We need a short break here before attempting to delete the physical old files or Windows
87519>>>>>>>                    // might report "File in use..." and the deletion will fail.
87519>>>>>>>                    Sleep 2
87520>>>>>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
87521>>>>>>>                End
87521>>>>>>>>
87521>>>>>>>            End
87521>>>>>>>>
87521>>>>>>>        End
87521>>>>>>>>
87521>>>>>>>
87521>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87523>>>>>>>            If (not(sPhysicalName contains ".")) Begin
87525>>>>>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
87526>>>>>>>            End
87526>>>>>>>>
87526>>>>>>>
87526>>>>>>>            // Change the table name in the .int file to the new table new:
87526>>>>>>>            Get _UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
87527>>>>>>>            If (bOK = False) Begin
87529>>>>>>>                Function_Return False
87530>>>>>>>            End
87530>>>>>>>>
87530>>>>>>>
87530>>>>>>>            // Change table name at the SQL side:
87530>>>>>>>            Get psSchema to sSchema
87531>>>>>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK
87532>>>>>>>
87532>>>>>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
87533>>>>>>>            // Remove cache file and Rename the physical file names:
87533>>>>>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK
87534>>>>>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
87535>>>>>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
87536>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
87537>>>>>>>
87537>>>>>>>            // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
87537>>>>>>>//            If (not(sDisplayName contains ".")) Begin
87537>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
87537>>>>>>>//            End
87537>>>>>>>        End
87537>>>>>>>>
87537>>>>>>>
87537>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87540>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87543>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87546>>>>>>>
87546>>>>>>>        Function_Return (Err = False)
87547>>>>>>>    End_Function
87548>>>>>>>
87548>>>>>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
87550>>>>>>>        Move False to Err
87551>>>>>>>        Set Private.phCurrentTable to hTable
87552>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87555>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87558>>>>>>>
87558>>>>>>>        Function_Return (Err = False)
87559>>>>>>>    End_Function
87560>>>>>>>
87560>>>>>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
87562>>>>>>>        Handle hTable
87562>>>>>>>        String sTableName
87562>>>>>>>        String sDriverIDFrom sDriverIDTo sLogicalNameTo
87562>>>>>>>        Integer iDbType
87562>>>>>>>        Boolean bOk bOpened bApiTableUpdateAuto bLogicalNameOK
87562>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
87562>>>>>>>        Boolean bIsSame bFilelistError bIsAliasFrom bIsSQLTableFrom bIsSQLTableTo
87562>>>>>>>        tSQLConnection SQLConnection
87562>>>>>>>        tSQLConnection SQLConnection
87562>>>>>>>        tAPITable      APITableFrom APITableTo
87562>>>>>>>        tAPITable      APITableFrom APITableTo
87562>>>>>>>        tColumnType    ColumnType
87562>>>>>>>        tColumnType    ColumnType
87562>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
87562>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
87563>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
87563>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
87564>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
87564>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
87565>>>>>>>
87565>>>>>>>        // We don't allow changes to the framework's DbVersion table.
87565>>>>>>>        If (Lowercase(sTableName) = "dbversion") Begin
87567>>>>>>>            Function_Return False
87568>>>>>>>        End
87568>>>>>>>>
87568>>>>>>>        
87568>>>>>>>        Move True to bOk
87569>>>>>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
87570>>>>>>>        Get piDbType                            to iDbType
87571>>>>>>>        Get pbRecnum                            to bRecnum
87572>>>>>>>        Get pbToANSI                            to bToANSI
87573>>>>>>>        Get pbCopyData                          to bCopyData
87574>>>>>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
87575>>>>>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
87576>>>>>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
87577>>>>>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase
87578>>>>>>>        Get pbUseConnectionID                   to bUseConnectionID
87579>>>>>>>
87579>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
87580>>>>>>>        Set Private.phCurrentTable              to hTable
87581>>>>>>>        Get _UtilTableExists  hTable            to bTableExists
87582>>>>>>>
87582>>>>>>>        If (ghoProgressBar <> 0) Begin
87584>>>>>>>            Send DoAdvance of ghoProgressBar
87585>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
87586>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
87587>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
87588>>>>>>>        End
87588>>>>>>>>
87588>>>>>>>
87588>>>>>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
87589>>>>>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
87590>>>>>>>        Get _UtilTableIsSql hTable              to bIsSQLTableTo
87591>>>>>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
87592>>>>>>>        Move True                               to APITableFrom.bFromTable
87593>>>>>>>        Move hTable                             to APITableFrom.hTable
87594>>>>>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
87595>>>>>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
87596>>>>>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
87597>>>>>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
87598>>>>>>>
87598>>>>>>>        // Check both the Filelist slot AND the LogicalName are the same! Else declare an error and break out of here!
87598>>>>>>>        If (bTableExists = True and sDriverIDTo <> DATAFLEX_ID) Begin
87600>>>>>>>            Get _SqlUtilCheckIfTableNameExists APITableFrom.ApiTableInfo.sLogicalName sDriverIDTo to bLogicalNameOK
87601>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
87602>>>>>>>            If (bOk = True and bLogicalNameOK = False) Begin
87604>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameTo
87607>>>>>>>                Error DFERR_PROGRAM ("The Filelist slot:" * String(hTable) * "exists on the client, but the Logical names are differnt! New Logical Name:" ;                                      * String(APITableFrom.ApiTableInfo.sLogicalName) * "existing Logical Name:" * String(sLogicalNameTo) * "- The file needs to be manually moved to another file slot (or removed) before this process can be started!")
87608>>>>>>>>
87608>>>>>>>                Function_Return False
87609>>>>>>>            End
87609>>>>>>>>
87609>>>>>>>        End
87609>>>>>>>>
87609>>>>>>>
87609>>>>>>>        If (bTableExists = True) Begin
87611>>>>>>>            If (bIsSQLTableTo = True) Begin
87613>>>>>>>                Get _UtilDeleteCacheFile APITableFrom.ApiTableInfo.sLogicalName to bOk
87614>>>>>>>            End
87614>>>>>>>>
87614>>>>>>>            Get OpenTableExclusive hTable to bOpened
87615>>>>>>>            If (bOpened = False) Begin
87617>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
87618>>>>>>>                Function_Return False
87619>>>>>>>            End
87619>>>>>>>>
87619>>>>>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
87620>>>>>>>            Get UtilColumnCombineFromAndToArrays   APITableFrom.aApiColumns   APITableTo.aApiColumns    to aAPIColumnCompare
87621>>>>>>>            Get UtilIndexCombineFromAndToArrays    APITableFrom.aApiIndexes   APITableTo.aApiIndexes    to aAPIIndexCompare
87622>>>>>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
87623>>>>>>>        End
87623>>>>>>>>
87623>>>>>>>
87623>>>>>>>        Move True to bOk
87624>>>>>>>        Move False to Err
87625>>>>>>>        Case Begin
87625>>>>>>>            // Alias table:
87625>>>>>>>            Case (bIsAliasFrom = True)
87627>>>>>>>                // Do nothing. Get _UtilTableCheckChangeFilelistNames is called below
87627>>>>>>>                Case Break
87628>>>>>>>
87628>>>>>>>            Case (bIsSQLTableFrom = True and bIsSQLTableTo = False and bTableExists = True)
87631>>>>>>>                    Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOk
87632>>>>>>>                    If (bOk = True) Begin
87634>>>>>>>                        Send LogError ("DataFlex table:" * String(APITableNameInfoFrom.sLogicalName) * "successfully converted to use driver:" * String(sDriverIDFrom)) False
87635>>>>>>>                    End
87635>>>>>>>>
87635>>>>>>>                Case Break
87636>>>>>>>            // New Table:
87636>>>>>>>            Case (bTableExists = False)
87639>>>>>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
87640>>>>>>>                //LR 20191112 Begin: Make file a system file if bIsSystemFile = True
87640>>>>>>>                If (APITableNameInfoFrom.bIsSystemFile) Begin
87642>>>>>>>                    Get ApiTableChangeAttribute hTable DF_FILE_IS_SYSTEM_FILE True to bOK
87643>>>>>>>                End                                                                 
87643>>>>>>>>
87643>>>>>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
87644>>>>>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
87645>>>>>>>                Case Break
87646>>>>>>>
87646>>>>>>>            // Update table:
87646>>>>>>>            Case (bTableExists = True)
87649>>>>>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
87650>>>>>>>                If (bIsSame = True) Begin
87652>>>>>>>                    Case Break
87653>>>>>>>                End
87653>>>>>>>>
87653>>>>>>>                If (bFilelistError = True) Begin
87655>>>>>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
87656>>>>>>>                    If (bOk = False) Begin
87658>>>>>>>                        Case Break
87659>>>>>>>                    End
87659>>>>>>>>
87659>>>>>>>                End
87659>>>>>>>>
87659>>>>>>>
87659>>>>>>>                If (ghoProgressBar <> 0) Begin
87661>>>>>>>                    Send DoAdvance of ghoProgressBar
87662>>>>>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
87663>>>>>>>                End
87663>>>>>>>>
87663>>>>>>>
87663>>>>>>>                // Columns:
87663>>>>>>>                Move True to bOk
87664>>>>>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
87665>>>>>>>                If (bIsSame = False) Begin
87667>>>>>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
87668>>>>>>>                End
87668>>>>>>>>
87668>>>>>>>                If (bOk = False) Begin
87670>>>>>>>                    Case Break
87671>>>>>>>                End
87671>>>>>>>>
87671>>>>>>>
87671>>>>>>>                // Indexes:
87671>>>>>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
87672>>>>>>>                If (bIsSame = False) Begin
87674>>>>>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
87675>>>>>>>                End
87675>>>>>>>>
87675>>>>>>>
87675>>>>>>>                // Relations:
87675>>>>>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
87676>>>>>>>                If (bIsSame = False) Begin
87678>>>>>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
87679>>>>>>>                    If (bOk = False) Begin
87681>>>>>>>                        Case Break
87682>>>>>>>                    End
87682>>>>>>>>
87682>>>>>>>                End
87682>>>>>>>>
87682>>>>>>>
87682>>>>>>>                Case Break
87683>>>>>>>
87683>>>>>>>            Case Else
87683>>>>>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
87684>>>>>>>>
87684>>>>>>>                Move False to bOk
87685>>>>>>>        Case End
87685>>>>>>>        
87685>>>>>>>        If (bOk = True) Begin
87687>>>>>>>            // Note: If the from table was SQL; we should either connect to an existing SQL to table,
87687>>>>>>>            // or convert an embedded table to SQL
87687>>>>>>>            If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87689>>>>>>>                Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
87690>>>>>>>                If (bOk = False) Begin
87692>>>>>>>                    Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOK
87693>>>>>>>                End
87693>>>>>>>>
87693>>>>>>>            End
87693>>>>>>>>
87693>>>>>>>            Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
87696>>>>>>>                Get SqlTableConvertToEmbedded hTable True to bOk
87697>>>>>>>            End
87697>>>>>>>>
87697>>>>>>>            
87697>>>>>>>            // Filelist Names:
87697>>>>>>>            Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
87698>>>>>>>        End
87698>>>>>>>>
87698>>>>>>>        
87698>>>>>>>        Close hTable
87699>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
87700>>>>>>>
87700>>>>>>>        Function_Return bOK
87701>>>>>>>    End_Function
87702>>>>>>>
87702>>>>>>>    // * Dummy function for the Studio's Code Explorer *
87702>>>>>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
87704>>>>>>>        Function_Return False
87705>>>>>>>    End_Function
87706>>>>>>>
87706>>>>>>>    // Adds a column name to the passed table number.
87706>>>>>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
87708>>>>>>>        Integer iColumn iCount iFile iPrecision iLastErr
87708>>>>>>>        Boolean bExists bOK bInitializeValue bRetval
87708>>>>>>>        String sDataPath sDdSrcPath sTableName sColumnValue sDriverID
87708>>>>>>>
87708>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
87709>>>>>>>        If (bExists = True) Begin
87711>>>>>>>            Function_Return False
87712>>>>>>>        End
87712>>>>>>>>
87712>>>>>>>
87712>>>>>>>        Move False to Err
87713>>>>>>>        If (num_arguments > 4) Begin
87715>>>>>>>            Move iPrec to iPrecision
87716>>>>>>>        End
87716>>>>>>>>
87716>>>>>>>        If (num_arguments > 6) Begin
87718>>>>>>>            Move bInitVal to bInitializeValue
87719>>>>>>>            Move sColVal  to sColumnValue
87720>>>>>>>        End
87720>>>>>>>>
87720>>>>>>>        If (iType < -1490) Begin
87722>>>>>>>            Move (iType + 1500) to iType
87723>>>>>>>        End
87723>>>>>>>>
87723>>>>>>>
87723>>>>>>>        Move hTable to iFile
87724>>>>>>>        Get psDriverID to sDriverID
87725>>>>>>>        Get AutoConnectionIDLogin to bOK
87726>>>>>>>        Move False to Err
87727>>>>>>>        Move LastErr to iLastErr
87728>>>>>>>        Get OpenTableExclusive iFile to bOK
87729>>>>>>>        Set Private.phCurrentTable to hTable
87730>>>>>>>
87730>>>>>>>        Structure_Start iFile sDriverID
87731>>>>>>>            Move 0 to iColumn
87732>>>>>>>            Set Private.piCurrentField to iColumn
87733>>>>>>>            Create_Field hTable At iColumn
87734>>>>>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
87737>>>>>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
87740>>>>>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
87743>>>>>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
87746>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87747>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87749>>>>>>>
87749>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87750>>>>>>>
87750>>>>>>>        // If in development environment; create .fd file:
87750>>>>>>>        Open hTable
87752>>>>>>>        Get psDdSrcPath  of (phoWorkspace(ghoApplication)) to sDDSrcPath
87753>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87754>>>>>>>        If (iCount > 1) Begin
87756>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87757>>>>>>>        End
87757>>>>>>>>
87757>>>>>>>        Get vFolderExists sDDSrcPath to bExists
87758>>>>>>>        If (bExists = True) Begin
87760>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87761>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87764>>>>>>>            Get _TableNameOnly sTableName to sTableName
87765>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87767>>>>>>>        End
87767>>>>>>>>
87767>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin  // We only want a tag if DataFlex embedded db
87769>>>>>>>            Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
87770>>>>>>>            Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
87771>>>>>>>            If (iCount > 1) Begin
87773>>>>>>>                Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
87774>>>>>>>            End
87774>>>>>>>>
87774>>>>>>>            Get vFolderFormat sDataPath to sDataPath
87775>>>>>>>            // Add the new column name to the .tag filen (if it doesn't exist):
87775>>>>>>>            // The following line should not be necexxary for the DataFlex driver. (Thank you, Hans van de Laar)
87775>>>>>>>            //Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sFieldName to bOK
87775>>>>>>>        End
87775>>>>>>>>
87775>>>>>>>        // Check for a default value
87775>>>>>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
87777>>>>>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
87778>>>>>>>        End
87778>>>>>>>>
87778>>>>>>>        Close hTable
87779>>>>>>>
87779>>>>>>>        Function_Return (Err = False)
87780>>>>>>>    End_Function
87781>>>>>>>
87781>>>>>>>    // Adds a column name to the passed table number.
87781>>>>>>>    Function ApiColumnInsert String sDriverIDFrom Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
87783>>>>>>>        Integer iCount iFile iPrecision iNumberOfFields iDbType
87783>>>>>>>        Boolean bExists bOK bIsDateType bIsSQLTypeTo
87783>>>>>>>        String sDdSrcPath sTableName
87783>>>>>>>
87783>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
87784>>>>>>>        Move False to Err
87785>>>>>>>        If (bExists = True) Begin
87787>>>>>>>            Function_Return False
87788>>>>>>>        End
87788>>>>>>>>
87788>>>>>>>        If (num_arguments > 4) Begin
87790>>>>>>>            Move iPrec to iPrecision
87791>>>>>>>        End
87791>>>>>>>>
87791>>>>>>>        If (iType < -1490) Begin
87793>>>>>>>            Move (iType + 1500) to iType
87794>>>>>>>        End
87794>>>>>>>>
87794>>>>>>>
87794>>>>>>>        Get AutoConnectionIDLogin to bOK
87795>>>>>>>        Move False to Err
87796>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTypeTo
87797>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
87797>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types. 
87797>>>>>>>        Get piDbType to iDbType
87798>>>>>>>        If (bIsSQLTypeTo = False) Begin
87800>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iType iLength to iType
87801>>>>>>>            If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87803>>>>>>>                Move DF_DATE to iType
87804>>>>>>>            End
87804>>>>>>>>
87804>>>>>>>        End
87804>>>>>>>>
87804>>>>>>>
87804>>>>>>>        // Structure_start will change the value of hTable...
87804>>>>>>>        Move hTable to iFile
87805>>>>>>>        Get OpenTableExclusive iFile to bOK
87806>>>>>>>        If (bOK = False) Begin
87808>>>>>>>            Function_Return False
87809>>>>>>>        End
87809>>>>>>>>
87809>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
87812>>>>>>>
87812>>>>>>>        // If the passed column number is higher than the current number of fields
87812>>>>>>>        // in the table, this means we should _not_ insert a field but rather add
87812>>>>>>>        // a new field to the end:
87812>>>>>>>        If (iColumn > iNumberOfFields) Begin
87814>>>>>>>            Move 0 to iColumn
87815>>>>>>>        End
87815>>>>>>>>
87815>>>>>>>
87815>>>>>>>        Set Private.phCurrentTable to hTable
87816>>>>>>>        Set Private.piCurrentField to iColumn
87817>>>>>>>
87817>>>>>>>        Structure_Start iFile
87818>>>>>>>            Create_Field iFile At iColumn
87819>>>>>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
87822>>>>>>>            If (bIsSQLTypeTo = False) Begin
87824>>>>>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
87827>>>>>>>            End
87827>>>>>>>>
87827>>>>>>>            Else Begin
87828>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
87831>>>>>>>            End
87831>>>>>>>>
87831>>>>>>>            Get UtilColumnIsDateType iType bIsSQLTypeTo to bIsDateType
87832>>>>>>>            If (bIsDateType = False) Begin
87834>>>>>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
87837>>>>>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
87840>>>>>>>            End
87840>>>>>>>>
87840>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87841>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87843>>>>>>>
87843>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87844>>>>>>>        // If in development environment; create .fd file:
87844>>>>>>>        Open hTable
87846>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
87847>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87848>>>>>>>        If (iCount > 1) Begin
87850>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87851>>>>>>>        End
87851>>>>>>>>
87851>>>>>>>        Get vFolderExists sDDSrcPath to bExists
87852>>>>>>>        If (bExists = True) Begin
87854>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87855>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87858>>>>>>>            Get _TableNameOnly sTableName to sTableName
87859>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87861>>>>>>>        End
87861>>>>>>>>
87861>>>>>>>
87861>>>>>>>        // Check for a default value
87861>>>>>>>        Close hTable
87862>>>>>>>
87862>>>>>>>        Function_Return (Err = False)
87863>>>>>>>    End_Function
87864>>>>>>>
87864>>>>>>>    // To update all records for a table column with a fixed value.
87864>>>>>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
87866>>>>>>>        Integer iRecs iCurrErr iField iRecord
87866>>>>>>>        Boolean bRetval bOpen
87866>>>>>>>
87866>>>>>>>        Move 0 to iRecs
87867>>>>>>>        Move False to bRetval
87868>>>>>>>        Move Err to iCurrErr
87869>>>>>>>        Move False to Err
87870>>>>>>>
87870>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
87873>>>>>>>        If (bOpen = False) Begin
87875>>>>>>>            Open hTable
87877>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
87880>>>>>>>            If (bOpen = False) Begin
87882>>>>>>>                Function_Return bRetval
87883>>>>>>>            End
87883>>>>>>>>
87883>>>>>>>        End
87883>>>>>>>>
87883>>>>>>>
87883>>>>>>>        Field_Map hTable sFieldName to iField
87885>>>>>>>        If (iField <> 0) Begin
87887>>>>>>>            Set Private.phCurrentTable to hTable
87888>>>>>>>            Set Private.piCurrentField to iField
87889>>>>>>>            Clear hTable
87890>>>>>>>            Repeat
87890>>>>>>>>
87890>>>>>>>                Vfind hTable 0 GT
87892>>>>>>>                If (Found) Begin
87894>>>>>>>                    If (ghoStatusPanel <> 0) Begin
87896>>>>>>>                        Get_Field_Value hTable 0 to iRecord
87899>>>>>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_DUF_UpdateVersion * String(iRecord))
87900>>>>>>>                    End
87900>>>>>>>>
87900>>>>>>>                    Reread hTable
87904>>>>>>>                        Set_Field_Value hTable iField to sColumnValue
87907>>>>>>>                        SaveRecord hTable
87908>>>>>>>                    Unlock
87909>>>>>>>>
87909>>>>>>>                End
87909>>>>>>>>
87909>>>>>>>           Until (not(Found))
87911>>>>>>>        End
87911>>>>>>>>
87911>>>>>>>
87911>>>>>>>        Move (Err = False) to bRetval
87912>>>>>>>        Move iCurrErr to Err
87913>>>>>>>
87913>>>>>>>        Function_Return bRetval
87914>>>>>>>    End_Function
87915>>>>>>>
87915>>>>>>>    // Note: This can only be used from within a Structure_Start/End construct.
87915>>>>>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
87917>>>>>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
87917>>>>>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
87917>>>>>>>        String sFieldName sDriverID sTableName sDefaultValue
87917>>>>>>>
87917>>>>>>>        Get psDriverID to sDriverID
87918>>>>>>>        Get piDbType to iDbType
87919>>>>>>>        Get UtilTableHandleToString hTable to sTableName
87920>>>>>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
87921>>>>>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
87922>>>>>>>        Get _UtilTableIsSql hTable to bIsSqlTable
87923>>>>>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
87925>>>>>>>            Move True to bIsSqlTable
87926>>>>>>>        End
87926>>>>>>>>
87926>>>>>>>        Move False to bIsOpen
87927>>>>>>>        If (hTable > 0) Begin
87929>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87932>>>>>>>        End
87932>>>>>>>>
87932>>>>>>>        If (bIsOpen = True) Begin
87934>>>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
87937>>>>>>>        End
87937>>>>>>>>
87937>>>>>>>        Else Begin
87938>>>>>>>            Get pbRecnum to bRecnumTable
87939>>>>>>>        End
87939>>>>>>>>
87939>>>>>>>
87939>>>>>>>        Move False to Err
87940>>>>>>>        Move (SizeOfArray(aColumns)) to iSize
87941>>>>>>>        Decrement iSize
87942>>>>>>>        for iCount from 0 to iSize
87948>>>>>>>>
87948>>>>>>>            Move aColumns[iCount].sFieldName to sFieldName
87949>>>>>>>            If (hTable > 0) Begin
87951>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87952>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87953>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
87956>>>>>>>                Move (Trim(sFieldName) <> "") to bFieldExists
87957>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
87958>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87959>>>>>>>            End
87959>>>>>>>>
87959>>>>>>>            Else Begin
87960>>>>>>>                Move False to bFieldExists
87961>>>>>>>            End
87961>>>>>>>>
87961>>>>>>>
87961>>>>>>>            If (bFieldExists = False) Begin
87963>>>>>>>                Move 0 to iColumn
87964>>>>>>>                Create_Field hTable At iColumn
87965>>>>>>>            End
87965>>>>>>>>
87965>>>>>>>            Else Begin
87966>>>>>>>                Move iCount to iColumn
87967>>>>>>>            End
87967>>>>>>>>
87967>>>>>>>
87967>>>>>>>            Set Private.piCurrentField to iColumn
87968>>>>>>>
87968>>>>>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
87969>>>>>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
87972>>>>>>>
87972>>>>>>>            Move aColumns[iCount].iType to iType
87973>>>>>>>            Move (not(iType < -1490)) to bNativeType
87974>>>>>>>            If (iType < -1490) Begin
87976>>>>>>>                Move (iType + 1500) to iType
87977>>>>>>>            End
87977>>>>>>>>
87977>>>>>>>
87977>>>>>>>            If (bIsSqlTable = True) Begin
87979>>>>>>>                If (aColumns[iCount].bIsSQLType = True) Begin
87981>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
87982>>>>>>>//                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
87982>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType
87985>>>>>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
87988>>>>>>>
87988>>>>>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
87989>>>>>>>                    If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
87991>>>>>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
87992>>>>>>>                    End
87992>>>>>>>>
87992>>>>>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue
87995>>>>>>>
87995>>>>>>>                End
87995>>>>>>>>
87995>>>>>>>                Else Begin
87996>>>>>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
87999>>>>>>>                End
87999>>>>>>>>
87999>>>>>>>            End
87999>>>>>>>>
87999>>>>>>>            Else Begin
88000>>>>>>>                If (bCreating = False) Begin
88002>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
88003>>>>>>>                    If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88005>>>>>>>                        Move DF_DATE to iType
88006>>>>>>>                    End
88006>>>>>>>>
88006>>>>>>>                End
88006>>>>>>>>
88006>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
88009>>>>>>>            End
88009>>>>>>>>
88009>>>>>>>
88009>>>>>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
88010>>>>>>>            If (bIsDateType = False) Begin
88012>>>>>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
88015>>>>>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
88018>>>>>>>            End
88018>>>>>>>>
88018>>>>>>>
88018>>>>>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
88020>>>>>>>                Move 0 to iIndex
88021>>>>>>>                Create_Index hTable at iIndex
88022>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
88025>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
88028>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
88031>>>>>>>
88031>>>>>>>                // If we have an identity table - we must create a primary_key table.
88031>>>>>>>                If (bIsSqlTable = True) Begin
88033>>>>>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to True
88036>>>>>>>                        Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True
88039>>>>>>>                End
88039>>>>>>>>
88039>>>>>>>            End
88039>>>>>>>>
88039>>>>>>>        Loop
88040>>>>>>>>
88040>>>>>>>
88040>>>>>>>        Function_Return (Err = False)
88041>>>>>>>    End_Function
88042>>>>>>>
88042>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
88042>>>>>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
88044>>>>>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
88044>>>>>>>        Boolean bOK bIsSqlTable
88044>>>>>>>        String sFieldNameTo
88044>>>>>>>
88044>>>>>>>        If (num_arguments > 4) Begin
88046>>>>>>>            Move iPrec to iPrecFrom
88047>>>>>>>        End
88047>>>>>>>>
88047>>>>>>>        If (iTypeFrom < -1490) Begin
88049>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
88050>>>>>>>        End
88050>>>>>>>>
88050>>>>>>>
88050>>>>>>>        Get AutoConnectionIDLogin to bOK
88051>>>>>>>        Move False to Err
88052>>>>>>>        Get OpenTableExclusive hTable to bOK
88053>>>>>>>        If (bOK = False) Begin
88055>>>>>>>            Function_Return False
88056>>>>>>>        End
88056>>>>>>>>
88056>>>>>>>
88056>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88057>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88058>>>>>>>        Field_Map hTable sFieldNameFrom to iColumn
88060>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88061>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88062>>>>>>>        If (Err = True) Begin
88064>>>>>>>            Function_Return False
88065>>>>>>>        End
88065>>>>>>>>
88065>>>>>>>
88065>>>>>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
88068>>>>>>>        Get _UtilTableIsSql hTable to bIsSqlTable
88069>>>>>>>        If (bIsSqlTable = False) Begin
88071>>>>>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
88074>>>>>>>        End
88074>>>>>>>>
88074>>>>>>>        Else Begin
88075>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
88078>>>>>>>        End
88078>>>>>>>>
88078>>>>>>>        // Let the driver decide the other values;
88078>>>>>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
88081>>>>>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
88084>>>>>>>
88084>>>>>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
88086>>>>>>>            Function_Return False
88087>>>>>>>        End
88087>>>>>>>>
88087>>>>>>>
88087>>>>>>>        Set Private.phCurrentTable to hTable
88088>>>>>>>        Set Private.piCurrentField to iColumn
88089>>>>>>>
88089>>>>>>>        Structure_Start hTable
88090>>>>>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
88093>>>>>>>            If (bIsSqlTable = False) Begin
88095>>>>>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
88098>>>>>>>            End
88098>>>>>>>>
88098>>>>>>>            Else Begin
88099>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
88102>>>>>>>            End
88102>>>>>>>>
88102>>>>>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to (iLengthFrom + iPrecFrom)
88105>>>>>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
88108>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88109>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88111>>>>>>>
88111>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88112>>>>>>>        Function_Return (Err = False)
88113>>>>>>>    End_Function
88114>>>>>>>
88114>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
88114>>>>>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
88116>>>>>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
88116>>>>>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
88116>>>>>>>        String sFieldNameTo sDriverIDTo
88116>>>>>>>        tColumnType ColumnType
88116>>>>>>>        tColumnType ColumnType
88116>>>>>>>
88116>>>>>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
88117>>>>>>>        Get piDbType to iDbType
88118>>>>>>>        If (num_arguments > 4) Begin
88120>>>>>>>            Move iPrec to iPrecFrom
88121>>>>>>>            Move iOpt  to iOptionFrom
88122>>>>>>>        End
88122>>>>>>>>
88122>>>>>>>        If (iTypeFrom < -1490) Begin
88124>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
88125>>>>>>>        End
88125>>>>>>>>
88125>>>>>>>
88125>>>>>>>        Get AutoConnectionIDLogin to bOK
88126>>>>>>>        Move False to Err
88127>>>>>>>        Close hTable
88128>>>>>>>        Get OpenTableExclusive hTable to bOK
88129>>>>>>>        If (bOK = False) Begin
88131>>>>>>>            Function_Return False
88132>>>>>>>        End
88132>>>>>>>>
88132>>>>>>>
88132>>>>>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
88135>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
88138>>>>>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
88139>>>>>>>        If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88141>>>>>>>            Move DF_DATE to iDataFlexType
88142>>>>>>>        End
88142>>>>>>>>
88142>>>>>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
88145>>>>>>>
88145>>>>>>>        If (bIsSQLTableTo = True) Begin
88147>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeTo
88150>>>>>>>        End
88150>>>>>>>>
88150>>>>>>>        Else Begin
88151>>>>>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
88154>>>>>>>        End
88154>>>>>>>>
88154>>>>>>>
88154>>>>>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
88157>>>>>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
88160>>>>>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo
88163>>>>>>>
88163>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
88163>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types.
88163>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
88165>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeTo
88166>>>>>>>            If (iTypeTo = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88168>>>>>>>                Move DF_DATE to iTypeTo  
88169>>>>>>>            End
88169>>>>>>>>
88169>>>>>>>        End
88169>>>>>>>>
88169>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
88172>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeFrom
88173>>>>>>>        End
88173>>>>>>>>
88173>>>>>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
88174>>>>>>>
88174>>>>>>>        If (bCompareDate_DateTime = False) Begin
88176>>>>>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
88177>>>>>>>            If (bSkip = True) Begin
88179>>>>>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
88181>>>>>>>                    Function_Return True
88182>>>>>>>                End
88182>>>>>>>>
88182>>>>>>>            End
88182>>>>>>>>
88182>>>>>>>        End
88182>>>>>>>>
88182>>>>>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
88185>>>>>>>            Function_Return True
88186>>>>>>>        End
88186>>>>>>>>
88186>>>>>>>
88186>>>>>>>        Set Private.phCurrentTable to hTable
88187>>>>>>>        Set Private.piCurrentField to iColumn
88188>>>>>>>
88188>>>>>>>        Structure_Start hTable
88189>>>>>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
88191>>>>>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
88194>>>>>>>            End
88194>>>>>>>>
88194>>>>>>>
88194>>>>>>>            If (bIsSameDataType = False) Begin
88196>>>>>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
88199>>>>>>>                If (bIsSQLTableTo = True) Begin
88201>>>>>>>                        Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iTypeFrom
88204>>>>>>>                End
88204>>>>>>>>
88204>>>>>>>            End
88204>>>>>>>>
88204>>>>>>>
88204>>>>>>>            If (iLengthFrom <> iLengthTo) Begin
88206>>>>>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
88209>>>>>>>            End
88209>>>>>>>>
88209>>>>>>>            If (iPrecFrom <> iPrecTo) Begin
88211>>>>>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
88214>>>>>>>            End
88214>>>>>>>>
88214>>>>>>>
88214>>>>>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
88216>>>>>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
88216>>>>>>>                If (bRecnumTable = True) Begin
88218>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
88221>>>>>>>                End
88221>>>>>>>>
88221>>>>>>>
88221>>>>>>>                // We might need to create an index here.
88221>>>>>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
88221>>>>>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
88221>>>>>>>                // index update checking logic.
88221>>>>>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
88224>>>>>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
88226>>>>>>>                    Create_Index hTable At iIndex
88227>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
88230>>>>>>>                End
88230>>>>>>>>
88230>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
88233>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
88236>>>>>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
88239>>>>>>>                If (bIsSQLTableTo = True) Begin
88241>>>>>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
88244>>>>>>>                End
88244>>>>>>>>
88244>>>>>>>            End
88244>>>>>>>>
88244>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88245>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88247>>>>>>>
88247>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88248>>>>>>>        Function_Return (Err = False)
88249>>>>>>>    End_Function
88250>>>>>>>
88250>>>>>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
88252>>>>>>>        Boolean bOK
88252>>>>>>>
88252>>>>>>>        Get AutoConnectionIDLogin to bOK
88253>>>>>>>        Move False to Err
88254>>>>>>>        Get OpenTableExclusive hTable to bOK
88255>>>>>>>        If (bOK = False) Begin
88257>>>>>>>            Function_Return False
88258>>>>>>>        End
88258>>>>>>>>
88258>>>>>>>
88258>>>>>>>        Structure_Start hTable
88259>>>>>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
88262>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88263>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88265>>>>>>>
88265>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88266>>>>>>>        Function_Return (Err = False)
88267>>>>>>>    End_Function
88268>>>>>>>
88268>>>>>>>    // To move an existing field to another position in a table.
88268>>>>>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Integer iLength Integer iPrecision Returns Boolean
88270>>>>>>>        String sColumn sDriverID
88270>>>>>>>        Integer iType iSQLType
88270>>>>>>>        Boolean bOK bIsDate
88270>>>>>>>
88270>>>>>>>        Close hTable
88271>>>>>>>        Get AutoConnectionIDLogin to bOK
88272>>>>>>>        Get OpenTableExclusive hTable to bOK
88273>>>>>>>        If (bOK = False) Begin
88275>>>>>>>            Function_Return False
88276>>>>>>>        End
88276>>>>>>>>
88276>>>>>>>
88276>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88279>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
88281>>>>>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
88282>>>>>>>>
88282>>>>>>>            Function_Return False
88283>>>>>>>        End
88283>>>>>>>>
88283>>>>>>>
88283>>>>>>>        Set Action_Text of ghoStatusPanel to "Restructures table..."
88284>>>>>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
88287>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
88290>>>>>>>        If (bIsSQLType = True) Begin
88292>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iOld to iSQLType
88295>>>>>>>            Get UtilColumnIsDateType iSQLType bIsSQLType  to bIsDate
88296>>>>>>>        End
88296>>>>>>>>
88296>>>>>>>        Else Begin
88297>>>>>>>            Get UtilColumnIsDateType iType bIsSQLType  to bIsDate
88298>>>>>>>        End
88298>>>>>>>>
88298>>>>>>>
88298>>>>>>>        Set Private.phCurrentTable to hTable
88299>>>>>>>        Set Private.piCurrentField to iOld
88300>>>>>>>
88300>>>>>>>        Move False to Err
88301>>>>>>>
88301>>>>>>>        Structure_Start hTable
88302>>>>>>>            Delete_Field hTable iOld
88303>>>>>>>            Create_Field hTable At iNew
88304>>>>>>>            
88304>>>>>>>            // This one is the crucial line:
88304>>>>>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
88307>>>>>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
88310>>>>>>>            
88310>>>>>>>            // If SQL table it is important that we don't try to change the field type, as MS-SQL then will generate an error.
88310>>>>>>>            If (bIsSQLType = True and bIsDate = False) Begin
88312>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType
88315>>>>>>>            End
88315>>>>>>>>
88315>>>>>>>            If (bIsDate = False) Begin
88317>>>>>>>                Set_Attribute DF_FIELD_TYPE   of hTable iNew to iType
88320>>>>>>>                Set_Attribute DF_FIELD_LENGTH of hTable iNew to iLength
88323>>>>>>>            End
88323>>>>>>>>
88323>>>>>>>            If (iType = DF_BCD) Begin
88325>>>>>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
88328>>>>>>>            End
88328>>>>>>>>
88328>>>>>>>
88328>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88330>>>>>>>
88330>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88331>>>>>>>        Move (not(Err)) to bOK
88332>>>>>>>        Move False to Err
88333>>>>>>>        Move 0 to LastErr
88334>>>>>>>        Function_Return bOK
88335>>>>>>>    End_Function 
88336>>>>>>>    
88336>>>>>>>    // Deletes a column name for the passed table number (and column number).
88336>>>>>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
88338>>>>>>>        Integer iColumn
88338>>>>>>>        Boolean bOK
88338>>>>>>>
88338>>>>>>>        Get AutoConnectionIDLogin to bOK
88339>>>>>>>        Move False to Err
88340>>>>>>>        Close hTable
88341>>>>>>>        Get OpenTableExclusive hTable to bOK
88342>>>>>>>        If (bOK = False) Begin
88344>>>>>>>            Function_Return False
88345>>>>>>>        End
88345>>>>>>>>
88345>>>>>>>
88345>>>>>>>        If (not(Err)) Begin
88347>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88348>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88349>>>>>>>            Field_Map hTable sFieldName to iColumn
88351>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
88352>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88353>>>>>>>            If (iColumn = 0) Begin
88355>>>>>>>                Move 0 to LastErr
88356>>>>>>>                Function_Return False
88357>>>>>>>            End
88357>>>>>>>>
88357>>>>>>>            Move False to Err
88358>>>>>>>
88358>>>>>>>            Set Private.phCurrentTable to hTable
88359>>>>>>>            Set Private.piCurrentField to iColumn
88360>>>>>>>
88360>>>>>>>            Structure_Start hTable
88361>>>>>>>                Delete_Field hTable iColumn
88362>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88363>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88365>>>>>>>            Set Action_Text of ghoStatusPanel to ""
88366>>>>>>>        End
88366>>>>>>>>
88366>>>>>>>        Else Begin
88367>>>>>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
88368>>>>>>>>
88368>>>>>>>        End
88368>>>>>>>>
88368>>>>>>>
88368>>>>>>>        Function_Return (Err = False)
88369>>>>>>>    End_Function
88370>>>>>>>
88370>>>>>>>    // Renames a field for the passed table number & old field name & new field name
88370>>>>>>>    // Returns True if no errors occured.
88370>>>>>>>    // Sample usage:
88370>>>>>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
88370>>>>>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
88372>>>>>>>        Integer iField
88372>>>>>>>        Boolean bOK bExists bIsOpen
88372>>>>>>>
88372>>>>>>>        Get UtilColumnExists hTable sNewFieldName to bExists
88373>>>>>>>        If (bExists = True) Begin
88375>>>>>>>            Function_Return False
88376>>>>>>>        End
88376>>>>>>>>
88376>>>>>>>
88376>>>>>>>        // Note: The Field_Map command does _not_ work if the table has been
88376>>>>>>>        //       opened exclusively, so we first open it in normal mode.
88376>>>>>>>        Close hTable
88377>>>>>>>        Open hTable
88379>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88382>>>>>>>        If (bIsOpen = False) Begin
88384>>>>>>>            Function_Return False
88385>>>>>>>        End
88385>>>>>>>>
88385>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88386>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88387>>>>>>>        Field_Map hTable sOldFieldName to iField
88389>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88390>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88391>>>>>>>
88391>>>>>>>        Get AutoConnectionIDLogin to bOK
88392>>>>>>>        Get OpenTableExclusive hTable to bOK
88393>>>>>>>        If (bOK = False) Begin
88395>>>>>>>            Function_Return False
88396>>>>>>>        End
88396>>>>>>>>
88396>>>>>>>
88396>>>>>>>        Move False to Err
88397>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
88398>>>>>>>        Set Private.phCurrentTable to hTable
88399>>>>>>>        Set Private.piCurrentField to iField
88400>>>>>>>
88400>>>>>>>        If (iField > 0) Begin
88402>>>>>>>            Structure_Start hTable
88403>>>>>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
88406>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88407>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88409>>>>>>>        End
88409>>>>>>>>
88409>>>>>>>        Else Begin
88410>>>>>>>            Move 0 to LastErr
88411>>>>>>>            Move False to Err
88412>>>>>>>        End
88412>>>>>>>>
88412>>>>>>>
88412>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88413>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
88414>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88415>>>>>>>
88415>>>>>>>        Function_Return (Err = False)
88416>>>>>>>    End_Function
88417>>>>>>>
88417>>>>>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
88419>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
88419>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
88420>>>>>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo iColumnNumber
88420>>>>>>>        Boolean bRenameField
88420>>>>>>>
88420>>>>>>>        Open hTable
88422>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88423>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88424>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88425>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
88428>>>>>>>        Move (iSize max iNumberOfFieldsTo) to iSize
88429>>>>>>>        Decrement iSize
88430>>>>>>>        for iCount from 0 to iSize
88436>>>>>>>>
88436>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
88438>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88439>>>>>>>
88439>>>>>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
88441>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iFieldTo = 0) Begin
88443>>>>>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iColumnNumber
88444>>>>>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount]      to bRenameField
88445>>>>>>>                    If (iColumnNumber = -1 and bRenameField = False) Begin
88447>>>>>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber
88448>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
88449>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom
88450>>>>>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
88451>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
88452>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
88453>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
88454>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
88455>>>>>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
88456>>>>>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
88457>>>>>>>                        Increment iItem
88458>>>>>>>                    End
88458>>>>>>>>
88458>>>>>>>                End
88458>>>>>>>>
88458>>>>>>>            End
88458>>>>>>>>
88458>>>>>>>        Loop
88459>>>>>>>>
88459>>>>>>>
88459>>>>>>>        Move False to Err
88460>>>>>>>        Move 0 to LastErr
88461>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88462>>>>>>>        Function_Return aAPIColumnsToInsert
88463>>>>>>>    End_Function
88464>>>>>>>
88464>>>>>>>    Function UtilColumnsInsert String sDriverIDFrom Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
88466>>>>>>>        Integer iSize iCount
88466>>>>>>>        Boolean bOK
88466>>>>>>>        tAPIColumn[] aColumnsTo
88466>>>>>>>        tAPIColumn[] aColumnsTo
88467>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88467>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88468>>>>>>>
88468>>>>>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
88469>>>>>>>        If (iSize = 0) Begin
88471>>>>>>>            Function_Return True
88472>>>>>>>        End
88472>>>>>>>>
88472>>>>>>>
88472>>>>>>>        Move False to Err
88473>>>>>>>        Decrement iSize
88474>>>>>>>        for iCount from 0 to iSize
88480>>>>>>>>
88480>>>>>>>            Get ApiColumnInsert sDriverIDFrom hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
88481>>>>>>>        Loop
88482>>>>>>>>
88482>>>>>>>
88482>>>>>>>        Function_Return bOK
88483>>>>>>>    End_Function
88484>>>>>>>
88484>>>>>>>    // Returns a struct array with fields that has the same names but different field numbers.
88484>>>>>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
88486>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
88486>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
88487>>>>>>>        Integer iSize iCount iItem iShouldMove
88487>>>>>>>
88487>>>>>>>        Move 0 to iItem
88488>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88489>>>>>>>        Decrement iSize
88490>>>>>>>        for iCount from 0 to iSize
88496>>>>>>>>
88496>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
88498>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
88499>>>>>>>                If (iShouldMove <> -1) Begin
88501>>>>>>>                    Move aAPIColumnCompare[iCount] to aAPIColumnsToMove[iItem]
88502>>>>>>>                    Move iShouldMove               to aAPIColumnsToMove[iItem].iFieldNumberTo
88503>>>>>>>                    Move aAPIColumnCompare[iShouldMove - 1].sFieldNameTo to aAPIColumnsToMove[iItem].sFieldNameTo
88504>>>>>>>                    Increment iItem
88505>>>>>>>                End
88505>>>>>>>>
88505>>>>>>>            End
88505>>>>>>>>
88505>>>>>>>        Loop
88506>>>>>>>>
88506>>>>>>>
88506>>>>>>>        Move False to Err
88507>>>>>>>        Move 0 to LastErr
88508>>>>>>>        Function_Return aAPIColumnsToMove
88509>>>>>>>    End_Function
88510>>>>>>>
88510>>>>>>>    Function UtilColumnsMove Handle hTable tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
88512>>>>>>>        Integer iSize iCount
88512>>>>>>>        Boolean bOK
88512>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88512>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88513>>>>>>>
88513>>>>>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
88514>>>>>>>        If (iSize = 0) Begin
88516>>>>>>>            Function_Return True
88517>>>>>>>        End
88517>>>>>>>>
88517>>>>>>>
88517>>>>>>>        Move False to Err
88518>>>>>>>        Decrement iSize
88519>>>>>>>        for iCount from 0 to iSize
88525>>>>>>>>
88525>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88526>>>>>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
88528>>>>>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom aAPIColumnsToMove[iCount].iLengthFrom aAPIColumnsToMove[iCount].iPrecisionFrom to bOK
88529>>>>>>>                If (bOK = True) Begin
88531>>>>>>>                    Get UtilColumnsStructFill hTable to aColumnsTo
88532>>>>>>>                    Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88533>>>>>>>                    Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIColumnsToMove
88534>>>>>>>                    If (SizeOfArray(aAPIColumnsToMove)) Begin
88536>>>>>>>                        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
88537>>>>>>>                        Decrement iSize
88538>>>>>>>                        Move 0 to iCount
88539>>>>>>>                    End
88539>>>>>>>>
88539>>>>>>>                End
88539>>>>>>>>
88539>>>>>>>                Else Begin
88540>>>>>>>                    Move iSize to iCount // We're out of here! Else there will be an error generated for each field.
88541>>>>>>>                End
88541>>>>>>>>
88541>>>>>>>            End
88541>>>>>>>>
88541>>>>>>>        Loop
88542>>>>>>>>
88542>>>>>>>
88542>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88543>>>>>>>        If (LastErr = DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) Begin
88545>>>>>>>            Move 0 to LastErr
88546>>>>>>>        End
88546>>>>>>>>
88546>>>>>>>        Function_Return bOK
88547>>>>>>>    End_Function
88548>>>>>>>
88548>>>>>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
88548>>>>>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
88548>>>>>>>    // - The "FROM" field name is <> "TO" field name
88548>>>>>>>    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
88548>>>>>>>    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
88548>>>>>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
88550>>>>>>>        Boolean bShouldRename
88550>>>>>>>        String sFieldNameFrom sFieldNameTo
88550>>>>>>>
88550>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
88551>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo
88552>>>>>>>        If (sFieldNameFrom = sFieldNameTo) Begin
88554>>>>>>>            Function_Return False
88555>>>>>>>        End
88555>>>>>>>>
88555>>>>>>>
88555>>>>>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
88556>>>>>>>//        If (bShouldRename = False) Begin
88556>>>>>>>//            Function_Return False
88556>>>>>>>//        End
88556>>>>>>>//
88556>>>>>>>//        If (sFieldNameFrom contains sFieldNameTo) Begin
88556>>>>>>>//            Function_Return True
88556>>>>>>>//        End
88556>>>>>>>
88556>>>>>>>        Function_Return bShouldRename
88557>>>>>>>    End_Function
88558>>>>>>>
88558>>>>>>>    // Returns -1 if the passed iColumn number doesn't exist with the same name in the aAPIColumnCompare struct array.
88558>>>>>>>    // Else it returns the column/field number of the field that exists in another position.
88558>>>>>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Integer
88560>>>>>>>        Integer iCount iSize iRetval
88560>>>>>>>        String sFieldNameFrom
88560>>>>>>>
88560>>>>>>>        Move -1 to iRetval
88561>>>>>>>        If (aAPIColumnCompare[iColumn].bExistsFrom = False or aAPIColumnCompare[iColumn].bExistsTo = False) Begin
88563>>>>>>>            Function_Return iRetval
88564>>>>>>>        End
88564>>>>>>>>
88564>>>>>>>
88564>>>>>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
88565>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88566>>>>>>>        Decrement iSize
88567>>>>>>>        for iCount from 0 to iSize
88573>>>>>>>>
88573>>>>>>>            // We're only interested in fields other than the passed field/column number:
88573>>>>>>>            If (iCount <> iColumn) Begin
88575>>>>>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
88577>>>>>>>                    Move (iCount + 1) to iRetval
88578>>>>>>>                End
88578>>>>>>>>
88578>>>>>>>            End
88578>>>>>>>>
88578>>>>>>>        Loop
88579>>>>>>>>
88579>>>>>>>
88579>>>>>>>        Move 0 to LastErr
88580>>>>>>>        Function_Return iRetval
88581>>>>>>>    End_Function
88582>>>>>>>
88582>>>>>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
88584>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
88584>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
88585>>>>>>>        Integer iSize iCount iItem iFieldTo iShouldMove
88585>>>>>>>        Boolean bRenameField
88585>>>>>>>
88585>>>>>>>        Open hTable
88587>>>>>>>        Move 0 to iItem
88588>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88589>>>>>>>        Decrement iSize
88590>>>>>>>        for iCount from 0 to iSize
88596>>>>>>>>
88596>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
88598>>>>>>>                // Check if the field exists in another position (other field number)
88598>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
88599>>>>>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
88600>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iShouldMove = -1 and bRenameField = True) Begin
88602>>>>>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber
88603>>>>>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo
88604>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
88605>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
88606>>>>>>>                    Increment iItem
88607>>>>>>>                End
88607>>>>>>>>
88607>>>>>>>            End
88607>>>>>>>>
88607>>>>>>>        Loop
88608>>>>>>>>
88608>>>>>>>
88608>>>>>>>        Move False to Err
88609>>>>>>>        Move 0 to LastErr
88610>>>>>>>        Function_Return aAPIColumnsToRename
88611>>>>>>>    End_Function
88612>>>>>>>
88612>>>>>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
88614>>>>>>>        Integer iSize iCount
88614>>>>>>>        Boolean bOK
88614>>>>>>>        tAPIColumn[] aColumnsTo
88614>>>>>>>        tAPIColumn[] aColumnsTo
88615>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88615>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88616>>>>>>>
88616>>>>>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
88617>>>>>>>        If (iSize = 0) Begin
88619>>>>>>>            Function_Return True
88620>>>>>>>        End
88620>>>>>>>>
88620>>>>>>>
88620>>>>>>>        Move False to Err
88621>>>>>>>        Decrement iSize
88622>>>>>>>        For iCount from 0 to iSize
88628>>>>>>>>
88628>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88629>>>>>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK
88630>>>>>>>        Loop
88631>>>>>>>>
88631>>>>>>>
88631>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88632>>>>>>>        Function_Return bOK
88633>>>>>>>    End_Function
88634>>>>>>>
88634>>>>>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
88636>>>>>>>        Boolean bDateType
88636>>>>>>>
88636>>>>>>>        If (bIsSQLTableTo = True) Begin
88638>>>>>>>            Move (iType = SQL_DATE or iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
88639>>>>>>>        End
88639>>>>>>>>
88639>>>>>>>        Else Begin
88640>>>>>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
88641>>>>>>>        End
88641>>>>>>>>
88641>>>>>>>
88641>>>>>>>        Function_Return bDateType
88642>>>>>>>    End_Function
88643>>>>>>>
88643>>>>>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
88645>>>>>>>        Integer iCount iColumns iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
88645>>>>>>>        Integer iCount2 iColumn2
88645>>>>>>>        Handle hFile
88645>>>>>>>        Boolean bFieldExistsFrom bFieldExistsTo bIsSQLDriver bIsSame bOK bSkip
88645>>>>>>>        Boolean bRecnum bIsSQLTableTo bRecnumTable bIsOpen bSkipTypeChange bIsDateType
88645>>>>>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
88645>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
88645>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
88650>>>>>>>        tColumnType ColumnType
88650>>>>>>>        tColumnType ColumnType
88650>>>>>>>
88650>>>>>>>        Move False to Err
88651>>>>>>>        Close hTable
88652>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88653>>>>>>>        If (bIsOpen = False) Begin
88655>>>>>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
88656>>>>>>>>
88656>>>>>>>            Function_Return False
88657>>>>>>>        End 
88657>>>>>>>>
88657>>>>>>>        
88657>>>>>>>        Get piDbType to iDbType
88658>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
88661>>>>>>>        Move bIsSQLTableFrom to bIsSQLDriver
88662>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
88663>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
88666>>>>>>>
88666>>>>>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88667>>>>>>>
88667>>>>>>>        // Before we start to change the table we need to do three things;
88667>>>>>>>        // 1) Insert any new fields
88667>>>>>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
88668>>>>>>>        If (SizeOfArray(aApiInsertColumns)) Begin
88670>>>>>>>            Get UtilColumnsInsert sDriverIDFrom hTable aApiInsertColumns to bOK
88671>>>>>>>            If (bOK = False) Begin
88673>>>>>>>                Function_Return False
88674>>>>>>>            End
88674>>>>>>>>
88674>>>>>>>            // Update info with changes made.
88674>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88675>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88676>>>>>>>        End
88676>>>>>>>>
88676>>>>>>>
88676>>>>>>>        // 2) Move fields with same names
88676>>>>>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
88677>>>>>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
88679>>>>>>>            Get UtilColumnsMove hTable aColumnsFrom aColumnsTo aAPIMoveColumns to bOK
88680>>>>>>>            If (bOK = False) Begin
88682>>>>>>>                Function_Return False
88683>>>>>>>            End
88683>>>>>>>>
88683>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88684>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88685>>>>>>>        End
88685>>>>>>>>
88685>>>>>>>        
88685>>>>>>>        // 3) Rename fields
88685>>>>>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
88686>>>>>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
88688>>>>>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
88689>>>>>>>            If (bOK = False) Begin
88691>>>>>>>                Function_Return False
88692>>>>>>>            End
88692>>>>>>>>
88692>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88693>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88694>>>>>>>        End
88694>>>>>>>>
88694>>>>>>>
88694>>>>>>>        // Note: Fields will be removed if needed in the Structure_Start/End below.
88694>>>>>>>        // Get utilColumnsCheckForRemoves hTable aAPIColumnCompare to aAPIRemoveColumns
88694>>>>>>>
88694>>>>>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again:
88694>>>>>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
88696>>>>>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
88697>>>>>>>            If (bIsSame = True) Begin
88699>>>>>>>                Function_Return True
88700>>>>>>>            End
88700>>>>>>>>
88700>>>>>>>        End
88700>>>>>>>>
88700>>>>>>>
88700>>>>>>>        Move False to Err
88701>>>>>>>        // We can now continue to make standard field changes:
88701>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88702>>>>>>>        Set Private.phCurrentTable to hTable
88703>>>>>>>        Move hTable to hFile
88704>>>>>>>        Structure_Start hFile sDriverIDTo
88705>>>>>>>
88705>>>>>>>            Move (SizeOfArray(aAPIColumnCompare)) to iColumns
88706>>>>>>>            Decrement iColumns
88707>>>>>>>            for iCount from 0 to iColumns
88713>>>>>>>>
88713>>>>>>>                Send DoAdvance of ghoProgressBar
88714>>>>>>>
88714>>>>>>>                Move aAPIColumnCompare[iCount].iFieldNumber to iColumn
88715>>>>>>>                Set Private.piCurrentField                  to iColumn
88716>>>>>>>                Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom aAPIColumnCompare[iCount].bIsSQLTypeTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
88717>>>>>>>                If (bIsSame = False) Begin
88719>>>>>>>
88719>>>>>>>                    Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
88720>>>>>>>                    If (bFieldExistsFrom = True) Begin
88722>>>>>>>                        Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
88723>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
88724>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom
88725>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
88726>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
88727>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
88728>>>>>>>
88728>>>>>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
88729>>>>>>>                        If (iTypeFrom < -1490) Begin
88731>>>>>>>                            Move (iTypeFrom + 1500)                     to iTypeFrom
88732>>>>>>>                        End
88732>>>>>>>>
88732>>>>>>>
88732>>>>>>>                        // If one of the two tables are SQL and the other Embedded we need to "translate"
88732>>>>>>>                        // data types between Embedded and SQL, else we can't compare the data types.
88732>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
88734>>>>>>>                            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
88735>>>>>>>                            If (iTypeFrom = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88737>>>>>>>                                Move DF_DATE to iTypeFrom
88738>>>>>>>                            End
88738>>>>>>>>
88738>>>>>>>                        End
88738>>>>>>>>
88738>>>>>>>                        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
88741>>>>>>>                            Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
88742>>>>>>>                        End
88742>>>>>>>>
88742>>>>>>>
88742>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
88743>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
88744>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
88745>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
88746>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
88747>>>>>>>
88747>>>>>>>                        Move False to bSkipTypeChange
88748>>>>>>>                        If (bCompareDate_DateTime = False) Begin
88750>>>>>>>                            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
88751>>>>>>>                        End
88751>>>>>>>>
88751>>>>>>>
88751>>>>>>>                        If (bFieldExistsTo = False) Begin
88753>>>>>>>                            Move 0 to iColumn
88754>>>>>>>                            Create_Field hFile At iColumn
88755>>>>>>>                            Set Private.piCurrentField to iColumn
88756>>>>>>>                        End
88756>>>>>>>>
88756>>>>>>>
88756>>>>>>>                        If (sFieldNameFrom <> sFieldNameTo) Begin
88758>>>>>>>                            Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
88761>>>>>>>                        End
88761>>>>>>>>
88761>>>>>>>
88761>>>>>>>                        // Note: In MS-SQL it is vital that *nothing* gets changed for e.g. a "datetime" column, else error: 22018 is generated by the SQL backend:
88761>>>>>>>                        //       "Explicit conversion from data type int to datetime2 is not allowed", which will make the update to fail, and all changes for the table is rollbacked. 
88761>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity and bSkipTypeChange = False) Begin
88763>>>>>>>                            Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
88766>>>>>>>                            Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
88767>>>>>>>                            If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
88769>>>>>>>                                Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
88770>>>>>>>                            End
88770>>>>>>>>
88770>>>>>>>                            Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
88773>>>>>>>                        End
88773>>>>>>>>
88773>>>>>>>
88773>>>>>>>                        If (bSkipTypeChange = False) Begin
88775>>>>>>>                            If (iTypeFrom <> iTypeTo) Begin
88777>>>>>>>                                If (bIsSQLTableTo = True) Begin
88779>>>>>>>                                    Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iTypeFrom
88782>>>>>>>                                End
88782>>>>>>>>
88782>>>>>>>                                Else Begin                                                   
88783>>>>>>>                                    If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88785>>>>>>>                                        Move DF_DATE to iDataFlexType  // Date
88786>>>>>>>                                    End
88786>>>>>>>>
88786>>>>>>>                                    Set_Attribute DF_FIELD_TYPE of hFile iColumn to iDataFlexType
88789>>>>>>>                                End
88789>>>>>>>>
88789>>>>>>>                            End
88789>>>>>>>>
88789>>>>>>>                        End
88789>>>>>>>>
88789>>>>>>>
88789>>>>>>>                        Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType
88790>>>>>>>                        // We can't set the length or precision for Date type columns (they are fixed).
88790>>>>>>>                        If (bIsDateType = False and iLengthFrom <> iLengthTo) Begin
88792>>>>>>>                            Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
88795>>>>>>>                        End
88795>>>>>>>>
88795>>>>>>>                        // We do want to set the precision for e.g. DateTime2 (can be 3 or 7, but DataFlex can just handle "3").
88795>>>>>>>                        If (iPrecisionFrom <> iPrecisionTo) Begin
88797>>>>>>>                            Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
88800>>>>>>>                        End
88800>>>>>>>>
88800>>>>>>>
88800>>>>>>>                        If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
88802>>>>>>>                            // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
88802>>>>>>>                            If (bRecnumTable = True) Begin
88804>>>>>>>                                Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
88807>>>>>>>                            End
88807>>>>>>>>
88807>>>>>>>
88807>>>>>>>                            // We might need to create an index here.
88807>>>>>>>                            // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
88807>>>>>>>                            // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
88807>>>>>>>                            // index update checking logic.
88807>>>>>>>                            Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
88810>>>>>>>                            If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
88812>>>>>>>                                Create_Index hFile at iIndex
88813>>>>>>>                                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
88816>>>>>>>                            End
88816>>>>>>>>
88816>>>>>>>
88816>>>>>>>                            Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
88819>>>>>>>                            Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
88822>>>>>>>                                // Note: The order here is crucial!
88822>>>>>>>                                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
88825>>>>>>>                                Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
88828>>>>>>>                        End
88828>>>>>>>>
88828>>>>>>>                    End
88828>>>>>>>>
88828>>>>>>>                    Else Begin
88829>>>>>>>                        Delete_Field hFile iColumn
88830>>>>>>>                        Move (RemoveFromArray(aColumnsTo, iCount)) to aColumnsTo
88831>>>>>>>                        Move (SizeOfArray(aColumnsTo)) to iCount2
88832>>>>>>>                        Decrement iCount2
88833>>>>>>>                        // We need to adjust FieldNumbers in the array with one, as we just deleted a field,
88833>>>>>>>                        // starting with the array number we just deleted the field for.
88833>>>>>>>                        for iColumn2 from iCount to iCount2
88839>>>>>>>>
88839>>>>>>>                            Move (aColumnsTo[iColumn2].iFieldNumber - 1) to aColumnsTo[iColumn2].iFieldNumber
88840>>>>>>>                        Loop
88841>>>>>>>>
88841>>>>>>>                        Decrement iCount
88842>>>>>>>                        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88843>>>>>>>                        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
88844>>>>>>>                        If (SizeOfArray(aColumnsFrom) = SizeOfArray(aColumnsTo)) Begin
88846>>>>>>>                            Move iColumns to iCount 
88847>>>>>>>                        End
88847>>>>>>>>
88847>>>>>>>                    End
88847>>>>>>>>
88847>>>>>>>                End 
88847>>>>>>>>
88847>>>>>>>                If (Err = True) Begin 
88849>>>>>>>                    Move False to bOK
88850>>>>>>>                    Move iColumns to iCount
88851>>>>>>>                End
88851>>>>>>>>
88851>>>>>>>            Loop
88852>>>>>>>>
88852>>>>>>>
88852>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructuring table..."
88853>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88855>>>>>>>
88855>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88856>>>>>>>        Function_Return (Not(Err))
88857>>>>>>>    End_Function
88858>>>>>>>
88858>>>>>>>    // * Dummy function for the Studio's Code Explorer *
88858>>>>>>>    Function API_INDEX_FUNCTIONS Returns Boolean
88860>>>>>>>        Function_Return False
88861>>>>>>>    End_Function
88862>>>>>>>
88862>>>>>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
88862>>>>>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
88862>>>>>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
88862>>>>>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
88864>>>>>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10  iIndexSegments
88864>>>>>>>        String sDriverID
88864>>>>>>>        Boolean bOK bExists bIsSQLTable
88864>>>>>>>
88864>>>>>>>        Get AutoConnectionIDLogin to bOK
88865>>>>>>>        Get OpenTableExclusive hTable to bOK
88866>>>>>>>        If (bOK = False) Begin
88868>>>>>>>            Function_Return False
88869>>>>>>>        End
88869>>>>>>>>
88869>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88872>>>>>>>
88872>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88873>>>>>>>            If (bIsSQLTable = True) Begin
88875>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88878>>>>>>>            End
88878>>>>>>>>
88878>>>>>>>
88878>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iIndexSegments
88881>>>>>>>        Move (iIndexSegments > 0) to bExists
88882>>>>>>>        If (bExists = True) Begin
88884>>>>>>>            Function_Return True
88885>>>>>>>        End
88885>>>>>>>>
88885>>>>>>>
88885>>>>>>>        Move -1 to iSegment1
88886>>>>>>>        Move -1 to iSegment2
88887>>>>>>>        Move -1 to iSegment3
88888>>>>>>>        Move -1 to iSegment4
88889>>>>>>>        Move -1 to iSegment5
88890>>>>>>>        Move -1 to iSegment6
88891>>>>>>>        Move -1 to iSegment7
88892>>>>>>>        Move -1 to iSegment8
88893>>>>>>>        Move -1 to iSegment9
88894>>>>>>>        Move -1 to iSegment10
88895>>>>>>>
88895>>>>>>>        If (num_arguments > 3) Begin
88897>>>>>>>            Move iSgmnt1 to iSegment1
88898>>>>>>>        End
88898>>>>>>>>
88898>>>>>>>        If (num_arguments > 4) Begin
88900>>>>>>>            Move iSgmnt2 to iSegment2
88901>>>>>>>        End
88901>>>>>>>>
88901>>>>>>>        If (num_arguments > 5) Begin
88903>>>>>>>            Move iSgmnt3 to iSegment3
88904>>>>>>>        End
88904>>>>>>>>
88904>>>>>>>        If (num_arguments > 6) Begin
88906>>>>>>>            Move iSgmnt4 to iSegment4
88907>>>>>>>        End
88907>>>>>>>>
88907>>>>>>>        If (num_arguments > 7) Begin
88909>>>>>>>            Move iSgmnt5 to iSegment5
88910>>>>>>>        End
88910>>>>>>>>
88910>>>>>>>        If (num_arguments > 8) Begin
88912>>>>>>>            Move iSgmnt6 to iSegment6
88913>>>>>>>        End
88913>>>>>>>>
88913>>>>>>>        If (num_arguments > 9) Begin
88915>>>>>>>            Move iSgmnt7 to iSegment7
88916>>>>>>>        End
88916>>>>>>>>
88916>>>>>>>        If (num_arguments > 10) Begin
88918>>>>>>>            Move iSgmnt8 to iSegment8
88919>>>>>>>        End
88919>>>>>>>>
88919>>>>>>>        If (num_arguments > 11) Begin
88921>>>>>>>            Move iSgmnt9 to iSegment9
88922>>>>>>>        End
88922>>>>>>>>
88922>>>>>>>        If (num_arguments > 12) Begin
88924>>>>>>>            Move iSgmnt10 to iSegment10
88925>>>>>>>        End
88925>>>>>>>>
88925>>>>>>>
88925>>>>>>>        Move False to Err
88926>>>>>>>        Move hTable to iTableNo
88927>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88928>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88929>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88930>>>>>>>
88930>>>>>>>        // We start by deleting the index, if it exists.
88930>>>>>>>        If (bExists = True) Begin
88932>>>>>>>            Structure_Start hTable sDriverID
88933>>>>>>>                Delete_Index iTableNo iIndex
88934>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88935>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88937>>>>>>>        End
88937>>>>>>>>
88937>>>>>>>
88937>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88938>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88939>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88940>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88941>>>>>>>        Move False to Err
88942>>>>>>>        Move 0 to LastErr
88943>>>>>>>
88943>>>>>>>        // Need to re-open if index deleted.
88943>>>>>>>        Move iTableNo to hTable
88944>>>>>>>        Get OpenTableExclusive hTable to bOK
88945>>>>>>>        If (bOK = False) Begin
88947>>>>>>>            Function_Return False
88948>>>>>>>        End
88948>>>>>>>>
88948>>>>>>>
88948>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88949>>>>>>>        Structure_Start hTable sDriverID
88950>>>>>>>            Create_Index hTable At iIndex
88951>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
88954>>>>>>>
88954>>>>>>>            If (iSgmnt1 <> -1) Begin
88956>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
88959>>>>>>>            End
88959>>>>>>>>
88959>>>>>>>            If (iSegment2 <> -1) Begin
88961>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
88964>>>>>>>            End
88964>>>>>>>>
88964>>>>>>>            If (iSegment3 <> -1) Begin
88966>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
88969>>>>>>>            End
88969>>>>>>>>
88969>>>>>>>            If (iSegment4 <> -1) Begin
88971>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
88974>>>>>>>            End
88974>>>>>>>>
88974>>>>>>>            If (iSegment5 <> -1) Begin
88976>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
88979>>>>>>>            End
88979>>>>>>>>
88979>>>>>>>            If (iSegment6 <> -1) Begin
88981>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
88984>>>>>>>            End
88984>>>>>>>>
88984>>>>>>>            If (iSegment7 <> -1) Begin
88986>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
88989>>>>>>>            End
88989>>>>>>>>
88989>>>>>>>            If (iSegment8 <> -1) Begin
88991>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
88994>>>>>>>            End
88994>>>>>>>>
88994>>>>>>>            If (iSegment9 <> -1) Begin
88996>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
88999>>>>>>>            End
88999>>>>>>>>
88999>>>>>>>            If (iSegment10 <> -1) Begin
89001>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
89004>>>>>>>            End
89004>>>>>>>>
89004>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89005>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89007>>>>>>>
89007>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89008>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89009>>>>>>>
89009>>>>>>>        Function_Return (Err = False)
89010>>>>>>>    End_Function
89011>>>>>>>
89011>>>>>>>    // Example:
89011>>>>>>>    // Get ApiIndexCreateEx hTable 1 (StrSplitToArray("1,5,6,7,8,2,3,4,10,9,11", ",")) to bOk
89011>>>>>>>    // Note: The StrSplitToArray function was introduced with DataFlex 18.2
89011>>>>>>>    Function ApiIndexCreateEx Handle hTable Integer iIndex Integer[] iSgmnts Returns Boolean
89013>>>>>>>        Integer iTableNo iNumSgmnt iNumSgmnts
89013>>>>>>>        String sDriverID
89013>>>>>>>        Boolean bOK bIsSQLTable
89013>>>>>>>
89013>>>>>>>        Get AutoConnectionIDLogin to bOK
89014>>>>>>>
89014>>>>>>>        Move False to Err
89015>>>>>>>        Move hTable to iTableNo
89016>>>>>>>        Get OpenTableExclusive hTable to bOK
89017>>>>>>>        If (bOK = False) Begin
89019>>>>>>>            Function_Return False
89020>>>>>>>        End
89020>>>>>>>>
89020>>>>>>>
89020>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89023>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89024>>>>>>>            If (bIsSQLTable = True) Begin
89026>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89029>>>>>>>            End
89029>>>>>>>>
89029>>>>>>>
89029>>>>>>>        // We start by deleting the index
89029>>>>>>>        Structure_Start hTable sDriverID
89030>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89031>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
89032>>>>>>>            Delete_Index iTableNo iIndex
89033>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
89034>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
89035>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
89037>>>>>>>
89037>>>>>>>        Move False to Err
89038>>>>>>>        Move iTableNo to hTable
89039>>>>>>>        Get OpenTableExclusive hTable to bOK
89040>>>>>>>        If (bOK = False) Begin
89042>>>>>>>            Function_Return False
89043>>>>>>>        End
89043>>>>>>>>
89043>>>>>>>
89043>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89044>>>>>>>        Structure_Start hTable sDriverID
89045>>>>>>>            Move (SizeOfArray(iSgmnts)) to iNumSgmnts
89046>>>>>>>
89046>>>>>>>            Create_Index hTable at iIndex
89047>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSgmnts
89050>>>>>>>
89050>>>>>>>            for iNumSgmnt from 0 to (iNumSgmnts - 1)
89056>>>>>>>>
89056>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iNumSgmnt + 1) to iSgmnts[iNumSgmnt]
89059>>>>>>>            Loop
89060>>>>>>>>
89060>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
89062>>>>>>>
89062>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89063>>>>>>>
89063>>>>>>>        Function_Return (Err = False)
89064>>>>>>>    End_Function
89065>>>>>>>
89065>>>>>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
89067>>>>>>>        Integer iCount iSegmentsFrom iFieldFrom iSegmentsTo iSQLIndexType iTableNo
89067>>>>>>>        String sDriverID sSQLIndexName
89067>>>>>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
89067>>>>>>>
89067>>>>>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
89068>>>>>>>        If (iSegmentsFrom = 0) Begin
89070>>>>>>>            Function_Return False
89071>>>>>>>        End
89071>>>>>>>>
89071>>>>>>>
89071>>>>>>>        Get AutoConnectionIDLogin to bOK
89072>>>>>>>        Move False to Err
89073>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
89074>>>>>>>        If (bIsOpen = False) Begin
89076>>>>>>>            Function_Return False
89077>>>>>>>        End
89077>>>>>>>>
89077>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89080>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
89081>>>>>>>            If (bIsSQLTable = True) Begin
89083>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89086>>>>>>>            End
89086>>>>>>>>
89086>>>>>>>
89086>>>>>>>        Move 0     to iSegmentsTo
89087>>>>>>>        Move 0     to iSQLIndexType
89088>>>>>>>        Move ""    to sSQLIndexName
89089>>>>>>>        Move False to bIsSQLTemporaryIndex
89090>>>>>>>        Move False to bIsSQLPrimaryKey
89091>>>>>>>        Move False to bIsSQLClustered
89092>>>>>>>
89092>>>>>>>            Get UtilIndexTempRenameSQLName hTable APIIndex.sSQLIndexName sDriverID          to bOK
89093>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber              to iSegmentsTo
89096>>>>>>>        Move (iSegmentsTo > 0) to bExists
89097>>>>>>>        If (bExists = True) Begin
89099>>>>>>>            If (bIsSQLTable = True and iSegmentsTo > 0) Begin
89101>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber                 to sSQLIndexName
89104>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
89107>>>>>>>                        Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
89108>>>>>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
89111>>>>>>>                    Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
89114>>>>>>>            End
89114>>>>>>>>
89114>>>>>>>        End
89114>>>>>>>>
89114>>>>>>>
89114>>>>>>>        Move hTable to iTableNo
89115>>>>>>>        Move False to Err
89116>>>>>>>        Move 0 to LastErr
89117>>>>>>>
89117>>>>>>>        Structure_Start hTable sDriverID
89118>>>>>>>            If (bExists = True) Begin
89120>>>>>>>                Delete_Index iTableNo APIIndex.iIndexNumber
89121>>>>>>>            End
89121>>>>>>>>
89121>>>>>>>
89121>>>>>>>            Create_Index hTable At APIIndex.iIndexNumber
89122>>>>>>>
89122>>>>>>>                If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
89124>>>>>>>                    Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType
89127>>>>>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
89130>>>>>>>                    Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
89133>>>>>>>                    Set_Attribute DF_INDEX_NAME            of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
89136>>>>>>>                End
89136>>>>>>>>
89136>>>>>>>
89136>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
89139>>>>>>>
89139>>>>>>>            for iCount from 0 to (iSegmentsFrom -1)
89145>>>>>>>>
89145>>>>>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom
89146>>>>>>>                If (iFieldFrom <> -1 ) Begin
89148>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
89151>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bAscending
89154>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bUppercase
89157>>>>>>>                End
89157>>>>>>>>
89157>>>>>>>            Loop
89158>>>>>>>>
89158>>>>>>>
89158>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89159>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89161>>>>>>>
89161>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89162>>>>>>>
89162>>>>>>>        Function_Return (Err = False)
89163>>>>>>>    End_Function
89164>>>>>>>
89164>>>>>>>    // If an SQL index is to be renamed we need to check that the name doesn't exist already, but
89164>>>>>>>    // with another index number. If we find one we temporarily renames it by adding "TMP" to the SQL name.
89164>>>>>>>    Function UtilIndexTempRenameSQLName Handle hTable String sSQLIndexName String sDriverID Returns Boolean
89166>>>>>>>        Integer iLastIndex iCount iTableNo iSegments
89166>>>>>>>        String sSQLIndexNameCompare sTmpIndexName
89166>>>>>>>        Boolean bIsOpen bExists bIsSQLDriver 
89166>>>>>>>
89166>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
89167>>>>>>>        
89167>>>>>>>        If (bIsSQLDriver = False) Begin
89169>>>>>>>            Function_Return False
89170>>>>>>>        End
89170>>>>>>>>
89170>>>>>>>
89170>>>>>>>        Move False to Err
89171>>>>>>>        Move hTable to iTableNo
89172>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
89175>>>>>>>        for iCount from 0 to iLastIndex
89181>>>>>>>>
89181>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iSegments
89184>>>>>>>            Move (iSegments > 0) to bExists
89185>>>>>>>            If (bExists = True) Begin
89187>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable iCount to sSQLIndexNameCompare
89190>>>>>>>                If (Lowercase(sSQLIndexName) = Lowercase(sSQLIndexNameCompare)) Begin
89192>>>>>>>                    Move (sSQLIndexNameCompare + String("_TMP")) to sTmpIndexName
89193>>>>>>>                    Structure_Start iTableNo sDriverID
89194>>>>>>>                        Set_Attribute DF_INDEX_NAME of iTableNo iCount to sTmpIndexName
89197>>>>>>>                    Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89199>>>>>>>                    Open hTable
89201>>>>>>>                End
89201>>>>>>>>
89201>>>>>>>            End
89201>>>>>>>>
89201>>>>>>>        Loop
89202>>>>>>>>
89202>>>>>>>
89202>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89205>>>>>>>        If (bIsOpen = False) Begin
89207>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
89208>>>>>>>        End
89208>>>>>>>>
89208>>>>>>>        If (bIsOpen = False) Begin
89210>>>>>>>            Function_Return False
89211>>>>>>>        End
89211>>>>>>>>
89211>>>>>>>
89211>>>>>>>        Function_Return (Err = False)
89212>>>>>>>    End_Function
89213>>>>>>>
89213>>>>>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
89213>>>>>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
89213>>>>>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
89215>>>>>>>        Integer iSize iCount
89215>>>>>>>        Integer iRetVal
89215>>>>>>>
89215>>>>>>>        Move 0 to iRetVal
89216>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
89219>>>>>>>        If (iRetVal = 0) Begin
89221>>>>>>>            Function_Return 0
89222>>>>>>>        End
89222>>>>>>>>
89222>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSize
89223>>>>>>>        Decrement iSize
89224>>>>>>>        for iCount from 0 to iSize
89230>>>>>>>>
89230>>>>>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
89232>>>>>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
89234>>>>>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
89235>>>>>>>                End
89235>>>>>>>>
89235>>>>>>>            End
89235>>>>>>>>
89235>>>>>>>        Loop
89236>>>>>>>>
89236>>>>>>>
89236>>>>>>>        Function_Return iRetVal
89237>>>>>>>    End_Function
89238>>>>>>>
89238>>>>>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
89240>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
89240>>>>>>>        Boolean bIsSQLTable
89240>>>>>>>        
89240>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89241>>>>>>>            If (bIsSQLTable = True) Begin
89243>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89246>>>>>>>            End
89246>>>>>>>>
89246>>>>>>>
89246>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89249>>>>>>>        If (iSegment = iNumSegments) Begin
89251>>>>>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89251>>>>>>>        End
89251>>>>>>>>
89251>>>>>>>
89251>>>>>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89254>>>>>>>            for iCurSegment from iSegment to (iNumSegments - 1)
89260>>>>>>>>
89260>>>>>>>                //*** Move index segment attributes
89260>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89263>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
89266>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
89269>>>>>>>
89269>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
89272>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
89275>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
89278>>>>>>>            Loop
89279>>>>>>>>
89279>>>>>>>
89279>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89282>>>>>>>        End
89282>>>>>>>>
89282>>>>>>>
89282>>>>>>>        Function_Return (Err = False)
89283>>>>>>>    End_Function
89284>>>>>>>
89284>>>>>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
89286>>>>>>>        Integer iCount iSize iIndex
89286>>>>>>>        String sDriverID
89286>>>>>>>        Boolean bOK bIsSQLTable bIsOpen
89286>>>>>>>
89286>>>>>>>        Move (SizeOfArray(APIIndex)) to iSize
89287>>>>>>>        If (iSize = 0) Begin
89289>>>>>>>            Function_Return True
89290>>>>>>>        End
89290>>>>>>>>
89290>>>>>>>
89290>>>>>>>        Get AutoConnectionIDLogin to bOK
89291>>>>>>>        Move False to Err
89292>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89295>>>>>>>        If (bIsOpen = False) Begin
89297>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
89298>>>>>>>            If (bIsOpen = False) Begin
89300>>>>>>>                Function_Return False
89301>>>>>>>            End
89301>>>>>>>>
89301>>>>>>>        End
89301>>>>>>>>
89301>>>>>>>
89301>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89304>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
89305>>>>>>>            If (bIsSQLTable = True) Begin
89307>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89310>>>>>>>            End
89310>>>>>>>>
89310>>>>>>>
89310>>>>>>>        Move False to Err
89311>>>>>>>        Move 0 to LastErr
89312>>>>>>>        Decrement iSize
89313>>>>>>>
89313>>>>>>>        Structure_Start hTable sDriverID
89314>>>>>>>            for iCount from 0 to iSize
89320>>>>>>>>
89320>>>>>>>//                Move False to bIsSQLPrimaryKey
89320>>>>>>>//                #IF (!@ > 180)   // DF 18.1 and up
89320>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89320>>>>>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
89320>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
89320>>>>>>>//                #ENDIF
89320>>>>>>>                // We can't delete if this is a primary key index:
89320>>>>>>>//                If (bIsSQLPrimaryKey = False) Begin
89320>>>>>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
89321>>>>>>>                    Delete_Index hTable iIndex
89322>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
89322>>>>>>>//                End
89322>>>>>>>            Loop
89323>>>>>>>>
89323>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89324>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89326>>>>>>>//        Move False to Err
89326>>>>>>>        Move 0 to LastErr
89327>>>>>>>
89327>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89328>>>>>>>        Function_Return (Err = False)
89329>>>>>>>    End_Function
89330>>>>>>>
89330>>>>>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
89332>>>>>>>        Boolean bOK
89332>>>>>>>
89332>>>>>>>        Get AutoConnectionIDLogin to bOK
89333>>>>>>>        Move False to Err
89334>>>>>>>        Get OpenTableExclusive hTable to bOK
89335>>>>>>>        If (bOK = False) Begin
89337>>>>>>>            Function_Return False
89338>>>>>>>        End
89338>>>>>>>>
89338>>>>>>>        Structure_Start hTable
89339>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
89342>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89343>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89345>>>>>>>
89345>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89346>>>>>>>        Function_Return (Err = False)
89347>>>>>>>    End_Function
89348>>>>>>>
89348>>>>>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
89350>>>>>>>        Integer iCase
89350>>>>>>>        Boolean bOK
89350>>>>>>>
89350>>>>>>>        If (bUppercase = True) Begin
89352>>>>>>>            Move DF_CASE_IGNORED to iCase
89353>>>>>>>        End
89353>>>>>>>>
89353>>>>>>>        Else Begin
89354>>>>>>>            Move DF_CASE_USED to iCase
89355>>>>>>>        End
89355>>>>>>>>
89355>>>>>>>
89355>>>>>>>        Get AutoConnectionIDLogin to bOK
89356>>>>>>>        Move False to Err
89357>>>>>>>        Get OpenTableExclusive hTable to bOK
89358>>>>>>>        If (bOK = False) Begin
89360>>>>>>>            Function_Return False
89361>>>>>>>        End
89361>>>>>>>>
89361>>>>>>>        Structure_Start hTable
89362>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
89365>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89366>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89368>>>>>>>
89368>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89369>>>>>>>        Function_Return (Err = False)
89370>>>>>>>    End_Function
89371>>>>>>>
89371>>>>>>>    // To delete an index
89371>>>>>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
89373>>>>>>>        Integer iTableNo iNumSegments
89373>>>>>>>        String sDriverID
89373>>>>>>>        Boolean bOK bIsSQLTable
89373>>>>>>>
89373>>>>>>>        Get AutoConnectionIDLogin to bOK
89374>>>>>>>        Move False to Err
89375>>>>>>>        Move hTable to iTableNo
89376>>>>>>>        Get OpenTableExclusive hTable to bOK
89377>>>>>>>        If (bOK = False) Begin
89379>>>>>>>            Function_Return False
89380>>>>>>>        End
89380>>>>>>>>
89380>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89383>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89384>>>>>>>            If (bIsSQLTable = True) Begin
89386>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89389>>>>>>>            End
89389>>>>>>>>
89389>>>>>>>
89389>>>>>>>        // Check to see if the index exists or not...
89389>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89392>>>>>>>        If (iNumSegments = 0) Begin
89394>>>>>>>            Function_Return True // Then nothing to do.
89395>>>>>>>        End
89395>>>>>>>>
89395>>>>>>>
89395>>>>>>>        Structure_Start hTable sDriverID
89396>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
89397>>>>>>>            Delete_Index iTableNo iIndex
89398>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
89399>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89400>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89402>>>>>>>
89402>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89403>>>>>>>        Function_Return (Err = False)
89404>>>>>>>    End_Function
89405>>>>>>>
89405>>>>>>>    // Delete an Index Segment
89405>>>>>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
89407>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
89407>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
89407>>>>>>>        Integer iIndexType
89407>>>>>>>        String sDriverID
89407>>>>>>>
89407>>>>>>>        Get AutoConnectionIDLogin to bOK
89408>>>>>>>        Move False to Err
89409>>>>>>>
89409>>>>>>>        Get OpenTableExclusive hTable to bOK
89410>>>>>>>        If (bOK = False) Begin
89412>>>>>>>            Function_Return False
89413>>>>>>>        End
89413>>>>>>>>
89413>>>>>>>
89413>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89414>>>>>>>            If (bIsSQLTable = True) Begin
89416>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89419>>>>>>>            End
89419>>>>>>>>
89419>>>>>>>
89419>>>>>>>        // Check to see if the index exists or not...
89419>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89422>>>>>>>        If (iNumSegments = 0) Begin
89424>>>>>>>            Function_Return False
89425>>>>>>>        End
89425>>>>>>>>
89425>>>>>>>
89425>>>>>>>        Move False to bIndexTemporary
89426>>>>>>>        Get psDriverID to sDriverID
89427>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
89428>>>>>>>        If (bSQLDriver) Begin
89430>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
89433>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
89436>>>>>>>                Move True to bIndexTemporary
89437>>>>>>>        End
89437>>>>>>>>
89437>>>>>>>
89437>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
89437>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
89439>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89442>>>>>>>            If (iSegment = iNumSegments) Begin
89444>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89447>>>>>>>            End
89447>>>>>>>>
89447>>>>>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89450>>>>>>>                For iCurSegment from iSegment to (iNumSegments - 1)
89456>>>>>>>>
89456>>>>>>>                    //*** Move index segment attributes
89456>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89459>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
89462>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
89465>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89468>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89471>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89474>>>>>>>                Loop
89475>>>>>>>>
89475>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89478>>>>>>>            End
89478>>>>>>>>
89478>>>>>>>        End
89478>>>>>>>>
89478>>>>>>>
89478>>>>>>>        Else Begin
89479>>>>>>>           Structure_Start hTable
89480>>>>>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89483>>>>>>>               If (iSegment = iNumSegments) Begin
89485>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89488>>>>>>>               End
89488>>>>>>>>
89488>>>>>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89491>>>>>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
89497>>>>>>>>
89497>>>>>>>                       //*** Move index segment attributes
89497>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89500>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
89503>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
89506>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89509>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89512>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89515>>>>>>>                   Loop
89516>>>>>>>>
89516>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89519>>>>>>>               End
89519>>>>>>>>
89519>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
89520>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89522>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89523>>>>>>>        End
89523>>>>>>>>
89523>>>>>>>
89523>>>>>>>        Function_Return (Err = False)
89524>>>>>>>    End_Function
89525>>>>>>>
89525>>>>>>>    // Add/Insert an Index Segment
89525>>>>>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
89527>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
89527>>>>>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
89527>>>>>>>        Integer iIndexType
89527>>>>>>>        String sDriverId
89527>>>>>>>
89527>>>>>>>        Get AutoConnectionIDLogin to bOK
89528>>>>>>>        Move False to Err
89529>>>>>>>
89529>>>>>>>        Get OpenTableExclusive hTable to bOK
89530>>>>>>>        If (bOK = False) Begin
89532>>>>>>>            Function_Return False
89533>>>>>>>        End
89533>>>>>>>>
89533>>>>>>>
89533>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89534>>>>>>>            If (bIsSQLTable = True) Begin
89536>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89539>>>>>>>            End
89539>>>>>>>>
89539>>>>>>>
89539>>>>>>>        Move False to bIndexTemporary
89540>>>>>>>        // Check to see if the index exists or not...
89540>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89543>>>>>>>        If (iNumSegments = 0) Begin
89545>>>>>>>            Function_Return False
89546>>>>>>>        End
89546>>>>>>>>
89546>>>>>>>
89546>>>>>>>        Get psDriverID to sDriverID
89547>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
89548>>>>>>>        If (bSQLDriver) Begin
89550>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
89553>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
89556>>>>>>>                Move True to bIndexTemporary
89557>>>>>>>        End
89557>>>>>>>>
89557>>>>>>>
89557>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
89557>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
89559>>>>>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89562>>>>>>>
89562>>>>>>>           If (iSegment > iNumSegments) Begin
89564>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89567>>>>>>>               Move (iNumSegments + 1) to iCurSegment
89568>>>>>>>           End
89568>>>>>>>>
89568>>>>>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
89571>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89574>>>>>>>               Move iNumSegments to iCurSegment
89575>>>>>>>
89575>>>>>>>               While (iCurSegment > iSegment)
89579>>>>>>>                   //*** Move index segment attributes
89579>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
89582>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
89585>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
89588>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
89591>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
89594>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
89597>>>>>>>                   Decrement iCurSegment
89598>>>>>>>               Loop
89599>>>>>>>>
89599>>>>>>>
89599>>>>>>>               //*** Now set new segment attributes
89599>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
89602>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
89605>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
89608>>>>>>>           End
89608>>>>>>>>
89608>>>>>>>        End
89608>>>>>>>>
89608>>>>>>>
89608>>>>>>>        Else Begin
89609>>>>>>>        Structure_Start hTable
89610>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89613>>>>>>>
89613>>>>>>>            If (iSegment > iNumSegments) Begin
89615>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89618>>>>>>>                Move (iNumSegments + 1) to iCurSegment
89619>>>>>>>            End
89619>>>>>>>>
89619>>>>>>>            Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
89622>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89625>>>>>>>                Move iNumSegments to iCurSegment
89626>>>>>>>
89626>>>>>>>                While (iCurSegment > iSegment)
89630>>>>>>>                    //*** Move index segment attributes
89630>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
89633>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
89636>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
89639>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89642>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89645>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89648>>>>>>>                    Decrement iCurSegment
89649>>>>>>>                Loop
89650>>>>>>>>
89650>>>>>>>
89650>>>>>>>                //*** Now set new segment attributes
89650>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
89653>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
89656>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
89659>>>>>>>            End
89659>>>>>>>>
89659>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89660>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89662>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89663>>>>>>>        End
89663>>>>>>>>
89663>>>>>>>
89663>>>>>>>        Function_Return (Err = False)
89664>>>>>>>    End_Function
89665>>>>>>>
89665>>>>>>>    // * Dummy function for the Studio's Code Explorer *
89665>>>>>>>    Function TABLE_UTILITY_FUNCTIONS Returns Boolean
89667>>>>>>>        Function_Return False
89668>>>>>>>    End_Function  
89669>>>>>>>    
89669>>>>>>>    // Preparation message before an SQL onversion. It will check and wash all embedded data tables and prepare them
89669>>>>>>>    // for an SQL conversion.
89669>>>>>>>    Function UtilPrepareDataFolderForSQLConversion Boolean bMoveMiscFilesToBackup Boolean bFixALLBogusFilelistEntries Boolean bConvertTo30Format Boolean bRepairAndReindex Boolean bFixBogusDates Returns Boolean
89671>>>>>>>        Boolean bConvertTo30FormatbOK bRepairAndReindexOK bFixBogusDatesOK bMoveMiscFilesToBackupOK
89671>>>>>>>        
89671>>>>>>>        Move True to bConvertTo30FormatbOK
89672>>>>>>>        Move True to bRepairAndReindexOK
89673>>>>>>>        Move True to bFixBogusDatesOK
89674>>>>>>>        Move True to bMoveMiscFilesToBackupOK
89675>>>>>>>        
89675>>>>>>>        If (bMoveMiscFilesToBackup = True) Begin   
89677>>>>>>>            Set Message_Text of ghoStatusPanel to "Moving misc. files to backup..."
89678>>>>>>>            Get UtilMoveMiscFilesToBackupFolder to bMoveMiscFilesToBackupOK
89679>>>>>>>        End                                                                                
89679>>>>>>>>
89679>>>>>>>        If (bFixALLBogusFilelistEntries = True) Begin
89681>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus Filelist.cfg entries..."
89682>>>>>>>            Get UtilTableFixALLBogusFilelistEntries to bFixALLBogusFilelistEntries
89683>>>>>>>        End
89683>>>>>>>>
89683>>>>>>>        If (bConvertTo30Format = True) Begin
89685>>>>>>>            Set Message_Text of ghoStatusPanel to "Converting .dat files from 2.3->..."
89686>>>>>>>            Get UtilTableConvertALLTablesFrom23Format to bConvertTo30FormatbOK
89687>>>>>>>        End                                                 
89687>>>>>>>>
89687>>>>>>>        If (bRepairAndReindex = True) Begin
89689>>>>>>>            Set Message_Text of ghoStatusPanel to "Repairing and reindexing..."
89690>>>>>>>            Get UtilTableRepairAndReindexALL to bRepairAndReindexOK
89691>>>>>>>        End  
89691>>>>>>>>
89691>>>>>>>        If (bFixBogusDates = True) Begin
89693>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
89694>>>>>>>            Get UtilTablesFixAllDateBogusValues True False to bFixBogusDatesOK
89695>>>>>>>        End                                    
89695>>>>>>>>
89695>>>>>>>        
89695>>>>>>>        Function_Return (bConvertTo30FormatbOK = True and bFixALLBogusFilelistEntries = True and bRepairAndReindexOK = True and bFixBogusDatesOK = True and bMoveMiscFilesToBackupOK = True)
89696>>>>>>>    End_Function
89697>>>>>>>
89697>>>>>>>    Function UtilTableConvertALLTablesFrom23Format Returns Boolean
89699>>>>>>>        Boolean bOK bFlexErrs bTemp
89699>>>>>>>        Handle hTable
89699>>>>>>>        String sTableName
89699>>>>>>>        Integer iCount iSize
89699>>>>>>>        
89699>>>>>>>        Move True to bOK
89700>>>>>>>        Move 0 to hTable    
89701>>>>>>>
89701>>>>>>>        Get UtilFilelistNoOfTables to iSize
89702>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89703>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89704>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89705>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89706>>>>>>>
89706>>>>>>>        Repeat
89706>>>>>>>>
89706>>>>>>>            Set Action_Text of ghoStatusPanel to "Checking if table is in 2.3 format..."
89707>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount  
89708>>>>>>>            Increment iCount
89709>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89712>>>>>>>            If (hTable > 0) Begin
89714>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89717>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
89718>>>>>>>                If (bFlexErrs = False) Begin
89720>>>>>>>                    Get UtilTableConvertFrom23Format hTable to bTemp
89721>>>>>>>                    If (bTemp = False) Begin
89723>>>>>>>                        Move False to bOK
89724>>>>>>>                    End
89724>>>>>>>>
89724>>>>>>>                End
89724>>>>>>>>
89724>>>>>>>            End
89724>>>>>>>>
89724>>>>>>>        Until (hTable = 0)
89726>>>>>>>        
89726>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89727>>>>>>>        Function_Return bOK
89728>>>>>>>    End_Function
89729>>>>>>>    
89729>>>>>>>    // Converts an embedded table from 2.3 -> 3.0.
89729>>>>>>>    // Returns: FALSE only if the table can't be opened or the conversion fails.
89729>>>>>>>    // It will return a TRUE if successful or the table is an SQL table.
89729>>>>>>>    Function UtilTableConvertFrom23Format Handle hTable Returns Boolean
89731>>>>>>>        Boolean bOK bIsEmbedded bIsAlias
89731>>>>>>>        String sRevision
89731>>>>>>>        
89731>>>>>>>        Get AutoConnectionIDLogin to bOK
89732>>>>>>>        If (bOK = False) Begin
89734>>>>>>>            Function_Return True
89735>>>>>>>        End
89735>>>>>>>>
89735>>>>>>>        Get OpenTableExclusive hTable to bOK
89736>>>>>>>        If (bOK = False) Begin
89738>>>>>>>            Function_Return True
89739>>>>>>>        End
89739>>>>>>>>
89739>>>>>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
89740>>>>>>>        If (bIsEmbedded = False) Begin
89742>>>>>>>            Function_Return True
89743>>>>>>>        End                             
89743>>>>>>>>
89743>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
89744>>>>>>>        If (bIsAlias = True) Begin
89746>>>>>>>            Function_Return True
89747>>>>>>>        End                     
89747>>>>>>>>
89747>>>>>>>        
89747>>>>>>>        Move False to Err
89748>>>>>>>        Get_Attribute DF_FILE_REVISION of hTable to sRevision
89751>>>>>>>        If (sRevision contains "2.3") Begin
89753>>>>>>>            Move False to Err
89754>>>>>>>            Set Private.phCurrentTable to hTable
89755>>>>>>>            Structure_Start hTable    
89756>>>>>>>                Set_Attribute DF_FILE_INTEGRITY_CHECK of hTable to True
89759>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table to 3.0/4.0"
89760>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
89762>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89763>>>>>>>        End
89763>>>>>>>>
89763>>>>>>>        
89763>>>>>>>        Function_Return (Err = False)
89764>>>>>>>    End_Function
89765>>>>>>>
89765>>>>>>>    Function UtilTableFixALLBogusFilelistEntries Returns Boolean
89767>>>>>>>        Boolean bIgnore bExists bOK bResponse
89767>>>>>>>        Handle hTable   
89767>>>>>>>        String sTableName
89767>>>>>>>        
89767>>>>>>>        Move False to Err 
89768>>>>>>>        Move True to bOK
89769>>>>>>>        Move 0 to hTable
89770>>>>>>>        Repeat
89770>>>>>>>>
89770>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89773>>>>>>>            If (hTable > 0) Begin
89775>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89778>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST")  to bIgnore
89779>>>>>>>                If (bIgnore = False) Begin
89781>>>>>>>                    Get _UtilTableExists hTable to bExists
89782>>>>>>>                    If (bExists = False) Begin
89784>>>>>>>                        Get ApiTableChangeFileListSlot "" "" "" hTable DATAFLEX_ID to bResponse
89785>>>>>>>                        If (bResponse = False) Begin
89787>>>>>>>                            Move False to bOK
89788>>>>>>>                        End
89788>>>>>>>>
89788>>>>>>>                        
89788>>>>>>>                    End
89788>>>>>>>>
89788>>>>>>>                End
89788>>>>>>>>
89788>>>>>>>            End
89788>>>>>>>>
89788>>>>>>>        Until (hTable = 0)                     
89790>>>>>>>        
89790>>>>>>>        Set Action_Text of ghoStatusPanel to "" 
89791>>>>>>>        Function_Return bOK
89792>>>>>>>    End_Function
89793>>>>>>>    
89793>>>>>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
89793>>>>>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
89793>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
89793>>>>>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
89793>>>>>>>    //
89793>>>>>>>    // The root of the problem is the following:
89793>>>>>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
89793>>>>>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
89793>>>>>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside
89793>>>>>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
89793>>>>>>>    // an SQL error will be thrown;
89793>>>>>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
89793>>>>>>>    Function UtilTablesFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
89795>>>>>>>        Boolean bOK bIsAlias bIsSQL
89795>>>>>>>        Integer iCount iSize iDateSize
89795>>>>>>>        Handle hTable
89795>>>>>>>        String sLogicalName
89795>>>>>>>        Integer[] aTablesToCheck aDateFields
89797>>>>>>>
89797>>>>>>>        Get _AllTablesDateCorrections to aTablesToCheck
89798>>>>>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
89799>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89800>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89801>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89802>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89803>>>>>>>
89803>>>>>>>        Move True to bOK
89804>>>>>>>        Decrement iSize
89805>>>>>>>        for iCount from 0 to iSize
89811>>>>>>>>
89811>>>>>>>            Move aTablesToCheck[iCount] to hTable
89812>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
89813>>>>>>>            Get UtilTableIsAlias hTable to bIsAlias
89814>>>>>>>            Get _UtilTableIsSql   hTable to bIsSQL
89815>>>>>>>
89815>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89818>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
89819>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
89820>>>>>>>
89820>>>>>>>            If (bIsAlias = False and bIsSQL = False) Begin
89822>>>>>>>                Get UtilCheckForDateFields hTable to aDateFields
89823>>>>>>>                Move (SizeOfArray(aDateFields)) to iDateSize
89824>>>>>>>                If (iDateSize > 0) Begin
89826>>>>>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
89827>>>>>>>                    Close hTable
89828>>>>>>>                End
89828>>>>>>>>
89828>>>>>>>            End
89828>>>>>>>>
89828>>>>>>>        Loop
89829>>>>>>>>
89829>>>>>>>
89829>>>>>>>        Close DF_ALL
89830>>>>>>>        Function_Return bOK
89831>>>>>>>    End_Function
89832>>>>>>>
89832>>>>>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
89832>>>>>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
89834>>>>>>>        Integer[] aDateFields aDateFieldsEmpty
89836>>>>>>>        Integer iSize iCount iType
89836>>>>>>>        Boolean bOpen bOK
89836>>>>>>>        
89836>>>>>>>        Get _UtilTableExists hTable to bOK
89837>>>>>>>        If (bOK = False) Begin
89839>>>>>>>            Set Private.phCurrentTable to hTable
89840>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
89841>>>>>>>>
89841>>>>>>>            Function_Return aDateFieldsEmpty
89842>>>>>>>        End
89842>>>>>>>>
89842>>>>>>>        Set Private.phCurrentTable to hTable
89843>>>>>>>        Set Private.piCurrentField to 0
89844>>>>>>>
89844>>>>>>>        Open hTable
89846>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89849>>>>>>>        If (bOpen = False) Begin
89851>>>>>>>            Function_Return aDateFieldsEmpty
89852>>>>>>>        End
89852>>>>>>>>
89852>>>>>>>
89852>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
89855>>>>>>>        For iCount from 1 to iSize
89861>>>>>>>>
89861>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
89864>>>>>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
89866>>>>>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
89867>>>>>>>            End
89867>>>>>>>>
89867>>>>>>>        Loop
89868>>>>>>>>
89868>>>>>>>
89868>>>>>>>        Function_Return aDateFields
89869>>>>>>>    End_Function
89870>>>>>>>
89870>>>>>>>    // Loops through all records for the passed hTable, and checks that all Date values
89870>>>>>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
89870>>>>>>>    // and the record is saved
89870>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
89870>>>>>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
89870>>>>>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
89872>>>>>>>        Integer iSize iCount iField iRecord iTotalRecords iDateFormat iDriverIndex
89872>>>>>>>        String sDriverID sDateMin
89872>>>>>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges 
89872>>>>>>>        Date dDate dDateMin
89872>>>>>>>        Integer[] iaChangeField
89873>>>>>>>
89873>>>>>>>        Get _UtilTableExists hTable to bOK
89874>>>>>>>        // I believe we should just skip files not found and not report an error.
89874>>>>>>>        // This is because a filelist may have entries but no files/tables on disk, but
89874>>>>>>>        // this may be adjusted by other calls to DUF in a later update package. 
89874>>>>>>>        // Especially considering that this call is probably done at the very
89874>>>>>>>        // beginning of a DUF update.
89874>>>>>>>        If (bOK = False) Begin
89876>>>>>>>//            Set Private.phCurrentTable to hTable
89876>>>>>>>//            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
89876>>>>>>>//            Function_Return False
89876>>>>>>>            Function_Return True
89877>>>>>>>        End
89877>>>>>>>>
89877>>>>>>>
89877>>>>>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the
89877>>>>>>>        // date format to "USA" = "MM/DD/YYYY"
89877>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
89880>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
89883>>>>>>>
89883>>>>>>>//        Send SetAllIndexesToBatch hTable True
89883>>>>>>>        Open hTable
89885>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
89888>>>>>>>        If (bOpened = False) Begin
89890>>>>>>>            Function_Return False
89891>>>>>>>        End
89891>>>>>>>>
89891>>>>>>>        
89891>>>>>>>        Set Private.phCurrentTable to hTable
89892>>>>>>>        Move 0 to iRecord
89893>>>>>>>        Move (SizeOfArray(aDateFields)) to iSize
89894>>>>>>>        Decrement iSize
89895>>>>>>>
89895>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89898>>>>>>>        Get DriverIndex sDriverID to iDriverIndex
89899>>>>>>>        If (iDriverIndex <> 0) Begin
89901>>>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDateMin
89904>>>>>>>            If (sDateMin = "") Begin
89906>>>>>>>                Move CS_DUFLowestAllowedDateValue to dDateMin
89907>>>>>>>            End
89907>>>>>>>>
89907>>>>>>>            Else Begin
89908>>>>>>>                If (IsDate(sDateMin)) Begin
89910>>>>>>>                    Move sDateMin to dDateMin
89911>>>>>>>                End
89911>>>>>>>>
89911>>>>>>>                Else Begin
89912>>>>>>>                    Move CS_DUFLowestAllowedDateValue to dDateMin
89913>>>>>>>                End
89913>>>>>>>>
89913>>>>>>>            End
89913>>>>>>>>
89913>>>>>>>        End
89913>>>>>>>>
89913>>>>>>>        Else Begin
89914>>>>>>>            Move CS_DUFLowestAllowedDateValue to dDateMin
89915>>>>>>>        End
89915>>>>>>>>
89915>>>>>>>
89915>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
89918>>>>>>>        Set piPosition   of ghoProgressBar to 0
89919>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 100
89920>>>>>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
89921>>>>>>>        Move False to Err
89922>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89923>>>>>>>
89923>>>>>>>        Clear hTable
89924>>>>>>>        Repeat
89924>>>>>>>>
89924>>>>>>>            Vfind hTable 0 GT
89926>>>>>>>            Move Found to bFound
89927>>>>>>>            If (bFound = True) Begin
89929>>>>>>>                Move False to bSaveChanges
89930>>>>>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField
89931>>>>>>>                Move (SizeOfArray(aDateFields)) to iSize
89932>>>>>>>                Decrement iSize
89933>>>>>>>                For iCount from 0 to iSize
89939>>>>>>>>
89939>>>>>>>                    Move aDateFields[iCount] to iField
89940>>>>>>>                    Get_Field_Value hTable iField to dDate
89943>>>>>>>                    If (bFixZeroDates = True) Begin
89945>>>>>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
89946>>>>>>>                    End
89946>>>>>>>>
89946>>>>>>>                    Else Begin
89947>>>>>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
89948>>>>>>>                    End
89948>>>>>>>>
89948>>>>>>>                    If (bChange = True) Begin
89950>>>>>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]
89951>>>>>>>                    End
89951>>>>>>>>
89951>>>>>>>                Loop
89952>>>>>>>>
89952>>>>>>>
89952>>>>>>>                // Only change Date fields that needs to be changed.
89952>>>>>>>                If (SizeOfArray(iaChangeField)) Begin
89954>>>>>>>                    Reread hTable
89958>>>>>>>                        Move (SizeOfArray(iaChangeField)) to iSize
89959>>>>>>>                        Decrement iSize
89960>>>>>>>                        For iCount from 0 to iSize
89966>>>>>>>>
89966>>>>>>>                            Move iaChangeField[iCount] to iField
89967>>>>>>>                            Set Private.piCurrentField to iField
89968>>>>>>>                            Set_Field_Value hTable iField to dDateMin
89971>>>>>>>                        Loop
89972>>>>>>>>
89972>>>>>>>                        Move False to Err
89973>>>>>>>                        SaveRecord hTable
89974>>>>>>>                    Unlock
89975>>>>>>>>
89975>>>>>>>                End
89975>>>>>>>>
89975>>>>>>>
89975>>>>>>>                Increment iRecord
89976>>>>>>>                // Increment the StatusPanel counter and check the
89976>>>>>>>                // cancel status every 100 records rather than every
89976>>>>>>>                // record, it's way faster.
89976>>>>>>>                If (Mod(iRecord, 100) = 0) Begin
89978>>>>>>>                    Send DoAdvance of ghoProgressBar
89979>>>>>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
89980>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
89981>>>>>>>                End
89981>>>>>>>>
89981>>>>>>>            End
89981>>>>>>>>
89981>>>>>>>        Until (bFound = False)
89983>>>>>>>
89983>>>>>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
89986>>>>>>>        If (bResetIndexesToOnLine = True) Begin
89988>>>>>>>            Send SetAllIndexesToBatch hTable False
89989>>>>>>>        End
89989>>>>>>>>
89989>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89990>>>>>>>
89990>>>>>>>        Function_Return (Err = False)
89991>>>>>>>    End_Function
89992>>>>>>>
89992>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
89992>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
89992>>>>>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
89994>>>>>>>        Boolean bIsSame
89994>>>>>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
89994>>>>>>>
89994>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
89995>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
89996>>>>>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
89997>>>>>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
89998>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
89999>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
90000>>>>>>>
90000>>>>>>>        If (bCompareFilelistUppercase = True) Begin
90002>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
90003>>>>>>>        End
90003>>>>>>>>
90003>>>>>>>        Else Begin
90004>>>>>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
90005>>>>>>>        End
90005>>>>>>>>
90005>>>>>>>        If (bIsSame = False) Begin
90007>>>>>>>            Function_Return False
90008>>>>>>>        End
90008>>>>>>>>
90008>>>>>>>
90008>>>>>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
90009>>>>>>>        If (bIsSame = False) Begin
90011>>>>>>>            Function_Return False
90012>>>>>>>        End
90012>>>>>>>>
90012>>>>>>>
90012>>>>>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
90013>>>>>>>        If (bIsSame = False) Begin
90015>>>>>>>            Function_Return False
90016>>>>>>>        End
90016>>>>>>>>
90016>>>>>>>
90016>>>>>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
90017>>>>>>>        If (bIsSame = False) Begin
90019>>>>>>>            Function_Return False
90020>>>>>>>        End
90020>>>>>>>>
90020>>>>>>>
90020>>>>>>>        Function_Return bIsSame
90021>>>>>>>    End_Function
90022>>>>>>>
90022>>>>>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
90024>>>>>>>        Handle hTableFrom hTableTo
90024>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
90024>>>>>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
90024>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
90024>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
90024>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
90025>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
90025>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
90026>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
90026>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
90027>>>>>>>
90027>>>>>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
90028>>>>>>>        If (bIsSame = True) Begin
90030>>>>>>>            Function_Return True
90031>>>>>>>        End
90031>>>>>>>>
90031>>>>>>>
90031>>>>>>>        Move False to bFilelistError
90032>>>>>>>        Move True to bIsSame
90033>>>>>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
90034>>>>>>>        Get pbCompareIndexAscending to bCompareIndexAscending
90035>>>>>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
90036>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
90037>>>>>>>        Set Private.phCurrentTable to hTableFrom
90038>>>>>>>        
90038>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
90039>>>>>>>
90039>>>>>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
90040>>>>>>>        Get _TableNameOnly sRootName             to sRootName
90041>>>>>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
90042>>>>>>>
90042>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
90042>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
90042>>>>>>>        If (bCodeGenerateMode = True) Begin
90044>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
90044>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
90046>>>>>>>                Function_Return False
90047>>>>>>>            End
90047>>>>>>>>
90047>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
90048>>>>>>>            If (bIsSame = False) Begin
90050>>>>>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
90051>>>>>>>                Move True to bFilelistError
90052>>>>>>>                Function_Return False
90053>>>>>>>            End
90053>>>>>>>>
90053>>>>>>>        End
90053>>>>>>>>
90053>>>>>>>
90053>>>>>>>        If (bCodeGenerateMode = False) Begin
90055>>>>>>>            // Then we want to create this table
90055>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
90057>>>>>>>                Function_Return False
90058>>>>>>>            End
90058>>>>>>>>
90058>>>>>>>
90058>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
90059>>>>>>>            If (bIsSame = False) Begin
90061>>>>>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
90062>>>>>>>>
90062>>>>>>>                Move True to bFilelistError
90063>>>>>>>                Function_Return False
90064>>>>>>>            End
90064>>>>>>>>
90064>>>>>>>        End
90064>>>>>>>>
90064>>>>>>>
90064>>>>>>>        // Check columns:
90064>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
90065>>>>>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
90066>>>>>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
90067>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
90068>>>>>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
90069>>>>>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
90070>>>>>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
90071>>>>>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
90072>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
90073>>>>>>>        If (bIsSame = False) Begin
90075>>>>>>>            Function_Return False
90076>>>>>>>        End
90076>>>>>>>>
90076>>>>>>>
90076>>>>>>>        // ...then check indexes:
90076>>>>>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
90077>>>>>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
90078>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
90079>>>>>>>        If (bIsSame = False) Begin
90081>>>>>>>            Function_Return False
90082>>>>>>>        End
90082>>>>>>>>
90082>>>>>>>
90082>>>>>>>        // ...and finally relationships:
90082>>>>>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
90083>>>>>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
90084>>>>>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
90085>>>>>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
90086>>>>>>>
90086>>>>>>>        Function_Return (bIsSame = True)
90087>>>>>>>    End_Function
90088>>>>>>>
90088>>>>>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
90088>>>>>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
90090>>>>>>>        Handle hTable
90090>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
90090>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
90090>>>>>>>
90090>>>>>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
90092>>>>>>>            Move True to bFilelistError
90093>>>>>>>            Function_Return False
90094>>>>>>>        End
90094>>>>>>>>
90094>>>>>>>
90094>>>>>>>        Move APITableCompare.hTable to hTable
90095>>>>>>>        Move True  to bIsSame
90096>>>>>>>        Move False to bFilelistError
90097>>>>>>>
90097>>>>>>>        If (APITableCompare.bExistsFrom = True) Begin
90099>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
90100>>>>>>>        End
90100>>>>>>>>
90100>>>>>>>        Else Begin
90101>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
90102>>>>>>>        End
90102>>>>>>>>
90102>>>>>>>        Get _TableNameOnly sRootName                                   to sRootName
90103>>>>>>>
90103>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
90104>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
90105>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
90106>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
90107>>>>>>>
90107>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
90107>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
90107>>>>>>>        If (bCodeGenerateMode = True) Begin
90109>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
90109>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
90111>>>>>>>                Function_Return False
90112>>>>>>>            End
90112>>>>>>>>
90112>>>>>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
90113>>>>>>>            If (bIsSame = False) Begin
90115>>>>>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
90116>>>>>>>                Move True to bFilelistError
90117>>>>>>>                Function_Return False
90118>>>>>>>            End
90118>>>>>>>>
90118>>>>>>>        End
90118>>>>>>>>
90118>>>>>>>
90118>>>>>>>        If (bCodeGenerateMode = False) Begin
90120>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
90122>>>>>>>                // Then we might want to create this table
90122>>>>>>>                Function_Return False
90123>>>>>>>            End
90123>>>>>>>>
90123>>>>>>>
90123>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
90124>>>>>>>            If (bIsSame = False) Begin
90126>>>>>>>                Function_Return False
90127>>>>>>>            End
90127>>>>>>>>
90127>>>>>>>
90127>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
90128>>>>>>>            If (bIsSame = False) Begin
90130>>>>>>>                Function_Return False
90131>>>>>>>            End
90131>>>>>>>>
90131>>>>>>>
90131>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
90132>>>>>>>            If (bIsSame = False) Begin
90134>>>>>>>                Function_Return False
90135>>>>>>>            End
90135>>>>>>>>
90135>>>>>>>
90135>>>>>>>            // Check table names et al.
90135>>>>>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
90136>>>>>>>            If (bIsSame = False) Begin
90138>>>>>>>                Function_Return False
90139>>>>>>>            End
90139>>>>>>>>
90139>>>>>>>        End
90139>>>>>>>>
90139>>>>>>>
90139>>>>>>>        // Check Columns:
90139>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
90140>>>>>>>        If (bIsSame = False) Begin
90142>>>>>>>            Function_Return False
90143>>>>>>>        End
90143>>>>>>>>
90143>>>>>>>
90143>>>>>>>        // ...then check Indexes:
90143>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
90144>>>>>>>        If (bIsSame = False) Begin
90146>>>>>>>            Function_Return False
90147>>>>>>>        End
90147>>>>>>>>
90147>>>>>>>
90147>>>>>>>        // ...and finally Relationships:
90147>>>>>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
90148>>>>>>>
90148>>>>>>>        Function_Return (bIsSame = True)
90149>>>>>>>    End_Function
90150>>>>>>>
90150>>>>>>>    // To fill a complete Table array structure (tAPITable[]) with data.
90150>>>>>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
90150>>>>>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
90150>>>>>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
90150>>>>>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
90152>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90152>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90152>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
90152>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
90154>>>>>>>        tAPIColumn[]    aApiColumns
90154>>>>>>>        tAPIColumn[]    aApiColumns
90155>>>>>>>        tAPIIndex[]     aApiIndexes
90155>>>>>>>        tAPIIndex[]     aApiIndexes
90156>>>>>>>        tAPIRelation[]  aApiRelations
90156>>>>>>>        tAPIRelation[]  aApiRelations
90157>>>>>>>        Handle hTable
90157>>>>>>>        Integer iCount
90157>>>>>>>        Boolean bUserCancel bOK
90157>>>>>>>        String sLogicalName sMessageText
90157>>>>>>>
90157>>>>>>>        Get AutoConnectionIDLogin to bOK
90158>>>>>>>        Move 0 to hTable
90159>>>>>>>        If (bFromTables = True) Begin
90161>>>>>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
90162>>>>>>>            If (bCompareUtil = True) Begin
90164>>>>>>>                Move (sMessageText * "(1 of 3)") to sMessageText
90165>>>>>>>            End
90165>>>>>>>>
90165>>>>>>>        End
90165>>>>>>>>
90165>>>>>>>        Else Begin
90166>>>>>>>            Move "Reading 'TO' Table Structure:" to sMessageText
90167>>>>>>>            If (bCompareUtil = True) Begin
90169>>>>>>>                Move (sMessageText * "(2 of 3)") to sMessageText
90170>>>>>>>            End
90170>>>>>>>>
90170>>>>>>>        End
90170>>>>>>>>
90170>>>>>>>        Set Message_Text of ghoStatusPanel to sMessageText
90171>>>>>>>
90171>>>>>>>        Get UtilFilelistNoOfTables to iCount
90172>>>>>>>        Set piMaximum of ghoProgressBar to iCount
90173>>>>>>>        Move 0 to iCount
90174>>>>>>>
90174>>>>>>>        Repeat
90174>>>>>>>>
90174>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90177>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
90179>>>>>>>
90179>>>>>>>                Open hTable
90181>>>>>>>                // ToDo: Needs to be revised
90181>>>>>>>                // For some reason tables may be reported as "unopened", while in
90181>>>>>>>                // fact the open was successful (!)
90181>>>>>>>//                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90181>>>>>>>//                If (bIsOpen = False) Begin
90181>>>>>>>//                    Move True to aApiTablesEmpty[0].bError
90181>>>>>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
90181>>>>>>>//                    Function_Return aApiTablesEmpty
90181>>>>>>>//                End
90181>>>>>>>
90181>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90184>>>>>>>                Set piPosition of ghoProgressBar to iCount
90185>>>>>>>                Send DoAdvance of ghoProgressBarOverall
90186>>>>>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
90187>>>>>>>
90187>>>>>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
90188>>>>>>>//                Close hTable DF_PERMANENT
90188>>>>>>>                Increment iCount
90189>>>>>>>            End
90189>>>>>>>>
90189>>>>>>>
90189>>>>>>>            If (bStatusPanel = True) Begin
90191>>>>>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
90192>>>>>>>                If (bUserCancel = True) Begin
90194>>>>>>>                    Move True to aApiTablesEmpty[0].bCancel
90195>>>>>>>                    Function_Return aApiTablesEmpty
90196>>>>>>>                End
90196>>>>>>>>
90196>>>>>>>            End
90196>>>>>>>>
90196>>>>>>>
90196>>>>>>>        Until (hTable = 0)
90198>>>>>>>
90198>>>>>>>        Function_Return aApiTables
90199>>>>>>>    End_Function
90200>>>>>>>
90200>>>>>>>    // Returns a 'single' table APITable struct.
90200>>>>>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
90202>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90202>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90202>>>>>>>        tAPITable         ApiTable ApiTableEmpty
90202>>>>>>>        tAPITable         ApiTable ApiTableEmpty
90202>>>>>>>        tAPIColumn[]     aApiColumns
90202>>>>>>>        tAPIColumn[]     aApiColumns
90203>>>>>>>        tAPIIndex[]      aApiIndexes
90203>>>>>>>        tAPIIndex[]      aApiIndexes
90204>>>>>>>        tAPIRelation[]   aApiRelations
90204>>>>>>>        tAPIRelation[]   aApiRelations
90205>>>>>>>        Boolean bIsOpen
90205>>>>>>>
90205>>>>>>>        Open hTable
90207>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90210>>>>>>>        If (bIsOpen = False) Begin
90212>>>>>>>            Move True to ApiTableEmpty.bError
90213>>>>>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90214>>>>>>>            Function_Return ApiTableEmpty
90215>>>>>>>        End
90215>>>>>>>>
90215>>>>>>>
90215>>>>>>>        // Fill Table Name Info
90215>>>>>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
90216>>>>>>>
90216>>>>>>>        // Fill columns
90216>>>>>>>        Get UtilColumnsStructFill hTable to aApiColumns
90217>>>>>>>        If (SizeOfArray(aApiColumns)) Begin
90219>>>>>>>            If (aApiColumns[0].bCancel = True) Begin
90221>>>>>>>                Move True to ApiTableEmpty.bError
90222>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90223>>>>>>>                Function_Return ApiTableEmpty
90224>>>>>>>            End
90224>>>>>>>>
90224>>>>>>>        End
90224>>>>>>>>
90224>>>>>>>
90224>>>>>>>        // Fill indexes
90224>>>>>>>        Get UtilIndexesStructFill hTable to aApiIndexes
90225>>>>>>>        If (SizeOfArray(aApiIndexes)) Begin
90227>>>>>>>            If (aApiIndexes[0].bCancel = True) Begin
90229>>>>>>>                Move True to ApiTableEmpty.bError
90230>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90231>>>>>>>                Function_Return ApiTableEmpty
90232>>>>>>>            End
90232>>>>>>>>
90232>>>>>>>        End
90232>>>>>>>>
90232>>>>>>>
90232>>>>>>>        // Fill relationships
90232>>>>>>>        Get UtilRelationsStructFill hTable to aApiRelations
90233>>>>>>>        If (SizeOfArray(aApiRelations)) Begin
90235>>>>>>>            If (aApiRelations[0].bCancel = True) Begin
90237>>>>>>>                Move True to ApiTableEmpty.bError
90238>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90239>>>>>>>                Function_Return ApiTableEmpty
90240>>>>>>>            End
90240>>>>>>>>
90240>>>>>>>        End
90240>>>>>>>>
90240>>>>>>>
90240>>>>>>>        Move hTable             to ApiTable.hTable
90241>>>>>>>        Move bFromTables        to ApiTable.bFromTable
90242>>>>>>>        Move (not(bFromTables)) to ApiTable.bToTable
90243>>>>>>>
90243>>>>>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
90244>>>>>>>        Move aApiColumns        to ApiTable.aApiColumns
90245>>>>>>>        Move aApiIndexes        to ApiTable.aApiIndexes
90246>>>>>>>        Move aApiRelations      to ApiTable.aApiRelations
90247>>>>>>>
90247>>>>>>>        Function_Return ApiTable
90248>>>>>>>    End_Function
90249>>>>>>>
90249>>>>>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
90251>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
90251>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
90251>>>>>>>        Boolean bIsOpen
90251>>>>>>>
90251>>>>>>>        Open hTable
90253>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90256>>>>>>>        If (bIsOpen = False) Begin
90258>>>>>>>            Move True   to APITableNameInfoEmpty.bError
90259>>>>>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
90260>>>>>>>            Function_Return APITableNameInfoEmpty
90261>>>>>>>        End
90261>>>>>>>>
90261>>>>>>>
90261>>>>>>>        Move hTable                                  to APITableNameInfo.iTableNumber
90262>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
90265>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
90268>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
90271>>>>>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
90274>>>>>>>
90274>>>>>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
90275>>>>>>>        Get _UtilTableIsSql                   hTable to APITableNameInfo.bIsSQL
90276>>>>>>>
90276>>>>>>>        Function_Return APITableNameInfo
90277>>>>>>>    End_Function
90278>>>>>>>
90278>>>>>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
90280>>>>>>>        Integer iSize iCount iItem
90280>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90280>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90280>>>>>>>
90280>>>>>>>        Move -1 to iItem
90281>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
90282>>>>>>>        Decrement iSize
90283>>>>>>>        for iCount from 0 to iSize
90289>>>>>>>>
90289>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
90290>>>>>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
90292>>>>>>>                Move iCount to iItem
90293>>>>>>>                Move iSize  to iCount // We're done.
90294>>>>>>>            End
90294>>>>>>>>
90294>>>>>>>        Loop
90295>>>>>>>>
90295>>>>>>>
90295>>>>>>>        Function_Return iItem
90296>>>>>>>    End_Function
90297>>>>>>>
90297>>>>>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
90299>>>>>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
90302>>>>>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
90305>>>>>>>
90305>>>>>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
90308>>>>>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
90311>>>>>>>
90311>>>>>>>        Function_Return (EQ)
90312>>>>>>>    End_Function
90313>>>>>>>
90313>>>>>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
90315>>>>>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
90315>>>>>>>        Handle hTable
90315>>>>>>>        tAPITable[] aAPITableFromAndTo
90315>>>>>>>        tAPITable[] aAPITableFromAndTo
90316>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
90316>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
90316>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90316>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90316>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
90316>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
90317>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
90317>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
90318>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
90318>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
90319>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
90319>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
90320>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
90320>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
90320>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
90320>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
90323>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
90323>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
90326>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
90326>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
90329>>>>>>>
90329>>>>>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
90330>>>>>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
90331>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
90333>>>>>>>            Function_Return aAPITableCompare
90334>>>>>>>        End
90334>>>>>>>>
90334>>>>>>>
90334>>>>>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
90335>>>>>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
90336>>>>>>>
90336>>>>>>>        Move 0 to iItem
90337>>>>>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
90338>>>>>>>        Decrement iSize
90339>>>>>>>        for iCount from 0 to iSize
90345>>>>>>>>
90345>>>>>>>
90345>>>>>>>            Move iCount to iItemFrom
90346>>>>>>>            Move iCount to iItemTo
90347>>>>>>>            Move APITableEmpty to APITableFrom
90348>>>>>>>            Move APITableEmpty to APITableTo
90349>>>>>>>
90349>>>>>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
90351>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
90352>>>>>>>            End
90352>>>>>>>>
90352>>>>>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
90354>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
90355>>>>>>>            End
90355>>>>>>>>
90355>>>>>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
90357>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
90358>>>>>>>                Move (iCount + 1) to iItemTo
90359>>>>>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
90360>>>>>>>            End
90360>>>>>>>>
90360>>>>>>>            If (APITableFrom.hTable > APITableTo.hTable) Begin
90362>>>>>>>                Get FindTableNumber aAPITableTo APITableFrom.hTable to iItemTo
90363>>>>>>>                If (iItemTo <> -1) Begin
90365>>>>>>>                    Move aAPITableTo[iItemTo] to APITableTo
90366>>>>>>>                End
90366>>>>>>>>
90366>>>>>>>                Else Begin
90367>>>>>>>                    Move APITableEmpty to APITableTo
90368>>>>>>>                End
90368>>>>>>>>
90368>>>>>>>            End
90368>>>>>>>>
90368>>>>>>>
90368>>>>>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
90369>>>>>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
90370>>>>>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
90371>>>>>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
90372>>>>>>>
90372>>>>>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
90373>>>>>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
90374>>>>>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
90375>>>>>>>            Move APITableTo.aApiRelations   to aApiRelationTo
90376>>>>>>>
90376>>>>>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
90377>>>>>>>
90377>>>>>>>            If (hTable > 0) Begin
90379>>>>>>>
90379>>>>>>>                // Table info:
90379>>>>>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
90380>>>>>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
90381>>>>>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
90382>>>>>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
90383>>>>>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
90384>>>>>>>
90384>>>>>>>                // Column info:
90384>>>>>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
90385>>>>>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
90386>>>>>>>
90386>>>>>>>                // Index info:
90386>>>>>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
90387>>>>>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
90388>>>>>>>
90388>>>>>>>                // Relation info:
90388>>>>>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
90389>>>>>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
90390>>>>>>>
90390>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
90391>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
90392>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bError
90393>>>>>>>                If (iItemTo > iItemFrom) Begin
90395>>>>>>>                    Increment iCount
90396>>>>>>>                End
90396>>>>>>>>
90396>>>>>>>                Increment iItem
90397>>>>>>>            End
90397>>>>>>>>
90397>>>>>>>
90397>>>>>>>        Loop
90398>>>>>>>>
90398>>>>>>>
90398>>>>>>>        Function_Return aAPITableCompare
90399>>>>>>>    End_Function
90400>>>>>>>
90400>>>>>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
90402>>>>>>>        Integer iSize iCount iItem
90402>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90402>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90402>>>>>>>
90402>>>>>>>        Move -1 to iItem
90403>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
90404>>>>>>>        Decrement iSize
90405>>>>>>>        For iCount from 0 to iSize
90411>>>>>>>>
90411>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
90412>>>>>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
90414>>>>>>>                Move iCount to iItem
90415>>>>>>>                Move iSize  to iCount // We're done.
90416>>>>>>>            End
90416>>>>>>>>
90416>>>>>>>        Loop
90417>>>>>>>>
90417>>>>>>>
90417>>>>>>>        Function_Return iItem
90418>>>>>>>    End_Function
90419>>>>>>>
90419>>>>>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
90421>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90421>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90421>>>>>>>
90421>>>>>>>        If (APITableNameInfoFrom.iTableNumber = 0 and APITableNameInfoTo.iTableNumber = 0) Begin
90423>>>>>>>            Function_Return APITableNameInfoCompare
90424>>>>>>>        End
90424>>>>>>>>
90424>>>>>>>
90424>>>>>>>        // FROM database info:
90424>>>>>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
90426>>>>>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
90427>>>>>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
90428>>>>>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
90429>>>>>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
90430>>>>>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
90431>>>>>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
90432>>>>>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
90433>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
90434>>>>>>>        End
90434>>>>>>>>
90434>>>>>>>
90434>>>>>>>        // TO database info:
90434>>>>>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
90436>>>>>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
90437>>>>>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
90438>>>>>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
90439>>>>>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
90440>>>>>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
90441>>>>>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
90442>>>>>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
90443>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsTo
90444>>>>>>>        End
90444>>>>>>>>
90444>>>>>>>
90444>>>>>>>        Function_Return APITableNameInfoCompare
90445>>>>>>>    End_Function
90446>>>>>>>
90446>>>>>>>    // Note:
90446>>>>>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
90446>>>>>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
90446>>>>>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
90446>>>>>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
90446>>>>>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
90446>>>>>>>    Function UtilTableHandleToString Handle hTable Returns String
90448>>>>>>>        String sTableName
90448>>>>>>>        Boolean bOpen bExists bOK
90448>>>>>>>
90448>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
90449>>>>>>>        If (bExists = False) Begin
90451>>>>>>>            Function_Return ""
90452>>>>>>>        End
90452>>>>>>>>
90452>>>>>>>
90452>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90453>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90456>>>>>>>        If (bOpen = False) Begin
90458>>>>>>>            Get AutoConnectionIDLogin to bOK
90459>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90460>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
90461>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
90462>>>>>>>            Open hTable
90464>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90465>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
90466>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
90467>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
90470>>>>>>>        End
90470>>>>>>>>
90470>>>>>>>        If (bOpen = True) Begin
90472>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90473>>>>>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
90476>>>>>>>            // If blank it is an embedded table:
90476>>>>>>>            If (sTableName = "") Begin
90478>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
90481>>>>>>>                Move 0 to LastErr
90482>>>>>>>                Move False to Err
90483>>>>>>>            End
90483>>>>>>>>
90483>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90484>>>>>>>        End
90484>>>>>>>>
90484>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90485>>>>>>>        Move 0 to LastErr
90486>>>>>>>
90486>>>>>>>        Function_Return sTableName
90487>>>>>>>    End_Function
90488>>>>>>>
90488>>>>>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
90488>>>>>>>    // Returns 0 if unsuccessful.
90488>>>>>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
90488>>>>>>>    Function UtilTableNameToHandle String sTableName Returns Integer
90490>>>>>>>        String sValue sPrefixTableName sDriverID
90490>>>>>>>        Handle hTable hRetval
90490>>>>>>>
90490>>>>>>>        Get psDriverID to sDriverID
90491>>>>>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
90493>>>>>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
90494>>>>>>>        End
90494>>>>>>>>
90494>>>>>>>        Move 0 to hTable
90495>>>>>>>        Move 0 to hRetval
90496>>>>>>>        Repeat
90496>>>>>>>>
90496>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90499>>>>>>>            If (hTable <> 0) Begin
90501>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
90504>>>>>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
90506>>>>>>>                    Move hTable to hRetval
90507>>>>>>>                    Move 0 to hTable
90508>>>>>>>                End
90508>>>>>>>>
90508>>>>>>>            End
90508>>>>>>>>
90508>>>>>>>        Until (hTable = 0)
90510>>>>>>>
90510>>>>>>>        Function_Return hRetval
90511>>>>>>>    End_Function
90512>>>>>>>
90512>>>>>>>    // Use function to move all *.dat, *.k?? & *.hdr files to a "Data\Backup" folder
90512>>>>>>>    // _after_ all tables have successfully been converted to SQL (.int files)
90512>>>>>>>    Function UtilMoveAllEmbeddedToBackupFolder Returns Boolean
90514>>>>>>>        Boolean bOK bExists
90514>>>>>>>        String sDataPath sBackupFolder
90514>>>>>>>
90514>>>>>>>        Close DF_ALL DF_PERMANENT
90515>>>>>>>        Send DoAdvance of ghoProgressBar
90516>>>>>>>
90516>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
90517>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
90518>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
90519>>>>>>>        Get vFolderFormat sDataPath to sDataPath
90520>>>>>>>
90520>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
90521>>>>>>>        If (bExists = False) Begin
90523>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
90524>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
90525>>>>>>>            If (bExists = False) Begin
90527>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
90528>>>>>>>>
90528>>>>>>>                Function_Return False
90529>>>>>>>            End
90529>>>>>>>>
90529>>>>>>>        End
90529>>>>>>>>
90529>>>>>>>
90529>>>>>>>        Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
90530>>>>>>>        Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
90531>>>>>>>        Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
90532>>>>>>>        Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
90533>>>>>>>        // We need to wait for Windows before we can copy files back
90533>>>>>>>        Sleep 2  
90534>>>>>>>        
90534>>>>>>>        //...except for these files that needs to be copied back to the Data folder:
90534>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeMast.*")  sDataPath to bOK 
90535>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeType.*")  sDataPath to bOK                                 
90536>>>>>>>        Get vCopyFile (sBackupFolder + "\Flexerrs.*")  sDataPath to bOK                                 
90537>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr001.*")  sDataPath to bOK                                 
90538>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr002.*")  sDataPath to bOK                                 
90539>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr003.*")  sDataPath to bOK                                 
90540>>>>>>>//            Get vCopyFile (sBackupFolder + "\DbVersion.*") sDataPath to bOK  
90540>>>>>>>        
90540>>>>>>>
90540>>>>>>>        Set Message_Text of ghoStatusPanel to ""
90541>>>>>>>        Function_Return True
90542>>>>>>>    End_Function
90543>>>>>>>    
90543>>>>>>>    Function UtilTableRepairAndReindexALL Returns Boolean
90545>>>>>>>        Boolean bOK bRetval
90545>>>>>>>        Handle hTable
90545>>>>>>>        Integer iSize iCount
90545>>>>>>>        
90545>>>>>>>        Move True to bOK
90546>>>>>>>        Get UtilFilelistNoOfTables to iSize
90547>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
90548>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
90549>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
90550>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
90551>>>>>>>
90551>>>>>>>        Repeat
90551>>>>>>>>
90551>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
90552>>>>>>>            Increment iCount
90553>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90556>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin // 50 = Flexerrs.
90558>>>>>>>                Get UtilTableRepairAndReindex hTable to bRetval
90559>>>>>>>                If (bRetval = False) Begin
90561>>>>>>>                    Move False to bOK
90562>>>>>>>                End
90562>>>>>>>>
90562>>>>>>>            End
90562>>>>>>>>
90562>>>>>>>        Until (hTable = 0)
90564>>>>>>>                
90564>>>>>>>        Function_Return bOK
90565>>>>>>>    End_Function           
90566>>>>>>>    
90566>>>>>>>    // Checks if an Embedded (DataFlex) data-file needs to be repaired.
90566>>>>>>>    // After the header has been repaired - also makes a re-index.  
90566>>>>>>>    // Returns TRUE if successful OR the table was an an ALIAS or SQL table in case we do nothing.
90566>>>>>>>    Function UtilTableRepairAndReindex Handle hTable Returns Boolean
90568>>>>>>>        Boolean bOK bIsAlias bIsEmbedded bIsOpen bBadExists
90568>>>>>>>        Integer iRetval
90568>>>>>>>        String sRootName sFileName sDataPath
90568>>>>>>>        
90568>>>>>>>        Move False to Err
90569>>>>>>>        Move 0 to LastErr 
90570>>>>>>>        Move True to bOK
90571>>>>>>>        
90571>>>>>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
90572>>>>>>>        If (bIsEmbedded = False or hTable = 50) Begin // 50 = Flexerrs
90574>>>>>>>            Function_Return True
90575>>>>>>>        End
90575>>>>>>>>
90575>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias 
90576>>>>>>>        If (bIsAlias = True) Begin
90578>>>>>>>            Function_Return True
90579>>>>>>>        End
90579>>>>>>>>
90579>>>>>>>        
90579>>>>>>>        // Check for bad file and remove if exists
90579>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
90582>>>>>>>        Set private.phCurrentTable to hTable  
90583>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
90584>>>>>>>        
90584>>>>>>>        // This is important! Else it can happen that the table can't be opened,
90584>>>>>>>        // with a "4077 - File in use" error.
90584>>>>>>>        Close DF_ALL DF_PERMANENT    
90585>>>>>>>        Open hTable
90587>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90590>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90591>>>>>>>        If (bIsOpen = False) Begin
90593>>>>>>>            Error DFERR_PROGRAM ("Could not open table to be repaired and reindexed:" * String(sRootName))
90594>>>>>>>>
90594>>>>>>>            Function_Return False        
90595>>>>>>>        End
90595>>>>>>>>
90595>>>>>>>
90595>>>>>>>        Get vFilePathExists (sRootName + ".BAD")  to bBadExists
90596>>>>>>>        If (bBadExists = True) Begin
90598>>>>>>>            Get_File_Path (sRootName + ".BAD") to sFileName
90599>>>>>>>            Get vDeleteFile sFileName to iRetval
90600>>>>>>>        End
90600>>>>>>>>
90600>>>>>>>        
90600>>>>>>>        Set TableName_Text of ghoStatusPanel to ("Repairing and reindex Table Name:" * sRootName * "Number:" * String(hTable))
90601>>>>>>>        
90601>>>>>>>        Move False to Err
90602>>>>>>>        // **** Repair and reindex the table. ****
90602>>>>>>>        Get UtilTableRepairEmbedded hTable sRootName to bOK
90603>>>>>>>
90603>>>>>>>        // Check for bad file: if it exists, something went wrong
90603>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
90604>>>>>>>        Get vFolderFormat sDataPath to sDataPath
90605>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".BAD") to bBadExists
90606>>>>>>>        If (bBadExists = True) Begin
90608>>>>>>>            Error DFERR_PROGRAM ("Error while sorting data. .BAD file created:"  * String(sRootName) + ".BAD")
90609>>>>>>>>
90609>>>>>>>            Move False to bOK
90610>>>>>>>        End
90610>>>>>>>>
90610>>>>>>>        Close hTable
90611>>>>>>>
90611>>>>>>>        Function_Return bOK
90612>>>>>>>    End_Function
90613>>>>>>>
90613>>>>>>>    // Repair and reindex the named DataFlex data-table.
90613>>>>>>>    // No checks are done if the passed table name is an embedded or SQL,
90613>>>>>>>    // so use with care (make sure you only pass embedded table names).
90613>>>>>>>    Function UtilTableRepairEmbedded Handle hTable String sTableName Returns Boolean
90615>>>>>>>        String sMode
90615>>>>>>>        Integer iVoid
90615>>>>>>>
90615>>>>>>>        Set Message_Text of ghoStatusPanel to "Repair/Reindex in progress..."
90616>>>>>>>        Move "0" to sMode   // 0=Reindex after repair!    
90617>>>>>>>        Close hTable        // The table needs to be closed, else error 4177 "Table in use".
90618>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_REPAIR_FILE Callback ghoDbUpdateHandler Passing sTableName sMode 0 Result iVoid 
90623>>>>>>>        Set Message_Text of ghoStatusPanel to ""
90624>>>>>>>        Function_Return (iVoid = 0)
90625>>>>>>>    End_Function
90626>>>>>>>
90626>>>>>>>    // Returns _two_ arrays.
90626>>>>>>>    // Returns all files that are Master files in array ByRef iaFileIsMaster
90626>>>>>>>    // Also returns all files that are Alias files in a second array.
90626>>>>>>>    // IMPORTANT: All master & alias files _must_ have been included into
90626>>>>>>>    //            the DoSetAllMasterAndAlias message.
90626>>>>>>>    Function UtilTableAllMasterAndAliasFiles Integer[] ByRef iaFileIsMaster Returns Integer[]
90628>>>>>>>        Integer[] iaFileIsAlias
90629>>>>>>>        Integer hTable iFileAlias iSize
90629>>>>>>>        Boolean bOpen
90629>>>>>>>
90629>>>>>>>        Move 0 to hTable
90630>>>>>>>        Repeat
90630>>>>>>>>
90630>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90633>>>>>>>            If (hTable <> 0) Begin
90635>>>>>>>                Open hTable
90637>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
90640>>>>>>>                If (bOpen = True) Begin
90642>>>>>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iFileAlias
90645>>>>>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
90647>>>>>>>                        Move (SizeOfArray(iaFileIsMaster)) to iSize
90648>>>>>>>                        Move hTable to iaFileIsMaster[iSize]
90649>>>>>>>                    End
90649>>>>>>>>
90649>>>>>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
90652>>>>>>>                        Move (SizeOfArray(iaFileIsAlias)) to iSize
90653>>>>>>>                        Move hTable to iaFileIsAlias[iSize]
90654>>>>>>>                    End
90654>>>>>>>>
90654>>>>>>>                End
90654>>>>>>>>
90654>>>>>>>            End
90654>>>>>>>>
90654>>>>>>>        Until (hTable = 0)
90656>>>>>>>
90656>>>>>>>        Function_Return iaFileIsAlias
90657>>>>>>>    End_Function  
90658>>>>>>>    
90658>>>>>>>    // Is a repair of the data-header necessary? (Embedded tables only)
90658>>>>>>>    Function UtilTableRepairIsNeeded Handle hTable String sTableName Returns Integer
90660>>>>>>>        String sMode
90660>>>>>>>        Integer iRepairNeeded bIsOpen
90660>>>>>>>
90660>>>>>>>        Move "0" to sMode
90661>>>>>>>        Set private.phCurrentTable to hTable 
90662>>>>>>>        Close hTable
90663>>>>>>>        Open hTable
90665>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90668>>>>>>>        Call_Driver hTable DATAFLEX_ID Function FLEX_GET_REPAIRS_NEEDED Callback 0 Passing sTableName sMode 0 Result iRepairNeeded
90673>>>>>>>
90673>>>>>>>        Function_Return iRepairNeeded
90674>>>>>>>    End_Function
90675>>>>>>>
90675>>>>>>>    // Helper function
90675>>>>>>>    // Takes two params:
90675>>>>>>>    //   1. An array with all master table numbers  (Function UtilTableAllMasterAndAliasFiles)
90675>>>>>>>    //   2. An array with all alias table numbers   (Function UtilTableAllMasterAndAliasFiles)
90675>>>>>>>    // Returns:
90675>>>>>>>    //  DF_FILE_ALIAS_DEFAULT if no master or alias
90675>>>>>>>    //  DF_FILE_IS_MASTER if master
90675>>>>>>>    //  DF_FILE_IS_ALIAS if alias
90675>>>>>>>    Function UtilTableIsMasterAlias Handle hTable Integer[] iaFileIsMaster Integer[] iaFileIsAlias Returns Integer
90677>>>>>>>        Integer i iSize
90677>>>>>>>
90677>>>>>>>        Move (SizeOfArray(iaFileIsMaster)) to iSize
90678>>>>>>>        Decrement iSize
90679>>>>>>>        for i from 0 to iSize
90685>>>>>>>>
90685>>>>>>>            If (hTable = iaFileIsMaster[i]) Begin
90687>>>>>>>                Function_Return DF_FILE_IS_MASTER
90688>>>>>>>            End
90688>>>>>>>>
90688>>>>>>>        Loop
90689>>>>>>>>
90689>>>>>>>
90689>>>>>>>        Move (SizeOfArray(iaFileIsAlias)) to iSize
90690>>>>>>>        Decrement iSize
90691>>>>>>>        for i from 0 to iSize
90697>>>>>>>>
90697>>>>>>>            If (hTable = iaFileIsAlias[i]) Begin
90699>>>>>>>                Function_Return DF_FILE_IS_ALIAS
90700>>>>>>>            End
90700>>>>>>>>
90700>>>>>>>        Loop
90701>>>>>>>>
90701>>>>>>>
90701>>>>>>>        Function_Return DF_FILE_ALIAS_DEFAULT
90702>>>>>>>    End_Function
90703>>>>>>>
90703>>>>>>>    // Determine the available indexes of a table.
90703>>>>>>>    //
90703>>>>>>>    // Arguments:
90703>>>>>>>    //   Handle hTable - The number of the table
90703>>>>>>>    //
90703>>>>>>>    // Returns:
90703>>>>>>>    //   String - A string to be used with the sort command
90703>>>>>>>    //   to re-index all indexes of a table.
90703>>>>>>>    Function UtilTableIndexString Handle hTable Returns String
90705>>>>>>>        String  sSortString
90705>>>>>>>        Integer iLastIndex iNumSegments iCount
90705>>>>>>>
90705>>>>>>>        Move "" to sSortString
90706>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
90709>>>>>>>
90709>>>>>>>        for iCount from 1 to iLastIndex
90715>>>>>>>>
90715>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iNumSegments
90718>>>>>>>            If iNumSegments Begin
90720>>>>>>>                If (Length(sSortString)) ;                    Move (Append(sSortString, " ")) to sSortString
90723>>>>>>>                Move (Append(sSortString, iCount)) to sSortString
90724>>>>>>>            End
90724>>>>>>>>
90724>>>>>>>        Loop
90725>>>>>>>>
90725>>>>>>>
90725>>>>>>>        Function_Return sSortString
90726>>>>>>>    End_Function
90727>>>>>>>
90727>>>>>>>    
90727>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90727>>>>>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
90729>>>>>>>        Function_Return False
90730>>>>>>>    End_Function
90731>>>>>>>
90731>>>>>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
90731>>>>>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90733>>>>>>>        Boolean bIsSame
90733>>>>>>>        Integer iCount iColumns iColumn
90733>>>>>>>
90733>>>>>>>        Move True to bIsSame
90734>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
90735>>>>>>>        Set piMaximum of ghoProgressBar  to iColumns
90736>>>>>>>        Decrement iColumns
90737>>>>>>>
90737>>>>>>>        for iCount from 0 to iColumns
90743>>>>>>>>
90743>>>>>>>            Set piPosition of ghoProgressBar to iCount
90744>>>>>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
90745>>>>>>>            If (bIsSame = False) Begin
90747>>>>>>>                Function_Return False
90748>>>>>>>            End
90748>>>>>>>>
90748>>>>>>>        Loop
90749>>>>>>>>
90749>>>>>>>
90749>>>>>>>        Function_Return (bIsSame = True)
90750>>>>>>>    End_Function
90751>>>>>>>
90751>>>>>>>    // Compares a single column (For 'FROM' & 'TO' tables)
90751>>>>>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90753>>>>>>>        Integer iFromType iToType iDbType
90753>>>>>>>        tColumnType ColumnType
90753>>>>>>>        tColumnType ColumnType
90753>>>>>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
90753>>>>>>>
90753>>>>>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
90755>>>>>>>            Function_Return False
90756>>>>>>>        End
90756>>>>>>>>
90756>>>>>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
90758>>>>>>>            Function_Return False
90759>>>>>>>        End
90759>>>>>>>>
90759>>>>>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
90761>>>>>>>            Function_Return False
90762>>>>>>>        End                                                                
90762>>>>>>>>
90762>>>>>>>
90762>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = True) Begin
90764>>>>>>>            If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
90766>>>>>>>                Function_Return False
90767>>>>>>>            End
90767>>>>>>>>
90767>>>>>>>            If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
90769>>>>>>>                If ((APIColumnCompare.sDefaultValueFrom = ""   and APIColumnCompare.sDefaultValueTo = "''") or ;                    (APIColumnCompare.sDefaultValueFrom = "''" and APIColumnCompare.sDefaultValueTo = "")) Begin
90771>>>>>>>                    End
90771>>>>>>>>
90771>>>>>>>                Else Begin
90772>>>>>>>                    Function_Return False
90773>>>>>>>                End
90773>>>>>>>>
90773>>>>>>>            End
90773>>>>>>>>
90773>>>>>>>        End
90773>>>>>>>>
90773>>>>>>>
90773>>>>>>>        Get piDbType                       to iDbType
90774>>>>>>>        Move APIColumnCompare.iTypeFrom    to iFromType
90775>>>>>>>        Move APIColumnCompare.iTypeTo      to iToType
90776>>>>>>>
90776>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
90776>>>>>>>        // data types between Embedded and SQL.
90776>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
90778>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
90779>>>>>>>        End
90779>>>>>>>>
90779>>>>>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
90781>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
90782>>>>>>>        End
90782>>>>>>>>
90782>>>>>>>
90782>>>>>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
90783>>>>>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
90784>>>>>>>
90784>>>>>>>        // Make Date and DateTime comparison?
90784>>>>>>>        If (bCompareDate_DataTime = True) Begin
90786>>>>>>>            If (iFromType <> iToType) Begin
90788>>>>>>>                Function_Return False
90789>>>>>>>            End
90789>>>>>>>>
90789>>>>>>>        End
90789>>>>>>>>
90789>>>>>>>
90789>>>>>>>        // This is when not checking for Date/DateTime differences but all other other field types...
90789>>>>>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
90791>>>>>>>            If (iFromType <> iToType) Begin
90793>>>>>>>                Function_Return False
90794>>>>>>>            End
90794>>>>>>>>
90794>>>>>>>        End
90794>>>>>>>>
90794>>>>>>>
90794>>>>>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
90794>>>>>>>        If (bIsDateTypeFrom = False) Begin
90796>>>>>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
90798>>>>>>>                Function_Return False
90799>>>>>>>            End
90799>>>>>>>>
90799>>>>>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
90801>>>>>>>                Function_Return False
90802>>>>>>>            End
90802>>>>>>>>
90802>>>>>>>        End
90802>>>>>>>>
90802>>>>>>>
90802>>>>>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
90804>>>>>>>            Function_Return False
90805>>>>>>>        End
90805>>>>>>>>
90805>>>>>>>
90805>>>>>>>        Function_Return True
90806>>>>>>>    End_Function
90807>>>>>>>
90807>>>>>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
90809>>>>>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iCheckFieldNumber iDriverID
90809>>>>>>>        Boolean bIdentityKey bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
90809>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90809>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90811>>>>>>>        String sDriverID sRootName sLogicalName sDataType
90811>>>>>>>
90811>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90812>>>>>>>        Get piDbType to iDbType
90813>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90816>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
90819>>>>>>>
90819>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90822>>>>>>>        If (bIsOpen = False) Begin
90824>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90825>>>>>>>            Open hTable
90827>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90828>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90831>>>>>>>            If (bIsOpen = False) Begin
90833>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90834>>>>>>>                Move True to APIColumnsEmpty[0].bError
90835>>>>>>>                Function_Return APIColumnsEmpty
90836>>>>>>>            End
90836>>>>>>>>
90836>>>>>>>        End
90836>>>>>>>>
90836>>>>>>>
90836>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
90839>>>>>>>        Get IsSQLDriver    sDriverID to bSqlDriver
90840>>>>>>>        Get _UtilTableIsSqlByRootName sRootName to bIsSqlTable
90841>>>>>>>        If (bIsSqlTable = True) Begin
90843>>>>>>>            Get _UtilTableExists hTable to bExists
90844>>>>>>>            If (bExists = False) Begin
90846>>>>>>>                Move True to APIColumnsEmpty[0].bError
90847>>>>>>>                Function_Return APIColumnsEmpty
90848>>>>>>>            End
90848>>>>>>>>
90848>>>>>>>        End
90848>>>>>>>>
90848>>>>>>>//        Get DriverIndex sDriverID to iDriverID
90848>>>>>>>//        If (sDriverID = MSSQLDRV_ID) Begin
90848>>>>>>>//            Set_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE of iDriverId to 'datetime2'
90848>>>>>>>//        End
90848>>>>>>>
90848>>>>>>>        Move 0 to iCount
90849>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90852>>>>>>>        Set piMaximum of ghoProgressBar to iNumColumns
90853>>>>>>>
90853>>>>>>>        for iColumn from 1 to iNumColumns
90859>>>>>>>>
90859>>>>>>>            Move 0 to iOptions
90860>>>>>>>            Move False to bIdentityKey
90861>>>>>>>            Move False to Err
90862>>>>>>>            Move 0     to LastErr
90863>>>>>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
90864>>>>>>>            Set piPosition of ghoProgressBar to iColumn
90865>>>>>>>
90865>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90866>>>>>>>            If (bIsSqlTable = True) Begin 
90868>>>>>>>//                If (iType = DF_DATE) Begin
90868>>>>>>>//                    // Note: This is actually the same as SQL_DATETIME
90868>>>>>>>//                    Move SQL_DATE to iType
90868>>>>>>>//                    Move 3 to APIColumns[iCouknt].iPrecision
90868>>>>>>>//                End
90868>>>>>>>//                Else If (iType = DF_DATET Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iTypeIME) Begin
90868>>>>>>>//                    // In modern MS-SQL databases SQL_DATETIME will be = to "datetime2".
90868>>>>>>>//                    // By default MS-SQL will create such a field with 7 (!) decimal places.
90868>>>>>>>//                    // This is just a waste because DataFlex will truncate that to 3 decimal
90868>>>>>>>//                    // places. Therefore, we hard-code the precision to be only thee decimals.
90868>>>>>>>//                    Move SQL_DATETIME to iType
90868>>>>>>>//                    Move 3 to APIColumns[iCount].iPrecision
90868>>>>>>>//                End
90868>>>>>>>//                Move iType                                                to APIColumns[iCount].iType
90868>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to APIColumns[iCount].iType
90871>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
90874>>>>>>>                Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
90877>>>>>>>                Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue
90880>>>>>>>            End
90880>>>>>>>>
90880>>>>>>>            Else Begin
90881>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
90884>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90885>>>>>>>            End
90885>>>>>>>>
90885>>>>>>>
90885>>>>>>>            // If the array value is out of bounce it means that this column doesn't exist on the backend.
90885>>>>>>>            Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
90888>>>>>>>            Move (iCheckFieldNumber >= 0) to bExists
90889>>>>>>>            If (bExists = False) Begin
90891>>>>>>>                Move 0 to APIColumns[iCount].iType
90892>>>>>>>            End
90892>>>>>>>>
90892>>>>>>>            If (bExists = True) Begin
90894>>>>>>>                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
90897>>>>>>>            End
90897>>>>>>>>
90897>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90898>>>>>>>            If (bIdentityKey = True) Begin
90900>>>>>>>                Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
90901>>>>>>>            End
90901>>>>>>>>
90901>>>>>>>
90901>>>>>>>//            Else Begin
90901>>>>>>>//                Move False to Err
90901>>>>>>>//                Move 0     to LastErr
90901>>>>>>>//                If (bIsSqlTable = True) Begin
90901>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
90901>>>>>>>//                End
90901>>>>>>>//                Else Begin
90901>>>>>>>//                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
90901>>>>>>>//                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90901>>>>>>>//                End
90901>>>>>>>//                // If the array value is out of bounce it means that this column doesn't exist on the backend.
90901>>>>>>>//                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
90901>>>>>>>//                If (bExists = False) Begin
90901>>>>>>>//                    Move 0 to APIColumns[iCount].iType
90901>>>>>>>//                End
90901>>>>>>>//            End
90901>>>>>>>
90901>>>>>>>            If (bExists = True) Begin
90903>>>>>>>                Move iColumn to APIColumns[iCount].iFieldNumber
90904>>>>>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
90907>>>>>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
90907>>>>>>>//                If (bIsSqlTable = True) Begin
90907>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
90907>>>>>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90907>>>>>>>//                End
90907>>>>>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength 
90910>>>>>>>                If (APIColumns[iCount].iPrecision = 0) Begin
90912>>>>>>>                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90915>>>>>>>                End
90915>>>>>>>>
90915>>>>>>>
90915>>>>>>>                // If the length was zero we might have an Overlap(!) field.
90915>>>>>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
90915>>>>>>>                If (APIColumns[iCount].iLength = 0) Begin
90917>>>>>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
90920>>>>>>>                    If (iType = DF_OVERLAP) Begin
90922>>>>>>>                        Move 0 to APIColumns[iCount].iFieldNumber
90923>>>>>>>                        Move 0 to APIColumns[iCount].iLength
90924>>>>>>>                        Move 0 to APIColumns[iCount].iOptions
90925>>>>>>>                        Move 0 to APIColumns[iCount].iPrecision
90926>>>>>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
90927>>>>>>>                        Move "" to APIColumns[iCount].sFieldName
90928>>>>>>>                        Decrement iCount
90929>>>>>>>                    End
90929>>>>>>>>
90929>>>>>>>                End
90929>>>>>>>>
90929>>>>>>>            End
90929>>>>>>>>
90929>>>>>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
90930>>>>>>>            If (bUserCancel = True) Begin
90932>>>>>>>                Move True to APIColumnsEmpty[0].bCancel
90933>>>>>>>                Function_Return APIColumnsEmpty
90934>>>>>>>            End
90934>>>>>>>>
90934>>>>>>>            Increment iCount
90935>>>>>>>        Loop
90936>>>>>>>>
90936>>>>>>>
90936>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90937>>>>>>>        Function_Return APIColumns
90938>>>>>>>    End_Function
90939>>>>>>>     
90939>>>>>>>    // ToDo: Shouldn't this be the other way round? The From bit last? That is what should be of interest??
90939>>>>>>>    // *** 
90939>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO column arrays.
90939>>>>>>>    // The combined data will be sorted on the first struct member: iFieldNumber
90939>>>>>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
90941>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
90941>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
90942>>>>>>>        tAPIColumnCompare   APIColumnCompare
90942>>>>>>>        tAPIColumnCompare   APIColumnCompare
90942>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90942>>>>>>>
90942>>>>>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
90943>>>>>>>        Decrement iSizeFrom
90944>>>>>>>        for iCount from 0 to iSizeFrom
90950>>>>>>>>
90950>>>>>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
90951>>>>>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
90952>>>>>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
90953>>>>>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
90954>>>>>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
90955>>>>>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
90956>>>>>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
90957>>>>>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom
90958>>>>>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
90959>>>>>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
90960>>>>>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
90961>>>>>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
90962>>>>>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
90963>>>>>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
90964>>>>>>>        Loop
90965>>>>>>>>
90965>>>>>>>
90965>>>>>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
90966>>>>>>>        Decrement iSizeTo
90967>>>>>>>        for iCount from 0 to iSizeTo
90973>>>>>>>>
90973>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
90974>>>>>>>            // Search if the field number already exists in the "to" array; else add it. <
90974>>>>>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
90975>>>>>>>            If (iItem = -1) Begin
90977>>>>>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
90978>>>>>>>            End
90978>>>>>>>>
90978>>>>>>>
90978>>>>>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
90979>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
90980>>>>>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
90981>>>>>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
90982>>>>>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
90983>>>>>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
90984>>>>>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
90985>>>>>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
90986>>>>>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
90987>>>>>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
90988>>>>>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
90989>>>>>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
90990>>>>>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
90991>>>>>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
90992>>>>>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
90993>>>>>>>        Loop
90994>>>>>>>>
90994>>>>>>>
90994>>>>>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
90995>>>>>>>
90995>>>>>>>        Function_Return aAPIColumnCompare
90996>>>>>>>    End_Function
90997>>>>>>>
90997>>>>>>>    // Checks if a field name exists in a table definition
90997>>>>>>>    // Returns True if it does
90997>>>>>>>    // Sample:
90997>>>>>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
90997>>>>>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
90999>>>>>>>        Integer iNumColumns iColumn
90999>>>>>>>        String sColumn
90999>>>>>>>        Boolean bExists bOK bOpen
90999>>>>>>>
90999>>>>>>>        Get AutoConnectionIDLogin to bOK
91000>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91001>>>>>>>        Open hTable
91003>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91004>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91007>>>>>>>        If (bOpen = False) Begin
91009>>>>>>>            Function_Return False
91010>>>>>>>        End
91010>>>>>>>>
91010>>>>>>>
91010>>>>>>>        Move False to bExists
91011>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
91014>>>>>>>        for iColumn from 1 to iNumColumns
91020>>>>>>>>
91020>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
91023>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
91025>>>>>>>                Move iNumColumns to iColumn
91026>>>>>>>                Move True to bExists
91027>>>>>>>            End
91027>>>>>>>>
91027>>>>>>>        Loop
91028>>>>>>>>
91028>>>>>>>        Close hTable
91029>>>>>>>
91029>>>>>>>        Function_Return bExists
91030>>>>>>>    End_Function
91031>>>>>>>
91031>>>>>>>    // Returns the field/column number for the passed FieldName as an integer.
91031>>>>>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
91033>>>>>>>        Integer iNumColumns iColumn iRetval
91033>>>>>>>        String sColumn
91033>>>>>>>        Boolean bOK bOpen
91033>>>>>>>
91033>>>>>>>        Get AutoConnectionIDLogin to bOK
91034>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91035>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91036>>>>>>>        Open hTable
91038>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91039>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91042>>>>>>>        If (bOpen = False) Begin
91044>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
91045>>>>>>>            Function_Return False
91046>>>>>>>        End
91046>>>>>>>>
91046>>>>>>>
91046>>>>>>>        Move 0 to iColumn
91047>>>>>>>        Move 0 to iRetval
91048>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
91051>>>>>>>        for iColumn from 1 to iNumColumns
91057>>>>>>>>
91057>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
91060>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
91062>>>>>>>                Move iColumn to iRetval
91063>>>>>>>                Move iNumColumns to iColumn
91064>>>>>>>            End
91064>>>>>>>>
91064>>>>>>>        Loop
91065>>>>>>>>
91065>>>>>>>        Close hTable
91066>>>>>>>
91066>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91067>>>>>>>        Function_Return iRetval
91068>>>>>>>    End_Function
91069>>>>>>>
91069>>>>>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
91069>>>>>>>    // The reciprocal function is UtilColumnTypeToString.
91069>>>>>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
91071>>>>>>>        tColumnType RetvalType
91071>>>>>>>        tColumnType RetvalType
91071>>>>>>>
91071>>>>>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
91072>>>>>>>        Function_Return RetvalType.iSQLType
91073>>>>>>>    End_Function
91074>>>>>>>
91074>>>>>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
91074>>>>>>>    // The reciprocal function is UtilColumnTypeToString.
91074>>>>>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
91076>>>>>>>        tColumnType RetvalType
91076>>>>>>>        tColumnType RetvalType
91076>>>>>>>
91076>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91077>>>>>>>        Function_Return RetvalType.sSQLType
91078>>>>>>>    End_Function
91079>>>>>>>
91079>>>>>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
91081>>>>>>>        tColumnType RetvalType
91081>>>>>>>        tColumnType RetvalType
91081>>>>>>>
91081>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91082>>>>>>>        Function_Return RetvalType.sPrecision
91083>>>>>>>    End_Function
91084>>>>>>>
91084>>>>>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
91086>>>>>>>        tColumnType RetvalType
91086>>>>>>>        tColumnType RetvalType
91086>>>>>>>
91086>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91087>>>>>>>        // Nils 2019-02-15. This return value seems to have been wrong. The function should return False
91087>>>>>>>        // if the column type length is _not_ fixed.
91087>>>>>>>        Function_Return (RetvalType.bCanEditSize = False)
91088>>>>>>>    End_Function
91089>>>>>>>
91089>>>>>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
91091>>>>>>>        tColumnType RetvalType
91091>>>>>>>        tColumnType RetvalType
91091>>>>>>>        String sValue
91091>>>>>>>        Integer iRetval iPos
91091>>>>>>>
91091>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91092>>>>>>>        Move RetvalType.sPrecision to sValue
91093>>>>>>>        Move (Pos(".", sValue)) to iPos
91094>>>>>>>        If (iPos <> 0) Begin
91096>>>>>>>            Move (Left(sValue, (iPos -1))) to iRetval
91097>>>>>>>        End
91097>>>>>>>>
91097>>>>>>>        Else Begin
91098>>>>>>>            Move sValue to iRetval
91099>>>>>>>        End
91099>>>>>>>>
91099>>>>>>>        Function_Return iRetval
91100>>>>>>>    End_Function
91101>>>>>>>
91101>>>>>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
91103>>>>>>>        tColumnType RetvalType
91103>>>>>>>        tColumnType RetvalType
91103>>>>>>>        String sValue
91103>>>>>>>        Integer iRetval iPos
91103>>>>>>>
91103>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91104>>>>>>>        Move RetvalType.sPrecision to sValue
91105>>>>>>>        Move (Pos(".", sValue)) to iPos
91106>>>>>>>        If (iPos = 0) Begin
91108>>>>>>>            Function_Return 0
91109>>>>>>>        End
91109>>>>>>>>
91109>>>>>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
91110>>>>>>>
91110>>>>>>>        Function_Return iRetval
91111>>>>>>>    End_Function
91112>>>>>>>
91112>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91112>>>>>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
91114>>>>>>>        Function_Return False
91115>>>>>>>    End_Function
91116>>>>>>>
91116>>>>>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
91116>>>>>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
91118>>>>>>>        Boolean bIsSame
91118>>>>>>>        Integer iCount iSize
91118>>>>>>>
91118>>>>>>>        Move True to bIsSame
91119>>>>>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
91120>>>>>>>        Decrement iSize
91121>>>>>>>        For iCount from 0 to iSize
91127>>>>>>>>
91127>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91128>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
91129>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
91130>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
91131>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
91132>>>>>>>            If (bIsSame = False) Begin
91134>>>>>>>                Function_Return False
91135>>>>>>>            End
91135>>>>>>>>
91135>>>>>>>        Loop
91136>>>>>>>>
91136>>>>>>>
91136>>>>>>>        Function_Return bIsSame
91137>>>>>>>    End_Function
91138>>>>>>>
91138>>>>>>>    // Compares a single index for a 'FROM' and a 'TO' table.
91138>>>>>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
91140>>>>>>>        Boolean bIsSame
91140>>>>>>>        Integer iSegment
91140>>>>>>>
91140>>>>>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
91141>>>>>>>        If (bIsSame = False) Begin
91143>>>>>>>            Function_Return False
91144>>>>>>>        End
91144>>>>>>>>
91144>>>>>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
91145>>>>>>>        If (bIsSame = False) Begin
91147>>>>>>>            Function_Return False
91148>>>>>>>        End
91148>>>>>>>>
91148>>>>>>>
91148>>>>>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
91150>>>>>>>            // * We should probably not compare SQL index names?
91150>>>>>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
91150>>>>>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
91150>>>>>>>            //     Function_Return False
91150>>>>>>>            // End
91150>>>>>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
91151>>>>>>>            If (bIsSame = False) Begin
91153>>>>>>>                Function_Return False
91154>>>>>>>            End
91154>>>>>>>>
91154>>>>>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
91155>>>>>>>            If (bIsSame = False) Begin
91157>>>>>>>                Function_Return False
91158>>>>>>>            End
91158>>>>>>>>
91158>>>>>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
91159>>>>>>>            If (bIsSame = False) Begin
91161>>>>>>>                Function_Return False
91162>>>>>>>            End
91162>>>>>>>>
91162>>>>>>>            Move (Uppercase(APIIndexCompare.sSQLIndexNameFrom) = Uppercase(APIIndexCompare.sSQLIndexNameTo)) to bIsSame
91163>>>>>>>            If (bIsSame = False) Begin
91165>>>>>>>                Function_Return False
91166>>>>>>>            End
91166>>>>>>>>
91166>>>>>>>        End
91166>>>>>>>>
91166>>>>>>>
91166>>>>>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
91167>>>>>>>        Move (iSegment = -1) to bIsSame
91168>>>>>>>
91168>>>>>>>        Function_Return (bIsSame = True)
91169>>>>>>>    End_Function
91170>>>>>>>
91170>>>>>>>    // Compares each segment for the passed index.
91170>>>>>>>    // Returns -1 if same; else returns the index segment that differs.
91170>>>>>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
91172>>>>>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
91172>>>>>>>        Boolean bIsSame
91172>>>>>>>
91172>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
91173>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91174>>>>>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
91175>>>>>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
91176>>>>>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
91177>>>>>>>
91177>>>>>>>        Decrement iNumSegments
91178>>>>>>>        for iSegment from 0 to iNumSegments
91184>>>>>>>>
91184>>>>>>>            Move False to bIsSame
91185>>>>>>>            If (iSegment < iNumSegmentsFrom and iSegment < iNumSegmentsTo) Begin
91187>>>>>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
91188>>>>>>>            End
91188>>>>>>>>
91188>>>>>>>            If (bIsSame = False) Begin
91190>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
91191>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91192>>>>>>>                Function_Return iSegment
91193>>>>>>>            End
91193>>>>>>>>
91193>>>>>>>        Loop
91194>>>>>>>>
91194>>>>>>>
91194>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91195>>>>>>>        Function_Return -1 // This means bIsSame = True
91196>>>>>>>    End_Function
91197>>>>>>>
91197>>>>>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
91199>>>>>>>        Boolean bIsSame
91199>>>>>>>
91199>>>>>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
91200>>>>>>>        If (bIsSame = False) Begin
91202>>>>>>>            Function_Return False
91203>>>>>>>        End
91203>>>>>>>>
91203>>>>>>>        If (bCompareIndexUppercase = True) Begin
91205>>>>>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
91206>>>>>>>            If (bIsSame = False) Begin
91208>>>>>>>                Function_Return False
91209>>>>>>>            End
91209>>>>>>>>
91209>>>>>>>        End
91209>>>>>>>>
91209>>>>>>>        If (bCompareIndexAscending = True) Begin
91211>>>>>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
91212>>>>>>>            If (bIsSame = False) Begin
91214>>>>>>>                Function_Return False
91215>>>>>>>            End
91215>>>>>>>>
91215>>>>>>>        End
91215>>>>>>>>
91215>>>>>>>
91215>>>>>>>        Function_Return True
91216>>>>>>>    End_Function
91217>>>>>>>
91217>>>>>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
91219>>>>>>>        Boolean bIsSame bOK
91219>>>>>>>        Integer iSize iSizeTo iCount
91219>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
91219>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
91220>>>>>>>
91220>>>>>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
91221>>>>>>>        If (iSize = 0) Begin
91223>>>>>>>            Function_Return True
91224>>>>>>>        End
91224>>>>>>>>
91224>>>>>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo
91225>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
91226>>>>>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
91227>>>>>>>
91227>>>>>>>        for iCount from 0 to (iSize - 1)
91233>>>>>>>>
91233>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
91234>>>>>>>            If (bIsSame = False) Begin
91236>>>>>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
91237>>>>>>>            End
91237>>>>>>>>
91237>>>>>>>        Loop
91238>>>>>>>>
91238>>>>>>>
91238>>>>>>>        // We probably should delete other indexes if they exists.
91238>>>>>>>        for iCount from (iSize +1) to iSizeTo
91244>>>>>>>>
91244>>>>>>>            Get ApiIndexRemove hTable iCount to bOK
91245>>>>>>>        Loop
91246>>>>>>>>
91246>>>>>>>
91246>>>>>>>        Function_Return bOK
91247>>>>>>>    End_Function
91248>>>>>>>
91248>>>>>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
91250>>>>>>>        tAPIIndex[] APIIndexes
91250>>>>>>>        tAPIIndex[] APIIndexes
91251>>>>>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
91251>>>>>>>        String sDriverID
91251>>>>>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable
91251>>>>>>>
91251>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91252>>>>>>>        Get psDriverID to sDriverID
91253>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
91254>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
91255>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91258>>>>>>>        If (bIsOpen = False) Begin
91260>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91261>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91262>>>>>>>            Open hTable
91264>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
91265>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91266>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91269>>>>>>>            If (bIsOpen = False) Begin
91271>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91272>>>>>>>                Move True to APIIndexes[0].bError
91273>>>>>>>                Function_Return APIIndexes
91274>>>>>>>            End
91274>>>>>>>>
91274>>>>>>>        End
91274>>>>>>>>
91274>>>>>>>
91274>>>>>>>        Move 0 to iCount
91275>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
91278>>>>>>>        for iIndex from 1 to iIndexes
91284>>>>>>>>
91284>>>>>>>            // This is a test that the index exists as there might be "holes" aka the index
91284>>>>>>>            // numbers doesn't not need to be consequitive:
91284>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
91287>>>>>>>            If (iNumSegments > 0) Begin
91289>>>>>>>
91289>>>>>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
91290>>>>>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
91293>>>>>>>                If (bIsSQLTable = True) Begin
91295>>>>>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
91298>>>>>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
91301>>>>>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
91304>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
91307>>>>>>>                End
91307>>>>>>>>
91307>>>>>>>
91307>>>>>>>                Move 0 to iSegmentCount
91308>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
91311>>>>>>>                For iSegment from 1 to iNumSegments
91317>>>>>>>>
91317>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
91320>>>>>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
91321>>>>>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
91324>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
91327>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
91330>>>>>>>                    Increment iSegmentCount
91331>>>>>>>                Loop
91332>>>>>>>>
91332>>>>>>>                Increment iCount
91333>>>>>>>            End
91333>>>>>>>>
91333>>>>>>>        Loop
91334>>>>>>>>
91334>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91335>>>>>>>
91335>>>>>>>        Function_Return APIIndexes
91336>>>>>>>    End_Function
91337>>>>>>>
91337>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
91337>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
91337>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
91337>>>>>>>    // have "holes" in the series of index numbers.
91337>>>>>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
91339>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
91339>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
91340>>>>>>>        tAPIIndexCompare   APIIndexCompare
91340>>>>>>>        tAPIIndexCompare   APIIndexCompare
91340>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
91340>>>>>>>
91340>>>>>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
91341>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
91342>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
91344>>>>>>>            Function_Return aAPIIndexCompare
91345>>>>>>>        End
91345>>>>>>>>
91345>>>>>>>
91345>>>>>>>        Decrement iSizeFrom
91346>>>>>>>        for iCount from 0 to iSizeFrom
91352>>>>>>>>
91352>>>>>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
91353>>>>>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
91354>>>>>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
91355>>>>>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
91356>>>>>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
91357>>>>>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
91358>>>>>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
91359>>>>>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
91360>>>>>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
91361>>>>>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
91362>>>>>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
91363>>>>>>>        Loop
91364>>>>>>>>
91364>>>>>>>
91364>>>>>>>        Decrement iSizeTo
91365>>>>>>>        for iCount from 0 to iSizeTo
91371>>>>>>>>
91371>>>>>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
91372>>>>>>>            // Search if the Index number already exists in the array; else add it.
91372>>>>>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
91373>>>>>>>            If (iItem = -1) Begin
91375>>>>>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
91376>>>>>>>            End
91376>>>>>>>>
91376>>>>>>>
91376>>>>>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
91377>>>>>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
91378>>>>>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
91379>>>>>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
91380>>>>>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
91381>>>>>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
91382>>>>>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
91383>>>>>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
91384>>>>>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
91385>>>>>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
91386>>>>>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
91387>>>>>>>        Loop
91388>>>>>>>>
91388>>>>>>>
91388>>>>>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
91389>>>>>>>
91389>>>>>>>        Function_Return aAPIIndexCompare
91390>>>>>>>    End_Function
91391>>>>>>>
91391>>>>>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
91391>>>>>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
91393>>>>>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
91393>>>>>>>        String sDriverID
91393>>>>>>>
91393>>>>>>>        Get psDriverID to sDriverID
91394>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
91395>>>>>>>        Get IsSQLDriver sDriverID to bIsSqlTable
91396>>>>>>>        If (bIsSqlTable = True) Begin
91398>>>>>>>            Get _UtilTableIsSql hTable to bIsSqlTable
91399>>>>>>>        End
91399>>>>>>>>
91399>>>>>>>
91399>>>>>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
91400>>>>>>>        If (bIsSame = False) Begin
91402>>>>>>>            Function_Return False
91403>>>>>>>        End
91403>>>>>>>>
91403>>>>>>>
91403>>>>>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
91405>>>>>>>            // Don't think we should do this. Or should we?
91405>>>>>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
91405>>>>>>>
91405>>>>>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
91406>>>>>>>            If (bIsSame = False) Begin
91408>>>>>>>                Function_Return False
91409>>>>>>>            End
91409>>>>>>>>
91409>>>>>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
91410>>>>>>>            If (bIsSame = False) Begin
91412>>>>>>>                Function_Return False
91413>>>>>>>            End
91413>>>>>>>>
91413>>>>>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
91414>>>>>>>            If (bIsSame = False) Begin
91416>>>>>>>                Function_Return False
91417>>>>>>>            End
91417>>>>>>>>
91417>>>>>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
91418>>>>>>>            If (bIsSame = False) Begin
91420>>>>>>>                Function_Return False
91421>>>>>>>            End
91421>>>>>>>>
91421>>>>>>>        End
91421>>>>>>>>
91421>>>>>>>
91421>>>>>>>        Function_Return bIsSame
91422>>>>>>>    End_Function
91423>>>>>>>
91423>>>>>>>    // DF_INDEX_SQL_TYPE values
91423>>>>>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
91423>>>>>>>    // returns a string with the name.
91423>>>>>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
91425>>>>>>>        String sRetval
91425>>>>>>>            Case Begin
91425>>>>>>>                Case (iIndexType = DF_INDEX_CLIENT)
91427>>>>>>>                    Move "DF_INDEX_CLIENT" to sRetval
91428>>>>>>>                    Case Break
91429>>>>>>>                Case (iIndexType = DF_INDEX_SERVER)
91432>>>>>>>                    Move "DF_INDEX_SERVER" to sRetval
91433>>>>>>>                    Case Break
91434>>>>>>>                Case (iIndexType = DF_INDEX_SERVER_ONLY)
91437>>>>>>>                    Move "DF_INDEX_SERVER_ONLY" to sRetval
91438>>>>>>>                    Case Break
91439>>>>>>>                Case (iIndexType = DF_INDEX_TEMPORARY)
91442>>>>>>>                    Move "DF_INDEX_TEMPORARY" to sRetval
91443>>>>>>>                    Case Break
91444>>>>>>>                Case Else
91444>>>>>>>                    Move "UNKNOWN INDEX TYPE" to sRetval
91445>>>>>>>            Case End
91445>>>>>>>        Function_Return sRetval
91446>>>>>>>    End_Function
91447>>>>>>>
91447>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91447>>>>>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
91449>>>>>>>        Function_Return False
91450>>>>>>>    End_Function
91451>>>>>>>
91451>>>>>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
91451>>>>>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
91453>>>>>>>        Boolean bIsSame
91453>>>>>>>        Integer iSize iCount
91453>>>>>>>
91453>>>>>>>        Move True to bIsSame
91454>>>>>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
91455>>>>>>>        Decrement iSize
91456>>>>>>>        For iCount from 0 to iSize
91462>>>>>>>>
91462>>>>>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
91463>>>>>>>            If (bIsSame = False) Begin
91465>>>>>>>                Function_Return False
91466>>>>>>>            End
91466>>>>>>>>
91466>>>>>>>        Loop
91467>>>>>>>>
91467>>>>>>>
91467>>>>>>>        Function_Return bIsSame
91468>>>>>>>    End_Function
91469>>>>>>>
91469>>>>>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
91469>>>>>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
91471>>>>>>>        Boolean bIsSame
91471>>>>>>>
91471>>>>>>>        Move True to bIsSame
91472>>>>>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
91474>>>>>>>            Function_Return False
91475>>>>>>>        End
91475>>>>>>>>
91475>>>>>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
91477>>>>>>>            Function_Return False
91478>>>>>>>        End
91478>>>>>>>>
91478>>>>>>>
91478>>>>>>>        // We could also compare field names, but I don't think that is necessary...
91478>>>>>>>
91478>>>>>>>        Function_Return bIsSame
91479>>>>>>>    End_Function
91480>>>>>>>
91480>>>>>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
91480>>>>>>>    // already exists.
91480>>>>>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
91482>>>>>>>        Boolean bOK
91482>>>>>>>        Integer iSizeTo iSize iCount iColumn
91482>>>>>>>        String sDriverID
91482>>>>>>>
91482>>>>>>>        Move True to bOK
91483>>>>>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
91484>>>>>>>        If (iSizeTo > 0) Begin
91486>>>>>>>            Get AutoConnectionIDLogin to bOK
91487>>>>>>>            Move False to Err
91488>>>>>>>            Open hTable Mode DF_EXCLUSIVE
91490>>>>>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
91493>>>>>>>            Decrement iSizeTo
91494>>>>>>>
91494>>>>>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
91494>>>>>>>            // for the "TO" database. But start by deleting all current "TO" relations:
91494>>>>>>>            Structure_Start hTable sDriverID
91495>>>>>>>                for iCount from 0 to iSizeTo
91501>>>>>>>>
91501>>>>>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
91502>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
91505>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
91508>>>>>>>                Loop
91509>>>>>>>>
91509>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
91510>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91512>>>>>>>            Set Action_Text of ghoStatusPanel to ""
91513>>>>>>>        End
91513>>>>>>>>
91513>>>>>>>
91513>>>>>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
91514>>>>>>>        Decrement iSize
91515>>>>>>>        for iCount from 0 to iSize
91521>>>>>>>>
91521>>>>>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
91522>>>>>>>        Loop
91523>>>>>>>>
91523>>>>>>>
91523>>>>>>>        Function_Return bOK
91524>>>>>>>    End_Function
91525>>>>>>>
91525>>>>>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
91527>>>>>>>        tAPIRelation[] APIRelations
91527>>>>>>>        tAPIRelation[] APIRelations
91528>>>>>>>        Integer iColumn iColumnTo iNumColumns iCount
91528>>>>>>>        Handle hParent
91528>>>>>>>        Boolean bIsOpen
91528>>>>>>>
91528>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91529>>>>>>>        Move 0 to iCount
91530>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91533>>>>>>>        If (bIsOpen = False) Begin
91535>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91536>>>>>>>            Open hTable
91538>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91539>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91542>>>>>>>            If (bIsOpen = False) Begin
91544>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91545>>>>>>>                Move True to APIRelations[0].bError
91546>>>>>>>                Function_Return APIRelations
91547>>>>>>>            End
91547>>>>>>>>
91547>>>>>>>        End
91547>>>>>>>>
91547>>>>>>>
91547>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
91550>>>>>>>        For iColumn from 1 to iNumColumns
91556>>>>>>>>
91556>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
91559>>>>>>>            If (hParent <> 0) Begin
91561>>>>>>>                Open hParent
91563>>>>>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
91564>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
91567>>>>>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
91568>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
91571>>>>>>>
91571>>>>>>>                Move hParent                                            to APIRelations[iCount].hTableTo
91572>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
91575>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
91578>>>>>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
91579>>>>>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
91582>>>>>>>                Move False                                              to APIRelations[iCount].bShouldChange
91583>>>>>>>                Move False                                              to APIRelations[iCount].bCancel
91584>>>>>>>                Move False                                              to APIRelations[iCount].bError
91585>>>>>>>                Close hParent
91586>>>>>>>                Increment iCount
91587>>>>>>>            End
91587>>>>>>>>
91587>>>>>>>        Loop
91588>>>>>>>>
91588>>>>>>>
91588>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91589>>>>>>>        Function_Return APIRelations
91590>>>>>>>    End_Function
91591>>>>>>>
91591>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO relation arrays.
91591>>>>>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
91591>>>>>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
91593>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
91593>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
91594>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
91594>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
91595>>>>>>>        tAPIRelationCompare   APIRelationCompare
91595>>>>>>>        tAPIRelationCompare   APIRelationCompare
91595>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
91595>>>>>>>
91595>>>>>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
91596>>>>>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
91597>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
91599>>>>>>>            Function_Return aAPIRelationCompare
91600>>>>>>>        End
91600>>>>>>>>
91600>>>>>>>
91600>>>>>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
91601>>>>>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(__UtilRelationArrayCompare))) to aAPIRelationFromAndTo
91602>>>>>>>
91602>>>>>>>        Decrement iSizeFrom
91603>>>>>>>        for iCount from 0 to iSizeFrom
91609>>>>>>>>
91609>>>>>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
91610>>>>>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
91611>>>>>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
91612>>>>>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
91613>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
91614>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
91615>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
91616>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
91617>>>>>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
91618>>>>>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
91619>>>>>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
91620>>>>>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
91621>>>>>>>        Loop
91622>>>>>>>>
91622>>>>>>>
91622>>>>>>>        Decrement iSizeTo
91623>>>>>>>        for iCount from 0 to iSizeTo
91629>>>>>>>>
91629>>>>>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
91630>>>>>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
91631>>>>>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
91632>>>>>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
91633>>>>>>>
91633>>>>>>>            // Search if the relation already exists in the array; else add it.
91633>>>>>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to iItem
91634>>>>>>>            If (iItem = -1) Begin
91636>>>>>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
91637>>>>>>>            End
91637>>>>>>>>
91637>>>>>>>
91637>>>>>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
91638>>>>>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
91639>>>>>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
91640>>>>>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
91641>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
91642>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
91643>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
91644>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
91645>>>>>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
91646>>>>>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
91647>>>>>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
91648>>>>>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
91649>>>>>>>        Loop
91650>>>>>>>>
91650>>>>>>>
91650>>>>>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to aAPIRelationCompare
91651>>>>>>>
91651>>>>>>>        Function_Return aAPIRelationCompare
91652>>>>>>>    End_Function
91653>>>>>>>
91653>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91653>>>>>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
91655>>>>>>>        Function_Return False
91656>>>>>>>    End_Function
91657>>>>>>>
91657>>>>>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
91657>>>>>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
91657>>>>>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
91657>>>>>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
91659>>>>>>>        Boolean bFound
91659>>>>>>>
91659>>>>>>>        Move False to Err
91660>>>>>>>        Open CodeMast
91662>>>>>>>        Open CodeType
91664>>>>>>>
91664>>>>>>>        If (bCodeType = True) Begin
91666>>>>>>>            Set Private.phCurrentTable to CODETYPE.File_Number
91667>>>>>>>            Clear CodeType
91668>>>>>>>            Move sTypeValue to CODETYPE.Type
91669>>>>>>>            Find eq CODETYPE by 1
91670>>>>>>>>
91670>>>>>>>            Move Found to bFound
91671>>>>>>>            If (bFound = True) Begin
91673>>>>>>>                Reread CodeType
91677>>>>>>>            End
91677>>>>>>>>
91677>>>>>>>            Else Begin
91678>>>>>>>                Clear CodeType
91679>>>>>>>            End
91679>>>>>>>>
91679>>>>>>>
91679>>>>>>>            Move sTypeValue to CODETYPE.Type
91680>>>>>>>            Move sValue2    to CODETYPE.Description
91681>>>>>>>            Move sValue3    to CODETYPE.Comment
91682>>>>>>>            SaveRecord CODETYPE
91683>>>>>>>
91683>>>>>>>            If (bFound = True) Begin
91685>>>>>>>                Unlock
91686>>>>>>>>
91686>>>>>>>            End
91686>>>>>>>>
91686>>>>>>>        End
91686>>>>>>>>
91686>>>>>>>
91686>>>>>>>        If (bCodeType = False) Begin
91688>>>>>>>            Set Private.phCurrentTable to CODEMAST.File_Number
91689>>>>>>>            Clear CODEMAST
91690>>>>>>>            Move sTypeValue to CODEMAST.Type
91691>>>>>>>            Move sValue2    to CODEMAST.Code
91692>>>>>>>            Find eq CODEMAST by 1
91693>>>>>>>>
91693>>>>>>>            Move Found to bFound
91694>>>>>>>            If (bFound = True) Begin
91696>>>>>>>                Reread CODEMAST
91700>>>>>>>            End
91700>>>>>>>>
91700>>>>>>>            Else Begin
91701>>>>>>>                Clear CODEMAST
91702>>>>>>>            End
91702>>>>>>>>
91702>>>>>>>
91702>>>>>>>            Move sTypeValue to CODEMAST.Type
91703>>>>>>>            Move sValue2    to CODEMAST.Code
91704>>>>>>>            Move sValue3    to CODEMAST.Description
91705>>>>>>>            SaveRecord CODEMAST
91706>>>>>>>
91706>>>>>>>            If (bFound = True) Begin
91708>>>>>>>                Unlock
91709>>>>>>>>
91709>>>>>>>            End
91709>>>>>>>>
91709>>>>>>>        End
91709>>>>>>>>
91709>>>>>>>
91709>>>>>>>        Close CodeMast
91710>>>>>>>        Close CodeType
91711>>>>>>>
91711>>>>>>>        Function_Return (Err = False)
91712>>>>>>>    End_Function
91713>>>>>>>
91713>>>>>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
91713>>>>>>>    // CodeType and then spins through all CodeMast records to change all related records.
91713>>>>>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
91715>>>>>>>        Boolean bFound
91715>>>>>>>
91715>>>>>>>        Move False to Err
91716>>>>>>>        Open CodeMast
91718>>>>>>>        Open CodeType
91720>>>>>>>
91720>>>>>>>        Clear CodeType
91721>>>>>>>        Move sFromValue to CODETYPE.Type
91722>>>>>>>        Find eq CODETYPE.Type
91723>>>>>>>>
91723>>>>>>>        If (Found = True) Begin
91725>>>>>>>            Reread CODETYPE
91729>>>>>>>                Move sToValue to CODETYPE.Type
91730>>>>>>>                SaveRecord CODETYPE
91731>>>>>>>            Unlock
91732>>>>>>>>
91732>>>>>>>        End
91732>>>>>>>>
91732>>>>>>>
91732>>>>>>>        Clear CODEMAST
91733>>>>>>>        Find gt CODEMAST by Recnum
91734>>>>>>>>
91734>>>>>>>        While (Found = True)
91738>>>>>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
91739>>>>>>>            If (bFound = True) Begin
91741>>>>>>>                Reread CODEMAST
91745>>>>>>>                    Move sToValue to CODEMAST.Type
91746>>>>>>>                    SaveRecord CODEMAST
91747>>>>>>>                Unlock
91748>>>>>>>>
91748>>>>>>>            End
91748>>>>>>>>
91748>>>>>>>            Find gt CODEMAST by Recnum
91749>>>>>>>>
91749>>>>>>>        Loop
91750>>>>>>>>
91750>>>>>>>
91750>>>>>>>        Close CodeMast
91751>>>>>>>        Close CodeType
91752>>>>>>>
91752>>>>>>>        Function_Return (Err = False)
91753>>>>>>>    End_Function
91754>>>>>>>
91754>>>>>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
91754>>>>>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
91756>>>>>>>        Boolean bFound
91756>>>>>>>
91756>>>>>>>        Move False to Err
91757>>>>>>>        Open CodeMast
91759>>>>>>>
91759>>>>>>>        Clear CODEMAST
91760>>>>>>>        Move sTypeValue to CODEMAST.Type
91761>>>>>>>        Move sValue2    to CODEMAST.Code
91762>>>>>>>        Find eq CODEMAST.Code
91763>>>>>>>>
91763>>>>>>>        Move Found to bFound
91764>>>>>>>        If (bFound = True) Begin
91766>>>>>>>            Delete CODEMAST
91767>>>>>>>        End
91767>>>>>>>>
91767>>>>>>>
91767>>>>>>>        Close CodeMast
91768>>>>>>>
91768>>>>>>>        Function_Return (Err = False)
91769>>>>>>>    End_Function
91770>>>>>>>
91770>>>>>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
91772>>>>>>>        Boolean bRecnum bToAnsi
91772>>>>>>>        Integer iCh
91772>>>>>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
91772>>>>>>>
91772>>>>>>>        If (Trim(sDataPath) = "") Begin
91774>>>>>>>            Function_Return False
91775>>>>>>>        End
91775>>>>>>>>
91775>>>>>>>
91775>>>>>>>        Move False to Err
91776>>>>>>>        Get psDriverID     to sDriverID
91777>>>>>>>        Get psConnectionID to sConnectionID
91778>>>>>>>        Get psSchema       to sSchemaName
91779>>>>>>>        Get True           to bRecnum
91780>>>>>>>        Get pbToANSI       to bToAnsi
91781>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
91782>>>>>>>        If (bToAnsi = False) Begin
91784>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
91785>>>>>>>        End
91785>>>>>>>>
91785>>>>>>>
91785>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91786>>>>>>>        Move "CodeMast.int"         to sFileName
91787>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91788>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91791>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91794>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
91797>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91800>>>>>>>            Writeln channel iCh ("")
91803>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91806>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91809>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91812>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91815>>>>>>>            Writeln channel iCh ("")
91818>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91821>>>>>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
91824>>>>>>>            Writeln channel iCh ("")
91827>>>>>>>        Send Seq_Close_Channel iCh
91828>>>>>>>
91828>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91829>>>>>>>        Move "CodeType.int"         to sFileName
91830>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91831>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91834>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91837>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
91840>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91843>>>>>>>            Writeln channel iCh ("")
91846>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91849>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91852>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91855>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91858>>>>>>>            Writeln channel iCh ("")
91861>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 0")
91864>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
91867>>>>>>>            Writeln channel iCh ("")
91870>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91873>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
91876>>>>>>>            Writeln channel iCh ("")
91879>>>>>>>        Send Seq_Close_Channel iCh
91880>>>>>>>
91880>>>>>>>        Function_Return (Err = False)
91881>>>>>>>    End_Function
91882>>>>>>>
91882>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91882>>>>>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
91884>>>>>>>        Function_Return False
91885>>>>>>>    End_Function
91886>>>>>>>
91886>>>>>>>    // Use function to move *.fd, termlist.*, collate.*, dfcollate.* files to a "Data\Backup" folder,
91886>>>>>>>    // and to remove all *.cch files (DAW SQL driver cache files. They will get recreated when needed.)
91886>>>>>>>    Function UtilMoveMiscFilesToBackupFolder Returns Boolean
91888>>>>>>>        Boolean bOK bExists
91888>>>>>>>        String sDataPath sBackupFolder
91888>>>>>>>
91888>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving misc. files to Backup folder."
91889>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
91890>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
91891>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91892>>>>>>>
91892>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91893>>>>>>>        If (bExists = False) Begin
91895>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
91896>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91897>>>>>>>            If (bExists = False) Begin
91899>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all misc. files to. You need to move them somewhere manually.")
91900>>>>>>>>
91900>>>>>>>                Function_Return False
91901>>>>>>>            End
91901>>>>>>>>
91901>>>>>>>            Get vMoveFile (sDataPath + "*.fd")         (sDataPath + sBackupFolder) to bOK  
91902>>>>>>>            Get vMoveFile (sDataPath + "*.bad")        (sDataPath + sBackupFolder) to bOK  
91903>>>>>>>            Get vMoveFile (sDataPath + "*.err")        (sDataPath + sBackupFolder) to bOK  
91904>>>>>>>            Get vMoveFile (sDataPath + "*.bak")        (sDataPath + sBackupFolder) to bOK
91905>>>>>>>            Get vMoveFile (sDataPath + "*.def")        (sDataPath + sBackupFolder) to bOK
91906>>>>>>>            Get vMoveFile (sDataPath + "*.fil")        (sDataPath + sBackupFolder) to bOK
91907>>>>>>>            Get vMoveFile (sDataPath + "*.hlp")        (sDataPath + sBackupFolder) to bOK
91908>>>>>>>            Get vMoveFile (sDataPath + "*.old")        (sDataPath + sBackupFolder) to bOK           
91909>>>>>>>            Get vMoveFile (sDataPath + "*.prn")        (sDataPath + sBackupFolder) to bOK           
91910>>>>>>>            Get vMoveFile (sDataPath + "*.sts")        (sDataPath + sBackupFolder) to bOK           
91911>>>>>>>            Get vMoveFile (sDataPath + "*.td")         (sDataPath + sBackupFolder) to bOK           
91912>>>>>>>            Get vMoveFile (sDataPath + "*.log")        (sDataPath + sBackupFolder) to bOK           
91913>>>>>>>            Get vMoveFile (sDataPath + "*.bat")        (sDataPath + sBackupFolder) to bOK           
91914>>>>>>>            Get vMoveFile (sDataPath + "*.cmd")        (sDataPath + sBackupFolder) to bOK           
91915>>>>>>>            Get vMoveFile (sDataPath + "*.zip")        (sDataPath + sBackupFolder) to bOK           
91916>>>>>>>            Get vMoveFile (sDataPath + "*.abs")        (sDataPath + sBackupFolder) to bOK           
91917>>>>>>>            Get vMoveFile (sDataPath + "termlist.*")   (sDataPath + sBackupFolder) to bOK
91918>>>>>>>            Get vMoveFile (sDataPath + "*.dfr")        (sDataPath + sBackupFolder) to bOK
91919>>>>>>>            Get vMoveFile (sDataPath + "vsutil.cfg")   (sDataPath + sBackupFolder) to bOK
91920>>>>>>>            Get vMoveFile (sDataPath + "collate.*")    (sDataPath + sBackupFolder) to bOK
91921>>>>>>>            Get vMoveFile (sDataPath + "df_collate.*") (sDataPath + sBackupFolder) to bOK
91922>>>>>>>            Get vDeleteFile (sDataPath + "*.cch")                                  to bOK
91923>>>>>>>        End
91923>>>>>>>>
91923>>>>>>>
91923>>>>>>>        Set Message_Text of ghoStatusPanel to ""
91924>>>>>>>        Function_Return True
91925>>>>>>>    End_Function
91926>>>>>>>    
91926>>>>>>>    // Check if the file exists in the Data folder,
91926>>>>>>>    // else creates it from memory as it has been compiled into the program as a resource:
91926>>>>>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
91928>>>>>>>        String sPath
91928>>>>>>>        Boolean bExists
91928>>>>>>>
91928>>>>>>>        Get psDataPathFirstPart to sPath
91929>>>>>>>        Move (sPath + sFileName) to sFileName
91930>>>>>>>        Get vFilePathExists sFileName to bExists
91931>>>>>>>
91931>>>>>>>        If (bExists = False) Begin
91933>>>>>>>            // Read from memory & create file on disk.
91933>>>>>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
91934>>>>>>>            Get vFilePathExists sFileName to bExists
91935>>>>>>>        End
91935>>>>>>>>
91935>>>>>>>        Function_Return bExists
91936>>>>>>>    End_Function
91937>>>>>>>
91937>>>>>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
91939>>>>>>>        tColumnType RetvalType
91939>>>>>>>        tColumnType RetvalType
91939>>>>>>>        Integer iRetval
91939>>>>>>>
91939>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91940>>>>>>>        Move RetvalType.iDataFlexType to iRetval
91941>>>>>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
91943>>>>>>>            If (iLength <= 255) Begin
91945>>>>>>>                Move DF_ASCII to iRetval
91946>>>>>>>            End
91946>>>>>>>>
91946>>>>>>>        End
91946>>>>>>>>
91946>>>>>>>        Function_Return iRetval
91947>>>>>>>    End_Function
91948>>>>>>>
91948>>>>>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
91950>>>>>>>        String sRetval
91950>>>>>>>
91950>>>>>>>        Case Begin
91950>>>>>>>            Case (iDataType = DF_ASCII)
91952>>>>>>>                Move "DF_ASCII" to sRetval
91953>>>>>>>                Case Break
91954>>>>>>>            Case (iDataType = DF_BCD)
91957>>>>>>>                Move "DF_BCD" to sRetval
91958>>>>>>>                Case Break
91959>>>>>>>            Case (iDataType = DF_BINARY)
91962>>>>>>>                Move "DF_BINARY" to sRetval
91963>>>>>>>                Case Break
91964>>>>>>>            Case (iDataType = DF_DATE)
91967>>>>>>>                Move "DF_DATE" to sRetval
91968>>>>>>>                Case Break
91969>>>>>>>            Case (iDataType = DF_DATETIME)
91972>>>>>>>                Move "DF_DATETIME" to sRetval
91973>>>>>>>                Case Break
91974>>>>>>>            Case (iDataType = DF_TEXT)
91977>>>>>>>                Move "DF_TEXT" to sRetval
91978>>>>>>>                Case Break
91979>>>>>>>            Case Else
91979>>>>>>>                Move "" to sRetval
91980>>>>>>>        Case End
91980>>>>>>>
91980>>>>>>>        Function_Return sRetval
91981>>>>>>>    End_Function
91982>>>>>>>
91982>>>>>>>    // The default value used for a datatype as specified in the driver int file.
91982>>>>>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
91984>>>>>>>        String sRetval sServer
91984>>>>>>>        tColumnType RetvalType
91984>>>>>>>        tColumnType RetvalType
91984>>>>>>>        Integer iDriver iDataFlexType
91984>>>>>>>        Handle hDatabase
91984>>>>>>>
91984>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91985>>>>>>>        Move RetvalType.iDataFlexType to iDataFlexType
91986>>>>>>>        Get DriverIndex sDriverID to iDriver
91987>>>>>>>        Get psServer to sServer
91988>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91989>>>>>>>        If (hDatabase = 0) Begin
91991>>>>>>>            Function_Return ""
91992>>>>>>>        End
91992>>>>>>>>
91992>>>>>>>
91992>>>>>>>        Case Begin
91992>>>>>>>            Case (iDataFlexType = DF_ASCII)
91994>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
91997>>>>>>>                Case Break
91998>>>>>>>            Case (iDataFlexType = DF_BCD)
92001>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
92004>>>>>>>                Case Break
92005>>>>>>>            Case (iDataFlexType = DF_BINARY)
92008>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
92011>>>>>>>                Case Break
92012>>>>>>>            Case (iDataFlexType = DF_DATE)
92015>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
92018>>>>>>>                Case Break
92019>>>>>>>            Case (iDataFlexType = DF_DATETIME)
92022>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
92025>>>>>>>                Case Break
92026>>>>>>>            Case (iDataFlexType = DF_TEXT)
92029>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
92032>>>>>>>                Case Break
92033>>>>>>>            Case Else
92033>>>>>>>                Move "" to sRetval
92034>>>>>>>        Case End
92034>>>>>>>
92034>>>>>>>        Function_Return sRetval
92035>>>>>>>    End_Function
92036>>>>>>>
92036>>>>>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
92038>>>>>>>        String sDriverID sServer
92038>>>>>>>        tColumnType RetvalType
92038>>>>>>>        tColumnType RetvalType
92038>>>>>>>        Integer iDbType iDriver
92038>>>>>>>        Handle hDatabase
92038>>>>>>>
92038>>>>>>>        Get psDriverID to sDriverID
92039>>>>>>>        Get piDbType   to iDbType
92040>>>>>>>        Get DriverIndex sDriverID to iDriver
92041>>>>>>>        Get psServer to sServer
92042>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
92043>>>>>>>        If (hDatabase = 0) Begin
92045>>>>>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database. (Check that at least one connection is 'Enabled')"
92046>>>>>>>>
92046>>>>>>>            Procedure_Return
92047>>>>>>>        End
92047>>>>>>>>
92047>>>>>>>
92047>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
92050>>>>>>>
92050>>>>>>>    End_Procedure
92051>>>>>>>
92051>>>>>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
92053>>>>>>>        String sDriverID sServer
92053>>>>>>>        tColumnType RetvalType
92053>>>>>>>        tColumnType RetvalType
92053>>>>>>>        Integer iDbType iDriver
92053>>>>>>>        Handle hDatabase
92053>>>>>>>
92053>>>>>>>        Get psDriverID to sDriverID
92054>>>>>>>        Get piDbType   to iDbType
92055>>>>>>>        Get DriverIndex sDriverID to iDriver
92056>>>>>>>        Get psServer to sServer
92057>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
92058>>>>>>>        If (hDatabase = 0) Begin
92060>>>>>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
92061>>>>>>>>
92061>>>>>>>            Procedure_Return
92062>>>>>>>        End
92062>>>>>>>>
92062>>>>>>>
92062>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
92065>>>>>>>
92065>>>>>>>    End_Procedure
92066>>>>>>>
92066>>>>>>>    // Returns a struct array with the default column types for the SQL back-end and how they
92066>>>>>>>    // are mapped to the standard DataFlex data types.
92066>>>>>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
92066>>>>>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
92068>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
92068>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
92070>>>>>>>        String sDataType
92070>>>>>>>        Integer iDataType iDriverID iCount
92070>>>>>>>        Boolean bSQLDriver
92070>>>>>>>
92070>>>>>>>        Move 0 to iCount
92071>>>>>>>        Get DriverIndex sDriverID to iDriverID
92072>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
92073>>>>>>>        If (bSQLDriver = False) Begin
92075>>>>>>>            Function_Return EmptyArray
92076>>>>>>>        End
92076>>>>>>>>
92076>>>>>>>
92076>>>>>>>        // DF_ASCII
92076>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92078>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
92081>>>>>>>        End
92081>>>>>>>>
92081>>>>>>>        Else Begin
92082>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
92085>>>>>>>        End
92085>>>>>>>>
92085>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92086>>>>>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
92087>>>>>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
92088>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92089>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92090>>>>>>>        Increment iCount
92091>>>>>>>
92091>>>>>>>        // DF_BINARY
92091>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92093>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
92096>>>>>>>        End
92096>>>>>>>>
92096>>>>>>>        Else Begin
92097>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
92100>>>>>>>        End
92100>>>>>>>>
92100>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92101>>>>>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
92102>>>>>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
92103>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92104>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92105>>>>>>>        Increment iCount
92106>>>>>>>
92106>>>>>>>        // DF_DATE
92106>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92108>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
92111>>>>>>>        End
92111>>>>>>>>
92111>>>>>>>        Else Begin
92112>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
92115>>>>>>>        End
92115>>>>>>>>
92115>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92116>>>>>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
92117>>>>>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
92118>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92119>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92120>>>>>>>        Increment iCount
92121>>>>>>>
92121>>>>>>>        // DF_DATETIME
92121>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92123>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
92126>>>>>>>        End
92126>>>>>>>>
92126>>>>>>>        Else Begin
92127>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
92130>>>>>>>        End
92130>>>>>>>>
92130>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92131>>>>>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
92132>>>>>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
92133>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92134>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92135>>>>>>>        Increment iCount
92136>>>>>>>
92136>>>>>>>        // DF_NUMERIC
92136>>>>>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
92136>>>>>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
92136>>>>>>>        // we make them here all "Numeric"...
92136>>>>>>>        Case Begin
92136>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
92138>>>>>>>                Move SQL_NUMERIC to iDataType
92139>>>>>>>                Move "numeric"   to sDataType
92140>>>>>>>                Case Break
92141>>>>>>>            Case (sDriverID = DB2_DRV_ID)
92144>>>>>>>                Move SQL_NUMERIC to iDataType
92145>>>>>>>                Move "NUMERIC"   to sDataType
92146>>>>>>>                Case Break
92147>>>>>>>            Case Else
92147>>>>>>>                Move DF_BCD      to iDataType
92148>>>>>>>                Move "Numeric"   to sDataType
92149>>>>>>>        Case End
92149>>>>>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
92150>>>>>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
92151>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92152>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92153>>>>>>>        Increment iCount
92154>>>>>>>
92154>>>>>>>        // DF_TEXT
92154>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92156>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
92159>>>>>>>        End
92159>>>>>>>>
92159>>>>>>>        Else Begin
92160>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
92163>>>>>>>        End
92163>>>>>>>>
92163>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92164>>>>>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
92165>>>>>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
92166>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92167>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92168>>>>>>>
92168>>>>>>>        Function_Return ColumnTypeArray
92169>>>>>>>    End_Function
92170>>>>>>>
92170>>>>>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
92172>>>>>>>        tColumnType[] ColumnTypeArray
92172>>>>>>>        tColumnType[] ColumnTypeArray
92173>>>>>>>        tColumnType   ColumnType
92173>>>>>>>        tColumnType   ColumnType
92173>>>>>>>        Integer iCount iSize
92173>>>>>>>
92173>>>>>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
92174>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
92175>>>>>>>        Decrement iSize
92176>>>>>>>
92176>>>>>>>        for iCount from 0 to iSize
92182>>>>>>>>
92182>>>>>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
92184>>>>>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
92185>>>>>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
92186>>>>>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
92187>>>>>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
92188>>>>>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
92189>>>>>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
92190>>>>>>>                Move iSize to iCount
92191>>>>>>>            End
92191>>>>>>>>
92191>>>>>>>        Loop
92192>>>>>>>>
92192>>>>>>>
92192>>>>>>>        Function_Return ColumnType
92193>>>>>>>    End_Function
92194>>>>>>>
92194>>>>>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
92194>>>>>>>    // An Alias file/table is a filelist number that share the same Physical filename
92194>>>>>>>    // but the Logical name is different.
92194>>>>>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
92194>>>>>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
92196>>>>>>>        String sRootName sRootNameCompare sLogicalName sLogicalNameCompare
92196>>>>>>>        Handle hInTable hMasterTable 
92196>>>>>>>        Boolean bIsAlias
92196>>>>>>>        
92196>>>>>>>        Move hTable to hInTable
92197>>>>>>>        Move False to bIsAlias
92198>>>>>>>        Move 0 to hMasterTable
92199>>>>>>>        
92199>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92202>>>>>>>        // Remove any prefix with a driver name.
92202>>>>>>>        Get _TableNameOnly sRootName to sRootName     
92203>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
92206>>>>>>>        Get _TableNameOnly sLogicalName to sLogicalName     
92207>>>>>>>        
92207>>>>>>>        // If the table has the same root and logical name it can't be an alias,
92207>>>>>>>        // so we can safely return a "False".
92207>>>>>>>        If (Uppercase(sRootName) <> Uppercase(sLogicalName)) Begin
92209>>>>>>>            Function_Return True
92210>>>>>>>        End
92210>>>>>>>>
92210>>>>>>>        
92210>>>>>>>        Function_Return False
92211>>>>>>>        
92211>>>>>>>        // Now we need to find a master table with the same root name (sRootName above),
92211>>>>>>>        // as the passed hTable root name.
92211>>>>>>>        // A master table always has the same root and logical name (except for any driver name prefix or .int suffix).
92211>>>>>>>//        Move 0 to hTable
92211>>>>>>>//        Repeat
92211>>>>>>>//            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92211>>>>>>>//            If (hTable > 0 and hTable <> 50) Begin
92211>>>>>>>//                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameCompare
92211>>>>>>>//                Get _TableNameOnly sRootNameCompare to sRootNameCompare
92211>>>>>>>//                // If we found another table with the same root and logical name
92211>>>>>>>//                // we have found a master table.
92211>>>>>>>//                If (Uppercase(sRootName) = Uppercase(sRootNameCompare)) Begin
92211>>>>>>>//                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameCompare
92211>>>>>>>//                    Get _TableNameOnly sLogicalNameCompare to sLogicalNameCompare     
92211>>>>>>>//                    If (Uppercase(sRootNameCompare) = Uppercase(sLogicalNameCompare)) Begin
92211>>>>>>>//                        Move hTable to hMasterTable   
92211>>>>>>>//                        Move 0 to hTable // To end the loop.
92211>>>>>>>//                    End
92211>>>>>>>//                End
92211>>>>>>>//            End
92211>>>>>>>//        Until (hTable = 0)
92211>>>>>>>//        
92211>>>>>>>//        If (hMasterTable <> 0 and hMasterTable <> hInTable) Begin
92211>>>>>>>//            Move True to bIsAlias
92211>>>>>>>//        End
92211>>>>>>>//        
92211>>>>>>>//        Function_Return bIsAlias
92211>>>>>>>    End_Function
92212>>>>>>>
92212>>>>>>>    // To Open a table with any driver.
92212>>>>>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
92212>>>>>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
92212>>>>>>>    //
92212>>>>>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
92212>>>>>>>    // The found flag is still used to indicate if the open was successful or not. The function
92212>>>>>>>    // returns a True if successful (table could be opened).
92212>>>>>>>    //
92212>>>>>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
92212>>>>>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
92212>>>>>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
92212>>>>>>>    // set properly we can open the table.
92212>>>>>>>    //
92212>>>>>>>    // DAW Driver Syntax:
92212>>>>>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
92212>>>>>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
92212>>>>>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
92212>>>>>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
92212>>>>>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
92212>>>>>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
92212>>>>>>>    //
92212>>>>>>>    // DAW Driver Sample:
92212>>>>>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
92212>>>>>>>    //
92212>>>>>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
92214>>>>>>>        String sTableNameOrg
92214>>>>>>>        Boolean bOpen bOK
92214>>>>>>>        tSQLConnection SQLConnection
92214>>>>>>>        tSQLConnection SQLConnection
92214>>>>>>>        
92214>>>>>>>        Move False to bOpen
92215>>>>>>>        Move sTableName to sTableNameOrg
92216>>>>>>>        If (hTable > 0) Begin
92218>>>>>>>            Send Ignore_Error of Error_Object_Id 20529
92219>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
92220>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
92221>>>>>>>            Send Ignore_Error of Error_Object_Id 10
92222>>>>>>>            Open hTable Mode iMode
92224>>>>>>>            Send Trap_Error of Error_Object_Id 20529
92225>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
92226>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
92227>>>>>>>            Send Trap_Error of Error_Object_Id 10
92228>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
92231>>>>>>>            If (bOpen = True) Begin
92233>>>>>>>                Function_Return True
92234>>>>>>>            End
92234>>>>>>>>
92234>>>>>>>        End
92234>>>>>>>>
92234>>>>>>>
92234>>>>>>>        Get UtilTableOpenAsIntFile hTable sTableName iMode to bOK 
92235>>>>>>>        If (hTable > 0) Begin
92237>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
92240>>>>>>>        End
92240>>>>>>>>
92240>>>>>>>
92240>>>>>>>        Function_Return bOpen
92241>>>>>>>    End_Function
92242>>>>>>>
92242>>>>>>>    Function UtilTableOpenAsIntFile Integer hTable String sTableName Integer iMode Returns Boolean
92244>>>>>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
92244>>>>>>>        Boolean bOpen bOK
92244>>>>>>>        tSQLConnection SQLConnection
92244>>>>>>>        tSQLConnection SQLConnection
92244>>>>>>>
92244>>>>>>>        If (hTable < 1) Begin
92246>>>>>>>            Function_Return False
92247>>>>>>>        End
92247>>>>>>>>
92247>>>>>>>
92247>>>>>>>        Move sTableName to sTableNameOrg
92248>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92249>>>>>>>        Move SQLConnection.sDriverID to sDriverID
92250>>>>>>>        Move SQLConnection.sConnectionString to sConnection
92251>>>>>>>        Move SQLConnection.sSchema to sSchema
92252>>>>>>>        If (sSchema = "") Begin
92254>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
92255>>>>>>>        End
92255>>>>>>>>
92255>>>>>>>
92255>>>>>>>        // We need to remove the ".int" part of the table name because
92255>>>>>>>        // the table name after the "#" in the connection syntax below wants the
92255>>>>>>>        // "bare" table name without any extension.
92255>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
92257>>>>>>>            If (Lowercase(sTableName) contains ".int") Begin
92259>>>>>>>                Get ParseFileExtension sTableName to sExt
92260>>>>>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
92261>>>>>>>            End
92261>>>>>>>>
92261>>>>>>>            Else Begin
92262>>>>>>>                Move sTableName to sTableNameShort
92263>>>>>>>                Move (Append(sTableName, ".int")) to sTableName
92264>>>>>>>            End
92264>>>>>>>>
92264>>>>>>>            Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
92265>>>>>>>            Move sConnection to sTableName
92266>>>>>>>        End
92266>>>>>>>>
92266>>>>>>>
92266>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
92267>>>>>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
92268>>>>>>>        If (hTable = 0) Begin
92270>>>>>>>            Get NextFreeFilelistSlot to hTable
92271>>>>>>>        End
92271>>>>>>>>
92271>>>>>>>
92271>>>>>>>        Case Begin
92271>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
92273>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92273>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
92275>>>>>>>                    Close hTable
92276>>>>>>>                    Open sTableName as hTable
92278>>>>>>>                End
92278>>>>>>>>
92278>>>>>>>                Else Begin
92279>>>>>>>                    Get OpenTableExclusive hTable to bOK
92280>>>>>>>                    If (bOK = False) Begin
92282>>>>>>>                        Function_Return False
92283>>>>>>>                    End
92283>>>>>>>>
92283>>>>>>>                End
92283>>>>>>>>
92283>>>>>>>                Case Break
92284>>>>>>>
92284>>>>>>>            Case (sDriverID = DB2_DRV_ID)
92287>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92287>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
92289>>>>>>>                    Close hTable
92290>>>>>>>                    Open sTableName as hTable
92292>>>>>>>                End
92292>>>>>>>>
92292>>>>>>>                Else Begin
92293>>>>>>>                    Get OpenTableExclusive hTable to bOK
92294>>>>>>>                    If (bOK = False) Begin
92296>>>>>>>                        Function_Return False
92297>>>>>>>                    End
92297>>>>>>>>
92297>>>>>>>                End
92297>>>>>>>>
92297>>>>>>>                Case Break
92298>>>>>>>
92298>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
92301>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92301>>>>>>>                If (iMode = DF_SHARE) Begin
92303>>>>>>>                    Close hTable
92304>>>>>>>                    Open sTableName as hTable
92306>>>>>>>                End
92306>>>>>>>>
92306>>>>>>>                Else Begin
92307>>>>>>>                    Get OpenTableExclusive hTable to bOK
92308>>>>>>>                    If (bOK = False) Begin
92310>>>>>>>                        Function_Return False
92311>>>>>>>                    End
92311>>>>>>>>
92311>>>>>>>                End
92311>>>>>>>>
92311>>>>>>>                Case Break
92312>>>>>>>
92312>>>>>>>            Case (sDriverID = DATAFLEX_ID)
92315>>>>>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
92317>>>>>>>                    Close hTable
92318>>>>>>>                    Open sTableName as hTable
92320>>>>>>>                End
92320>>>>>>>>
92320>>>>>>>                Else If (iMode = DF_EXCLUSIVE) Begin
92323>>>>>>>                    Get OpenTableExclusive hTable to bOK
92324>>>>>>>                    If (bOK = False) Begin
92326>>>>>>>                        Function_Return False
92327>>>>>>>                    End
92327>>>>>>>>
92327>>>>>>>                End
92327>>>>>>>>
92327>>>>>>>                Else Begin
92328>>>>>>>                    Open hTable
92330>>>>>>>                End
92330>>>>>>>>
92330>>>>>>>                Case Break
92331>>>>>>>
92331>>>>>>>            Case Else
92331>>>>>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
92332>>>>>>>>
92332>>>>>>>        Case End
92332>>>>>>>
92332>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
92333>>>>>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
92334>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
92336>>>>>>>            Move False to Found
92337>>>>>>>        End
92337>>>>>>>>
92337>>>>>>>        // If open failed, the Err is set to true,
92337>>>>>>>        // but we don't want that because it could end our loop.
92337>>>>>>>        Move False to Err
92338>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
92341>>>>>>>
92341>>>>>>>        Function_Return bOpen
92342>>>>>>>    End_Function
92343>>>>>>>
92343>>>>>>>    // Pass a table's logical name
92343>>>>>>>    // Returns True if the table exists in filelist.cfg.
92343>>>>>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
92345>>>>>>>        Handle hTable
92345>>>>>>>        Boolean bFound
92345>>>>>>>        String sCompareTable
92345>>>>>>>
92345>>>>>>>        Move False to bFound
92346>>>>>>>        Move 0 to hTable
92347>>>>>>>        Repeat
92347>>>>>>>>
92347>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92350>>>>>>>            If (hTable > 0) Begin
92352>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
92355>>>>>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
92357>>>>>>>                    Move True to bFound
92358>>>>>>>                End
92358>>>>>>>>
92358>>>>>>>            End
92358>>>>>>>>
92358>>>>>>>            If (bFound = True) ;                Break
92361>>>>>>>        Until (hTable = 0)
92363>>>>>>>
92363>>>>>>>        Function_Return (bFound = True)
92364>>>>>>>    End_Function
92365>>>>>>>
92365>>>>>>>    // Function will report the default driver "DATAFLEX" if table can't be opened
92365>>>>>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
92367>>>>>>>        Boolean bOK bExists
92367>>>>>>>        String sDriverID
92367>>>>>>>
92367>>>>>>>        Get _UtilTableExists hTable to bExists
92368>>>>>>>        If (bExists = False) Begin
92370>>>>>>>            Function_Return DATAFLEX_ID
92371>>>>>>>        End
92371>>>>>>>>
92371>>>>>>>        Get OpenTableExclusive hTable to bOK
92372>>>>>>>        If (bOK = False) Begin
92374>>>>>>>            Function_Return DATAFLEX_ID
92375>>>>>>>        End
92375>>>>>>>>
92375>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
92378>>>>>>>        Function_Return sDriverID
92379>>>>>>>    End_Function
92380>>>>>>>
92380>>>>>>>    // Number of tables in Filelist.cfg. Returns integger
92380>>>>>>>    Function UtilFilelistNoOfTables Returns Integer
92382>>>>>>>        Handle hTable
92382>>>>>>>        Integer iRetval
92382>>>>>>>
92382>>>>>>>        Move 0 to hTable
92383>>>>>>>        Move 0 to iRetval
92384>>>>>>>
92384>>>>>>>        Repeat
92384>>>>>>>>
92384>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92387>>>>>>>            If (hTable > 0) Begin
92389>>>>>>>                Increment iRetval
92390>>>>>>>            End
92390>>>>>>>>
92390>>>>>>>        Until (hTable = 0)
92392>>>>>>>
92392>>>>>>>        Function_Return iRetval
92393>>>>>>>    End_Function
92394>>>>>>>
92394>>>>>>>    // Checks if any of the tables in Filelist.cfg is an SQL driver and returns the first Driver ID.
92394>>>>>>>    Function UtilIsAnyFilelistEntrySQLtable Returns String
92396>>>>>>>        Handle hTable
92396>>>>>>>        String sRoot sDriverID
92396>>>>>>>        Boolean bIsSQLTable
92396>>>>>>>        Integer iPos
92396>>>>>>>
92396>>>>>>>        Move 0 to hTable
92397>>>>>>>        Move "" to sDriverID
92398>>>>>>>        Move False to bIsSQLTable
92399>>>>>>>
92399>>>>>>>        Repeat
92399>>>>>>>>
92399>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92402>>>>>>>            If (hTable > 0) Begin
92404>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
92407>>>>>>>                If (sRoot contains ":") Begin
92409>>>>>>>                    Move (Pos(":", sRoot)) to iPos
92410>>>>>>>                    Move (Left(sRoot, (iPos -1))) to sDriverID
92411>>>>>>>                End
92411>>>>>>>>
92411>>>>>>>                Get IsSQLDriver sDriverID to bIsSQLTable
92412>>>>>>>            End
92412>>>>>>>>
92412>>>>>>>
92412>>>>>>>        Until (hTable = 0 or bIsSQLTable = True)
92414>>>>>>>
92414>>>>>>>        Function_Return sDriverID
92415>>>>>>>    End_Function
92416>>>>>>>
92416>>>>>>>    Function UtilIsAllFilelistEntriesDataFlexTables Returns Boolean
92418>>>>>>>        String sRootName
92418>>>>>>>        Boolean bIsSQL
92418>>>>>>>        Handle hTable
92418>>>>>>>
92418>>>>>>>        Move False to bIsSQL
92419>>>>>>>        Move 0 to hTable
92420>>>>>>>        Repeat
92420>>>>>>>>
92420>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92423>>>>>>>            If (hTable > 0) Begin
92425>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92428>>>>>>>                Get _UtilTableIsSqlByRootName sRootName to bIsSQL
92429>>>>>>>                If (bIsSQL = True) Begin
92431>>>>>>>                    Move 0 to hTable
92432>>>>>>>                End
92432>>>>>>>>
92432>>>>>>>            End
92432>>>>>>>>
92432>>>>>>>        Until (hTable = 0)
92434>>>>>>>
92434>>>>>>>        Function_Return (bIsSQL = False)
92435>>>>>>>    End_Function
92436>>>>>>>
92436>>>>>>>    // * Dummy function for the Studio's Code Explorer *
92436>>>>>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
92438>>>>>>>        Function_Return False
92439>>>>>>>    End_Function
92440>>>>>>>
92440>>>>>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
92442>>>>>>>        String  sRetval
92442>>>>>>>        String[] sOverlapFieldsArray
92443>>>>>>>        Integer iType iColumn iColumns
92443>>>>>>>        Boolean bOpen bOverlap
92443>>>>>>>
92443>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
92446>>>>>>>        If (bOpen = False) Begin
92448>>>>>>>            Open hTable
92450>>>>>>>        End
92450>>>>>>>>
92450>>>>>>>
92450>>>>>>>        Move "" to sRetval
92451>>>>>>>
92451>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
92454>>>>>>>
92454>>>>>>>        for iColumn from 0 to iColumns
92460>>>>>>>>
92460>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
92463>>>>>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
92465>>>>>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
92468>>>>>>>                If (bOverlap) Begin
92470>>>>>>>                    If (sRetval <> "") Begin
92472>>>>>>>                        Append sRetval ","
92473>>>>>>>                    End
92473>>>>>>>>
92473>>>>>>>                    Append sRetval iColumn
92474>>>>>>>                End
92474>>>>>>>>
92474>>>>>>>            End
92474>>>>>>>>
92474>>>>>>>        Loop
92475>>>>>>>>
92475>>>>>>>
92475>>>>>>>        If (bOpen = False) Begin
92477>>>>>>>            Close hTable
92478>>>>>>>        End
92478>>>>>>>>
92478>>>>>>>
92478>>>>>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
92479>>>>>>>
92479>>>>>>>        Function_Return sOverlapFieldsArray
92480>>>>>>>    End_Function
92481>>>>>>>
92481>>>>>>>    Function UtilEnumerateODBCDrivers Returns String
92483>>>>>>>        Handle hoRegistry hoODBCDriverNames
92483>>>>>>>        Boolean bExists bKeyOpened
92483>>>>>>>        String sKey
92483>>>>>>>        String[] sDrivers
92484>>>>>>>        Integer iDriverNames iDriverName
92484>>>>>>>
92484>>>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
92485>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
92486>>>>>>>        Set pfAccessRights of hoRegistry to Key_Read
92487>>>>>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
92488>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
92489>>>>>>>        If (bExists) Begin
92491>>>>>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
92492>>>>>>>            If (bKeyOpened) Begin
92494>>>>>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
92495>>>>>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
92496>>>>>>>                If (iDriverNames > 0) Begin
92498>>>>>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
92499>>>>>>>                    Decrement iDriverNames
92500>>>>>>>                    for iDriverName from 0 to iDriverNames
92506>>>>>>>>
92506>>>>>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
92507>>>>>>>                    Loop
92508>>>>>>>>
92508>>>>>>>                End
92508>>>>>>>>
92508>>>>>>>                Send CloseKey of hoRegistry
92509>>>>>>>            End
92509>>>>>>>>
92509>>>>>>>        End
92509>>>>>>>>
92509>>>>>>>        Send Destroy of hoRegistry
92510>>>>>>>
92510>>>>>>>        Function_Return sDrivers
92511>>>>>>>    End_Function
92512>>>>>>>
92512>>>>>>>    Procedure IncreaseSortBufferSize
92514>>>>>>>        String sNull
92514>>>>>>>        Integer iSortBufferSize
92514>>>>>>>        Boolean bBufferSet
92514>>>>>>>
92514>>>>>>>        Move "" to sNull
92515>>>>>>>        Move (1024 * 128) to iSortBufferSize
92516>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
92521>>>>>>>
92521>>>>>>>    End_Procedure
92522>>>>>>>
92522>>>>>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
92524>>>>>>>        Integer iLastIndex iIndex iNumSegments
92524>>>>>>>        Boolean bOK
92524>>>>>>>        String sDriverID
92524>>>>>>>
92524>>>>>>>        If (hTable > 0) Begin
92526>>>>>>>            Get UtilDriverFromTableNumber hTable to sDriverID
92527>>>>>>>            Close hTable
92528>>>>>>>            Get OpenTableExclusive hTable to bOK
92529>>>>>>>            If (bOK = False) Begin
92531>>>>>>>                Procedure_Return
92532>>>>>>>            End
92532>>>>>>>>
92532>>>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
92535>>>>>>>            Structure_Start hTable sDriverID
92536>>>>>>>                for iIndex from 1 to iLastIndex
92542>>>>>>>>
92542>>>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
92545>>>>>>>                    If (iNumSegments > 0) Begin
92547>>>>>>>                        If (bSetToBatch = True) Begin
92549>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
92552>>>>>>>                        End
92552>>>>>>>>
92552>>>>>>>                        Else Begin
92553>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
92556>>>>>>>                        End
92556>>>>>>>>
92556>>>>>>>                    End
92556>>>>>>>>
92556>>>>>>>                Loop
92557>>>>>>>>
92557>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92559>>>>>>>        End
92559>>>>>>>>
92559>>>>>>>    End_Procedure
92560>>>>>>>
92560>>>>>>>    Function NextFreeFilelistSlot Returns Handle
92562>>>>>>>        Handle hTable
92562>>>>>>>
92562>>>>>>>        Move 0 to hTable
92563>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
92566>>>>>>>
92566>>>>>>>        Function_Return hTable
92567>>>>>>>    End_Function
92568>>>>>>>
92568>>>>>>>    // For debugging purposes. To print Sql statements as they are build...
92568>>>>>>>    Procedure DebugPrint String sStmt String sFileName
92570>>>>>>>        Integer iCh
92570>>>>>>>        Get Seq_Append_Output_Channel sFileName to iCh
92571>>>>>>>            Write channel iCh sStmt
92573>>>>>>>        Send Seq_Close_Channel iCh
92574>>>>>>>    End_Procedure
92575>>>>>>>
92575>>>>>>>    // Returns the integer number for the passed Driver ID that is
92575>>>>>>>    // needed by some database API calls.
92575>>>>>>>    Function DriverIndex String sDriverID Returns Integer
92577>>>>>>>        String  sCurrentDriver
92577>>>>>>>        Integer iNumberOfDrivers iDriver iCount
92577>>>>>>>
92577>>>>>>>        Move 0 to iDriver
92578>>>>>>>
92578>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
92581>>>>>>>        for iCount from 1 to iNumberOfDrivers
92587>>>>>>>>
92587>>>>>>>
92587>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
92590>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
92592>>>>>>>                Move iCount to iDriver
92593>>>>>>>            End
92593>>>>>>>>
92593>>>>>>>        Loop
92594>>>>>>>>
92594>>>>>>>
92594>>>>>>>        // In case it was not found, it wasn't loaded so we do that now.
92594>>>>>>>        If (iDriver = 0) Begin
92596>>>>>>>            Move False to Err
92597>>>>>>>            Load_Driver sDriverID
92598>>>>>>>            If (Err = False) Begin
92600>>>>>>>                Get_Attribute DF_NUMBER_DRIVERS to iDriver
92603>>>>>>>            End
92603>>>>>>>>
92603>>>>>>>        End
92603>>>>>>>>
92603>>>>>>>
92603>>>>>>>        Function_Return iDriver
92604>>>>>>>    End_Function
92605>>>>>>>
92605>>>>>>>
92605>>>>>>>    Function SqlServerClientVersionName for cMSSQLHandler Integer iClientVersion  Returns String
92607>>>>>>>        String  sSqlServerClientVersionName
92607>>>>>>>        
92607>>>>>>>        Case Begin
92607>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
92609>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientVersionName
92610>>>>>>>                Case Break
92611>>>>>>>
92611>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
92614>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
92615>>>>>>>                Case Break
92616>>>>>>>                
92616>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
92619>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
92620>>>>>>>                Case Break
92621>>>>>>>            
92621>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
92624>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
92625>>>>>>>                Case Break
92626>>>>>>>            
92626>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
92629>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
92630>>>>>>>                Case Break
92631>>>>>>>            
92631>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
92634>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
92635>>>>>>>                Case Break
92636>>>>>>>            
92636>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
92639>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
92640>>>>>>>                Case Break
92641>>>>>>>            
92641>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
92644>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
92645>>>>>>>                Case Break
92646>>>>>>>            
92646>>>>>>>            Case Else
92646>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
92647>>>>>>>        Case End
92647>>>>>>>        
92647>>>>>>>        Function_Return sSqlServerClientVersionName
92648>>>>>>>    End_Function
92649>>>>>>>
92649>>>>>>>    Function SqlServerClientDriverName for cMSSQLHandler Integer iClientVersion  Returns String
92651>>>>>>>        String  sSqlServerClientDriverName
92651>>>>>>>        
92651>>>>>>>        Case Begin
92651>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
92653>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientDriverName
92654>>>>>>>                Case Break
92655>>>>>>>
92655>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
92658>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
92659>>>>>>>                Case Break
92660>>>>>>>                
92660>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
92663>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
92664>>>>>>>                Case Break
92665>>>>>>>            
92665>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
92668>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
92669>>>>>>>                Case Break
92670>>>>>>>            
92670>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
92673>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
92674>>>>>>>                Case Break
92675>>>>>>>            
92675>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
92678>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
92679>>>>>>>                Case Break
92680>>>>>>>            
92680>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
92683>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
92684>>>>>>>                Case Break
92685>>>>>>>            
92685>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
92688>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
92689>>>>>>>                Case Break
92690>>>>>>>            
92690>>>>>>>            Case Else
92690>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
92691>>>>>>>        Case End
92691>>>>>>>        
92691>>>>>>>        Function_Return sSqlServerClientDriverName
92692>>>>>>>    End_Function
92693>>>>>>>    
92693>>>>>>>    Function MinMSSQLDRV_And_ClientVersion String sMSSQLDRVVersion Integer iClientVersion Boolean bShowErrorDialog Boolean bExitProgram Returns String
92695>>>>>>>        String sDriverID sVersion sClient sClientLowest sRetval
92695>>>>>>>        Integer iNumberOfDrivers iDriver iClient
92695>>>>>>>        Handle hoCLIHandler hoMSSQLHandler   
92695>>>>>>>        Boolean bOK
92695>>>>>>>        
92695>>>>>>>        Move "" to sRetval
92696>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLIHandler
92697>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMSSQLHandler
92698>>>>>>>        Load_Driver MSSQLDRV_ID
92699>>>>>>>
92699>>>>>>>        // Loop through all loaded drivers.
92699>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
92702>>>>>>>        For iDriver from 1 to iNumberOfDrivers
92708>>>>>>>>
92708>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
92711>>>>>>>            If (sDriverID = MSSQLDRV_ID) Begin
92713>>>>>>>                Set psDriverID of hoCLIHandler to sDriverID
92714>>>>>>>                Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient   
92717>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClientVersion to sClientLowest 
92718>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClient to sClient 
92719>>>>>>>                Get CKRevision of hoCLIHandler to sVersion
92720>>>>>>>                Move (SFormat (String(C_$DatabaseDriver), (sDriverID * "-" * (String(C_$Version) + ": " + String(sVersion))))) to sRetval
92721>>>>>>>                If (sClient <> "" and sRetval <> "") Begin
92723>>>>>>>                    Move (String(sRetval) + "\n" + String(C_$SQL_Client_Text) + "\n" + Trim(sClient)) to sRetval
92724>>>>>>>                End                                
92724>>>>>>>>
92724>>>>>>>                Else Begin
92725>>>>>>>                    Move (String(C_$SQL_Client_Text) + "\n" + Trim(sClient) * "(" + String(iClient) + ")") to sRetval
92726>>>>>>>                End
92726>>>>>>>>
92726>>>>>>>            End
92726>>>>>>>>
92726>>>>>>>        Loop
92727>>>>>>>>
92727>>>>>>>        Send Destroy of hoCLIHandler  
92728>>>>>>>        Send Destroy of hoMSSQLHandler  
92729>>>>>>>        If (bShowErrorDialog = True) Begin
92731>>>>>>>            Get IsFirstStringGreaterThanSecond sVersion sMSSQLDRVVersion to bOK
92732>>>>>>>            If (bOK = False or (iClient < iClientVersion)) Begin
92734>>>>>>>                Move (MSSQLDRV_ID + ".dll" * String(C_$SQL_Driver_Version_Min_Text) *  String(sMSSQLDRVVersion) + String("\n") + String(C_$SQL_Client_Version_Min_Text) + "\n" + String(sClientLowest) + String("\n\n") + String(C_$SQL_Versions_Are_Text) + String("\n") + String(sRetval)) to sRetval
92735>>>>>>>                If (bExitProgram = True) Begin
92737>>>>>>>                    Move (String(sRetval) + String("\n\n") + String(C_$PleaseAdjustTxt) * String(C_$ProgramWillExit_Text)) to sRetval
92738>>>>>>>                End
92738>>>>>>>>
92738>>>>>>>                Send Stop_Box sRetval  
92739>>>>>>>                If (bExitProgram = True) Begin
92741>>>>>>>                    Send Exit_Application
92742>>>>>>>                End
92742>>>>>>>>
92742>>>>>>>            End
92742>>>>>>>>
92742>>>>>>>        End
92742>>>>>>>>
92742>>>>>>>        
92742>>>>>>>        Function_Return sRetval
92743>>>>>>>    End_Function  
92744>>>>>>>    
92744>>>>>>>    // Returns True if first "." separated string is greater than the second.
92744>>>>>>>    // It checks from left to right, one part of the string at a time.
92744>>>>>>>    // E.g. if sVersion="20.1.31.10 and sSQLVersion="6.3.0.13" the function would return TRUE.
92744>>>>>>>    Function IsFirstStringGreaterThanSecond Global String sVersion String sSQLVersion Returns Boolean
92746>>>>>>>        String[] asVersion asSQLVersion          
92748>>>>>>>        Integer iSize iCount iVersion iSQLVersion
92748>>>>>>>        
92748>>>>>>>        Move (StrSplitToArray(sVersion, "."))    to asVersion
92749>>>>>>>        Move (StrSplitToArray(sSQLVersion, ".")) to asSQLVersion
92750>>>>>>>        Move (SizeOfArray(asVersion)) to iSize
92751>>>>>>>        // Make sure the two arrays are of the same size:
92751>>>>>>>        If (SizeOfArray(asSQLVersion) < iSize) Begin
92753>>>>>>>            Move (ResizeArray(asSQLVersion, iSize, 0)) to asSQLVersion
92754>>>>>>>        End
92754>>>>>>>>
92754>>>>>>>        Decrement iSize
92755>>>>>>>        for iCount from 0 to iSize
92761>>>>>>>>
92761>>>>>>>            Move asVersion[iCount]    to iVersion
92762>>>>>>>            Move asSQLVersion[iCount] to iSQLVersion
92763>>>>>>>            CompilerWarnings Off
92763>>>>>>>            If (iVersion > iSQLVersion) Break
92766>>>>>>>            CompilerWarnings On
92766>>>>>>>        Loop
92767>>>>>>>>
92767>>>>>>>        
92767>>>>>>>        Function_Return (iVersion >= iSQLVersion)
92768>>>>>>>    End_Function
92769>>>>>>>
92769>>>>>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
92769>>>>>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
92769>>>>>>>    //       so in that case we "cheat" and report those tables were opened OK.
92769>>>>>>>    Function OpenTableExclusive Handle hTable Returns Boolean
92771>>>>>>>        Integer iMode iErrorObject
92771>>>>>>>        Boolean bOpened bExitIfDebuggerActive
92771>>>>>>>        String sTableName 
92771>>>>>>>        Handle hoCurrentErrorHandler
92771>>>>>>>        
92771>>>>>>>        Move False to bExitIfDebuggerActive
92772>>>>>>>        If (ghoDbUpdateHandler <> 0) Begin
92774>>>>>>>            Get pbExitIfDebuggerActive of ghoDbUpdateHandler to bExitIfDebuggerActive
92775>>>>>>>        End
92775>>>>>>>>
92775>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92776>>>>>>>        // Can't open a table properly if run through the Debugger/Studio,
92776>>>>>>>        // so we generate an error here:
92776>>>>>>>        If (IsDebuggerPresent() and bExitIfDebuggerActive = True) Begin
92778>>>>>>>            Move Error_Object_Id to hoCurrentErrorHandler
92779>>>>>>>            Get piOrgErrorHandlerID to iErrorObject
92780>>>>>>>            If (iErrorObject <> 0) Begin
92782>>>>>>>                Move iErrorObject to Error_Object_Id
92783>>>>>>>            End
92783>>>>>>>>
92783>>>>>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio! You need to run this program from outside of the Studio."
92784>>>>>>>>
92784>>>>>>>            Move hoCurrentErrorHandler to Error_Object_Id
92785>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
92786>>>>>>>            Function_Return False
92787>>>>>>>        End
92787>>>>>>>>
92787>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92790>>>>>>>        If (bOpened) Begin
92792>>>>>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
92795>>>>>>>            If (iMode = DF_EXCLUSIVE) Begin
92797>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92798>>>>>>>                Function_Return True
92799>>>>>>>            End
92799>>>>>>>>
92799>>>>>>>            Close hTable
92800>>>>>>>        End
92800>>>>>>>>
92800>>>>>>>        Else Begin
92801>>>>>>>            Open hTable
92803>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
92806>>>>>>>            If (bOpened and IsDebuggerPresent()) Begin
92808>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
92811>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
92813>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
92814>>>>>>>                    Function_Return True
92815>>>>>>>                End
92815>>>>>>>>
92815>>>>>>>            End
92815>>>>>>>>
92815>>>>>>>
92815>>>>>>>        End
92815>>>>>>>>
92815>>>>>>>
92815>>>>>>>        Close hTable
92816>>>>>>>        Open hTable Mode DF_EXCLUSIVE
92818>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92821>>>>>>>
92821>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92822>>>>>>>        Function_Return bOpened
92823>>>>>>>    End_Function
92824>>>>>>>
92824>>>>>>>    Function AutoConnectionIDLogin Returns Boolean
92826>>>>>>>        String sConnectionID sConnectionString sDriverID
92826>>>>>>>        Boolean bExists bOK bSQLDriver
92826>>>>>>>        Handle hoCLI hoDriver
92826>>>>>>>        Integer iRetval
92826>>>>>>>        tSQLConnection SQLConnection
92826>>>>>>>        tSQLConnection SQLConnection
92826>>>>>>>
92826>>>>>>>        Get psDriverID to sDriverID
92827>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
92828>>>>>>>        If (bSQLDriver = False) Begin
92830>>>>>>>            Function_Return True
92831>>>>>>>        End
92831>>>>>>>>
92831>>>>>>>
92831>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92832>>>>>>>        Move SQLConnection.sDriverID                  to sDriverID
92833>>>>>>>        Move SQLConnection.sConnectionString          to sConnectionString
92834>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
92835>>>>>>>
92835>>>>>>>        Get IsConnectionID sConnectionID sDriverID to bExists
92836>>>>>>>        If (bExists = False) Begin
92838>>>>>>>            // We always start by deleting the current connection - if any - because the
92838>>>>>>>            // login details my have changed.
92838>>>>>>>            Get phoCLIHandler to hoCLI
92839>>>>>>>            Set psDriverID    of hoCLI to sDriverID
92840>>>>>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
92841>>>>>>>            Get AutoSetConnectionID sConnectionID to bOk
92842>>>>>>>            If (bOk = False) Begin
92844>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
92845>>>>>>>>
92845>>>>>>>                Function_Return False
92846>>>>>>>            End
92846>>>>>>>>
92846>>>>>>>            Move bOK to bExists
92847>>>>>>>        End
92847>>>>>>>>
92847>>>>>>>
92847>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
92848>>>>>>>        Set Name of hoDriver to "oDbUpdateDatabaseDriver"
92849>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
92850>>>>>>>        Get DbLogin of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
92851>>>>>>>        Send Destroy of hoDriver
92852>>>>>>>
92852>>>>>>>        Function_Return (bExists = True)
92853>>>>>>>    End_Function
92854>>>>>>>
92854>>>>>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
92854>>>>>>>    // Returns: False if nobody else is running
92854>>>>>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
92854>>>>>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
92854>>>>>>>    //      tables are not locked as DataFlex tables are.
92854>>>>>>>    Function IsDatabaseInUse Returns Boolean
92856>>>>>>>        Handle  hTable
92856>>>>>>>        String  sRootName sDatabase sSchema sDriverID
92856>>>>>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs bExists
92856>>>>>>>        Integer iCount iTables
92856>>>>>>>        String[] asTablesArray asTablesArrayEmpty
92858>>>>>>>        
92858>>>>>>>        Move 0 to iTables
92859>>>>>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
92860>>>>>>>        Get AutoConnectionIDLogin to bOK
92861>>>>>>>        Get UtilFilelistNoOfTables to iTables
92862>>>>>>>        Set piPosition   of ghoProgressBar to 0
92863>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 1
92864>>>>>>>        Set piMaximum    of ghoProgressBar to iTables
92865>>>>>>>        Close DF_ALL
92866>>>>>>>        Move 0 to hTable
92867>>>>>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92870>>>>>>>        Move False to bErr
92871>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92872>>>>>>>
92872>>>>>>>        Get psDriverID to sDriverID
92873>>>>>>>        Get psDatabase to sDatabase
92874>>>>>>>        Get psSchema   to sSchema
92875>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to asTablesArray
92876>>>>>>>        Set pasSQLDataTables to asTablesArray
92877>>>>>>>        Repeat
92877>>>>>>>>
92877>>>>>>>            Set piPosition of ghoProgressBar to iCount
92878>>>>>>>            Increment iCount
92879>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92882>>>>>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
92883>>>>>>>
92883>>>>>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
92883>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQLTable
92884>>>>>>>            Move False to bOpen
92885>>>>>>>            // _UtilTableExists_Ex is a variant of "_UtilTableExists", but it needs that the pasSQLDataTables
92885>>>>>>>            // property has been set/updated before usage! This makes the loop much faster.
92885>>>>>>>            Get _UtilTableExists_Ex hTable to bExists
92886>>>>>>>            // Don't bother about CodeType (253, CodeMast (254) or) FlexErrs (Normally table 50)
92886>>>>>>>            If (bIsSQLTable = False and bExists = True and hTable <> 0 and hTable <> 253 and hTable <> 254 and bFlexErrs = False) Begin
92888>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92889>>>>>>>                Open hTable
92891>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
92894>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92895>>>>>>>                If (bOpen = True) Begin
92897>>>>>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
92897>>>>>>>                    Get UtilTableIsAlias hTable to bAlias
92898>>>>>>>                    If (bAlias = False) Begin
92900>>>>>>>                        Close hTable
92901>>>>>>>                        Get OpenTableExclusive hTable to bOpen
92902>>>>>>>                        If (bOpen = False) Begin
92904>>>>>>>                            Move True to bErr
92905>>>>>>>                        End
92905>>>>>>>>
92905>>>>>>>                    End
92905>>>>>>>>
92905>>>>>>>                End
92905>>>>>>>>
92905>>>>>>>            End
92905>>>>>>>>
92905>>>>>>>            Close hTable
92906>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92909>>>>>>>            If (bErr = True ) ;                Break
92912>>>>>>>        Until (not(hTable))
92914>>>>>>>
92914>>>>>>>        // Reset the temporary used data tables property to blank:
92914>>>>>>>        Set pasSQLDataTables to asTablesArrayEmpty
92915>>>>>>>        Set Action_Text of ghoStatusPanel to ""
92916>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92917>>>>>>>        Move False to Err
92918>>>>>>>
92918>>>>>>>        Function_Return bErr
92919>>>>>>>    End_Function
92920>>>>>>>
92920>>>>>>>End_Class
92921>>>>>Use for_all.pkg // Handy to have available in the OnUpdate event.
Including file: for_all.pkg    (C:\Program Files\DataFlex 24.0\Pkg\for_all.pkg)
92921>>>>>>>// This module contains the command definitions for the FOR_ALL construct.
92921>>>>>>>//
92921>>>>>>>// FOR_ALL is used to select and process a set of records in a database file;
92921>>>>>>>// FOR_ALL constructs may be nested. FOR_ALL is intended to work in
92921>>>>>>>// conjunction with constraint-clauses.
92921>>>>>>>//
92921>>>>>>>// SYNTAX:
92921>>>>>>>//
92921>>>>>>>//  For_All <File> BY|DOWN <Index> {AS QUE|QUEUE} {DO}
92921>>>>>>>//    <Constraints...>
92921>>>>>>>//    {DO}
92921>>>>>>>//      <loop body>
92921>>>>>>>//  End_For_All
92921>>>>>>>//
92921>>>>>>>// This set of macros implements a constraint-oriented file enumeration
92921>>>>>>>// syntax.  For example, to list all Customers by name in reverse order:
92921>>>>>>>//
92921>>>>>>>//   For_All Customer DOWN Customer.Customer_Name DO
92921>>>>>>>//     showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92921>>>>>>>//   End_For_All
92921>>>>>>>//
92921>>>>>>>// To list only Customers with a Balance greater than their credit limit:
92921>>>>>>>//
92921>>>>>>>//   For_All Customer BY Index.1
92921>>>>>>>//     CONSTRAIN Customer.Balance GT Customer.Credit_Limit
92921>>>>>>>//     DO
92921>>>>>>>//       showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92921>>>>>>>//   End_For_All
92921>>>>>>>//
92921>>>>>>>// Constraint clauses are:
92921>>>>>>>//
92921>>>>>>>//   CONSTRAIN <File> RELATES TO <File> ...
92921>>>>>>>//   CONSTRAIN <File> AS <Expression>
92921>>>>>>>//   CONSTRAIN <File.Field> AS <Expression>
92921>>>>>>>//   CONSTRAIN <File.Field> BETWEEN <lowBound> AND <highBound>
92921>>>>>>>//
92921>>>>>>>// For example, to list all customers with a bad status whose names start
92921>>>>>>>// with "A" and which have not made a payment in thirty days:
92921>>>>>>>//
92921>>>>>>>//    For_All Customer BY Index.2       //Index.2 = <Status>+<Name>
92921>>>>>>>//      CONSTRAIN Customer.Status EQ BAD
92921>>>>>>>//      CONSTRAIN Customer.Customer_Name GE "A"
92921>>>>>>>//      CONSTRAIN Customer.Customer_Name LT "B"
92921>>>>>>>//      CONSTRAIN Customer.Last_Pymt_Date LE (Today - 30)
92921>>>>>>>//      DO
92921>>>>>>>//        showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92921>>>>>>>//    End_For_All
92921>>>>>>>//
92921>>>>>>>
92921>>>>>>>
92921>>>>>>>//This command starts the loop process body when constraints are used;
92921>>>>>>>//If no constraints are required, DO should be specified on the FOR_ALL
92921>>>>>>>//command line, and not on a line by itself
92921>>>>>>>//
92921>>>>>>>
92921>>>>>>>//Ends a For_All loop
92921>>>>>>>//
92921>>>>>>>
92921>>>>>>>
92921>>>>>
92921>>>>>
92921>>>>>Class cDbUpdateVersion is a cObject
92922>>>>>
92922>>>>>    Procedure Construct_Object    
92924>>>>>        Boolean bOnCreateExecuted bUseCustomDbVersion
92924>>>>>        String[] aSQLQueryMessages
92925>>>>>        
92925>>>>>        Forward Send Construct_Object
92927>>>>>
92927>>>>>        // cDbUpdateHandler object event.
92927>>>>>        Delegate Get Private.pbOnCreateExecuted to bOnCreateExecuted
92929>>>>>        If (bOnCreateExecuted = False) Begin    
92931>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
92933>>>>>            If (bUseCustomDbVersion = False) Begin
92935>>>>>                Delegate Send CheckAutoCreateDbVersionTable 
92937>>>>>            End
92937>>>>>>
92937>>>>>            Delegate Send OnCreate
92939>>>>>            Delegate Set Private.pbOnCreateExecuted to True
92941>>>>>        End
92941>>>>>>
92941>>>>>
92941>>>>>        // Don't touch! It is used by class logic to indicate if the OnUpdate
92941>>>>>        // event was triggered, thus an actual change of the database was made.
92941>>>>>        Property Boolean pbVersionUpdate False
92942>>>>>
92942>>>>>        // This property must be manually set within each cDbUpdateVersion object
92942>>>>>        // by the programmer, to a consecutive number.
92942>>>>>        Property Number pnVersionNumber
92943>>>>>
92943>>>>>        Property Boolean pbUseConnectionID True
92944>>>>>        Property Boolean private.pbToANSI   True
92945>>>>>        Property Boolean private.pbRecnum   True
92946>>>>>        Property Boolean private.pbCopyData True
92947>>>>>        Property Boolean private.pbApiTableUpdateAuto False
92948>>>>>        Property Boolean private.pbCompareDate_DateTime False
92949>>>>>        Property Boolean private.pbCompareIndexAscending False
92950>>>>>        Property Boolean private.pbCompareIndexUppercase False
92951>>>>>        Property String private.psSchema
92952>>>>>        Property String private.psBaseTableSpace
92953>>>>>        Property String private.psLongTableSpace
92954>>>>>        Property String private.psIndexTableSpace
92955>>>>>
92955>>>>>        // Driver default value settings:
92955>>>>>        Property String private.psDriverDefaultValueASCII    ""
92956>>>>>        Property String private.psDriverDefaultValueBinary   ""
92957>>>>>        Property String private.psDriverDefaultValueDate     ""
92958>>>>>        Property String private.psDriverDefaultValueDateTime ""
92959>>>>>        Property String private.psDriverDefaultValueNumeric  ""
92960>>>>>        Property String private.psDriverDefaultValueText     ""
92961>>>>>
92961>>>>>        // Driver "nullability" settings:
92961>>>>>        Property Boolean private.pbDriverDefaultNullableASCII    False
92962>>>>>        Property Boolean private.pbDriverDefaultNullableBinary   False
92963>>>>>        Property Boolean private.pbDriverDefaultNullableDate     False
92964>>>>>        Property Boolean private.pbDriverDefaultNullableDateTime False
92965>>>>>        Property Boolean private.pbDriverDefaultNullableNumeric  False
92966>>>>>        Property Boolean private.pbDriverDefaultNullableText     False
92967>>>>>
92967>>>>>        // paSQLQueryMessages is a property of the container class cDbUpdateHandler.
92967>>>>>        // It is being used to gather ESQL message replies, and is output to the log file
92967>>>>>        // if pbVerboseState = True in the cDbUpdateHandler object.
92967>>>>>        // (See: Procedure Set pbDatabaseWasUpdated in the cDbUpdateHandler class)
92967>>>>>        // We reset it here for each cDbUpdateVersion object
92967>>>>>        Delegate Set paSQLQueryMessages to aSQLQueryMessages
92969>>>>>    End_Procedure
92970>>>>>
92970>>>>>    // *** Main hook event message ***
92970>>>>>    // Place your database update logic here!
92970>>>>>    Procedure OnUpdate
92972>>>>>    End_Procedure
92973>>>>>
92973>>>>>    // These properties also exists in the cDbUpdateFunctionLibray that is
92973>>>>>    // imported to the cDbUpdateHandler container class which should be a
92973>>>>>    // parent object to this object. To have the Studio's Property Panel
92973>>>>>    // "behave" aka show these properties we need to duplicate them in this
92973>>>>>    // class and "relay" them to the parent object.
92973>>>>>    Procedure Set pbToANSI Boolean bState
92975>>>>>        Set private.pbToANSI  to bState
92976>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92977>>>>>        Delegate Set pbToANSI to bState
92979>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92980>>>>>    End_Procedure
92981>>>>>
92981>>>>>    Function pbToANSI Returns Boolean
92983>>>>>        Function_Return (private.pbToAnsi(Self))
92984>>>>>    End_Function
92985>>>>>
92985>>>>>    Procedure Set pbRecnum Boolean bState
92987>>>>>        Set private.pbRecnum  to bState
92988>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92989>>>>>        Delegate Set pbRecnum to bState
92991>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92992>>>>>    End_Procedure
92993>>>>>
92993>>>>>    Function pbRecnum Returns Boolean
92995>>>>>        Function_Return (private.pbRecnum(Self))
92996>>>>>    End_Function
92997>>>>>
92997>>>>>    Procedure Set pbCopyData Boolean bState
92999>>>>>        Set private.pbCopyData  to bState
93000>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93001>>>>>        Delegate Set pbCopyData to bState
93003>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93004>>>>>    End_Procedure
93005>>>>>
93005>>>>>    Function pbCopyData Returns Boolean
93007>>>>>        Function_Return (private.pbCopyData(Self))
93008>>>>>    End_Function
93009>>>>>
93009>>>>>    // ToDo: Should we put these four properties under another "Property Panel" section?
93009>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
93011>>>>>        Set private.pbApiTableUpdateAuto  to bState
93012>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93013>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
93014>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93015>>>>>    End_Procedure
93016>>>>>
93016>>>>>    Function pbApiTableUpdateAuto Returns Boolean
93018>>>>>        Function_Return (private.pbApiTableUpdateAuto(Self))
93019>>>>>    End_Function
93020>>>>>
93020>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
93022>>>>>        Set private.pbCompareDate_DateTime  to bState
93023>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93024>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
93025>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93026>>>>>    End_Procedure
93027>>>>>
93027>>>>>    Function pbCompareDate_DateTime Returns Boolean
93029>>>>>        Function_Return (private.pbCompareDate_DateTime(Self))
93030>>>>>    End_Function
93031>>>>>
93031>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
93033>>>>>        Set private.pbCompareIndexAscending  to bState
93034>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93035>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
93036>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93037>>>>>    End_Procedure
93038>>>>>
93038>>>>>    Function pbCompareIndexAscending Returns Boolean
93040>>>>>        Function_Return (private.pbCompareIndexAscending(Self))
93041>>>>>    End_Function
93042>>>>>
93042>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
93044>>>>>        Set private.pbCompareIndexUppercase  to bState
93045>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93046>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
93047>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93048>>>>>    End_Procedure
93049>>>>>
93049>>>>>    Function pbCompareIndexUppercase Returns Boolean
93051>>>>>        Function_Return (private.pbCompareIndexUppercase(Self))
93052>>>>>    End_Function
93053>>>>>
93053>>>>>    Procedure Set psSchema String sValue
93055>>>>>        Set private.psSchema  to sValue
93056>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93057>>>>>        Delegate Set psSchema to sValue
93059>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93060>>>>>    End_Procedure
93061>>>>>
93061>>>>>    // First retrieve the private value that might have been set in the object.
93061>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93061>>>>>    // it might have been specified in the SQLConnections.ini file.
93061>>>>>    Function psSchema Returns String
93063>>>>>        String sValue
93063>>>>>        Get private.psSchema to sValue
93064>>>>>        If (sValue = "") Begin
93066>>>>>            Get psSchema of ghoSQLConnectionHandler to sValue
93067>>>>>        End
93067>>>>>>
93067>>>>>        Function_Return sValue
93068>>>>>    End_Function
93069>>>>>
93069>>>>>    Procedure Set psBaseTableSpace String sValue
93071>>>>>        Set private.psBaseTableSpace  to sValue
93072>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93073>>>>>        Delegate Set psBaseTableSpace to sValue
93075>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93076>>>>>    End_Procedure
93077>>>>>
93077>>>>>    // First retrieve the private value that might have been set in the object.
93077>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93077>>>>>    // it might have been specified in the SQLConnections.ini file.
93077>>>>>    Function psBaseTableSpace Returns String
93079>>>>>        String sValue
93079>>>>>        Get private.psBaseTableSpace to sValue
93080>>>>>        If (sValue = "") Begin
93082>>>>>            Get psBaseTableSpace of ghoSQLConnectionHandler to sValue
93083>>>>>        End
93083>>>>>>
93083>>>>>        Function_Return sValue
93084>>>>>    End_Function
93085>>>>>
93085>>>>>    Procedure Set psLongTableSpace String sValue
93087>>>>>        Set private.psLongTableSpace  to sValue
93088>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93089>>>>>        Delegate Set psLongTableSpace to sValue
93091>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93092>>>>>    End_Procedure
93093>>>>>
93093>>>>>    // First retrieve the private value that might have been set in the object.
93093>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93093>>>>>    // it might have been specified in the SQLConnections.ini file.
93093>>>>>    Function psLongTableSpace Returns String
93095>>>>>        String sValue
93095>>>>>        Get private.psLongTableSpace to sValue
93096>>>>>        If (sValue = "") Begin
93098>>>>>            Get psLongTableSpace of ghoSQLConnectionHandler to sValue
93099>>>>>        End
93099>>>>>>
93099>>>>>        Function_Return sValue
93100>>>>>    End_Function
93101>>>>>
93101>>>>>    Procedure Set psIndexTableSpace String sValue
93103>>>>>        Set private.psIndexTableSpace  to sValue
93104>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93105>>>>>        Delegate Set psIndexTableSpace to sValue
93107>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93108>>>>>    End_Procedure
93109>>>>>
93109>>>>>    // First retrieve the private value that might have been set in the object.
93109>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93109>>>>>    // it might have been specified in the SQLConnections.ini file.
93109>>>>>    Function psIndexTableSpace Returns String
93111>>>>>        String sValue
93111>>>>>        Get private.psIndexTableSpace to sValue
93112>>>>>        If (sValue = "") Begin
93114>>>>>            Get psIndexTableSpace of ghoSQLConnectionHandler to sValue
93115>>>>>        End
93115>>>>>>
93115>>>>>        Function_Return sValue
93116>>>>>    End_Function
93117>>>>>
93117>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
93119>>>>>        Set private.psDriverDefaultValueASCII  to sValue
93120>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93121>>>>>        Delegate Set psDriverDefaultValueASCII to sValue
93123>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93124>>>>>    End_Procedure
93125>>>>>
93125>>>>>    // First retrieve the private value that might have been set in the object.
93125>>>>>    // If blank; get it from the parent object
93125>>>>>    Function psDriverDefaultValueASCII Returns String
93127>>>>>        String sValue
93127>>>>>        Get private.psDriverDefaultValueASCII to sValue
93128>>>>>        If (sValue = "") Begin
93130>>>>>            Delegate Get psDriverDefaultValueASCII to sValue
93132>>>>>        End
93132>>>>>>
93132>>>>>        Function_Return sValue
93133>>>>>    End_Function
93134>>>>>
93134>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
93136>>>>>        Set private.psDriverDefaultValueBinary  to sValue
93137>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93138>>>>>        Delegate Set psDriverDefaultValueBinary to sValue
93140>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93141>>>>>    End_Procedure
93142>>>>>
93142>>>>>    // First retrieve the private value that might have been set in the object.
93142>>>>>    // If blank; get it from the parent object
93142>>>>>    Function psDriverDefaultValueBinary Returns String
93144>>>>>        String sValue
93144>>>>>        Get private.psDriverDefaultValueBinary to sValue
93145>>>>>        If (sValue = "") Begin
93147>>>>>            Delegate Get psDriverDefaultValueBinary to sValue
93149>>>>>        End
93149>>>>>>
93149>>>>>        Function_Return sValue
93150>>>>>    End_Function
93151>>>>>
93151>>>>>    Procedure Set psDriverDefaultValueDate String sValue
93153>>>>>        Set private.psDriverDefaultValueDate  to sValue
93154>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93155>>>>>        Delegate Set psDriverDefaultValueDate to sValue
93157>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93158>>>>>    End_Procedure
93159>>>>>
93159>>>>>    // First retrieve the private value that might have been set in the object.
93159>>>>>    // If blank; get it from the parent object
93159>>>>>    Function psDriverDefaultValueDate Returns String
93161>>>>>        String sValue
93161>>>>>        Get private.psDriverDefaultValueDate to sValue
93162>>>>>        If (sValue = "") Begin
93164>>>>>            Delegate Get psDriverDefaultValueDate to sValue
93166>>>>>        End
93166>>>>>>
93166>>>>>        Function_Return sValue
93167>>>>>    End_Function
93168>>>>>
93168>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
93170>>>>>        Set private.psDriverDefaultValueDateTime  to sValue
93171>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93172>>>>>        Delegate Set psDriverDefaultValueDateTime to sValue
93174>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93175>>>>>    End_Procedure
93176>>>>>
93176>>>>>    // First retrieve the private value that might have been set in the object.
93176>>>>>    // If blank; get it from the parent object
93176>>>>>    Function psDriverDefaultValueDateTime Returns String
93178>>>>>        String sValue
93178>>>>>        Get private.psDriverDefaultValueDateTime to sValue
93179>>>>>        If (sValue = "") Begin
93181>>>>>            Delegate Get psDriverDefaultValueDateTime to sValue
93183>>>>>        End
93183>>>>>>
93183>>>>>        Function_Return sValue
93184>>>>>    End_Function
93185>>>>>
93185>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
93187>>>>>        Set private.psDriverDefaultValueNumeric  to sValue
93188>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93189>>>>>        Delegate Set psDriverDefaultValueNumeric to sValue
93191>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93192>>>>>    End_Procedure
93193>>>>>
93193>>>>>    // First retrieve the private value that might have been set in the object.
93193>>>>>    // If blank; get it from the parent object
93193>>>>>    Function psDriverDefaultValueNumeric Returns String
93195>>>>>        String sValue
93195>>>>>        Get private.psDriverDefaultValueNumeric to sValue
93196>>>>>        If (sValue = "") Begin
93198>>>>>            Delegate Get psDriverDefaultValueNumeric to sValue
93200>>>>>        End
93200>>>>>>
93200>>>>>        Function_Return sValue
93201>>>>>    End_Function
93202>>>>>
93202>>>>>    Procedure Set psDriverDefaultValueText String sValue
93204>>>>>        Set private.psDriverDefaultValueText  to sValue
93205>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93206>>>>>        Delegate Set psDriverDefaultValueText to sValue
93208>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93209>>>>>    End_Procedure
93210>>>>>
93210>>>>>    // First retrieve the private value that might have been set in the object.
93210>>>>>    // If blank; get it from the parent object
93210>>>>>    Function psDriverDefaultValueText Returns String
93212>>>>>        String sValue
93212>>>>>        Get private.psDriverDefaultValueText to sValue
93213>>>>>        If (sValue = "") Begin
93215>>>>>            Delegate Get psDriverDefaultValueText to sValue
93217>>>>>        End
93217>>>>>>
93217>>>>>        Function_Return sValue
93218>>>>>    End_Function
93219>>>>>
93219>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
93221>>>>>        Set private.pbDriverDefaultNullableASCII  to bState
93222>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93223>>>>>        Delegate Set pbDriverDefaultNullableASCII to bState
93225>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93226>>>>>    End_Procedure
93227>>>>>
93227>>>>>    // First retrieve the private value that might have been set in the object.
93227>>>>>    // If blank; get it from the parent object
93227>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
93229>>>>>        Boolean bState
93229>>>>>        Get private.pbDriverDefaultNullableASCII to bState
93230>>>>>        If (bState = False) Begin
93232>>>>>            Delegate Get pbDriverDefaultNullableASCII to bState
93234>>>>>        End
93234>>>>>>
93234>>>>>        Function_Return bState
93235>>>>>    End_Function
93236>>>>>
93236>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
93238>>>>>        Set private.pbDriverDefaultNullableBinary  to bState
93239>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93240>>>>>        Delegate Set pbDriverDefaultNullableBinary to bState
93242>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93243>>>>>    End_Procedure
93244>>>>>
93244>>>>>    // First retrieve the private value that might have been set in the object.
93244>>>>>    // If blank; get it from the parent object
93244>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
93246>>>>>        Boolean bState
93246>>>>>        Get private.pbDriverDefaultNullableBinary to bState
93247>>>>>        If (bState = False) Begin
93249>>>>>            Delegate Get pbDriverDefaultNullableBinary to bState
93251>>>>>        End
93251>>>>>>
93251>>>>>        Function_Return bState
93252>>>>>    End_Function
93253>>>>>
93253>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
93255>>>>>        Set private.pbDriverDefaultNullableDate  to bState
93256>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93257>>>>>        Delegate Set pbDriverDefaultNullableDate to bState
93259>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93260>>>>>    End_Procedure
93261>>>>>
93261>>>>>    // First retrieve the private value that might have been set in the object.
93261>>>>>    // If blank; get it from the parent object
93261>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
93263>>>>>        Boolean bState
93263>>>>>        Get private.pbDriverDefaultNullableDate to bState
93264>>>>>        If (bState = False) Begin
93266>>>>>            Delegate Get pbDriverDefaultNullableDate to bState
93268>>>>>        End
93268>>>>>>
93268>>>>>        Function_Return bState
93269>>>>>    End_Function
93270>>>>>
93270>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
93272>>>>>        Set private.pbDriverDefaultNullableDateTime  to bState
93273>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93274>>>>>        Delegate Set pbDriverDefaultNullableDateTime to bState
93276>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93277>>>>>    End_Procedure
93278>>>>>
93278>>>>>    // First retrieve the private value that might have been set in the object.
93278>>>>>    // If blank; get it from the parent object
93278>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
93280>>>>>        Boolean bState
93280>>>>>        Get private.pbDriverDefaultNullableDateTime to bState
93281>>>>>        If (bState = False) Begin
93283>>>>>            Delegate Get pbDriverDefaultNullableDateTime to bState
93285>>>>>        End
93285>>>>>>
93285>>>>>        Function_Return bState
93286>>>>>    End_Function
93287>>>>>
93287>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
93289>>>>>        Set private.pbDriverDefaultNullableNumeric  to bState
93290>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93291>>>>>        Delegate Set pbDriverDefaultNullableNumeric to bState
93293>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93294>>>>>    End_Procedure
93295>>>>>
93295>>>>>    // First retrieve the private value that might have been set in the object.
93295>>>>>    // If blank; get it from the parent object
93295>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
93297>>>>>        Boolean bState
93297>>>>>        Get private.pbDriverDefaultNullableNumeric to bState
93298>>>>>        If (bState = False) Begin
93300>>>>>            Delegate Get pbDriverDefaultNullableNumeric to bState
93302>>>>>        End
93302>>>>>>
93302>>>>>        Function_Return bState
93303>>>>>    End_Function
93304>>>>>
93304>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
93306>>>>>        Set private.pbDriverDefaultNullableText  to bState
93307>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93308>>>>>        Delegate Set pbDriverDefaultNullableText to bState
93310>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93311>>>>>    End_Procedure
93312>>>>>
93312>>>>>    // First retrieve the private value that might have been set in the object.
93312>>>>>    // If blank; get it from the parent object
93312>>>>>    Function pbDriverDefaultNullableText Returns Boolean
93314>>>>>        Boolean bState
93314>>>>>        Get private.pbDriverDefaultNullableText to bState
93315>>>>>        If (bState = False) Begin
93317>>>>>            Delegate Get pbDriverDefaultNullableText to bState
93319>>>>>        End
93319>>>>>>
93319>>>>>        Function_Return bState
93320>>>>>    End_Function
93321>>>>>
93321>>>>>    Function ApiTableConvertToSQL Handle hTable Returns Boolean
93323>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK
93323>>>>>        String sDriverID sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace
93323>>>>>
93323>>>>>        Get psDriverID to sDriverID
93324>>>>>        Get psSchema to sSchema
93325>>>>>
93325>>>>>        Get psBaseTableSpace to sBaseTableSpace
93326>>>>>        If (sBaseTableSpace <> "") Begin
93328>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93329>>>>>            Delegate Set psBaseTableSpace to sBaseTableSpace
93331>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93332>>>>>        End
93332>>>>>>
93332>>>>>
93332>>>>>        Get psLongTableSpace to sLongTableSpace
93333>>>>>        If (sLongTableSpace <> "") Begin
93335>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93336>>>>>            Delegate Set psLongTableSpace to sLongTableSpace
93338>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93339>>>>>        End
93339>>>>>>
93339>>>>>
93339>>>>>        Get psIndexTableSpace to sIndexTableSpace
93340>>>>>        If (sIndexTableSpace <> "") Begin
93342>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93343>>>>>            Delegate Set psIndexTableSpace to sIndexTableSpace
93345>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93346>>>>>        End
93346>>>>>>
93346>>>>>
93346>>>>>        Get pbUseConnectionID to bUseConnectionID
93347>>>>>        Get pbToANSI          to bToANSI
93348>>>>>        Get pbRecnum          to bRecnum
93349>>>>>        Get pbCopyData        to bCopyData
93350>>>>>
93350>>>>>        Get ApiTableConvertToSQL_Ex hTable sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
93351>>>>>
93351>>>>>        Function_Return bOK
93352>>>>>    End_Function
93353>>>>>
93353>>>>>//    Function ApiTableMoveAllToBackupFolder Returns Boolean
93353>>>>>//        Boolean bOK bExists
93353>>>>>//        String sDataPath sBackupFolder
93353>>>>>//        
93353>>>>>//        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
93353>>>>>//        Move CS_DUFBackupDataFolder to sBackupFolder
93353>>>>>//        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
93353>>>>>//        Get vFolderFormat sDataPath to sDataPath
93353>>>>>//        
93353>>>>>//        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
93353>>>>>//        If (bExists = False) Begin
93353>>>>>//            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
93353>>>>>//            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
93353>>>>>//            If (bExists = False) Begin
93353>>>>>//                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
93353>>>>>//                Function_Return False
93353>>>>>//            End                                                                                                                                            
93353>>>>>//            Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
93353>>>>>//            Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
93353>>>>>//            Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
93353>>>>>//            Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
93353>>>>>//        End
93353>>>>>//        
93353>>>>>//        Set Message_Text of ghoStatusPanel to ""
93353>>>>>//        Function_Return bOK
93353>>>>>//    End_Function
93353>>>>>//
93353>>>>>    // This is automatically called after the OnUpdate
93353>>>>>    // event has been executed. It will automatically update the
93353>>>>>    // version database field/column with the "pnVersionNumber"
93353>>>>>    // value of the parent cDbUpdateHandler class - if it has been changed.
93353>>>>>    Procedure UpdateVersionColumnValue
93355>>>>>        Number nVersion nCurrentValue
93355>>>>>        Integer hTable iColumn
93355>>>>>        Boolean bVersionUpdate bDbUpdateErrorHasOccured bUseCustomDbVersion
93355>>>>>
93355>>>>>        Move False to Err
93356>>>>>        Move 0 to LastErr
93357>>>>>        // This is a property of the container class; cDbUpdateHandler that gets set when
93357>>>>>        // an error occurres when processing ESQL or database API messages of the cDbUpdateFunctionLibrary.
93357>>>>>        Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
93359>>>>>        Get pbVersionUpdate to bVersionUpdate
93360>>>>>
93360>>>>>        If (bVersionUpdate = True and bDbUpdateErrorHasOccured = False) Begin
93362>>>>>            Get pnVersionNumber to nVersion
93363>>>>>            Delegate Get piDbVersionFileNumber  to hTable
93365>>>>>            Delegate Get piDbVersionFieldNumber to iColumn
93367>>>>>            // NB! We need to permanently close tables as they e.g. now might no longer be embedded
93367>>>>>            // but instead SQL tables. If we don't the "old" embedded table will be opened instead.
93367>>>>>            Close DF_ALL DF_PERMANENT
93368>>>>>
93368>>>>>            Open hTable
93370>>>>>
93370>>>>>            // It is then the developer responsibility to take care of finding
93370>>>>>            // the correct record that is to be updated (The DbVersion table is not used). 
93370>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
93372>>>>>            If (bUseCustomDbVersion = True) Begin
93374>>>>>                Delegate Send OnFindVersionRecord   // cDbUpdateHandler object event (Programmer's hook!).
93376>>>>>            End
93376>>>>>>
93376>>>>>
93376>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
93379>>>>>            If (nCurrentValue < nVersion) Begin
93381>>>>>                Lock
93382>>>>>>
93382>>>>>                    If (bUseCustomDbVersion = False) Begin
93384>>>>>                        Vfind hTable Recnum GE                            
93386>>>>>                    End
93386>>>>>>
93386>>>>>                    Set_Field_Value hTable iColumn to nVersion
93389>>>>>                    SaveRecord hTable
93390>>>>>                Unlock
93391>>>>>>
93391>>>>>            End
93391>>>>>>
93391>>>>>            Close hTable
93392>>>>>        End
93392>>>>>>
93392>>>>>    End_Procedure
93393>>>>>
93393>>>>>// Property of the container object (cDbUpdateHandler)
93393>>>>>Register_Function piCurrentErrorHandlerID Returns Integer
93393>>>>>
93393>>>>>    Procedure End_Construct_Object
93395>>>>>        Forward Send End_Construct_Object
93397>>>>>        Send ProcessUpdate True
93398>>>>>    End_Procedure
93399>>>>>    
93399>>>>>    Procedure ProcessUpdate Boolean bShouldTestForDuplicateVersionNumbers
93401>>>>>        Number nVersion nCurrentValue
93401>>>>>        Integer hTable iColumn iSize iDbVersionFileNumber iStatus iErrorObject
93401>>>>>        Boolean bStopOnFirstError bDbUpdateErrorHasOccured bContinueOnError bOpened 
93401>>>>>        Boolean bSystemTable bUseCustomDbVersion bTableExists bOnPreUpdateExecuted bExitIfDebuggerActive
93401>>>>>        String sObjectName
93401>>>>>        tDbVersionInfo[] dbVersionInfoArray
93401>>>>>        tDbVersionInfo[] dbVersionInfoArray
93402>>>>>
93402>>>>>        Move 0 to nCurrentValue
93403>>>>>        Delegate Set Private.pbUpdateVersionObjectError to False
93405>>>>>
93405>>>>>        Delegate Get pbExitIfDebuggerActive to bExitIfDebuggerActive
93407>>>>>        If (IsDebuggerPresent() and bExitIfDebuggerActive = True) Begin
93409>>>>>            Delegate Get piOrgErrorHandlerID to iErrorObject
93411>>>>>            If (iErrorObject <> 0) Begin
93413>>>>>                Move iErrorObject to Error_Object_Id
93414>>>>>            End
93414>>>>>>
93414>>>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio! You need to run this program from outside of the Studio."
93415>>>>>>
93415>>>>>            Send Exit_Application
93416>>>>>        End
93416>>>>>>
93416>>>>>        // If the programmer forgot to set the version number we do not allow for the application
93416>>>>>        // to continue to run, as this potentially could endanger the integrity of the database. E.g. if
93416>>>>>        // one database update is depended on an earlier update and that earlier version
93416>>>>>        // update was never executed it could lead to disastrous results.
93416>>>>>        // This is a programmer error and should be discovered before any customer sees it. Thus no point in translating...
93416>>>>>        Get pnVersionNumber to nVersion
93417>>>>>        If (nVersion < 0) Begin
93419>>>>>            Get piCurrentErrorHandlerID to Error_Object_Id
93420>>>>>            Move (Name(Self)) to sObjectName
93421>>>>>            Error DFERR_PROGRAM ("The pnVersionNumber property was not set properly by the programmer for the following object; Program will now exit!\n\n" + sObjectName)
93422>>>>>>
93422>>>>>            Send Exit_Application
93423>>>>>        End
93423>>>>>>
93423>>>>>
93423>>>>>        // These are send to the parent container object (cDbUpdateHandler). The order is very sensitive!
93423>>>>>        // Hook event for the developer to e.g. create a database before the update events starts.
93423>>>>>        Delegate Get Private.pbOnPreUpdateExecuted to bOnPreUpdateExecuted
93425>>>>>        If (bOnPreUpdateExecuted = False) Begin
93427>>>>>            Delegate Send OnPreUpdate
93429>>>>>            Delegate Set Private.pbOnPreUpdateExecuted to True
93431>>>>>        End
93431>>>>>>
93431>>>>>        
93431>>>>>        Delegate Get piDbVersionFileNumber to iDbVersionFileNumber
93433>>>>>        
93433>>>>>        Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
93435>>>>>        If (bUseCustomDbVersion = False) Begin
93437>>>>>//            Delegate Send CheckAutoCreateDbVersionTable // cDbUpdateHandler object event.
93437>>>>>        End
93437>>>>>>
93437>>>>>        Else Begin
93438>>>>>            Get _UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
93439>>>>>            If (bTableExists = False) Begin
93441>>>>>                Delegate Send OnCreateCustomDbVersionTable
93443>>>>>            End
93443>>>>>>
93443>>>>>        End
93443>>>>>>
93443>>>>>        
93443>>>>>        // We now check that two or more cDbVersion objects does not have the same pnVersionNumber.
93443>>>>>        // Note that the paDbVersionInfoArray is a property of the container object (cDbUpdateHandler)
93443>>>>>        If (bShouldTestForDuplicateVersionNumbers = True) Begin
93445>>>>>            Delegate Get paDbVersionInfoArray to dbVersionInfoArray
93447>>>>>            Move (SizeOfArray(dbVersionInfoArray)) to iSize
93448>>>>>            Move nVersion to dbVersionInfoArray[iSize].nVersionNumber
93449>>>>>            Move (Self)   to dbVersionInfoArray[iSize].hObject
93450>>>>>            Delegate Set paDbVersionInfoArray to dbVersionInfoArray
93452>>>>>            Delegate Send CheckForDuplicates nVersion   // cDbUpdateHandler object event.
93454>>>>>        End
93454>>>>>>
93454>>>>>
93454>>>>>        Delegate Get piDbVersionFileNumber  to hTable
93456>>>>>        Delegate Get piDbVersionFieldNumber to iColumn
93458>>>>>
93458>>>>>        Open hTable
93460>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
93463>>>>>        If (bOpened = False) Begin
93465>>>>>            Send Stop_Box CS_DUF_DbUpdateTableMissing
93466>>>>>            Send Exit_Application
93467>>>>>        End
93467>>>>>>
93467>>>>>        
93467>>>>>        // It can happen that the table isn't initialized with a record even though it is a system table,
93467>>>>>        // in case we take care of it here.
93467>>>>>        Get_Attribute DF_FILE_STATUS of hTable to iStatus
93470>>>>>        If (iStatus = DF_FILE_INACTIVE) Begin
93472>>>>>            Vfind hTable 0 GT
93474>>>>>        End
93474>>>>>>
93474>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemTable
93477>>>>>        If (bSystemTable = True) Begin
93479>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
93482>>>>>        End
93482>>>>>>
93482>>>>>        Else Begin
93483>>>>>            If (bUseCustomDbVersion = True) Begin
93485>>>>>                Send OnFindVersionRecord
93486>>>>>                Get_Field_Value hTable iColumn to nCurrentValue
93489>>>>>            End
93489>>>>>>
93489>>>>>        End
93489>>>>>>
93489>>>>>
93489>>>>>        Close hTable
93490>>>>>
93490>>>>>        // We also guard from missing 'DatabaseVersionInfoTable' and column properties settings.
93490>>>>>        // If not set we do nothing.
93490>>>>>        If (nCurrentValue < nVersion) Begin
93492>>>>>
93492>>>>>            // If pbStopOnFirstError is True in the parent, the idea is that we do _no_ further
93492>>>>>            // execution of database update code. So if true _and_ one error
93492>>>>>            // has already occured; we're out of here.
93492>>>>>            Delegate Get pbStopOnFirstError        to bStopOnFirstError
93494>>>>>            Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
93496>>>>>            If (bStopOnFirstError = True) Begin
93498>>>>>                If (bDbUpdateErrorHasOccured = True) Begin
93500>>>>>                    Procedure_Return
93501>>>>>                End
93501>>>>>>
93501>>>>>            End
93501>>>>>>
93501>>>>>
93501>>>>>            // This is send to the parent container object (cDbUpdateHandler)
93501>>>>>            Delegate Send InitDatabaseUpdate (Self)    // cDbUpdateHandler object event.
93503>>>>>
93503>>>>>            // If the parent property pbContinueOnError = False, an update
93503>>>>>            // of a following cDbUpdateVersion object should not take place and we're out of here.
93503>>>>>            Delegate Get pbContinueOnError to bContinueOnError
93505>>>>>            If (bContinueOnError = False and bDbUpdateErrorHasOccured = True) Begin
93507>>>>>                Procedure_Return
93508>>>>>            End
93508>>>>>>
93508>>>>>
93508>>>>>            Delegate Set pnCurrentVersionUpdate to nVersion
93510>>>>>
93510>>>>>            Set Title_Text of ghoStatusPanel to (CS_DUF_UpdateVersion * CS_DUF_UpdateFromVersion * String(nCurrentValue) * CS_DUF_UpdateToVersion * String(nVersion))
93511>>>>>
93511>>>>>            // *** Programmer's main hook event for database update functions:
93511>>>>>            Send OnUpdate
93512>>>>>
93512>>>>>            Set pbVersionUpdate to True
93513>>>>>            Send UpdateVersionColumnValue
93514>>>>>            Delegate Set pbDatabaseWasUpdated to True   // cDbUpdateHandler property.
93516>>>>>        End
93516>>>>>>
93516>>>>>
93516>>>>>    End_Procedure
93517>>>>>
93517>>>>>End_Class
93518>>>Use cDbUpdateUserCount.pkg
Including file: cDbUpdateUserCount.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.pkg)
93518>>>>>//****************************************************************************
93518>>>>>// $Module type: Class
93518>>>>>// $Module name: cDbUpdateUserCount.pkg
93518>>>>>// $Author     : Emil Stojanov Quantaris B.V.
93518>>>>>//
93518>>>>>//               Collected from DAW's newsgroups.
93518>>>>>//
93518>>>>>// Description : It uses the windows API to lock bytes in a file.
93518>>>>>//               If the application or PC craches it will release the lock
93518>>>>>//               automatically.
93518>>>>>//
93518>>>>>// Note 1      : It will count the number of running app's, so if a
93518>>>>>//               user starts the app twice on one machine it will count as two users.
93518>>>>>// Note 2      : The class was originally named cUserCount by Emil Stojanov.
93518>>>>>//               However, to not conflict with any other usage of this class it was
93518>>>>>//               renamed to "fit" into the "Database Update Framework" (cDbUpdateHandler
93518>>>>>//               and cDbUpdateVersion classes)
93518>>>>>//
93518>>>>>// $Rev History:
93518>>>>>//    2008-10-17  Module header created (Militaty data format)
93518>>>>>//    2008-10-17  Minor changes by Nils G Svedmyr. Created UI text constants
93518>>>>>//                for easy translation to other languages.
93518>>>>>//                Added the tUserCount struct for easier passing of parameters.
93518>>>>>//                Added the ApplicationPath message.
93518>>>>>//****************************************************************************
93518>>>>>Use LanguageText.pkg
93518>>>>>Use cDbUpdateUserCount.inc
Including file: cDbUpdateUserCount.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.inc)
93518>>>>>>>Use GlobalFunctionsProcedures.pkg
93518>>>>>>>// Sample:
93518>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
93518>>>>>>>
93518>>>>>>>
93518>>>>>>>// Symbols used by UserCounting
93518>>>>>>>    Define GENERIC_READ         for |CI$80000000
93518>>>>>>>    Define GENERIC_WRITE        for |CI$40000000
93518>>>>>>>    Define GENERIC_EXECUTE      for |CI$20000000
93518>>>>>>>    Define GENERIC_ALL          for |CI$10000000
93518>>>>>>>    Define CREATE_NEW           for 1
93518>>>>>>>    Define CREATE_ALWAYS        for 2
93518>>>>>>>    Define OPEN_EXISTING        for 3
93518>>>>>>>    Define OPEN_ALWAYS          for 4
93518>>>>>>>    Define TRUNCATE_EXISTING    for 5
93518>>>>>>>    Define FILE_BEGIN           for 0
93518>>>>>>>    Define FILE_CURRENT         for 1
93518>>>>>>>    Define FILE_END             for 2
93518>>>>>>>    Define FILE_SHARE_READ      for |CI$00000001
93518>>>>>>>    Define FILE_SHARE_WRITE     for |CI$00000002
93518>>>>>>>    Define FILE_SHARE_DELETE    for |CI$00000004
93518>>>>>>>    Define FILE_FLAG_WRITE_THROUGH            for |CI$80000000
93518>>>>>>>    Define _MAX_PATH  for 260
93518>>>>>>>    Define _MAX_DRIVE for 3
93518>>>>>>>    Define _MAX_DIR   for 256
93518>>>>>>>    Define _MAX_FNAME for 256
93518>>>>>>>    Define _MAX_EXT   for 256
93518>>>>>>>
93518>>>>>>>External_Function Win32_CreateFile "CreateFileA" KERNEL32.DLL ;    Pointer lpFileName ;              // file name    DWord dwDesiredAccess ;           // access mode    DWord dwShareMode ;               // share mode    Pointer lpSecurityAttributes ;    // SD    DWord dwCreationDisposition ;     // how to create    DWord dwFlagsAndAttributes ;      // file attributes    Handle hTemplateFile ;            // handle to template file    Returns Handle
93519>>>>>>>
93519>>>>>>>External_Function Win32_ReadFile "ReadFile" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Pointer lpBuffer ;              // pointer to the buffer that receives the data    dWord nNumberOfBytesToRead ;    // number of bytes to read    Pointer lpNumberOfBytesRead ;   // number of bytes read    Pointer lpOverlapped ;          // pointer to an overlapped structure    Returns Integer
93520>>>>>>>
93520>>>>>>>External_Function Win32_WriteFile "WriteFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    Pointer lpBuffer ;                  // pointer to buffer containing data to write    dWord nNumberOfBytesToWrite ;       // number of bytes to write    Pointer lpNumberOfBytesWritten ;    // number of bytes written    Pointer lpOverlapped ;              // pointer to an overlapped structure    Returns Integer
93521>>>>>>>
93521>>>>>>>External_Function Win32_LockFile "LockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToLockLow ;     // low-order word of length    dWord nNumberOfBytesToLockHigh ;    // high-order word of length    Returns Integer
93522>>>>>>>
93522>>>>>>>External_Function Win32_UnlockFile "UnlockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToUnLockLow ;   // low-order word of length    dWord nNumberOfBytesToUnLockHigh ;  // high-order word of length    Returns Integer
93523>>>>>>>
93523>>>>>>>External_Function Win32_SetFilePointer "SetFilePointer" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Integer lDistanceToMove ;       // bytes to move pointer (low-order 32-bits)    Pointer lpDistanceToMoveHigh ;  // bytes to move pointer (high-order 32-bits)    dWord dwMoveMethod ;            // starting point    Returns dWord
93524>>>>>>>
93524>>>>>>>External_Function Win32_CloseHandle "CloseHandle" KERNEL32.DLL ;    Handle hObject ;    // handle to object    Returns Integer
93525>>>>>>>
93525>>>>>>>External_Function SetDefaultPrinterEf "SetDefaultPrinterA" winspool.drv Pointer lpPrinter Returns Boolean
93526>>>>>>>// Sample:
93526>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
93526>>>>>>>Function DoSetDefaultPrinter String sPrinter Returns Boolean
93528>>>>>>>    Boolean bReturn
93528>>>>>>>    Move (Utf8ToAnsi(sPrinter)) to sPrinter
93529>>>>>>>    Move (sPrinter + (Character(0))) to sPrinter
93530>>>>>>>    Move (SetDefaultPrinterEf(AddressOf(sPrinter))) to bReturn
93531>>>>>>>    Function_Return bReturn
93532>>>>>>>End_Function
93533>>>>>Use vWin32fh.pkg
93533>>>>>Use seq_chnl.pkg
93533>>>>>
93533>>>>>// User interface constant strings:
93533>>>>>    Define CS_UserCountError            for "User count error:"
93533>>>>>    Define CS_UnableToInitUserCountSys  for "Unable to initialize user counting system!"
93533>>>>>    Define CS_UnableResetUserCountSys   for "Error resetting usercounting system!"
93533>>>>>    Define CS_ErrorAdvancingPointer     for "Error advancing file pointer!"
93533>>>>>    Define CS_MaxNoOfUserExceeded       for "Maximum number of users exceeded!"
93533>>>>>
93533>>>>>
93533>>>>>
93533>>>>>
93533>>>>>
93533>>>>>
93533>>>>>
93533>>>>>
93533>>>>>
93533>>>>>
93533>>>>>
93533>>>>>
93533>>>>>
93533>>>>>    Struct tUserCount
93533>>>>>        Integer iUserCount
93533>>>>>        Integer iError
93533>>>>>        String  sErrorTxt
93533>>>>>    End_Struct
93533>>>>>
93533>>>>>    Define CI_UserCountMaxUsers for 9999
93533>>>>>
93533>>>>>Class cDbUpdateUserCount is a cObject
93534>>>>>    Procedure Construct_Object
93536>>>>>        Forward Send Construct_Object
93538>>>>>
93538>>>>>        Property String  psLockFileName
93539>>>>>        Property Integer piMaxUsers
93540>>>>>        Property Boolean pbCheckDataFlexUserCount True
93541>>>>>
93541>>>>>        Property Handle  phUserCountFile
93542>>>>>        Property Integer pdwLockPosition
93543>>>>>    End_Procedure
93544>>>>>
93544>>>>>    Function IsProgramRunning Returns Boolean
93546>>>>>        tUserCount UserCount
93546>>>>>        tUserCount UserCount
93546>>>>>
93546>>>>>        Get CheckUserCount to UserCount
93547>>>>>
93547>>>>>        Function_Return (UserCount.iUserCount > 1)
93548>>>>>    End_Function
93549>>>>>
93549>>>>>    // Returns the full path of the Application (no trailing "\")
93549>>>>>    Function ApplicationPath Returns String
93551>>>>>        String sApplicationFileName sPath
93551>>>>>        Integer iNumChars iRetval
93551>>>>>
93551>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
93552>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
93553>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
93554>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
93555>>>>>        Move (CString(sApplicationFileName)) to sPath
93556>>>>>
93556>>>>>        Function_Return sPath
93557>>>>>    End_Function
93558>>>>>
93558>>>>>    Function OpenUserCountFile String sFileName Returns Handle
93560>>>>>        Handle  hFile
93560>>>>>        Pointer pFileName
93560>>>>>        String sPath sFile
93560>>>>>        Integer iCh
93560>>>>>
93560>>>>>        Move (Addressof(sFileName)) to pFileName
93561>>>>>        Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
93562>>>>>
93562>>>>>        // If lock file doesn't exist, create it.
93562>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
93564>>>>>            Get ApplicationPath to sPath
93565>>>>>            Get vFolderFormat sPath to sPath
93566>>>>>            Move (sPath + psLockFileName(Self)) to sFile
93567>>>>>            Get Seq_Open_Output_Channel sFile to iCh
93568>>>>>            If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
93570>>>>>                Function_Return 0
93571>>>>>            End
93571>>>>>>
93571>>>>>            Direct_Output channel iCh sFile
93573>>>>>                Write channel iCh ""
93575>>>>>            Send Seq_Close_Channel iCh
93576>>>>>            Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
93577>>>>>        End
93577>>>>>>
93577>>>>>
93577>>>>>        Function_Return hFile
93578>>>>>    End_Function
93579>>>>>
93579>>>>>    Function CloseUserCountFile Handle hFile Returns Integer
93581>>>>>        Integer iReturnValue 
93581>>>>>        Boolean bOK
93581>>>>>
93581>>>>>        Move (Win32_CloseHandle(hFile)) to iReturnValue
93582>>>>>        If (iReturnValue = 0) Begin
93584>>>>>            Move False to bOK
93585>>>>>        End
93585>>>>>>
93585>>>>>        Else Begin
93586>>>>>            Move True to bOK
93587>>>>>        End
93587>>>>>>
93587>>>>>        Function_Return bOK
93588>>>>>    End_Function
93589>>>>>
93589>>>>>    Function UnlockUserCountFile Handle hFile dWord dwLockPos Returns Integer
93591>>>>>        Integer iReturnValue
93591>>>>>        Boolean bOK
93591>>>>>
93591>>>>>        Move (Win32_UnLockFile(hFile, dwLockPos, 0, 1, 0)) to iReturnValue
93592>>>>>        If (iReturnValue = 0) Begin
93594>>>>>            Move False to bOK
93595>>>>>        End
93595>>>>>>
93595>>>>>        Else Begin
93596>>>>>            Move True to bOK
93597>>>>>        End           
93597>>>>>>
93597>>>>>        Function_Return bOK
93598>>>>>    End_Function
93599>>>>>
93599>>>>>    Function ReSetUserCountPointer Handle hFile Returns dWord
93601>>>>>        dWord dwCurrPos
93601>>>>>
93601>>>>>        Move (Win32_SetFilePointer(hFile, 0, 0, FILE_BEGIN)) to dwCurrPos
93602>>>>>        Function_Return dwCurrPos
93603>>>>>    End_Function
93604>>>>>
93604>>>>>    Function SetUserCountPointer Handle hFile Integer iAdvance Returns dWord
93606>>>>>        DWord dwCurrPos
93606>>>>>
93606>>>>>        Move (Win32_SetFilePointer(hFile, iAdvance, 0, FILE_CURRENT)) to dwCurrPos
93607>>>>>        Function_Return dwCurrPos
93608>>>>>    End_Function
93609>>>>>
93609>>>>>    Function ReadUserCountFile Handle hFile Returns Boolean
93611>>>>>        Integer iReturnValue                               
93611>>>>>        Boolean bOK
93611>>>>>        String  sBuffer
93611>>>>>        Pointer pBuffer
93611>>>>>        String  sSize
93611>>>>>        Pointer pSize
93611>>>>>
93611>>>>>        Move (Repeat((Character(0)),5)) to sBuffer
93612>>>>>        Move (AddressOf(sBuffer)) to pBuffer
93613>>>>>
93613>>>>>        Move (Repeat((Character(0)),4)) to sSize
93614>>>>>        Move (AddressOf(sSize)) to pSize
93615>>>>>
93615>>>>>        Move (Win32_ReadFile(hFile, pBuffer, 1, pSize, 0)) to iReturnValue
93616>>>>>        If (iReturnValue = 0) Begin
93618>>>>>            Move False to bOK
93619>>>>>        End
93619>>>>>>
93619>>>>>        Else Begin
93620>>>>>            Move True to bOK
93621>>>>>        End                 
93621>>>>>>
93621>>>>>        Function_Return bOK
93622>>>>>    End_Function
93623>>>>>
93623>>>>>    Function LockUserCountFile Handle hFile dWord dwFilePos Returns Integer
93625>>>>>        Integer iReturnValue
93625>>>>>
93625>>>>>        Move (Win32_LockFile(hFile, dwFilePos, 0, 1, 0)) to iReturnValue
93626>>>>>        Function_Return iReturnValue
93627>>>>>    End_Function
93628>>>>>
93628>>>>>    Procedure DoCheckUserCount
93630>>>>>        tUserCount UserCount
93630>>>>>        tUserCount UserCount
93630>>>>>
93630>>>>>        Get CheckUserCount to UserCount
93631>>>>>        // If all is fine, we're done.
93631>>>>>        If (UserCount.iError = 0) Begin
93633>>>>>            Procedure_Return
93634>>>>>        End
93634>>>>>>
93634>>>>>
93634>>>>>        Send UserError (CS_UserCountError * String(UserCount.iError) + "\n" + UserCount.sErrorTxt)
93635>>>>>
93635>>>>>        If (UserCount.iUserCount = CI_UserCountMaxUsers) Begin
93637>>>>>            Abort
93638>>>>>>
93638>>>>>        End
93638>>>>>>
93638>>>>>    End_Procedure
93639>>>>>
93639>>>>>    Function CheckUserCount Returns tUserCount
93641>>>>>        Handle  hFile
93641>>>>>        String  sPath sFile
93641>>>>>        Integer iResult
93641>>>>>        DWord   dwFilePos
93641>>>>>        Integer bLocked
93641>>>>>        Integer iMaxUsers
93641>>>>>        Integer iCurUser
93641>>>>>        tUserCount UserCount
93641>>>>>        tUserCount UserCount
93641>>>>>
93641>>>>>        Move 0 to UserCount.iError
93642>>>>>
93642>>>>>        Get phUserCountFile to hFile
93643>>>>>        If (not(hFile)) Begin
93645>>>>>            Get ApplicationPath to sPath
93646>>>>>            Get vFolderFormat sPath to sPath
93647>>>>>            Move (sPath + psLockFileName(Self)) to sFile
93648>>>>>            Get OpenUserCountFile sFile to hFile
93649>>>>>            If (hFile = INVALID_HANDLE_VALUE) Begin
93651>>>>>                Move 1 to UserCount.iUserCount
93652>>>>>                Move 1 to UserCount.iError
93653>>>>>                Move CS_UnableToInitUserCountSys to UserCount.sErrorTxt
93654>>>>>                Function_Return UserCount
93655>>>>>            End
93655>>>>>>
93655>>>>>            Else Begin
93656>>>>>                Move False to bLocked
93657>>>>>                Set phUserCountFile to hFile
93658>>>>>                Get piMaxUsers to iMaxUsers
93659>>>>>
93659>>>>>                // Set Filepointer to beginning of the file
93659>>>>>                Get ResetUserCountPointer hFile to dwFilePos
93660>>>>>                If (dwFilePos = -1) Begin
93662>>>>>                    Move 1 to UserCount.iUserCount
93663>>>>>                    Move 2 to UserCount.iError
93664>>>>>                    Move CS_UnableResetUserCountSys to UserCount.sErrorTxt
93665>>>>>                    Function_Return UserCount
93666>>>>>                End
93666>>>>>>
93666>>>>>                For iCurUser from 1 to iMaxUsers
93672>>>>>>
93672>>>>>                    Get LockUserCountFile hFile dwFilePos to iResult
93673>>>>>                    If (not(iResult)) Begin  // byte is locked
93675>>>>>                        Get SetUserCountPointer hFile 10 to dwFilePos
93676>>>>>                        If (dwFilePos = -1) Begin
93678>>>>>                            Move 1 to UserCount.iUserCount
93679>>>>>                            Move 3 to UserCount.iError
93680>>>>>                            Move CS_ErrorAdvancingPointer to UserCount.sErrorTxt
93681>>>>>                            Function_Return UserCount
93682>>>>>                        End
93682>>>>>>
93682>>>>>                    End
93682>>>>>>
93682>>>>>                    Else Begin  // byte is not locked
93683>>>>>                        Set pdwLockPosition to dwFilePos
93684>>>>>                        Move True to bLocked
93685>>>>>                        Move iMaxUsers to iCurUser
93686>>>>>                    End
93686>>>>>>
93686>>>>>                Loop
93687>>>>>>
93687>>>>>                If (not(bLocked)) Begin
93689>>>>>                    Move CI_UserCountMaxUsers to UserCount.iUserCount
93690>>>>>                    Move 4 to UserCount.iError
93691>>>>>                    Move CS_MaxNoOfUserExceeded to UserCount.sErrorTxt
93692>>>>>                    Function_Return UserCount
93693>>>>>                End
93693>>>>>>
93693>>>>>            End
93693>>>>>>
93693>>>>>        End
93693>>>>>>
93693>>>>>
93693>>>>>        Function_Return UserCount
93694>>>>>    End_Function
93695>>>>>
93695>>>>>
93695>>>>>    Procedure DoReleaseUserCount
93697>>>>>        Integer iResult
93697>>>>>        Handle  hFile
93697>>>>>        DWord   dwLockPos
93697>>>>>
93697>>>>>        Get phUserCountFile to hFile
93698>>>>>        Get pdwLockPosition to dwLockPos
93699>>>>>        If (hFile) Begin
93701>>>>>            If (dwLockPos) Begin
93703>>>>>                Get UnlockUserCountFile hFile dwLockPos to iResult
93704>>>>>            End
93704>>>>>>
93704>>>>>            Get CloseUserCountFile hFile to iResult
93705>>>>>        End
93705>>>>>>
93705>>>>>    End_Procedure
93706>>>>>
93706>>>>>    Function CurrentNumberOfUsers Returns Integer
93708>>>>>        Handle  hFile
93708>>>>>        Integer iMaxUsers
93708>>>>>        DWord   dwFilePos
93708>>>>>        Integer iCurUser
93708>>>>>        Integer iResult
93708>>>>>        Integer iNumberOfLocks
93708>>>>>        String  sPath sFile
93708>>>>>
93708>>>>>        Move 0 to iNumberOfLocks
93709>>>>>
93709>>>>>        Get ApplicationPath to sPath
93710>>>>>        Get vFolderFormat sPath to sPath
93711>>>>>        Move (sPath + psLockFileName(Self)) to sFile
93712>>>>>        Get OpenUserCountFile sFile to hFile
93713>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
93715>>>>>            Send UserError CS_UnableToInitUserCountSys
93716>>>>>            Abort
93717>>>>>>
93717>>>>>        End
93717>>>>>>
93717>>>>>
93717>>>>>        If (hFile > 0) Begin
93719>>>>>            Get piMaxUsers To iMaxUsers
93720>>>>>
93720>>>>>            // Set Filepointer to beginning of the file
93720>>>>>            Get ResetUserCountPointer hFile to dwFilePos
93721>>>>>            If (dwFilePos = -1) Begin
93723>>>>>                Send UserError CS_UnableResetUserCountSys
93724>>>>>                Abort
93725>>>>>>
93725>>>>>            End
93725>>>>>>
93725>>>>>            For iCurUser from 1 to iMaxUsers
93731>>>>>>
93731>>>>>                Get LockUserCountFile hFile dwFilePos to iResult
93732>>>>>                If (Not(iResult)) Begin  // byte is locked
93734>>>>>                    Increment iNumberOfLocks
93735>>>>>                End
93735>>>>>>
93735>>>>>                Else Begin  // byte is not locked
93736>>>>>                    Get UnlockUserCountFile hFile dwFilePos to iResult
93737>>>>>                End
93737>>>>>>
93737>>>>>                Get SetUserCountPointer hFile 10 to dwFilePos
93738>>>>>                If (dwFilePos = -1) Begin
93740>>>>>                    Send UserError CS_ErrorAdvancingPointer
93741>>>>>                    Abort
93742>>>>>>
93742>>>>>                End
93742>>>>>>
93742>>>>>            Loop
93743>>>>>>
93743>>>>>        End
93743>>>>>>
93743>>>>>        Get CloseUserCountFile hFile to iResult
93744>>>>>        Function_Return iNumberOfLocks
93745>>>>>    End_Function
93746>>>>>
93746>>>>>End_Class
93747>>>Use cDbUpdateFunctionLibrary.pkg
93747>>>
93747>>>//{ DataBindable=True }
93747>>>Class cDbUpdateHandler is a cDbUpdateFunctionLibrary
93748>>>
93748>>>    Procedure Construct_Object
93750>>>        tUserCount UserCount
93750>>>        tUserCount UserCount
93750>>>        Integer iUserCount
93750>>>        Handle ho                     
93750>>>
93750>>>        Forward Send Construct_Object
93752>>>        Move Self to ghoDbUpdateHandler  
93753>>>        
93753>>>        // Latin1_General_CI_AS = General Insensitive collation
93753>>>        // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.   
93753>>>        // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
93753>>>        // Good read about which collation to select:
93753>>>        // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
93753>>>        Property String psCollation "Latin1_General_CS_AS" //"SQL_Latin1_General_Cp1_CS_AS"
93754>>>
93754>>>        // Struct array that will contain pnVersionNumbers & object id's of
93754>>>        // all child cDbVersion objects.
93754>>>        Property tDbVersionInfo[] paDbVersionInfoArray
93755>>>
93755>>>        Property Integer Error_Processing_State False  // internal usage
93756>>>        
93756>>>        Property Boolean Private.pbDbVersionCheckDone False
93757>>>
93757>>>        Property Boolean pbUseCustomDbVersion False  
93758>>>        
93758>>>        // If this property = True _and_ no DbVersion table exists 
93758>>>        // when the framework is started, a DbVersion table will be created automatically.
93758>>>        Property Boolean pbAutoCreateDbVersionTable True
93759>>>
93759>>>        // Connected to the pbAutoCreateDbVersionTable property. If it is true,
93759>>>        // the Filelist.cfg slot number indicated by this property will be used
93759>>>        // if a DbVersion table is to be created. If this value = -1 at runtime
93759>>>        // an Unhandled Exception Error will be genereted and the program halted. So
93759>>>        // this property _must_ be set in the cDbUpdateHandler object if pbAutoCreateDbVersionTable = True,
93759>>>        // to a value that corresponds to a free Filelist.cfg slot number.
93759>>>        Property Integer Private.piDbVersionFileNumber -1
93760>>>        Property Integer Private.piDbVersionFieldNumber 1
93761>>>
93761>>>        // This is a message of the cDbUpdateFunctionLibrary_Mixin class
93761>>>        // that creates all library properties
93761>>>        Send CreateDbUpdateLibraryProperties
93762>>>
93762>>>        Property tDbUpdateHandlerMasterAlias[] paDbUpdateHandlerMasterAlias
93763>>>
93763>>>        // Error handling:
93763>>>        Property Boolean Private.pbOnCreateExecuted False
93764>>>        Property Boolean Private.pbOnPreUpdateExecuted False
93765>>>        Property Boolean Private.pbProcessingError False
93766>>>        Property Boolean pbDbUpdateErrorHasOccured False
93767>>>        // Don't touch. It is being used by the cDbUpdateVersion
93767>>>        // subclass to tell if that particular update was a success or not.
93767>>>        Property Boolean Private.pbUpdateVersionObjectError False
93768>>>        Property String[] paSQLQueryMessages
93769>>>        
93769>>>        Property Boolean pbExitIfDebuggerActive True
93770>>>        Property Integer piOrgErrorHandlerID Error_Object_Id
93771>>>        Move Self to Error_Object_Id
93772>>>        // Error handling:
93772>>>        // Temporarily redirect all errors to this object so we can silently
93772>>>        // log all errors that might appear while updating the database.
93772>>>        // We temporarily redirect all errors to this object so we can
93772>>>        // log and write errors to the log file. It will be reset after
93772>>>        // the database updates have been finished.
93772>>>        Property Integer piCurrentErrorHandlerID Error_Object_Id
93773>>>
93773>>>        Property Handle phoLogFile (Create(Self,RefClass(cDbUpdateLogFile)))
93774>>>
93774>>>        // Error Reporting Related
93774>>>        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
93774>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
93775>>>
93775>>>        // If the pbContinueOnError = False, an update
93775>>>        // of another cDbUpdateVersion object will _not_ be
93775>>>        // performed if an error occured in a previous
93775>>>        // cDbUpdateVersion object.
93775>>>        Property Boolean pbContinueOnError False
93776>>>        // Stops execution in other cDbUpdateVersion objecs,
93776>>>        // if errors occurred in one cDbUpdateVersion object.
93776>>>        Property Boolean pbStopOnFirstError False
93777>>>        // If True errors that occured while updating the database
93777>>>        // will be shown in the default app for .txt files when done.
93777>>>        // Note: The log file will _always_ be created in the Data folder.
93777>>>        Property Boolean pbShowErrorLogPostRun True
93778>>>
93778>>>        // Be _very_ careful to set this property to true!
93778>>>        // If = True, no question will be asked if the update
93778>>>        // should begin. Also, even if the pbShowErrorLogPostRun=True,
93778>>>        // the error log won't be shown. The logfile itself will still be created though.
93778>>>        // You have to know what you're doing!
93778>>>        Property Boolean pbSilentMode False
93779>>>        
93779>>>        Property Boolean pbEnableCancelButton False
93780>>>
93780>>>        // Don't touch! Very private. The value is used by the error log to write for which
93780>>>        // cDbUpdateVersion object an error occured.
93780>>>        Property Number pnCurrentVersionUpdate 0
93781>>>
93781>>>        // The user counting logic is used to safe-guard agains anybody else is
93781>>>        // using the application when a database update is to be performed.
93781>>>        // (Garters & suspenders!)
93781>>>        Property Handle phoUserCountSystem (Create(Self,RefClass(cDbUpdateUserCount)))
93782>>>        Set psLockFileName of (phoUserCountSystem(Self)) to "DbUpdateUserCount.ucf"
93783>>>        Set piMaxUsers     of (phoUserCountSystem(Self)) to (CI_UserCountMaxUsers -1) // Large number!
93784>>>
93784>>>        // This lock file is used to guard against somebody else tries to start the
93784>>>        // application while updates are in progress.
93784>>>        Property Handle phoDatabaseUpdateLock (Create(Self,RefClass(cDbUpdateUserCount)))
93785>>>        Set psLockFileName of (phoDatabaseUpdateLock(Self)) to "DbUpdateLock.ucf"
93786>>>        Set piMaxUsers     of (phoDatabaseUpdateLock(Self)) to 1
93787>>>                                                                                      // Only the current user allowed.
93787>>>        // Properties for the table & column of a system file field/column where
93787>>>        // the database version update number gets saved.
93787>>>        Property Integer Private.Data_File  0
93788>>>        Property Integer Private.Data_Field 0
93789>>>
93789>>>        // Property that is used to indicate that we have already
93789>>>        // started the database update.
93789>>>        Property Boolean Private.pbDatabaseUpdateStarted False
93790>>>
93790>>>        // Don't touch! It is used by the child class cDbUpdateVersion logic to indicate that
93790>>>        // at least one OnUpdate child event has been triggered. Thus at least one active
93790>>>        // change of the database has been made.
93790>>>        Property Boolean Private.pbDatabaseWasUpdated False
93791>>>
93791>>>        // We need to trigger the user counting system so that a bit in the
93791>>>        // user counting file is locked. This is to guard that not more than one user
93791>>>        // is currently runnning the program.
93791>>>        Get CheckUserCount of (phoUserCountSystem(Self)) to UserCount
93792>>>
93792>>>        Get CurrentNumberOfUsers of (phoDatabaseUpdateLock(Self)) to iUserCount
93793>>>        If (iUserCount > 0) Begin
93795>>>            Send Stop_Box CS_DUF_UpdateInProgressTxt
93796>>>            Send Exit_Application
93797>>>        End
93797>>>>
93797>>>
93797>>>        Set pbHandleQueryErrors to False
93798>>>            
93798>>>        Property Handle phoSQLConnectionHandler 0
93799>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
93799>>>        // we will create one as it is used for all ConnectionID, ConnectionString
93799>>>        // etc information.
93799>>>        If (ghoSQLConnectionHandler = 0) Begin
93801>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
93802>>>            Set phoSQLConnectionHandler to ho
93803>>>        End             
93803>>>>
93803>>>        
93803>>>        // Do *not* set this property in this object!
93803>>>        // Instead use logic to set it in the Procedure OnCreate of the cApplication
93803>>>        // object. Aka, use phoCommandLine to retrieve an e.g. "-restore" parameter on
93803>>>        // the command line to the program. If such param has been passed, set  pbRestoreIntFilesNow = True.
93803>>>        // The user will then be informed that .int files will be restored and then the program will exit.
93803>>>        Property Boolean pbRestoreIntFilesNow False   
93804>>>        // In parallell with the above property, the pbSaveIntFilesNow can be set. That same property
93804>>>        // also needs to be created in the ghoApplication object.
93804>>>        Property Boolean pbSaveIntFilesNow False
93805>>>        Property Boolean pbUseIntFilesBackup False   
93806>>>        Property Handle  phIntFilesTable -1
93807>>>        Property Boolean Private.pbIntFilesTablesCheckDone False
93808>>>        
93808>>>        Set Icon to "Default.ico"
93809>>>    End_Procedure
93810>>>
93810>>>    Procedure End_Construct_Object
93812>>>        Boolean bCheckIntFiles
93812>>>        
93812>>>        Forward Send End_Construct_Object
93814>>>        If (Private.pbOnCreateExecuted(Self) = False) Begin  
93816>>>            Send OnCreate
93817>>>            Set Private.pbOnCreateExecuted to True
93818>>>        End
93818>>>>
93818>>>        Send Cleanup
93819>>>    End_Procedure
93820>>>    
93820>>>    // Programmers hook event.
93820>>>    Procedure OnCreate
93822>>>    End_Procedure        
93823>>>                                 
93823>>>    // Note: If you get a compile Error 4295: "xxx Can't include resource FILELISTBACKUPFILE.CFG",
93823>>>    //       you will need to manually make a copy of the Filelist.cfg in the Data folder -> "FilelistBackupFile.cfg"
93823>>>    Include_Resource FilelistBackupFile.cfg as res_EmbeddedFilelistCfg type DF_RESOURCE_TYPE_BINARY
93823>>>    // *** MAIN .Int file (and Filelist.cfg) Integrity Check Message ***
93823>>>    //                                                
93823>>>    // The logic is activated by setting the property "pbUseIntFilesBackup = True" in the
93823>>>    // cDbUpdateHandler object.
93823>>>    //
93823>>>    // Checks that all .int files are intact, or else writes new copies to disk. 
93823>>>    // Also checks that there is a Filelist.cfg, and if missing writes a new copy to disk.
93823>>>    //
93823>>>    // If not done previously the phIntFilesTable will be created and filled with data
93823>>>    // from the current set of .int files - iif (if-and-only-if) this is a development
93823>>>    // machine. Which is decided by checking if the DdSrc folder exists. And a copy
93823>>>    // of Filelist.cfg is made for backup purposes.
93823>>>    //
93823>>>    // Note: If an error occurrs the application will exit, as it means that at least one
93823>>>    // .int file is in error or the Filelist.cfg was missing and couldn't be recreated.
93823>>>
93823>>>    // Note: Include_Resource is a compiler directive!
93823>>>    // It will embedd the Filelist.cfg from the developers machine
93823>>>    // into the executable.        
93823>>>    //
93823>>>    // There is a pickle with the Filelist.cfg as it is "busy" as it is open in the Studio,
93823>>>    // when we get here and then the compiler can't embedd it!        
93823>>>    // NOTE: This relies on the "WriteDateTimeHeaderFile" program and that each Project has
93823>>>    //       been setup to run it as the "Before Compilation Process:" (See: Project - Project Properties - Compiler tab-page)
93823>>>    Function SaveUpdateIntFiles String ByRef sErrorText Returns Boolean
93825>>>        Boolean bCheckIntFiles bExists bOK bSaved bIsSQL bFileListExist bResult bDevelop bZipExists bIntFilesTablesCheckDone bNewer bIsIntFileTable  bIsAlias
93825>>>        String sPaths sDataPath sIntFileName sRootName sFileListName sFileListNameBackup sDDSrcPath sCurrentFolder
93825>>>        String sFileListZipFile sParam sProgram sFile 
93825>>>        Integer iDataPaths iCount
93825>>>        Handle hTable hIntFilesTable                    
93825>>>        UChar[] asFileListArray 
93826>>>        String[] asSavedIntFile
93827>>>        tDUFIntFile[] DUFIntFiles
93827>>>        tDUFIntFile[] DUFIntFiles
93828>>>
93828>>>        // This will automatically create the phIntFilesTable if not exists.
93828>>>        // It is used to save data from the current set of .int files.
93828>>>        // We do this on both developer & client machines.
93828>>>        Get IsIntFileTable to bIsIntFileTable
93829>>>        If (bIsIntFileTable = False) Begin
93831>>>            Send AutoCreateIntFilesTable
93832>>>            Get Private.pbIntFilesTablesCheckDone to bOK
93833>>>            If (bOK = False) Begin
93835>>>//                Move CS_DUF_DbUpdatedErrorText to sErrorText
93835>>>                Function_Return False
93836>>>            End
93836>>>>
93836>>>        End                                                       
93836>>>>
93836>>>        
93836>>>        // Check Filelist.cfg & backup file
93836>>>        Get psFileList of (phoWorkspace(ghoApplication)) to sFileListName
93837>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath 
93838>>>        Move (sDataPath + "\" + CS_FilelistBackupFile)   to sFileListNameBackup
93839>>>        Get IsFileTimeNewer sFileListName sFileListNameBackup to bNewer
93840>>>
93840>>>        Move (IsDebuggerPresent()) to bDevelop
93841>>>        // Is this a client machine?
93841>>>        If (bDevelop = False) Begin
93843>>>            If (bNewer = True) Begin
93845>>>                // Create filelist.cfg from resource backup file.
93845>>>                Get ReadFileListResource "res_EmbeddedFilelistCfg" to asFileListArray
93846>>>                Get WriteFileListResource asFileListArray sFileListName to bOK  
93847>>>            End
93847>>>>
93847>>>        End
93847>>>>
93847>>>
93847>>>        Else If (bDevelop = True) Begin
93850>>>            Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
93851>>>            If (bNewer = True) Begin
93853>>>                Get vDeleteFile sFileListNameBackup to bOK
93854>>>                Get vCopyFile sFileListName sFileListNameBackup to bOK
93855>>>                Move "A new backup copy of the Filelist.cfg file was made. In order to include a backup copy of the file into the program, as a resource, you will need to re-compile/restart the program.\n\nThe program will now exit." to sErrorText
93856>>>                Function_Return True
93857>>>            End
93857>>>>
93857>>>        End
93857>>>>
93857>>>        
93857>>>        Move True to bResult        
93858>>>        Send StartStatusPanel
93859>>>        Get phIntFilesTable to hIntFilesTable
93860>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
93861>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths
93862>>>
93862>>>        For iCount from 1 to iDataPaths
93868>>>>
93868>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
93869>>>            Get vFolderFormat sDataPath to sDataPath 
93870>>>            Get vFolderExists sDataPath to bExists
93871>>>            If (bExists = True) Begin                  
93873>>>                Move 0 to hTable
93874>>>                Repeat
93874>>>>
93874>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
93877>>>                    If (hTable <> 0 and hTable <> 50) Begin
93879>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
93882>>>                        Set Message_Text of ghoStatusPanel to ("Saving/updating IntFilesTable:" * String(sIntFileName))
93883>>>                        Get _UtilTableIsSqlByRootName sIntFileName to bIsSQL
93884>>>                        Get UtilTableIsAlias hTable to bIsAlias 
93885>>>                        If (bIsSQL = True and bIsAlias = False) Begin
93887>>>                            If (bIsSQL = True) Begin     
93889>>>                                Get _TableNameOnly sIntFileName to sIntFileName
93890>>>                                Move (sIntFileName + ".int")    to sIntFileName
93891>>>                                Get IsIntFileSaved sIntFileName to bSaved  
93892>>>                                Move True to bOK            
93893>>>                                
93893>>>                                // Save .int file to database if not done previously (both on development- and customer-machines).
93893>>>                                If (bSaved = False) Begin
93895>>>                                    Get SaveIntFileData sDataPath sIntFileName to bOK
93896>>>                                    If (bOK = False) Begin
93898>>>                                        Error DFERR_PROGRAM ("The 'SaveIntFileData' function for the internal database table:" * String(sIntFileName) * "failed.")
93899>>>>
93899>>>                                        Move False to bResult    
93900>>>                                    End
93900>>>>
93900>>>                                End         
93900>>>>
93900>>>                                Else Begin
93901>>>                                    Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
93902>>>                                    If (SizeOfArray(asSavedIntFile) <> 0) Begin
93904>>>                                        Get UpdateIntFileData sDataPath sIntFileName asSavedIntFile to bOK
93905>>>                                        If (bOK = False) Begin
93907>>>                                            Move False to bResult
93908>>>                                            Error DFERR_PROGRAM ("Could not update .int file data to the internal database table:" * String(sIntFileName))
93909>>>>
93909>>>                                        End
93909>>>>
93909>>>                                    End
93909>>>>
93909>>>                                End
93909>>>>
93909>>>                            End
93909>>>>
93909>>>                        End
93909>>>>
93909>>>                    End
93909>>>>
93909>>>                Until (hTable = 0)
93911>>>            End
93911>>>>
93911>>>        Loop       
93912>>>>
93912>>>        
93912>>>        Send Stop_StatusPanel of ghoStatusPanel
93913>>>        // If an error occured we need to exit the application as we cannot start with an uncomplete set of .int files.
93913>>>        If (bResult = False) Begin  
93915>>>            Function_Return False
93916>>>        End 
93916>>>>
93916>>>        Send LogError ("The *.int file backup table was updated:" * String(CS_IntFilesTableLogicalName)) False
93917>>>        Function_Return True
93918>>>    End_Function
93919>>>
93919>>>    // It checks that *.int files on disk corresponds with the content in the
93919>>>    // .int file backup table phIntFilesTable.
93919>>>    Procedure RestoreIntFiles
93921>>>        Boolean bCheckIntFiles bIsIntFileTable bExists bIsSQL bRestored bOK
93921>>>        String sPaths sDataPath sIntFileName 
93921>>>        String[] asSavedIntFile
93922>>>        Integer iDataPaths iCount iRetval
93922>>>        Handle hTable hIntFilesTable
93922>>>
93922>>>        Get IsIntFileTable to bIsIntFileTable
93923>>>        If (bIsIntFileTable = False) Begin
93925>>>            Send Info_Box "The 'IntFilesTable' has not been created. Thus no backup info for .int files exists. The property pbUseIntFilesBackup must have been set to True in the cDbUpdateHandler object for automatic creation of the table and save of all .int files."
93926>>>            Procedure_Return
93927>>>        End
93927>>>>
93927>>>        
93927>>>        Get YesNo_Box "This will restore the content of .int files. Current .int files will be compared to the content in the backup table. If different, files on disk will be updated. Cash files (.cch) will be removed.\n\n Continue?" to iRetval
93928>>>        If (iRetval <> MBR_Yes) Begin
93930>>>            Procedure_Return
93931>>>        End
93931>>>>
93931>>>
93931>>>        Send StartStatusPanel
93932>>>        Move False to bRestored
93933>>>        Get phIntFilesTable to hIntFilesTable
93934>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
93935>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths
93936>>>
93936>>>        For iCount from 1 to iDataPaths
93942>>>>
93942>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
93943>>>            Get vFolderFormat sDataPath to sDataPath 
93944>>>            Get vFolderExists sDataPath to bExists
93945>>>            If (bExists = True) Begin                  
93947>>>                Move 0 to hTable
93948>>>                Repeat
93948>>>>
93948>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable    
93951>>>                    If (hTable <> 0) Begin
93953>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
93956>>>                        Set Message_Text of ghoStatusPanel to ("Checking info for." * String(sIntFileName))
93957>>>                        Get _UtilTableIsSqlByRootName sIntFileName to bIsSQL
93958>>>                        If (bIsSQL = True) Begin     
93960>>>                            Get _TableNameOnly sIntFileName to sIntFileName
93961>>>                            Move (sIntFileName + ".int")    to sIntFileName
93962>>>                            Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
93963>>>                            If (SizeOfArray(asSavedIntFile) <> 0) Begin
93965>>>                                Set Message_Text of ghoStatusPanel to ("Restoring .int file:" * String(sIntFileName))
93966>>>                                Get CreateIntFileFromSavedData sIntFileName sDataPath to bOK
93967>>>                                If (bRestored = False and bOK = True) Begin
93969>>>                                    Move True to bRestored
93970>>>                                End
93970>>>>
93970>>>                                If (bOK = False) Begin
93972>>>                                    Error DFERR_PROGRAM ("Could not create the .int file" * String(sIntFileName) * "from the internal database table:" * String(CS_IntFilesTableLogicalName))
93973>>>>
93973>>>                                End
93973>>>>
93973>>>                            End
93973>>>>
93973>>>                        End
93973>>>>
93973>>>                    End
93973>>>>
93973>>>                Until (hTable = 0)
93975>>>            End
93975>>>>
93975>>>        Loop       
93976>>>>
93976>>>        
93976>>>        Send Stop_StatusPanel of ghoStatusPanel
93977>>>        If (bRestored = True) Begin
93979>>>            Send Info_Box "Ready! All .int files checked and updated if different. The program will now exit."
93980>>>            Send Exit_Application
93981>>>        End
93981>>>>
93981>>>    End_Procedure
93982>>>
93982>>>    Function IsIntFileTable Returns Boolean
93984>>>        Boolean bExists
93984>>>        Handle hTable
93984>>>        String sLogicalName
93984>>>        Move False to bExists
93985>>>        Get phIntFilesTable to hTable
93986>>>        If (hTable > 0) Begin
93988>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
93991>>>            Move (sLogicalName = CS_IntFilesTableLogicalName) to bExists
93992>>>        End
93992>>>>
93992>>>        Function_Return bExists    
93993>>>    End_Function
93994>>>    
93994>>>    // To update currently saved IntFile data to the database.
93994>>>    // Because it is much easier, we first delete all current records and
93994>>>    // then saves the changed .int file to the database.
93994>>>    Function UpdateIntFileData String sDataPath String sIntFileName String[] asSavedIntFile Returns Boolean
93996>>>        Boolean bOK
93996>>>        Move False to bOK
93997>>>        Move (Lowercase(sIntFileName)) to sIntFileName
93998>>>        Get DeleteIntFileData sDataPath sIntFileName to bOK
93999>>>        If (bOK = True) Begin
94001>>>            Get SaveIntFileData sDataPath sIntFileName to bOK
94002>>>        End
94002>>>>
94002>>>        Function_Return bOK
94003>>>    End_Function
94004>>>    
94004>>>    // Note: We use vFind here as the IntFileName may not yet have been created,
94004>>>    //       and thus we cannot compile.
94004>>>    Function IsIntFileSaved String sIntFileName Returns Boolean
94006>>>        Handle hTable
94006>>>        Boolean bOK
94006>>>        Integer iColumn iIndex   
94006>>>        String sFileName
94006>>>        
94006>>>        Move (Lowercase(sIntFileName)) to sIntFileName
94007>>>        Move False to bOK  
94008>>>        Get phIntFilesTable to hTable
94009>>>        Move 2              to iColumn // This is the "InfFileName" field no.
94010>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
94011>>>
94011>>>        Open hTable
94013>>>        Set_Field_Value hTable iColumn to sIntFileName
94016>>>        Vfind hTable iIndex GE
94018>>>        Get_Field_Value hTable iColumn to sFileName
94021>>>        If (Trim(sIntFileName) = Trim(sFileName)) Begin
94023>>>            Move True to bOK    
94024>>>        End
94024>>>>
94024>>>        Close hTable
94025>>>        
94025>>>        Function_Return bOK       
94026>>>    End_Function   
94027>>>    
94027>>>    // Checks that the passed .int file is the same as what is saved in the database.
94027>>>    // If not same, the return string array will contain the read .int file,
94027>>>    // else the returned array will be empty.
94027>>>    Function HasIntFileChanged String sDataPath String sIntFileName Returns String[]
94029>>>        String[] asIntFileOrg asIntFile asSavedIntFile asReturnIntFile
94033>>>        Boolean bIsSame
94033>>>        
94033>>>        Move (Lowercase(sIntFileName)) to sIntFileName
94034>>>        Get ReadIntFileData  sDataPath sIntFileName to asIntFileOrg   
94035>>>        Get SavedIntFileData sDataPath sIntFileName to asSavedIntFile
94036>>>        Get RemoveBlankLines asIntFileOrg   to asIntFile
94037>>>        Get RemoveBlankLines asSavedIntFile to asSavedIntFile
94038>>>        
94038>>>        Move (IsSameArray(asIntFile, asSavedIntFile)) to bIsSame
94039>>>        If (bIsSame = False) Begin
94041>>>            Move asIntFileOrg to asReturnIntFile    
94042>>>        End
94042>>>>
94042>>>        
94042>>>        Function_Return asReturnIntFile    
94043>>>    End_Function                                   
94044>>>    
94044>>>    // Takes a string array as parameter and returns a new
94044>>>    // string array without any empty rows and all rows trimmed.
94044>>>    // This is e.g. used by the HasIntFileChanged message to compare
94044>>>    // two .int file arrays. 
94044>>>    Function RemoveBlankLines String[] asIntFile Returns String[]
94046>>>        Integer iSize iCount iRow
94046>>>        String sVal        
94046>>>        String[] asRetValArray
94047>>>        
94047>>>        Move (SizeOfArray(asIntFile)) to iSize
94048>>>        If (iSize = 0) Begin
94050>>>            Function_Return asRetValArray
94051>>>        End                          
94051>>>>
94051>>>        Decrement iSize         
94052>>>        Move 0 to iRow
94053>>>        
94053>>>        For iCount from 0  to iSize
94059>>>>
94059>>>            Move asIntFile[iCount] to sVal
94060>>>            Move (Trim(sVal)) to sVal
94061>>>            If (sVal <> "") Begin
94063>>>                Move sVal to asRetValArray[iRow]
94064>>>                Increment iRow        
94065>>>            End
94065>>>>
94065>>>        Loop
94066>>>>
94066>>>        
94066>>>        Function_Return asRetValArray
94067>>>    End_Function
94068>>>    
94068>>>    Function SaveIntFileData String sPath String sIntFileName Returns Boolean
94070>>>        Handle hTable
94070>>>        Boolean bOK bErr
94070>>>        Integer iIDCol iFileCol iTextCol iIndex iIDIdx iSize iCount 
94070>>>        Number iID
94070>>>        String sFileName
94070>>>        String[] asIntFile
94071>>>        
94071>>>        // Note: We will lowercase all .int file names, to not get into having duplicates in the database
94071>>>        Move (Lowercase(sIntFileName)) to sIntFileName
94072>>>        
94072>>>        Move Err to bErr
94073>>>        Move False to Err
94074>>>        Move False to bOK
94075>>>        Get phIntFilesTable to hTable  
94076>>>        Move 1              to iIDCol
94077>>>        Move 2              to iFileCol
94078>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
94079>>>        Move 1              to iIDIdx   // Main ID index.
94080>>>        Move 2              to iIndex   // This is the IntFileName + ID index.
94081>>>
94081>>>        Get ReadIntFileData sPath sIntFileName to asIntFile
94082>>>        Move (SizeOfArray(asIntFile)) to iSize
94083>>>        If (iSize = 0) Begin
94085>>>            Function_Return False
94086>>>        End
94086>>>>
94086>>>        Decrement iSize
94087>>>        Open hTable  
94089>>>                  
94089>>>        // Find the last used ID no:
94089>>>        Fill_Field hTable iIDCol with DF_HIGH
94091>>>        Vfind hTable iIDIdx LE
94093>>>        Get_Field_Value hTable iIDCol to iID 
94096>>>        // This only happens the very first time we save a record.
94096>>>        If (iID = 999999999999) Begin
94098>>>            Move 0 to iID
94099>>>        End
94099>>>>
94099>>>        Increment iID
94100>>>        
94100>>>        Lock
94101>>>>
94101>>>            For iCount from 0 to iSize
94107>>>>
94107>>>                Clear hTable
94108>>>                Set_Field_Value hTable iIDCol   to iID     
94111>>>                Set_Field_Value hTable iFileCol to sIntFileName
94114>>>                Set_Field_Value hTable iTextCol to asIntFile[iCount]
94117>>>                SaveRecord hTable
94118>>>                Increment iID
94119>>>            Loop
94120>>>>
94120>>>        Unlock
94121>>>>
94121>>>        Close hTable
94122>>>        
94122>>>        Move (not(Err)) to bOK
94123>>>        Move bErr to Err
94124>>>        
94124>>>        Function_Return bOK
94125>>>    End_Function
94126>>>    
94126>>>    // Deletes all records for the passed sIntFileName value,
94126>>>    // from the phIntFilesTable.
94126>>>    // Returns True if no errors occured.
94126>>>    Function DeleteIntFileData String sPath String sIntFileName Returns Boolean
94128>>>        Handle hTable
94128>>>        Boolean bOK bErr bFound
94128>>>        Integer iFileCol iIndex
94128>>>        String sVal
94128>>>        String[] asIntFile
94129>>>        
94129>>>        Move (Trim(Lowercase(sIntFileName))) to sIntFileName
94130>>>        Move Err to bErr
94131>>>        Move False to Err
94132>>>        Move False to bOK
94133>>>        Move 2              to iFileCol
94134>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
94135>>>        Get phIntFilesTable to hTable  
94136>>>        Open hTable  
94138>>>                  
94138>>>        // Find the first record
94138>>>        Set_Field_Value hTable iFileCol to sIntFileName
94141>>>        Vfind hTable iIndex GE
94143>>>        Get_Field_Value hTable iFileCol to sVal
94146>>>        Move (Trim(Lowercase(sVal))) to sVal
94147>>>        Move (Found and sVal = sIntFileName) to bFound
94148>>>        While (bFound = True)
94152>>>            Delete hTable
94153>>>            Vfind hTable iIndex GT
94155>>>            Get_Field_Value hTable iFileCol to sVal
94158>>>            Move (Trim(Lowercase(sVal))) to sVal
94159>>>            Move (Found and sVal = sIntFileName) to bFound
94160>>>        Loop
94161>>>>
94161>>>        Unlock
94162>>>>
94162>>>        Close hTable
94163>>>        
94163>>>        Move (not(Err)) to bOK
94164>>>        Move bErr to Err
94165>>>        
94165>>>        Function_Return bOK
94166>>>    End_Function
94167>>>
94167>>>    // Returns all saved phIntFilesTable records for the passed 
94167>>>    // sIntFileName value as a string array.
94167>>>    Function SavedIntFileData String sPath String sIntFileName Returns String[]
94169>>>        Handle hTable
94169>>>        Boolean bOK bErr bFound
94169>>>        Integer iFileCol iTextCol iIndex
94169>>>        String sVal sFileName
94169>>>        String[] asIntFile asEmptyArray
94171>>>        
94171>>>        Move (Trim(Lowercase(sIntFileName))) to sIntFileName
94172>>>        Move Err to bErr
94173>>>        Move False to Err
94174>>>        Move False to bOK
94175>>>        Move 2              to iFileCol
94176>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
94177>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
94178>>>        Get phIntFilesTable to hTable  
94179>>>        Open hTable  
94181>>>        
94181>>>        // Find the first record
94181>>>        Set_Field_Value hTable iFileCol to sIntFileName
94184>>>        Vfind hTable iIndex GE
94186>>>        Get_Field_Value hTable iFileCol to sFileName
94189>>>        Move (Trim(Lowercase(sFileName))) to sFileName
94190>>>        Move (Found and sFileName = sIntFileName) to bFound
94191>>>        While (bFound = True)
94195>>>            Get_Field_Value hTable iFileCol   to sFileName
94198>>>            Move (Trim(Lowercase(sFileName))) to sFileName
94199>>>            Move (Found and sFileName = sIntFileName) to bFound
94200>>>            If (bFound = True) Begin
94202>>>                Get_Field_Value hTable iTextCol to sVal
94205>>>                Move (Trim(sVal)) to asIntFile[SizeOfArray(asIntFile)]
94206>>>            End
94206>>>>
94206>>>            Vfind hTable iIndex GT
94208>>>        Loop
94209>>>>
94209>>>        
94209>>>        Close hTable
94210>>>        Move (not(Err)) to bOK
94211>>>        If (bOK = False) Begin
94213>>>            Move asEmptyArray to asIntFile
94214>>>        End
94214>>>>
94214>>>        Move bErr to Err               
94215>>>        
94215>>>        Function_Return asIntFile
94216>>>    End_Function
94217>>>
94217>>>    // Reads the passed sIntFileName from disk and returns its value
94217>>>    // as a string array.
94217>>>    Function ReadIntFileData String sPath String sIntFileName Returns String[]
94219>>>        String[] asIntFile       
94220>>>        String sFileName sLine
94220>>>        Integer iCh iSize iCount
94220>>>        
94220>>>        Move (Lowercase(sIntFileName)) to sIntFileName
94221>>>        Get vFolderFormat sPath to sPath
94222>>>        If (not(sIntFileName contains ".")) Begin
94224>>>            Move (sIntFileName + ".int") to sIntFileName
94225>>>        End
94225>>>>
94225>>>        Move (sPath + sIntFileName) to sFileName
94226>>>        Get Seq_Open_input_Channel sFileName to iCh
94227>>>        If (iCh < 0) Begin
94229>>>            Function_Return asIntFile
94230>>>        End                                 
94230>>>>
94230>>>        
94230>>>        Repeat
94230>>>>
94230>>>            Readln channel iCh sLine
94232>>>            If (SeqEof = False) Begin
94234>>>                Move (Trim(sLine)) to asIntFile[SizeOfArray(asIntFile)]
94235>>>            End
94235>>>>
94235>>>        Until (SeqEof = True)
94237>>>        Send Seq_Close_Channel iCh    
94238>>>        
94238>>>        Function_Return asIntFile
94239>>>    End_Function
94240>>>    
94240>>>    // Reads the Filelist.cfg from memeory as a resource.
94240>>>    // The Filelist.cfg has been compiled into the program.
94240>>>    Function ReadFileListResource String sMemFileName Returns UChar[]
94242>>>        Integer iCh iCount
94242>>>        Number nByteCount
94242>>>        String[] asFileListArray sEmptyArray
94244>>>        String sLine
94244>>>        UChar[] uCharData
94245>>>        
94245>>>        Move False to Err
94246>>>        Get Seq_New_Channel to iCh
94247>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
94249>>>            Error DFERR_PROGRAM 'No channel available...'
94250>>>>
94250>>>            Function_Return sEmptyArray
94251>>>        End
94251>>>>
94251>>>
94251>>>        // First decide the size of the script
94251>>>        Direct_Input channel iCh ("Resource: " + sMemFileName)
94253>>>        Read_Block channel iCh uCharData -1 // -1 means that all data should be read.
94255>>>        Close_Input channel iCh
94257>>>        Send Seq_Release_Channel iCh
94258>>>
94258>>>        Function_Return uCharData
94259>>>    End_Function    
94260>>>    
94260>>>    // Writes a copy of the workspace Filelist.cfg to disk.
94260>>>    // It does so by reading from a memory resource, as the file has
94260>>>    // been compiled into the program.
94260>>>    Function WriteFileListResource UChar[] asFileListArray String sFileListName Returns Boolean
94262>>>        Boolean bOK bErr
94262>>>        Integer iSize iCh
94262>>>        
94262>>>        Move Err to bErr
94263>>>        Move False to Err
94264>>>        Move False to bOK
94265>>>        Move (SizeOfArray(asFileListArray)) to iSize
94266>>>        If (iSize = 0) Begin
94268>>>            Function_Return False
94269>>>        End
94269>>>>
94269>>>
94269>>>        Get Seq_New_Channel to iCh
94270>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
94272>>>            Error DFERR_PROGRAM 'No channel available...'
94273>>>>
94273>>>            Function_Return False
94274>>>        End                      
94274>>>>
94274>>>        
94274>>>        Direct_Output channel iCh sFileListName
94276>>>        Writeln channel iCh asFileListArray
94279>>>                
94279>>>        Close_Input channel iCh
94281>>>        Send Seq_Release_Channel iCh
94282>>>        Move (not(Err)) to bOK
94283>>>        Move bErr to Err
94284>>>        
94284>>>        Function_Return bOK
94285>>>    End_Function
94286>>>
94286>>>    // Writes an .int for the passed sIntFileName file to disk by reading data from the phIntFilesTable data table.
94286>>>    // It first deletes the .cch file (if any).
94286>>>    Function CreateIntFileFromSavedData String sIntFileName String sDataPath Returns Boolean
94288>>>        Boolean bOK bFound bExists bErr
94288>>>        Integer iCh iSize iCount
94288>>>        String sFileName sCCHFileName sVal
94288>>>        String[] asIntFile
94289>>>        
94289>>>        Move (Lowercase(sIntFileName)) to sIntFileName
94290>>>        Move Err to bErr   
94291>>>        Move False to Err
94292>>>        Move False to bOK
94293>>>
94293>>>        Get SavedIntFileData sDataPath sIntFileName to asIntFile
94294>>>        Move (SizeOfArray(asIntFile)) to iSize
94295>>>        If (iSize = 0) Begin
94297>>>            Function_Return False        
94298>>>        End                      
94298>>>>
94298>>>        Decrement iSize
94299>>>        
94299>>>        Get Seq_New_Channel to iCh
94300>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
94302>>>            Function_Return False
94303>>>        End   
94303>>>>
94303>>>        
94303>>>        // Before we start to actually create the new .int file, make sure we delete
94303>>>        // the .cch file.                                     
94303>>>        Move (Uppercase(sIntFileName)) to sCCHFileName
94304>>>        Move (Replace(".INT", sCCHFileName, ".CCH")) to sCCHFileName
94305>>>        Get vFilePathExists (sDataPath + sCCHFileName) to bExists
94306>>>        If (bExists = True) Begin
94308>>>            Get vDeleteFile (sDataPath + sCCHFileName) to bOK
94309>>>            If (bOK = False) Begin
94311>>>                Function_Return False
94312>>>            End
94312>>>>
94312>>>        End
94312>>>>
94312>>>        
94312>>>        Direct_Output channel iCh (sDataPath + sIntFileName)
94314>>>        For iCount from 0 to iSize
94320>>>>
94320>>>            Writeln channel iCh asIntFile[iCount]
94323>>>        Loop
94324>>>>
94324>>>        
94324>>>        Close_Input channel iCh
94326>>>        Send Seq_Release_Channel iCh
94327>>>        Move (not(Err)) to bOK
94328>>>        Move bErr to Err
94329>>>        
94329>>>        Function_Return bOK
94330>>>    End_Function   
94331>>>              
94331>>>    // Automatically writes .int files to disk that is missing.
94331>>>    // We only need to make this test this once, but because the message is called
94331>>>    // from each child cDbUpdateVersion object (and it needs to be called from there),
94331>>>    // we use property Private.pbIntFilesTablesCheckDone to ensure it is only run once.
94331>>>    Procedure AutoCreateIntFilesTable
94333>>>        Integer hTable 
94333>>>        Boolean bIntFilesTablesCheckDone bTableExists bOK
94333>>>        String sInfoTxt 
94333>>>        
94333>>>        Get phIntFilesTable to hTable  
94334>>>        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
94335>>>        If (bIntFilesTablesCheckDone = True) Begin
94337>>>            Procedure_Return
94338>>>        End
94338>>>>
94338>>>
94338>>>        If (hTable < 1) Begin
94340>>>            Set Private.pbIntFilesTablesCheckDone to False
94341>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94342>>>            Error DFERR_PROGRAM "The phIntFilesTable has been set to 0 (!). The default value is 2048 and if changed MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object.\nProgram will now exit!"
94343>>>>
94343>>>            Procedure_Return
94344>>>        End
94344>>>>
94344>>>        
94344>>>        Get IsIntFileTable hTable to bTableExists
94345>>>        If (bTableExists = True) Begin
94347>>>            Set Private.pbIntFilesTablesCheckDone to True
94348>>>            Procedure_Return
94349>>>        End
94349>>>>
94349>>>
94349>>>        Send SubCreateIntFilesTable hTable
94350>>>    End_Procedure
94351>>>                
94351>>>    Procedure SubCreateIntFilesTable Handle hTable
94353>>>        String sTableName sColumnName sInfoTxt sDriverID sDataPath
94353>>>        Boolean bTableExists bOK bUseConnectionID bExists
94353>>>        tAPIColumn[] APIColumn
94353>>>        tAPIColumn[] APIColumn
94354>>>
94354>>>        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
94355>>>        If (bTableExists = True) Begin
94357>>>            Procedure_Return
94358>>>        End
94358>>>>
94358>>>
94358>>>        Move False to Err
94359>>>        Get psDriverID to sDriverID
94360>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
94361>>>
94361>>>        Move CS_IntFilesTableLogicalName to sTableName
94362>>>
94362>>>        Move 1                  to APIColumn[0].iFieldNumber
94363>>>        Move "ID"               to APIColumn[0].sFieldName
94364>>>        Move DF_BCD             to APIColumn[0].iType
94365>>>        Move False              to APIColumn[0].bIsSQLType
94366>>>        Move 12                 to APIColumn[0].iLength
94367>>>        Move 0                  to APIColumn[0].iPrecision
94368>>>
94368>>>        Move 2                  to APIColumn[1].iFieldNumber
94369>>>        Move "IntFileName"      to APIColumn[1].sFieldName
94370>>>        Move DF_ASCII           to APIColumn[1].iType
94371>>>        Move False              to APIColumn[1].bIsSQLType
94372>>>        Move 50                 to APIColumn[1].iLength
94373>>>        Move 0                  to APIColumn[1].iPrecision
94374>>>
94374>>>        Move 3                  to APIColumn[2].iFieldNumber
94375>>>        Move "IntLineText"      to APIColumn[2].sFieldName
94376>>>        Move DF_ASCII           to APIColumn[2].iType
94377>>>        Move False              to APIColumn[2].bIsSQLType
94378>>>        Move 100                to APIColumn[2].iLength
94379>>>        Move 0                  to APIColumn[2].iPrecision
94380>>>
94380>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
94381>>>        
94381>>>        If (bOK = True and Err = False) Begin
94383>>>            Move ("Int Files Table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
94384>>>        End
94384>>>>
94384>>>        Else Begin
94385>>>            Set Private.pbIntFilesTablesCheckDone to False
94386>>>            Move ("ERROR" * "Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
94387>>>            Error DFERR_PROGRAM sInfoTxt
94388>>>>
94388>>>            Procedure_Return
94389>>>        End
94389>>>>
94389>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
94390>>>        
94390>>>        Open hTable
94392>>>        Get ApiIndexCreate hTable 1 1 1   to bOK     // Index 1 = ID
94393>>>        If (bOK = True) Begin
94395>>>            Get ApiIndexCreate hTable 2 2 2 1 to bOK // Index 2 = InteFileName, ID.
94396>>>        End
94396>>>>
94396>>>        If (bOK = False) Begin
94398>>>            Set Private.pbIntFilesTablesCheckDone to False
94399>>>            Move ("ERROR" * "Indexes for Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
94400>>>            Error DFERR_PROGRAM sInfoTxt
94401>>>>
94401>>>            Procedure_Return
94402>>>        End
94402>>>>
94402>>>        
94402>>>        // Check if the new .int file was created. If so and a .dat file exists - delete it.
94402>>>        If (sDriverID <> DATAFLEX_ID) Begin
94404>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
94405>>>            Get vFolderFormat sDataPath to sDataPath
94406>>>            Move (CS_IntFilesTableLogicalName + ".int") to sTableName
94407>>>            Get vFilePathExists (sDataPath + sTableName) to bExists
94408>>>            If (bExists = True) Begin
94410>>>                Move CS_IntFilesTableLogicalName to sTableName
94411>>>                Get vFilePathExists (sDataPath + sTableName + ".dat") to bExists
94412>>>                If (bExists = True) Begin
94414>>>                    Get vDeleteFile (sDataPath + sTableName + ".dat") to bOK
94415>>>                    Get vDeleteFile (sDataPath + sTableName + ".hdr") to bOK
94416>>>                    Get vDeleteFile (sDataPath + sTableName + ".k??") to bOK
94417>>>                End
94417>>>>
94417>>>            End
94417>>>>
94417>>>        End
94417>>>>
94417>>>        
94417>>>        Set Private.pbIntFilesTablesCheckDone to True
94418>>>    End_Procedure
94419>>>
94419>>>    Procedure CheckAutoCreateDbVersionTable
94421>>>        Boolean bDbVersionCheckDone bUseCustomDbVersion bAutoCreateDbVersionTable bTableExists
94421>>>        Integer iDbVersionFileNumber
94421>>>
94421>>>        Get Private.pbDbVersionCheckDone to bDbVersionCheckDone
94422>>>        If (bDbVersionCheckDone = True) Begin
94424>>>            Procedure_Return
94425>>>        End
94425>>>>
94425>>>        Get pbUseCustomDbVersion to bUseCustomDbVersion
94426>>>        If (bUseCustomDbVersion = True) Begin
94428>>>            Procedure_Return
94429>>>        End
94429>>>>
94429>>>
94429>>>        Get piDbVersionFileNumber to iDbVersionFileNumber
94430>>>        Get pbAutoCreateDbVersionTable to bAutoCreateDbVersionTable
94431>>>        If (bAutoCreateDbVersionTable = True and iDbVersionFileNumber < 1) Begin
94433>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94434>>>            Error DFERR_PROGRAM "The iDbVersionFileSlotNumber = -1. It MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object. Could not auto-create the DbVersion table.\nProgram will now exit!"
94435>>>>
94435>>>            Send Exit_Application
94436>>>        End
94436>>>>
94436>>>
94436>>>        Get _UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
94437>>>        If (bTableExists = True) Begin
94439>>>            Set Private.pbDbVersionCheckDone to True
94440>>>            Procedure_Return
94441>>>        End
94441>>>>
94441>>>
94441>>>        Send CreateDbVersionTable iDbVersionFileNumber
94442>>>
94442>>>        // We only need to these DbVersion checks once, but because this message is called
94442>>>        // from each child cDbUpdateVersion object (and it needs to be called from there),
94442>>>        // we use a property to only run these tests once.
94442>>>        Set Private.pbDbVersionCheckDone to True
94443>>>    End_Procedure
94444>>>
94444>>>    Procedure CreateDbVersionTable Handle hTable
94446>>>        String sTableName sColumnName sInfoTxt sDriverID 
94446>>>        Boolean bTableExists bOK bUseConnectionID
94446>>>        tAPIColumn[] APIColumn
94446>>>        tAPIColumn[] APIColumn
94447>>>
94447>>>        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
94448>>>        If (bTableExists = True) Begin
94450>>>            Procedure_Return
94451>>>        End
94451>>>>
94451>>>
94451>>>        Get psDriverID to sDriverID
94452>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
94453>>>
94453>>>        Move "DbVersion"        to sTableName
94454>>>        Move 1                  to APIColumn[0].iFieldNumber
94455>>>        Move "DatabaseVersion"  to APIColumn[0].sFieldName
94456>>>        Move DF_BCD             to APIColumn[0].iType
94457>>>        Move False              to APIColumn[0].bIsSQLType
94458>>>        Move 4                  to APIColumn[0].iLength
94459>>>        Move 2                  to APIColumn[0].iPrecision
94460>>>
94460>>>        Move False to Err                                
94461>>>        
94461>>>        // Note: We always create an embedded DbVersion table. To do this we temporarily need to set the psDriverID to "DATAFLEX".
94461>>>        // To convert the DbVersion table to SQL, use the 'ApiTableConvertToSQL' function.
94461>>>        Set psDriverID to DATAFLEX_ID
94462>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
94463>>>        Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
94464>>>        Set psDriverID to sDriverID
94465>>>        
94465>>>        If (bOK = True and Err = False) Begin
94467>>>//            Move ("Column '" + APIColumn[0].sFieldName + "'" * "NUMERIC" * String(APIColumn[0].iLength) + ", was successfully added to '" + sTableName + "'" * "(at filelist slot:" * String(hTable) + ")") to sInfoTxt
94467>>>            Move ("DbVersion table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
94468>>>        End
94468>>>>
94468>>>        Else Begin
94469>>>            Move ("The column could NOT be added. Either column" * sColumnName * "already exists or the Table name is incorrect?") to sInfoTxt
94470>>>        End
94470>>>>
94470>>>
94470>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
94471>>>    End_Procedure
94472>>>
94472>>>    Procedure Set pbVerboseState Boolean bVerboseState
94474>>>        Handle ho
94474>>>        Get phoLogFile to ho
94475>>>        Set pbVerboseState of ho to bVerboseState
94476>>>    End_Procedure
94477>>>
94477>>>    Function pbVerboseState Returns Boolean
94479>>>        Boolean bVerboseState
94479>>>        Handle ho
94479>>>        Get phoLogFile to ho
94480>>>        Get pbVerboseState of ho to bVerboseState
94481>>>        Function_Return bVerboseState
94482>>>    End_Function
94483>>>
94483>>>    // Callback functionality used when e.g. calling driver functions directly.
94483>>>    // Note that this overrules the callback function of the cDbUpdateFunctionLibrary class.
94483>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
94485>>>        Integer iPerc
94485>>>        Number nReady nTotal nVersion
94485>>>        Boolean bVerboseState
94485>>>        Handle hoLogFile
94485>>>
94485>>>        Get pbVerboseState to bVerboseState
94486>>>        Get pnCurrentVersionUpdate to nVersion
94487>>>        Get phoLogFile     to hoLogFile
94488>>>        Send DoAdvance of ghoProgressBar
94489>>>
94489>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
94491>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
94492>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
94493>>>        End
94493>>>>
94493>>>        If (sCallback_Text contains "Creating index") Begin
94495>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
94496>>>        End
94496>>>>
94496>>>        If (bVerboseState = True and (iCallback_Type <> DF_Message_Progress_Value)) Begin
94498>>>            Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94499>>>        End
94499>>>>
94499>>>        If (iCallback_Type <> DF_Message_Progress_Value) Begin
94501>>>            Set Message_Text of ghoStatusPanel to sCallback_Text
94502>>>            Set Action_Text  of ghoStatusPanel to ""
94503>>>        End
94503>>>>
94503>>>
94503>>>        Case Begin
94503>>>            Case (iCallback_Type = DF_Message_Progress_Title)
94505>>>                Set Action_Text  of ghoStatusPanel to ""
94506>>>                Case Break
94507>>>            Case (iCallback_Type = DF_Message_Progress_Value)
94510>>>                //*** Interpret numbers
94510>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
94511>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
94512>>>                Move ((nReady/nTotal) * 100)                                                      to iPerc
94513>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% (Total:") * String(nTotal) + ")")
94514>>>                Set piPosition of ghoProgressBar to iPerc
94515>>>                Case Break
94516>>>//            Case Else
94516>>>//                Set Message_Text of ghoStatusPanel to ""
94516>>>//                Set Action_Text  of ghoStatusPanel to ""
94516>>>        Case End
94516>>>
94516>>>        Send ProcessEvents of ghoStatusPanel
94517>>>        Function_Return False
94518>>>    End_Function
94519>>>
94519>>>    // This was made to be a procedure/function pair so we
94519>>>    // at the same time can set the property of the cDbUpdateFunctionLibrary
94519>>>
94519>>>    Procedure Set piDbType Integer iDbType
94521>>>        If (ghoSQLConnectionHandler = 0) Begin
94523>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94524>>>>
94524>>>            Procedure_Return
94525>>>        End
94525>>>>
94525>>>        Set piDbType of ghoSQLConnectionHandler to iDbType
94526>>>    End_Procedure
94527>>>
94527>>>    Function piDbType Returns Integer
94529>>>        Integer iDbType
94529>>>        If (ghoSQLConnectionHandler = 0) Begin
94531>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94532>>>>
94532>>>            Function_Return ""
94533>>>        End
94533>>>>
94533>>>        Get piDbType of ghoSQLConnectionHandler to iDbType
94534>>>        Function_Return iDbType
94535>>>    End_Function
94536>>>
94536>>>    Procedure Set psDriverID String sDriverID
94538>>>        If (ghoSQLConnectionHandler = 0) Begin
94540>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94541>>>>
94541>>>            Procedure_Return
94542>>>        End
94542>>>>
94542>>>        Set psDriverID of ghoSQLConnectionHandler to sDriverID
94543>>>    End_Procedure
94544>>>
94544>>>    Function psDriverID Returns String
94546>>>        String sValue
94546>>>        If (ghoSQLConnectionHandler = 0) Begin
94548>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94549>>>>
94549>>>            Function_Return ""
94550>>>        End
94550>>>>
94550>>>        Get psDriverID of ghoSQLConnectionHandler to sValue
94551>>>        Function_Return sValue
94552>>>    End_Function
94553>>>
94553>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
94555>>>        If (ghoSQLConnectionHandler = 0) Begin
94557>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94558>>>>
94558>>>            Procedure_Return
94559>>>        End
94559>>>>
94559>>>        Send CreateSQLConnection of ghoSQLConnectionHandler sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
94560>>>    End_Procedure
94561>>>
94561>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
94563>>>        Integer iRetval
94563>>>        If (ghoSQLConnectionHandler = 0) Begin
94565>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94566>>>>
94566>>>            Function_Return 2
94567>>>        End
94567>>>>
94567>>>
94567>>>        Get RedirectConnection of ghoSQLConnectionHandler to iRetval
94568>>>        Function_Return iRetval
94569>>>    End_Function
94570>>>
94570>>>    Procedure Set psConnectionID String sValue
94572>>>        If (ghoSQLConnectionHandler = 0) Begin
94574>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94575>>>>
94575>>>            Procedure_Return
94576>>>        End
94576>>>>
94576>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
94577>>>    End_Procedure
94578>>>
94578>>>    Function psConnectionID Returns String
94580>>>        String sValue
94580>>>        If (ghoSQLConnectionHandler = 0) Begin
94582>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94583>>>>
94583>>>            Function_Return ""
94584>>>        End
94584>>>>
94584>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
94585>>>
94585>>>        Function_Return sValue
94586>>>    End_Function
94587>>>
94587>>>    // These "properties" are settings of the cCLIHandler class, but are being
94587>>>    // relayed to the ghoSQLConnectionHandler object
94587>>>    // simply by changing one of its parameters.
94587>>>    Procedure Set psServer String sValue
94589>>>        If (ghoSQLConnectionHandler = 0) Begin
94591>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94592>>>>
94592>>>            Procedure_Return
94593>>>        End
94593>>>>
94593>>>        Set psServer of ghoSQLConnectionHandler to sValue
94594>>>    End_Procedure
94595>>>
94595>>>    Function psServer Returns String
94597>>>        String sValue
94597>>>        If (ghoSQLConnectionHandler = 0) Begin
94599>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94600>>>>
94600>>>            Function_Return ""
94601>>>        End
94601>>>>
94601>>>        Get psServer of ghoSQLConnectionHandler to sValue
94602>>>
94602>>>        Function_Return sValue
94603>>>    End_Function
94604>>>
94604>>>    Procedure Set psDatabase String sValue
94606>>>        If (ghoSQLConnectionHandler = 0) Begin
94608>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94609>>>>
94609>>>            Procedure_Return
94610>>>        End
94610>>>>
94610>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
94611>>>    End_Procedure
94612>>>
94612>>>    Function psDatabase Returns String
94614>>>        String sValue
94614>>>        If (ghoSQLConnectionHandler = 0) Begin
94616>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94617>>>>
94617>>>            Function_Return ""
94618>>>        End
94618>>>>
94618>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
94619>>>
94619>>>        Function_Return sValue
94620>>>    End_Function
94621>>>
94621>>>    Procedure Set psUserID String sValue
94623>>>        If (ghoSQLConnectionHandler = 0) Begin
94625>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94626>>>>
94626>>>            Procedure_Return
94627>>>        End
94627>>>>
94627>>>        Set psUserID of ghoSQLConnectionHandler to sValue
94628>>>    End_Procedure
94629>>>
94629>>>    Function psUserID Returns String
94631>>>        String sValue
94631>>>        If (ghoSQLConnectionHandler = 0) Begin
94633>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94634>>>>
94634>>>            Function_Return ""
94635>>>        End
94635>>>>
94635>>>        Get psUserID of ghoSQLConnectionHandler to sValue
94636>>>
94636>>>        Function_Return sValue
94637>>>    End_Function
94638>>>
94638>>>    Procedure Set psPassword String sValue
94640>>>        If (ghoSQLConnectionHandler = 0) Begin
94642>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94643>>>>
94643>>>            Procedure_Return
94644>>>        End
94644>>>>
94644>>>        Set psPassword of ghoSQLConnectionHandler to sValue
94645>>>    End_Procedure
94646>>>
94646>>>    Function psPassword Returns String
94648>>>        String sValue
94648>>>        If (ghoSQLConnectionHandler = 0) Begin
94650>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94651>>>>
94651>>>            Function_Return ""
94652>>>        End
94652>>>>
94652>>>        Get psPassword of ghoSQLConnectionHandler to sValue
94653>>>
94653>>>        Function_Return sValue
94654>>>    End_Function
94655>>>
94655>>>    Procedure Set pbTrusted Boolean bValue
94657>>>        If (ghoSQLConnectionHandler = 0) Begin
94659>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94660>>>>
94660>>>            Procedure_Return
94661>>>        End
94661>>>>
94661>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
94662>>>    End_Procedure
94663>>>
94663>>>    Function pbTrusted Returns Boolean
94665>>>        Boolean bValue
94665>>>        If (ghoSQLConnectionHandler = 0) Begin
94667>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94668>>>>
94668>>>            Function_Return False
94669>>>        End
94669>>>>
94669>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
94670>>>
94670>>>        Function_Return bValue
94671>>>    End_Function
94672>>>
94672>>>    Procedure Set psConnectionString String sValue
94674>>>        If (ghoSQLConnectionHandler = 0) Begin
94676>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94677>>>>
94677>>>            Procedure_Return
94678>>>        End
94678>>>>
94678>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
94679>>>    End_Procedure
94680>>>
94680>>>    Function psConnectionString Returns String
94682>>>        String sValue
94682>>>        If (ghoSQLConnectionHandler = 0) Begin
94684>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94685>>>>
94685>>>            Function_Return ""
94686>>>        End
94686>>>>
94686>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
94687>>>
94687>>>        Function_Return sValue
94688>>>    End_Function
94689>>>
94689>>>    Function piConnectionOptions Returns Integer
94691>>>        Integer iValue
94691>>>        If (ghoSQLConnectionHandler = 0) Begin
94693>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94694>>>>
94694>>>            Function_Return 0
94695>>>        End
94695>>>>
94695>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
94696>>>
94696>>>        Function_Return iValue
94697>>>    End_Function
94698>>>
94698>>>
94698>>>    Procedure Set pbCheckDataFlexUserCount Boolean bState
94700>>>        Set pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
94701>>>    End_Procedure
94702>>>
94702>>>    Function pbCheckDataFlexUserCount Returns Boolean
94704>>>        Boolean bState
94704>>>        Get pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
94705>>>        Function_Return bState
94706>>>    End_Function
94707>>>
94707>>>    Procedure Set psLogTextFile String sValue
94709>>>        Set psLogTextFile of (phoLogFile(Self)) to sValue
94710>>>    End_Procedure
94711>>>
94711>>>    Function psLogTextFile Returns String
94713>>>        String sValue
94713>>>        Get psLogTextFile of (phoLogFile(Self)) to sValue
94714>>>        Function_Return sValue
94715>>>    End_Function
94716>>>
94716>>>    Procedure Set psEditorProgram String sValue
94718>>>        Set psEditorProgram of (phoLogFile(Self)) to sValue
94719>>>    End_Procedure
94720>>>
94720>>>    Function psEditorProgram Returns String
94722>>>        String sValue
94722>>>        Get psEditorProgram of (phoLogFile(Self)) to sValue
94723>>>        Function_Return sValue
94724>>>    End_Function
94725>>>
94725>>>    Procedure Set pbUseDataTableLog Boolean bState
94727>>>        Set pbUseDataTableLog of (phoLogFile(Self)) to bState
94728>>>    End_Procedure
94729>>>
94729>>>    Function pbUseDataTableLog Returns Boolean
94731>>>        Boolean bState
94731>>>        Get pbUseDataTableLog of (phoLogFile(Self)) to bState
94732>>>        Function_Return bState
94733>>>    End_Function
94734>>>
94734>>>    Procedure Set pbQuickWrite Boolean bState
94736>>>        Set pbQuickWrite of (phoLogFile(Self)) to bState
94737>>>    End_Procedure
94738>>>
94738>>>    Function pbQuickWrite Returns Boolean
94740>>>        Boolean bState
94740>>>        Get pbQuickWrite of (phoLogFile(Self)) to bState
94741>>>        Function_Return bState
94742>>>    End_Function
94743>>>
94743>>>    Procedure Set pbDatabaseWasUpdated Boolean bState
94745>>>        Boolean bUpdateVersionObjectError bVerboseState
94745>>>        Integer iSize iCount
94745>>>        Number nVersion
94745>>>        String[] aSQLQueryMessages
94746>>>
94746>>>        Get Private.pbUpdateVersionObjectError to bUpdateVersionObjectError
94747>>>        Set Private.pbDatabaseWasUpdated to bState
94748>>>        // If no errors occurred in the current cDbUpdateVersion object - write
94748>>>        // to the log that it was OK.
94748>>>        If (bUpdateVersionObjectError = False) Begin
94750>>>            Get pnCurrentVersionUpdate to nVersion
94751>>>            Send LogError of (phoLogFile(Self)) nVersion 0 CS_SuccessfulUpdate 0 False
94752>>>        End
94752>>>>
94752>>>
94752>>>        Get pbVerboseState to bVerboseState
94753>>>        If (bVerboseState = True) Begin
94755>>>            Get paSQLQueryMessages to aSQLQueryMessages
94756>>>            Move (SizeOfArray(aSQLQueryMessages)) to iSize
94757>>>            Decrement iSize
94758>>>            For iCount from 0 to iSize
94764>>>>
94764>>>                Send LogError of (phoLogFile(Self)) nVersion 0 aSQLQueryMessages[iCount] 0 False
94765>>>            Loop
94766>>>>
94766>>>        End
94766>>>>
94766>>>
94766>>>    End_Procedure 
94767>>>    
94767>>>    Procedure Set piDbVersionFileNumber Integer iFileNumber
94769>>>        Set Private.piDbVersionFileNumber to iFileNumber
94770>>>    End_Procedure                                         
94771>>>    
94771>>>    Function piDbVersionFileNumber Returns Integer
94773>>>        Function_Return (Private.piDbVersionFileNumber(Self))
94774>>>    End_Function
94775>>>
94775>>>    Procedure Set piDbVersionFieldNumber Integer iFieldNumber
94777>>>        Set Private.piDbVersionFieldNumber to iFieldNumber
94778>>>    End_Procedure                                         
94779>>>    
94779>>>    Function piDbVersionFieldNumber Returns Integer
94781>>>        Function_Return (Private.piDbVersionFieldNumber(Self))
94782>>>    End_Function
94783>>>
94783>>>    Function pbDatabaseWasUpdated Returns Boolean
94785>>>        Function_Return (Private.pbDatabaseWasUpdated(Self))
94786>>>    End_Function
94787>>>    
94787>>>    //
94787>>>    Procedure ReinitializeFramework  
94789>>>        tDbVersionInfo[] aDbVersionInfoArray
94789>>>        tDbVersionInfo[] aDbVersionInfoArray
94790>>>        Handle hoDbVersionObject
94790>>>        Integer iSize iCount
94790>>>        
94790>>>        Set Private.pbDatabaseUpdateStarted to False
94791>>>        Get paDbVersionInfoArray to aDbVersionInfoArray
94792>>>        Move (SizeOfArray(aDbVersionInfoArray)) to iSize
94793>>>        Decrement iSize
94794>>>        
94794>>>        For iCount from 0 to iSize
94800>>>>
94800>>>            Move aDbVersionInfoArray[0].hObject to hoDbVersionObject
94801>>>            Send ProcessUpdate                  of hoDbVersionObject False
94802>>>        Loop
94803>>>>
94803>>>        Send Cleanup
94804>>>    End_Procedure
94805>>>    
94805>>>    Procedure StartStatusPanel
94807>>>        Send EnableCancelButton     of ghoStatusPanel (pbEnableCancelButton(Self))
94808>>>        Send Initialize_StatusPanel of ghoStatusPanel ("   " + CS_DUF_WorkingUpdateText) CS_DUF_WorkingHeaderText ""
94809>>>        Send Start_StatusPanel      of ghoStatusPanel
94810>>>    End_Procedure
94811>>>    
94811>>>    // This event is triggered by the cDbUpdateVersion child class when
94811>>>    // a database change is to be started, and is considered private.
94811>>>    // It is only executed once for the first cDbUpateVersion object!
94811>>>    Procedure InitDatabaseUpdate Handle hDbUpdateVersionObject
94813>>>        Boolean bDatabaseUpdateStarted bInUse bExists bCheckDataFlexUserCount
94813>>>        Integer iRetval iDataFlexUsers iUserCount
94813>>>        Handle hoUserCountSystem
94813>>>        tUserCount UserCount
94813>>>        tUserCount UserCount
94813>>>        DateTime dtUpdateStarted
94813>>>        tSQLConnection SQLConnection
94813>>>        tSQLConnection SQLConnection
94813>>>
94813>>>        // *Important:* If we already started the update; we do no further checking.
94813>>>        Get Private.pbDatabaseUpdateStarted to bDatabaseUpdateStarted
94814>>>        If (bDatabaseUpdateStarted = True) Begin
94816>>>            Procedure_Return
94817>>>        End
94817>>>>
94817>>>
94817>>>        // If not silent mode; Ask user if OK to start database update.
94817>>>        If (pbSilentMode(Self) = False) Begin
94819>>>            Get YesNo_Box CS_DUF_DatabaseNeedsUpdate CS_DUF_HeaderUpdateText to iRetval
94820>>>            If (iRetval <> MBR_Yes) Begin
94822>>>                Send Exit_Application
94823>>>            End
94823>>>>
94823>>>        End
94823>>>>
94823>>>        
94823>>>        Send StartStatusPanel
94824>>>        // This will save the status of all open tables including Master/Alias settings,
94824>>>        // so we can restore them later;
94824>>>        Send SaveOpenTables
94825>>>
94825>>>        Move 0 to iDataFlexUsers
94826>>>        // Make various tests to check that the database is not in use.
94826>>>        Get IsDatabaseInUse of hDbUpdateVersionObject to bInUse
94827>>>        // We also use our own user counting mechanism to guard against the
94827>>>        // database isn't opened already as we need exclusive access to the tables.:
94827>>>        Get phoUserCountSystem to hoUserCountSystem
94828>>>        Get CheckUserCount of hoUserCountSystem to UserCount
94829>>>        Get CurrentNumberOfUsers of hoUserCountSystem to iUserCount
94830>>>
94830>>>        Get pbCheckDataFlexUserCount of hoUserCountSystem to bCheckDataFlexUserCount
94831>>>        // Check DataFlex user count to see if anybody else is using the DataFlex license...
94831>>>        If (bCheckDataFlexUserCount = True) Begin
94833>>>            Get_Current_User_Count to iDataFlexUsers
94834>>>            // For some reason DataFlex - in some cases - might think that 2 users
94834>>>            // are in use while debugging from the Studio.
94834>>>            If (IsDebuggerPresent() and iDataFlexUsers = 2) Begin
94836>>>                Decrement iDataFlexUsers
94837>>>            End
94837>>>>
94837>>>        End 
94837>>>>
94837>>>        Else Begin
94838>>>            Move 1 to iDataFlexUsers 
94839>>>            Move 1 to iUserCount
94840>>>            Move False to bInUse
94841>>>        End
94841>>>>
94841>>>
94841>>>        If (pbSilentMode(Self) = False and iDataFlexUsers > 1) Begin
94843>>>            Get YesNo_Box CS_DUF_DatabaseInUseShort to iRetval
94844>>>            If (iRetval <> MBR_Yes) Begin
94846>>>                Send Exit_Application
94847>>>            End
94847>>>>
94847>>>        End
94847>>>>
94847>>>
94847>>>        If (bInUse = True or (UserCount.iError <> 0) or (iUserCount > 1)) Begin
94849>>>            Send Stop_Box CS_DUF_DatabaseInUseText
94850>>>            Send Exit_Application
94851>>>        End
94851>>>>
94851>>>
94851>>>        // This will put a look on the DbUpdateLock.ucf file.
94851>>>        // It is released when the update process is finished
94851>>>        Get CheckUserCount of (phoDatabaseUpdateLock(Self)) to UserCount
94852>>>
94852>>>        Move (CurrentDateTime()) to dtUpdateStarted
94853>>>        Set pdtUpdateStart of (phoLogFile(Self)) to dtUpdateStarted
94854>>>        Set Private.pbDatabaseUpdateStarted to True
94855>>>
94855>>>        // We need to close all tables before starting to make changes.
94855>>>        Close DF_ALL DF_PERMANENT
94856>>>
94856>>>        // If these properties has not exclicitly been set in the object, set them
94856>>>        // to settings from the SQLConnections.ini file;
94856>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
94857>>>        If (psSchema(Self) = "") Begin
94859>>>            Set psSchema            to SQLConnection.sSchema
94860>>>        End
94860>>>>
94860>>>        If (psBaseTableSpace(Self) = "") Begin
94862>>>            Set psBaseTableSpace    to SQLConnection.sBaseTableSpace
94863>>>        End
94863>>>>
94863>>>        If (psLongTableSpace(Self) = "") Begin
94865>>>            Set psLongTableSpace    to SQLConnection.sLongTableSpace
94866>>>        End
94866>>>>
94866>>>        If (psIndexTableSpace(Self) = "") Begin
94868>>>            Set psIndexTableSpace   to SQLConnection.sIndexTableSpace
94869>>>        End
94869>>>>
94869>>>        If (SQLConnection.sDriverID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
94871>>>            Procedure_Return
94872>>>        End
94872>>>>
94872>>>
94872>>>        Get SQLUtilCheckIfDatabaseExists of hDbUpdateVersionObject SQLConnection.sDatabase to bExists
94873>>>        If (SQLConnection.sDatabase <> "" and bExists = False) Begin
94875>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94876>>>            Send Stop_StatusPanel of ghoStatusPanel
94877>>>            // ToDo: NS 2019-09-23 I think we should always show an error message to the user if this occur (!)
94877>>>            Send Stop_Box (CS_DUF_DatabaseConnStringSpec + SQLConnection.sDatabase + CS_DUF_DatabaseDoesntExist )
94878>>>//            Error DFERR_PROGRAM ("The database specified in the connection string: '" + SQLConnection.sDatabase + "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit.")
94878>>>            Send Exit_Application
94879>>>        End
94879>>>>
94879>>>    End_Procedure
94880>>>
94880>>>    // *** Hook message for pre-processing ***
94880>>>    // Event to be used to auto-create a version table when "DUF_Use_Custom_DbVersion" is used.
94880>>>    // Aka, when another table than the standard "DbVersion" is used.
94880>>>    Procedure OnCreateCustomDbVersionTable
94882>>>    End_Procedure
94883>>>    
94883>>>    // *** Hook message for pre-processing ***
94883>>>    // The programmer can use this event for putting code that
94883>>>    // needs to be executed _before_ code in any of the cDbUpdateVersion
94883>>>    // child objects are executed.
94883>>>    Procedure OnPreUpdate
94885>>>    End_Procedure
94886>>>
94886>>>    // *** Hook message for post-processing ***
94886>>>    // The programmer should use this event for putting code that
94886>>>    // needs to be executed _after_ all database updates have finished.
94886>>>    Procedure OnPostUpdate
94888>>>    End_Procedure
94889>>>
94889>>>    // *** Hook message for custom DbVersion record find ***
94889>>>    // The programmer can use this event for putting code that
94889>>>    // needs to be executed to find a *custom* DbVersion table record.
94889>>>    // By default the DbVersion table is used but this can be
94889>>>    // customized by adding this line to the code;
94889>>>    // "Define DUF_Use_Custom_DbVersion" before the line "Use cDbUpdateHandler.pkg"
94889>>>    // Note: You do _not_ need to use this event if the DbVersion table is used
94889>>>    //       to save the current database version to. Only if you use your own
94889>>>    //       table _and_ it is not a system table (contains only one record).
94889>>>    Procedure OnFindVersionRecord
94891>>>        // Open MyTable
94891>>>        // Move xx to MyTable.Field1
94891>>>        // Move yy to MyTable.Field2
94891>>>        // Find le MyTable by Index.x
94891>>>    End_Procedure
94892>>>
94892>>>    // Hook event for writing header error text (pre-update) to
94892>>>    // a datatable. Only called if the pbUseDataTableLog property = True.
94892>>>    // Don't forget to Open the table first (!) as all
94892>>>    // tables have been closed at this stage.
94892>>>    // The start date & time is passed.
94892>>>    Procedure OnErrorWriteHeader_DataTable DateTime dtUpdateStart
94894>>>    End_Procedure
94895>>>
94895>>>    // Hook event to log errors to a database table.
94895>>>    // Only called if the pbUseDataTableLog = True.
94895>>>    // Don't forget to Open the table first (!) as all
94895>>>    // tables have been closed at this stage.
94895>>>    // If pbQuickWrite = True the DbUpdateErrorArray
94895>>>    // will contain just one row, as it is called for each error
94895>>>    // that occurred. Else it is called once at the end after all updates
94895>>>    // have run and contains all errors.
94895>>>    Procedure OnErrorWriteRow_DataTable tDbUpdateError[] DbUpdateErrorArray
94897>>>    End_Procedure
94898>>>
94898>>>    // Automatically send after all processing is done, but before the OnPostUpdate event.
94898>>>    Procedure Cleanup
94900>>>        Boolean bDatabaseWasUpdated bError bUseIntFilesBackup bOK
94900>>>        String sErrorText
94900>>>        
94900>>>        Move "" to sErrorText
94901>>>        Send CheckAutoCreateDbVersionTable
94902>>>        Send RestoreOpenTables
94903>>>
94903>>>        // The function library have two purposes; one is to use it in the
94903>>>        // Database Update Framework, but it can also be used on its own.
94903>>>        // If that is the case it has its own error handling system, which
94903>>>        // we temporarily disbled when running updates because we have
94903>>>        // error handling/logging here too... We now restore its setting.
94903>>>        If (ghoDbUpdateFunctionLibrary > 0) Begin
94905>>>            Set pbHandleQueryErrors of ghoDbUpdateFunctionLibrary to True
94906>>>        End
94906>>>>
94906>>>        Set pbHandleQueryErrors to True
94907>>>
94907>>>        Get pbDatabaseWasUpdated to bDatabaseWasUpdated
94908>>>        Get pbDbUpdateErrorHasOccured to bError
94909>>>        // Note: We make backup of .int files even if an error occured.
94909>>>        If (bDatabaseWasUpdated = True) Begin
94911>>>            // Check/create/update *.int files backup table:
94911>>>            Get pbUseIntFilesBackup to bUseIntFilesBackup
94912>>>            If (bUseIntFilesBackup = True) Begin
94914>>>                Get SaveUpdateIntFiles (&sErrorText) to bOK
94915>>>                If (bOK = False) Begin
94917>>>                    Send LogError sErrorText True
94918>>>                End
94918>>>>
94918>>>                Else If (sErrorText <> "") Begin
94921>>>                    Send LogError sErrorText False
94922>>>                End
94922>>>>
94922>>>            End
94922>>>>
94922>>>        End            
94922>>>>
94922>>>            
94922>>>        If (bDatabaseWasUpdated = True or bError = True) Begin
94924>>>
94924>>>            // We should always create the log as it also contains info about
94924>>>            // the update being successful.
94924>>>            Send WriteErrorLog of (phoLogFile(Self))
94925>>>
94925>>>            // This is a programmer's hook message:
94925>>>            Send OnPostUpdate
94926>>>
94926>>>            Send Stop_StatusPanel of ghoStatusPanel
94927>>>
94927>>>            If (pbSilentMode(Self) = False) Begin
94929>>>                If (bError = True) Begin
94931>>>                    If (pbShowErrorLogPostRun(Self) = True) Begin
94933>>>                        Send ShowErrorLog of (phoLogFile(Self))
94934>>>                    End
94934>>>>
94934>>>                    Send Info_Box CS_DUF_DbUpdatedErrorText
94935>>>                    Send Exit_Application
94936>>>                End
94936>>>>
94936>>>                Else Begin
94937>>>                    If (Private.pbDatabaseWasUpdated(Self) = True) Begin
94939>>>                        Send Info_Box CS_DUF_DatabaseUpdatedText
94940>>>                    End
94940>>>>
94940>>>                    Else Begin
94941>>>                        Send Info_Box CS_DUF_DatabaseCheckedText
94942>>>                    End
94942>>>>
94942>>>                End
94942>>>>
94942>>>            End
94942>>>>
94942>>>        End
94942>>>>
94942>>>
94942>>>        // Restore the standard error handler:
94942>>>        Get piOrgErrorHandlerID to Error_Object_Id
94943>>>    End_Procedure
94944>>>
94944>>>    // We do this _before_ we close the database to make changes, and save
94944>>>    // all 'Master' & 'Alias' tables settings so we can restore when
94944>>>    // we reopen the database.
94944>>>    Procedure SaveOpenTables
94946>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94946>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94947>>>        Get _MasterAndAliasFiles to aDbUpdateHandlerMasterAlias
94948>>>        Set paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
94949>>>    End_Procedure
94950>>>
94950>>>    // Returns a struct array with all currently open tables and a "state" that indicates if the table
94950>>>    // was opened DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER or DF_FILE_IS_ALIAS
94950>>>    Function _MasterAndAliasFiles Returns tDbUpdateHandlerMasterAlias[]
94952>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94952>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94953>>>        Integer hTable iMasterAliasType iSize
94953>>>        Boolean bOpen
94953>>>
94953>>>        Move 0 to hTable
94954>>>        Repeat
94954>>>>
94954>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94957>>>            If (hTable <> 0) Begin
94959>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
94962>>>                If (bOpen = True) Begin
94964>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iMasterAliasType
94967>>>                    Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
94968>>>                    Move hTable to aDbUpdateHandlerMasterAlias[iSize].hTable
94969>>>                    Move iMasterAliasType to aDbUpdateHandlerMasterAlias[iSize].iMode
94970>>>                End
94970>>>>
94970>>>            End
94970>>>>
94970>>>        Until (hTable = 0)
94972>>>
94972>>>        Function_Return aDbUpdateHandlerMasterAlias
94973>>>    End_Function
94974>>>
94974>>>    // Message that re-opens all files in the filelist.cfg and restores any master & alias attributes.
94974>>>    // Takes one parameter:
94974>>>    //   A struct array with all master & alias
94974>>>    Procedure RestoreOpenTables
94976>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94976>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94977>>>        Integer hTable iFileAlias iSize iCount
94977>>>        Boolean bOpen
94977>>>        String sRootName
94977>>>
94977>>>        Move 0 to hTable
94978>>>        Get paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
94979>>>        Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
94980>>>        Decrement iSize
94981>>>        For iCount from 0 to iSize
94987>>>>
94987>>>            Move aDbUpdateHandlerMasterAlias[iCount].hTable to hTable
94988>>>            // We also need to check that the table hasn't been removed...
94988>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
94991>>>            If (hTable <> 0 and sRootName <> "") Begin
94993>>>                Open hTable
94995>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
94998>>>                If (bOpen = True) Begin
95000>>>                    Move aDbUpdateHandlerMasterAlias[iCount].iMode to iFileAlias
95001>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
95003>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_MASTER
95006>>>                    End
95006>>>>
95006>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
95009>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_ALIAS
95012>>>                    End
95012>>>>
95012>>>                End
95012>>>>
95012>>>            End
95012>>>>
95012>>>        Loop
95013>>>>
95013>>>    End_Procedure
95014>>>
95014>>>    // This checks for both duplicate pnVersionNumbers _and_ that
95014>>>    // the cDbVersion object pnVersionNumber's all are consecutive (higher than the previous).
95014>>>    Procedure CheckForDuplicates Number nVersion
95016>>>        tDbVersionInfo[] DbVersionInfoArray
95016>>>        tDbVersionInfo[] DbVersionInfoArray
95017>>>        Integer iCount iSize iHits iDuplicateIndex
95017>>>        Number nCompare
95017>>>        Handle hObject1 hObject2
95017>>>        String sObjectName1 sObjectName2
95017>>>        Boolean bObjectOrderError
95017>>>
95017>>>        Get paDbVersionInfoArray to DbVersionInfoArray
95018>>>        Move (SizeOfArray(DbVersionInfoArray)) to iSize
95019>>>        Decrement iSize
95020>>>        Move 0 to iHits
95021>>>        Move 0 to nCompare
95022>>>        Move False to bObjectOrderError
95023>>>        For iCount from 0 to iSize
95029>>>>
95029>>>            If (nVersion = DbVersionInfoArray[iCount].nVersionNumber) Begin
95031>>>                Increment iHits
95032>>>                If (iHits > 1) Begin
95034>>>                    Move iCount to iDuplicateIndex
95035>>>                    If (nCompare <> 0) Begin
95037>>>                        Move (nCompare >= DbVersionInfoArray[iCount].nVersionNumber) to bObjectOrderError
95038>>>                    End
95038>>>>
95038>>>                End
95038>>>>
95038>>>            End
95038>>>>
95038>>>            Move DbVersionInfoArray[iCount].nVersionNumber to nCompare
95039>>>        Loop
95040>>>>
95040>>>        If (iHits > 1) Begin
95042>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
95043>>>            Move DbVersionInfoArray[(iDuplicateIndex   )].hObject to hObject1
95044>>>            Move DbVersionInfoArray[(iDuplicateIndex -1)].hObject to hObject2
95045>>>            Move (Name(hObject1)) to sObjectName1
95046>>>            Move (Name(hObject2)) to sObjectName2
95047>>>            Error DFERR_PROGRAM ("Duplicate version numbers! The SAME pnVersionNumber value was set for the following two objects; Program will now exit!\n\n" + sObjectName1 + "\n" + sObjectName2)
95048>>>>
95048>>>            Send Exit_Application
95049>>>        End
95049>>>>
95049>>>        Else If (bObjectOrderError = True) Begin
95052>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
95053>>>            Error DFERR_PROGRAM ("cDbVersion objects out of order! One or more of the cDbVersion objects has been placed out of order. This means that at least one pnVersionNumber is HIGHER than the following object's pnVersionNumber.\nProgram will now exit!")
95054>>>>
95054>>>            Send Exit_Application
95055>>>        End
95055>>>>
95055>>>    End_Procedure
95056>>>
95056>>>    // We take care of all errors in the Error_Report below and
95056>>>    // collect them all to an array property. So just ignore any
95056>>>    // "Ignore_Error" & "Trap_Error" messages that might be send/used
95056>>>    // in some other package.
95056>>>    Procedure Ignore_Error Integer iError
95058>>>    End_Procedure
95059>>>
95059>>>    Procedure Trap_Error Integer iError
95061>>>    End_Procedure
95062>>>
95062>>>    // Build complete error description from Flexerrs and user error message.
95062>>>    Function Error_Description Integer Error# String ErrMsg Returns String
95064>>>        String Full_Error_Text
95064>>>        
95064>>>        Move (Trim(ErrMsg)) to ErrMsg
95065>>>        Move (Trim(Error_Text(DESKTOP, Error#))) to Full_Error_Text
95066>>>        
95066>>>        If (ErrMsg <> "") Begin
95068>>>            
95068>>>            If ((Full_Error_Text<>"" ) and ;                Error_Text_Available( DESKTOP, Error# ) ) Begin
95070>>>                // Make sure last character of error text is a separating symbol.
95070>>>                // if not, add a "." So we have format of "error-text. error-detail"
95070>>>                If (Pos(Right(Full_Error_Text,1),".,:;") =0) ;                    Move (Full_Error_Text - ".") to Full_Error_Text
95073>>>                Move (Full_Error_Text * ErrMsg)  to Full_Error_Text
95074>>>            End
95074>>>>
95074>>>            Else ;                Move ErrMsg to Full_Error_Text
95076>>>            
95076>>>        End
95076>>>>
95076>>>        
95076>>>        Function_Return Full_Error_Text
95077>>>    End_Function
95078>>>
95078>>>    // While we update the database we collect all errors in
95078>>>    // the struct array paDbUpdateErrorArray.
95078>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
95080>>>        Number nVersion
95080>>>        Handle hoLogFile 
95080>>>        
95080>>>        If (Private.pbProcessingError(Self)) Begin
95082>>>            Procedure_Return
95083>>>        End
95083>>>>
95083>>>
95083>>>        // The UtilTableNameFromHandleToString function does a:
95083>>>        // "Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName" call
95083>>>        // and it generates an error if the table is of the embedded type.
95083>>>        // As we don't want to trigger an error in that very specific case,
95083>>>        // we just ignore it here.
95083>>>        //
95083>>>        // If no report mode, just set the err indicator to false.
95083>>>        If (Error_Report_Mode(Self) = DUF_ERROR_NO_REPORT) Begin
95085>>>            Set Private.pbProcessingError to False
95086>>>            Procedure_Return
95087>>>        End
95087>>>>
95087>>>
95087>>>        If (iErrorNumber = DFERR_UNSUPPORTED_ATTRIBUTE) Begin
95089>>>            Set Private.pbProcessingError to False
95090>>>            Procedure_Return
95091>>>        End
95091>>>>
95091>>>
95091>>>        Set Private.pbProcessingError to True
95092>>>        Set Private.pbUpdateVersionObjectError to True
95093>>>
95093>>>        Set pbDbUpdateErrorHasOccured to True
95094>>>        Get pnCurrentVersionUpdate to nVersion
95095>>>        Get phoLogFile to hoLogFile
95096>>>        Send LogError of hoLogFile nVersion iErrorNumber sErrorText iErrorLine True
95097>>>
95097>>>        Set Private.pbProcessingError to False
95098>>>    End_Procedure
95099>>>
95099>>>End_Class
95100>
95100>Object oHtmlHelp is a cHtmlHelp
95102>    Set pbAlwaysOnTop to False
95103>
95103>    // Overriden class message to also handle internet HTML Help links;
95103>    // which in which case we should not try to find the path to the help file.
95103>    Function GetHelpFile Returns String
95106>        String sHelpFile
95106>
95106>        Get psHelpFile of ghoApplication to sHelpFile
95107>        If (sHelpFile <> "" and not(sHelpFile contains "http:")) Begin
95109>            Get_File_Path sHelpFile to sHelpFile
95110>        End
95110>        Function_Return sHelpFile
95111>    End_Function
95112>
95112>End_Object
95113>
95113>Object oApplication is a cApplication
95115>    Set peHelpType to htHtmlHelp
95116>
95116>    // Note: These help file settings gets changed by the Help toolbar button(s).
95116>    Set psHelpFile to "Developer5.chm"
95117>
95117>    Set pbPreserveEnvironment to True
95118>    Set psProduct to "Database Update Framework Lab"
95119>    Set psCompany to "RDC Tools International" 
95120>
95120>    Object oConnection is a cConnection
95122>        Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (C:\Program Files\DataFlex 24.0\Pkg\LoginEncryption.pkg)
95122>>>Use cLoginEncryption.pkg
95122>>>
95122>>>Object oLoginEncryption is a cLoginEncryption
95124>>>
95124>>>    // this must be created in your appsrc directory and must contain an encryption
95124>>>    // key that is set to psEncryptPassword. It will look something like this
95124>>>    //
95124>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
95124>>>    //  
Including file: LoginEncryptionKey.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\LoginEncryptionKey.inc)
95124>>>>// Studio generated login encryption key
95124>>>>Set psEncryptPassword to "%sLm*XHVF>f0yB.:.PHrBx6L)8x70i7zAN{q._WC"
95125>>>>
95125>>>    
95125>>>    // use this to register this object to your cConnection Object. This object
95125>>>    // must be created after the cConnection object
95125>>>    Move Self to ghoLoginEncryption
95126>>>End_Object
95127>        Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (C:\Program Files\DataFlex 24.0\Pkg\DatabaseLoginDialog.dg)
95127>>>
95127>>>Use Windows.pkg
95127>>>Use cConnection.pkg
95127>>>Use dfLine.pkg
95127>>>
95127>>>Object oDatabaseLoginDialog is a ModalPanel
95129>>>    Set Label to "Database Login"
95130>>>    Set Location to 2 2
95131>>>    Set Size to 110 211
95132>>>    
95132>>>    Property String psId
95134>>>    Property Boolean pbOk False
95136>>>    Property Boolean pbChanged False
95138>>>    Property Boolean pbAllowRemember True
95140>>>    
95140>>>    // this registers this object with the cConnection object.
95140>>>    Move Self to ghoLoginConnectDialog
95141>>>    
95141>>>    Object oUserIDForm is a Form
95143>>>        Set Label to "User Name"
95144>>>        Set Size to 12 85
95145>>>        Set Location to 34 79
95146>>>        Set Label_Col_Offset to 64
95147>>>        Set peAnchors to anTopLeftRight
95148>>>    End_Object
95149>>>    
95149>>>    Object oPwdForm is a Form
95151>>>        Set Size to 12 85
95152>>>        Set Location to 49 79
95153>>>        Set Label_Col_Offset to 64
95154>>>        Set Password_State to True
95155>>>        Set peAnchors to anTopLeftRight
95156>>>        Set Label to "Password"
95157>>>    End_Object
95158>>>    
95158>>>    Object oTrustedConnection is a CheckBox
95160>>>        Set Size to 10 50
95161>>>        Set Location to 65 79
95162>>>        Set Label to "Trusted Connection"
95163>>>    End_Object
95164>>>    
95164>>>    Object oRemember is a CheckBox
95166>>>        Set Size to 10 50
95167>>>        Set Location to 79 14
95168>>>        Set Label to "Remember and don't ask again"
95169>>>        Set Checked_State to True
95170>>>    End_Object
95171>>>    
95171>>>    Object oLogin_btn is a Button
95173>>>        Set Label to "&Login"
95174>>>        Set Location to 92 102
95175>>>        Set peAnchors to anBottomRight
95176>>>        Set Default_State to True
95177>>>        
95177>>>        Procedure OnClick
95180>>>            Boolean bTrust
95180>>>            String sUser sPwd sConn sErr sId
95180>>>            Integer iError
95180>>>            Get psId to sId
95181>>>            Get Value of oUserIDForm to sUser
95182>>>            Get Value of oPwdForm to sPwd
95183>>>            Get Checked_State of oTrustedConnection to bTrust
95184>>>            
95184>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
95185>>>            If (iError=0) Begin
95187>>>                Set pbOk to True
95188>>>                Set pbChanged to True
95189>>>                Send Close_Panel
95190>>>            End
95190>>>>
95190>>>            Else Begin
95191>>>                Get psErrorText of ghoConnection to sErr
95192>>>                Send UserError sErr "Login Error"
95193>>>            End
95193>>>>
95193>>>        End_Procedure
95194>>>    End_Object
95195>>>    
95195>>>    Object oCancel_btn is a Button
95197>>>        Set Label to "&Cancel"
95198>>>        Set Location to 92 157
95199>>>        Set peAnchors to anBottomRight
95200>>>        
95200>>>        Procedure OnClick
95203>>>            Send Close_Panel
95204>>>        End_Procedure
95205>>>    End_Object
95206>>>    
95206>>>    Object oConnectionIdInfo is a TextBox
95208>>>        Set Size to 10 50
95209>>>        Set Location to 4 14
95210>>>        Set Label to 'Connection Id='
95211>>>    End_Object
95212>>>    
95212>>>    Object oConnectionServerInfo is a TextBox
95214>>>        Set Size to 10 50
95215>>>        Set Location to 16 14
95216>>>        Set Label to 'Server'
95217>>>    End_Object
95218>>>    
95218>>>    Object oLineControl1 is a LineControl
95220>>>        Set Size to 2 202
95221>>>        Set Location to 29 5
95222>>>    End_Object
95223>>>    
95223>>>    Function LoginConnectIdDialog String sId Returns Boolean
95226>>>        Boolean bOk bChanged bTrusted bAllowRemember bRemember
95226>>>        String sUser sPwd sDescription
95226>>>        tConnection Connect
95226>>>        tConnection Connect
95226>>>        
95226>>>        Get pbAllowRemember to bAllowRemember
95227>>>        
95227>>>        
95227>>>        If not bAllowRemember Begin
95229>>>            Set Enabled_State of oRemember to bRemember
95230>>>            Set Visible_State of oRemember to bRemember
95231>>>        End
95231>>>>
95231>>>        
95231>>>        Get ConnectionIdInfo of ghoConnection sId to Connect
95232>>>        Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
95233>>>        Set Value of oConnectionServerInfo to Connect.sString
95234>>>        
95234>>>        Set psId to sId
95235>>>        Set pbOk to False
95236>>>        Set pbChanged to False
95237>>>        Set Value of oUserIDForm to Connect.sUID
95238>>>        Set Value of oPwdForm to ""
95239>>>        
95239>>>        Send Popup
95240>>>        
95240>>>        Get pbOk to bOk
95241>>>        Get pbChanged to bChanged
95242>>>        If (bChanged and bOk) Begin
95244>>>            If bAllowRemember Begin
95246>>>                Get Checked_State of oRemember to bRemember
95247>>>                If bRemember Begin
95249>>>                    Get Checked_State of oTrustedConnection to bTrusted
95250>>>                    If not (bTrusted) Begin
95252>>>                        Get Value of oUserIDForm to sUser
95253>>>                        Get Value of oPwdForm to sPwd
95254>>>                    End
95254>>>>
95254>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
95255>>>                End
95255>>>>
95255>>>            End
95255>>>>
95255>>>        End
95255>>>>
95255>>>        Function_Return bOk
95256>>>    End_Function
95257>>>    
95257>>>    
95257>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
95258>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
95259>>>End_Object
95260>>>
95260>    End_Object
95261>
95261>End_Object   
95262>
95262>Object oDbUpdateHandler is a cDbUpdateHandler 
95264>    Set piDbVersionFileNumber to 255
95265>    Set piDbVersionFieldNumber to 1
95266>    
95266>End_Object
95267>
95267>Object oCJSkinFramework is a cCJSkinFramework
95269>    Set pbLoadPreference to True
95270>End_Object
95271>
95271>Object oToolTipController is a cToolTipController
95273>    Set piDurationPopup to 10000
95274>    Set piMaxWidth to 500
95275>    Move Self to ghoToolTipController
95276>End_Object
95277>
95277>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files\DataFlex 24.0\Pkg\oEditContextMenu.pkg)
95277>>>Use cCJStandardMenuItemClasses.pkg
95277>>>
95277>>>Object oEditContextMenu is a cCJContextMenu
95279>>>    
95279>>>    Move Self to Default_Form_Floating_Menu_ID
95280>>>    
95280>>>    Object oUndoMenuItem is a cCJUndoMenuItem
95282>>>    End_Object
95283>>>    
95283>>>    Object oCutMenuItem is a cCJCutMenuItem
95285>>>        Set pbControlBeginGroup to True
95286>>>    End_Object
95287>>>    
95287>>>    Object oCopyMenuItem is a cCJCopyMenuItem
95289>>>    End_Object
95290>>>
95290>>>    Object oPasteMenuItem is a cCJPasteMenuItem
95292>>>    End_Object
95293>>>
95293>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
95295>>>    End_Object
95296>>>
95296>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
95298>>>        Set pbControlBeginGroup to True
95299>>>    End_Object
95300>>>
95300>>>End_Object
95301>>>
95301>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files\DataFlex 24.0\Pkg\oDEOEditContextMenu17.pkg)
95301>>>Use Windows.pkg
95301>>>Use cCJStandardMenuItemClasses.pkg
95301>>>Use cCJDeoMenuItemClasses.pkg
95301>>>
95301>>>
95301>>>Object oDEOEditContextMenu17 is a cCJContextMenu
95303>>>    
95303>>>    Move Self to Default_dbFloating_Menu_ID
95304>>>    
95304>>>    Object oUndoMenuItem is a cCJUndoMenuItem
95306>>>    End_Object
95307>>>    
95307>>>    Object oCutMenuItem is a cCJCutMenuItem
95309>>>        Set pbControlBeginGroup to True
95310>>>    End_Object
95311>>>    
95311>>>    Object oCopyMenuItem is a cCJCopyMenuItem
95313>>>    End_Object
95314>>>
95314>>>    Object oPasteMenuItem is a cCJPasteMenuItem
95316>>>    End_Object
95317>>>
95317>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
95319>>>    End_Object
95320>>>
95320>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
95322>>>        Set pbControlBeginGroup to True
95323>>>    End_Object
95324>>>
95324>>>    Object oPromptMenuItem is a cCJPromptMenuItem
95326>>>        Set pbControlBeginGroup to True
95327>>>    End_Object
95328>>>
95328>>>    Object oFindNextMenu is a cCJFindNextMenuItem
95330>>>        Set pbControlBeginGroup to True
95331>>>    End_Object
95332>>>
95332>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
95334>>>    End_Object
95335>>>
95335>>>    Object oClearMenuItem is a cCJClearMenuItem
95337>>>        Set pbControlBeginGroup to True
95338>>>    End_Object
95339>>>
95339>>>    Object oClearAllMenu is a cCJClearAllMenuItem
95341>>>    End_Object
95342>>>
95342>>>    Object oSaveMenu is a cCJSaveMenuItem
95344>>>    End_Object
95345>>>    
95345>>>    Object oDeleteMenu is a cCJDeleteMenuItem
95347>>>    End_Object
95348>>>
95348>>>    Object oRememberitem is a cCJRememberFieldMenuItem
95350>>>        Set pbControlBeginGroup to True
95351>>>    End_Object
95352>>>
95352>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
95354>>>    End_Object
95355>>>
95355>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
95357>>>    End_Object
95358>>>
95358>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
95360>>>    End_Object
95361>>>
95361>>>End_Object
95362>Use cSkinComboBoxCJMenuItem.pkg
Including file: cSkinComboBoxCJMenuItem.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cSkinComboBoxCJMenuItem.pkg)
95362>>>Use cCJCommandBarSystem.pkg
95362>>>Use Wingdi.pkg
95362>>>Use LanguageText.pkg
95362>>>
95362>>>// User interface constant strings:
95362>>>Define CS_NoSkinShort For "-None"
95362>>>Define CS_NoSkinLong  For "Do not use a skin"
95362>>>
95362>>>
95362>>>
95362>>>
95362>>>
95362>>>
95362>>>
95362>>>
95362>>>
95362>>>
95362>>>Class cSkinComboBoxCJMenuItem is a cCJMenuItem
95363>>>
95363>>>    Procedure Construct_Object
95365>>>        Forward Send Construct_Object
95367>>>
95367>>>        Set peControlType to xtpControlComboBox
95368>>>
95368>>>        Property tSkinInformation[] pSkins
95369>>>
95369>>>    End_Procedure
95370>>>
95370>>>    Procedure End_Construct_Object
95372>>>        Forward Send End_Construct_Object
95374>>>    End_Procedure
95375>>>
95375>>>    // Custom array sort for the tSkinInformation struct array.
95375>>>    // Used by LoadSkins message to sort the skin array alphabetically after it has been loaded.
95375>>>    // Why?
95375>>>    // First of all, structs can't be used with the standard SortArray function, that is why we need to
95375>>>    // create a custom sort algorithm.
95375>>>    // Secondly the list of skins would else be sorted in the alphabetical order by the file names.
95375>>>    // However, it is not always the case that the skin description (sName) is the same as the file name.
95375>>>    // If it isn't (which is almost always the case if you have many skin files) the list will look
95375>>>    // randomly ordered. This custom sort method will take care of that.
95375>>>    Function SkinSort tSkinInformation sDescription tSkinInformation sSearchDescription Returns Integer
95377>>>        If ((sDescription.sName * sDescription.sSkinIni) > (sSearchDescription.sName * sSearchDescription.sSkinIni)) Begin
95379>>>            Function_Return (GT)
95380>>>        End
95380>>>>
95380>>>        If ((sDescription.sName * sDescription.sSkinIni) < (sSearchDescription.sName * sSearchDescription.sSkinIni)) Begin
95382>>>            Function_Return (LT)
95383>>>        End
95383>>>>
95383>>>        Function_Return (EQ)
95384>>>    End_Function
95385>>>
95385>>>    Procedure OnCreateControl Handle hoObj
95387>>>        Forward Send OnCreateControl hoObj
95389>>>
95389>>>        Send LoadSkins
95390>>>        Send FillComboList hoObj
95391>>>    End_Procedure
95392>>>
95392>>>    // Load all skins. We will only look for skins in expected
95392>>>    // directory which is the Programs folder.
95392>>>    // Important: When loading skins they will be sorted alphabetically. (See Skinsort function above).
95392>>>    // This is not the case with the 'standard' VDF behaviour.
95392>>>    Procedure LoadSkins
95394>>>        Integer iCount iItems iSize
95394>>>        Boolean bFound
95394>>>        String sFile sIni sSkin
95394>>>        tSkinInformation[] SkinsArray SkinsArrayNoLarge
95394>>>        tSkinInformation[] SkinsArray SkinsArrayNoLarge
95396>>>        tSkinInformation NoneRow
95396>>>        tSkinInformation NoneRow
95396>>>
95396>>>        If (ghoSkinFramework > 0) Begin
95398>>>            Get EnumerateSkins of ghoSkinFramework "" True   to SkinsArray
95399>>>
95399>>>            Move (SortArray(SkinsArray, Self, get_SkinSort)) to SkinsArray
95400>>>            Move CS_NoSkinShort to NoneRow.sName
95401>>>            Move CS_NoSkinLong  to NoneRow.sSkinfile
95402>>>            Move CS_NoSkinLong  to NoneRow.sSkinIni
95403>>>            Move (InsertInArray(SkinsArray, 0, NoneRow))     to SkinsArray
95404>>>
95404>>>            // Get the currently loaded skin.
95404>>>            Get psSkinFile of ghoSkinFramework to sFile
95405>>>            Get psSkinIni  of ghoSkinFramework to sIni
95406>>>
95406>>>            // Remove all Extra Large and Large skins from the array.
95406>>>            Move (SizeOfArray(SkinsArray)) to iItems
95407>>>            Decrement iItems
95408>>>            For iCount From 0 to iItems
95414>>>>
95414>>>                Move SkinsArray[iCount].sSkinIni to sSkin
95415>>>                Move (Uppercase(sSkin) contains " LARGE") to bFound
95416>>>                If (bFound = False) Begin
95418>>>                    Move (SizeOfArray(SkinsArrayNoLarge)) to iSize
95419>>>                    Move SkinsArray[iCount].sName         to SkinsArrayNoLarge[iSize].sName
95420>>>                    Move SkinsArray[iCount].sSkinfile     to SkinsArrayNoLarge[iSize].sSkinfile
95421>>>                    Move SkinsArray[iCount].sSkinIni      to SkinsArrayNoLarge[iSize].sSkinIni
95422>>>                End
95422>>>>
95422>>>            Loop
95423>>>>
95423>>>            Set pSkins to SkinsArrayNoLarge
95424>>>        End
95424>>>>
95424>>>    End_Procedure
95425>>>
95425>>>    // Fills the CodeJock combobox with all skins from the current Programs folder.
95425>>>    Procedure FillComboList Handle hoCombo
95427>>>        Integer iCount iItems iCurrent iTxtEntentSize
95427>>>        String  sFile sIni sCurrSkin
95427>>>        String  sSkin sSkinText
95427>>>        tSkinInformation[] SkinsArray
95427>>>        tSkinInformation[] SkinsArray
95428>>>        Integer iSize
95428>>>
95428>>>        If (ghoSkinFramework < 1) Begin
95430>>>            Procedure_Return
95431>>>        End
95431>>>>
95431>>>
95431>>>        // Get the currently loaded skin.
95431>>>        Get psSkinFile of ghoSkinFramework to sFile
95432>>>        Get psSkinIni  of ghoSkinFramework to sIni
95433>>>        Get pSkins to SkinsArray
95434>>>        Move (SizeOfArray(SkinsArray)) to iItems
95435>>>        Decrement iItems
95436>>>        Send ComClear of hoCombo
95437>>>
95437>>>        For iCount From 0 to iItems
95443>>>>
95443>>>            Move SkinsArray[iCount].sSkinIni  to sSkin
95444>>>            Move (Replace(".ini", sSkin, "")) to sSkin
95445>>>            Move (SkinsArray[iCount].sName * "-" * sSkin) to sSkinText
95446>>>            Send ComAddItem of hoCombo sSkinText (iCount +1)
95447>>>            Get Text_Extent sSkinText to iSize
95448>>>            If (iSize > iTxtEntentSize) Begin
95450>>>                Move iSize to iTxtEntentSize
95451>>>            End
95451>>>>
95451>>>            Move (SkinsArray[iCount].sSkinFile * "-" * SkinsArray[iCount].sSkinIni) to sCurrSkin
95452>>>            If (sCurrSkin = (sFile * "-" * sIni)) Begin
95454>>>                Move iCount to iCurrent
95455>>>            End
95455>>>>
95455>>>        Loop
95456>>>>
95456>>>
95456>>>        Move (Low(iTxtEntentSize) + 30)  to iSize
95457>>>        Set ComDropDownWidth of hoCombo  to iSize
95458>>>        Set ComWidth         of hoCombo  to (iSize + 100)
95459>>>        Set ComListIndex     of hoCombo  to (iCurrent +1)
95460>>>    End_Procedure
95461>>>
95461>>>    // Event for when an item is selected from the comboform
95461>>>    Procedure OnExecute Variant vCommandBarControl
95463>>>        Handle  hoCombo
95463>>>        Integer iSelection
95463>>>        String  sSkinFile sSkinIni
95463>>>        tSkinInformation[] SkinsArray
95463>>>        tSkinInformation[] SkinsArray
95464>>>
95464>>>        // Create and bind proxy control
95464>>>        Get CreateProxyControl vCommandBarControl to hoCombo
95465>>>        // Get the current selection
95465>>>        Get ComListIndex of hoCombo to iSelection
95466>>>        Decrement iSelection
95467>>>        Get pSkins to SkinsArray
95468>>>        Move SkinsArray[iSelection].sSkinfile to sSkinFile
95469>>>        Move SkinsArray[iSelection].sSkinIni  to sSkinIni
95470>>>
95470>>>        Send DoChangeSkin sSkinFile sSkinIni
95471>>>
95471>>>        // Dispose of the proxy control
95471>>>        Send Destroy of hoCombo
95472>>>    End_Procedure
95473>>>
95473>>>    // Send this message to change the current skin.
95473>>>    Procedure DoChangeSkin String sSkinFile String sSkinIni
95475>>>        Handle hoClient
95475>>>
95475>>>        Set psSkinFile of ghoSkinFramework to sSkinFile
95476>>>        Set psSkinIni  of ghoSkinFramework to sSkinIni
95477>>>        Send ApplySkin of ghoSkinFramework
95478>>>
95478>>>        // Note: The following line is essential for the resizing logic
95478>>>        // to function properly when changing a skin and a view is maximized.
95478>>>        Move (Client_Id(phoMainPanel(ghoApplication))) to hoClient
95479>>>        Set Size of hoClient to (Hi(Size(hoClient))) (Low(Size(hoClient) +2))
95480>>>        Set Size of hoClient to (Hi(Size(hoClient))) (Low(Size(hoClient) -2))
95481>>>    End_Procedure
95482>>>
95482>>>    // Returns: DPI setting as an integer.
95482>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
95482>>>    //                      iDPI=120 is "Medium setting" 125%
95482>>>    //                      iDPI= 144 is "Large setting" 150%
95482>>>    Function GetCurrentDPI Returns Integer
95484>>>        Handle hDC
95484>>>        Integer iPixelsX
95484>>>        Move (GetDC(0)) to hDC
95485>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
95486>>>        Move (ReleaseDC(0, hDC)) to hDC
95487>>>        Function_Return iPixelsX
95488>>>    End_Function
95489>>>
95489>>>End_Class
95490>
95490>Object oMain is a Panel
95492>    Set Label to "Test Program - The Database Update Framework"
95493>    Set Location to 2 2
95494>    Set Size to 309 493
95495>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
95496>    Set Icon to "TestTools.ico"
95497>
95497>    Property Handle phoViewMenu 0
95499>    Property Handle phoReportMenu 0
95501>
95501>    Object oCommandBarSystem is a cCJCommandBarSystem
95503>        Set pbTimerUpdate to True
95504>            Set pbAutoResizeIcons to True
95505>            Set pbTabbedWorkspaces to True // Switch on for DF 19 to see the new tabbed-view look.
95506>            Set peVisualTheme to xtpThemeOffice2013Publisher
95507>            Set pbLargeIcons to True
95508>
95508>        Procedure OnCreateCommandBars
95511>            Handle hoOptions
95511>            Forward Send OnCreateCommandBars
95513>                Get OptionsObject to hoOptions
95514>                Send ComSetIconSize of hoOptions False 32 32  // Set icon size for Toolbar buttons.
95515>        End_Procedure
95516>
95516>
95516>    Procedure OnCreateTabbedWorkspace Handle hoTabWorkspace Handle hoTabPaintManager
95519>        Set ComShowIcons of hoTabPaintManager to True
95520>
95520>        // This will truncate the middle part of long items
95520>        Set ComDrawTextPathEllipsis of hoTabPaintManager to True
95521>    End_Procedure
95522>
95522>        // This is needed to get the "Key_Shift+Key_Tab" key combination to activate
95522>        // the previous tab workspace view.
95522>        Object oPreviousTabAction is a cCJAction
95524>            Set piShortCutKey to (xtpKey_Shift + xtpKey_Ctrl) VK_TAB
95525>            Procedure OnExecute Variant vCommandBarControl
95528>                Handle hoCommandBars hoClientArea
95528>                Forward Send OnExecute vCommandBarControl
95530>                Get CommandBarSystemObject to hoCommandBars
95531>                Get ClientAreaObject of hoCommandBars to hoClientArea
95532>                If hoClientArea Begin
95534>                    Send Switch_Next_View of hoClientArea
95535>                End
95535>            End_Procedure
95536>        End_Object
95537>
95537>        Object oToolBar is a cCJToolbar
95539>            Set psTitle to "Edit Toolbar"
95540>            Set pbGripper to False
95541>            Set peStretched to stStretch
95542>
95542>            Object oCutToolbarItem is a cCJCutMenuItem  
95544>                Set psImage to "ActionCut1.ico"
95545>            End_Object
95546>
95546>            Object oCopyToolbarItem is a cCJCopyMenuItem
95548>                Set psImage to "ActionCopy1.ico"
95549>            End_Object
95550>
95550>            Object oPasteToolbarItem is a cCJPasteMenuItem
95552>                Set psImage to "ActionPaste1.ico"
95553>            End_Object
95554>
95554>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
95556>                Set psImage to "ActionDelete1.ico"
95557>                Set pbControlBeginGroup to True
95558>            End_Object
95559>
95559>            Object oTheme_tb is a cCJMenuItem
95561>                Set peControlType to xtpControlLabel
95562>                Set psCaption to "Theme:"
95563>                Set pbControlBeginGroup to True
95564>            End_Object
95565>
95565>            Object oThemeItem is a cCJMenuItem
95567>                Set peControlType to xtpControlComboBox
95568>                Set psToolTip to "Select a theme to change the appearance of menu- and toolbars."
95569>
95569>                Procedure OnCreateControl Handle hoObj
95572>                    Integer iItem eTheme
95572>                    Set ComWidth of hoObj to 250
95573>                    Send FillComboList hoObj
95574>                    Get peVisualTheme to eTheme
95575>                    Get FindDataItem hoObj eTheme to iItem
95576>                    Set ComListIndex of hoObj to (If(iItem,iItem,1))
95577>                End_Procedure
95578>
95578>                Function FindDataItem Handle hoCombo Integer eVal Returns Integer
95581>                    Integer iCount i eTheme
95581>                    Get ComListCount of hoCombo to iCount
95582>                    For i from 1 to iCount
95588>                        Get ComItemData of hoCombo i to eTheme
95589>                        If (eTheme=eVal) Begin
95591>                            Send SetTheTheme eTheme
95592>                            Function_Return i
95593>                        End
95593>                    Loop
95594>                    Function_Return 0
95595>                End_Function
95596>
95596>                Procedure AddTheme Handle hoCombo String sText Integer eTheme
95599>                    Integer iCount
95599>                    Get ComListCount of hoCombo to iCount
95600>                    Increment iCount
95601>                    Send ComAddItem  of hoCombo sText iCount
95602>                    Set ComItemData  of hoCombo iCount to  eTheme
95603>                End_Procedure
95604>
95604>                Procedure FillComboList Handle hoCombo
95607>                    Send ComClear     of hoCombo
95608>                        Send AddTheme hoCombo "xtpThemeOffice2013Word" xtpThemeOffice2013Word
95609>                        Send AddTheme hoCombo "xtpThemeOffice2013Outlook" xtpThemeOffice2013Outlook
95610>                        Send AddTheme hoCombo "xtpThemeOffice2013Excel" xtpThemeOffice2013Excel
95611>                        Send AddTheme hoCombo "xtpThemeOffice2013PowerPoint" xtpThemeOffice2013PowerPoint
95612>                        Send AddTheme hoCombo "xtpThemeOffice2013Publisher" xtpThemeOffice2013Publisher
95613>                        Send AddTheme hoCombo "xtpThemeOffice2013OneNote" xtpThemeOffice2013OneNote
95614>                        Send AddTheme hoCombo "xtpThemeOffice2013Access" xtpThemeOffice2013Access
95615>                        Send AddTheme hoCombo "xtpThemeOffice2003" xtpThemeOffice2003
95616>                        Send AddTheme hoCombo "xtpThemeOffice2000" xtpThemeOffice2000
95617>                        Send AddTheme hoCombo "xtpThemeOfficeXP" xtpThemeOfficeXP
95618>    
95618>                        Send AddTheme hoCombo "xtpThemeOffice2010Blue" xtpThemeOffice2010Blue
95619>                        Send AddTheme hoCombo "xtpThemeOffice2010Black" xtpThemeOffice2010Black
95620>                        Send AddTheme hoCombo "xtpThemeOffice2010Silver" xtpThemeOffice2010Silver
95621>    
95621>                        Send AddTheme hoCombo "xtpThemeOffice2007Aqua" xtpThemeOffice2007Aqua
95622>                        Send AddTheme hoCombo "xtpThemeOffice2007Black" xtpThemeOffice2007Black
95623>                        Send AddTheme hoCombo "xtpThemeOffice2007Blue" xtpThemeOffice2007Blue
95624>                        Send AddTheme hoCombo "xtpThemeOffice2007Silver" xtpThemeOffice2007Silver
95625>    
95625>                        Send AddTheme hoCombo "xtpThemeVisualStudio2015Blue" xtpThemeVisualStudio2015Blue
95626>                        Send AddTheme hoCombo "xtpThemeVisualStudio2015Light" xtpThemeVisualStudio2015Light
95627>                        Send AddTheme hoCombo "xtpThemeVisualStudio2015Dark" xtpThemeVisualStudio2015Dark
95628>    
95628>                        Send AddTheme hoCombo "xtpThemeVisualStudio2012Light" xtpThemeVisualStudio2012Light
95629>                        Send AddTheme hoCombo "xtpThemeVisualStudio2012Dark" xtpThemeVisualStudio2012Dark
95630>    
95630>                        Send AddTheme hoCombo "xtpThemeVisualStudio2008" xtpThemeVisualStudio2008
95631>                        Send AddTheme hoCombo "xtpThemeVisualStudio6" xtpThemeVisualStudio6
95632>    
95632>                        Send AddTheme hoCombo "xtpThemeWindows7" xtpThemeWindows7
95633>    
95633>                        Send AddTheme hoCombo "xtpThemeWhidbey" xtpThemeWhidbey
95634>    
95634>                        Send AddTheme hoCombo "xtpThemeNativeWinXP" xtpThemeNativeWinXP
95635>                End_Procedure
95636>
95636>                Function CurrentTheme Handle vCommandBarControl Returns Integer
95639>                    Handle hMessage hoCombo
95639>                    Integer iIndex
95639>                    // create and bind  proxy control
95639>                    Get CreateProxyControl vCommandBarControl to hoCombo
95640>                    // get the current selection
95640>                    Get ComListIndex of hoCombo to iIndex
95641>                    // note the index selections are 1 based
95641>                    If (iIndex > 0) Begin
95643>                        // get the ItemData for the selected item and send that message
95643>                        Get ComItemData of hoCombo iIndex to hMessage
95644>                        Function_Return hMessage
95645>                    End
95645>                    // dispose of the proxy control
95645>                    Send Destroy of hoCombo
95646>                    Function_Return 0
95647>                End_Function
95648>
95648>                Procedure OnExecute Variant vCommandBarControl
95651>                    Integer eTheme
95651>                    Integer iColor
95651>                    Get CurrentTheme vCommandBarControl to eTheme
95652>                    Set peVisualTheme of ghoCommandBars to eTheme
95653>                    Send ComRecalcLayout of ghoCommandBars
95654>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
95655>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
95657>                End_Procedure
95658>
95658>                Procedure SetTheTheme Integer eTheme
95661>                    Integer iColor
95661>                    Set peVisualTheme of ghoCommandBars to eTheme
95662>                    Send ComRecalcLayout of ghoCommandBars
95663>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
95664>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
95666>                End_Procedure
95667>
95667>                Function ConvertSystemColor Integer iColor Returns Integer
95670>                    Integer iSysColor
95670>                    If (iColor = clDefault or iColor = clNone) Begin    // If default color then use -1
95672>                        Move clNone to iColor
95673>                    End
95673>                    Else If (iColor < 0) Begin    // If it is a system color (<0) then convert this into an RGB value
95676>                        Move (iColor iand |CI$7FFFFFFF) to iSysColor    // extract the system color constant
95677>                        Move (GetSysColor(iSysColor)) to iColor
95678>                    End
95678>                    Function_Return iColor
95679>                End_Function
95680>
95680>            End_Object
95681>
95681>            Object oAbout_MenuItem is a cCJMenuItem
95683>                Set psCaption to "About"
95684>                Set psToolTip to "About Info"
95685>                Set psDescription to "About the program"
95686>                Set psImage to "ActionAbout1.ico"
95687>                Set pbControlBeginGroup to True
95688>                Procedure OnExecute Variant vCommandBarControl
95691>                    Forward Send OnExecute vCommandBarControl
95693>                    Send Activate_About of (Client_Id(ghoCommandBars))
95694>                End_Procedure
95695>            End_Object
95696>
95696>            Object oHelpMenuItem is a cCJHelpMenuItem
95698>                Set peControlType to xtpControlSplitButtonPopup
95699>                Set psImage to "ActionHelp1.ico"
95700>
95700>                Procedure OnExecute Variant vCommandBarControl
95703>                    Forward Send OnExecute vCommandBarControl
95705>                    Set psHelpFile of ghoApplication to "DataFlex.chm"
95706>                    Send ShowProgramHelp
95707>                End_Procedure
95708>
95708>                Object oHelpMenuItemLocal is a cCJMenuItem
95710>                    Set psCaption to "Local HTML Help"
95711>                    Set psImage to "ActionHelp1.ico"
95712>                    Procedure OnExecute Variant vCommandBarControl
95715>                        Set psHelpFile of ghoApplication to "DataFlex.chm"
95716>                        Send ShowProgramHelp
95717>                    End_Procedure
95718>                End_Object
95719>
95719>                Object oHelpMenuItemInternetBrowser is a cCJMenuItem
95721>                    Set psCaption to "Internet Online HTML Help"
95722>                    Set psImage to "ActionHelp1.ico"
95723>                    Procedure OnExecute Variant vCommandBarControl
95726>                        Send vShellExecute "open" "http://www.rdctools.com/HTMLHelp/Developer5.htm" "" ""
95727>                    End_Procedure
95728>
95728>                End_Object
95729>            End_Object
95730>
95730>            Object oExitMenuItem is a cCJExitMenuItem
95732>                Set psImage to "ActionExit1.ico"
95733>                Set psToolTip to "Exit application"
95734>                Set psDescription to "Exit the program (Alt+F4)"
95735>                Set pbControlBeginGroup to True
95736>            End_Object
95737>        End_Object
95738>
95738>//        Object oSpacerBar is a cCJToolbar
95738>//            Set pbDockNextTo to False
95738>//            Set pbShowExpandButton to False
95738>//            Set pbGripper to False
95738>//            Set peStretched to stStretch
95738>//            Set pbCustomizable to False
95738>//            Set pbCloseable to False
95738>//            Set pbEnableDocking to False
95738>//            Set pbHideWrap to True
95738>//
95738>//            Object oFiller is a cCJMenuItem
95738>//            End_Object
95738>//
95738>//        End_Object
95738>
95738>        Object oStatusBar is a cCJStatusBar
95740>
95740>            Object oStatusPane1 is a cCJStatusBarPane
95742>                Set piID to sbpIDIdlePane
95743>                Set pbStyleStretch to True
95744>            End_Object
95745>            Object oStatusPane2 is a cCJStatusBarPane
95747>                Set phoViewPane to Self
95748>                Set pbStyleStretch to True
95749>            End_Object
95750>
95750>        End_Object
95751>
95751>    End_Object
95752>
95752>    Object oClientArea is a ClientArea
95754>
95754>//        Use Dd_debug.dg // This Provides access to dd debugger by pressing ctrl+d within any view. Good for debugging
95754>
95754>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\StdAbout.pkg)
95754>>>//************************************************************************
95754>>>// Confidential Trade Secret.
95754>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
95754>>>// as an unpublished work.  All rights reserved.
95754>>>// DataFlex is a registered trademark of Data Access Corporation.
95754>>>//
95754>>>//************************************************************************
95754>>>//************************************************************************
95754>>>//
95754>>>// $File name  : StdAbout.pkg
95754>>>// $File title : Standard about object package for VDF
95754>>>// Notice      :
95754>>>// $Author(s)  : John Tuohy
95754>>>//
95754>>>// $Rev History
95754>>>//
95754>>>// JT 06/27/97   File created
95754>>>//************************************************************************
95754>>>
95754>>>// This provides a quick and simple way to create an about package for a program.
95754>>>// You need to create a message inside you client area called Activate_About.
95754>>>// Within this message you should send the message DoAbout passing needed
95754>>>// string information.
95754>>>//
95754>>>//       Procedure Activate_About
95754>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
95754>>>//       End_Procedure
95754>>>//    where: sTitle =     Name of application. If none provided, uses caption
95754>>>//                        bar title
95754>>>//           sVersion   = Version Line. If none provided, will be blank
95754>>>//           sCopyRight = Copyright Line. If none provided, will be blank
95754>>>//           sAuthor    = Author name, blank if none provided
95754>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
95754>>>//                        is used.
95754>>>// It is expected that you will place this in your own object package. For
95754>>>// example an order about package may look like this:
95754>>>//
95754>>>//   // OrderAbout.pkg
95754>>>//   Use StdAbout.pkg
95754>>>//   Procedure Activate_About
95754>>>//      String sTitle sCopyright sVersion sAuthor
95754>>>//      Move "My Order Entry System" to sTitle
95754>>>//      Move "Version 2.1" to sVersion
95754>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
95754>>>//      Move "John Smith"  to sAuthor
95754>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
95754>>>//   end_procedure
95754>>>//   // end of file.
95754>>>
95754>>>Use DfAbout.pkg
95754>>>
95754>>>// *************************************************************************
95754>>>//  Public message. This is the default message. It is expected that you will
95754>>>//   create your own message to override this
95754>>>// *************************************************************************
95754>>>
95754>>>Procedure Activate_About
95757>>>    Send DoAbout "" "" "" "" "" "" "" "" "" ""
95758>>>End_Procedure
95759>>>
95759>>>// *************************************************************************
95759>>>//  Public message. It is expected that you will send this message (most
95759>>>//  likely from Activate_About. This creates an about object, activates it
95759>>>//  and destroys it when done. It is not exepected that you will augment this.
95759>>>// *************************************************************************
95759>>>// Sample usage:
95759>>>//   The first two params will automatically be filled from the application settings if not provided.
95759>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
95759>>>
95759>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;    String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
95762>>>    Integer hoObj hoMain iArgs
95762>>>    String sValue
95762>>>
95762>>>    // Create object
95762>>>    Object About is an AboutDialog
95764>>>    // Uncomment these two lines if you would like to have a resizable About object.
95764>>>    //            Set Border_Style to Border_Thick
95764>>>    //            Set peAnchors to anAll
95764>>>
95764>>>    // Add checking for the number of arguments passed to avoid runtime errors
95764>>>    // if one of them is not passed. This makes the interface
95764>>>    // more flexible.
95764>>>        Move num_arguments to iArgs
95765>>>
95765>>>        // If no title is passed use the label of the main panel (if a main panel exists).
95765>>>        If (iArgs > 0 and sTitle = "") Begin
95767>>>            Get Main_Window of Desktop to hoMain
95768>>>            If hoMain Begin
95770>>>                Get Label of hoMain to sValue
95771>>>            End
95771>>>>
95771>>>        End
95771>>>>
95771>>>        Else If (iArgs > 0 and sTitle <> "") Begin
95774>>>            Move sTitle to sValue
95775>>>        End
95775>>>>
95775>>>        Else If (iArgs = 0) Begin
95778>>>            Get Main_Window of Desktop to hoMain
95779>>>            If hoMain Begin
95781>>>                Get Label of hoMain to sValue
95782>>>            End
95782>>>>
95782>>>        End
95782>>>>
95782>>>
95782>>>        If (sValue <> "") Begin
95784>>>            Send Add_LineLn sValue
95785>>>        End
95785>>>>
95785>>>        Move "" to sValue
95786>>>
95786>>>        // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
95786>>>        // For this to work the Project Properties Version must have been set in the Studio.
95786>>>        If (iArgs < 2) Begin
95788>>>            Move "" to sValue
95789>>>        End
95789>>>>
95789>>>        Else Begin
95790>>>            Move sVersion to sValue
95791>>>        End
95791>>>>
95791>>>        Set Version to sValue
95792>>>
95792>>>        If (iArgs > 2 and sCopyRight <> "") Begin
95794>>>            Send Add_LineLn sCopyRight
95795>>>        End
95795>>>>
95795>>>
95795>>>        // If only the five "standard" params were passed we don't add an extra linefeed;
95795>>>        // else we do.
95795>>>        If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
95797>>>            Send Add_Line sAuthor
95798>>>        End
95798>>>>
95798>>>        Else If (iArgs > 5 and sAuthor <> "") Begin
95801>>>            Send Add_LineLn sAuthor
95802>>>        End
95802>>>>
95802>>>
95802>>>        // Square bitmaps of 80x80 works best
95802>>>        If (iArgs > 4 and sBitmap <> "") Begin
95804>>>            Set Logo to sBitMap
95805>>>        End
95805>>>>
95805>>>
95805>>>        // Here starts handling of the five optional params:
95805>>>        If (iArgs = 6 and sParam6  <> "") Begin
95807>>>            Send Add_Line sParam6
95808>>>        End
95808>>>>
95808>>>        Else If (iArgs > 6 and sParam6  <> "") Begin
95811>>>            Send Add_LineLn sParam6
95812>>>        End
95812>>>>
95812>>>
95812>>>        If (iArgs = 7 and sParam7  <> "") Begin
95814>>>            Send Add_Line sParam7
95815>>>        End
95815>>>>
95815>>>        Else If (iArgs > 7 and sParam7  <> "") Begin
95818>>>            Send Add_LineLn sParam7
95819>>>        End
95819>>>>
95819>>>
95819>>>        If (iArgs = 8 and sParam8  <> "") Begin
95821>>>            Send Add_Line sParam8
95822>>>        End
95822>>>>
95822>>>        Else If (iArgs > 8 and sParam8  <> "") Begin
95825>>>            Send Add_LineLn sParam8
95826>>>        End
95826>>>>
95826>>>
95826>>>        If (iArgs = 9 and sParam9  <> "") Begin
95828>>>            Send Add_Line sParam9
95829>>>        End
95829>>>>
95829>>>        Else If (iArgs > 9 and sParam9  <> "") Begin
95832>>>            Send Add_LineLn sParam9
95833>>>        End
95833>>>>
95833>>>
95833>>>        If (iArgs = 10 and sParam10 <> "") Begin
95835>>>            Send Add_Line sParam10
95836>>>        End
95836>>>>
95836>>>
95836>>>        Move Self to hoObj
95837>>>    End_Object
95838>>>
95838>>>    Send Popup   of hoObj // Popup the about object
95839>>>    Send Destroy of hoObj // When done, it will be destroyed
95840>>>End_Procedure
95841>        Use DatabaseSelection.dg
Including file: DatabaseSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DatabaseSelection.dg)
95841>>>Use Windows.pkg
95841>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJGridPromptList.pkg)
95841>>>>>Use Windows.pkg
95841>>>>>Use cCJGrid.pkg
95841>>>>>Use umPromptRelational.pkg
95841>>>>>
95841>>>>>Class cCJGridPromptList is a cCJGrid
95842>>>>>    
95842>>>>>    Procedure Construct_Object
95844>>>>>        Forward Send Construct_Object
95846>>>>>        
95846>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
95847>>>>>        Property Boolean Private_pbAutoOrdering True
95848>>>>>        Property Boolean pbAutoSearch True  // pops up search window
95849>>>>>        Property Integer peUpdateMode umPromptValue
95850>>>>>        Property Integer piUpdateColumn 0
95851>>>>>        Property Integer piInitialColumn -1
95852>>>>>        Property String  psSeedValue ''
95853>>>>>        Property Handle phmPromptUpdateCallback 0
95854>>>>>        Property Integer phoInvokingObject
95855>>>>>        
95855>>>>>        Property Boolean pbStoredAutoSeed
95856>>>>>        Property Boolean pbStoredAutoOrdering
95857>>>>>        Property Boolean pbStoredAutoSearch
95858>>>>>        Property Integer peStoredUpdateMode
95859>>>>>        Property Integer piStoredUpdateColumn
95860>>>>>        Property Integer piStoredInitialColumn
95861>>>>>        Property Handle  phmStoredPromptUpdateCallback
95862>>>>>        Property Boolean pbStoredSelectionEnable
95863>>>>>        Property Boolean pbStoredMultipleSelection
95864>>>>>        
95864>>>>>        // internally set by list
95864>>>>>        // these must be set upon closing the list and can be used for manual list updates
95864>>>>>        Property Boolean pbCanceled
95865>>>>>        Property Integer[] pSelectedRows
95866>>>>>        
95866>>>>>        Property Boolean pbNeedsNewOrdering
95867>>>>>        Property Boolean pbRequestSearch
95868>>>>>        Property tGridKeyPair[] pSearchKeys
95869>>>>>        
95869>>>>>        // these properties makes a prompt list a prompt list
95869>>>>>        // and should not be changed.
95869>>>>>        Set pbEditOnKeyNavigation to False
95870>>>>>        Set pbEditOnClick to False
95871>>>>>        Set pbReadOnly to True
95872>>>>>        Set pbFocusSubItems to True
95873>>>>>        
95873>>>>>        // these could maybe be changed
95873>>>>>        Set pbShadeSortColumn to True
95874>>>>>        Set pbHeaderReorders to True
95875>>>>>        Set pbHeaderTogglesDirection to True
95876>>>>>        Set pbHeaderSelectsColumn to True
95877>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
95878>>>>>        Set piFocusCellBackColor to clNone
95879>>>>>        Set piFocusCellForeColor to clNone
95880>>>>>        Set piFocusCellRectangleColor to clBlack
95881>>>>>        Set pbUseFocusCellRectangle to False
95882>>>>>        Set pbSelectionEnable to True
95883>>>>>        
95883>>>>>        On_Key kEnter Send Ok
95884>>>>>        On_Key kCancel Send Cancel
95885>>>>>        
95885>>>>>    End_Procedure
95886>>>>>    
95886>>>>>    // reorder list automatically on column change
95886>>>>>    // this also set pbFocusSubItems which is required to make the two states work
95886>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
95888>>>>>        Set Private_pbAutoOrdering to bAutoOrder
95889>>>>>        Set pbFocusSubItems to bAutoOrder
95890>>>>>    End_Procedure
95891>>>>>    
95891>>>>>    Function pbAutoOrdering Returns Boolean
95893>>>>>        Boolean bAutoOrder
95893>>>>>        Get Private_pbAutoOrdering to bAutoOrder
95894>>>>>        Function_Return bAutoOrder
95895>>>>>    End_Function
95896>>>>>    
95896>>>>>    // augmented to handle auto-ordering and invoking the search popup list
95896>>>>>    Procedure OnIdle
95898>>>>>        Boolean bNeedsReorder bSearch bOldToggle
95898>>>>>        Handle hoCol
95898>>>>>        Integer iKy1 iKy2 iCol
95898>>>>>        
95898>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
95899>>>>>        If bNeedsReorder Begin
95901>>>>>            Get SelectedColumn to iCol
95902>>>>>            If (iCol<>-1) Begin
95904>>>>>                
95904>>>>>                Get pbHeaderTogglesDirection to bOldToggle
95905>>>>>                Set pbHeaderTogglesDirection to False
95906>>>>>                Send HeaderReorder iCol
95907>>>>>                Set pbHeaderTogglesDirection to bOldToggle
95908>>>>>                
95908>>>>>                Set pbNeedsNewOrdering to False
95909>>>>>            End
95909>>>>>>
95909>>>>>        End
95909>>>>>>
95909>>>>>        
95909>>>>>        Get pbRequestSearch to bSearch
95910>>>>>        If bSearch Begin
95912>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
95913>>>>>        End
95913>>>>>>
95913>>>>>        
95913>>>>>        Forward Send OnIdle
95915>>>>>    End_Procedure
95916>>>>>    
95916>>>>>    Procedure OnStoreDefaults
95918>>>>>        Integer iVal
95918>>>>>        Boolean bVal
95918>>>>>        
95918>>>>>        Get pbAutoSeed to bVal
95919>>>>>        Set pbStoredAutoSeed to bVal
95920>>>>>        
95920>>>>>        Get pbAutoOrdering to bVal
95921>>>>>        Set pbStoredAutoOrdering to bVal
95922>>>>>        
95922>>>>>        Get pbAutoSearch to bVal
95923>>>>>        Set pbStoredAutoSearch to bVal
95924>>>>>        
95924>>>>>        Get peUpdateMode to iVal
95925>>>>>        Set peStoredUpdateMode to iVal
95926>>>>>        
95926>>>>>        Get piUpdateColumn to iVal
95927>>>>>        Set piStoredUpdateColumn to iVal
95928>>>>>        
95928>>>>>        Get piInitialColumn to iVal
95929>>>>>        Set piStoredInitialColumn to iVal
95930>>>>>        
95930>>>>>        Get phmPromptUpdateCallback to iVal
95931>>>>>        Set phmStoredPromptUpdateCallback to iVal
95932>>>>>        
95932>>>>>        Get pbSelectionEnable to bVal
95933>>>>>        Set pbStoredSelectionEnable to bVal
95934>>>>>        
95934>>>>>        Get pbMultipleSelection to bVal
95935>>>>>        Set pbStoredMultipleSelection to bVal
95936>>>>>        
95936>>>>>    End_Procedure
95937>>>>>    
95937>>>>>    Procedure OnRestoreDefaults
95939>>>>>        Integer iVal
95939>>>>>        Boolean bVal
95939>>>>>        
95939>>>>>        Get pbStoredAutoSeed to bVal
95940>>>>>        Set pbAutoSeed to bVal
95941>>>>>        
95941>>>>>        Get pbStoredAutoOrdering to bVal
95942>>>>>        Set pbAutoOrdering to bVal
95943>>>>>        
95943>>>>>        Get pbStoredAutoSearch to bVal
95944>>>>>        Set pbAutoSearch to bVal
95945>>>>>        
95945>>>>>        Get peStoredUpdateMode to iVal
95946>>>>>        Set peUpdateMode to iVal
95947>>>>>        
95947>>>>>        Get piStoredUpdateColumn to iVal
95948>>>>>        Set piUpdateColumn to iVal
95949>>>>>        
95949>>>>>        Get piStoredInitialColumn to iVal
95950>>>>>        Set piInitialColumn to iVal
95951>>>>>        
95951>>>>>        Get phmStoredPromptUpdateCallback to iVal
95952>>>>>        Set phmPromptUpdateCallback to iVal
95953>>>>>        
95953>>>>>        Get pbStoredSelectionEnable to bVal
95954>>>>>        Set pbSelectionEnable to bVal
95955>>>>>        
95955>>>>>        Get pbStoredMultipleSelection to bVal
95956>>>>>        Set pbMultipleSelection to bVal
95957>>>>>        
95957>>>>>    End_Procedure
95958>>>>>    
95958>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
95958>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
95958>>>>>    // Suitable for augmentation
95958>>>>>    Procedure OnSeedData
95960>>>>>        Integer iUpdateColumn iSortColumn
95960>>>>>        Boolean bSeed bAuto
95960>>>>>        String sValue
95960>>>>>        Handle hoCol
95960>>>>>        
95960>>>>>        Get piUpdateColumn to iUpdateColumn
95961>>>>>        Get psSeedValue to sValue
95962>>>>>        Get pbAutoSeed to bSeed
95963>>>>>        Get piSortColumn to iSortColumn
95964>>>>>        Get pbAutoOrdering to bAuto
95965>>>>>        // if not yet sorted and this is auto ordering we will
95965>>>>>        // sort the data for the search column. We do this to make the
95965>>>>>        // column search GE logic work properly.
95965>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
95967>>>>>            Get ColumnObject iUpdateColumn to hoCol
95968>>>>>            Send SortGridByColumn hoCol False
95969>>>>>        End
95969>>>>>>
95969>>>>>        
95969>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
95971>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0
95972>>>>>        End
95972>>>>>>
95972>>>>>        Else Begin
95973>>>>>            Send MovetoFirstRow
95974>>>>>        End
95974>>>>>>
95974>>>>>        
95974>>>>>    End_Procedure
95975>>>>>    
95975>>>>>    Procedure OnMoveValueOutByValue
95977>>>>>        String sValue
95977>>>>>        Handle hoInvokingObject hoCol  hoDataSource
95977>>>>>        Integer iRow iCol
95977>>>>>        Integer[] SelRowsIndexes
95978>>>>>        
95978>>>>>        Get phoInvokingObject to hoInvokingObject
95979>>>>>        Get pSelectedRows to SelRowsIndexes
95980>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
95982>>>>>            Get piUpdateColumn to iCol
95983>>>>>            Get ColumnObject iCol to hoCol
95984>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
95985>>>>>            Set Value of hoInvokingObject to sValue
95986>>>>>            Set Item_Changed_State of hoInvokingObject to True
95987>>>>>        End
95987>>>>>>
95987>>>>>    End_Procedure
95988>>>>>    
95988>>>>>    Procedure OnMoveValueOutByCustom
95990>>>>>    End_Procedure
95991>>>>>    
95991>>>>>    // augment to popup a search window when allowed
95991>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
95993>>>>>        Boolean bSubFocus bAutoSearch bChar
95993>>>>>        Integer iVal
95993>>>>>        
95993>>>>>        Get pbFocusSubItems to bSubFocus
95994>>>>>        Get pbAutoSearch to bAutoSearch
95995>>>>>        Forward Send OnComKeyDown llKeyCode llShift
95997>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
95999>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
96001>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
96002>>>>>                Move (iVal<>0) to bChar
96003>>>>>            End
96003>>>>>>
96003>>>>>            If bChar Begin
96005>>>>>                // this can get called multiple times before a search dialog pops up
96005>>>>>                Send AddToSearchKeys llKeyCode llShift
96006>>>>>            End
96006>>>>>>
96006>>>>>        End
96006>>>>>>
96006>>>>>    End_Procedure
96007>>>>>    
96007>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
96009>>>>>        Boolean bAutoSearch
96009>>>>>        Integer iKeyCode iShiftCode
96009>>>>>        Get pbAutoSearch to bAutoSearch
96010>>>>>        If bAutoSearch Begin
96012>>>>>            // this can get called multiple times before a search dialog pops up
96012>>>>>            Get piLastKey to iKeyCode
96013>>>>>            Get piLastKey2 to iShiftCode
96014>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
96015>>>>>        End
96015>>>>>>
96015>>>>>        Move True to llCancel
96016>>>>>    End_Procedure
96017>>>>>    
96017>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
96019>>>>>        Send ClearSearchRequest // kill any deferred search popup
96020>>>>>        Forward Send OnComRowDblClick llRow llItem
96022>>>>>    End_Procedure
96023>>>>>    
96023>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
96025>>>>>        Send Ok
96026>>>>>    End_Procedure
96027>>>>>    
96027>>>>>    
96027>>>>>    // we don't want a menu for prompt lists
96027>>>>>    Function CreateContextMenu Returns Handle
96029>>>>>        Function_Return 0
96030>>>>>    End_Function
96031>>>>>    
96031>>>>>    // if we use auto-ordering, change the order when the column changes
96031>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
96033>>>>>        Boolean bAutoOrder
96033>>>>>        Forward Send ColumnChanged iOld iNew
96035>>>>>        Get pbAutoOrdering to bAutoOrder
96036>>>>>        If bAutoOrder Begin
96038>>>>>            // will be reordered in idle event
96038>>>>>            Set pbNeedsNewOrdering to True
96039>>>>>        End
96039>>>>>>
96039>>>>>    End_Procedure
96040>>>>>    
96040>>>>>    
96040>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
96042>>>>>        Integer eMode
96042>>>>>        Integer[] SelRowsIndexes
96043>>>>>        Set pbCanceled to True // assume cancel unless changed
96044>>>>>        Set pSelectedRows to SelRowsIndexes // empty
96045>>>>>        Get peUpdateMode to eMode
96046>>>>>        If (eMode<>umPromptNonInvoking) Begin
96048>>>>>            Send OnStoreDefaults
96049>>>>>        End
96049>>>>>>
96049>>>>>        Send InitializePromptList
96050>>>>>        Forward Send Add_Focus hoParent
96052>>>>>        Send LoadData
96053>>>>>        Set psSeedValue to ""
96054>>>>>    End_Procedure
96055>>>>>    
96055>>>>>    // called before the list is activated.
96055>>>>>    Procedure InitializePromptList
96057>>>>>        Integer hoInvokingObject
96057>>>>>        Boolean bAutoColumn bAutoSeed
96057>>>>>        Integer i iOldMode eUpdateMode
96057>>>>>        String sValue
96057>>>>>        
96057>>>>>        Get peUpdateMode to eUpdateMode
96058>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
96060>>>>>            Get Focus of Desktop to hoInvokingObject
96061>>>>>            If (hoInvokingObject<=Desktop) Begin
96063>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
96064>>>>>>
96064>>>>>                Procedure_Return
96065>>>>>            End
96065>>>>>>
96065>>>>>            
96065>>>>>            Set phoInvokingObject to hoInvokingObject
96066>>>>>            
96066>>>>>            Send Prompt_Callback to hoInvokingObject Self
96067>>>>>            Get peUpdateMode to eUpdateMode
96068>>>>>        End
96068>>>>>>
96068>>>>>        
96068>>>>>        Send ClearSearchRequest // clear the search keys
96069>>>>>        Set pbNeedsNewOrdering to False
96070>>>>>        
96070>>>>>        Get pbAutoSeed to bAutoSeed
96071>>>>>        
96071>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
96073>>>>>            Get Value of hoInvokingObject to sValue
96074>>>>>            Set psSeedValue to sValue
96075>>>>>        End
96075>>>>>>
96075>>>>>        
96075>>>>>    End_Procedure
96076>>>>>    
96076>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
96076>>>>>    Procedure LoadData
96078>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
96078>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
96078>>>>>        Integer eUpdateMode
96078>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder
96078>>>>>        
96078>>>>>        Get phoDataSource to hoDataSource
96079>>>>>        Get peUpdateMode to eUpdateMode
96080>>>>>        Get phoInvokingObject to hoInvokingObject
96081>>>>>        Get pbAutoSeed to bAutoSeed
96082>>>>>        Get piInitialColumn to iInitialColumn
96083>>>>>        Get piUpdateColumn to iUpdateColumn
96084>>>>>        Get RowCount of hoDataSource to iRows
96085>>>>>        
96085>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
96085>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
96085>>>>>        If (iInitialColumn=-1) Begin
96087>>>>>            Move iUpdateColumn to iInitialColumn
96088>>>>>        End
96088>>>>>>
96088>>>>>        If (iInitialColumn>=0) Begin
96090>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
96091>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
96092>>>>>        End
96092>>>>>>
96092>>>>>        Send OnSeedData // find a good starting place for the row
96093>>>>>        Get pbFocusSubItems to bSubFocus
96094>>>>>        If bSubFocus Begin
96096>>>>>            // if column focus, which is normal, go to initialcolumn
96096>>>>>            If hoInitialColumn Begin
96098>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
96099>>>>>            End
96099>>>>>>
96099>>>>>            Else Begin
96100>>>>>                Send MoveToFirstEnterableColumn
96101>>>>>            End
96101>>>>>>
96101>>>>>        End
96101>>>>>>
96101>>>>>        
96101>>>>>    End_Procedure
96102>>>>>    
96102>>>>>    // This is only called in a successful close
96102>>>>>    Procedure ClosePromptList
96104>>>>>        Handle hoDataSource hoInvokingObject
96104>>>>>        Handle hmCallBack
96104>>>>>        Integer iRow eUpdateMode
96104>>>>>        Integer[] SelRowsIndexes
96105>>>>>        
96105>>>>>        Get phoDataSource to hoDataSource
96106>>>>>        Get phoInvokingObject to hoInvokingObject
96107>>>>>        
96107>>>>>        If (pbMultipleSelection(Self)) Begin
96109>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
96110>>>>>        End
96110>>>>>>
96110>>>>>        Else Begin
96111>>>>>            Get SelectedRow of hoDataSource to iRow
96112>>>>>            If (iRow<>-1) Begin
96114>>>>>                Move iRow to SelRowsIndexes[0]
96115>>>>>            End
96115>>>>>>
96115>>>>>        End
96115>>>>>>
96115>>>>>        
96115>>>>>        Set pbCanceled to False
96116>>>>>        Set pSelectedRows to SelRowsIndexes
96117>>>>>        
96117>>>>>        Get peUpdateMode to eUpdateMode
96118>>>>>        // if non-invoking there is by definition, no move value out
96118>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
96120>>>>>            
96120>>>>>            If (eUpdateMode=umPromptValue) Begin
96122>>>>>                Send OnMoveValueOutByValue
96123>>>>>            End
96123>>>>>>
96123>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
96126>>>>>                Send OnMoveValueOutByCustom
96127>>>>>            End
96127>>>>>>
96127>>>>>            Get phmPromptUpdateCallback to hmCallBack
96128>>>>>            If hmCallBack Begin
96130>>>>>                Send hmCallBack of hoInvokingObject Self
96131>>>>>            End
96131>>>>>>
96131>>>>>        End
96131>>>>>>
96131>>>>>        
96131>>>>>        Send Close_Panel
96132>>>>>    End_Procedure
96133>>>>>    
96133>>>>>    // augment to send OnRestoreDefaults.
96133>>>>>    Procedure Release_Focus
96135>>>>>        Integer eUpdateMode
96135>>>>>        Get peUpdateMode to eUpdateMode
96136>>>>>        Forward Send Release_Focus
96138>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
96140>>>>>            Send OnRestoreDefaults
96141>>>>>        End
96141>>>>>>
96141>>>>>    End_Procedure
96142>>>>>    
96142>>>>>    Function SelectedRowIds Returns RowID[]
96144>>>>>        RowID[] SelectedRowids
96145>>>>>        Integer[] SelectedRows
96146>>>>>        Integer i iRows
96146>>>>>        Handle hoDataSource
96146>>>>>        Get phoDataSource to hoDataSource
96147>>>>>        Get pSelectedRows to SelectedRows
96148>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
96149>>>>>        For i from 0 to (iRows-1)
96155>>>>>>
96155>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
96156>>>>>        Loop
96157>>>>>>
96157>>>>>        Function_Return SelectedRowids
96158>>>>>    End_Function
96159>>>>>    
96159>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
96161>>>>>        String[] SelectedValues
96162>>>>>        Integer[] SelectedRows
96163>>>>>        Integer i iRows
96163>>>>>        Handle hoCol
96163>>>>>        Get ColumnObject iCol to hoCol
96164>>>>>        Get pSelectedRows to SelectedRows
96165>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
96166>>>>>        For i from 0 to (iRows-1)
96172>>>>>>
96172>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
96173>>>>>        Loop
96174>>>>>>
96174>>>>>        Function_Return SelectedValues
96175>>>>>    End_Function
96176>>>>>    
96176>>>>>    Procedure Ok Returns Integer
96178>>>>>        Send ClosePromptList
96179>>>>>    End_Procedure
96180>>>>>    
96180>>>>>    Procedure Cancel Returns Integer
96182>>>>>        Send Close_Panel
96183>>>>>    End_Procedure
96184>>>>>    
96184>>>>>    Procedure Search
96186>>>>>        Send Activate // give focus back to list so focus things are correct
96187>>>>>        Send Request_Search 0 0
96188>>>>>    End_Procedure
96189>>>>>    
96189>>>>>    // do a search using the current keys in the search key buffer for the sort column.
96189>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
96189>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
96189>>>>>    Procedure Request_SearchEx
96191>>>>>        tGridKeyPair[] Keys
96191>>>>>        tGridKeyPair[] Keys
96192>>>>>        Integer iCol
96192>>>>>        Handle hoCol hoSearchDialog
96192>>>>>        Boolean bOk
96192>>>>>        String sValue
96192>>>>>        
96192>>>>>        Get piSortColumn to iCol
96193>>>>>        If (iCol<>-1) Begin
96195>>>>>            Get ColumnObject iCol to hoCol
96196>>>>>            Get pSearchKeys to Keys
96197>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
96198>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
96199>>>>>            If bOk Begin
96201>>>>>                Send RequestFindColumnValue iCol sValue True 0
96202>>>>>            End
96202>>>>>>
96202>>>>>            Send Destroy of hoSearchDialog
96203>>>>>        End
96203>>>>>>
96203>>>>>        Send ClearSearchRequest // clear the search keys
96204>>>>>    End_Procedure
96205>>>>>    
96205>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
96205>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
96207>>>>>        tGridKeyPair[] Keys
96207>>>>>        tGridKeyPair[] Keys
96208>>>>>        tGridKeyPair KeyPair
96208>>>>>        tGridKeyPair KeyPair
96208>>>>>        Set pbRequestSearch to True
96209>>>>>        Move iKeyCode to KeyPair.KeyCode
96210>>>>>        Move iShiftCode to KeyPair.ShiftCode
96211>>>>>        Get pSearchKeys to Keys
96212>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
96213>>>>>        Set pSearchKeys to Keys
96214>>>>>    End_Procedure
96215>>>>>    
96215>>>>>    Procedure ClearSearchRequest
96217>>>>>        tGridKeyPair[] SearchKeys
96217>>>>>        tGridKeyPair[] SearchKeys
96218>>>>>        Set pSearchKeys to SearchKeys
96219>>>>>        Set pbRequestSearch to False
96220>>>>>    End_Procedure
96221>>>>>    
96221>>>>>End_Class
96222>>>>>
96222>>>Use cDbUpdateFunctionLibrary.pkg
96222>>>Use MSSqldrv.pkg
96222>>>Use db2_drv.pkg
96222>>>Use odbc_drv.pkg
96222>>>Use cRDCModalPanel.pkg
Including file: cRDCModalPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\cRDCModalPanel.pkg)
96222>>>>>//****************************************************************************
96222>>>>>// $Module type: Class
96222>>>>>// $Module name: cRDCModalPanel
96222>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
96222>>>>>// Created     : 2014-03-17 @ 12:33
96222>>>>>//
96222>>>>>// Description :
96222>>>>>//
96222>>>>>// $Rev History:
96222>>>>>//    2014-03-17  Module header created
96222>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
96222>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
96222>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
96222>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
96222>>>>>// in the help folder for more details.
96222>>>>>//
96222>>>>>//****************************************************************************
96222>>>>>Use Windows.pkg
96222>>>>>Use cCJCommandBarSystem.pkg   
96222>>>>>Use cCJSkinFramework.pkg
96222>>>>>
96222>>>>>Class cRDCModalPanel is a ModalPanel
96223>>>>>
96223>>>>>    Procedure Construct_Object
96225>>>>>        Forward Send Construct_Object
96227>>>>>
96227>>>>>        Set Maximize_Icon to True
96228>>>>>        Set Minimize_Icon to False
96229>>>>>        Set Border_Style to Border_Thick
96230>>>>>        Set Locate_Mode to Center_On_Parent
96231>>>>>
96231>>>>>        Property String Private_Icon
96232>>>>>        Property Handle phoDialogCommandbar
96233>>>>>    End_Procedure
96234>>>>>
96234>>>>>    Procedure Set Icon String sIcon
96236>>>>>        Forward Set Icon to sIcon
96238>>>>>        Set Private_Icon to sIcon
96239>>>>>    End_Procedure
96240>>>>>
96240>>>>>    Function Icon Returns String
96242>>>>>        String sIcon
96242>>>>>        Get Private_Icon to sIcon
96243>>>>>        Function_Return sIcon
96244>>>>>    End_Function
96245>>>>>
96245>>>>>    Procedure Page Integer iPageObject
96247>>>>>        String sIcon
96247>>>>>        Integer hWnd
96247>>>>>        
96247>>>>>        Forward Send Page iPageObject
96249>>>>>        Get Private_Icon to sIcon
96250>>>>>        If (sIcon <> "") Begin
96252>>>>>            Set Icon to sIcon
96253>>>>>        End
96253>>>>>>
96253>>>>>
96253>>>>>        Get Window_Handle to hWnd
96254>>>>>
96254>>>>>        If ((ghoSkinFramework <> 0) and (hWnd <> 0)) Begin
96256>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
96257>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
96258>>>>>        End
96258>>>>>>
96258>>>>>    End_Procedure
96259>>>>>
96259>>>>>    // Put a status bar at the bottom of the panel, which makes
96259>>>>>    // status_help work and puts a gripper in the lower right corner.
96259>>>>>    Procedure End_Construct_Object
96261>>>>>        Integer iStyle iSize iOffset
96261>>>>>
96261>>>>>        Forward Send End_Construct_Object
96263>>>>>
96263>>>>>        Get Border_Style to iStyle
96264>>>>>        Move 8 to iOffset
96265>>>>>        If (iStyle = Border_Thick) Begin
96267>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
96269>>>>>                Object oStatusBar is a cCJStatusBar
96271>>>>>                    Set phoDialogCommandbar to Self
96272>>>>>                    Object oStatusIdle is a cCJStatusBarPane
96274>>>>>                        Set piId to sbpIDIdlePane
96275>>>>>                        Set pbStyleStretch to True
96276>>>>>                    End_Object
96277>>>>>                End_Object
96278>>>>>            End_Object
96279>>>>>            Get Size to iSize
96280>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
96281>>>>>            Set piMinSize to (Hi(iSize) + iOffset) (Low(iSize))
96282>>>>>        End
96282>>>>>>
96282>>>>>
96282>>>>>    End_Procedure
96283>>>>>
96283>>>>>    Procedure Popup
96285>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
96286>>>>>        Forward Send Popup
96288>>>>>    End_Procedure
96289>>>>>
96289>>>>>End_Class
96290>>>
96290>>>Object oDatabaseSelection_sl is a cRDCModalPanel
96292>>>    Set Label to "SQL Database Selection"
96293>>>    Set Size to 119 183
96294>>>    Set piMinSize to 89 170
96295>>>    Set Location to 2 2
96296>>>    Set Border_Style to Border_Thick
96297>>>    Set Icon to "DatabaseLookup1.ico"
96298>>>
96298>>>    Property String[] psTheData
96300>>>
96300>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
96302>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
96304>>>        End_Object
96305>>>    End
96305>>>>
96305>>>
96305>>>    Object oSelList is a cCJGridPromptList
96307>>>        Set Size to 89 167
96308>>>        Set Location to 6 6
96309>>>        Set peAnchors to anAll
96310>>>        Set pbAllowColumnRemove to False
96311>>>        Set pbUseAlternateRowBackgroundColor to True
96312>>>        Set pbGrayIfDisable to False
96313>>>        Set pbHeaderReorders to False
96314>>>        Set pbHeaderSelectsColumn to False
96315>>>        Set pbHeaderTogglesDirection to False
96316>>>        Set pbShadeSortColumn to False
96317>>>        Set piFocusCellBackColor to clDkGray
96318>>>
96318>>>        Object oName is a cCJGridColumn
96320>>>            Set piWidth to 334
96321>>>            Set psCaption to "Database Name"
96322>>>        End_Object
96323>>>
96323>>>        Procedure Activating
96326>>>            tDataSourceRow[] MyData
96326>>>            tDataSourceRow[] MyData
96327>>>            Handle hoDataSource
96327>>>            String[] sTheData
96328>>>            Integer iCount iSize
96328>>>
96328>>>            Send Cursor_Wait of Cursor_Control
96329>>>            Forward Send Activating
96331>>>
96331>>>            Get psTheData to sTheData
96332>>>            Move (SizeOfArray(sTheData)) to iSize
96333>>>            Decrement iSize
96334>>>            For iCount from 0 to iSize
96340>>>>
96340>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
96341>>>            Loop
96342>>>>
96342>>>
96342>>>            Get phoDataSource to hoDataSource
96343>>>            Send InitializeData of hoDataSource MyData
96344>>>            Send Cursor_Ready of Cursor_Control
96345>>>        End_Procedure
96346>>>
96346>>>    End_Object
96347>>>
96347>>>    Object oOK_Btn is a Button
96349>>>        Set Size to 14 50
96350>>>        Set Label    to "&OK"
96351>>>        Set Location to 98 68
96352>>>        Set peAnchors To anBottomRight
96353>>>
96353>>>        Procedure OnClick
96356>>>            Send Ok of oSelList
96357>>>        End_Procedure
96358>>>
96358>>>    End_Object
96359>>>
96359>>>    Object oCancel_Btn is a Button
96361>>>        Set Size to 14 50
96362>>>        Set Label    to "&Cancel"
96363>>>        Set Location to 98 123
96364>>>        Set peAnchors to anBottomRight
96365>>>
96365>>>        Procedure OnClick
96368>>>            Send Close_Panel
96369>>>        End_Procedure
96370>>>
96370>>>    End_Object
96371>>>
96371>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96372>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96373>>>End_Object
96374>        Use SQLDatabaseBackup.dg
Including file: SQLDatabaseBackup.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLDatabaseBackup.dg)
96374>>>// Note: At the bottom of this package there's a general purpose access method for this dialog.
96374>>>Use Windows.pkg
96374>>>Use vWin32fh.pkg
96374>>>
96374>>>Object oSQLDatabaseBackup_dg is a ModalPanel
96376>>>    Set Size to 104 298
96377>>>    Set Label to "SQL Database Backup"
96378>>>    Set piMinSize to 89 211
96379>>>    Set Location to 2 4
96380>>>    Set Border_Style To Border_Thick
96381>>>
96381>>>    Property Boolean pbOK False
96383>>>    Property String  psDatabase
96385>>>    Property String  psPath
96387>>>    Property String  psBackupName
96389>>>
96389>>>    Object oDatabase_fm is a Form
96391>>>        Set Size to 13 204
96392>>>        Set Location to 14 71
96393>>>        Set Label_Justification_Mode to JMode_Right
96394>>>        Set Label_Col_Offset to 2
96395>>>        Set Label to "Database Name"
96396>>>        Set Enabled_State to False
96397>>>        Set peAnchors to anTopLeftRight
96398>>>
96398>>>        Procedure Page Integer iPageObject
96401>>>            String sValue
96401>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sValue
96402>>>            Set Value to sValue
96403>>>            Set psDatabase to sValue
96404>>>            Forward Send Page iPageObject
96406>>>        End_Procedure
96407>>>
96407>>>    End_Object
96408>>>
96408>>>    Object oBackupName_fm is a Form
96410>>>        Set Size to 13 204
96411>>>        Set Location to 29 71
96412>>>        Set Label_Justification_Mode to JMode_Right
96413>>>        Set Label_Col_Offset to 2
96414>>>        Set Label to "Backup Name"
96415>>>        Set peAnchors to anTopLeftRight
96416>>>
96416>>>        Procedure Page Integer iPageObject
96419>>>            String sValue
96419>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sValue
96420>>>            Set Value to sValue
96421>>>            Forward Send Page iPageObject
96423>>>        End_Procedure
96424>>>
96424>>>        Procedure OnChange
96427>>>            String sValue
96427>>>            Get Value to sValue
96428>>>            Set psBackupName to sValue
96429>>>        End_Procedure
96430>>>
96430>>>    End_Object
96431>>>
96431>>>    Object oUseDefaultBackupFolder_cb is a CheckBox
96433>>>        Set Size to 10 50
96434>>>        Set Location to 50 71
96435>>>        Set Label to "Use Default SQL Backup Folder"
96436>>>        Set Checked_State to True
96437>>>
96437>>>        Procedure OnChange
96440>>>            Boolean bChecked
96440>>>            Get Checked_State to bChecked
96441>>>            Set Enabled_State of oPath_fm to (bChecked = False)
96442>>>        End_Procedure
96443>>>
96443>>>    End_Object
96444>>>
96444>>>    Object oPath_fm is a Form
96446>>>        Set Size to 13 204
96447>>>        Set Location to 62 71
96448>>>        Set Label_Justification_Mode to JMode_Right
96449>>>        Set Label_Col_Offset to 2
96450>>>        Set Label to "Path"
96451>>>        Set Prompt_Button_Mode to PB_PromptOn
96452>>>        Set peAnchors to anTopLeftRight
96453>>>        Set Enabled_State to False
96454>>>
96454>>>        Procedure Page Integer iPageObject
96457>>>            String sValue
96457>>>            Get psDataPathFirstPart of ghoDbUpdateFunctionLibrary to sValue
96458>>>            Get vFolderFormat sValue to sValue
96459>>>            Move (sValue + "Backup") to sValue
96460>>>            Set Value to sValue
96461>>>            Forward Send Page iPageObject
96463>>>        End_Procedure
96464>>>
96464>>>        Procedure Prompt
96467>>>            String sPath sFileMask sRetval
96467>>>
96467>>>            Get Value to sPath
96468>>>            Move "Database Backup files (*.bak)|*.bak" to sFileMask
96469>>>            Get vSelect_File sFileMask "Please select a .bak file" sPath to sRetval
96470>>>            If (sRetval <> "") Begin
96472>>>                Get ParseFolderName sRetval to sPath
96473>>>                If (Right(sPath, 1) ="\") Begin
96475>>>                    Move (Left(sPath, Length(sPath) -1)) to sPath
96476>>>                End
96476>>>>
96476>>>                Set Value to sPath
96477>>>            End
96477>>>>
96477>>>        End_Procedure
96478>>>
96478>>>        Procedure OnChange
96481>>>            String sValue
96481>>>            Get Value to sValue
96482>>>            Set psPath to sValue
96483>>>        End_Procedure
96484>>>
96484>>>    End_Object
96485>>>
96485>>>    Object oOK_Btn is a Button
96487>>>        Set Label    to "&OK"
96488>>>        Set Location to 81 169
96489>>>        Set peAnchors to anBottomRight
96490>>>
96490>>>        Procedure OnClick
96493>>>            Set pbOK to True
96494>>>            Send Close_Panel
96495>>>        End_Procedure
96496>>>
96496>>>    End_Object
96497>>>
96497>>>    Object oCancel_Btn is a Button
96499>>>        Set Label    to "&Cancel"
96500>>>        Set Location to 81 224
96501>>>        Set peAnchors to anBottomRight
96502>>>
96502>>>        Procedure OnClick
96505>>>            Set pbOK to False
96506>>>            Send Close_Panel
96507>>>        End_Procedure
96508>>>
96508>>>    End_Object
96509>>>
96509>>>    Object oButton1 is a Button
96511>>>        Set Size to 14 96
96512>>>        Set Location to 80 32
96513>>>        Set Label to "Enum table types"
96514>>>
96514>>>        Procedure OnClick
96517>>>            String sDriverID
96517>>>            tSQLConnection SQLConnection
96517>>>            tSQLConnection SQLConnection
96517>>>            Get pSQLConnection of ghoDbUpdateFunctionLibrary to SQLConnection
96518>>>            Send ShowAllTablesAndColumns SQLConnection.sDriverID SQLConnection.sConnectionString
96519>>>        End_Procedure
96520>>>
96520>>>        Procedure ShowAllTablesAndColumns String sDriver String sLogin
96523>>>            Handle hoCLIHandler
96523>>>            Integer iNumTables iTableCount
96523>>>
96523>>>            Get Create U_cCLIHandler to hoCLIhandler
96524>>>            If (hoCLIHandler > 0) Begin
96526>>>                Set psDriverID of hoCLIHandler to sDriver
96527>>>                Get EnumerateTables of hoCLIHandler sLogin to iNumTables
96528>>>                For iTableCount from 1 to iNumTables
96534>>>>
96534>>>                    Show (TableName(hoCLIHandler, iTableCount)) "; "
96536>>>                    Show (SchemaName(hoCLIHandler, iTableCount)) "; "
96538>>>                    Show (TableType(hoCLIHandler, iTableCount)) "; "
96540>>>                    Showln (TableComment(hoCLIHandler, iTableCount))
96542>>>//                    Get EnumerateColumns of hoCLIHandler sLogin (TableName(hoCLIHandler, iTableCount)) to iNumColumns
96542>>>//                    For iColumnCount from 1 to iNumColumns
96542>>>//                        Showln " " (ColumnName(hoCLIHandler, iColumnCount))
96542>>>//                    Loop
96542>>>                    Showln
96543>>>                Loop
96544>>>>
96544>>>                Send Destroy of hoCLIHandler
96545>>>            End
96545>>>>
96545>>>        End_Procedure
96546>>>
96546>>>    End_Object
96547>>>
96547>>>    Procedure Page Integer iPageObject
96550>>>        Set Icon to "DbBackup1.ico"
96551>>>        Forward Send Page iPageObject
96553>>>    End_Procedure
96554>>>
96554>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96555>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96556>>>
96556>>>End_Object
96557>>>
96557>>>// *** General purpose access method for this dialog ***
96557>>>Function MakeSQLDatabaseBackup Returns Boolean
96560>>>    Handle ho
96560>>>    Boolean bOK bDefault
96560>>>    String sDatabase sPath sBackupName
96560>>>
96560>>>    Move (oSQLDatabaseBackup_dg(Self)) to ho
96561>>>    Set pbOK of ho to False
96562>>>    Send Popup of ho
96563>>>
96563>>>    Get pbOk of ho to bOK
96564>>>    If (bOK = True) Begin
96566>>>        Get Value of (oDatabase_fm(ho))   to sDatabase
96567>>>        Get Value of (oBackupName_fm(ho)) to sBackupName
96568>>>        Get Checked_State of (oUseDefaultBackupFolder_cb(ho)) to bDefault
96569>>>        If (bDefault = False) Begin
96571>>>            Get Value of (oPath_fm(ho)) to sPath
96572>>>        End
96572>>>>
96572>>>        Get SqlDatabaseBackupToDisk of ghoDbUpdateFunctionLibrary sDatabase sBackupName sPath True to bOK
96573>>>    End
96573>>>>
96573>>>
96573>>>    Function_Return bOK
96574>>>End_Function
96575>        Use SQLConnections.vw
Including file: SQLConnections.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLConnections.vw)
96575>>>Use Windows.pkg
96575>>>Use DFClient.pkg
96575>>>Use cDbScrollingContainer.pkg
Including file: cDbScrollingContainer.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cDbScrollingContainer.pkg)
96575>>>>>// Provides support for db aware scrolling containers.
96575>>>>>// Scrolling containers is provided by creating two objects,
96575>>>>>// a host (dbScrollingContainer) and a scrolling clientarea (dbScrollingClientArea)
96575>>>>>// The host has no public interface, you just drop the object. It should have only one child object
96575>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
96575>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
96575>>>>>
96575>>>>>Use DFClient.pkg
96575>>>>>Use cScrollingContainerMixin.pkg
Including file: cScrollingContainerMixin.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cScrollingContainerMixin.pkg)
96575>>>>>>>// Mixin classes for scrolling container support:
96575>>>>>>>// cScrollingContainerMixin & cScrollingClientAreaMixin
96575>>>>>>>// These are used by cSrollingContainer / cScrollingClientArea and
96575>>>>>>>// dbScrollingContainer / dbScrollingClientArea.
96575>>>>>>>// The scrolling container has no public interface, you just drop the object. It should have only one child object
96575>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
96575>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
96575>>>>>>>
96575>>>>>>>Use Windows.pkg
96575>>>>>>>Use Winuser.pkg
96575>>>>>>>Use tWinStructs.pkg
96575>>>>>>>
96575>>>>>>>Register_Function pbTabbedWorkspaces Returns Boolean
96575>>>>>>>Register_Function pbCenterTabbedViews Returns Boolean
96575>>>>>>>// support for the scrolling client area mixin object.
96575>>>>>>>
96575>>>>>>>Class cScrollingClientAreaMixin is a Mixin
96576>>>>>>>    
96576>>>>>>>    Procedure Define_cScrollingClientAreaMixin
96578>>>>>>>        
96578>>>>>>>        Set pbSizeToClientArea to False // should already be set to this, but just in case.
96579>>>>>>>        Set Border_Style to Border_None
96580>>>>>>>        
96580>>>>>>>        Property Boolean pbAutoScroll True
96581>>>>>>>        Property Boolean pbAutoScrollFocus True
96582>>>>>>>        Property Integer piAutoScrollMarginX 5
96583>>>>>>>        Property Integer piAutoScrollMarginY 5
96584>>>>>>>        Property Integer piAutoScrollMinX 0
96585>>>>>>>        Property Integer piAutoScrollMinY 0
96586>>>>>>>        Property Boolean pbShowDisabledScrollBar False
96587>>>>>>>        
96587>>>>>>>        
96587>>>>>>>        Property Integer piLineScrollUnit  5 // minimum scrolling unit for line up/down and mouse wheel
96588>>>>>>>        Property Integer piMinimumHeight 0 // the minimum height that doesn't need scrolling
96589>>>>>>>        Property Integer piMinimumWidth 0 //(the minimum width that doesn't need scrolling
96590>>>>>>>        // keeps track of scrolling
96590>>>>>>>        Property Integer piCurrentVertScrolled 0
96591>>>>>>>        Property Integer piCurrentHorzScrolled 0
96592>>>>>>>        Property Integer piWheelDelta 0               // internal, accumulates mouse wheel clicks
96593>>>>>>>        Delegate Set phoScrollingClientArea to Self
96595>>>>>>>        
96595>>>>>>>        // set this true to make this a tabbed workspace view (design time)
96595>>>>>>>        Property Boolean pbTabWorkspaceView False
96596>>>>>>>        // set this false to stop auto-determination of pbTabWorkspaceView (design time)
96596>>>>>>>        Property Boolean pbAutoSetTabWorkspaceView True
96597>>>>>>>    End_Procedure
96598>>>>>>>    
96598>>>>>>>    // low level event sent from windows.
96598>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
96600>>>>>>>        Integer iWheelDelta iKeys iDelta iClicks
96600>>>>>>>        Move (low(abs(wParam))) to iKeys           // any keys down when pressed
96601>>>>>>>        Move (hi(abs(wParam))) to iDelta           // number of click units
96602>>>>>>>        If (wParam<0) Begin
96604>>>>>>>            Move (-iDelta) to iDelta     // can be up or down
96605>>>>>>>        End
96605>>>>>>>>
96605>>>>>>>        Get  piWheelDelta to iWheelDelta           // Current accumulated micro clicks
96606>>>>>>>        Move (iWheelDelta+iDelta) to iWheelDelta
96607>>>>>>>        // C_WHEELDATA is 120 as defined by MS as the delta to react to. Once click is usually 120
96607>>>>>>>        Move (iWheelDelta/C_WHEELDELTA) to iClicks // Number of clicks to react to
96608>>>>>>>        Set  piWheelDelta to (mod(iWheelDelta,C_WHEELDELTA)) // remainder unused microclicks
96609>>>>>>>        // If we have enough Clicks send OnMouseWheel
96609>>>>>>>        If (iClicks<>0) Begin
96611>>>>>>>            Send OnMouseWheel iClicks iKeys
96612>>>>>>>        End
96612>>>>>>>>
96612>>>>>>>        // tell windows that we've handled the event.
96612>>>>>>>        Set Windows_Override_State to True
96613>>>>>>>    End_Procedure
96614>>>>>>>    
96614>>>>>>>    
96614>>>>>>>    // should be sent by DF message OnWMMouseWheel , which is sent by WM_MOUSEWHEEL
96614>>>>>>>    Procedure OnMouseWheel Integer iClicks Integer iKey
96616>>>>>>>        Integer iLineScrollUnit
96616>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96617>>>>>>>        Send VScroll (-iClicks*iLineScrollUnit*2) // (If(iClicks>0,False,True)) (abs(iClicks))
96618>>>>>>>    End_Procedure
96619>>>>>>>    
96619>>>>>>>    // should be sent by WM_VSCROLL
96619>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
96621>>>>>>>        Boolean bOk
96621>>>>>>>        tWinScrollInfo ScrollInfo
96621>>>>>>>        tWinScrollInfo ScrollInfo
96621>>>>>>>        Integer iLineScrollUnit
96621>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96622>>>>>>>        Get GetScrollBarInfo True (&ScrollInfo) to bOk
96623>>>>>>>        If bOk Begin
96625>>>>>>>            
96625>>>>>>>            Case Begin
96625>>>>>>>                Case (iType=SB_PAGEDOWN)
96627>>>>>>>                    Send VScroll ScrollInfo.nPage
96628>>>>>>>                    Case Break
96629>>>>>>>                
96629>>>>>>>                Case (iType=SB_PAGEUP)
96632>>>>>>>                    Send VScroll (-Integer(ScrollInfo.nPage))
96633>>>>>>>                    Case Break
96634>>>>>>>                
96634>>>>>>>                Case (iType=SB_LINEDOWN)
96637>>>>>>>                    Send VScroll iLineScrollUnit
96638>>>>>>>                    Case Break
96639>>>>>>>                
96639>>>>>>>                Case (iType=SB_LINEUP)
96642>>>>>>>                    Send VScroll (-iLineScrollUnit)
96643>>>>>>>                    Case Break
96644>>>>>>>                
96644>>>>>>>                Case (iType=SB_BOTTOM)
96647>>>>>>>                    Send VScroll (ScrollInfo.nMax-ScrollInfo.nPos)
96648>>>>>>>                    Case Break
96649>>>>>>>                
96649>>>>>>>                Case (iType=SB_Top)
96652>>>>>>>                    Send VScroll (-ScrollInfo.nPos)
96653>>>>>>>                    Case Break
96654>>>>>>>                
96654>>>>>>>                Case (iType=SB_THUMBPOSITION)
96657>>>>>>>                    Case Break
96658>>>>>>>                
96658>>>>>>>                Case (iType=SB_THUMBTRACK)
96661>>>>>>>                    Send VScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
96662>>>>>>>                    Case Break
96663>>>>>>>            Case End
96663>>>>>>>        End
96663>>>>>>>>
96663>>>>>>>    End_Procedure
96664>>>>>>>    
96664>>>>>>>    // should be sent by WM_HSCROLL
96664>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
96666>>>>>>>        Boolean bOk
96666>>>>>>>        tWinScrollInfo ScrollInfo
96666>>>>>>>        tWinScrollInfo ScrollInfo
96666>>>>>>>        Integer iLineScrollUnit
96666>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96667>>>>>>>        Get GetScrollBarInfo False (&ScrollInfo) to bOk
96668>>>>>>>        If bOk Begin
96670>>>>>>>            
96670>>>>>>>            Case Begin
96670>>>>>>>                Case (iType=SB_PAGEDOWN)
96672>>>>>>>                    Send hScroll ScrollInfo.nPage
96673>>>>>>>                    Case Break
96674>>>>>>>                
96674>>>>>>>                Case (iType=SB_PAGEUP)
96677>>>>>>>                    Send hScroll (-Integer(ScrollInfo.nPage))
96678>>>>>>>                    Case Break
96679>>>>>>>                
96679>>>>>>>                Case (iType=SB_LINEDOWN)
96682>>>>>>>                    Send hScroll iLineScrollUnit
96683>>>>>>>                    Case Break
96684>>>>>>>                
96684>>>>>>>                Case (iType=SB_LINEUP)
96687>>>>>>>                    Send hScroll (-iLineScrollUnit)
96688>>>>>>>                    Case Break
96689>>>>>>>                
96689>>>>>>>                Case (iType=SB_BOTTOM)
96692>>>>>>>                    Send hScroll (ScrollInfo.nMax-ScrollInfo.nPos)
96693>>>>>>>                    Case Break
96694>>>>>>>                
96694>>>>>>>                Case (iType=SB_Top)
96697>>>>>>>                    Send hScroll (-ScrollInfo.nPos)
96698>>>>>>>                    Case Break
96699>>>>>>>                
96699>>>>>>>                Case (iType=SB_THUMBPOSITION)
96702>>>>>>>                    Case Break
96703>>>>>>>                
96703>>>>>>>                Case (iType=SB_THUMBTRACK)
96706>>>>>>>                    Send hScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
96707>>>>>>>                    Case Break
96708>>>>>>>            Case End
96708>>>>>>>        End
96708>>>>>>>>
96708>>>>>>>    End_Procedure
96709>>>>>>>    
96709>>>>>>>    
96709>>>>>>>    // this calls SetScrollInfo with proper info
96709>>>>>>>    Procedure SetScrollBarInfo Boolean bVert Integer iRangeMin Integer iRangeMax Integer iPageSize
96711>>>>>>>        tWinScrollInfo ScrollInfo
96711>>>>>>>        tWinScrollInfo ScrollInfo
96711>>>>>>>        Integer iVoid
96711>>>>>>>        Handle hWnd
96711>>>>>>>        Boolean bShow
96711>>>>>>>        
96711>>>>>>>        Delegate Get Window_Handle to hWnd
96713>>>>>>>        If (hWnd <> 0) Begin
96715>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
96716>>>>>>>            
96716>>>>>>>            Move (SIF_RANGE ior SIF_POS ior SIF_PAGE ) to ScrollInfo.fMask
96717>>>>>>>            Get pbShowDisabledScrollBar to bShow
96718>>>>>>>            If bShow Begin
96720>>>>>>>                Move (ScrollInfo.fMask ior SIF_DISABLENOSCROLL) to ScrollInfo.fMask
96721>>>>>>>            End
96721>>>>>>>>
96721>>>>>>>            Move iRangeMin to ScrollInfo.nMin
96722>>>>>>>            Move iRangeMax to ScrollInfo.nMax
96723>>>>>>>            Move iPageSize to ScrollInfo.nPage
96724>>>>>>>            Move 0 to ScrollInfo.nPos
96725>>>>>>>            Move (SetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo), True)) to iVoid
96726>>>>>>>            
96726>>>>>>>        End
96726>>>>>>>>
96726>>>>>>>    End_Procedure
96727>>>>>>>    
96727>>>>>>>    // this wraps GetScrollInfo
96727>>>>>>>    Function GetScrollBarInfo Boolean bVert tWinScrollInfo ByRef ScrollInfo Returns Boolean
96729>>>>>>>        Boolean bOk
96729>>>>>>>        Handle hWnd
96729>>>>>>>        
96729>>>>>>>        Delegate Get Window_Handle to hWnd
96731>>>>>>>        If (hWnd <> 0) Begin
96733>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
96734>>>>>>>            Move (SIF_ALL) to ScrollInfo.fMask
96735>>>>>>>            Move (GetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo))) to bOk
96736>>>>>>>        End
96736>>>>>>>>
96736>>>>>>>        Function_Return bOk
96737>>>>>>>    End_Function
96738>>>>>>>    
96738>>>>>>>    // this wraps SetScrollPos
96738>>>>>>>    Procedure SetScrollBarPosInfo Boolean bVert Integer iPos
96740>>>>>>>        Integer iVoid
96740>>>>>>>        Handle hWnd
96740>>>>>>>        
96740>>>>>>>        Delegate Get Window_Handle to hWnd
96742>>>>>>>        If (hWnd <> 0) Begin
96744>>>>>>>            Move (SetScrollPos(hWnd, If(bVert,SB_VERT,SB_HORZ), iPos, True)) to iVoid
96745>>>>>>>        End
96745>>>>>>>>
96745>>>>>>>    End_Procedure
96746>>>>>>>    
96746>>>>>>>    // scrolling containers don't do anhcors. However, this gets called every time the parent's
96746>>>>>>>    // guiSize changes. We can use that to scroll or resize the scrolling client as needed.
96746>>>>>>>    Procedure DoapplyAnchors Integer Arg1 Integer Arg2
96748>>>>>>>        Send ScrollClientArea
96749>>>>>>>    End_Procedure
96750>>>>>>>    
96750>>>>>>>    // augment to handle the scrolling area initialization.
96750>>>>>>>    Procedure Add_Focus Handle hoParent
96752>>>>>>>        Forward Send Add_Focus hoParent
96754>>>>>>>        // at this the scrolling container and client area should both be paged.
96754>>>>>>>        // child objects ae also paged with initial anchors applied
96754>>>>>>>        Send CalculateAutoScrollMinimums
96755>>>>>>>    End_Procedure
96756>>>>>>>    
96756>>>>>>>    Procedure Page Integer iPage
96758>>>>>>>        Forward Send Page iPage
96760>>>>>>>        If iPage Begin
96762>>>>>>>            // at this the scrolling container and client area should both be paged
96762>>>>>>>            // but the child controls are not paged. We don't want scrollbars when
96762>>>>>>>            // the child items are paged (else they may get anchored oddly)
96762>>>>>>>            // Prior to 19.0 these were set in Add_focus which meant that the child objects were
96762>>>>>>>            // already paged with scrollbars present. This would result in scrollbars appearing
96762>>>>>>>            // before they were really needed. This should be more accurate
96762>>>>>>>            Send SetScrollBarInfo True 0 0 0
96763>>>>>>>            Send SetScrollBarInfo False 0 0 0
96764>>>>>>>        End
96764>>>>>>>>
96764>>>>>>>    End_Procedure
96765>>>>>>>    
96765>>>>>>>    // determine scrolling minimums and set the client area as required.
96765>>>>>>>    
96765>>>>>>>    Procedure CalculateAutoScrollMinimums
96767>>>>>>>        Integer iMinX iMinY iSiz iLoc iMargin
96767>>>>>>>        Integer iAutoMinX iAutoMinY
96767>>>>>>>        Boolean bAutoScroll
96767>>>>>>>        Handle hoNext hoFirst
96767>>>>>>>        
96767>>>>>>>        Get pbAutoScroll to bAutoScroll
96768>>>>>>>        Get piAutoScrollMinX to iAutoMinX
96769>>>>>>>        Get piAutoScrollMinY to iAutoMinY
96770>>>>>>>        Get DialogToGui iAutoMinY iAutoMinX to iSiz
96771>>>>>>>        Move (Hi(iSiz)) to iAutoMinY
96772>>>>>>>        Move (Low(iSiz)) to iAutoMinX
96773>>>>>>>        Set piMinimumHeight to iAutoMinY
96774>>>>>>>        Set piMinimumWidth to iAutoMinX
96775>>>>>>>        
96775>>>>>>>        If (bAutoScroll and (iAutoMinX=0 or iAutoMinY=0)) Begin
96777>>>>>>>            
96777>>>>>>>            Get Next_Level to hoFirst
96778>>>>>>>            Move hoFirst to hoNext
96779>>>>>>>            If (hoFirst) Begin
96781>>>>>>>                Repeat
96781>>>>>>>>
96781>>>>>>>                    Get GuiWindowSize of hoNext to iSiz
96782>>>>>>>                    Get GuiLocation of hoNext to iLoc
96783>>>>>>>                    Move (Hi(iLoc)+Hi(iSiz) max iMinY) to iMinY
96784>>>>>>>                    Move (Low(iLoc)+Low(iSiz) max iMinX) to iMinx
96785>>>>>>>                    Get Next_Focus of hoNext to hoNext
96786>>>>>>>                Until (hoNext=0 or hoNext=hoFirst)
96788>>>>>>>                
96788>>>>>>>                If (iAutoMinY=0) Begin
96790>>>>>>>                    Get piAutoScrollMarginY to iMargin
96791>>>>>>>                    Set piMinimumHeight to (iMinY+iMargin)
96792>>>>>>>                End
96792>>>>>>>>
96792>>>>>>>                
96792>>>>>>>                If (iAutoMinX=0) Begin
96794>>>>>>>                    Get piAutoScrollMarginX to iMargin
96795>>>>>>>                    Set piMinimumWidth to (iMinX+iMargin)
96796>>>>>>>                    
96796>>>>>>>                End
96796>>>>>>>>
96796>>>>>>>            End
96796>>>>>>>>
96796>>>>>>>        End
96796>>>>>>>>
96796>>>>>>>        
96796>>>>>>>        // before setting the client area, unset all anchors so DoApplyAnchors will not do anything
96796>>>>>>>        Broadcast Set pbAnchorCreated to False
96798>>>>>>>        Send ScrollClientArea
96799>>>>>>>        // after the scroll set up, reinitialize all anchors.
96799>>>>>>>        Broadcast Send DoCreateAnchors
96801>>>>>>>    End_Procedure
96802>>>>>>>    
96802>>>>>>>    // Scroll the client area and adjust the client area size as needed. This does all the
96802>>>>>>>    // work of scrolling.
96802>>>>>>>    
96802>>>>>>>    Procedure ScrollClientArea
96804>>>>>>>        Integer iSiz
96804>>>>>>>        Integer iHeight iHCur iHCuriDelta iOrig iRange bOk
96804>>>>>>>        Integer iWidth iWCur iWDelta iWOrig
96804>>>>>>>        Integer iSzY iSzX iLocX iLocY
96804>>>>>>>        
96804>>>>>>>        Delegate Get GuiClientSize to iSiz
96806>>>>>>>        Move (Hi(iSiz)) to iHeight
96807>>>>>>>        Move (Low(iSiz)) to iWidth
96808>>>>>>>        
96808>>>>>>>        // Vertical scrolling
96808>>>>>>>        
96808>>>>>>>        Get piMinimumHeight to iOrig
96809>>>>>>>        Get piMinimumWidth to iWOrig
96810>>>>>>>        
96810>>>>>>>        If (iOrig<>0 or iWOrig<>0) Begin
96812>>>>>>>            
96812>>>>>>>            If (iOrig<>0) Begin
96814>>>>>>>                Get piCurrentVertScrolled to iHCur
96815>>>>>>>                // If the size got bigger and we've scrolled, we want to scroll up
96815>>>>>>>                If (iHCur<>0 and (iHCur+iHeight>iOrig)) Begin
96817>>>>>>>                    Move (iOrig-iHeight max 0) to iHCur
96818>>>>>>>                    Set piCurrentVertScrolled to iHCur
96819>>>>>>>                End
96819>>>>>>>>
96819>>>>>>>                If (iHCur<>0 or iOrig>iHeight) Begin
96821>>>>>>>                    Send SetScrollBarInfo True 0 iOrig (iHeight min iOrig)
96822>>>>>>>                    Send SetScrollBarPosInfo True iHCur
96823>>>>>>>                End
96823>>>>>>>>
96823>>>>>>>                Else Begin
96824>>>>>>>                    Send SetScrollBarInfo True 0 0 0 //iOrig (iHeight min iOrig)
96825>>>>>>>                End
96825>>>>>>>>
96825>>>>>>>            End
96825>>>>>>>>
96825>>>>>>>            
96825>>>>>>>            // Horiz scrolling
96825>>>>>>>            
96825>>>>>>>            Get piCurrentHorzScrolled to iWCur
96826>>>>>>>            // If the size got bigger and we've scrolled, we want to scroll left
96826>>>>>>>            If (iWCur<>0 and (iWCur+iWidth>iWOrig)) Begin
96828>>>>>>>                Move (iWOrig-iWidth max 0) to iWCur
96829>>>>>>>                Set piCurrentHorzScrolled to iWCur
96830>>>>>>>            End
96830>>>>>>>>
96830>>>>>>>            If (iWCur<>0 or iWOrig>iWidth) Begin
96832>>>>>>>                Send SetScrollBarInfo False 0 iWOrig (iWidth min iWOrig)
96833>>>>>>>                Send SetScrollBarPosInfo False iWCur
96834>>>>>>>            End
96834>>>>>>>>
96834>>>>>>>            Else Begin
96835>>>>>>>                Send SetScrollBarInfo False 0 0 0
96836>>>>>>>            End
96836>>>>>>>>
96836>>>>>>>        End
96836>>>>>>>>
96836>>>>>>>        
96836>>>>>>>        // this could change depending on scrollbars appearing or not
96836>>>>>>>        Delegate Get GuiClientSize to iSiz
96838>>>>>>>        
96838>>>>>>>        // size of container is the the minimum allowed size (if scrolling is needed)
96838>>>>>>>        // or it is the actual size of the container (if scrolling not needed and it is bigger)
96838>>>>>>>        // This is required to make anchors work sensibly
96838>>>>>>>        Move (hi(iSiz) max iOrig) to iSzY
96839>>>>>>>        Move (low(iSiz) max iWOrig) to iSzX
96840>>>>>>>        Move (-iHCur) to iLocY
96841>>>>>>>        Move (-iWCur) to iLocX
96842>>>>>>>        
96842>>>>>>>        // Allow chance to make modifications
96842>>>>>>>        Send AdjustSizesLocs (&iSzY) (&iSzX) (&iLocY) (&iLocX)
96843>>>>>>>        
96843>>>>>>>        Set GuiSize to iSzY iSzX
96844>>>>>>>        // if we've scrolled, we need to reposition the container
96844>>>>>>>        Set GuiLocation to iLocY iLocX
96845>>>>>>>    End_Procedure
96846>>>>>>>    
96846>>>>>>>    // note that scrolling never changes the size of the scrolling client.
96846>>>>>>>    // this way, it does not interfere with anchors.
96846>>>>>>>    
96846>>>>>>>    Procedure VScroll Integer iDelta
96848>>>>>>>        Integer iHeight iCur iOrig iSiz
96848>>>>>>>        Delegate Get GuiClientSize to iSiz
96850>>>>>>>        Move (hi(iSiz)) to iHeight
96851>>>>>>>        Get piCurrentVertScrolled to iCur
96852>>>>>>>        Get piMinimumHeight to iOrig
96853>>>>>>>        If (iOrig=0 or  Hi(iSiz)>=iOrig) Begin
96855>>>>>>>            Procedure_Return
96856>>>>>>>        End
96856>>>>>>>>
96856>>>>>>>        // make sure delta is within range
96856>>>>>>>        If (iDelta+iCur<0) Begin
96858>>>>>>>            Move (-iCur) to iDelta
96859>>>>>>>        End
96859>>>>>>>>
96859>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
96862>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
96863>>>>>>>        End
96863>>>>>>>>
96863>>>>>>>        If (iDelta=0) ;            Procedure_Return
96866>>>>>>>        
96866>>>>>>>        Move (iCur + iDelta) to iCur
96867>>>>>>>        Set piCurrentVertScrolled to iCur
96868>>>>>>>        Send SetScrollBarPosInfo True iCur
96869>>>>>>>        Get GuiLocation to iSiz
96870>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Integer)-iDelta) (cast(low(iSiz),Integer))
96871>>>>>>>        Send ScrollClientArea
96872>>>>>>>    End_Procedure
96873>>>>>>>    
96873>>>>>>>    
96873>>>>>>>    Procedure HScroll Integer iDelta
96875>>>>>>>        Integer iHeight iCur iOrig iSiz
96875>>>>>>>        Delegate Get GuiClientSize to iSiz
96877>>>>>>>        Move (low(iSiz)) to iHeight
96878>>>>>>>        Get piCurrentHorzScrolled to iCur
96879>>>>>>>        Get piMinimumWidth to iOrig
96880>>>>>>>        If (iOrig=0 or  low(iSiz)>=iOrig) Begin
96882>>>>>>>            Procedure_Return
96883>>>>>>>        End
96883>>>>>>>>
96883>>>>>>>        If (iDelta+iCur<0) Begin
96885>>>>>>>            Move (-iCur) to iDelta
96886>>>>>>>        End
96886>>>>>>>>
96886>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
96889>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
96890>>>>>>>        End
96890>>>>>>>>
96890>>>>>>>        If (iDelta=0) ;            Procedure_Return
96893>>>>>>>        
96893>>>>>>>        Move (iCur + iDelta) to iCur
96894>>>>>>>        Set piCurrentHorzScrolled to iCur
96895>>>>>>>        Send SetScrollBarPosInfo False iCur
96896>>>>>>>        Get GuiLocation to iSiz
96897>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)) (cast(low(iSiz),Short) -iDelta)
96898>>>>>>>        Send ScrollClientArea
96899>>>>>>>    End_Procedure
96900>>>>>>>    
96900>>>>>>>    // make sure client is a 0,0
96900>>>>>>>    Procedure ScrollHome
96902>>>>>>>        Send SetVScrollbox SB_TOP 0
96903>>>>>>>        Send SetHScrollbox SB_TOP 0
96904>>>>>>>    End_Procedure
96905>>>>>>>    
96905>>>>>>>    // get relative GUI location of this object to the parent one passed.
96905>>>>>>>    Procedure LocationRelativeTo Handle hoContainer Handle hoControl Integer ByRef iLocY Integer ByRef iLocX
96907>>>>>>>        Integer ivoid
96907>>>>>>>        tWinRect Rect0 Rect1
96907>>>>>>>        tWinRect Rect0 Rect1
96907>>>>>>>        Move (GetWindowRect(window_handle(hoContainer),addressof(Rect0))) to ivoid
96908>>>>>>>        Move (GetWindowRect(window_handle(hoControl),addressof(Rect1))) to ivoid
96909>>>>>>>        Move ((Rect1.top) - (Rect0.top)) to iLocY
96910>>>>>>>        Move ((rect1.left) - (rect0.left)) to iLocX
96911>>>>>>>    End_Procedure
96912>>>>>>>    
96912>>>>>>>    // This scrolls this object into visual range.
96912>>>>>>>    Procedure ScrollObjectInRange Handle hoControl
96914>>>>>>>        Handle hoScrollingContainer
96914>>>>>>>        Integer iCurrentVertScrolled iCurrentHorzScrolled
96914>>>>>>>        Integer iViewHeight iViewWidth
96914>>>>>>>        Integer iRelLocHeight iRelLocWidth
96914>>>>>>>        Integer iSize iControlHeight iControlWidth
96914>>>>>>>        Integer iScroll
96914>>>>>>>        Integer iMarginX iMarginY
96914>>>>>>>        Integer iScrollingContainerWindowSize iScrollingContainerClientSize
96914>>>>>>>        
96914>>>>>>>        Get piAutoScrollMarginX to iMarginX
96915>>>>>>>        Get piAutoScrollMarginY to iMarginY
96916>>>>>>>        
96916>>>>>>>        // the scrolling container
96916>>>>>>>        Move Self to hoScrollingContainer
96917>>>>>>>        // the amount the SC is currently scrolled
96917>>>>>>>        Get piCurrentVertScrolled of hoScrollingContainer to iCurrentVertScrolled
96918>>>>>>>        Get piCurrentHorzScrolled of hoScrollingContainer to iCurrentHorzScrolled
96919>>>>>>>        
96919>>>>>>>        // size of view's client area (this is the viewport area)
96919>>>>>>>        Get GuiClientSize of (Parent(hoScrollingContainer)) to iSize
96920>>>>>>>        Move (hi(iSize)) to iViewHeight
96921>>>>>>>        Move (low(iSize)) to iViewWidth
96922>>>>>>>        
96922>>>>>>>        // get this object's location relative to the scrolling container
96922>>>>>>>        Send LocationRelativeTo hoScrollingContainer hoControl (&iRelLocHeight) (&iRelLocWidth)
96923>>>>>>>        
96923>>>>>>>        // we expect that the client size is the window size but just in case
96923>>>>>>>        Get GuiWindowSize of hoScrollingContainer to iScrollingContainerWindowSize
96924>>>>>>>        Get GuiClientSize of hoScrollingContainer to iScrollingContainerClientSize
96925>>>>>>>        Move (iRelLocHeight - (Hi(iScrollingContainerWindowSize)-Hi(iScrollingContainerClientSize))) to iRelLocHeight
96926>>>>>>>        Move (iRelLocWidth - (Low(iScrollingContainerWindowSize)-Low(iScrollingContainerClientSize))) to iRelLocWidth
96927>>>>>>>        
96927>>>>>>>        // the outer size of the control object
96927>>>>>>>        Get GUIWindowSize of hoControl to iSize
96928>>>>>>>        Move (hi(iSize)) to iControlHeight
96929>>>>>>>        Move (low(iSize)) to iControlWidth
96930>>>>>>>        
96930>>>>>>>        // the general idea is to make the control fully visible but to scroll as little as possible.
96930>>>>>>>        
96930>>>>>>>        // Vertical Scroll
96930>>>>>>>        
96930>>>>>>>        // Vertical Scroll down
96930>>>>>>>        // if the bottom of the control plus a bottom margin does not fit make it fit at the bottom
96930>>>>>>>        If (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled >iViewHeight) Begin
96932>>>>>>>            
96932>>>>>>>            // set scroll amount so that the bottom of the control is visible
96932>>>>>>>            Move (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled - iViewHeight ) to iScroll
96933>>>>>>>            
96933>>>>>>>            // See if this amount, scrolls the top out of range. If so just scroll enough so that the
96933>>>>>>>            // top of the object appears at the bottom
96933>>>>>>>            If (iRelLocHeight - iCurrentVertScrolled < iScroll) Begin
96935>>>>>>>                Move (iRelLocHeight + iMarginY  - iCurrentVertScrolled - iViewHeight  ) to iScroll
96936>>>>>>>            End
96936>>>>>>>>
96936>>>>>>>            // if the scroll amnt is negative it's best to just keep it where it is.
96936>>>>>>>            If (iScroll>0) Begin
96938>>>>>>>                Send VScroll of hoScrollingContainer iScroll
96939>>>>>>>            End
96939>>>>>>>>
96939>>>>>>>        End
96939>>>>>>>>
96939>>>>>>>        // else vertical scroll up
96939>>>>>>>        // We scroll if the top of the object is not visible.
96939>>>>>>>        Else If (iRelLocHeight + iMarginY < iCurrentVertScrolled) Begin
96942>>>>>>>            // if we scroll we will scroll enough to see the top of the object.
96942>>>>>>>            Move (iRelLocHeight -iMarginY - iCurrentVertScrolled ) to iScroll
96943>>>>>>>            If (iScroll<0) Begin
96945>>>>>>>                Send VScroll of hoScrollingContainer (iScroll max (-iCurrentVertScrolled))
96946>>>>>>>            End
96946>>>>>>>>
96946>>>>>>>        End
96946>>>>>>>>
96946>>>>>>>        
96946>>>>>>>        // Horizonal Scroll
96946>>>>>>>        
96946>>>>>>>        // if the right side of the control does not fit, scroll it so it fits
96946>>>>>>>        If (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled >iViewWidth) Begin
96948>>>>>>>            Move (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled - iViewWidth ) to iScroll
96949>>>>>>>            If (iRelLocWidth - iCurrentHorzScrolled - iScroll<0) Begin
96951>>>>>>>                Move (iRelLocWidth  - iCurrentHorzScrolled - iMarginX ) to iScroll
96952>>>>>>>            End
96952>>>>>>>>
96952>>>>>>>            If (iScroll>0) Begin
96954>>>>>>>                Send HScroll of hoScrollingContainer iScroll
96955>>>>>>>            End
96955>>>>>>>>
96955>>>>>>>        End
96955>>>>>>>>
96955>>>>>>>        If (iRelLocWidth - iMarginX  - iCurrentHorzScrolled <0) Begin
96957>>>>>>>            // if this can fit by moving all the way to left, do so.
96957>>>>>>>            If (iRelLocWidth + iControlWidth + iMarginX <= iViewWidth) Begin
96959>>>>>>>                Move (-iCurrentHorzScrolled) to iScroll
96960>>>>>>>            End
96960>>>>>>>>
96960>>>>>>>            Else Begin
96961>>>>>>>                Move (iRelLocWidth - iCurrentHorzScrolled - iMarginX) to iScroll
96962>>>>>>>            End
96962>>>>>>>>
96962>>>>>>>            If (iScroll<0) Begin
96964>>>>>>>                Send HScroll of hoScrollingContainer (iScroll max (-iCurrentHorzScrolled))
96965>>>>>>>            End
96965>>>>>>>>
96965>>>>>>>        End
96965>>>>>>>>
96965>>>>>>>        
96965>>>>>>>        
96965>>>>>>>    End_Procedure
96966>>>>>>>    
96966>>>>>>>    // when we receive this message, we might need to scroll to bring the new focus in to view.
96966>>>>>>>    Procedure NotifyFocusSetInContainer Handle hoControl
96968>>>>>>>        Boolean bScrollOnFocus
96968>>>>>>>        Get pbAutoScrollFocus to bScrollOnFocus
96969>>>>>>>        If bScrollOnFocus Begin
96971>>>>>>>            Send ScrollObjectInRange hoControl
96972>>>>>>>        End
96972>>>>>>>>
96972>>>>>>>        Delegate Send NotifyFocusSetInContainer hoControl
96974>>>>>>>    End_Procedure
96975>>>>>>>    
96975>>>>>>>    
96975>>>>>>>    Function CenterTabWorkspaceView Returns Boolean
96977>>>>>>>        Boolean bCenter
96977>>>>>>>        Get pbCenterTabbedViews of ghoCommandBars to bCenter
96978>>>>>>>        Function_Return bCenter
96979>>>>>>>    End_Function
96980>>>>>>>    
96980>>>>>>>    Procedure AdjustSizesLocs Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
96982>>>>>>>        Boolean bTabWorkspaceView
96982>>>>>>>        Get pbTabWorkspaceView to bTabWorkspaceView
96983>>>>>>>        If bTabWorkspaceView Begin
96985>>>>>>>            Send AdjustTabWorkspaceView (&iHeight) (&iWidth) (&iLocY) (&iLocX)
96986>>>>>>>        End
96986>>>>>>>>
96986>>>>>>>    End_Procedure
96987>>>>>>>    
96987>>>>>>>    Function ParentView Returns Handle
96989>>>>>>>        Function_Return (Parent(Parent(Self)))
96990>>>>>>>    End_Function
96991>>>>>>>    
96991>>>>>>>    Procedure AdjustTabWorkspaceView Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
96993>>>>>>>        Integer iSize iMax iDiff
96993>>>>>>>        Handle hoView
96993>>>>>>>        Boolean bCenter bModal
96993>>>>>>>        Get ParentView to hoView
96994>>>>>>>        Get Block_Mouse_State of hoView to bModal
96995>>>>>>>        If not bModal Begin
96997>>>>>>>            Get CenterTabWorkspaceView to bCenter
96998>>>>>>>            Get GuiSize of hoView to iSize
96999>>>>>>>            Get piMaxSize of hoView to iMax
97000>>>>>>>            Get DialogToGui (Hi(iMax)) (Low(iMax)) to iMax
97001>>>>>>>            If (Low(iMax) and Low(iMax)<=Low(isize)) Begin
97003>>>>>>>                If bCenter Begin
97005>>>>>>>                    Move ((Low(iSize)-Low(iMax))/2) to iLocX
97006>>>>>>>                End
97006>>>>>>>>
97006>>>>>>>                Move (Low(iMax)) to iWidth
97007>>>>>>>            End
97007>>>>>>>>
97007>>>>>>>            If (Hi(iMax) and Hi(iMax)<=Hi(iSize)) Begin
97009>>>>>>>                If bCenter Begin
97011>>>>>>>                    Move ((Hi(iSize)-Hi(iMax))/2) to iLocY
97012>>>>>>>                    Move (iLocy min 25) to  iLocY
97013>>>>>>>                End
97013>>>>>>>>
97013>>>>>>>                Move (Hi(imax)) to iHeight
97014>>>>>>>            End
97014>>>>>>>>
97014>>>>>>>        End
97014>>>>>>>>
97014>>>>>>>    End_Procedure
97015>>>>>>>    
97015>>>>>>>    // Automatically determine if this is a scrolling tabbed workspace view
97015>>>>>>>    // If determines this by checking pbAutoSetTabWorkspaceView is set (it can be
97015>>>>>>>    // set to stop this), if we have a global commandbar object and we are using tabbed
97015>>>>>>>    // workspaces. We also make sure that the expected view object is a framework view class
97015>>>>>>>    // This should almost always yield the right answer.
97015>>>>>>>    // This is called by the scrolling container's end_constructor
97015>>>>>>>    Procedure AutoSetTabWorkspaceView
97017>>>>>>>        Boolean bTabView bIsView bAutoSetTabWorkspaceView
97017>>>>>>>        Handle hoParent
97017>>>>>>>        Integer iSize
97017>>>>>>>        Get pbAutoSetTabWorkspaceView to bAutoSetTabWorkspaceView
97018>>>>>>>        If (ghoCommandBars and bAutoSetTabWorkspaceView) Begin
97020>>>>>>>            Get pbTabbedWorkspaces of ghoCommandBars to bTabView
97021>>>>>>>            // not that pbTabbedWorkspaces is a designtime only property. You can not
97021>>>>>>>            // change this after the commandbar is paged.
97021>>>>>>>            If (bTabView) Begin
97023>>>>>>>                Get ParentView to hoParent
97024>>>>>>>                Get IsObjectOfClass of hoParent (RefClass(MdiDialog)) to bIsView
97025>>>>>>>                If (bIsView) Begin
97027>>>>>>>                    // set this as a tab workspace view
97027>>>>>>>                    Set pbTabWorkspaceView to True
97028>>>>>>>                    // when tab workspaces are enabled we always enable auto-scrolling
97028>>>>>>>                    // when tab workspaces are not enabled, pbScroll is whatever it is
97028>>>>>>>                    Set pbAutoScroll to True
97029>>>>>>>                    
97029>>>>>>>                End
97029>>>>>>>>
97029>>>>>>>            End
97029>>>>>>>>
97029>>>>>>>        End
97029>>>>>>>>
97029>>>>>>>    End_Procedure
97030>>>>>>>    
97030>>>>>>>End_Class
97031>>>>>>>
97031>>>>>>>// Container scrolling class support. Nothing in here is public
97031>>>>>>>Class cScrollingContainerMixin is a Mixin
97032>>>>>>>    
97032>>>>>>>    Procedure Define_cScrollingContainerMixin
97034>>>>>>>        Forward Set Border_Style to Border_None
97036>>>>>>>        Set pbSizeToClientArea to False // scrollbars and clientsize do not mix
97037>>>>>>>        Forward Set peAnchors to anAll
97039>>>>>>>        
97039>>>>>>>        // forcing scrollbars right away seems to make painting better
97039>>>>>>>        Set Window_Style WS_HSCROLL to True
97040>>>>>>>        Set Window_Style WS_VSCROLL to True
97041>>>>>>>        
97041>>>>>>>        Property Handle phoScrollingClientArea 0
97042>>>>>>>    End_Procedure
97043>>>>>>>    
97043>>>>>>>    // if anchors are changed, it will not work. We won't let that happen
97043>>>>>>>    Procedure Set peAnchors Integer eAnchors
97045>>>>>>>    End_Procedure
97046>>>>>>>    
97046>>>>>>>    // if a border style is set, it will not work. We won't let that happen
97046>>>>>>>    Procedure Set Border_Style Integer eStyle
97048>>>>>>>    End_Procedure
97049>>>>>>>    
97049>>>>>>>    // redirect scrollbar events and wheel events to the scrolling client area
97049>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
97051>>>>>>>        Handle hoClient
97051>>>>>>>        Get phoScrollingClientArea to hoClient
97052>>>>>>>        If hoClient Begin
97054>>>>>>>            Send OnMouseWheel of hoClient wParam lParam
97055>>>>>>>        End
97055>>>>>>>>
97055>>>>>>>    End_Procedure
97056>>>>>>>    
97056>>>>>>>    // should be sent by WM_VSCROLL
97056>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
97058>>>>>>>        Handle hoClient
97058>>>>>>>        Get phoScrollingClientArea to hoClient
97059>>>>>>>        If hoClient Begin
97061>>>>>>>            Send SetVScrollbox of hoClient iType iNewPos
97062>>>>>>>        End
97062>>>>>>>>
97062>>>>>>>    End_Procedure
97063>>>>>>>    
97063>>>>>>>    // should be sent by WM_HSCROLL
97063>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
97065>>>>>>>        Handle hoClient
97065>>>>>>>        Get phoScrollingClientArea to hoClient
97066>>>>>>>        If hoClient Begin
97068>>>>>>>            Send SetHScrollbox of hoClient iType iNewPos
97069>>>>>>>        End
97069>>>>>>>>
97069>>>>>>>    End_Procedure
97070>>>>>>>    
97070>>>>>>>    // augmented to adjust its size to the size of the parent client area.
97070>>>>>>>    // After this is set, anchors will handle any further resizing.
97070>>>>>>>    Procedure Page Integer iState
97072>>>>>>>        Integer iSiz iHeight iWidth
97072>>>>>>>        Integer iTop iBottom iLeft iRight iFontSize
97072>>>>>>>        Boolean bGroup
97072>>>>>>>        Handle hoClient
97072>>>>>>>        If (iState =1) Begin
97074>>>>>>>            Delegate Get Window_Style BS_GROUPBOX to bGroup
97076>>>>>>>            // We have special code to support groups because they
97076>>>>>>>            // draw a border inside of the client rectangle
97076>>>>>>>            If bGroup Begin
97078>>>>>>>                Get Physical_FontSize to iFontSize
97079>>>>>>>                Move (Hi(iFontSize)) to iTop
97080>>>>>>>                Move 2 to iLeft
97081>>>>>>>                Move 2 to iRight
97082>>>>>>>                Move 2 to iBottom
97083>>>>>>>            End
97083>>>>>>>>
97083>>>>>>>            // We use GetContainerClientSize instead of GuiClientSize because
97083>>>>>>>            // GetContainerClientSize has a special augmentation in tab pages that
97083>>>>>>>            // makes anchors work properly with unpaged tab-pages
97083>>>>>>>            Delegate Get GetContainerClientSize to iSiz
97085>>>>>>>            Set GuiSize to (Hi(iSiz)-(iTop+iBottom)) (Low(iSiz)-(iLeft+iRight))
97086>>>>>>>            Set GuiLocation to iTop iLeft
97087>>>>>>>            Send Adjust_Logicals
97088>>>>>>>        End
97088>>>>>>>>
97088>>>>>>>        Forward Send Page iState
97090>>>>>>>    End_Procedure
97091>>>>>>>    
97091>>>>>>>    Procedure End_Construct_Object
97093>>>>>>>        Handle hoClient
97093>>>>>>>        Forward Send End_Construct_Object
97095>>>>>>>        Get phoScrollingClientArea to hoClient
97096>>>>>>>        If (hoClient) Begin
97098>>>>>>>            Send AutoSetTabWorkspaceView of hoClient
97099>>>>>>>        End
97099>>>>>>>>
97099>>>>>>>    End_Procedure
97100>>>>>>>    
97100>>>>>>>End_Class
97101>>>>>
97101>>>>>Class cDbScrollingClientArea is a dbContainer3d
97102>>>>>    Import_Class_Protocol cScrollingClientAreaMixin
97103>>>>>    Procedure Construct_Object
97105>>>>>        Forward Send Construct_Object
97107>>>>>        Send Define_cScrollingClientAreaMixin
97108>>>>>    End_Procedure
97109>>>>>End_Class
97110>>>>>
97110>>>>>
97110>>>>>
97110>>>>>Class cDbScrollingContainer is a dbContainer3d
97111>>>>>    Import_Class_Protocol cScrollingContainerMixin
97112>>>>>    Procedure Construct_Object
97114>>>>>        Forward Send Construct_Object
97116>>>>>        Send Define_cScrollingContainerMixin
97117>>>>>    End_Procedure
97118>>>>>End_Class
97119>>>Use cDbUpdateFunctionLibrary.pkg
97119>>>Use cRDCButtonDPI.pkg
Including file: cRDCButtonDPI.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButtonDPI.pkg)
97119>>>>>//****************************************************************************
97119>>>>>// $Module type: Package
97119>>>>>// $Module name: cRDCButtonDPI.pkg
97119>>>>>//
97119>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
97119>>>>>// Copyright (c) 2013 RDC Tools International
97119>>>>>// E-mail      : support@rdctools.com
97119>>>>>// Web-site    : http://www.rdctools.com
97119>>>>>//
97119>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
97119>>>>>//
97119>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
97119>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
97119>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
97119>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
97119>>>>>// in the help folder for more details.
97119>>>>>//
97119>>>>>//****************************************************************************
97119>>>>>Use cRDCButton.pkg
Including file: cRDCButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButton.pkg)
97119>>>>>>>//****************************************************************************
97119>>>>>>>// $Module type: Package
97119>>>>>>>// $Module name: cRDCButton.pkg
97119>>>>>>>//
97119>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
97119>>>>>>>// Copyright (c) 2013 RDC Tools International
97119>>>>>>>// E-mail      : support@rdctools.com
97119>>>>>>>// Web-site    : http://www.rdctools.com
97119>>>>>>>//
97119>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
97119>>>>>>>//
97119>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
97119>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
97119>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
97119>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
97119>>>>>>>// in the help folder for more details.
97119>>>>>>>//
97119>>>>>>>//****************************************************************************
97119>>>>>>>Use Windows.pkg
97119>>>>>>>Use Enclient.pkg
97119>>>>>>>Use errornum.inc
97119>>>>>>>
97119>>>>>>>Class cButtonIdleHandler is a cIdleHandler
97120>>>>>>>    Procedure Construct_Object
97122>>>>>>>        Forward Send Construct_Object
97124>>>>>>>
97124>>>>>>>    End_Procedure
97125>>>>>>>
97125>>>>>>>    Procedure OnIdle
97127>>>>>>>        Delegate Send DoUpdate
97129>>>>>>>    End_Procedure
97130>>>>>>>
97130>>>>>>>End_Class
97131>>>>>>>
97131>>>>>>>Class cRDCButton is a Button
97132>>>>>>>
97132>>>>>>>    Procedure Construct_Object
97134>>>>>>>        Forward Send Construct_Object
97136>>>>>>>
97136>>>>>>>        Property Boolean pbAutoEnable True
97137>>>>>>>
97137>>>>>>>        Property Boolean pbEnabled True
97138>>>>>>>
97138>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cButtonIdleHandler)))
97139>>>>>>>
97139>>>>>>>        On_Key kCancel Send CancelIfPopupObject
97140>>>>>>>    End_Procedure
97141>>>>>>>
97141>>>>>>>    Procedure CancelIfPopupObject
97143>>>>>>>        Boolean bIsInPopupObject
97143>>>>>>>        Delegate Get Popup_State to bIsInPopupObject
97145>>>>>>>        If (bIsInPopupObject = True) Begin
97147>>>>>>>            Send Close_Panel
97148>>>>>>>        End
97148>>>>>>>>
97148>>>>>>>    End_Procedure
97149>>>>>>>
97149>>>>>>>    Procedure End_Construct_Object
97151>>>>>>>        String sTooltip sStatus_Help
97151>>>>>>>
97151>>>>>>>        Forward Send End_Construct_Object
97153>>>>>>>
97153>>>>>>>        Get psToolTip   to sTooltip
97154>>>>>>>        Get Status_Help to sStatus_Help
97155>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
97157>>>>>>>            Set psToolTip to sStatus_Help
97158>>>>>>>        End
97158>>>>>>>>
97158>>>>>>>        If (sTooltip <> "" and sStatus_Help = "") Begin
97160>>>>>>>            Set Status_Help to sToolTip
97161>>>>>>>        End
97161>>>>>>>>
97161>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
97162>>>>>>>    End_Procedure
97163>>>>>>>
97163>>>>>>>    Procedure DoUpdate
97165>>>>>>>        If (pbAutoEnable(Self) = False) Begin
97167>>>>>>>            Procedure_Return
97168>>>>>>>        End
97168>>>>>>>>
97168>>>>>>>        Set Enabled_State to (IsEnabled(Self))
97169>>>>>>>    End_Procedure
97170>>>>>>>
97170>>>>>>>    Function IsEnabled Returns Boolean
97172>>>>>>>        Boolean bEnabled
97172>>>>>>>        Get pbEnabled to bEnabled
97173>>>>>>>        Function_Return bEnabled
97174>>>>>>>    End_Function
97175>>>>>>>
97175>>>>>>>    // Enable the idle handler timer when the button is activated
97175>>>>>>>    Procedure Activating
97177>>>>>>>        Forward Send Activating
97179>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
97180>>>>>>>    End_Procedure
97181>>>>>>>
97181>>>>>>>    // Disable the idle handler when the button is deactivated
97181>>>>>>>    Procedure Deactivating
97183>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
97184>>>>>>>        Forward Send Deactivating
97186>>>>>>>    End_Procedure
97187>>>>>>>
97187>>>>>>>End_Class
97188>>>>>
97188>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
97188>>>>>Class cRDCButtonDPI is a cRDCButton
97189>>>>>    Procedure Construct_Object
97191>>>>>        Integer iIconSize
97191>>>>>        Forward Send Construct_Object
97193>>>>>        Set piImageMarginLeft to 10
97194>>>>>    End_Procedure
97195>>>>>
97195>>>>>    // Returns: DPI setting as an integer.
97195>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
97195>>>>>    //                      iDPI=120 is "Medium setting" 125%
97195>>>>>    //                      iDPI= 144 is "Large setting" 150%
97195>>>>>    Function GetCurrentDPI Returns Integer
97197>>>>>        Handle hDC
97197>>>>>        Integer iPixelsX
97197>>>>>        Move (GetDC(0)) to hDC
97198>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
97199>>>>>        Move (ReleaseDC(0, hDC)) to hDC
97200>>>>>        Function_Return iPixelsX
97201>>>>>    End_Function
97202>>>>>
97202>>>>>    Function GetCorrectIconSize Returns Integer
97204>>>>>        Integer iPixelsX iIndex iSize
97204>>>>>        Integer[] iaSizes
97205>>>>>
97205>>>>>        Move 16 to iaSizes[0]
97206>>>>>        Move 24 to iaSizes[1]
97207>>>>>        Move 32 to iaSizes[2]
97208>>>>>        Move 48 to iaSizes[3]
97209>>>>>        Move 64 to iaSizes[4]
97210>>>>>
97210>>>>>        Get piImageSize to iSize  // the "100%" size
97211>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
97212>>>>>        Move (0 max iIndex) to iIndex
97213>>>>>        Get GetCurrentDPI to iPixelsX
97214>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
97214>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
97214>>>>>        // will increment iIndex as many times as we need here.
97214>>>>>        Case Begin
97214>>>>>            Case (iPixelsX > 144)
97216>>>>>                Increment iIndex
97217>>>>>            Case (iPixelsX = 144)
97220>>>>>                Increment iIndex
97221>>>>>            Case (iPixelsX = 120)
97224>>>>>                Increment iIndex
97225>>>>>        Case End
97225>>>>>        Move (iIndex min 4) to iIndex
97226>>>>>        Function_Return iaSizes[iIndex]
97227>>>>>    End_Function
97228>>>>>
97228>>>>>    Procedure Set psToolTip String sToolTip
97230>>>>>        String sStatusHelp
97230>>>>>
97230>>>>>        Get Status_Help to sStatusHelp
97231>>>>>        If (sStatusHelp = "") Begin
97233>>>>>            Set Status_Help to sToolTip
97234>>>>>        End
97234>>>>>>
97234>>>>>
97234>>>>>        Forward Set psToolTip to sToolTip
97236>>>>>    End_Procedure
97237>>>>>
97237>>>>>End_Class
97238>>>Use DatabaseSelection.dg
97238>>>Use ServerSelection.dg
Including file: ServerSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ServerSelection.dg)
97238>>>>>Use Windows.pkg
97238>>>>>Use cCJGridPromptList.pkg
97238>>>>>Use MSSqldrv.pkg
97238>>>>>Use db2_drv.pkg
97238>>>>>Use odbc_drv.pkg    
97238>>>>>Use cRDCModalPanel.pkg
97238>>>>>Use cDbUpdateFunctionLibrary.pkg
97238>>>>>
97238>>>>>Object oServerSelection_sl is a cRDCModalPanel
97240>>>>>    Set Size to 105 225
97241>>>>>    Set Label to "Database Server/DSN Selection"
97242>>>>>    Set piMinSize to 89 211
97243>>>>>    Set Location to 2 2
97244>>>>>    Set Icon to "ServerLookup1.ico"
97245>>>>>
97245>>>>>    Property String[] psTheData
97247>>>>>
97247>>>>>    Object oSelList is a cCJGridPromptList
97249>>>>>        Set Size to 72 215
97250>>>>>        Set Location to 6 6
97251>>>>>        Set peAnchors to anAll
97252>>>>>        Set pbAllowColumnRemove to False
97253>>>>>        Set pbUseAlternateRowBackgroundColor to True
97254>>>>>        Set pbGrayIfDisable to False
97255>>>>>        Set pbHeaderReorders to False
97256>>>>>        Set pbHeaderSelectsColumn to False
97257>>>>>        Set pbHeaderTogglesDirection to False
97258>>>>>        Set pbShadeSortColumn to False
97259>>>>>        Set piFocusCellBackColor to clDkGray
97260>>>>>
97260>>>>>        Object oName is a cCJGridColumn
97262>>>>>            Set piWidth to 358
97263>>>>>            Set psCaption to "Name"
97264>>>>>        End_Object
97265>>>>>
97265>>>>>        Procedure Activating
97268>>>>>            tDataSourceRow[] MyData
97268>>>>>            tDataSourceRow[] MyData
97269>>>>>            Handle hoDataSource
97269>>>>>            String[] sTheData
97270>>>>>            Integer iCount iSize
97270>>>>>
97270>>>>>            Send Cursor_Wait of Cursor_Control
97271>>>>>            Get psTheData to sTheData
97272>>>>>            Move (SizeOfArray(sTheData)) to iSize
97273>>>>>            Decrement iSize
97274>>>>>            For iCount from 0 to iSize
97280>>>>>>
97280>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
97281>>>>>            Loop
97282>>>>>>
97282>>>>>
97282>>>>>            Forward Send Activating
97284>>>>>
97284>>>>>            Get phoDataSource to hoDataSource
97285>>>>>            Send InitializeData of hoDataSource MyData
97286>>>>>            Send Cursor_Ready of Cursor_Control
97287>>>>>        End_Procedure
97288>>>>>
97288>>>>>    End_Object
97289>>>>>
97289>>>>>    Object oOK_Btn is a Button
97291>>>>>        Set Size to 14 50
97292>>>>>        Set Label    to "&OK"
97293>>>>>        Set Location to 85 116
97294>>>>>        Set peAnchors To anBottomRight
97295>>>>>
97295>>>>>        Procedure OnClick
97298>>>>>            Send Ok of oSelList
97299>>>>>        End_Procedure
97300>>>>>
97300>>>>>    End_Object
97301>>>>>
97301>>>>>    Object oCancel_Btn is a Button
97303>>>>>        Set Size to 14 50
97304>>>>>        Set Label    to "&Cancel"
97305>>>>>        Set Location to 85 171
97306>>>>>        Set peAnchors to anBottomRight
97307>>>>>
97307>>>>>        Procedure OnClick
97310>>>>>            Send Close_Panel
97311>>>>>        End_Procedure
97312>>>>>
97312>>>>>    End_Object
97313>>>>>
97313>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
97314>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
97315>>>>>End_Object
97316>>>Use SQLConnections.dg
Including file: SQLConnections.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLConnections.dg)
97316>>>>>Use Windows.pkg
97316>>>>>Use cCJGridPromptList.pkg
97316>>>>>Use cDbUpdateFunctionLibrary.pkg
97316>>>>>Use MSSqldrv.pkg
97316>>>>>Use db2_drv.pkg
97316>>>>>Use odbc_drv.pkg
97316>>>>>Use cCJGridColumn.pkg
97316>>>>>
97316>>>>>Object oSQLConnections is a ModalPanel
97318>>>>>    Set Label to "SQL Connections"
97319>>>>>    Set Size to 121 397
97320>>>>>    Set piMinSize to 89 185
97321>>>>>    Set Location to 2 2
97322>>>>>    Set Border_Style to Border_Thick
97323>>>>>
97323>>>>>    Property tSQLConnection[] psTheData
97325>>>>>
97325>>>>>//    If (ghoDbUpdateFunctionLibrary = 0) Begin
97325>>>>>//        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
97325>>>>>//        End_Object
97325>>>>>//    End
97325>>>>>
97325>>>>>    Object oSelListSQLConnections is a cCJGridPromptList
97327>>>>>        Set Size to 90 377
97328>>>>>        Set Location to 6 6
97329>>>>>        Set peAnchors to anAll
97330>>>>>        Set pbAllowColumnRemove to False
97331>>>>>        Set pbUseAlternateRowBackgroundColor to True
97332>>>>>        Set pbGrayIfDisable to False
97333>>>>>        Set pbHeaderReorders to False
97334>>>>>        Set pbHeaderSelectsColumn to False
97335>>>>>        Set pbHeaderTogglesDirection to False
97336>>>>>        Set pbShadeSortColumn to False
97337>>>>>        Set piFocusCellBackColor to clDkGray  
97338>>>>>        Set pbRestoreLayout to True
97339>>>>>        Set psLayoutSection to "oSQLConnections_oSelListSQLConnections"
97340>>>>>
97340>>>>>        Object oID_Col is a cCJGridColumn
97342>>>>>            Set piWidth to 132
97343>>>>>            Set psCaption to "ID"
97344>>>>>        End_Object
97345>>>>>
97345>>>>>        Object oDbType_Col is a cCJGridColumn
97347>>>>>            Set piWidth to 182
97348>>>>>            Set psCaption to "Database Type"
97349>>>>>        End_Object
97350>>>>>
97350>>>>>        Object oServer_Col is a cCJGridColumn
97352>>>>>            Set piWidth to 296
97353>>>>>            Set psCaption to "Server/DSN"
97354>>>>>        End_Object
97355>>>>>
97355>>>>>        Object oDatabase_Col is a cCJGridColumn
97357>>>>>            Set piWidth to 211
97358>>>>>            Set psCaption to "Database"
97359>>>>>        End_Object
97360>>>>>
97360>>>>>        Object oDriverID_Col is a cCJGridColumn
97362>>>>>            Set piWidth to 121
97363>>>>>            Set psCaption to "Driver ID"
97364>>>>>        End_Object
97365>>>>>
97365>>>>>        Procedure Activating
97368>>>>>            tDataSourceRow[] MyData
97368>>>>>            tDataSourceRow[] MyData
97369>>>>>            Handle hoDataSource
97369>>>>>            Integer iCount iSize iPos
97369>>>>>            String sDriverID sConnectionID sValue
97369>>>>>            tSQLConnection[] sTheData
97369>>>>>            tSQLConnection[] sTheData
97370>>>>>
97370>>>>>            Send Cursor_Wait of Cursor_Control
97371>>>>>            Forward Send Activating
97373>>>>>
97373>>>>>            Get psTheData to sTheData
97374>>>>>            Move (SizeOfArray(sTheData)) to iSize
97375>>>>>            Decrement iSize
97376>>>>>            For iCount from 0 to iSize
97382>>>>>>
97382>>>>>                Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary sTheData[iCount].iDbType to sValue
97383>>>>>                Move sTheData[iCount].sConnectionID to MyData[iCount].sValue[0]
97384>>>>>                Move sValue                         to MyData[iCount].sValue[1]
97385>>>>>                Move sTheData[iCount].sServer       to MyData[iCount].sValue[2]
97386>>>>>                Move sTheData[iCount].sDatabase     to MyData[iCount].sValue[3]
97387>>>>>                Move sTheData[iCount].sDriverID     to MyData[iCount].sValue[4]
97388>>>>>            Loop
97389>>>>>>
97389>>>>>
97389>>>>>            Get phoDataSource to hoDataSource
97390>>>>>            Send InitializeData of hoDataSource MyData
97391>>>>>            Send Cursor_Ready of Cursor_Control
97392>>>>>        End_Procedure
97393>>>>>
97393>>>>>    End_Object
97394>>>>>
97394>>>>>    Object oOK_Btn is a Button
97396>>>>>        Set Label    to "&OK"
97397>>>>>        Set Location to 101 280
97398>>>>>        Set peAnchors to anBottomRight
97399>>>>>
97399>>>>>        Procedure OnClick
97402>>>>>            Send Ok of oSelListSQLConnections
97403>>>>>        End_Procedure
97404>>>>>
97404>>>>>    End_Object
97405>>>>>
97405>>>>>    Object oCancel_Btn is a Button
97407>>>>>        Set Label    to "&Cancel"
97408>>>>>        Set Location to 101 335
97409>>>>>        Set peAnchors to anBottomRight
97410>>>>>
97410>>>>>        Procedure OnClick
97413>>>>>            Send Close_Panel
97414>>>>>        End_Procedure
97415>>>>>
97415>>>>>    End_Object
97416>>>>>
97416>>>>>    Procedure Page Integer iPageObject
97419>>>>>        Set Icon to "SQLConnections1.ico"
97420>>>>>        Forward Send Page iPageObject
97422>>>>>    End_Procedure
97423>>>>>
97423>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
97424>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
97425>>>>>End_Object
97426>>>
97426>>>Activate_View Activate_oSQLConnections_vw for oSQLConnections_vw
97436>>>>
97436>>>Object oSQLConnections_vw is a dbView
97438>>>    Set Border_Style to Border_Thick
97439>>>    Set Size to 251 427
97440>>>    Set Location to 2 2
97441>>>    Set Label to "SQL Connections"
97442>>>    Set pbAutoActivate to True
97443>>>    Set Icon to "SQLConnections1.ico"
97444>>>
97444>>>    Object oScrollingContainer1 is a cDbScrollingContainer
97446>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
97448>>>
97448>>>            Object oCurrentSettings_grp is a Group
97450>>>                Set Size to 232 402
97451>>>                Set Location to 6 12
97452>>>                Set Label to "Current Connection Settings"
97453>>>                Set peAnchors to anAll
97454>>>
97454>>>                Object oConnectionID_fm is a Form
97456>>>                    Set Size to 12 100
97457>>>                    Set Location to 12 68
97458>>>                    Set Label to "Connection ID"
97459>>>                    Set Label_Col_Offset to 2
97460>>>                    Set Label_Justification_Mode to JMode_Right
97461>>>                    Set Prompt_Button_Mode to PB_PromptOn
97462>>>                    Set Prompt_Object to (oSQLConnections(Self))
97463>>>
97463>>>                    Procedure Prompt
97466>>>                        String[] sTheData
97467>>>                        String sCurrentVal sNewVal
97467>>>                        Handle hoIniFile ho
97467>>>                        Integer iSize iCount
97467>>>                        tSQLConnection[] SQLConnectionArray
97467>>>                        tSQLConnection[] SQLConnectionArray
97468>>>
97468>>>                        Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to hoIniFile
97469>>>                        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
97470>>>                        Get Value to sCurrentVal
97471>>>                        Get Prompt_Object to ho
97472>>>                        Set psTheData of ho to SQLConnectionArray
97473>>>
97473>>>                        Forward Send Prompt
97475>>>                        Get Value to sNewVal
97476>>>                        If (sCurrentVal <> sNewVal) Begin
97478>>>                            Send Cursor_Wait of Cursor_Control
97479>>>                            Set psConnectionID of ghoSQLConnectionHandler to sNewVal
97480>>>                            Broadcast Recursive Send Refresh of (phoMainPanel(ghoApplication))
97482>>>                            Send Cursor_Ready of Cursor_Control
97483>>>                            Send KeyAction of oTestLogin_btn
97484>>>                        End
97484>>>>
97484>>>                    End_Procedure   
97485>>>                    
97485>>>                    Procedure PromptUpdate Handle hoPrompt
97488>>>                        String[] sSelectedNames                    
97489>>>                
97489>>>                        Get SelectedColumnValues of hoPrompt 2 to sSelectedNames // Col 2 = Server column
97490>>>                        If (SizeOfArray(sSelectedNames)) Begin
97492>>>                            Set psServer of ghoSQLConnectionHandler to sSelectedNames[0] 
97493>>>                            Delegate Send Page True // Broadcast sends refresh
97495>>>                        End
97495>>>>
97495>>>                    End_Procedure   
97496>>>
97496>>>                    Procedure Prompt_Callback Handle hoPrompt
97499>>>                        String sServer
97499>>>                        Set peUpdateMode of hoPrompt to umPromptCustom
97500>>>                        Set piUpdateColumn of hoPrompt to 2 // The server column
97501>>>                        Get Value of oServer_fm to sServer
97502>>>                        Set psSeedValue of hoPrompt to sServer
97503>>>                        Set phmPromptUpdateCallback of hoPrompt to (RefProc(PromptUpdate))
97504>>>                    End_Procedure
97505>>>
97505>>>                    Procedure Refresh
97508>>>                        String sValue
97508>>>                        Get psConnectionID of ghoSQLConnectionHandler to sValue
97509>>>                        Set Value to sValue
97510>>>                    End_Procedure
97511>>>
97511>>>                End_Object
97512>>>
97512>>>                Object oDriverID_cf is a ComboForm
97514>>>                    Set Size to 12 91
97515>>>                    Set Location to 12 222
97516>>>                    Set Label_Col_Offset to 2
97517>>>                    Set Label_Justification_Mode to JMode_Right
97518>>>                    Set Label to "Driver ID"
97519>>>                    Set Entry_State to False
97520>>>                    Set Enabled_State to False
97521>>>
97521>>>                    Procedure Combo_Fill_List
97524>>>                        Send Combo_Add_Item MSSQLDRV_ID
97525>>>                        Send Combo_Add_Item DB2_DRV_ID
97526>>>                        Send Combo_Add_Item ODBC_DRV_ID
97527>>>                    End_Procedure
97528>>>
97528>>>                    Procedure OnChange
97531>>>                        String sValue sOrgValue
97531>>>                        Boolean bEnabled bChecked
97531>>>
97531>>>                        Get Value to sValue
97532>>>                        Get psDriverID of ghoSQLConnectionHandler to sOrgValue
97533>>>                        If (sValue <> "" and sValue <> sOrgValue and sValue <> "None") Begin
97535>>>                            Set psDriverID of ghoSQLConnectionHandler to sValue
97536>>>                        End
97536>>>>
97536>>>                        Move (sValue <> "None") to bEnabled
97537>>>                        Broadcast Set Enabled_State of (Parent(Self)) to bEnabled
97539>>>                        Set Enabled_State to False
97540>>>                        Set Enabled_State of oConnectionString_fm to False
97541>>>                        Set Enabled_State of oDatabase_fm to (sValue <> DB2_DRV_ID)
97542>>>
97542>>>                        Get Checked_State of oTrusted_cb  to bChecked
97543>>>                        Set Enabled_State of oUserID_fm   to (bChecked = False)
97544>>>                        Set Enabled_State of oPassword_fm to (bChecked = False)
97545>>>                    End_Procedure
97546>>>
97546>>>                    Procedure Refresh
97549>>>                        String sValue
97549>>>
97549>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
97550>>>                        Set Value to sValue
97551>>>                    End_Procedure
97552>>>
97552>>>                End_Object
97553>>>
97553>>>                Object oServer_fm is a Form
97555>>>                    Set Size to 12 100
97556>>>                    Set Location to 26 68
97557>>>                    Set Label to "Server"
97558>>>                    Set Label_Col_Offset to 2
97559>>>                    Set Label_Justification_Mode to JMode_Right
97560>>>                    Set Prompt_Button_Mode to PB_PromptOn
97561>>>                    Set Prompt_Object to (oServerSelection_sl(Self))
97562>>>
97562>>>                    Procedure Refresh
97565>>>                        String sValue
97565>>>                        Get psServer of ghoSQLConnectionHandler to sValue
97566>>>                        Set Value to sValue
97567>>>                    End_Procedure
97568>>>
97568>>>                    Procedure Prompt
97571>>>                        String[] sTheData
97572>>>                        String sDriverID
97572>>>                        Handle ho
97572>>>
97572>>>                        Send Cursor_Wait of Cursor_Control
97573>>>                        Get Prompt_Object to ho
97574>>>                        Get Value of oDriverID_cf to sDriverID
97575>>>                        Get SqlUtilEnumerateServers of ghoDbUpdateFunctionLibrary sDriverID 2 to sTheData
97576>>>                        Set psTheData of ho to sTheData
97577>>>                        Send Cursor_Ready of Cursor_Control
97578>>>
97578>>>                        Forward Send Prompt
97580>>>                    End_Procedure
97581>>>
97581>>>                End_Object
97582>>>
97582>>>                Object oDatabase_fm is a Form
97584>>>                    Set Size to 12 91
97585>>>                    Set Location to 26 222
97586>>>                    Set Label to "Database"
97587>>>                    Set Label_Col_Offset to 2
97588>>>                    Set Label_Justification_Mode to JMode_Right
97589>>>                    Set Prompt_Button_Mode to PB_PromptOn
97590>>>                    Set Prompt_Object to (oDatabaseSelection_sl(Self))
97591>>>                    Set peAnchors to anNone
97592>>>                    Set Entry_State to False
97593>>>
97593>>>                    Procedure Refresh
97596>>>                        String sDatabase
97596>>>
97596>>>                        Get psDatabase of ghoSQLConnectionHandler to sDatabase
97597>>>                        Set Value to sDatabase
97598>>>                    End_Procedure
97599>>>
97599>>>                    Procedure Prompt
97602>>>                        String[] sTheData
97603>>>                        Handle ho
97603>>>                        String sDriverID
97603>>>
97603>>>                        Get Value of oDriverID_cf to sDriverID
97604>>>                        Get SqlUtilEnumerateDatabases of ghoDbUpdateFunctionLibrary sDriverID to sTheData
97605>>>
97605>>>                        Get Prompt_Object to ho
97606>>>                        Set psTheData of ho to sTheData
97607>>>
97607>>>                        Forward Send Prompt
97609>>>                    End_Procedure
97610>>>
97610>>>                    Procedure OnChange
97613>>>                        String sValue sOrgValue
97613>>>                        Get Value to sValue
97614>>>                        Get psDatabase of ghoSQLConnectionHandler to sOrgValue
97615>>>                        If (Uppercase(Trim(sValue)) <> Uppercase(Trim(sOrgValue))) Begin
97617>>>                            Set psDatabase of ghoSQLConnectionHandler to sValue
97618>>>                            Get psConnectionString of ghoSQLConnectionHandler to sValue
97619>>>                            Set Value of oConnectionString_fm to sValue
97620>>>                        End
97620>>>>
97620>>>                    End_Procedure
97621>>>
97621>>>                End_Object
97622>>>
97622>>>                Object oTrusted_cb is a CheckBox
97624>>>                    Set Size to 10 50
97625>>>                    Set Location to 45 68
97626>>>                    Set Label to "Use Trusted Connection"
97627>>>
97627>>>                    Procedure Refresh
97630>>>                        Boolean bValue
97630>>>                        Get pbTrusted of ghoSQLConnectionHandler to bValue
97631>>>                        Set Checked_State to bValue
97632>>>                    End_Procedure
97633>>>
97633>>>                    Procedure OnChange
97636>>>                        Boolean bChecked
97636>>>
97636>>>                        Get Checked_State to bChecked
97637>>>                        Set Enabled_State of oUserID_fm   to (bChecked = False)
97638>>>                        Set Enabled_State of oPassword_fm to (bChecked = False)
97639>>>                    End_Procedure
97640>>>
97640>>>                End_Object
97641>>>
97641>>>                Object oUserID_fm is a Form
97643>>>                    Set Size to 12 100
97644>>>                    Set Location to 57 68
97645>>>                    Set Label to "UserID"
97646>>>                    Set Label_Col_Offset to 2
97647>>>                    Set Label_Justification_Mode to JMode_Right
97648>>>
97648>>>                    Procedure Refresh
97651>>>                        String sValue
97651>>>                        Get psUserID of ghoSQLConnectionHandler to sValue
97652>>>                        Set Value to sValue
97653>>>                    End_Procedure
97654>>>
97654>>>                End_Object
97655>>>
97655>>>                Object oPassword_fm is a Form
97657>>>                    Set Size to 12 91
97658>>>                    Set Location to 57 222
97659>>>                    Set Label to "Password"
97660>>>                    Set Label_Col_Offset to 2
97661>>>                    Set Label_Justification_Mode to JMode_Right
97662>>>                    // Set psToolTip to "Note: The password form does _not_ have it's password state set to True because the view is for testing purposes only. And we can see the password - if set - from the connection string as well."
97662>>>                    Set psToolTip to "Press the 'Toggle Password' button to reveal the password"
97663>>>                    Set Password_State to True
97664>>>
97664>>>                    Procedure Refresh
97667>>>                        String sValue
97667>>>                        Get psPassword of ghoSQLConnectionHandler to sValue
97668>>>                        Set Value to sValue
97669>>>                    End_Procedure
97670>>>
97670>>>                End_Object
97671>>>
97671>>>                Object oViewPassword_btn is a cRDCButtonDPI
97673>>>                    Set Size to 12 19
97674>>>                    Set Location to 57 317
97675>>>                    Set psToolTip to "Toggle password"
97676>>>                    Set psImage to "ViewPassword1.ico"
97677>>>                    Set piImageMarginLeft to 0
97678>>>
97678>>>                    Procedure OnClick
97681>>>                        Boolean bState
97681>>>                        Get Password_State of oPassword_fm to bState
97682>>>                        Send Page_Object   of oPassword_fm False
97683>>>                        Set Password_State of oPassword_fm to (not(bState))
97684>>>                        Send Page_Object   of oPassword_fm True
97685>>>                    End_Procedure
97686>>>
97686>>>                End_Object
97687>>>
97687>>>                Object oTestLogin_btn is a cRDCButtonDPI
97689>>>                    Set Size to 12 56
97690>>>                    Set Location to 57 340
97691>>>                    Set Label to "Test Login"
97692>>>                    Set peAnchors to anNone
97693>>>                    Set psToolTip to "Changes the connection string with any changes made and tries to login to the server with the connection string."
97694>>>                    Set FontWeight to fw_Bold
97695>>>                    Set psImage to "ActionLogin1.ico"
97696>>>                    Set piImageMarginLeft to 0
97697>>>
97697>>>                    Procedure OnClick
97700>>>                        tSQLConnection SQLConnection
97700>>>                        tSQLConnection SQLConnection
97700>>>                        String sServer sDatabase sDriverID sUserID sPassword sConnectionID sConnectionString
97700>>>                        Boolean bTrusted bLoginSuccessful
97700>>>                        Integer iDriverID
97700>>>                        Handle hoDriver
97700>>>
97700>>>                        Get Value of oDriverID_cf        to SQLConnection.sDriverID
97701>>>                        Get Value of oConnectionID_fm    to SQLConnection.sConnectionID
97702>>>                        Get Value of oServer_fm          to SQLConnection.sServer
97703>>>                        Get Value of oDatabase_fm        to SQLConnection.sDatabase
97704>>>                        Get Checked_State of oTrusted_cb to SQLConnection.bTrusted
97705>>>                        Get Value of oUserID_fm          to SQLConnection.sUserID
97706>>>                        Get Value of oPassword_fm        to SQLConnection.sPassword
97707>>>
97707>>>                        Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
97708>>>
97708>>>                        Get DriverIndex of ghoSQLConnectionHandler SQLConnection.sDriverID to iDriverID
97709>>>                        If (iDriverID = 0) Begin
97711>>>                            Send Info_Box ("The driver" * SQLConnection.sDriverID * "could not be loaded. Is the driver installed? And equally imporant; Is the corresponding database server or client software installed?")
97712>>>                            Procedure_Return
97713>>>                        End
97713>>>>
97713>>>
97713>>>                        Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to True
97716>>>                        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
97717>>>                        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
97718>>>                        Set psDriverID of hoDriver to SQLConnection.sDriverID
97719>>>                        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bLoginSuccessful
97720>>>                        Send Destroy   of hoDriver
97721>>>
97721>>>                        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
97722>>>                        If (LastErr <> CLIERR_LOGIN_UNSUCCESSFUL) Begin
97724>>>                            Move (Replace(("PWD=" + SQLConnection.sPassword), sConnectionString, "PWD=***")) to sConnectionString
97725>>>                            Set Value of oConnectionString_fm to sConnectionString
97726>>>                            Send Info_Box "Login Successful!"
97727>>>                        End
97727>>>>
97727>>>                        Else Begin
97728>>>                            Send Info_Box "Nope, that didn't work. Login failed."
97729>>>                        End
97729>>>>
97729>>>                        Broadcast Recursive Send Combo_Fill_List of (Client_Id(phoMainPanel(ghoApplication)))
97731>>>                        Move 0 to LastErr
97732>>>                    End_Procedure
97733>>>
97733>>>                End_Object
97734>>>
97734>>>                Object oConnectionString_fm is a Form
97736>>>                    Set Size to 12 328
97737>>>                    Set Location to 82 68
97738>>>                    Set Label to "Connection String"    
97739>>>                    Set Label_Col_Offset to 2
97740>>>                    Set Label_Justification_Mode to JMode_Right
97741>>>                    Set peAnchors to anTopLeftRight
97742>>>                    Set Enabled_State to False
97743>>>
97743>>>                    Procedure Refresh
97746>>>                        String sValue
97746>>>                        tSQLConnection SQLConnection
97746>>>                        tSQLConnection SQLConnection
97746>>>
97746>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97747>>>                        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
97748>>>                        Set Value to sValue
97749>>>                    End_Procedure
97750>>>
97750>>>                End_Object
97751>>>
97751>>>                Object oInfo_tb is a TextBox
97753>>>                    Set Auto_Size_State to False
97754>>>                    Set Size to 18 303
97755>>>                    Set Location to 106 8
97756>>>                    Set Label to "Note: The above settings was read from the SQLConnections.ini file when the object was created and are properties of the 'ghoSQLConnectionHandler' object."
97757>>>                    Set Justification_Mode to JMode_Left
97758>>>                    Set FontItalics to True
97759>>>                End_Object
97760>>>
97760>>>                Object oRunSQLConnectionsProgram_btn is a cRDCButtonDPI
97762>>>                    Set Size to 21 83
97763>>>                    Set Location to 106 315
97764>>>                    Set Label to "SQL Connections"
97765>>>                    Set peAnchors to anNone
97766>>>                    Set psImage to "SQLConnections1.ico"
97767>>>
97767>>>                    Procedure OnClick 
97770>>>                        Runprogram Background "DUFSQLConnections.exe"
97771>>>                    End_Procedure
97772>>>
97772>>>                End_Object
97773>>>
97773>>>                Object oGetCollation_btn is a Button
97775>>>                    Set Size to 27 91
97776>>>                    Set Location to 154 38
97777>>>                    Set Label to 'Get Database Collation'
97778>>>                
97778>>>                    Procedure OnClick
97781>>>                        String sCollation sDatabase
97781>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase 
97782>>>                        Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary sDatabase False to sCollation 
97783>>>                        Set Value of oGetCollation_fm to sCollation
97784>>>                    End_Procedure
97785>>>                
97785>>>                End_Object
97786>>>
97786>>>                Object oGetCollation_fm is a Form
97788>>>                    Set Size to 12 148
97789>>>                    Set Location to 162 143
97790>>>                    Set Label to "Current SQL Collation Name"
97791>>>                    Set Label_Col_Offset to 0
97792>>>                    Set Label_Row_Offset to 1
97793>>>                    Set Label_Justification_Mode to JMode_Top
97794>>>                End_Object
97795>>>        
97795>>>                Object oSetCollation_btn is a Button
97797>>>                    Set Size to 27 91
97798>>>                    Set Location to 188 38
97799>>>                    Set Label to "Set Database Collation"
97800>>>                
97800>>>                    Procedure OnClick
97803>>>                        String sCollation sDatabase sErrorText
97803>>>                        Boolean bOK
97803>>>                        Integer iRetval  
97803>>>                        tSqlErrorArray aSqlErrorArray
97803>>>                        tSqlErrorArray aSqlErrorArray
97803>>>                        
97803>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase  
97804>>>                        Get Value of oSetCollation_fm to sCollation
97805>>>                        Get YesNo_Box ("This will permanently change SQL collation for the selected database:" * String(sDatabase) * "Are you sure you want to do this?") to iRetval
97806>>>                        If (iRetval <> MBR_Yes) Begin
97808>>>                            Procedure_Return
97809>>>                        End
97809>>>>
97809>>>                        Get SqlDatabaseCollationChange of ghoDbUpdateFunctionLibrary sDatabase sCollation to bOK
97810>>>                        If (bOK = True) Begin
97812>>>                            Send Info_Box ("Changing the collation for database:" * String(sDatabase) * "was successful.")
97813>>>                        End
97813>>>>
97813>>>                        Else Begin                   
97814>>>                            Get paSqlErrorArray of ghoDbUpdateFunctionLibrary to aSqlErrorArray
97815>>>                            Move ("Embedded SQL Statement:" * String(aSqlErrorArray.sSqlStatementArray[0])) to sErrorText
97816>>>                            Move (sErrorText + "\n")                  to sErrorText
97817>>>                            Move (sErrorText + "\n" + "SQL Error:" * String(aSqlErrorArray.sSqlErrorArray[0])) to sErrorText
97818>>>                            Send Info_Box ("Changing the collation for database:" * String(sDatabase) * "failed." + "\n" + sErrorText)
97819>>>                        End
97819>>>>
97819>>>
97819>>>                    End_Procedure
97820>>>                
97820>>>                End_Object
97821>>>
97821>>>                Object oSetCollation_fm is a Form
97823>>>                    Set Size to 12 148
97824>>>                    Set Location to 197 143
97825>>>                    Set Label to "New SQL Collation Name"
97826>>>                    Set Label_Col_Offset to 0
97827>>>                    Set Label_Row_Offset to 1
97828>>>                    Set Label_Justification_Mode to JMode_Top
97829>>>                End_Object
97830>>>
97830>>>                Procedure Page Integer iPageObject
97833>>>                    Broadcast Recursive Send Refresh of (phoMainPanel(ghoApplication))
97835>>>                    Forward Send Page iPageObject
97837>>>                End_Procedure
97838>>>
97838>>>            End_Object
97839>>>
97839>>>        End_Object
97840>>>        
97840>>>    End_Object
97841>>>
97841>>>End_Object
97842>        Use SQLFunctions.vw
Including file: SQLFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLFunctions.vw)
97842>>>Use Windows.pkg
97842>>>Use DFClient.pkg
97842>>>Use Dfspnfrm.pkg
97842>>>Use cDbScrollingContainer.pkg
97842>>>Use cRDCButtonDPI.pkg
97842>>>Use cDbUpdateFunctionLibrary.pkg
97842>>>Use SQLDatabaseBackup.dg
97842>>>
97842>>>Activate_View Activate_oSQLFunctions_vw for oSQLFunctions_vw
97852>>>>
97852>>>Object oSQLFunctions_vw is a dbView
97854>>>    Set Border_Style to Border_Thick
97855>>>    Set Size to 260 426
97856>>>    Set Location to -4 2
97857>>>    Set Label to "Functions"
97858>>>    Set pbAutoActivate to True
97859>>>    Set Icon to "Sql1.ico"
97860>>>
97860>>>    Procedure OnSetFocus
97863>>>        String sValue
97863>>>        tSQLConnection SQLConnection
97863>>>        tSQLConnection SQLConnection
97863>>>
97863>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97864>>>        Set Value of oSQLDatabase_fm to SQLConnection.sDatabase
97865>>>        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
97866>>>        Set Value of oSQLConnectionString_fm to sValue
97867>>>    End_Procedure
97868>>>
97868>>>    Object oScrollingContainer1 is a cDbScrollingContainer
97870>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
97872>>>
97872>>>            Object oSQLFunctionTests_grp is a Group
97874>>>                Set Size to 243 402
97875>>>                Set Location to 7 12
97876>>>                Set Label to "Tests: Change SQL Database with Specialized SQL Functions"
97877>>>                Set peAnchors to anAll
97878>>>
97878>>>                Object oSQLConnectionString_fm is a Form
97880>>>                    Set Size to 12 375
97881>>>                    Set Location to 23 14
97882>>>                    Set Label to "Current Connection String Settings:"
97883>>>                    Set Label_Col_Offset to 0
97884>>>                    Set Label_Justification_Mode to JMode_Top
97885>>>                    Set peAnchors to anTopLeftRight
97886>>>                    Set Enabled_State to False
97887>>>                    Set Label_Row_Offset to 1
97888>>>                End_Object
97889>>>
97889>>>                Object oSQLDatabase_fm is a Form
97891>>>                    Set Size to 12 86
97892>>>                    Set Location to 50 14
97893>>>                    Set Label to "Database:"
97894>>>                    Set Label_Col_Offset to 0
97895>>>                    Set Label_Justification_Mode to JMode_Top
97896>>>                    Set Label_Row_Offset to 1
97897>>>                    Set FontWeight to fw_Bold
97898>>>                    Set Enabled_State to False
97899>>>                End_Object
97900>>>
97900>>>                Object oDriverID2_cf is a ComboForm
97902>>>                    Set Size to 12 91
97903>>>                    Set Location to 50 121
97904>>>                    Set Label_Col_Offset to 0
97905>>>                    Set Label_Justification_Mode to JMode_Top
97906>>>                    Set Label to "Driver ID:"
97907>>>                    Set Entry_State to False
97908>>>                    Set Enabled_State to False
97909>>>                    Set Label_Row_Offset to 1
97910>>>
97910>>>                    Procedure Combo_Fill_List
97913>>>                        Send Combo_Add_Item MSSQLDRV_ID
97914>>>                        Send Combo_Add_Item DB2_DRV_ID
97915>>>                        Send Combo_Add_Item ODBC_DRV_ID
97916>>>                    End_Procedure
97917>>>
97917>>>                    Procedure Refresh
97920>>>                        String sValue
97920>>>
97920>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
97921>>>                        Set Value to sValue
97922>>>                    End_Procedure
97923>>>
97923>>>                End_Object
97924>>>
97924>>>                Object oBackupSQLDatabase_btn is a cRDCButtonDPI
97926>>>                    Set Size to 12 109
97927>>>                    Set Location to 50 220
97928>>>                    Set Label to "Backup MS-SQL Database"
97929>>>                    Set psImage to "DbBackup1.ico"
97930>>>
97930>>>                    Procedure OnClick
97933>>>                        Boolean bOK
97933>>>
97933>>>                        // SQLDatabaseBackup dialog:
97933>>>                        Get MakeSQLDatabaseBackup to bOK
97934>>>
97934>>>                        If (bOK = True) Begin
97936>>>                            Send Info_Box "The backup of the database was successful!"
97937>>>                        End
97937>>>>
97937>>>                        Else Begin
97938>>>                            Send Info_Box "The database was not backup up"
97939>>>                        End
97939>>>>
97939>>>                    End_Procedure
97940>>>
97940>>>                End_Object
97941>>>
97941>>>                Object oDatabaseInfo_tb is a TextBox
97943>>>                    Set Auto_Size_State to False
97944>>>                    Set Size to 25 96
97945>>>                    Set Location to 64 14
97946>>>                    Set Label to "(Change database on the SQL Connections tabpage)"
97947>>>                    Set Justification_Mode to JMode_Left
97948>>>                End_Object
97949>>>
97949>>>                Object oSQLInfo_tb is a TextBox
97951>>>                    Set Auto_Size_State to False
97952>>>                    Set Size to 37 270
97953>>>                    Set Location to 76 118
97954>>>                    Set Label to "Note: The DataFlex database API is NOT used here. Instead all is done with specialized embedded SQL (ESQL) funtions from the cDbUpdateFunctionLibrary. This is because an API 'Structure_End' command could drop and rebuild the whole table (!). That can take a long time..."
97955>>>                    Set Justification_Mode to JMode_Left
97956>>>                End_Object
97957>>>
97957>>>                Object oSQLTableName_cf is a ComboForm
97959>>>                    Set Size to 12 96
97960>>>                    Set Location to 106 14
97961>>>                    Set Label_Col_Offset to 0
97962>>>                    Set Label_Justification_Mode to JMode_Top
97963>>>                    Set Label to "Select Table:"
97964>>>                    Set Label_Row_Offset to 1
97965>>>                    Set Entry_State to False
97966>>>
97966>>>                    Procedure OnDropDown
97969>>>                        Send DoCombo_Fill_List
97970>>>                    End_Procedure
97971>>>
97971>>>                    Procedure OnCloseUp
97974>>>                        Send Delete_Data of oSQLColumnName_cf
97975>>>                    End_Procedure
97976>>>
97976>>>                    Procedure DoCombo_Fill_List
97979>>>                        String[] sTablesArray
97980>>>                        String sDriverID
97980>>>                        Integer iCount iSize
97980>>>
97980>>>                        Send Delete_Data
97981>>>                        Get Value of oDriverID2_cf to sDriverID
97982>>>                        Get _SqlUtilEnumerateTables of ghoDbUpdateFunctionLibrary sDriverID to sTablesArray
97983>>>                        Move (SizeOfArray(sTablesArray)) to iSize
97984>>>                        Decrement iSize
97985>>>                        For iCount from 0 to iSize
97991>>>>
97991>>>                            Send Combo_Add_Item sTablesArray[iCount]
97992>>>                        Loop
97993>>>>
97993>>>                    End_Procedure
97994>>>
97994>>>                    // DataFlex bug. It has been here as long as I can remember and _never_ seems to be fixed :-(
97994>>>                    // Augmented Value function.
97994>>>                    // We need to use Wincombo_x messages. Probably due to sync reasons.
97994>>>                    // When e.g. OnCloseUp is fired the data_value still holds the old value.
97994>>>                    Function Value Integer iItem Returns String
97997>>>                        String sValue
97997>>>                        Get WinCombo_Current_Item to iItem
97998>>>                        Get WinCombo_Value iItem  to sValue
97999>>>                        Function_Return sValue
98000>>>                    End_Function
98001>>>
98001>>>                End_Object
98002>>>
98002>>>                Object oSQLColumnName_cf is a ComboForm
98004>>>                    Set Size to 12 96
98005>>>                    Set Location to 134 14
98006>>>                    Set Label_Col_Offset to 0
98007>>>                    Set Label_Justification_Mode to JMode_Top
98008>>>                    Set Label to "Select Column:"
98009>>>                    Set Label_Row_Offset to 1
98010>>>                    Set Entry_State to False
98011>>>
98011>>>                    Procedure DoCombo_Fill_List
98014>>>                        String[] sColumnsArray
98015>>>                        String sTableName sDriverID
98015>>>                        Integer iCount iSize
98015>>>
98015>>>                        Send Delete_Data
98016>>>                        Get Value of oDriverID2_cf    to sDriverID
98017>>>                        Get Value of oSQLTableName_cf to sTableName
98018>>>                        Get _SqlUtilEnumerateColumns of ghoDbUpdateFunctionLibrary sDriverID sTableName to sColumnsArray
98019>>>                        Move (SizeOfArray(sColumnsArray)) to iSize
98020>>>                        Decrement iSize
98021>>>                        For iCount from 0 to iSize
98027>>>>
98027>>>                            Send Combo_Add_Item sColumnsArray[iCount]
98028>>>                        Loop
98029>>>>
98029>>>                        If (iSize > 1) Begin
98031>>>                            Set Current_Item to 1
98032>>>                        End
98032>>>>
98032>>>                    End_Procedure
98033>>>
98033>>>                    Procedure OnDropDown
98036>>>                        Send DoCombo_Fill_List
98037>>>                    End_Procedure
98038>>>                End_Object
98039>>>
98039>>>                Object oSQLRenameColumnTo_fm is a Form
98041>>>                    Set Size to 12 96
98042>>>                    Set Location to 134 116
98043>>>                    Set Label_Col_Offset to 0
98044>>>                    Set Label_Justification_Mode to JMode_Top
98045>>>                    Set Label to "Rename Column To:"
98046>>>                    Set Label_Row_Offset to 1
98047>>>                    Set Value to "NewColumnName"
98048>>>                End_Object
98049>>>
98049>>>                Object oSQLRenameColumn_btn is a cRDCButtonDPI
98051>>>                    Set Size to 12 69
98052>>>                    Set Location to 134 220
98053>>>                    Set Label to "Rename Column"
98054>>>                    Set psToolTip to "Test of SQLColumnRename function"
98055>>>                    Set MultiLineState to True
98056>>>
98056>>>                    Procedure OnClick
98059>>>                        Boolean bOk
98059>>>                        Handle hTable
98059>>>                        String sTableName sColumnName sNewColumnName sDriverID
98059>>>
98059>>>                        Get Value of oSQLTableName_cf to sTableName
98060>>>                        If (sTableName = "") Begin
98062>>>                            Send Info_Box "You need to select a table first..."
98063>>>                            Procedure_Return
98064>>>                        End
98064>>>>
98064>>>                        Get Value of oSQLColumnName_cf to sColumnName
98065>>>                        If (Uppercase(sColumnName) = "RECNUM" or sColumnName = "") Begin
98067>>>                            Send Info_Box "You need to select a column (and 'RECNUM' cannot be used)"
98068>>>                            Procedure_Return
98069>>>                        End
98069>>>>
98069>>>                        Get Value of oSQLRenameColumnTo_fm to sNewColumnName
98070>>>                        If (Trim(sNewColumnName) = "") Begin
98072>>>                            Send Info_Box "You need to enter a column name to rename to..."
98073>>>                            Procedure_Return
98074>>>                        End
98074>>>>
98074>>>
98074>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98075>>>                        If (hTable = 0) Begin
98077>>>                            Send Info_Box "Sorry, no free fileslot in filelist.cfg could be found. Cannot continue changing table."
98078>>>                            Procedure_Return
98079>>>                        End
98079>>>>
98079>>>
98079>>>                        Get Value of oDriverID2_cf to sDriverID
98080>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98081>>>                        Get SqlColumnRenameByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName sNewColumnName to bOk
98082>>>                        If (bOk = True) Begin
98084>>>                            // Better delete the combo values after a successful rename as it looks odd to show the old column name...
98084>>>                            Send Delete_Data of oSQLColumnName_cf
98085>>>                            Send Info_Box ("Column" * sColumnName + ", was successfully renamed to" * sNewColumnName * "for table:" * sTableName)
98086>>>                        End
98086>>>>
98086>>>                        Else Begin
98087>>>                            Send Info_Box "Nope, that didn't work..."
98088>>>                        End
98088>>>>
98088>>>
98088>>>                    End_Procedure
98089>>>
98089>>>                End_Object
98090>>>
98090>>>                Object oSQLRemoveColumn_btn is a cRDCButtonDPI
98092>>>                    Set Size to 12 91
98093>>>                    Set Location to 134 297
98094>>>                    Set Label to "Drop Column"
98095>>>                    Set psToolTip to "Test of SQLColumnRemove function"
98096>>>                    Set psImage to "DeleteColumn1.ico"
98097>>>
98097>>>                    Procedure OnClick
98100>>>                        Boolean bOk
98100>>>                        String sTableName sColumnName sDriverID
98100>>>                        Integer iRetval
98100>>>
98100>>>                        Get Value of oDriverID2_cf              to sDriverID
98101>>>                        Get Value of oSQLTableName_cf           to sTableName
98102>>>                        Get Value of oSQLColumnName_cf          to sColumnName
98103>>>
98103>>>                        If (sTableName = "" or sColumnName = "") Begin
98105>>>                            Send Info_Box "You first need to select a table and a column."
98106>>>                            Procedure_Return
98107>>>                        End
98107>>>>
98107>>>
98107>>>                        Get YesNo_Box ("This will remove (drop) the column named:" * sColumnName * "from table:" * sTableName + ". Are you sure?") to iRetval
98108>>>                        If (iRetval <> MBR_Yes) Begin
98110>>>                            Procedure_Return
98111>>>                        End
98111>>>>
98111>>>
98111>>>                        Get SqlColumnRemoveByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName to bOk
98112>>>
98112>>>                        If (bOk = True) Begin
98114>>>                            // Better delete the combo values after a successful operation as it looks odd to show the old column name...
98114>>>                            Send Delete_Data of oSQLColumnName_cf
98115>>>                            Send Info_Box ("Column" * sColumnName + ", was successfully removed")
98116>>>                        End
98116>>>>
98116>>>                        Else Begin
98117>>>                            Send Info_Box ("The column could NOT be removed. Either the column" * sColumnName * "doesn't exists or the current Database is incorrect?")
98118>>>                            Procedure_Return
98119>>>                        End
98119>>>>
98119>>>
98119>>>                    End_Procedure
98120>>>
98120>>>                End_Object
98121>>>
98121>>>                Object oSQLAddColumnName_fm is a Form
98123>>>                    Set Size to 12 96
98124>>>                    Set Location to 177 14
98125>>>                    Set Label_Col_Offset to 0
98126>>>                    Set Label_Justification_Mode to JMode_Top
98127>>>                    Set Label to "Column Name:"
98128>>>                    Set Label_Row_Offset to 1
98129>>>                    Set Value to "NewColumn"
98130>>>                End_Object
98131>>>
98131>>>                Object oSQLColumnType_cf is a ComboForm
98133>>>                    Set Size to 12 96
98134>>>                    Set Location to 177 116
98135>>>                    Set Label_Col_Offset to 0
98136>>>                    Set Label_Justification_Mode to JMode_Top
98137>>>                    Set Label_Row_Offset to 1
98138>>>                    Set Label to "Type:"
98139>>>                    Set Entry_State to False
98140>>>
98140>>>                    Procedure Combo_Fill_List
98143>>>                        tColumnType[] ColumnTypeArray
98143>>>                        tColumnType[] ColumnTypeArray
98144>>>                        Integer iSize iCount iDbType
98144>>>                        String sDriverID
98144>>>
98144>>>                        Send Delete_Data
98145>>>                        Get Value of oDriverID2_cf to sDriverID
98146>>>                        Get piDbType of ghoDbUpdateFunctionLibrary to iDbType
98147>>>                        Get _UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary sDriverID iDbType to ColumnTypeArray
98148>>>                        Move (SizeOfArray(ColumnTypeArray)) to iSize
98149>>>                        Decrement iSize
98150>>>                        For iCount from 0 to iSize
98156>>>>
98156>>>                            Send Combo_Add_Item ColumnTypeArray[iCount].sSQLType
98157>>>                        Loop
98158>>>>
98158>>>                        If (iSize > 0) Begin
98160>>>                            Set Value to ColumnTypeArray[0].sSQLType
98161>>>                        End
98161>>>>
98161>>>                    End_Procedure
98162>>>
98162>>>                    Procedure OnChange
98165>>>                        Integer iType iSize iDec
98165>>>                        tSQLConnection SQLConnection
98165>>>                        tSQLConnection SQLConnection
98165>>>                        Boolean bFixed
98165>>>
98165>>>                        Get SelectedType to iType
98166>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98167>>>                        Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to iSize
98168>>>                        Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to iDec
98169>>>                        Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to bFixed
98170>>>
98170>>>                        Set Enabled_State of oSQLLength_sf   to (bFixed = False)
98171>>>                        Set Enabled_State of oSQLDecimals_sf to (bFixed = False)
98172>>>                        Set Value         of oSQLLength_sf   to iSize
98173>>>                        If (iDec = 0) Begin
98175>>>                            Set Value     of oSQLDecimals_sf to ""
98176>>>                        End
98176>>>>
98176>>>                        Else Begin
98177>>>                            Set Value     of oSQLDecimals_sf to iDec
98178>>>                        End
98178>>>>
98178>>>                        If (bFixed = False) Begin
98180>>>                            Set Enabled_State of oSQLDecimals_sf to (iDec <> 0)
98181>>>                        End
98181>>>>
98181>>>                    End_Procedure
98182>>>
98182>>>                    Function SelectedType Returns Integer
98185>>>                        String sValue sDriverID
98185>>>                        Integer iType iDbType
98185>>>
98185>>>                        Get Value to sValue
98186>>>                        Get psDriverID of ghoSQLConnectionHandler to sDriverID
98187>>>                        Get piDbType   of ghoSQLConnectionHandler to iDbType
98188>>>                        Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary sDriverID iDbType sValue to iType
98189>>>
98189>>>                        Function_Return iType
98190>>>                    End_Function
98191>>>
98191>>>                End_Object
98192>>>
98192>>>                Object oSQLAddColumn_btn is a cRDCButtonDPI
98194>>>                    Set Size to 12 69
98195>>>                    Set Location to 177 220
98196>>>                    Set Label to "Add Column"
98197>>>                    Set psToolTip to "Test of SQLColumnAdd function"
98198>>>                    Set psImage to "AddColumn1.ico"
98199>>>
98199>>>                    Procedure OnClick
98202>>>                        Boolean bOk bInitialize
98202>>>                        Handle hTable
98202>>>                        String sTableName sColumnName sType sColumnValue sDriverID
98202>>>                        Integer iType iLength iDecimals
98202>>>
98202>>>                        Get Value of oDriverID2_cf              to sDriverID
98203>>>                        Get Value of oSQLTableName_cf           to sTableName
98204>>>                        Get Value of oSQLAddColumnName_fm       to sColumnName
98205>>>                        Get SelectedType  of oSQLColumnType_cf  to iType
98206>>>                        Get Value         of oSQLColumnType_cf  to sType
98207>>>                        Get Checked_State of oSQLInitializeColumnValue_cb to bInitialize
98208>>>                        Get Value         of oSQLColumnValue_fm to sColumnValue
98209>>>                        Get Value         of oSQLLength_sf      to iLength
98210>>>                        Get Value         of oSQLDecimals_sf    to iDecimals
98211>>>
98211>>>                        If (sTableName <> "") Begin
98213>>>                            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98214>>>                            If (hTable = 0) Begin
98216>>>                                Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98217>>>                            End
98217>>>>
98217>>>                        End
98217>>>>
98217>>>                        If (hTable = 0) Begin
98219>>>                            Send Info_Box "You first need to select a table before you can add a column to it."
98220>>>                            Procedure_Return
98221>>>                        End
98221>>>>
98221>>>                        If (sColumnName = "") Begin
98223>>>                            Send Info_Box "You need to enter a column name"
98224>>>                            Procedure_Return
98225>>>                        End
98225>>>>
98225>>>
98225>>>                        Get SqlColumnAddByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName iType iLength iDecimals bInitialize sColumnValue to bOk
98226>>>
98226>>>                        If (bOk = True) Begin
98228>>>                            Send Info_Box ("New column" * sColumnName * sType * String(iLength) + ", was successfully added to" * sTableName)
98229>>>                        End
98229>>>>
98229>>>                        Else Begin
98230>>>                            Send Info_Box ("The column could NOT be added. Either column" * sColumnName * "already exists or the current Database is incorrect?")
98231>>>                            Procedure_Return
98232>>>                        End
98232>>>>
98232>>>
98232>>>                    End_Procedure
98233>>>
98233>>>                End_Object
98234>>>
98234>>>//                Object oTest_btn is a cRDCButtonDPI
98234>>>//                    Set Size to 13 92
98234>>>//                    Set Location to 177 298
98234>>>//                    Set Label to "Test SQL script button"
98234>>>//
98234>>>//                    Procedure OnClick
98234>>>//                        Boolean bOK
98234>>>//                        String sTableName sColumnName
98234>>>//
98234>>>//                        Get Value of oSQLTableName_cf      to sTableName
98234>>>//                        Get Value of oSQLAddColumnName_fm  to sColumnName
98234>>>////                        Get SqlUtilDefaultConstraintsMSSQL of ghoDbUpdateFunctionLibrary sTableName sColumnName to bOK
98234>>>//
98234>>>//                    End_Procedure
98234>>>//
98234>>>//                End_Object
98234>>>
98234>>>                Object oSQLLength_sf is a SpinForm
98236>>>                    Set Label to "Length:"
98237>>>                    Set Size to 12 40
98238>>>                    Set Location to 202 16
98239>>>                    Set Label_Col_Offset to 0
98240>>>                    Set Label_Justification_Mode to JMode_Top
98241>>>                    Set Label_Row_Offset to 1
98242>>>                    Set Value to "10"
98243>>>                    Set Maximum_Position to 500
98244>>>                    Set Minimum_Position to 1
98245>>>                End_Object
98246>>>
98246>>>                Object oSQLDecimals_sf is a SpinForm
98248>>>                    Set Label to "Decimals:"
98249>>>                    Set Size to 12 33
98250>>>                    Set Location to 202 60
98251>>>                    Set Label_Col_Offset to 0
98252>>>                    Set Label_Justification_Mode to JMode_Top
98253>>>                    Set Label_Row_Offset to 1
98254>>>                    Set Value to "0"
98255>>>                    Set Maximum_Position to 16
98256>>>                    Set Minimum_Position to 1
98257>>>                End_Object
98258>>>
98258>>>                Object oSQLInitializeColumnValue_cb is a CheckBox
98260>>>                    Set Size to 12 85
98261>>>                    Set Location to 202 116
98262>>>                    Set Label to "Initialize Column Value"
98263>>>
98263>>>                    Procedure OnChange
98266>>>                        Boolean bChecked
98266>>>
98266>>>                        Get Checked_State to bChecked
98267>>>                        Set Enabled_State of oSQLColumnValue_fm to bChecked
98268>>>                    End_Procedure
98269>>>
98269>>>                End_Object
98270>>>
98270>>>                Object oSQLColumnValue_fm is a Form
98272>>>                    Set Size to 12 96
98273>>>                    Set Location to 218 116
98274>>>                    Set Label_Col_Offset to 2
98275>>>                    Set Label_Justification_Mode to JMode_Right
98276>>>                    Set Label to "Column Value"
98277>>>                    Set psToolTip to "When a new column is added the new column can be initialized with a value for all existing records."
98278>>>                    Set Enabled_State to False
98279>>>                End_Object
98280>>>
98280>>>                Object oEnumRelations_btn is a cRDCButtonDPI
98282>>>                    Set Size to 12 91
98283>>>                    Set Location to 116 297
98284>>>                    Set Label to "Test Enum SQL Relations"
98285>>>
98285>>>                    Procedure OnClick
98288>>>                        tSQLRelation[] SQLRelationArray
98288>>>                        tSQLRelation[] SQLRelationArray
98289>>>                        String sTableName sDriverID
98289>>>                        Integer iSize iCount
98289>>>
98289>>>                        Get Value of oDriverID2_cf to sDriverID
98290>>>                        Get Value of oSQLTableName_cf to sTableName
98291>>>                        Get _SqlUtilEnumerateRelations of ghoDbUpdateFunctionLibrary sTableName sDriverID to SQLRelationArray
98292>>>                        Move (SizeOfArray(SQLRelationArray)) to iSize
98293>>>                        Decrement iSize
98294>>>                        For iCount from 0 to iSize
98300>>>>
98300>>>                            Showln "Tablename.FieldName = " SQLRelationArray[iCount].sFileName "." SQLRelationArray[iCount].sFieldName " Number: " SQLRelationArray[iCount].iFileNumber "." SQLRelationArray[iCount].iFieldNumber
98309>>>                        Loop
98310>>>>
98310>>>                        If (iSize < 1) Begin
98312>>>                            Send Info_Box ("No SQL Foreign keys found for table:" * sTableName)
98313>>>                        End
98313>>>>
98313>>>
98313>>>                    End_Procedure
98314>>>
98314>>>                End_Object
98315>>>
98315>>>                Object oEnumerateLoggedInUsers is a cRDCButtonDPI
98317>>>                    Set Size to 12 101
98318>>>                    Set Location to 177 297
98319>>>                    Set Label to "Enumerate Logged In Users"
98320>>>
98320>>>                    Procedure OnClick
98323>>>                        tSQLLoggedInUser[] SQLLoggedInUser
98323>>>                        tSQLLoggedInUser[] SQLLoggedInUser
98324>>>                        String sDriverID sDatabase
98324>>>                        Integer iSize iCount
98324>>>
98324>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98325>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase
98326>>>                        Get SqlUtilEnumerateLoggedInUsers of ghoDbUpdateFunctionLibrary sDriverID sDatabase to SQLLoggedInUser
98327>>>                        Move (SizeOfArray(SQLLoggedInUser)) to iSize
98328>>>                        Decrement iSize
98329>>>
98329>>>                        Showln "SQL User Name" " and Program:"
98332>>>                        For iCount from 0 to iSize
98338>>>>
98338>>>                            Showln SQLLoggedInUser[iCount].sUser " " SQLLoggedInUser[iCount].sProgram
98342>>>                        Loop
98343>>>>
98343>>>                    End_Procedure
98344>>>
98344>>>                End_Object
98345>>>
98345>>>                Object oEnumerateTablesAndViews is a cRDCButtonDPI
98347>>>                    Set Size to 12 101
98348>>>                    Set Location to 193 297
98349>>>                    Set Label to "Is Table or View?"
98350>>>
98350>>>                    Procedure OnClick
98353>>>                        String sDriverID sTableName
98353>>>                        Handle hTable
98353>>>                        Boolean bViewTableType
98353>>>
98353>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98354>>>                        Get Value of oSQLTableName_cf to sTableName
98355>>>                        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98356>>>                        If (hTable = 0) Begin
98358>>>                            Procedure_Return
98359>>>                        End
98359>>>>
98359>>>                        Get SQLUtilTableIsViewType of ghoDbUpdateFunctionLibrary sDriverID hTable to bViewTableType
98360>>>                        Send Info_Box ("The table" * sTableName * "is a" * If(bViewTableType = True, "View Table Type", "Standard Table (not view)"))
98361>>>                    End_Procedure
98362>>>
98362>>>                End_Object
98363>>>
98363>>>            End_Object
98364>>>
98364>>>        End_Object
98365>>>
98365>>>    End_Object
98366>>>
98366>>>End_Object
98367>        Use APIFunctions.vw
Including file: APIFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\APIFunctions.vw)
98367>>>Use Windows.pkg
98367>>>Use DFClient.pkg
98367>>>Use Dfspnfrm.pkg
98367>>>Use Dfline.pkg
98367>>>Use cDbScrollingContainer.pkg
98367>>>Use cRDCButtonDPI.pkg
98367>>>Use cDbUpdateFunctionLibrary.pkg
98367>>>
98367>>>Define CI_Table1_FileNo for 401
98367>>>Define CI_View1_FileNo  for 402
98367>>>
98367>>>Activate_View Activate_oAPIFunctions_vw for oAPIFunctions_vw
98377>>>>
98377>>>Object oAPIFunctions_vw is a dbView
98379>>>    Set Border_Style to Border_Thick
98380>>>    Set Size to 237 424
98381>>>    Set Location to 17 2
98382>>>    Set Label to "API Functions"
98383>>>    Set pbAutoActivate to True
98384>>>    Set Icon to "APIFunctions1.ico"
98385>>>
98385>>>    Property String psTableName ""
98387>>>
98387>>>    Procedure OnSetFocus
98390>>>        String sValue
98390>>>        tSQLConnection SQLConnection
98390>>>        tSQLConnection SQLConnection
98390>>>
98390>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98391>>>        Set Value of oApiDatabase_fm to SQLConnection.sDatabase
98392>>>        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
98393>>>        Set Value of oApiConnectionString_fm to sValue
98394>>>    End_Procedure
98395>>>
98395>>>    Object oScrollingContainer1 is a cDbScrollingContainer
98397>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
98399>>>
98399>>>            Object oApiFunctions_grp is a Group
98401>>>                Set Size to 222 402
98402>>>                Set Location to 6 12
98403>>>                Set Label to "Tests: Change MS-SQL Database with Database API Functions"
98404>>>                Set peAnchors to anAll
98405>>>
98405>>>                Object oApiConnectionString_fm is a Form
98407>>>                    Set Size to 12 368
98408>>>                    Set Location to 23 14
98409>>>                    Set Label to "Current Connection String Settings:"
98410>>>                    Set Label_Col_Offset to 0
98411>>>                    Set Label_Justification_Mode to JMode_Top
98412>>>                    Set peAnchors to anTopLeftRight
98413>>>                    Set Enabled_State to False
98414>>>                    Set Label_Row_Offset to 1
98415>>>                End_Object
98416>>>
98416>>>                Object oApiDatabase_fm is a Form
98418>>>                    Set Size to 12 86
98419>>>                    Set Location to 50 14
98420>>>                    Set Label to "Database:"
98421>>>                    Set Label_Col_Offset to 0
98422>>>                    Set Label_Justification_Mode to JMode_Top
98423>>>                    Set Label_Row_Offset to 1
98424>>>                    Set Enabled_State to False
98425>>>                    Set FontWeight to fw_Bold
98426>>>//                    Set Label_FontWeight to fw_Bold
98426>>>
98426>>>                    Procedure Page Integer iPageObject
98429>>>                        String sValue
98429>>>                        Get psDatabase of ghoSQLConnectionHandler to sValue
98430>>>                        Set Value to sValue
98431>>>
98431>>>                        Forward Send Page iPageObject
98433>>>                    End_Procedure
98434>>>
98434>>>                End_Object
98435>>>
98435>>>                Object oDriverID3_cf is a ComboForm
98437>>>                    Set Size to 12 91
98438>>>                    Set Location to 51 121
98439>>>                    Set Label_Col_Offset to 0
98440>>>                    Set Label_Justification_Mode to JMode_Top
98441>>>                    Set Label to "Driver ID:"
98442>>>                    Set Entry_State to False
98443>>>                    Set Enabled_State to False
98444>>>                    Set Label_Row_Offset to 1
98445>>>                    Set Enabled_State to False
98446>>>
98446>>>                    Procedure Combo_Fill_List
98449>>>                        Send Combo_Add_Item MSSQLDRV_ID
98450>>>                        Send Combo_Add_Item DB2_DRV_ID
98451>>>                        Send Combo_Add_Item ODBC_DRV_ID
98452>>>                    End_Procedure
98453>>>
98453>>>                    Procedure Refresh
98456>>>                        String sValue
98456>>>
98456>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
98457>>>                        Set Value to sValue
98458>>>                    End_Procedure
98459>>>
98459>>>                End_Object
98460>>>
98460>>>                Object oDatabaseInfo_tb is a TextBox
98462>>>                    Set Auto_Size_State to False
98463>>>                    Set Size to 25 96
98464>>>                    Set Location to 64 14
98465>>>                    Set Label to "(Change database on the SQL Connections tabpage)"
98466>>>                    Set Justification_Mode to JMode_Left
98467>>>                End_Object
98468>>>
98468>>>                Object oApiTableName_fm is a Form
98470>>>                    Set Size to 12 77
98471>>>                    Set Location to 114 14
98472>>>                    Set Label_Col_Offset to 0
98473>>>                    Set Label_Justification_Mode to JMode_Top
98474>>>                    Set Label to "Table Name:"
98475>>>                    Set Label_Row_Offset to 1
98476>>>                    Set Value to "NewTable"
98477>>>                    Procedure OnChange
98480>>>                        String sValue
98480>>>                        Get Value to sValue
98481>>>                        Set psTableName to sValue
98482>>>                    End_Procedure
98483>>>                    Send OnChange
98484>>>                End_Object
98485>>>
98485>>>                Object oApiAddNewTable_btn is a cRDCButtonDPI
98487>>>                    Set Size to 12 69
98488>>>                    Set Location to 114 271
98489>>>                    Set Label to "Add Table"
98490>>>                    Set psImage to "ActionAddTable1.ico"
98491>>>
98491>>>                    Procedure OnClick
98494>>>                        Boolean bOk
98494>>>                        Handle hTable
98494>>>                        String sTableName sDriverID
98494>>>
98494>>>                        Get Value of oDriverID3_cf to sDriverID
98495>>>                        Get Value of oApiTableName_fm to sTableName
98496>>>                        Move (Trim(sTableName)) to sTableName
98497>>>                        If (sTableName = "") Begin
98499>>>                            Send Info_Box "You first need to enter a table name."
98500>>>                            Procedure_Return
98501>>>                        End
98501>>>>
98501>>>
98501>>>                        Send Cursor_Wait of Cursor_Control
98502>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98503>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98504>>>                        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True to bOk
98505>>>                        If (bOk = True) Begin
98507>>>                            Send Info_Box ("Test table" * sTableName * "was successfully created and put in filelist slot:" * String(hTable))
98508>>>                        End
98508>>>>
98508>>>                        Else Begin
98509>>>                            Send Cursor_Ready of Cursor_Control
98510>>>                            Send Info_Box ("Nope, the test table" * sTableName * "could not be created, or does it already exist?") "Error"
98511>>>                            Procedure_Return
98512>>>                        End
98512>>>>
98512>>>
98512>>>                    End_Procedure
98513>>>
98513>>>                End_Object
98514>>>
98514>>>                Object oApiAddColumn_fm is a Form
98516>>>                    Set Size to 12 77
98517>>>                    Set Location to 141 14
98518>>>                    Set Label_Col_Offset to 0
98519>>>                    Set Label_Justification_Mode to JMode_Top
98520>>>                    Set Label to "Column Name:"
98521>>>                    Set Label_Row_Offset to 1
98522>>>                    Set Value to "NewColumn"
98523>>>                End_Object
98524>>>
98524>>>                Object oApiColumnType_cf is a ComboForm
98526>>>                    Set Size to 12 85
98527>>>                    Set Location to 141 96
98528>>>                    Set Label_Col_Offset to 0
98529>>>                    Set Label_Justification_Mode to JMode_Top
98530>>>                    Set Label_Row_Offset to 1
98531>>>                    Set Label to "Type:"
98532>>>                    Set Entry_State to False
98533>>>
98533>>>                    Procedure Combo_Fill_List
98536>>>                        tColumnType[] ColumnTypeArray
98536>>>                        tColumnType[] ColumnTypeArray
98537>>>                        Integer iSize iCount
98537>>>
98537>>>                        Send Delete_Data
98538>>>                        Get _UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex to ColumnTypeArray
98539>>>                        Move (SizeOfArray(ColumnTypeArray)) to iSize
98540>>>                        Decrement iSize
98541>>>                        For iCount from 0 to iSize
98547>>>>
98547>>>                            Send Combo_Add_Item ColumnTypeArray[iCount].sSQLType
98548>>>                        Loop
98549>>>>
98549>>>                        Set Value to ColumnTypeArray[0].sSQLType
98550>>>                    End_Procedure
98551>>>
98551>>>                    Procedure OnChange
98554>>>                        Integer iType iSize iDec
98554>>>                        tSQLConnection SQLConnection
98554>>>                        tSQLConnection SQLConnection
98554>>>                        Boolean bFixed
98554>>>
98554>>>                        Get SelectedType to iType
98555>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98556>>>                        Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to iSize
98557>>>                        Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to iDec
98558>>>                        Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to bFixed
98559>>>
98559>>>                        Set Enabled_State of oApiLength_sf   to (bFixed = False)
98560>>>                        Set Enabled_State of oApiDecimals_sf to (bFixed = False)
98561>>>                        Set Value         of oApiLength_sf   to iSize
98562>>>                        If (iDec = 0) Begin
98564>>>                            Set Value     of oApiDecimals_sf to ""
98565>>>                        End
98565>>>>
98565>>>                        Else Begin
98566>>>                            Set Value     of oApiDecimals_sf to iDec
98567>>>                        End
98567>>>>
98567>>>                        If (bFixed = False) Begin
98569>>>                            Set Enabled_State of oApiDecimals_sf to (iDec <> 0)
98570>>>                        End
98570>>>>
98570>>>                    End_Procedure
98571>>>
98571>>>                    Function SelectedType Returns Integer
98574>>>                        String sValue
98574>>>                        Integer iType
98574>>>
98574>>>                        Get Value to sValue
98575>>>                        Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex sValue to iType
98576>>>
98576>>>                        Function_Return iType
98577>>>                    End_Function
98578>>>
98578>>>                End_Object
98579>>>
98579>>>                Object oApiLength_sf is a SpinForm
98581>>>                    Set Label to "Length:"
98582>>>                    Set Size to 12 35
98583>>>                    Set Location to 141 186
98584>>>                    Set Label_Col_Offset to 0
98585>>>                    Set Label_Justification_Mode to JMode_Top
98586>>>                    Set Label_Row_Offset to 1
98587>>>                    Set Value to "10"
98588>>>                    Set Maximum_Position to 500
98589>>>                    Set Minimum_Position to 1
98590>>>                End_Object
98591>>>
98591>>>                Object oApiDecimals_sf is a SpinForm
98593>>>                    Set Label to "Decimals:"
98594>>>                    Set Size to 12 33
98595>>>                    Set Location to 141 225
98596>>>                    Set Label_Col_Offset to 0
98597>>>                    Set Label_Justification_Mode to JMode_Top
98598>>>                    Set Label_Row_Offset to 1
98599>>>                    Set Value to "0"
98600>>>                    Set Maximum_Position to 16
98601>>>                    Set Minimum_Position to 1
98602>>>                End_Object
98603>>>
98603>>>                Object oApiAddColumn_btn is a cRDCButtonDPI
98605>>>                    Set Size to 12 69
98606>>>                    Set Location to 141 271
98607>>>                    Set Label to "Add Column"
98608>>>                    Set psToolTip to "ApiColumnAdd function"
98609>>>                    Set psImage to "ActionAddColumn1.ico"
98610>>>
98610>>>                    Procedure OnClick
98613>>>                        Boolean bOk
98613>>>                        Handle hTable
98613>>>                        String sTableName sColumnName sType sDriverID
98613>>>                        Integer iType iLength iDecimals
98613>>>
98613>>>                        Get Value of oDriverID3_cf            to sDriverID
98614>>>                        Get Value of oApiTableName_fm         to sTableName
98615>>>                        Get Value of oApiAddColumn_fm         to sColumnName
98616>>>                        Get SelectedType of oApiColumnType_cf to iType
98617>>>                        Get Value        of oApiLength_sf     to iLength
98618>>>                        Get Value        of oApiDecimals_sf   to iDecimals
98619>>>
98619>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98620>>>                        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98621>>>                        If (hTable = 0) Begin
98623>>>                            Send Info_Box "You first need to create the new table by pressing the 'Create New Table...' button, before you can add a column to it."
98624>>>                            Procedure_Return
98625>>>                        End
98625>>>>
98625>>>                        If (sColumnName = "") Begin
98627>>>                            Send Info_Box "You need to enter a column name"
98628>>>                            Procedure_Return
98629>>>                        End
98629>>>>
98629>>>
98629>>>                        Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable sColumnName iType iLength iDecimals to bOk
98630>>>                        If (bOk = True) Begin
98632>>>                            Send Info_Box ("Column" * sColumnName * sType * String(iLength) + ", was successfully added to" * sTableName * "(at filelist slot:" * String(hTable) + ")")
98633>>>                        End
98633>>>>
98633>>>                        Else Begin
98634>>>                            Send Info_Box ("The column could NOT be added. Either column" * sColumnName * "already exists or the current Database is incorrect?")
98635>>>                            Procedure_Return
98636>>>                        End
98636>>>>
98636>>>
98636>>>                    End_Procedure
98637>>>
98637>>>                End_Object
98638>>>
98638>>>                Object oApiAddTableAndColumns_btn is a cRDCButtonDPI
98640>>>                    Set Size to 26 77
98641>>>                    Set Location to 184 14
98642>>>                    Set Label to "Create 'New' Table with Three Columns"
98643>>>                    Set MultiLineState to True
98644>>>                    Set psImage to "ActionAddTable1.ico"
98645>>>
98645>>>                    Procedure OnClick
98648>>>                        Boolean bOk
98648>>>                        Handle hTable
98648>>>                        String sTableName sDriverID
98648>>>
98648>>>                        Get Value of oDriverID3_cf to sDriverID
98649>>>                        Get Value of oApiTableName_fm to sTableName
98650>>>                        Move (Trim(sTableName)) to sTableName
98651>>>                        If (sTableName = "") Begin
98653>>>                            Send Info_Box "You first need to enter a table name."
98654>>>                            Procedure_Return
98655>>>                        End
98655>>>>
98655>>>
98655>>>                        Send Cursor_Wait of Cursor_Control
98656>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98657>>>
98657>>>                        Set psDriverID       of ghoDbUpdateFunctionLibrary to sDriverID
98658>>>                        Get ApiTableCreate   of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True to bOk
98659>>>                        If (bOk = True) Begin
98661>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col1Ascii"   DF_ASCII 10 0 to bOk
98662>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col2Date"    DF_DATE   6 0 to bOk
98663>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col3Numeric" DF_BCD    6 2 to bOk
98664>>>                        End
98664>>>>
98664>>>                        Send Cursor_Ready of Cursor_Control
98665>>>
98665>>>                        If (bOk = True) Begin
98667>>>                            Send Info_Box ("Test table" * sTableName * "with Columns: 'Col1 ASCII 10', 'Col2 Date' and 'Col3 Numeric 6,2' was successfully created and put in filelist slot:" * String(CI_Table1_FileNo))
98668>>>                        End
98668>>>>
98668>>>                        Else Begin
98669>>>                            Send Cursor_Ready of Cursor_Control
98670>>>                            Send Info_Box ("Nope, the test table" * sTableName * "could not be created") "Error"
98671>>>                            Procedure_Return
98672>>>                        End
98672>>>>
98672>>>
98672>>>                    End_Procedure
98673>>>
98673>>>                End_Object
98674>>>
98674>>>                Object oApiRemoveTable_btn is a cRDCButtonDPI
98676>>>                    Set Size to 26 77
98677>>>                    Set Location to 184 96
98678>>>                    Set Label to "Remove 'New' Table"
98679>>>                    Set psImage to "ActionDeleteTable1.ico"
98680>>>                    Set MultiLineState to True
98681>>>
98681>>>                    Procedure OnClick
98684>>>                        Boolean bOk
98684>>>                        Integer iRetval
98684>>>                        Handle hTable
98684>>>                        String sTableName sDriverID
98684>>>
98684>>>                        Get Value of oDriverID3_cf to sDriverID
98685>>>                        Get Value of oApiTableName_fm to sTableName
98686>>>                        Get YesNo_Box ("Are you sure you want to PERMANENTLY DELETE the table named:" * String(sTableName) + "?") to iRetval
98687>>>                        If (iRetval = MBR_Yes) Begin
98689>>>                            Send Cursor_Wait of Cursor_Control
98690>>>                            Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98691>>>                            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98692>>>                            Get ApiTableRemove of ghoDbUpdateFunctionLibrary hTable to bOk
98693>>>                            Send Cursor_Ready of Cursor_Control
98694>>>                            If (bOk = True) Begin
98696>>>                                Send Info_Box "Table removed"
98697>>>                            End
98697>>>>
98697>>>                            Else Begin
98698>>>                                Send Info_Box "Nope, that didnt' work. Either the table doesn't exist or your rights aren't sufficient."
98699>>>                            End
98699>>>>
98699>>>                        End
98699>>>>
98699>>>                    End_Procedure
98700>>>
98700>>>                End_Object
98701>>>
98701>>>                Object oLineControl1 is a LineControl
98703>>>                    Set Size to 2 387
98704>>>                    Set Location to 96 6
98705>>>                    Set peAnchors to anTopLeftRight
98706>>>                End_Object
98707>>>
98707>>>                Object oLineControl2 is a LineControl
98709>>>                    Set Size to 3 248
98710>>>                    Set Location to 171 9
98711>>>                End_Object
98712>>>
98712>>>                Object oTestError_fm is a Form
98714>>>                    Set Size to 13 64
98715>>>                    Set Location to 186 180
98716>>>                    Set Form_Datatype to 0 
98717>>>                    On_Key kEnter send KeyAction of oFindErrorText_Btn
98718>>>                End_Object
98719>>>
98719>>>Register_Function FetchErrorDescription Integer iError Returns String
98719>>>                Object oFindErrorText_Btn is a Button
98721>>>                    Set Size to 13 70
98722>>>                    Set Location to 186 248
98723>>>                    Set Label to "Find Error Text"
98724>>>                
98724>>>                    Procedure OnClick
98727>>>                        String sRetval
98727>>>                        Integer iError 
98727>>>                        Handle hoLogFile
98727>>>                        
98727>>>                        Get phoLogFile of ghoDbUpdateFunctionLibrary to hoLogFile
98728>>>                        Get Value of oTestError_fm to iError
98729>>>                        Get FetchErrorDescription of hoLogFile iError to sRetval 
98730>>>                        Set Value of oErrorText_fm to sRetval    
98731>>>                    End_Procedure
98732>>>                
98732>>>                End_Object
98733>>>
98733>>>                Object oErrorText_fm is a Form
98735>>>                    Set Size to 13 213
98736>>>                    Set Location to 202 180
98737>>>                End_Object
98738>>>
98738>>>            End_Object
98739>>>
98739>>>        End_Object
98740>>>
98740>>>    End_Object
98741>>>
98741>>>End_Object
98742>        Use UtilFunctions.vw
Including file: UtilFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\UtilFunctions.vw)
98742>>>
98742>>>Use Windows.pkg
98742>>>Use DFClient.pkg
98742>>>Use Dfline.pkg
98742>>>Use cDbScrollingContainer.pkg
98742>>>Use cRDCButtonDPI.pkg
98742>>>Use cDbUpdateFunctionLibrary.pkg
98742>>>Use Dftreevw.pkg
98742>>>Use Working.pkg
Including file: Working.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Working.pkg)
98742>>>>>// COPYRIGHT (c) 2003-2017 RDC Tools International
98742>>>>>//
98742>>>>>// This program is free software; you can redistribute it and/or
98742>>>>>// modify it under the terms of the GNU General Public License
98742>>>>>// as published by the Free Software Foundation; version 2
98742>>>>>// of the License.
98742>>>>>
98742>>>>>// This program is distributed in the hope that it will be useful,
98742>>>>>// but WITHOUT ANY WARRANTY; without even the implied warranty of
98742>>>>>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
98742>>>>>// GNU General Public License for more details.
98742>>>>>
98742>>>>>// You should have received a copy of the GNU General Public License
98742>>>>>// along with this program; (See the GPL.txt file in the Help directory) if not, write to the Free Software
98742>>>>>// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
98742>>>>>Use Windows.pkg
98742>>>>>
98742>>>>>Object oWorkingMessagePanel is a ToolPanel
98744>>>>>    Set Label    to "Working"
98745>>>>>    Set Size to 48 150
98746>>>>>    Set Locate_Mode to CENTER_ON_PARENT
98747>>>>>    Set Popup_State to True
98748>>>>>
98748>>>>>    Object oWorkingMessage is a Textbox
98750>>>>>        Set Label to "Working message..."
98751>>>>>        Set Location to 15 5
98752>>>>>        Set Size to 27 123
98753>>>>>        Set Auto_Size_State to False
98754>>>>>        Set Justification_Mode to JMode_Center
98755>>>>>        Set FontWeight to fw_Bold
98756>>>>>    End_Object
98757>>>>>
98757>>>>>End_Object
98758>>>>>
98758>>>>>Procedure StartWorkingMessage Global String sText
98760>>>>>    Send Close_Panel of (oWorkingMessagePanel(Self))
98761>>>>>    Set Label  of (oWorkingMessage(oWorkingMessagePanel(Self))) to sText
98762>>>>>    Send Popup of (oWorkingMessagePanel(Self))
98763>>>>>End_Procedure
98764>>>>>
98764>>>>>Procedure StopWorkingMessage Global
98766>>>>>    Send Close_Panel of (oWorkingMessagePanel(Self))
98767>>>>>End_Procedure
98768>>>Use DUFStatusPanel.pkg
98768>>>Use cCharTranslate.pkg
98768>>>
98768>>>Struct tFilelistDUF
98768>>>    Integer iFileNumber
98768>>>    String sLogicalName
98768>>>    String sRootName
98768>>>    String sDisplayName
98768>>>End_Struct
98768>>>
98768>>>Activate_View Activate_oUtilFunctions_vw for oUtilFunctions_vw
98778>>>>
98778>>>Object oUtilFunctions_vw is a dbView
98780>>>    Set Border_Style to Border_Thick
98781>>>    Set Size to 291 428
98782>>>    Set Location to 2 1
98783>>>    Set Label to "Utility Functions"
98784>>>    Set pbAutoActivate to True
98785>>>    Set Icon to "TestTools1.ico"
98786>>>    Set pbAcceptDropFiles to True
98787>>>
98787>>>    Object oScrollingContainer1 is a cDbScrollingContainer
98789>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
98791>>>
98791>>>            Object oSQL_grp is a Group
98793>>>                Set Size to 88 402
98794>>>                Set Location to 7 12
98795>>>                Set Label to "Run SQL Database Scripts Embedded as Resources"
98796>>>                Set peAnchors to anTopLeftRight
98797>>>
98797>>>                Object oCreateOrderEntry_btn is a cRDCButtonDPI
98799>>>                    Set Size to 14 219
98800>>>                    Set Location to 13 13
98801>>>                    Set Label to "Create New SQL Database [OrderEntry] Complete with Data"
98802>>>                    Set psToolTip to "Creates the full Order Entry Sample database from the DataFlex samples complete with data with the name: [OrderEntry]"
98803>>>                    Set psImage to "ActionCreateDatabase1.ico"
98804>>>
98804>>>                    Procedure OnClick
98807>>>                        String sInfoText sDriverID
98807>>>                        Boolean bOK
98807>>>                        TimeSpan tsTotalQueryTime
98807>>>                        Integer iRetval
98807>>>
98807>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98807>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98807>>>                        SQLIncludeScriptFile ..\Scripts\CreateOrderEntry.sql as CreateOrderEntry.sql
98807>>>                        Get YesNo_Box "This will run the 'CreateOrderEntry.sql' script from the 'Script' workspace folder which will create the [OrderEntry] database from the DataFlex samples for Microsoft SQL Server, complete with data. If it exists it will first be dropped, then re-created and populated with new data. Continue?" to iRetval
98808>>>                        If (iRetval <> MBR_Yes) Begin
98810>>>                            Procedure_Return
98811>>>                        End
98811>>>>
98811>>>
98811>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98812>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
98814>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
98815>>>                            Procedure_Return
98816>>>                        End
98816>>>>
98816>>>
98816>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
98817>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateOrderEntry.sql" MSSQLDRV_ID False to bOK
98818>>>                        Send StopWorkingMessage
98819>>>
98819>>>                        If (bOK = True) Begin
98821>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98822>>>                            Move ("Success! DataFlex Order Entry Sample Database was created as [OrderEntry]. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98823>>>                        End
98823>>>>
98823>>>
98823>>>                        Else Begin
98824>>>                            Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98825>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98826>>>                        End
98826>>>>
98826>>>
98826>>>                        Send Info_Box sInfoText
98827>>>                    End_Procedure
98828>>>
98828>>>                End_Object
98829>>>
98829>>>                Object oCreateNorthWind_btn is a cRDCButtonDPI
98831>>>                    Set Size to 14 219
98832>>>                    Set Location to 33 13
98833>>>                    Set Label to "Create New SQL Database [NorthWind] Complete with Data"
98834>>>                    Set psToolTip to "Creates the full NorthWind Sample database from the DataFlex samples complete with data with the name: [NorthWind]"
98835>>>                    Set psImage to "ActionCreateDatabase1.ico"
98836>>>
98836>>>                    Procedure OnClick
98839>>>                        String sInfoText sDriverID
98839>>>                        Boolean bOK
98839>>>                        TimeSpan tsTotalQueryTime
98839>>>                        Integer iRetval
98839>>>
98839>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98839>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98839>>>                        SQLIncludeScriptFile ..\Scripts\CreateNorthWindDatabase.sql as CreateNorthWindDatabase.sql
98839>>>
98839>>>                        Get YesNo_Box "This will run the 'CreateNorthWindDatabase.sql' script from the 'Script' workspace folder and it will create the [NorthWind] sample database in Microsoft SQL Server, complete with data. If it exists it will first be dropped, then re-created and populated with new data. Continue?" to iRetval
98840>>>                        If (iRetval <> MBR_Yes) Begin
98842>>>                            Procedure_Return
98843>>>                        End
98843>>>>
98843>>>
98843>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98844>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
98846>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
98847>>>                            Procedure_Return
98848>>>                        End
98848>>>>
98848>>>
98848>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
98849>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateNorthWindDatabase.sql" MSSQLDRV_ID False to bOK
98850>>>                        Send StopWorkingMessage
98851>>>
98851>>>                        If (bOK = True) Begin
98853>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98854>>>                            Move ("Success! The Northwind Sample Database was created as [NorthWind]. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98855>>>                        End
98855>>>>
98855>>>
98855>>>                        Else Begin
98856>>>                            Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98857>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98858>>>                        End
98858>>>>
98858>>>
98858>>>                        Send Info_Box sInfoText
98859>>>                    End_Procedure
98860>>>
98860>>>                End_Object
98861>>>
98861>>>                Object oCreateFullChinookDatabase_btn is a cRDCButtonDPI
98863>>>                    Set Size to 14 219
98864>>>                    Set Location to 53 13
98865>>>                    Set Label to "Create New SQL Database [Chinook] Complete with Data"
98866>>>                    Set psToolTip to "Creates the Chinook demo database complete with data in Microsoft SQL Server. Note: If it exists it will first be dropped then recreated. Note: These scripts were part of Data Access Europe's '' training class."
98867>>>                    Set psImage to "ActionCreateDatabase1.ico"
98868>>>
98868>>>                    Procedure OnClick
98871>>>                        String sInfoText sDriverID
98871>>>                        Boolean bOK
98871>>>                        TimeSpan tsTotalQueryTime
98871>>>                        Integer iRetval
98871>>>
98871>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98871>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98871>>>                        SQLIncludeScriptFile ..\Scripts\CreateChinookDatabase.sql as CreateChinookDatabase.sql
98871>>>
98871>>>                        Get YesNo_Box "This will run the 'CreateChinookDatabase.sql' script from the 'Script' workspace folder which will create the [Chinook] sample database complete with data. If it exists it will first be dropped, then re-created and populated with new data.\n\nContinue?" to iRetval
98872>>>                        If (iRetval <> MBR_Yes) Begin
98874>>>                            Procedure_Return
98875>>>                        End
98875>>>>
98875>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98876>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
98878>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
98879>>>                            Procedure_Return
98880>>>                        End
98880>>>>
98880>>>
98880>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
98881>>>
98881>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateChinookDatabase.sql" MSSQLDRV_ID False to bOK
98882>>>
98882>>>                        Send StopWorkingMessage
98883>>>                        If (bOK = True) Begin
98885>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98886>>>                            Move ("Success! The script was run OK. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98887>>>                        End
98887>>>>
98887>>>
98887>>>                        Else Begin
98888>>>                            Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98889>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98890>>>                        End
98890>>>>
98890>>>
98890>>>                        Send Info_Box sInfoText
98891>>>                    End_Procedure
98892>>>
98892>>>                End_Object
98893>>>
98893>>>                Object oInfo_tb is a TextBox
98895>>>                    Set Auto_Size_State to False
98896>>>                    Set Size to 25 158
98897>>>                    Set Location to 53 238
98898>>>                    Set Label to "Note: The Chinook script was provided by Data Access Europe as part of their 'Web Touch Training' course."
98899>>>                    Set Justification_Mode to JMode_Left
98900>>>                    Set peAnchors to anTopLeftRight
98901>>>                End_Object
98902>>>
98902>>>        //  This will choke the computer so don't try it!
98902>>>        //        Object oCreateAdventureWorksDatabase_btn is a cRDCButtonDPI
98902>>>        //            Set Size to 14 312
98902>>>        //            Set Location to 97 45
98902>>>        //            Set Label to "Create [AdventureWorks] Database and Populate with Data"
98902>>>        //            Set psToolTip to "Creates the Adenture Works database complete with data in Microsoft SQL Server. Note: If it exists it will first be dropped then recreated."
98902>>>        //
98902>>>        //            Procedure OnClick
98902>>>        //                String sInfoText
98902>>>        //                Boolean bOK
98902>>>        //                TimeSpan tsTotalQueryTime
98902>>>        //                Integer iRetval
98902>>>        //
98902>>>        //                // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98902>>>        //                // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98902>>>        ////                SQLIncludeScriptFile ..\Scripts\CreateAdventureWorks.sql as CreateAdventureWorks.sql
98902>>>        //Procedure_Return
98902>>>        //                Get YesNo_Box "This will create the [AdventurWorks] sample database complete with data. If it exists it will first be dropped, then re-created and populated with new data.\n\nContinue?" to iRetval
98902>>>        //                If (iRetval <> MBR_Yes) Begin
98902>>>        //                    Procedure_Return
98902>>>        //                End
98902>>>        //
98902>>>        //                Send StartWorkingMessage "Executing SQL Script. Please wait..."
98902>>>        //                Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateAdventureWorks.sql" MSSQLDRV_ID False to bOK
98902>>>        //                Send StopWorkingMessage
98902>>>        //
98902>>>        //                If (bOK = True) Begin
98902>>>        //                    Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98902>>>        //                    Move ("Success! The script was run OK. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98902>>>        //                End
98902>>>        //
98902>>>        //                Else Begin
98902>>>        //                    Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98902>>>        //                    Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98902>>>        //                End
98902>>>        //
98902>>>        //                Send Info_Box sInfoText
98902>>>        //            End_Procedure
98902>>>        //
98902>>>        //        End_Object
98902>>>
98902>>>            End_Object
98903>>>
98903>>>            Object oChangeIntFiles_grp is a Group
98905>>>                Set Size to 65 402
98906>>>                Set Location to 102 12
98907>>>                Set Label to "Change Old .int files to use Connection ID's"
98908>>>                Set peAnchors to anTopLeftRight
98909>>>
98909>>>                Object oSelectDataPath_fm is a Form
98911>>>                    Set Size to 12 300
98912>>>                    Set Location to 22 13
98913>>>                    Set Label to "Select path to a Data folder with .int files (Select one '.int' file):"
98914>>>                    Set Label_Col_Offset to 0
98915>>>                    Set Label_Row_Offset to 1
98916>>>                    Set Label_Justification_Mode to JMode_Top
98917>>>
98917>>>                    // This is very strange but for some reason the tooltip is _not_ displayed if PB_PromptOn is set...
98917>>>        //            Set Prompt_Button_Mode to PB_PromptOn
98917>>>                    Set psToolTip to "You can use this if you have .int files that currently have content like; 'SERVER=xxx; DATABASE=yyy' et.al. and you need to change them to use a connection ID like; 'SERVER_NAME DFCONNID=MyConnID'"
98918>>>                    Set peAnchors to anTopLeftRight
98919>>>
98919>>>                    Procedure Prompt
98922>>>                        String sPath sFileMask sRetval
98922>>>
98922>>>                        Get psDataPathFirstPart to sPath
98923>>>                        Move "Database intermediate files (*.int)|*.int" to sFileMask
98924>>>                        Get vSelect_File sFileMask "Please select an .int file from the data folder" sPath to sRetval
98925>>>                        If (sRetval <> "") Begin
98927>>>                            Get ParseFolderName sRetval to sPath
98928>>>                            If (Right(sPath, 1) ="\") Begin
98930>>>                                Move (Left(sPath, Length(sPath) -1)) to sPath
98931>>>                            End
98931>>>>
98931>>>                            Set Value to sPath
98932>>>                        End
98932>>>>
98932>>>                    End_Procedure
98933>>>
98933>>>                    // Returns the first datapath found in the psDataPath property.
98933>>>                    // The returned path always ends with a "\"
98933>>>                    Function psDataPathFirstPart Returns String
98936>>>                        String sDataPath
98936>>>                        Integer iCount
98936>>>
98936>>>                        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
98937>>>                        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
98938>>>                        If (iCount > 1) Begin
98940>>>                            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
98941>>>                        End
98941>>>>
98941>>>                        If (sDataPath <> "") Begin
98943>>>                            Get vFolderFormat sDataPath to sDataPath
98944>>>                        End
98944>>>>
98944>>>
98944>>>                        Function_Return sDataPath
98945>>>                    End_Function
98946>>>
98946>>>                End_Object
98947>>>
98947>>>                Object oSelectFolder_btn is a cRDCButtonDPI
98949>>>                    Set Size to 13 73
98950>>>                    Set Location to 22 320
98951>>>                    Set Label to "Select Folder"
98952>>>                    Set psToolTip to "Please select an .int file from the data folder"
98953>>>                    Set peAnchors to anTopRight
98954>>>                    Set psImage to "ActionOpen1.ico"
98955>>>
98955>>>                    Procedure OnClick
98958>>>                        Send Prompt to oSelectDataPath_fm
98959>>>                    End_Procedure
98960>>>
98960>>>                End_Object
98961>>>
98961>>>                Object oConnectionID_fm is a Form
98963>>>                    Set Size to 13 111
98964>>>                    Set Location to 38 202
98965>>>                    Set Label_Col_Offset to 2
98966>>>                    Set Label_Justification_Mode to JMode_Right
98967>>>                    Set Label to "Change to DFConnID:"
98968>>>                    Set psToolTip to "Please enter your Connection ID (DFCONNID=) that should replace the SERVER_NAME settings for all .int files in the selected folder."
98969>>>                    Set peAnchors to anTopRight
98970>>>                End_Object
98971>>>
98971>>>                Object oChangeAllIntFiles_btn is a cRDCButtonDPI
98973>>>                    Set Size to 13 68
98974>>>                    Set Location to 38 320
98975>>>                    Set Label to "GO !"
98976>>>                    Set psToolTip to "Changes or updates all .int files in the selected folder - except for DAW driver .int files (MSSQL_DRV.int, DB2_DRV.int & ODBC_DRV.int) - to use 'SERVER_NAME DFCONNID=xxx'"
98977>>>                    Set FontWeight to fw_Bold
98978>>>                    Set peAnchors to anTopRight
98979>>>
98979>>>                    Procedure OnClick
98982>>>                        String sDataPath sConnectionID
98982>>>                        Boolean bExists bActive
98982>>>                        Integer iRetval iChangedFiles
98982>>>
98982>>>                        Get Value of oSelectDataPath_fm to sDataPath
98983>>>                        Get vFolderExists sDataPath to bExists
98984>>>                        If (bExists = False) Begin
98986>>>                            Send Info_Box ("The data folder doesn't exist!\n" + sDataPath)
98987>>>                            Procedure_Return
98988>>>                        End
98988>>>>
98988>>>                        Get Value of oConnectionID_fm to sConnectionID
98989>>>                        Move (Trim(sConnectionID)) to sConnectionID
98990>>>                        If (sConnectionID = "") Begin
98992>>>                            Send Info_Box "You need to specify a Connection_ID to use for the .int files."
98993>>>                            Procedure_Return
98994>>>                        End
98994>>>>
98994>>>
98994>>>                        Get YesNo_Box ("Do you want to change all .int files in folder:\n" + sDataPath + "\n\nTo use 'DFCONNID=" + sConnectionID +"' ?") to iRetval
98995>>>                        If (iRetval <> MBR_Yes) Begin
98997>>>                            Procedure_Return
98998>>>                        End
98998>>>>
98998>>>                        Get YesNo_Box "All '.CCH' files will first be deleted. Continue?" to iRetval
98999>>>                        If (iRetval <> MBR_Yes) Begin
99001>>>                            Procedure_Return
99002>>>                        End
99002>>>>
99002>>>
99002>>>                        Get vDeleteFile (sDataPath + "\*.cch") to iRetval
99003>>>                        If (iRetval <> 0) Begin
99005>>>                            Send Info_Box "Could not delete .cch files!"
99006>>>                            Procedure_Return
99007>>>                        End
99007>>>>
99007>>>
99007>>>                        Send Initialize_StatusPanel of ghoStatusPanel "The Database Update Framework" "Changing Connection ID's in .int files" ""
99008>>>                        Send Start_StatusPanel of ghoStatusPanel
99009>>>                        Get SqlUtilChangeIntFilesToConnectionIDs of ghoDbUpdateFunctionLibrary sDataPath sConnectionID True to iChangedFiles
99010>>>
99010>>>                        Get Active_State of ghoStatusPanel to bActive
99011>>>                        If (bActive = False) Begin
99013>>>                            Send Info_Box "Process interupted..."
99014>>>                        End
99014>>>>
99014>>>                        Else Begin
99015>>>                            Send Stop_StatusPanel of ghoStatusPanel
99016>>>                            Send Info_Box ("Ready!" * String(iChangedFiles) * String(".int files changed."))
99017>>>                        End
99017>>>>
99017>>>                    End_Procedure
99018>>>
99018>>>                End_Object
99019>>>
99019>>>            End_Object
99020>>>
99020>>>            Object oRemoveFilelistDriverIDs_grp is a Group
99022>>>                Set Size to 59 402
99023>>>                Set Location to 171 12
99024>>>                Set Label to "Remove Database Identifications from Filelist.cfg"
99025>>>                Set peAnchors to anTopLeftRight
99026>>>//                Set TextColor to clGreen
99026>>>//
99026>>>//                Procedure Page Integer iPage
99026>>>//                    Integer ia iz
99026>>>//                    Forward Send Page iPage
99026>>>//                    Move 0 to iz
99026>>>//                    Move (AddressOf(iz)) to ia
99026>>>//                    Move (SetWindowTheme(Window_Handle(Self),ia,ia)) to iPage
99026>>>//                End_Procedure
99026>>>
99026>>>                Object oFilelistPath_fm is a Form
99028>>>                    Set Size to 13 299
99029>>>                    Set Location to 22 13
99030>>>                    Set Label to "Path and Filelist.cfg Name:"
99031>>>                    Set Label_Col_Offset to 0
99032>>>                    Set Label_Row_Offset to 1
99033>>>                    Set Label_Justification_Mode to JMode_Top
99034>>>
99034>>>                    // This is very strange but for some reason the tooltip is _not_ displayed if PB_PromptOn is set...
99034>>>        //            Set Prompt_Button_Mode to PB_PromptOn
99034>>>                    Set psToolTip to "You can use this if you have entries in a Filelist.cfg with driver prefixes like 'MSSQLDRV;Customer' and you need to remove them all."
99035>>>                    Set peAnchors to anTopLeftRight
99036>>>
99036>>>                    Procedure Prompt
99039>>>                        String sFileName sPath sFileMask sRetval
99039>>>
99039>>>                        Get Value to sFileName
99040>>>                        Get ParseFolderName sFileName to sPath
99041>>>                        Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
99042>>>                        Get vSelect_File sFileMask "Please select a Filelist.cft file" sPath to sRetval
99043>>>                        If (sRetval <> "") Begin
99045>>>                            Set Value to sRetval
99046>>>                            Set_Attribute DF_FILELIST_NAME to sRetval
99049>>>                        End
99049>>>>
99049>>>                    End_Procedure
99050>>>
99050>>>                    Procedure OnCreate
99053>>>                        String sFilelist
99053>>>                        Get_Attribute DF_FILELIST_NAME to sFilelist
99056>>>                        Set Value to sFilelist
99057>>>                    End_Procedure
99058>>>                    Send OnCreate
99059>>>
99059>>>                End_Object
99060>>>
99060>>>                Object oSelectFilelist_btn is a cRDCButtonDPI
99062>>>                    Set Size to 13 73
99063>>>                    Set Location to 22 319
99064>>>                    Set Label to "Select Filelist.cfg"
99065>>>                    Set psToolTip to "Please select a Filelist.cfg file to be changed"
99066>>>                    Set peAnchors to anTopRight
99067>>>
99067>>>                    Procedure OnClick
99070>>>                        Send Prompt to oFilelistPath_fm
99071>>>                    End_Procedure
99072>>>
99072>>>                End_Object
99073>>>
99073>>>                Object oInfo_tb is a TextBox
99075>>>                    Set Size to 9 207
99076>>>                    Set Location to 40 138
99077>>>                    Set Label to "Remove database driver identifications from Filelist.cfg:"
99078>>>                    Set peAnchors to anTopRight
99079>>>                End_Object
99080>>>
99080>>>                Object oChangeFilelist_btn is a cRDCButtonDPI
99082>>>                    Set Size to 13 68
99083>>>                    Set Location to 38 319
99084>>>                    Set Label to "GO !"
99085>>>                    Set FontWeight to fw_Bold
99086>>>                    Set peAnchors to anTopRight
99087>>>                    Set psToolTip to 'Removes all database driver identificatins from Filelist.cfg, such as: "MSSQLDRV:MyTable"'
99088>>>
99088>>>                    Procedure OnClick
99091>>>                        String sFileList
99091>>>                        Integer iRetval iCount
99091>>>                        Boolean bExits
99091>>>
99091>>>                        Get Value of oFilelistPath_fm to sFileList
99092>>>                        Get vFilePathExists sFileList to bExits
99093>>>                        If (bExits = False) Begin
99095>>>                            Send Info_Box ("Sorry, the Filelist.cfg does not exist;\n" + sFileList)
99096>>>                            Procedure_Return
99097>>>                        End
99097>>>>
99097>>>
99097>>>                        Get YesNo_Box ("Are you sure you want to remove all driver identifications for the following Filelist.cfg?\n" + sFileList) to iRetval
99098>>>                        If (iRetval <> MBR_Yes) Begin
99100>>>                            Procedure_Return
99101>>>                        End
99101>>>>
99101>>>                        Send Cursor_Wait of Cursor_Control
99102>>>
99102>>>                        Get SqlUtilFilelistRemoveDriverInfo of ghoDbUpdateFunctionLibrary sFileList to iCount
99103>>>
99103>>>                        Send Cursor_Ready of Cursor_Control
99104>>>                        If (iCount <> 0) Begin
99106>>>                            Send Info_Box ("Ready!" * String(iCount) * "Filelist.cfg entries adjusted.")
99107>>>                        End
99107>>>>
99107>>>                        Else Begin
99108>>>                            Send Info_Box "Ready. No driver based Filelist entries found."
99109>>>                        End
99109>>>>
99109>>>
99109>>>                    End_Procedure
99110>>>
99110>>>                End_Object
99111>>>
99111>>>            End_Object
99112>>>
99112>>>            Object oOutput_grp is a Group
99114>>>                Set Size to 47 402
99115>>>                Set Location to 234 12
99116>>>                Set Label to "Print sekected Filelist.cfg as a Text file"
99117>>>                Set peAnchors to anTopLeftRight
99118>>>
99118>>>                Object oOutput_rg is a RadioGroup
99120>>>                    Set Location to 18 13
99121>>>                    Set Size to 25 288
99122>>>                    Set Label to "Filelist Output Order"
99123>>>
99123>>>                    Object oRadio1 is a Radio
99125>>>                        Set Label to "Filelist Number"
99126>>>                        Set Size to 10 61
99127>>>                        Set Location to 10 7
99128>>>                    End_Object
99129>>>
99129>>>                    Object oRadio2 is a Radio
99131>>>                        Set Label to "Logical Name"
99132>>>                        Set Size to 10 61
99133>>>                        Set Location to 10 77
99134>>>                    End_Object
99135>>>
99135>>>                    Object oRadio3 is a Radio
99137>>>                        Set Label to "Root Name"
99138>>>                        Set Size to 10 61
99139>>>                        Set Location to 10 147
99140>>>                    End_Object
99141>>>
99141>>>                    Object oRadio4 is a Radio
99143>>>                        Set Label to "Display Name"
99144>>>                        Set Size to 10 62
99145>>>                        Set Location to 10 213
99146>>>                    End_Object
99147>>>
99147>>>                    Procedure Notify_Select_State Integer iToItem Integer iFromItem
99150>>>                        Forward Send Notify_Select_State iToItem iFromItem
99152>>>                        Set piSortOrder of oPrintFilelist_btn to iToItem
99153>>>                    End_Procedure
99154>>>
99154>>>                End_Object
99155>>>                
99155>>>                Object oPrintFilelist_btn is a cRDCButtonDPI
99157>>>                    Set Size to 13 78
99158>>>                    Set Location to 26 315
99159>>>                    Set Label to "Print to Filelist.txt"
99160>>>                    Set psToolTip to "Writes the content of Filelist.cfg to a textfile and shows the textfile in the editor program asociated with *.txt files."
99161>>>                    Set psImage to "ActionDocument1.ico"
99162>>>
99162>>>                    Property Integer piSortOrder 0 // Property gets set by the radio group object.
99164>>>
99164>>>                    // Custom array sort function.
99164>>>                    // iSortOrder = 0 -> Filelist number order
99164>>>                    // iSortOrder = 1 -> Logical name order
99164>>>                    // iSortOrder = 2 -> Root name order
99164>>>                    // iSortOrder = 3 -> Display name order
99164>>>                    Function CompareSortFilelist tFilelistDUF FilelistDUF1 tFilelistDUF FilelistDUF2 Returns Integer
99167>>>                        Integer iSortOrder
99167>>>
99167>>>                        Get piSortOrder to iSortOrder
99168>>>
99168>>>                        Case Begin
99168>>>                            Case (iSortOrder = 0)
99170>>>                                If (FilelistDUF1.iFileNumber  > FilelistDUF2.iFileNumber) Begin
99172>>>                                    Function_Return (GT)
99173>>>                                End
99173>>>>
99173>>>                                If (FilelistDUF1.iFileNumber  < FilelistDUF2.iFileNumber) Begin
99175>>>                                    Function_Return (LT)
99176>>>                                End
99176>>>>
99176>>>                                Function_Return (EQ)
99177>>>                            Case (iSortOrder = 1)
99180>>>                                If (Uppercase(FilelistDUF1.sLogicalName) > Uppercase(FilelistDUF2.sLogicalName)) Begin
99182>>>                                    Function_Return (GT)
99183>>>                                End
99183>>>>
99183>>>                                If (Uppercase(FilelistDUF1.sLogicalName) < Uppercase(FilelistDUF2.sLogicalName)) Begin
99185>>>                                    Function_Return (LT)
99186>>>                                End
99186>>>>
99186>>>                                Function_Return (EQ)
99187>>>                            Case (iSortOrder = 2)
99190>>>                                If (Uppercase(FilelistDUF1.sRootName)    > Uppercase(FilelistDUF2.sRootName)) Begin
99192>>>                                    Function_Return (GT)
99193>>>                                End
99193>>>>
99193>>>                                If (Uppercase(FilelistDUF1.sRootName)    < Uppercase(FilelistDUF2.sRootName)) Begin
99195>>>                                    Function_Return (LT)
99196>>>                                End
99196>>>>
99196>>>                                Function_Return (EQ)
99197>>>                            Case (iSortOrder = 3)
99200>>>                                If (Uppercase(FilelistDUF1.sDisplayName) > Uppercase(FilelistDUF2.sDisplayName)) Begin
99202>>>                                    Function_Return (GT)
99203>>>                                End
99203>>>>
99203>>>                                If (Uppercase(FilelistDUF1.sDisplayName) < Uppercase(FilelistDUF2.sDisplayName)) Begin
99205>>>                                    Function_Return (LT)
99206>>>                                End
99206>>>>
99206>>>                                Function_Return (EQ)
99207>>>                        Case End
99207>>>
99207>>>                    End_Function
99208>>>
99208>>>                    Procedure OnClick
99211>>>                        String sFileList sRootName sLogicalName sDisplayName sPath sOutputName sTable sExt
99211>>>                        Integer iCh iCount iSize
99211>>>                        Handle hTable
99211>>>                        tFilelistDUF[] FilelistDUFArray FilelistDUFSorted
99211>>>                        tFilelistDUF[] FilelistDUFArray FilelistDUFSorted
99213>>>
99213>>>                        Get Value of oFilelistPath_fm to sFileList
99214>>>                        Move (Trim(sFileList)) to sFileList
99215>>>                        If (sFileList = "") Begin
99217>>>                            Send Info_Box "You need to select a Filelist.cfg file first"
99218>>>                            Procedure_Return
99219>>>                        End
99219>>>>
99219>>>
99219>>>                        Get ParseFolderName sFileList to sPath
99220>>>                        Get vFolderFormat sPath to sPath
99221>>>                        Get ParseFileName sFileList to sOutputName
99222>>>                        Get ParseFileExtension sFileList to sExt
99223>>>                        Move (Replace(sExt, sOutputName, "")) to sOutputName
99224>>>                        Move (sOutputName + "txt")           to sOutputName
99225>>>                        Get Seq_Open_Output_Channel (sPath + sOutputName) to iCh
99226>>>                        If (iCh < 0) Begin
99228>>>                            Procedure_Return
99229>>>                        End
99229>>>>
99229>>>
99229>>>                        Move 0 to hTable
99230>>>                        Writeln channel iCh sFileList
99233>>>                        Writeln channel iCh "[Table No:]            [LogicalName:]        [RootName:]                             [DisplayName:]"
99236>>>                        Writeln channel iCh "==================================================================================================="
99239>>>                        Writeln channel iCh
99241>>>
99241>>>                        Move 0 to iCount
99242>>>                        Repeat
99242>>>>
99242>>>                            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
99245>>>                            If (hTable > 0) Begin
99247>>>                                Move hTable                                  to FilelistDUFArray[iCount].iFileNumber
99248>>>                                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to FilelistDUFArray[iCount].sLogicalName
99251>>>                                Get_Attribute DF_FILE_ROOT_NAME    of hTable to FilelistDUFArray[iCount].sRootName
99254>>>                                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to FilelistDUFArray[iCount].sDisplayName
99257>>>                                Increment iCount
99258>>>                            End
99258>>>>
99258>>>                        Until (hTable = 0)
99260>>>
99260>>>                        Move (SortArray(FilelistDUFArray, Self, (RefFunc(CompareSortFilelist)))) to FilelistDUFSorted
99261>>>                        Move (SizeOfArray(FilelistDUFSorted)) to iSize
99262>>>                        Decrement iSize
99263>>>
99263>>>                        For iCount from 0 to iSize
99269>>>>
99269>>>                            Move FilelistDUFSorted[iCount].iFileNumber  to hTable
99270>>>                            Move FilelistDUFSorted[iCount].sLogicalName to sLogicalName
99271>>>                            Move FilelistDUFSorted[iCount].sRootName    to sRootName
99272>>>                            Move FilelistDUFSorted[iCount].sDisplayName to sDisplayName
99273>>>
99273>>>                            Get PadLeft (String(hTable))        09 to sTable
99274>>>                            Get PadLeft (String(sLogicalName)) (27 - Length(sTable))       to sLogicalName
99275>>>                            Get PadLeft (String(sRootName))    (46 - Length(sLogicalName)) to sRootName
99276>>>                            Get PadLeft (String(sDisplayName)) (72 - Length(sRootName))    to sDisplayName
99277>>>
99277>>>                            Writeln channel iCh sTable (Utf8ToAnsi(sRootName)) (Utf8ToAnsi(sLogicalName)) (Utf8ToAnsi(sDisplayName))
99283>>>                        Loop
99284>>>>
99284>>>
99284>>>                        Writeln channel iCh "==================================================================================================="
99287>>>                        Writeln channel iCh "Total Number of Tables in Filelist.cfg: " (iSize + 1)
99291>>>                        Close_Output
99292>>>
99292>>>                        Send vShellExecute "open" sOutputName "" sPath
99293>>>                    End_Procedure
99294>>>
99294>>>                    Function PadLeft String sString Integer iLength String sOptChar Returns String
99297>>>                        String sChar
99297>>>
99297>>>                        If (Num_Arguments >= 3) Begin
99299>>>                            Move sOptChar to sChar
99300>>>                        End
99300>>>>
99300>>>                        Else Begin
99301>>>                            Move " " to sChar
99302>>>                        End
99302>>>>
99302>>>
99302>>>                        While (Length(sString) < iLength)
99306>>>                            Move (sChar + sString) to sString
99307>>>                        Loop
99308>>>>
99308>>>
99308>>>                        Function_Return sString
99309>>>                    End_Function
99310>>>
99310>>>                End_Object
99311>>>            End_Object
99312>>>
99312>>>        End_Object
99313>>>
99313>>>    End_Object
99314>>>
99314>>>    Procedure OnFileDropped String sFilename Boolean bLast
99317>>>        String sTest
99317>>>        Forward Send OnFileDropped sFilename bLast
99319>>>        If (bLast = True) Begin
99321>>>            Get ParseFileName sFilename to sTest
99322>>>            If (Uppercase(sTest) <> "FILELIST.CFG") Begin
99324>>>                Send Info_Box "Sorry, only Filist.cfg files can be dropped here..."
99325>>>                Procedure_Return
99326>>>            End
99326>>>>
99326>>>            Set Value of oFilelistPath_fm to sFilename
99327>>>        End
99327>>>>
99327>>>    End_Procedure
99328>>>
99328>>>End_Object
99329>
99329>        Procedure Activate_About
99332>            Send DoAbout "" "" ("Copyright 2016-2023" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "TestTools.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com" ("This tool was created with DataFlex" * String(C_DFVersion) * "from Data Access Worldwide. Please visit http://www.dataaccess.com for a free personal copy of DataFlex.")
99333>        End_Procedure
99334>
99334>        On_Key Key_Ctrl+Key_Tab           Send Switch_Prior_View
99335>        On_Key Key_Ctrl+Key_Shift+Key_Tab Send Switch_Next_View
99336>        On_Key Key_Ctrl+Key_W             Send Close_Panel
99337>    End_Object
99338>
99338>    // Note that we have overriden the cHtmlHelp "GetHelpFile" function
99338>    // in the oHtmlHelp object, so we need to explitetly send the message
99338>    // to that object.
99338>    Procedure ShowProgramHelp
99341>        Send DoDisplayKeyword of oHtmlHelp "DbUpdateFrameworkTests" //"cDbUpdateFunctionLibrary"
99342>    End_Procedure
99343>
99343>    On_Key Key_F1 Send ShowProgramHelp
99344>End_Object
99345>
99345>// We do this to activate the first view:
99345>//Send Activate_oSQLConnections_vw of (Client_Id(phoMainPanel(ghoApplication)))
99345>Start_UI
99346>
Including Resources...
Summary
Memory Available: 26555088896
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 52819
Total Resources: 10
Total Commands : 99345
Total Windows  : 0
Total Pages    : 0
Static Data    : 849127
Message area   : 638930
Total Blocks   : 80753
