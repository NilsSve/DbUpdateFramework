Compiling Program: C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFTestProgram.src
Memory Available: 76979187712
1>    CompilerLevelWarning All On
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.x64.pkd    (C:\Program Files\DataFlex 24.0\Pkg\dfallent.x64.pkd)
73440>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJStandardCommandBarSystem.pkg)
73440>>>// these are all the packages used in a standard MDI menubar/toolbar system
73440>>>
73440>>>Use cCJCommandBarSystem.pkg
73440>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJStandardMenuItemClasses.pkg)
73440>>>>>Use Dfpanel.pkg
73440>>>>>Use cCJCommandBarSystem.pkg
73440>>>>>Use LanguageText.pkg
73440>>>>>
73440>>>>>
73440>>>>>Class cCJUndoMenuItem is a cCJMenuItem
73441>>>>>    
73441>>>>>    Procedure Construct_Object
73443>>>>>        Forward Send Construct_Object
73445>>>>>        Set psCaption   to C_$CaptionUndo
73446>>>>>        Set psToolTip to C_$ToolTipUndo
73447>>>>>        Set psDescription to C_$DescUndo
73448>>>>>        Set psImage to "ActionUndo.ico"
73449>>>>>        Set pbActiveUpdate to True
73450>>>>>        Set psCategory to C_$CategoryEdit
73451>>>>>        Set psShortcut to C_$Key_Ctrl_Z
73452>>>>>    End_Procedure
73453>>>>>    
73453>>>>>    Procedure OnExecute Variant vCommandBarControl
73455>>>>>        Send Undo of (focus(Self))
73456>>>>>    End_Procedure
73457>>>>>    
73457>>>>>    Function IsEnabled Returns Boolean
73459>>>>>        Boolean bEnabled
73459>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
73460>>>>>        Function_Return bEnabled
73461>>>>>    End_Function
73462>>>>>    
73462>>>>>End_Class
73463>>>>>
73463>>>>>
73463>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
73464>>>>>    
73464>>>>>    Procedure Construct_Object
73466>>>>>        Forward Send Construct_Object
73468>>>>>        Set psCaption   to C_$CaptionDelete
73469>>>>>        Set psToolTip to C_$ToolTipDelete
73470>>>>>        Set psDescription to C_$DescDelete
73471>>>>>        Set psImage to "actionDelete.ico"
73472>>>>>        Set psShortcut to C_$Key_Delete
73473>>>>>        Set pbActiveUpdate to True
73474>>>>>        Set psCategory to C_$CategoryEdit
73475>>>>>    End_Procedure
73476>>>>>    
73476>>>>>    
73476>>>>>    Procedure OnExecute Variant vCommandBarControl
73478>>>>>        Send Delete of (focus(Self))
73479>>>>>    End_Procedure
73480>>>>>    
73480>>>>>    Function IsEnabled Returns Boolean
73482>>>>>        Boolean bEnabled
73482>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
73483>>>>>        Function_Return bEnabled
73484>>>>>    End_Function
73485>>>>>    
73485>>>>>End_Class
73486>>>>>
73486>>>>>
73486>>>>>Class cCJCutMenuItem is a cCJMenuItem
73487>>>>>    
73487>>>>>    Procedure Construct_Object
73489>>>>>        Forward Send Construct_Object
73491>>>>>        Set psCaption   to C_$CaptionCut
73492>>>>>        Set psToolTip to C_$TooltipCut
73493>>>>>        Set psDescription to C_$DescCut
73494>>>>>        Set psImage to "actionCut.ico"
73495>>>>>        Set psShortcut to C_$Key_Ctrl_X
73496>>>>>        Set pbActiveUpdate to True
73497>>>>>        Set psCategory to C_$CategoryEdit
73498>>>>>    End_Procedure
73499>>>>>    
73499>>>>>    
73499>>>>>    Procedure OnExecute Variant vCommandBarControl
73501>>>>>        Send Cut of (focus(Self))
73502>>>>>    End_Procedure
73503>>>>>    
73503>>>>>    Function IsEnabled Returns Boolean
73505>>>>>        Boolean bEnabled
73505>>>>>        Get CanCut of (Focus(Self)) to bEnabled
73506>>>>>        Function_Return bEnabled
73507>>>>>    End_Function
73508>>>>>    
73508>>>>>End_Class
73509>>>>>
73509>>>>>
73509>>>>>Class cCJCopyMenuItem is a cCJMenuItem
73510>>>>>    
73510>>>>>    Procedure Construct_Object
73512>>>>>        Forward Send Construct_Object
73514>>>>>        Set psCaption   to C_$CaptionCopy
73515>>>>>        Set psToolTip to C_$ToolTipCopy
73516>>>>>        Set psDescription to C_$DescCopy
73517>>>>>        Set psImage to "actionCopy.ico"
73518>>>>>        Set psShortcut to C_$Key_Ctrl_C
73519>>>>>        Set pbActiveUpdate to True
73520>>>>>        Set psCategory to C_$CategoryEdit
73521>>>>>    End_Procedure
73522>>>>>    
73522>>>>>    
73522>>>>>    Procedure OnExecute Variant vCommandBarControl
73524>>>>>        Send Copy of (focus(Self))
73525>>>>>    End_Procedure
73526>>>>>    
73526>>>>>    Function IsEnabled Returns Boolean
73528>>>>>        Boolean bEnabled
73528>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
73529>>>>>        Function_Return bEnabled
73530>>>>>    End_Function
73531>>>>>    
73531>>>>>End_Class
73532>>>>>
73532>>>>>
73532>>>>>Class cCJPasteMenuItem is a cCJMenuItem
73533>>>>>    
73533>>>>>    Procedure Construct_Object
73535>>>>>        Forward Send Construct_Object
73537>>>>>        Set psCaption   to C_$CaptionPaste
73538>>>>>        Set psToolTip to C_$ToolTipPaste
73539>>>>>        Set psDescription to C_$DescPaste
73540>>>>>        Set psImage to "actionPaste.ico"
73541>>>>>        Set pbActiveUpdate to True
73542>>>>>        Set psShortcut to C_$Key_Ctrl_V
73543>>>>>        Set psCategory to C_$CategoryEdit
73544>>>>>    End_Procedure
73545>>>>>    
73545>>>>>    
73545>>>>>    Procedure OnExecute Variant vCommandBarControl
73547>>>>>        Send Paste of (focus(Self))
73548>>>>>    End_Procedure
73549>>>>>    
73549>>>>>    Function IsEnabled Returns Boolean
73551>>>>>        Boolean bEnabled
73551>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
73552>>>>>        Function_Return bEnabled
73553>>>>>    End_Function
73554>>>>>    
73554>>>>>End_Class
73555>>>>>
73555>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
73556>>>>>    
73556>>>>>    Procedure Construct_Object
73558>>>>>        Forward Send Construct_Object
73560>>>>>        Set psCaption   to C_$CaptionSelectAll
73561>>>>>        Set psToolTip to C_$ToolTipSelectAll
73562>>>>>        Set psDescription to C_$DescSelectAll
73563>>>>>        Set pbActiveUpdate to True
73564>>>>>        Set psShortcut to C_$Key_Ctrl_A
73565>>>>>        Set psCategory to C_$CategoryEdit
73566>>>>>    End_Procedure
73567>>>>>    
73567>>>>>    
73567>>>>>    Procedure OnExecute Variant vCommandBarControl
73569>>>>>        Send Select_All of (focus(Self))
73570>>>>>    End_Procedure
73571>>>>>    
73571>>>>>    Function IsEnabled Returns Boolean
73573>>>>>        Boolean bEnabled
73573>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
73574>>>>>        Function_Return bEnabled
73575>>>>>    End_Function
73576>>>>>    
73576>>>>>End_Class
73577>>>>>
73577>>>>>
73577>>>>>Class cCJExitMenuItem is a cCJMenuItem
73578>>>>>    
73578>>>>>    Procedure Construct_Object
73580>>>>>        Forward Send Construct_Object
73582>>>>>        Set psCaption to C_$CaptionExit
73583>>>>>        Set psToolTip to C_$ToolTipExit
73584>>>>>        Set psDescription to C_$ToolTipExit
73585>>>>>        Set psShortcut to C_$Key_Alt_F4
73586>>>>>        Set psCategory to C_$CategoryFile
73587>>>>>    End_Procedure
73588>>>>>    
73588>>>>>    Procedure OnExecute Variant vCommandBarControl
73590>>>>>        Send Exit_Application of Desktop
73591>>>>>    End_Procedure
73592>>>>>    
73592>>>>>End_Class
73593>>>>>
73593>>>>>Class cCJHelpMenuItem is a cCJMenuItem
73594>>>>>    
73594>>>>>    Procedure Construct_Object
73596>>>>>        Forward Send Construct_Object
73598>>>>>        Set psCaption to C_$CaptionHelp
73599>>>>>        Set psDescription to C_$ToolTipHelp
73600>>>>>        Set psToolTip to C_$DescHelp
73601>>>>>        Set psImage to "ActionHelp.ico"
73602>>>>>        Set psShortcut to "F1"
73603>>>>>        Set psCategory to C_$CategoryHelp
73604>>>>>    End_Procedure
73605>>>>>    
73605>>>>>    Procedure OnExecute Variant vCommandBarControl
73607>>>>>        Send Help of (Focus(Self))
73608>>>>>    End_Procedure
73609>>>>>    
73609>>>>>End_Class
73610>>>>>
73610>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
73611>>>>>    
73611>>>>>    Procedure Construct_Object
73613>>>>>        Forward Send Construct_Object
73615>>>>>        Set psCaption to C_$CaptionAddStatusbar
73616>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
73617>>>>>        Set psDescription to  C_$DescAddStatusbar
73618>>>>>        Set psCategory to C_$CategoryWindow
73619>>>>>    End_Procedure
73620>>>>>    
73620>>>>>    Procedure OnExecute Variant vCommandBarControl
73622>>>>>        Handle hoCommandBars hoClientArea
73622>>>>>        Get CommandBarSystemObject to hoCommandBars
73623>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73624>>>>>        If hoClientArea Begin
73626>>>>>            // the clientarea's parent panel has message
73626>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
73627>>>>>        End
73627>>>>>>
73627>>>>>    End_Procedure
73628>>>>>    
73628>>>>>    Function IsChecked Returns Boolean
73630>>>>>        Boolean bOn
73630>>>>>        Handle hoCommandBars hoClientArea
73630>>>>>        Get CommandBarSystemObject to hoCommandBars
73631>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73632>>>>>        If hoClientArea Begin
73634>>>>>            // the clientarea's parent panel has message
73634>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
73635>>>>>        End
73635>>>>>>
73635>>>>>        Function_Return bOn
73636>>>>>    End_Function
73637>>>>>End_Class
73638>>>>>
73638>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
73639>>>>>    
73639>>>>>    Procedure Construct_Object
73641>>>>>        Forward Send Construct_Object
73643>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
73644>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
73645>>>>>        Set psDescription to C_$DescAutoArrangeIcons
73646>>>>>        Set psCategory to C_$CategoryWindow
73647>>>>>    End_Procedure
73648>>>>>    
73648>>>>>    Procedure OnExecute Variant vCommandBarControl
73650>>>>>        Handle hoCommandBars hoClientArea
73650>>>>>        Get CommandBarSystemObject to hoCommandBars
73651>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73652>>>>>        If hoClientArea Begin
73654>>>>>            // the clientarea's parent panel has message
73654>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
73655>>>>>        End
73655>>>>>>
73655>>>>>    End_Procedure
73656>>>>>    
73656>>>>>    Function IsChecked Returns Boolean
73658>>>>>        Boolean bOn
73658>>>>>        Handle hoCommandBars hoClientArea
73658>>>>>        Get CommandBarSystemObject to hoCommandBars
73659>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73660>>>>>        If hoClientArea Begin
73662>>>>>            // the clientarea's parent panel has message
73662>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
73663>>>>>        End
73663>>>>>>
73663>>>>>        Function_Return bOn
73664>>>>>    End_Function
73665>>>>>End_Class
73666>>>>>
73666>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
73667>>>>>    
73667>>>>>    Procedure Construct_Object
73669>>>>>        Forward Send Construct_Object
73671>>>>>        Set psCaption to C_$CaptionRestoreMenus
73672>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
73673>>>>>        Set psDescription to C_$DescRestoreMenus
73674>>>>>        Set psCategory to C_$CategoryWindow
73675>>>>>    End_Procedure
73676>>>>>    
73676>>>>>    Procedure OnExecute Variant vCommandBarControl
73678>>>>>        Handle hoCommandBars
73678>>>>>        Get CommandBarSystemObject to hoCommandBars
73679>>>>>        Send RestoreLayout of hoCommandBars
73680>>>>>    End_Procedure
73681>>>>>    
73681>>>>>End_Class
73682>>>>>
73682>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
73683>>>>>    
73683>>>>>    Procedure Construct_Object
73685>>>>>        Forward Send Construct_Object
73687>>>>>        Set psCaption to C_$CaptionCascade
73688>>>>>        Set psToolTip to C_$ToolTipCascade
73689>>>>>        Set psDescription to  C_$DescCascade
73690>>>>>        Set psImage to "ActionCascade.ico"
73691>>>>>        Set psCategory to C_$CategoryWindow
73692>>>>>    End_Procedure
73693>>>>>    
73693>>>>>    Procedure OnExecute Variant vCommandBarControl
73695>>>>>        Handle hoCommandBars hoClientArea
73695>>>>>        Get CommandBarSystemObject to hoCommandBars
73696>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73697>>>>>        If hoClientArea Begin
73699>>>>>            Send Cascade_Windows of hoClientArea
73700>>>>>        End
73700>>>>>>
73700>>>>>    End_Procedure
73701>>>>>End_Class
73702>>>>>
73702>>>>>Class cCJTileHorizontally is a cCJMenuItem
73703>>>>>    
73703>>>>>    Procedure Construct_Object
73705>>>>>        Forward Send Construct_Object
73707>>>>>        Set psCaption to C_$CaptionTileHorizontally
73708>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
73709>>>>>        Set psDescription to  C_$DescTileHorizontally
73710>>>>>        Set psImage to "ActionTileHorizontally.ico"
73711>>>>>        Set psCategory to C_$CategoryWindow
73712>>>>>    End_Procedure
73713>>>>>    
73713>>>>>    Procedure OnExecute Variant vCommandBarControl
73715>>>>>        Handle hoCommandBars hoClientArea
73715>>>>>        Get CommandBarSystemObject to hoCommandBars
73716>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73717>>>>>        If hoClientArea Begin
73719>>>>>            Send Tile_Windows_Horizontal of hoClientArea
73720>>>>>        End
73720>>>>>>
73720>>>>>    End_Procedure
73721>>>>>End_Class
73722>>>>>
73722>>>>>Class cCJTileVertically is a cCJMenuItem
73723>>>>>    
73723>>>>>    Procedure Construct_Object
73725>>>>>        Forward Send Construct_Object
73727>>>>>        Set psCaption to C_$CaptionTileVertically
73728>>>>>        Set psToolTip to C_$ToolTipTileVertically
73729>>>>>        Set psDescription to  C_$DescTileVertically
73730>>>>>        Set psImage to "ActionTileVertically.ico"
73731>>>>>        Set psCategory to C_$CategoryWindow
73732>>>>>    End_Procedure
73733>>>>>    
73733>>>>>    Procedure OnExecute Variant vCommandBarControl
73735>>>>>        Handle hoCommandBars hoClientArea
73735>>>>>        Get CommandBarSystemObject to hoCommandBars
73736>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73737>>>>>        If hoClientArea Begin
73739>>>>>            Send Tile_Windows_Vertical of hoClientArea
73740>>>>>        End
73740>>>>>>
73740>>>>>    End_Procedure
73741>>>>>End_Class
73742>>>>>
73742>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
73743>>>>>    
73743>>>>>    Procedure Construct_Object
73745>>>>>        Forward Send Construct_Object
73747>>>>>        Set psCaption to C_$CaptionMinimizeWindows
73748>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
73749>>>>>        Set psDescription to  C_$DescMinimizeWindows
73750>>>>>        Set psCategory to C_$CategoryWindow
73751>>>>>    End_Procedure
73752>>>>>    
73752>>>>>    Procedure OnExecute Variant vCommandBarControl
73754>>>>>        Handle hoCommandBars hoClientArea
73754>>>>>        Get CommandBarSystemObject to hoCommandBars
73755>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73756>>>>>        If hoClientArea Begin
73758>>>>>            // the clientarea's parent panel has message
73758>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
73759>>>>>        End
73759>>>>>>
73759>>>>>    End_Procedure
73760>>>>>End_Class
73761>>>>>
73761>>>>>
73761>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
73762>>>>>    
73762>>>>>    Procedure Construct_Object
73764>>>>>        Forward Send Construct_Object
73766>>>>>        Set psCaption to C_$CaptionRestoreWindows
73767>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
73768>>>>>        Set psDescription to  C_$DescRestoreWindows
73769>>>>>        Set psCategory to C_$CategoryWindow
73770>>>>>    End_Procedure
73771>>>>>    
73771>>>>>    Procedure OnExecute Variant vCommandBarControl
73773>>>>>        Handle hoCommandBars hoClientArea
73773>>>>>        Get CommandBarSystemObject to hoCommandBars
73774>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73775>>>>>        If hoClientArea Begin
73777>>>>>            // the clientarea's parent panel has message
73777>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
73778>>>>>        End
73778>>>>>>
73778>>>>>    End_Procedure
73779>>>>>End_Class
73780>>>>>
73780>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
73781>>>>>    
73781>>>>>    Procedure Construct_Object
73783>>>>>        Forward Send Construct_Object
73785>>>>>        Set psCaption to C_$CaptionArrangeIcons
73786>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
73787>>>>>        Set psDescription to  C_$DescArrangeIcons
73788>>>>>        Set psCategory to C_$CategoryWindow
73789>>>>>    End_Procedure
73790>>>>>    
73790>>>>>    Procedure OnExecute Variant vCommandBarControl
73792>>>>>        Handle hoCommandBars hoClientArea
73792>>>>>        Get CommandBarSystemObject to hoCommandBars
73793>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73794>>>>>        If hoClientArea Begin
73796>>>>>            Send Arrange_Icons of hoClientArea
73797>>>>>        End
73797>>>>>>
73797>>>>>    End_Procedure
73798>>>>>    
73798>>>>>End_Class
73799>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJAboutMenuItem.pkg)
73799>>>>>Use cCJCommandBarSystem.pkg
73799>>>>>Use LanguageText.pkg
73799>>>>>
73799>>>>>// It is expected that if you use this class that you provide an about object that is
73799>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
73799>>>>>// because you may wish to create your own custom about package.
73799>>>>>
73799>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
73800>>>>>
73800>>>>>    Procedure Construct_Object
73802>>>>>        Forward Send Construct_Object
73804>>>>>        Set psCaption to C_$CaptionAbout
73805>>>>>        Set psDescription to C_$ToolTipAbout
73806>>>>>        Set psToolTip to C_$DescAbout
73807>>>>>        Set psImage to "ActionAbout.ico"
73808>>>>>        Set psCategory to C_$CategoryHelp
73809>>>>>    End_Procedure
73810>>>>>    
73810>>>>>    Procedure OnExecute Variant vCommandBarControl
73812>>>>>        Handle hoCommandBars hoClientArea
73812>>>>>        Get CommandBarSystemObject to hoCommandBars
73813>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73814>>>>>        If hoClientArea Begin
73816>>>>>            Send Activate_About of hoClientArea
73817>>>>>        End
73817>>>>>>
73817>>>>>    End_Procedure
73818>>>>>
73818>>>>>End_Class
73819>>>>>
73819>>>>>
73819>>>Use cCJDeoMenuItemClasses.pkg
73819>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJMDIWindowsMenuItem.pkg)
73819>>>>>Use cCJCommandBarSystem.pkg
73819>>>>>
73819>>>>>Register_Function Client_ID Returns Integer
73819>>>>>
73819>>>>>// only used by cCJMDIWIndowsMenuItem
73819>>>>>Class cCJMDIWindowItem is a cCJMenuItem
73820>>>>>    
73820>>>>>    Procedure Construct_Object
73822>>>>>        Forward Send Construct_Object
73824>>>>>        Property Handle phWindow 0 // object id of view
73825>>>>>        Set pbControlFlagNoMovable to True
73826>>>>>        Set pbActiveUpdate to True
73827>>>>>    End_Procedure
73828>>>>>    
73828>>>>>    Procedure OnExecute Variant vCommandBarControl
73830>>>>>        Handle hWindow
73830>>>>>        Get phWindow to hWindow
73831>>>>>        Send Activate_View of hWindow
73832>>>>>    End_Procedure
73833>>>>>    
73833>>>>>End_Class
73834>>>>>
73834>>>>>
73834>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
73835>>>>>    
73835>>>>>    Procedure Construct_Object
73837>>>>>        Forward Send Construct_Object
73839>>>>>        Property Handle[] phArrayOfWindows
73840>>>>>        Set peControlType to xtpControlPopup
73841>>>>>        Set psCategory to C_$CategoryWindow
73842>>>>>    End_Procedure
73843>>>>>    
73843>>>>>    // This adds MDI windows to the existing menu items.
73843>>>>>    // This removes any existing windows menus and always adds a new set to the end
73843>>>>>    
73843>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
73845>>>>>        Handle  hClientArea hView
73845>>>>>        String  sLabel
73845>>>>>        Integer i iWindows
73845>>>>>        Handle[] hArrayOfWindows
73846>>>>>        Variant vItem
73846>>>>>        
73846>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
73846>>>>>        // also assume that destroying an action removes all menu instances of that action
73846>>>>>        Get phArrayOfWindows to hArrayOfWindows
73847>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
73848>>>>>        For i from 0 to (iWindows-1)
73854>>>>>>
73854>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
73855>>>>>        Loop
73856>>>>>>
73856>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
73857>>>>>        
73857>>>>>        // Add all views to this menu. Create the action and add the item
73857>>>>>        Move 0 to i
73858>>>>>        Get Client_Id to hClientArea // object id of client area
73859>>>>>        If (hClientArea > 0) Begin
73861>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
73862>>>>>            While (hView <> 0)
73866>>>>>                If (Active_State(hView)) Begin
73868>>>>>                    // create the action
73868>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
73869>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
73870>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
73871>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
73872>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
73874>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
73875>>>>>                    End
73875>>>>>>
73875>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
73876>>>>>                    If (i=0) Begin
73878>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
73879>>>>>                    End
73879>>>>>>
73879>>>>>                    // Create a menu item for this action
73879>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
73880>>>>>                    Increment i
73881>>>>>                End
73881>>>>>>
73881>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
73882>>>>>            Loop
73883>>>>>>
73883>>>>>        End
73883>>>>>>
73883>>>>>        
73883>>>>>        Set phArrayOfWindows to hArrayOfWindows
73884>>>>>        
73884>>>>>    End_Procedure
73885>>>>>    
73885>>>>>End_Class
73886>Use cCJCommandBarSystem.pkg
73886>Use cDbUpdateHandler.pkg
Including file: cDbUpdateHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.pkg)
73886>>>//****************************************************************************
73886>>>// $Module type: Class
73886>>>// $Module name: cDbUpdateHandler
73886>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
73886>>>// Web-site    : http://www.rdctools.com
73886>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
73886>>>//
73886>>>// Purpose     : A framework for doing automated code based updates of a database from within
73886>>>//               a program, when it is started.
73886>>>//
73886>>>// Description : Place _one_ object of this class right after the cApplication object.
73886>>>//               Then inside this object place a series of cDbUpdateVersion objects
73886>>>//               as childs. One child object for each new database update.
73886>>>//
73886>>>//               - OnPreUpdate is a pre-processing event called
73886>>>//               before any database changes are started.
73886>>>//               - OnPostUpdate is a post-processing event called after all
73886>>>//               database changes have taken place.
73886>>>//
73886>>>// Note        : If tables have been opened prior to an object of this class
73886>>>//               (e.g. in the cApplication object), those tables will be closed.
73886>>>//               In that case you need to use the OnPostUpdate hook event to re-open
73886>>>//               tables after the last update has finished.
73886>>>//
73886>>>// Security    : Before an update is attempted; three things are checked to ensure the
73886>>>//               database is not in use. Aka nobody else is running the application.
73886>>>//               - All tables are tested for "Open in Exclusive_Mode"
73886>>>//               - The DataFlex license User Count is checked - cannot be more than 1, unless the
73886>>>//                 pbCheckDataFlexUserCount is set to False (Default = True)
73886>>>//               - A special user count file ("DbUpdateUserCount.ucf") is created in the Programs
73886>>>//                 folder and a bit-lock is performed for each start of the application and this
73886>>>//                 user counter is checked before an update is attempted.
73886>>>//                 Important: Even if it seems like both garters & suspenders are used to guard
73886>>>//                            against the database being "in use", there is no such guarantee! The
73886>>>//                            database could e.g. be open in "Microsoft SQL Server Management Studio"
73886>>>//                            and there is no way of telling. SO BE CAUTIOUS before attempting an update!
73886>>>//                 A second "user count file" is also used - "DbUpdateLock.ucf". It is used to
73886>>>//                 lock everybody else out (with a Stop box) while the database is being updated. The lock will
73886>>>//                 automatically be released after the update is completed.
73886>>>//
73886>>>//
73886>>>// Usage       :  Use cDbUpdateHandler.pkg
73886>>>//                Object oDatabaseUpdateHandler is a cDbUpdateHandler
73886>>>//                    // Declare the table that contains a "database version" field.
73886>>>//                    Declare_Datafile Sys
73886>>>//                    // Either one of these syntaxes is fine:
73886>>>//                    Set Data_File_Field to File_Field Sys.DbUpdateVersion
73886>>>//                    Set Data_File_Field to (RefTable(Sys)) (RefTable(Sys.DbUpdateVersion))
73886>>>//
73886>>>//                    // Don't forget to increase the pnVersionNumber property for each
73886>>>//                    // cDbUpdateVersion object!
73886>>>//                    // The VersionTableColumn field/column specified above will be updated automatically
73886>>>//                    // with the value of pnVersionNumber after each update has been finished.
73886>>>//                    Object oVersionUpdate1.1 is a cDbUpdateVersion
73886>>>//                        Set pnVersionNumber to 1.1
73886>>>//                        Use VersionUpdate1_1.pkg
73886>>>//                    End_Object
73886>>>//
73886>>>//                    Object oVersionUpdate1.2 is a cDbUpdateVersion
73886>>>//                        Set pnVersionNumber to 1.2
73886>>>//                        Use VersionUpdate1_2.pkg
73886>>>//                    End_Object
73886>>>//
73886>>>//                End_Object
73886>>>//
73886>>>// *** To use the pbRestoreIntFilesNow & pbSaveIntFilesNow properties, the pbUseIntFilesBackup property needs to be True.
73886>>>//     Sample Code:
73886>>>//                Object oApplication is a cApplication
73886>>>//                    Set peHelpType to htHtmlHelp
73886>>>//                
73886>>>//                    Object oConnection is a cConnection
73886>>>//                        Use LoginEncryption.pkg
73886>>>//                        Use DatabaseLoginDialog.dg
73886>>>//                    End_Object
73886>>>//                
73886>>>//                    Property Boolean pbRestoreIntFilesNow False
73886>>>//                    Property Boolean pbSaveIntFilesNow False
73886>>>//                    // This allows the program to have the parameter "-restore" passed on the command line.
73886>>>//                    // If found, it will call the "RestoreIntFiles" of the cDbUpdateHandler object.
73886>>>//                    Procedure OnCreate
73886>>>//                        Handle hoCmdLine
73886>>>//                        Integer iSize iCount
73886>>>//                        String sParam
73886>>>//                        
73886>>>//                        Get phoCommandLine to hoCmdLine
73886>>>//                        Get CountOfArgs of hoCmdLine to iSize
73886>>>//                        For iCount from 1 to iSize
73886>>>//                            Get Argument of hoCmdLine iCount to sParam
73886>>>//                            If (Lowercase(sParam) contains "restore") Begin
73886>>>//                                Set pbRestoreIntFilesNow to True
73886>>>//                            End
73886>>>//                            Else If (Lowercase(sParam) contains "save") Begin
73886>>>//                                Set pbSaveIntFilesNow to True
73886>>>//                            End
73886>>>//                        Loop
73886>>>//                    End_Procedure
73886>>>//                
73886>>>//                End_Object
73886>>>//
73886>>>//                Object oDbUpdateHandler is a cDbUpdateHandler
73886>>>//                    Set piDbVersionFileNumber  to 255
73886>>>//                    Set piDbVersionFieldNumber to 1
73886>>>//                    Set piIntFilesFileNumber to 256
73886>>>//                    Set pbUseIntFilesBackup to True
73886>>>//                    Set pbExitIfDebuggerActive to False
73886>>>//                
73886>>>//                    Procedure OnCreate
73886>>>//                        String sVersionInfo sErrorText
73886>>>//                        Boolean bRestoreIntFilesNow bSaveIntFilesNow bOK
73886>>>//                        
73886>>>//                        Get pbRestoreIntFilesNow of ghoApplication to bRestoreIntFilesNow
73886>>>//                        If (bRestoreIntFilesNow = True) Begin
73886>>>//                            Get RestoreIntFiles (&sErrorText) to bOK
73886>>>//                        End
73886>>>//                        Get pbSaveIntFilesNow of ghoApplication to bSaveIntFilesNow
73886>>>//                        If (bSaveIntFilesNow = True) Begin
73886>>>//                            Get SaveUpdateIntFiles (&sErrorText) to bOK
73886>>>//                        End 
73886>>>//                        
73886>>>//                        // To check for correct the driver and db client versions, when the program starts (each-Time it is started!)
73886>>>//                        Get MinMSSQLDRV_And_ClientVersion "24.0.29.10" SQLSERVER2019CLIENT True True to sVersionInfo
73886>>>//                    End_Procedure
73886>>>// ******************
73886>>>
73886>>>
73886>>>
73886>>>//
73886>>>// $Rev History:
73886>>>//    2016-09-27  Module header created
73886>>>//    2016-09-28  Removed the Master/Alias logic. All update code must
73886>>>//                take place before any tables have been opened, or errors
73886>>>//                could occur if the client database is out of sync with the
73886>>>//                compiled program.
73886>>>//                Added user counting checks + lockout while database is being
73886>>>//                updated.
73886>>>//    2016-10-03  Changed the class name from cDatabaseUpdateHandler to cDbUpdateHandler,
73886>>>//                as it is more in line with the child class cDbUpdateVersion name.
73886>>>//    2016-10-06  Moved constant declarations, structs etc. to separate cDbUpdateHandler.inc file
73886>>>//****************************************************************************
73886>>>Use VdfBase.pkg
73886>>>Use Dferror.pkg
73886>>>Use seq_chnl.pkg
73886>>>Use Datadict.pkg
73886>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
73886>>>>>// *** The Database Update Framework Include file for Languages ***
73886>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
73886>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
73886>>>>>//
73886>>>>>Use LanguageText.Pkg
73886>>>>>
73886>>>>>    // *** cSQLConnectionsIniFile.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
73886>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
73886>>>>>    // *** cSQLConnectionsHandler.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_SetupErrorcConnection     for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
73886>>>>>    Define CS_DUF_CannotLoginToServer       for "Could not login to the database server. Can't continue. Program will now exit."
73886>>>>>    Define CS_DUF_ErrorText                 for "\n\nError Text:"
73886>>>>>    // *** cDbUpdateFunctionLibrary.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_ConnectError              for "SQL error. Could not connect to the SQL database manager"
73886>>>>>    Define CS_DUF_AttachError               for "Could not attach to the database:"
73886>>>>>    Define CS_DUF_DeletingIndex             for "Deleting index"
73886>>>>>    Define CS_DUF_CopyingData               for "Copying data"
73886>>>>>    Define CS_DUF_CreatingIndex             for "Creating index"
73886>>>>>    Define CS_DUF_LoginToDbServerFailed     for  "Login failed to the database server. The following connect string was used:\n"
73886>>>>>    Define CS_DUF_DoYouWantToExit           for "Do you want to stop the database update and exit?"  
73886>>>>>    Define CS_DUF_NoIntFilesFound           for "No .int files found! Nothing was changed."
73886>>>>>    // *** cDbUpdateVersion.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_UpdateVersion             for "Updating database"
73886>>>>>    Define CS_DUF_UpdateFromVersion         for "from version"
73886>>>>>    Define CS_DUF_UpdateToVersion           for "to version:"
73886>>>>>    Define CS_DUF_DbUpdateTableMissing      for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
73886>>>>>    // *** cDbUpdateHandler.inc Language Constants ***
73886>>>>>    Define CS_DUF_DatabaseInUseShort        for "There are others using the application/database. Are you sure you still want to update the database?"
73886>>>>>    Define CS_DUF_DatabaseNeedsUpdate       for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
73886>>>>>    Define CS_DUF_HeaderUpdateText          for "Important!"
73886>>>>>    Define CS_DUF_DatabaseInUseText         for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
73886>>>>>    Define CS_DUF_WorkingHeaderText         for "Working!"
73886>>>>>    Define CS_DUF_WorkingUpdateText         for "The database is being updated. Please wait..."
73886>>>>>    Define CS_DUF_DatabaseUpdatedText       for "Ready! The database was updated."
73886>>>>>    Define CS_DUF_DatabaseCheckedText       for "Ready! The database was checked but no updates was needed."
73886>>>>>    Define CS_DUF_DbUpdatedErrorText        for "One or more errors occured while the database was updated. Please check the logfile in the data-folder.\n\nThe program will now close."
73886>>>>>    Define CS_DUF_UpdateInProgressTxt       for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
73886>>>>>    // *** cDbUpdateHandler.pkg Class Language Constants ***
73886>>>>>    Define CS_DUF_DatabaseConnStringSpec    for "The database specified in the connection string: '"
73886>>>>>    Define CS_DUF_DatabaseDoesntExist       for "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit."
73886>>>>>    // *** cDbUpdateLogFile.pkg Class Language Constants ***   
73886>>>>>    Define CS_DUF_LogFileNotFound           for "Could not locate the log file:\n\n"
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>>>
73886>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
73886>>>>>// StatPnl.pkg - creates the standard status_panel object.
73886>>>>>//
73886>>>>>//
73886>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
73886>>>>>// invoke the standard status panel. The standard has always been that the package name
73886>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
73886>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
73886>>>>>// prior revisions has been replace with status panel that is part of the application.
73886>>>>>// This should work much better and faster than the old sentinel based solution.
73886>>>>>// While the way this operates has changed, the interface has not and therefore this should work
73886>>>>>// with most applications.
73886>>>>>//
73886>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
73886>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
73886>>>>>// a cleaner more robust interface.
73886>>>>>//
73886>>>>>//
73886>>>>>// Compatibility Note:
73886>>>>>//
73886>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
73886>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
73886>>>>>//
73886>>>>>// If for some reason you application will not work using this as a replacement for the old status
73886>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
73886>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
73886>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
73886>>>>>//
73886>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
73886>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
73886>>>>>//
73886>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
73886>>>>>// can still access the new object via the ghoStatusPanel handle.
73886>>>>>//
73886>>>>>//
73886>>>>>// Creating your own Status Panel objects
73886>>>>>//
73886>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
73886>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
73886>>>>>// with a different file and object name and direct your status panel request to the new object.
73886>>>>>//
73886>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
73886>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
73886>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
73886>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
73886>>>>>// e.g.
73886>>>>>//       Procedure UpdateStatusBar
73886>>>>>//           Send DoAdvance of oProgressBar
73886>>>>>//           Send ProcessEvents
73886>>>>>//       End_Procedure
73886>>>>>//
73886>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
73886>>>>>// messages this will be done for you.
73886>>>>>//
73886>>>>>// the standard Interface for status panels are:
73886>>>>>//
73886>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
73886>>>>>// Send Start_StatusPanel      - start the status panel
73886>>>>>// Send Stop_StatusPanel       - stop the status panel
73886>>>>>// Send Update_StatusPanel     - update the status panel's action area
73886>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
73886>>>>>//
73886>>>>>// Get/Set Caption_Text - updates the caption bar
73886>>>>>// Get/Set Title_Text   - updates the title area
73886>>>>>// Get/Set Message_Text - updates the Message area
73886>>>>>// Get/Set Action_Text  - updates the action area
73886>>>>>// Get/Set Button_Text  - updates the button area
73886>>>>>//
73886>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
73886>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
73886>>>>>//
73886>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
73886>>>>>Use cProcessStatusPanel.pkg
73886>>>>>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJSkinFramework.pkg)
73886>>>>>>>Use windows.pkg
73886>>>>>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJComSkinFramework.pkg)
73886>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v22.0.0\Bin\Codejock.SkinFramework.Unicode.x64.v22.0.0.ocx
73886>>>>>>>>>Use FlexCom20.pkg
73886>>>>>>>>>
73886>>>>>>>>>// Changes to Imported package
73886>>>>>>>>>//     OLEXTPxx to XTPxx
73886>>>>>>>>>//     OLExtpxx to xtpxx
73886>>>>>>>>>//     OLESkinFramework to SkinFramework
73886>>>>>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
73886>>>>>>>>>//     cCom classes to cCJ
73886>>>>>>>>>//     cCJAutomationObject back to cComAutomationObject
73886>>>>>>>>>//     cCJActiveXControl back to cComActiveXControl
73886>>>>>>>>>//     cCJSkinFramework to cCJComSkinFramework
73886>>>>>>>>>//     Use statements as noted below (classes moved to these files)
73886>>>>>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
73886>>>>>>>>>
73886>>>>>>>>>// These have been extracted from this class and moved into seperate packages
73886>>>>>>>>>// because other Codejock classes use these.
73886>>>>>>>>>Use cCJColorManager.pkg     // cCJColorManager
73886>>>>>>>>>
73886>>>>>>>>>
73886>>>>>>>>>Define SkinFrameworkApplyOptions for Integer
73886>>>>>>>>>    Define xtpSkinApplyMetrics for 1
73886>>>>>>>>>    Define xtpSkinApplyFrame for 2
73886>>>>>>>>>    Define xtpSkinApplyColors for 4
73886>>>>>>>>>    Define xtpSkinApplyMenus for 8
73886>>>>>>>>>
73886>>>>>>>>>// CLSID: {C0DE2200-28D7-4F2C-87A7-7266367B4655}
73886>>>>>>>>>// Dispatch interface for SkinFramework Control
73886>>>>>>>>>Class cCJ_DSkinFramework is a Mixin
73887>>>>>>>>>
73887>>>>>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
73889>>>>>>>>>        SkinFrameworkApplyOptions retVal
73889>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
73890>>>>>>>>>        Function_Return retVal
73891>>>>>>>>>    End_Function
73892>>>>>>>>>
73892>>>>>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
73894>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
73895>>>>>>>>>    End_Procedure
73896>>>>>>>>>
73896>>>>>>>>>    Function ComAutoApplyNewWindows Returns Boolean
73898>>>>>>>>>        Boolean retVal
73898>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
73899>>>>>>>>>        Function_Return retVal
73900>>>>>>>>>    End_Function
73901>>>>>>>>>
73901>>>>>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
73903>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
73904>>>>>>>>>    End_Procedure
73905>>>>>>>>>
73905>>>>>>>>>    Function ComAutoApplyNewThreads Returns Boolean
73907>>>>>>>>>        Boolean retVal
73907>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
73908>>>>>>>>>        Function_Return retVal
73909>>>>>>>>>    End_Function
73910>>>>>>>>>
73910>>>>>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
73912>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
73913>>>>>>>>>    End_Procedure
73914>>>>>>>>>
73914>>>>>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
73916>>>>>>>>>        Handle hDispatchDriver
73916>>>>>>>>>        Boolean retVal
73916>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73917>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73918>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
73919>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
73920>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
73921>>>>>>>>>        Function_Return retVal
73922>>>>>>>>>    End_Function
73923>>>>>>>>>
73923>>>>>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
73925>>>>>>>>>        Handle hDispatchDriver
73925>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73926>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73927>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73928>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
73929>>>>>>>>>    End_Procedure
73930>>>>>>>>>
73930>>>>>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
73932>>>>>>>>>        Handle hDispatchDriver
73932>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73933>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73934>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73935>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
73936>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
73937>>>>>>>>>    End_Procedure
73938>>>>>>>>>
73938>>>>>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
73940>>>>>>>>>        Handle hDispatchDriver
73940>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73941>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73942>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73943>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
73944>>>>>>>>>    End_Procedure
73945>>>>>>>>>
73945>>>>>>>>>    Procedure ComRemoveAllWindows
73947>>>>>>>>>        Handle hDispatchDriver
73947>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73948>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
73949>>>>>>>>>    End_Procedure
73950>>>>>>>>>
73950>>>>>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
73952>>>>>>>>>        Handle hDispatchDriver
73952>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73953>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73954>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
73955>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
73956>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
73957>>>>>>>>>    End_Procedure
73958>>>>>>>>>
73958>>>>>>>>>    Procedure ComRemoveWindowClass String llClassName
73960>>>>>>>>>        Handle hDispatchDriver
73960>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73961>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73962>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
73963>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
73964>>>>>>>>>    End_Procedure
73965>>>>>>>>>
73965>>>>>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
73967>>>>>>>>>        Handle hDispatchDriver
73967>>>>>>>>>        Variant retVal
73967>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73968>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73969>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
73970>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
73971>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
73972>>>>>>>>>        Function_Return retVal
73973>>>>>>>>>    End_Function
73974>>>>>>>>>
73974>>>>>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
73976>>>>>>>>>        Handle hDispatchDriver
73976>>>>>>>>>        Variant retVal
73976>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73977>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73978>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
73979>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
73980>>>>>>>>>        Function_Return retVal
73981>>>>>>>>>    End_Function
73982>>>>>>>>>
73982>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
73984>>>>>>>>>        Handle hDispatchDriver
73984>>>>>>>>>        OLE_COLOR retVal
73984>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73985>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73986>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
73987>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
73988>>>>>>>>>        Function_Return retVal
73989>>>>>>>>>    End_Function
73990>>>>>>>>>
73990>>>>>>>>>    Procedure ComExcludeModule String llModuleName
73992>>>>>>>>>        Handle hDispatchDriver
73992>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73993>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73994>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
73995>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
73996>>>>>>>>>    End_Procedure
73997>>>>>>>>>
73997>>>>>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
73999>>>>>>>>>        Handle hDispatchDriver
73999>>>>>>>>>        Variant retVal
73999>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74000>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74001>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
74002>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
74003>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
74004>>>>>>>>>        Function_Return retVal
74005>>>>>>>>>    End_Function
74006>>>>>>>>>
74006>>>>>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
74008>>>>>>>>>        Handle hDispatchDriver
74008>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74009>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74010>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74011>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
74012>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
74013>>>>>>>>>    End_Procedure
74014>>>>>>>>>
74014>>>>>>>>>    Procedure ComAboutBox
74016>>>>>>>>>        Handle hDispatchDriver
74016>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74017>>>>>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
74018>>>>>>>>>    End_Procedure
74019>>>>>>>>>End_Class
74020>>>>>>>>>
74020>>>>>>>>>// CLSID: {C0DE2200-4463-4030-B324-AC6A8075FEC8}
74020>>>>>>>>>// Event interface for SkinFramework Control
74020>>>>>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
74021>>>>>>>>>
74021>>>>>>>>>    Procedure RegisterComEvents
74023>>>>>>>>>    End_Procedure
74024>>>>>>>>>End_Class
74025>>>>>>>>>
74025>>>>>>>>>// CoClass
74025>>>>>>>>>// ProgID: Codejock.SkinFramework.22.0.0
74025>>>>>>>>>// CLSID: {C0DE2200-2217-42EE-B1B0-82C890431F17}
74025>>>>>>>>>// SkinFramework Control
74025>>>>>>>>>Class cCJComSkinFramework is a cComActiveXControl
74026>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFramework
74027>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
74028>>>>>>>>>
74028>>>>>>>>>    Procedure Construct_Object
74030>>>>>>>>>        Forward Send Construct_Object
74032>>>>>>>>>        Set psProgID to "{C0DE2200-2217-42EE-B1B0-82C890431F17}"
74033>>>>>>>>>        Set psEventId to "{C0DE2200-4463-4030-B324-AC6A8075FEC8}"
74034>>>>>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2022 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v22.0"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
74035>>>>>>>>>        Set peAutoCreate to acAutoCreate
74036>>>>>>>>>    End_Procedure
74037>>>>>>>>>End_Class
74038>>>>>>>>>
74038>>>>>>>>>// CLSID: {C0DE2200-CA9A-4AA9-8601-0AB7F551AA3D}
74038>>>>>>>>>// SkinFramework Global Settings
74038>>>>>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
74039>>>>>>>>>
74039>>>>>>>>>    Function ComLicense Returns String
74041>>>>>>>>>        String retVal
74041>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
74042>>>>>>>>>        Function_Return retVal
74043>>>>>>>>>    End_Function
74044>>>>>>>>>
74044>>>>>>>>>    Procedure Set ComLicense String value
74046>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
74047>>>>>>>>>    End_Procedure
74048>>>>>>>>>
74048>>>>>>>>>    Function ComTitle Returns String
74050>>>>>>>>>        String retVal
74050>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
74051>>>>>>>>>        Function_Return retVal
74052>>>>>>>>>    End_Function
74053>>>>>>>>>
74053>>>>>>>>>    Procedure Set ComTitle String value
74055>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
74056>>>>>>>>>    End_Procedure
74057>>>>>>>>>
74057>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74057>>>>>>>>>    Function ComUseLegacyCore Returns Boolean
74059>>>>>>>>>        Boolean retVal
74059>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to retVal
74060>>>>>>>>>        Function_Return retVal
74061>>>>>>>>>    End_Function
74062>>>>>>>>>
74062>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74062>>>>>>>>>    Procedure Set ComUseLegacyCore Boolean value
74064>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to value
74065>>>>>>>>>    End_Procedure
74066>>>>>>>>>
74066>>>>>>>>>    Function ComVersion Returns String
74068>>>>>>>>>        Handle hDispatchDriver
74068>>>>>>>>>        String retVal
74068>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74069>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
74070>>>>>>>>>        Function_Return retVal
74071>>>>>>>>>    End_Function
74072>>>>>>>>>
74072>>>>>>>>>    Function ComUnicode Returns Boolean
74074>>>>>>>>>        Handle hDispatchDriver
74074>>>>>>>>>        Boolean retVal
74074>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74075>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
74076>>>>>>>>>        Function_Return retVal
74077>>>>>>>>>    End_Function
74078>>>>>>>>>
74078>>>>>>>>>    Function ComOcxPath Returns String
74080>>>>>>>>>        Handle hDispatchDriver
74080>>>>>>>>>        String retVal
74080>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74081>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
74082>>>>>>>>>        Function_Return retVal
74083>>>>>>>>>    End_Function
74084>>>>>>>>>End_Class
74085>>>>>>>>>
74085>>>>>>>>>// CoClass
74085>>>>>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.22.0.0
74085>>>>>>>>>// CLSID: {C0DE2200-F744-4373-B38D-29CE83EF0EE5}
74085>>>>>>>>>// SkinFramework Global Settings
74085>>>>>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
74086>>>>>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
74087>>>>>>>>>
74087>>>>>>>>>    Procedure Construct_Object
74089>>>>>>>>>        Forward Send Construct_Object
74091>>>>>>>>>        Set psProgID to "{C0DE2200-F744-4373-B38D-29CE83EF0EE5}"
74092>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
74093>>>>>>>>>    End_Procedure
74094>>>>>>>>>End_Class
74095>>>>>>>>>
74095>>>>>>>>>// CLSID: {C0DE2200-1038-498E-A936-361F08B4C4AA}
74095>>>>>>>>>Class cCJSkinIniFile is a cComAutomationObject
74096>>>>>>>>>
74096>>>>>>>>>    Function ComColorScheme Returns String
74098>>>>>>>>>        String retVal
74098>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74099>>>>>>>>>        Function_Return retVal
74100>>>>>>>>>    End_Function
74101>>>>>>>>>
74101>>>>>>>>>    Procedure Set ComColorScheme String value
74103>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74104>>>>>>>>>    End_Procedure
74105>>>>>>>>>
74105>>>>>>>>>    Function ComFontSize Returns String
74107>>>>>>>>>        String retVal
74107>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74108>>>>>>>>>        Function_Return retVal
74109>>>>>>>>>    End_Function
74110>>>>>>>>>
74110>>>>>>>>>    Procedure Set ComFontSize String value
74112>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74113>>>>>>>>>    End_Procedure
74114>>>>>>>>>
74114>>>>>>>>>    Function ComIniFileName Returns String
74116>>>>>>>>>        String retVal
74116>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
74117>>>>>>>>>        Function_Return retVal
74118>>>>>>>>>    End_Function
74119>>>>>>>>>
74119>>>>>>>>>    Procedure Set ComIniFileName String value
74121>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
74122>>>>>>>>>    End_Procedure
74123>>>>>>>>>End_Class
74124>>>>>>>>>
74124>>>>>>>>>// CLSID: {C0DE2200-4834-499E-95B4-30E0C3F43A10}
74124>>>>>>>>>Class cCJSkinDescription is a cComAutomationObject
74125>>>>>>>>>
74125>>>>>>>>>    Function ComName Returns String
74127>>>>>>>>>        String retVal
74127>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74128>>>>>>>>>        Function_Return retVal
74129>>>>>>>>>    End_Function
74130>>>>>>>>>
74130>>>>>>>>>    Procedure Set ComName String value
74132>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74133>>>>>>>>>    End_Procedure
74134>>>>>>>>>
74134>>>>>>>>>    Function ComPath Returns String
74136>>>>>>>>>        String retVal
74136>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74137>>>>>>>>>        Function_Return retVal
74138>>>>>>>>>    End_Function
74139>>>>>>>>>
74139>>>>>>>>>    Procedure Set ComPath String value
74141>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74142>>>>>>>>>    End_Procedure
74143>>>>>>>>>
74143>>>>>>>>>    Function ComCount Returns Integer
74145>>>>>>>>>        Handle hDispatchDriver
74145>>>>>>>>>        Integer retVal
74145>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74146>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74147>>>>>>>>>        Function_Return retVal
74148>>>>>>>>>    End_Function
74149>>>>>>>>>
74149>>>>>>>>>    Function ComIniFile Integer llIndex Returns Variant
74151>>>>>>>>>        Handle hDispatchDriver
74151>>>>>>>>>        Variant retVal
74151>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74152>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74153>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74154>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74155>>>>>>>>>        Function_Return retVal
74156>>>>>>>>>    End_Function
74157>>>>>>>>>
74157>>>>>>>>>    Function Com_NewEnum Returns Variant
74159>>>>>>>>>        Handle hDispatchDriver
74159>>>>>>>>>        Variant retVal
74159>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74160>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74161>>>>>>>>>        Function_Return retVal
74162>>>>>>>>>    End_Function
74163>>>>>>>>>End_Class
74164>>>>>>>>>
74164>>>>>>>>>// CLSID: {C0DE2200-FB37-4B08-A2B9-F6F8B253D697}
74164>>>>>>>>>Class cCJSkinDescriptions is a cComAutomationObject
74165>>>>>>>>>
74165>>>>>>>>>    Function ComCount Returns Integer
74167>>>>>>>>>        Handle hDispatchDriver
74167>>>>>>>>>        Integer retVal
74167>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74168>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74169>>>>>>>>>        Function_Return retVal
74170>>>>>>>>>    End_Function
74171>>>>>>>>>
74171>>>>>>>>>    Function ComSkin Integer llIndex Returns Variant
74173>>>>>>>>>        Handle hDispatchDriver
74173>>>>>>>>>        Variant retVal
74173>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74174>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74175>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74176>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74177>>>>>>>>>        Function_Return retVal
74178>>>>>>>>>    End_Function
74179>>>>>>>>>
74179>>>>>>>>>    Function Com_NewEnum Returns Variant
74181>>>>>>>>>        Handle hDispatchDriver
74181>>>>>>>>>        Variant retVal
74181>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74182>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74183>>>>>>>>>        Function_Return retVal
74184>>>>>>>>>    End_Function
74185>>>>>>>>>End_Class
74186>>>>>>>>>
74186>>>>>>>>>// CLSID: {C0DE2200-C56F-43C0-BCF1-8193B35FE4C4}
74186>>>>>>>>>Class cCJSkinSchema is a cComAutomationObject
74187>>>>>>>>>
74187>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
74189>>>>>>>>>        Handle hDispatchDriver
74189>>>>>>>>>        OLE_COLOR retVal
74189>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74190>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74191>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74192>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
74193>>>>>>>>>        Function_Return retVal
74194>>>>>>>>>    End_Function
74195>>>>>>>>>End_Class
74196>>>>>>>Use cApplication.pkg
74196>>>>>>>
74196>>>>>>>Struct tSkinInformation
74196>>>>>>>    String sName     // description of the skin
74196>>>>>>>    String sSkinfile // file path. Can be relative or full
74196>>>>>>>    String sSkinIni  // section name
74196>>>>>>>End_Struct
74196>>>>>>>
74196>>>>>>>
74196>>>>>>>Class cCJSkinFramework is a cCJComSkinFramework
74197>>>>>>>    
74197>>>>>>>    Procedure Construct_Object
74199>>>>>>>        Forward Send Construct_Object
74201>>>>>>>        
74201>>>>>>>        Property String psSkinFile ""
74202>>>>>>>        Property String psSkinIni ""
74203>>>>>>>        Property Boolean pbLoadPreference False
74204>>>>>>>        
74204>>>>>>>        Set peAutoCreate to acAutoCreate
74205>>>>>>>        
74205>>>>>>>        Move Self to ghoSkinFramework
74206>>>>>>>    End_Procedure
74207>>>>>>>    
74207>>>>>>>    // return the default skin path, which is the programs directory.
74207>>>>>>>    // This requires an application object.
74207>>>>>>>    // If you want to different skin path, override this.
74207>>>>>>>    Function SkinPath Returns String
74209>>>>>>>        String sPath sPaths
74209>>>>>>>        Handle hoWorkspace
74209>>>>>>>        If ghoApplication Begin
74211>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
74212>>>>>>>            Get psProgramPath of hoWorkspace to sPaths
74213>>>>>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
74214>>>>>>>        End
74214>>>>>>>>
74214>>>>>>>        Else Begin
74215>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74216>>>>>>>>
74216>>>>>>>        End
74216>>>>>>>>
74216>>>>>>>        Function_Return sPath
74217>>>>>>>    End_Function
74218>>>>>>>    
74218>>>>>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
74218>>>>>>>    // returns itself. If it is not, it uses SkinPath to get the path.
74218>>>>>>>    Function SkinQFile Returns String
74220>>>>>>>        String sFile sPath sSep
74220>>>>>>>        Boolean bQualified
74220>>>>>>>        Get psSkinFile to sFile
74221>>>>>>>        If not (IsFileNameQualified(sFile)) Begin
74223>>>>>>>            Get SkinPath to sPath
74224>>>>>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74225>>>>>>>            Move (sPath - sSep - sFile) to sFile
74226>>>>>>>        End
74226>>>>>>>>
74226>>>>>>>        Function_Return sFile
74227>>>>>>>    End_Function
74228>>>>>>>    
74228>>>>>>>    // defines the default VDF window class mapping.
74228>>>>>>>    Procedure OnAddVDFWindowClasses
74230>>>>>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
74231>>>>>>>        Send ComAddWindowClass "DFentry"                 "Edit"
74232>>>>>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
74233>>>>>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
74234>>>>>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
74235>>>>>>>        Send ComAddWindowClass "DFformlist"              "Edit"
74236>>>>>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
74237>>>>>>>        Send ComAddWindowClass "DFbutton"                "Button"
74238>>>>>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
74239>>>>>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
74240>>>>>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
74241>>>>>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
74242>>>>>>>        Send ComAddWindowClass "DFedit"                  "edit"
74243>>>>>>>        Send ComAddWindowClass "DFlistedit"              "edit"
74244>>>>>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
74245>>>>>>>        Send ComAddWindowClass "DFgroup"                 "Button"
74246>>>>>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
74247>>>>>>>        // External class
74247>>>>>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
74248>>>>>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
74249>>>>>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
74250>>>>>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
74251>>>>>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
74252>>>>>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
74253>>>>>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
74254>>>>>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
74255>>>>>>>    End_Procedure
74256>>>>>>>    
74256>>>>>>>    // Used to support developer designed class mappings (e.g. COM controls)
74256>>>>>>>    Procedure OnAddCustomWindowClasses
74258>>>>>>>    End_Procedure
74259>>>>>>>    
74259>>>>>>>    // called when object is created during end_construct_object.
74259>>>>>>>    Procedure OnCreate
74261>>>>>>>        Integer iOpts
74261>>>>>>>        Boolean bUseWindowsFont
74261>>>>>>>        Forward Send OnCreate
74263>>>>>>>        
74263>>>>>>>        // if we are using the windows fonts we will disable the apply metrics which
74263>>>>>>>        // never really looked good anyway. This test only exists or legacy purposes
74263>>>>>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
74264>>>>>>>        If bUseWindowsFont Begin
74266>>>>>>>            Get ComApplyOptions to iOpts
74267>>>>>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
74268>>>>>>>        End
74268>>>>>>>>
74268>>>>>>>        
74268>>>>>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
74268>>>>>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
74268>>>>>>>        // and this was the suggested workaround.
74268>>>>>>>        Set ComAutoApplyNewThreads to False
74269>>>>>>>        
74269>>>>>>>        Send OnAddVDFWindowClasses
74270>>>>>>>        Send OnAddCustomWindowClasses
74271>>>>>>>        
74271>>>>>>>        // if preferences are used, it will set psSkinFile and psSkinIni
74271>>>>>>>        If (pbLoadPreference(Self)) Begin
74273>>>>>>>            Send LoadSkinPreference
74274>>>>>>>        End
74274>>>>>>>>
74274>>>>>>>        // if a skin file name exists, we apply the skin.
74274>>>>>>>        If (psSkinFile(Self)<>"") Begin
74276>>>>>>>            Send ApplySkin
74277>>>>>>>        End
74277>>>>>>>>
74277>>>>>>>    End_Procedure
74278>>>>>>>    
74278>>>>>>>    // called by framework as part of application exit.
74278>>>>>>>    Procedure Broadcast_Notify_Exit_Application
74280>>>>>>>        Send Notify_Exit_Application
74281>>>>>>>    End_Procedure
74282>>>>>>>    
74282>>>>>>>    Procedure Notify_Exit_Application
74284>>>>>>>        If (pbLoadPreference(Self)) Begin
74286>>>>>>>            Send SaveSkinPreference
74287>>>>>>>        End
74287>>>>>>>>
74287>>>>>>>    End_Procedure
74288>>>>>>>    
74288>>>>>>>    Procedure NotifyPreApplySkin
74290>>>>>>>        Broadcast Send OnPreApplySkin of Desktop True
74292>>>>>>>    End_Procedure
74293>>>>>>>    
74293>>>>>>>    Procedure NotifyPostApplySkin
74295>>>>>>>        Broadcast Send OnPostApplySkin of Desktop True
74297>>>>>>>    End_Procedure
74298>>>>>>>    
74298>>>>>>>    // returns an array of all skins in the path. If path is "", use the default path.
74298>>>>>>>    // If the default path is used, returns the file names as relative names, else use full path.
74298>>>>>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
74300>>>>>>>        tSkinInformation[] Skins
74300>>>>>>>        tSkinInformation[] Skins
74301>>>>>>>        String sSkinName sSkinFile sDefaultPath sSep
74301>>>>>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
74301>>>>>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
74301>>>>>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
74301>>>>>>>        Integer iPos iDfltLen
74301>>>>>>>        Boolean bUseRelativePath
74301>>>>>>>        
74301>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74302>>>>>>>        
74302>>>>>>>        Get SkinPath to sDefaultPath
74303>>>>>>>        If (sPath="") Begin
74305>>>>>>>            Move sDefaultPath to sPath
74306>>>>>>>        End
74306>>>>>>>>
74306>>>>>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
74307>>>>>>>        Move (Length(sDefaultPath)) to iDfltLen
74308>>>>>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
74309>>>>>>>        
74309>>>>>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
74310>>>>>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
74312>>>>>>>            
74312>>>>>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
74313>>>>>>>            Get Create U_cCJSkinDescription to hSkinDescription
74314>>>>>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
74315>>>>>>>            
74315>>>>>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
74316>>>>>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
74317>>>>>>>            
74317>>>>>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
74323>>>>>>>>
74323>>>>>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
74324>>>>>>>                Set pvComObject of hSkinDescription to vSkinDescription
74325>>>>>>>                
74325>>>>>>>                Get ComCount of hSkinDescription to iNumSkins
74326>>>>>>>                
74326>>>>>>>                For iSkinsCount from 0 to (iNumSkins-1)
74332>>>>>>>>
74332>>>>>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
74333>>>>>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
74334>>>>>>>                    
74334>>>>>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
74335>>>>>>>                    Get ComPath of hSkinDescription to sSkinFile
74336>>>>>>>                    If bUseRelativePath Begin
74338>>>>>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
74339>>>>>>>                        If iPos Begin
74341>>>>>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
74342>>>>>>>                            While (Left(sSkinFile,1)=sSep)
74346>>>>>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
74347>>>>>>>                            Loop
74348>>>>>>>>
74348>>>>>>>                        End
74348>>>>>>>>
74348>>>>>>>                    End
74348>>>>>>>>
74348>>>>>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
74349>>>>>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
74350>>>>>>>                    
74350>>>>>>>                    Increment iArrayItem
74351>>>>>>>                Loop
74352>>>>>>>>
74352>>>>>>>            Loop
74353>>>>>>>>
74353>>>>>>>            
74353>>>>>>>            Send Destroy of hSkinDescriptions
74354>>>>>>>            Send Destroy of hSkinDescription
74355>>>>>>>            Send Destroy of hSkinIniFile
74356>>>>>>>            
74356>>>>>>>        End
74356>>>>>>>>
74356>>>>>>>        Function_Return Skins
74357>>>>>>>    End_Function
74358>>>>>>>    
74358>>>>>>>    // Save the skin preference. This requires an application object.
74358>>>>>>>    // Only do this if the application object allows it.
74358>>>>>>>    // This is called during startup if pbLoadPreference is True
74358>>>>>>>    // Suitable for override
74358>>>>>>>    Procedure SaveSkinPreference
74360>>>>>>>        String sSkin sIni
74360>>>>>>>        If ghoApplication Begin
74362>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74364>>>>>>>                Get psSkinFile to sSkin
74365>>>>>>>                Get psSkinIni to sIni
74366>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
74367>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
74368>>>>>>>            End
74368>>>>>>>>
74368>>>>>>>        End
74368>>>>>>>>
74368>>>>>>>        Else Begin
74369>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74370>>>>>>>>
74370>>>>>>>        End
74370>>>>>>>>
74370>>>>>>>    End_Procedure
74371>>>>>>>    
74371>>>>>>>    // Load the skin preference. This requires an application object.
74371>>>>>>>    // Only do this if the application object allows it.
74371>>>>>>>    // This is called during startup if pbLoadPreference is True
74371>>>>>>>    // Suitable for override
74371>>>>>>>    Procedure LoadSkinPreference
74373>>>>>>>        String sSkin sIni
74373>>>>>>>        Boolean bExists
74373>>>>>>>        If ghoApplication Begin
74375>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74377>>>>>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
74378>>>>>>>                If bExists Begin
74380>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
74381>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
74382>>>>>>>                    Set psSkinFile to sSkin
74383>>>>>>>                    Set psSkinIni to sIni
74384>>>>>>>                End
74384>>>>>>>>
74384>>>>>>>            End
74384>>>>>>>>
74384>>>>>>>        End
74384>>>>>>>>
74384>>>>>>>        Else Begin
74385>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74386>>>>>>>>
74386>>>>>>>        End
74386>>>>>>>>
74386>>>>>>>    End_Procedure
74387>>>>>>>    
74387>>>>>>>    // Can be called to apply the current skin.
74387>>>>>>>    Procedure ApplySkin
74389>>>>>>>        Boolean bOk
74389>>>>>>>        String sSkin sIni
74389>>>>>>>        If (IsComObjectCreated(Self)) Begin
74391>>>>>>>            Get SkinQFile to sSkin
74392>>>>>>>            Get psSkinIni to sIni
74393>>>>>>>            
74393>>>>>>>            Send NotifyPreApplySkin
74394>>>>>>>            // when skins are used we don't want to use built in Visual Styles
74394>>>>>>>            Send EnableVisualStyles of Desktop (sSkin="")
74395>>>>>>>            Get ComLoadSkin sSkin sIni to bOK
74396>>>>>>>            If (sSkin<>"" and not(bOk)) Begin
74398>>>>>>>                // if not ok, no skin was appied. Enable visual styles
74398>>>>>>>                Send EnableVisualStyles of Desktop True
74399>>>>>>>            End
74399>>>>>>>>
74399>>>>>>>            Send NotifyPostApplySkin
74400>>>>>>>        End
74400>>>>>>>>
74400>>>>>>>    End_Procedure
74401>>>>>>>    
74401>>>>>>>    
74401>>>>>>>End_Class
74402>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cProgressBar.pkg)
74402>>>>>>>Use Windows.pkg
74402>>>>>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cWinControl.pkg)
74402>>>>>>>>>Use Windows.pkg
74402>>>>>>>>>
74402>>>>>>>>>// Key State Masks for Mouse Messages
74402>>>>>>>>>
74402>>>>>>>>>Define MK_LBUTTON  for |CI$0001
74402>>>>>>>>>Define MK_RBUTTON  for |CI$0002
74402>>>>>>>>>Define MK_SHIFT    for |CI$0004
74402>>>>>>>>>Define MK_CONTROL  for |CI$0008
74402>>>>>>>>>Define MK_MBUTTON  for |CI$0010
74402>>>>>>>>>Define MK_XBUTTON1 for |CI$0020
74402>>>>>>>>>Define MK_XBUTTON2 for |CI$0040
74402>>>>>>>>>
74402>>>>>>>>>Enum_List // Mouse Key Flags
74402>>>>>>>>>    Define mkLeft    for MK_LBUTTON
74402>>>>>>>>>    Define mkMiddle  for MK_MBUTTON
74402>>>>>>>>>    Define mkRight   for MK_RBUTTON
74402>>>>>>>>>    Define mkX1      for MK_XBUTTON1
74402>>>>>>>>>    Define mkX2      for MK_XBUTTON2
74402>>>>>>>>>    Define mkShift   for MK_SHIFT
74402>>>>>>>>>    Define mkControl for MK_CONTROL
74402>>>>>>>>>End_Enum_List
74402>>>>>>>>>
74402>>>>>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
74402>>>>>>>>>    Define mbLeft
74402>>>>>>>>>    Define mbMiddle
74402>>>>>>>>>    Define mbRight
74402>>>>>>>>>    Define mbX1
74402>>>>>>>>>    Define mbX2
74402>>>>>>>>>End_Enum_List
74402>>>>>>>>>
74402>>>>>>>>>Class cWinControl is a DfBaseControl
74403>>>>>>>>>    Procedure Construct_Object
74405>>>>>>>>>        Forward Send Construct_Object
74407>>>>>>>>>        Property Integer private_pbEnabled True
74408>>>>>>>>>        Property Integer private_pbVisible True
74409>>>>>>>>>    End_Procedure
74410>>>>>>>>>    
74410>>>>>>>>>    Procedure End_Construct_Object
74412>>>>>>>>>        Forward Send End_Construct_Object
74414>>>>>>>>>        
74414>>>>>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
74415>>>>>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
74416>>>>>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
74417>>>>>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
74418>>>>>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
74419>>>>>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
74420>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
74421>>>>>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
74422>>>>>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
74423>>>>>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
74424>>>>>>>>>    End_Procedure
74425>>>>>>>>>    
74425>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
74427>>>>>>>>>        //Intentionally cancelled
74427>>>>>>>>>    End_Procedure
74428>>>>>>>>>    
74428>>>>>>>>>    Procedure Command Longptr wParam Longptr lParam
74430>>>>>>>>>        //Intentionally cancelled
74430>>>>>>>>>    End_Procedure
74431>>>>>>>>>    
74431>>>>>>>>>    Procedure DoRecreateWindow
74433>>>>>>>>>        // Recreates the window
74433>>>>>>>>>        If (Window_Handle(Self)) Begin
74435>>>>>>>>>            // attempt to do this without disturbing the focus tree.
74435>>>>>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
74436>>>>>>>>>            Send Page 1      //                       Send Page_Object 1
74437>>>>>>>>>        End
74437>>>>>>>>>>
74437>>>>>>>>>    End_Procedure
74438>>>>>>>>>    
74438>>>>>>>>>    Procedure DoUpdateWindow
74440>>>>>>>>>        // Forces windows to update the window by bypassing WM_PAINT
74440>>>>>>>>>        Handle hWnd
74440>>>>>>>>>        
74440>>>>>>>>>        Get Window_Handle to hWnd
74441>>>>>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
74444>>>>>>>>>    End_Procedure
74445>>>>>>>>>    
74445>>>>>>>>>    Procedure Page Integer iState
74447>>>>>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
74448>>>>>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
74449>>>>>>>>>        Forward Send Page iState
74451>>>>>>>>>    End_Procedure
74452>>>>>>>>>    
74452>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
74454>>>>>>>>>        Integer x y eButton
74454>>>>>>>>>        
74454>>>>>>>>>        Move (Hi(lParam))  to y
74455>>>>>>>>>        Move (Low(lParam)) to x
74456>>>>>>>>>        
74456>>>>>>>>>        Send OnMouseUp mbLeft x y wParam
74457>>>>>>>>>    End_Procedure
74458>>>>>>>>>    
74458>>>>>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
74460>>>>>>>>>        Integer x y eButton
74460>>>>>>>>>        
74460>>>>>>>>>        Move (Hi(lParam))  to y
74461>>>>>>>>>        Move (Low(lParam)) to x
74462>>>>>>>>>        
74462>>>>>>>>>        Send OnMouseUp mbMiddle x y wParam
74463>>>>>>>>>    End_Procedure
74464>>>>>>>>>    
74464>>>>>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
74466>>>>>>>>>        Integer x y eButton
74466>>>>>>>>>        
74466>>>>>>>>>        Move (Hi(lParam))  to y
74467>>>>>>>>>        Move (Low(lParam)) to x
74468>>>>>>>>>        
74468>>>>>>>>>        Send OnMouseUp mbRight x y wParam
74469>>>>>>>>>    End_Procedure
74470>>>>>>>>>    
74470>>>>>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
74472>>>>>>>>>        Integer x y eButton fKeys
74472>>>>>>>>>        
74472>>>>>>>>>        Move (Hi(lParam))  to y
74473>>>>>>>>>        Move (Low(lParam)) to x
74474>>>>>>>>>        
74474>>>>>>>>>        Send OnMouseDown mbLeft x y wParam
74475>>>>>>>>>    End_Procedure
74476>>>>>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
74478>>>>>>>>>        Integer x y eButton
74478>>>>>>>>>        
74478>>>>>>>>>        Move (Hi(lParam))  to y
74479>>>>>>>>>        Move (Low(lParam)) to x
74480>>>>>>>>>        
74480>>>>>>>>>        Send OnMouseDown mbMiddle x y wParam
74481>>>>>>>>>    End_Procedure
74482>>>>>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
74484>>>>>>>>>        Integer x y eButton
74484>>>>>>>>>        
74484>>>>>>>>>        Move (Hi(lParam))  to y
74485>>>>>>>>>        Move (Low(lParam)) to x
74486>>>>>>>>>        
74486>>>>>>>>>        Send OnMouseDown mbRight x y wParam
74487>>>>>>>>>    End_Procedure
74488>>>>>>>>>    
74488>>>>>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
74490>>>>>>>>>        Integer x y eButton
74490>>>>>>>>>        
74490>>>>>>>>>        Move (Hi(lParam))  to y
74491>>>>>>>>>        Move (Low(lParam)) to x
74492>>>>>>>>>        
74492>>>>>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
74493>>>>>>>>>    End_Procedure
74494>>>>>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
74496>>>>>>>>>        Integer x y eButton
74496>>>>>>>>>        
74496>>>>>>>>>        Move (Hi(lParam))  to y
74497>>>>>>>>>        Move (Low(lParam)) to x
74498>>>>>>>>>        
74498>>>>>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
74499>>>>>>>>>    End_Procedure
74500>>>>>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
74502>>>>>>>>>        Integer x y eButton
74502>>>>>>>>>        
74502>>>>>>>>>        Move (Hi(lParam))  to y
74503>>>>>>>>>        Move (Low(lParam)) to x
74504>>>>>>>>>        
74504>>>>>>>>>        Send OnMouseDoubleClick mbRight x y wParam
74505>>>>>>>>>    End_Procedure
74506>>>>>>>>>    
74506>>>>>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
74508>>>>>>>>>        Integer x y eButton
74508>>>>>>>>>        
74508>>>>>>>>>        Move (Hi(lParam))  to y
74509>>>>>>>>>        Move (Low(lParam)) to x
74510>>>>>>>>>        
74510>>>>>>>>>        Send OnMouseMove x y wParam
74511>>>>>>>>>    End_Procedure
74512>>>>>>>>>    
74512>>>>>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
74514>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74514>>>>>>>>>        //String sButton
74514>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74514>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74514>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74514>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74514>>>>>>>>>        
74514>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74514>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74514>>>>>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74514>>>>>>>>>    End_Procedure
74515>>>>>>>>>    
74515>>>>>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
74517>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74517>>>>>>>>>        //String sButton
74517>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74517>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74517>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74517>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74517>>>>>>>>>        
74517>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74517>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74517>>>>>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74517>>>>>>>>>    End_Procedure
74518>>>>>>>>>    
74518>>>>>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
74520>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74520>>>>>>>>>        //String sButton
74520>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74520>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74520>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74520>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74520>>>>>>>>>        
74520>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74520>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74520>>>>>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74520>>>>>>>>>    End_Procedure
74521>>>>>>>>>    
74521>>>>>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
74523>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74523>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74523>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74523>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74523>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74523>>>>>>>>>        
74523>>>>>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74523>>>>>>>>>    End_Procedure
74524>>>>>>>>>    
74524>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
74526>>>>>>>>>        Handle hWnd
74526>>>>>>>>>        
74526>>>>>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
74528>>>>>>>>>            Set private_pbEnabled to bEnabled
74529>>>>>>>>>            Get Window_Handle to hWnd
74530>>>>>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
74533>>>>>>>>>        End
74533>>>>>>>>>>
74533>>>>>>>>>    End_Procedure
74534>>>>>>>>>    Function pbEnabled Returns Boolean
74536>>>>>>>>>        Function_Return (private_pbEnabled(Self))
74537>>>>>>>>>    End_Function
74538>>>>>>>>>    
74538>>>>>>>>>    Procedure Set pbVisible Boolean bVisible
74540>>>>>>>>>        Handle  hWnd
74540>>>>>>>>>        Integer iVoid
74540>>>>>>>>>        
74540>>>>>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
74542>>>>>>>>>            Set private_pbVisible to bVisible
74543>>>>>>>>>            Get Window_Handle to hWnd
74544>>>>>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
74547>>>>>>>>>        End
74547>>>>>>>>>>
74547>>>>>>>>>    End_Procedure
74548>>>>>>>>>    Function pbVisible Returns Boolean
74550>>>>>>>>>        Function_Return (private_pbVisible(Self))
74551>>>>>>>>>    End_Function
74552>>>>>>>>>    
74552>>>>>>>>>End_Class
74553>>>>>>>Use CommCtrl.pkg
74553>>>>>>>
74553>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
74553>>>>>>>Class cProgressBar is a cWinControl
74554>>>>>>>    
74554>>>>>>>    Procedure Construct_Object
74556>>>>>>>        Forward Send Construct_Object
74558>>>>>>>        Property Integer private_piMinimum
74559>>>>>>>        Property Integer private_piMaximum   100
74560>>>>>>>        Property Integer private_piAdvanceBy 10
74561>>>>>>>        Property Integer private_piPosition
74562>>>>>>>        Property Integer private_pbVertical  False
74563>>>>>>>        Property Integer private_pbSmooth    False
74564>>>>>>>        Property Integer private_piBackColor clDefault
74565>>>>>>>        Property Integer private_piBarColor  clDefault
74566>>>>>>>        
74566>>>>>>>        Send Define_ToolTip_Support_Mixin
74567>>>>>>>        
74567>>>>>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
74568>>>>>>>        Set Focus_Mode to NonFocusable
74569>>>>>>>        Set Skip_State to True
74570>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
74571>>>>>>>    End_Procedure
74572>>>>>>>    
74572>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
74573>>>>>>>    
74573>>>>>>>    Procedure Set piMinimum Integer iMin
74575>>>>>>>        Integer iMax
74575>>>>>>>        
74575>>>>>>>        Set private_piMinimum to iMin
74576>>>>>>>        Get private_piMaximum to iMax
74577>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74578>>>>>>>    End_Procedure
74579>>>>>>>    Function piMinimum Returns Integer
74581>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
74584>>>>>>>        Else;            Function_Return (private_piMinimum(Self))
74586>>>>>>>    End_Function
74587>>>>>>>    
74587>>>>>>>    Procedure Set piMaximum Integer iMax
74589>>>>>>>        Integer iMin
74589>>>>>>>        
74589>>>>>>>        Set private_piMaximum to iMax
74590>>>>>>>        Get private_piMinimum to iMin
74591>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74592>>>>>>>    End_Procedure
74593>>>>>>>    Function piMaximum Returns Integer
74595>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
74598>>>>>>>        Else;            Function_Return (private_piMaximum(Self))
74600>>>>>>>    End_Function
74601>>>>>>>    
74601>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
74603>>>>>>>        Set private_piAdvanceBy to iAdvanceBy
74604>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
74605>>>>>>>    End_Procedure
74606>>>>>>>    Function piAdvanceBy Returns Integer
74608>>>>>>>        Function_Return (private_piAdvanceBy(Self))
74609>>>>>>>    End_Function
74610>>>>>>>    
74610>>>>>>>    Procedure Set piPosition Integer iPos
74612>>>>>>>        Set private_piPosition to iPos
74613>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
74614>>>>>>>    End_Procedure
74615>>>>>>>    
74615>>>>>>>    Function piPosition Returns Integer
74617>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
74620>>>>>>>        Else;            Function_Return (private_piPosition(Self))
74622>>>>>>>    End_Function
74623>>>>>>>    
74623>>>>>>>    Procedure Set pbVertical Boolean bVertical
74625>>>>>>>        If (private_pbVertical(Self) <> bVertical) Begin
74627>>>>>>>            Set private_pbVertical to bVertical
74628>>>>>>>            Send DoRecreateWindow
74629>>>>>>>        End
74629>>>>>>>>
74629>>>>>>>    End_Procedure
74630>>>>>>>    
74630>>>>>>>    Function pbVertical Returns Boolean
74632>>>>>>>        Function_Return (private_pbVertical(Self))
74633>>>>>>>    End_Function
74634>>>>>>>    
74634>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
74636>>>>>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
74638>>>>>>>            Set private_pbSmooth to bSmooth
74639>>>>>>>            Send DoRecreateWindow
74640>>>>>>>        End
74640>>>>>>>>
74640>>>>>>>    End_Procedure
74641>>>>>>>    Function pbSmooth Returns Boolean
74643>>>>>>>        Function_Return (private_pbSmooth(Self))
74644>>>>>>>    End_Function
74645>>>>>>>    
74645>>>>>>>    Procedure Set piBackColor Integer rgbColor
74647>>>>>>>        Set private_piBackColor to rgbColor
74648>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
74649>>>>>>>    End_Procedure
74650>>>>>>>    Function piBackColor Returns Integer
74652>>>>>>>        Function_Return (private_piBackColor(Self))
74653>>>>>>>    End_Function
74654>>>>>>>    
74654>>>>>>>    Procedure Set piBarColor Integer rgbColor
74656>>>>>>>        Set private_piBarColor to rgbColor
74657>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
74658>>>>>>>    End_Procedure
74659>>>>>>>    Function piBarColor Returns Integer
74661>>>>>>>        Function_Return (private_piBarColor(Self))
74662>>>>>>>    End_Function
74663>>>>>>>    
74663>>>>>>>    Procedure DoAdvance
74665>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
74666>>>>>>>    End_Procedure
74667>>>>>>>    
74667>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
74669>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
74670>>>>>>>    End_Procedure
74671>>>>>>>    
74671>>>>>>>    Procedure private_DoInitWindow
74673>>>>>>>        Set piBarColor  to (private_piBarColor(Self))
74674>>>>>>>        Set piBackColor to (private_piBackColor(Self))
74675>>>>>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
74676>>>>>>>        Set piMinimum   to (private_piMinimum(Self))
74677>>>>>>>        Set piMaximum   to (private_piMaximum(Self))
74678>>>>>>>        Set piPosition  to (private_piPosition(Self))
74679>>>>>>>    End_Procedure
74680>>>>>>>    
74680>>>>>>>    Procedure Page_Object Integer iState
74682>>>>>>>        Handle hWnd
74682>>>>>>>        
74682>>>>>>>        Get Window_Handle to hWnd
74683>>>>>>>        If (hWnd=0 and iState) Begin
74685>>>>>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
74686>>>>>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
74687>>>>>>>            Forward Send Page_Object True
74689>>>>>>>        End
74689>>>>>>>>
74689>>>>>>>        Else ;            Forward Send Page_Object iState
74692>>>>>>>        
74692>>>>>>>        // Handle tooltip support....
74692>>>>>>>        If (iState = 0) Begin
74694>>>>>>>            Send RequestDeleteToolTip
74695>>>>>>>        End
74695>>>>>>>>
74695>>>>>>>        Else Begin
74696>>>>>>>            Send RequestAddToolTip
74697>>>>>>>        End
74697>>>>>>>>
74697>>>>>>>    End_Procedure
74698>>>>>>>    
74698>>>>>>>    Procedure Page Integer iState
74700>>>>>>>        Forward Send Page iState
74702>>>>>>>        If (iState =1);            Send private_DoInitWindow
74705>>>>>>>    End_Procedure
74706>>>>>>>    
74706>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
74706>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
74706>>>>>>>    // is implemented in a mixin class.
74706>>>>>>>    Procedure RequestAddToolTip
74708>>>>>>>        Send AddToolTip
74709>>>>>>>    End_Procedure
74710>>>>>>>    
74710>>>>>>>    
74710>>>>>>>    // Called by Page_Object. Handles tooltip removal.
74710>>>>>>>    Procedure RequestDeleteToolTip
74712>>>>>>>        Send DeleteToolTip
74713>>>>>>>    End_Procedure
74714>>>>>>>End_Class
74715>>>>>Use Windows.pkg
74715>>>>>Use DUFLanguageConstants.inc
74715>>>>>Use Statpnl.pkg
74715>>>>>
74715>>>>>
74715>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
74715>>>>>
74715>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
74715>>>>>
74715>>>>>Object Status_Panel is a cProcessStatusPanel
74717>>>>>    Set Size to 152 222
74718>>>>>    Set Border_Style to Border_Dialog
74719>>>>>    Set Icon to "Default.ico"
74720>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
74721>>>>>
74721>>>>>    Property Boolean Cancel_Button_Visible_State True
74723>>>>>
74723>>>>>    Procedure Activate
74726>>>>>        Integer iSizeBefore
74726>>>>>        Get GuiSize to iSizeBefore
74727>>>>>        Forward Send Activate
74729>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
74730>>>>>    End_Procedure
74731>>>>>
74731>>>>>    Procedure End_Construct_Object
74734>>>>>        Forward Send End_Construct_Object
74736>>>>>        Set Label of oTitleTxt      to ""
74737>>>>>        Set Label of oTableNameTxt  to ""
74738>>>>>        Set Label of oMessageTxt    to ""
74739>>>>>        Set Label of oActionTxt     to ""
74740>>>>>    End_Procedure
74741>>>>>
74741>>>>>    Object oTitleTxt is a TextBox
74743>>>>>        Set Location to 5 21
74744>>>>>        Set Size to 8 179
74745>>>>>        Set Auto_Size_State to False
74746>>>>>        Set Justification_Mode  to jMode_Center
74747>>>>>        Set Label to "This is the Title Text"
74748>>>>>    End_Object
74749>>>>>
74749>>>>>    Object oTableNameTxt is a TextBox
74751>>>>>        Set Size to 19 204
74752>>>>>        Set Location to 18 9
74753>>>>>        Set Auto_Size_State to False
74754>>>>>        Set Justification_Mode to JMode_Left
74755>>>>>        Set Label to "This is the TableName Text"
74756>>>>>    End_Object
74757>>>>>
74757>>>>>    Object oMessageTxt is a TextBox
74759>>>>>        Set Location to 39 9
74760>>>>>        Set Size to 19 204
74761>>>>>        Set Auto_Size_State to False
74762>>>>>        Set Justification_Mode to JMode_Left
74763>>>>>        Set Label to "This is the Message text"
74764>>>>>    End_Object
74765>>>>>
74765>>>>>    Object oActionTxt is a TextBox
74767>>>>>        Set Size to 16 204
74768>>>>>        Set Location to 60 9
74769>>>>>        Set Auto_Size_State to False
74770>>>>>        Set Justification_Mode to JMode_Left
74771>>>>>        Set Label to "This is the Action Text"
74772>>>>>    End_Object
74773>>>>>
74773>>>>>    Object oStopButton is a Button
74775>>>>>        Set Location to 123 82
74776>>>>>        Set Label to C_$Cancel
74777>>>>>
74777>>>>>        Procedure OnClick 
74780>>>>>            Integer iRetval
74780>>>>>            Get YesNo_Box CS_DUF_DoYouWantToExit to iRetval
74781>>>>>            If (iRetval = MBR_Yes) Begin
74783>>>>>                Send Exit_Application
74784>>>>>            End
74784>>>>>>
74784>>>>>        End_Procedure
74785>>>>>
74785>>>>>    End_Object
74786>>>>>
74786>>>>>    Object oPercentage_tb is a TextBox
74788>>>>>        Set Location to 74 196
74789>>>>>        Set Size to 10 25
74790>>>>>//        Set Label to "% Done"
74790>>>>>    End_Object
74791>>>>>
74791>>>>>    Object oCopyRight is a TextBox
74793>>>>>        Set Location to 140 21
74794>>>>>        Set Size to 9 197
74795>>>>>        Set FontPointHeight to 8
74796>>>>>        Set Auto_Size_State to False
74797>>>>>        Set Justification_Mode  to jMode_Center
74798>>>>>        Set Label to "Copyright 2001-2024 RDC Tools International"
74799>>>>>    End_Object
74800>>>>>
74800>>>>>    Object oProgressBar is a cProgressBar
74802>>>>>        Set Size to 10 179
74803>>>>>        Set Location to 83 22
74804>>>>>        Set pbVisible to True // default
74805>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
74806>>>>>    End_Object
74807>>>>>
74807>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
74810>>>>>        Set pbVisible of ghoProgressBar to bVisible
74811>>>>>    End_Procedure
74812>>>>>
74812>>>>>    Function Progress_Bar_Visible_State Returns Boolean
74815>>>>>        Boolean bVisible
74815>>>>>        Get pbVisible of ghoProgressBar to bVisible
74816>>>>>        Function_Return (bVisible)
74817>>>>>    End_Function
74818>>>>>
74818>>>>>    Object oProgressBarOverall is a cProgressBar
74820>>>>>        Set Size to 10 179
74821>>>>>        Set Location to 107 22
74822>>>>>        Set pbVisible to True // default
74823>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
74824>>>>>    End_Object
74825>>>>>
74825>>>>>    Object oOverallProgress_tb is a TextBox
74827>>>>>        Set Size to 10 65
74828>>>>>        Set Location to 95 24
74829>>>>>        Set Label to "Overall Progress"
74830>>>>>    End_Object
74831>>>>>
74831>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
74834>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible 
74835>>>>>        Set Visible_State of oOverallProgress_tb to bVisible
74836>>>>>    End_Procedure
74837>>>>>
74837>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
74840>>>>>        Boolean bVisible
74840>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
74841>>>>>        Function_Return (bVisible)
74842>>>>>    End_Function
74843>>>>>
74843>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
74843>>>>>    // objects defined within this instance of the status panel.
74843>>>>>
74843>>>>>    // note: all of the messages that change text should be forwarded
74843>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
74843>>>>>
74843>>>>>    Procedure Set Message_Text String sText
74846>>>>>        Set Label of oMessageTxt to sText
74847>>>>>        Forward Set Message_Text to sText
74849>>>>>    End_Procedure
74850>>>>>
74850>>>>>    Function Message_Text Returns String
74853>>>>>        Function_Return (Label(oMessageTxt))
74854>>>>>    End_Function
74855>>>>>
74855>>>>>    Procedure Set Action_Text String sText
74858>>>>>        Set Label of oActionTxt to sText
74859>>>>>        Forward Set Action_Text to sText
74861>>>>>    End_Procedure
74862>>>>>
74862>>>>>    Function Action_Text Returns String
74865>>>>>        Function_Return (Label(oActionTxt))
74866>>>>>    End_Function
74867>>>>>
74867>>>>>    Procedure Set Button_Text String sText
74870>>>>>        Set Label of oStopButton to sText
74871>>>>>        Forward Set Button_Text to sText
74873>>>>>    End_Procedure
74874>>>>>
74874>>>>>    Function Button_Text Returns String
74877>>>>>        Function_Return (Label(oStopButton))
74878>>>>>    End_Function
74879>>>>>
74879>>>>>    Procedure Set Title_Text String sText
74882>>>>>        Set Label of oTitleTxt to sText
74883>>>>>        Forward Set Title_Text to sText
74885>>>>>    End_Procedure
74886>>>>>
74886>>>>>    Function Title_Text Returns String
74889>>>>>        Function_Return (Label(oTitleTxt))
74890>>>>>    End_Function
74891>>>>>
74891>>>>>    Procedure Set TableName_Text String sText
74894>>>>>        Set Label of oTableNameTxt to sText
74895>>>>>    End_Procedure
74896>>>>>
74896>>>>>    Function TableName_Text Returns String
74899>>>>>        Function_Return (Label(oTableNameTxt))
74900>>>>>    End_Function
74901>>>>>
74901>>>>>    Procedure Set License_Text String sText
74904>>>>>//        Set Label of oLicense_txt to sText
74904>>>>>    End_Procedure 
74905>>>>>    
74905>>>>>    Procedure Set piMaximum Integer iSize
74908>>>>>        Set piMaximum of ghoProgressBar to iSize
74909>>>>>    End_Procedure  
74910>>>>>    
74910>>>>>    Procedure Set piAdvanceBy Integer iCount
74913>>>>>        Set piAdvanceBy of ghoProgressBar to iCount
74914>>>>>    End_Procedure
74915>>>>>
74915>>>>>    Procedure DoAdvance
74918>>>>>        Send DoAdvance of ghoProgressBar
74919>>>>>    End_Procedure
74920>>>>>
74920>>>>>    Procedure Set piPosition Integer iPos
74923>>>>>        Set piPosition of ghoProgressBar to iPos
74924>>>>>    End_Procedure
74925>>>>>    
74925>>>>>    // gets called when status panel is activated passing whether a button
74925>>>>>    // should appear
74925>>>>>    Procedure EnableCancelButton Boolean bEnable
74928>>>>>        Boolean bVisible
74928>>>>>        Get Cancel_Button_Visible_State to bVisible
74929>>>>>        If (bEnable = False) Begin
74931>>>>>            Set Visible_State of oStopButton to bVisible
74932>>>>>        End
74932>>>>>>
74932>>>>>        Set Enabled_State of oStopButton to bEnable
74933>>>>>    End_Procedure
74934>>>>>
74934>>>>>    Procedure Reset_StatusPanel
74937>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
74938>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
74939>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
74940>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
74941>>>>>    End_Procedure
74942>>>>>
74942>>>>>//    Object oProgressBar is a cProgressBar
74942>>>>>//        Move Self to ghoProgressBar
74942>>>>>//        Set Location to 1 25
74942>>>>>//        Set Size to 9 173
74942>>>>>//        Set piMinimum        to 0
74942>>>>>//        Set piMaximum        to 2000
74942>>>>>//        Set piAdvanceBy      to 100
74942>>>>>//        Set pbSmooth to True
74942>>>>>//
74942>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
74942>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
74942>>>>>//        // color will show correctly.
74942>>>>>//        Procedure Page Integer iPageObject
74942>>>>>//            Handle hWin
74942>>>>>//            Forward Send Page iPageObject
74942>>>>>//            If (ghoSkinFramework <> 0) Begin
74942>>>>>//                Get Window_Handle to hWin
74942>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
74942>>>>>//            End
74942>>>>>//        End_Procedure
74942>>>>>//    End_Object
74942>>>>>
74942>>>>>End_Object
74943>>>>>
74943>>>Use cDbUpdateHandler.inc // Contains cDbUpdateHandler class constants, structs etc.
Including file: cDbUpdateHandler.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.inc)
74943>>>>>// Constant declarations, structs etc. for the cDbUdpateHandler class.
74943>>>>>//
74943>>>>>Use VdfBase.pkg
74943>>>>>Use cApplication.pkg
74943>>>>>Use seq_chnl.pkg
74943>>>>>Use vWin32fh.pkg
Including file: vWin32fh.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vWin32fh.pkg)
74943>>>>>>>// This code is part of VDF GUIdance
74943>>>>>>>// Visit us @ http://www.vdf-guidance.com
74943>>>>>>>// e-Mail us @ info@vdf-guidance.com
74943>>>>>>>// VDF GUIdance is a mutual project of
74943>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
74943>>>>>>>// Wil van Antwerpen  - Antwise Solutions
74943>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
74943>>>>>>>//
74943>>>>>>>//
74943>>>>>>>// *** Windows 32bit file handling wrapper class ***
74943>>>>>>>//
74943>>>>>>>
74943>>>>>>>
74943>>>>>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
74943>>>>>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\cvFileDialogs.pkg)
74943>>>>>>>>>//***************************************************************************
74943>>>>>>>>>//*
74943>>>>>>>>>//* Class:        cvSaveAsDialog
74943>>>>>>>>>//* Package Name: cvFileDialogs.pkg
74943>>>>>>>>>//*
74943>>>>>>>>>//***************************************************************************
74943>>>>>>>>>
74943>>>>>>>>>Use File_dlg.pkg
74943>>>>>>>>>
74943>>>>>>>>>// *WvA: 13-01-1999 Created
74943>>>>>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
74943>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
74943>>>>>>>>>// file_name.
74943>>>>>>>>>Class cvSelectFile_Dialog is an OpenDialog
74944>>>>>>>>>
74944>>>>>>>>>    Procedure Construct_Object Integer iImage_Id
74946>>>>>>>>>        Forward Send Construct_Object iImage_Id
74948>>>>>>>>>        Set HideReadOnly_State to True
74949>>>>>>>>>    End_Procedure
74950>>>>>>>>>
74950>>>>>>>>>    Function SelectedFileName Returns String
74952>>>>>>>>>        String sFileName
74952>>>>>>>>>        Move "" to sFileName
74953>>>>>>>>>        If (Show_Dialog(Self)) Begin
74955>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
74956>>>>>>>>>        End
74956>>>>>>>>>>
74956>>>>>>>>>        Function_Return sFileName
74957>>>>>>>>>    End_Function
74958>>>>>>>>>End_Class
74959>>>>>>>>>
74959>>>>>>>>>// *WvA: 13-01-1999 Created
74959>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
74959>>>>>>>>>// file_name. Returns '' if the user didn't make a selection.
74959>>>>>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
74959>>>>>>>>>//                   file-open dialog
74959>>>>>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
74961>>>>>>>>>    String sSelectedFile
74961>>>>>>>>>    Integer hoOpenFileDialog
74961>>>>>>>>>
74961>>>>>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
74963>>>>>>>>>
74963>>>>>>>>>        Set Dialog_Caption    to sCaptionText
74964>>>>>>>>>        Set Filter_String     to sSupportedFileTypes
74965>>>>>>>>>        Set Initial_Folder    to sInitialFolder
74966>>>>>>>>>
74966>>>>>>>>>        Move Self       to hoOpenFileDialog
74967>>>>>>>>>    End_Object
74968>>>>>>>>>
74968>>>>>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
74969>>>>>>>>>    Send Destroy_Object to hoOpenFileDialog
74970>>>>>>>>>    Function_Return sSelectedFile
74971>>>>>>>>>End_Function
74972>>>>>>>>>
74972>>>>>>>>>Class cvSaveAsDialog is a SaveAsDialog
74973>>>>>>>>>
74973>>>>>>>>>    Procedure Construct_Object
74975>>>>>>>>>        Forward Send Construct_Object
74977>>>>>>>>>        Set HideReadOnly_State to True
74978>>>>>>>>>    End_Procedure
74979>>>>>>>>>
74979>>>>>>>>>    Function SelectedFileName Returns String
74981>>>>>>>>>        String sFileName
74981>>>>>>>>>        Move "" to sFileName
74982>>>>>>>>>        If (Show_Dialog(Self)) Begin
74984>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
74985>>>>>>>>>        End
74985>>>>>>>>>>
74985>>>>>>>>>        Function_Return sFileName
74986>>>>>>>>>    End_Function
74987>>>>>>>>>
74987>>>>>>>>>End_Class
74988>>>>>>>>>
74988>>>>>>>>>// Added optional default filename as suggested by Nils
74988>>>>>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
74990>>>>>>>>>    String sSelectedFile
74990>>>>>>>>>    Integer hoDialog
74990>>>>>>>>>
74990>>>>>>>>>    Move "" to sSelectedFile
74991>>>>>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
74992>>>>>>>>>    If (hoDialog) Begin
74994>>>>>>>>>    //Set NoChangeDir_State Of hoDialog To True
74994>>>>>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
74995>>>>>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
74996>>>>>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
74997>>>>>>>>>        If (Num_Arguments = 4) Begin
74999>>>>>>>>>            Set File_Title        of hoDialog to sDefaultFileName
75000>>>>>>>>>        End
75000>>>>>>>>>>
75000>>>>>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
75001>>>>>>>>>        Send Destroy of hoDialog
75002>>>>>>>>>    End
75002>>>>>>>>>>
75002>>>>>>>>>    Function_Return sSelectedFile
75003>>>>>>>>>End_Function
75004>>>>>>>Use Seq_chnl.pkg
75004>>>>>>>
75004>>>>>>>Use windows.pkg
75004>>>>>>>Use Dll.pkg
75004>>>>>>>
75004>>>>>>>Use vWin32fhW.pkg     // WinAPI Unicode version
Including file: vwin32fhW.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fhW.pkg)
75004>>>>>>>>>// This code is part of VDF GUIdance
75004>>>>>>>>>// Visit us @ http://www.vdf-guidance.com
75004>>>>>>>>>// e-Mail us @ info@vdf-guidance.com
75004>>>>>>>>>// VDF GUIdance is a mutual project of
75004>>>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
75004>>>>>>>>>// Wil van Antwerpen  - Antwise Solutions
75004>>>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
75004>>>>>>>>>//
75004>>>>>>>>>//
75004>>>>>>>>>// *** Windows 32bit file handling wrapper class ***
75004>>>>>>>>>// Unicode variant
75004>>>>>>>>>
75004>>>>>>>>>Use vWin32fhW.h       // Header file with WinAPI Unicode declarations
Including file: vwin32fhW.h    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fhW.h)
75004>>>>>>>>>>>//TH-Header
75004>>>>>>>>>>>//*****************************************************************************************
75004>>>>>>>>>>>// Copyright (c)  2004 KURANT Project
75004>>>>>>>>>>>// All rights reserved.
75004>>>>>>>>>>>//
75004>>>>>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
75004>>>>>>>>>>>// $ProjectName : Windows 32 bits file handling
75004>>>>>>>>>>>// $Authors     : Wil van Antwerpen
75004>>>>>>>>>>>// $Created     : 19.02.2004  19:25
75004>>>>>>>>>>>// $Type        : BSD (as in do with it whatever you like)
75004>>>>>>>>>>>//
75004>>>>>>>>>>>// Contents:
75004>>>>>>>>>>>//  This file contains the Windows API external function call definitions and
75004>>>>>>>>>>>//  constants as they are used in the vWin32fh package.
75004>>>>>>>>>>>//*****************************************************************************************
75004>>>>>>>>>>>//TH-RevisionStart
75004>>>>>>>>>>>//TH-RevisionEnd
75004>>>>>>>>>>>
75004>>>>>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
75004>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
75004>>>>>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
75004>>>>>>>>>>>
75004>>>>>>>>>>>
75004>>>>>>>>>>>Define vMax_Path     For |CI260
75004>>>>>>>>>>>Define vMinChar      For |CI$80
75004>>>>>>>>>>>Define vMaxChar      For |CI$7F
75004>>>>>>>>>>>Define vMinShort     For |CI$8000
75004>>>>>>>>>>>Define vMaxShort     For |CI$7FFF
75004>>>>>>>>>>>Define vMinLong      For |CI$80000000
75004>>>>>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
75004>>>>>>>>>>>Define vMaxByte      For |CI$FF
75004>>>>>>>>>>>Define vMaxWord      For |CI$FFFF
75004>>>>>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
75004>>>>>>>>>>>
75004>>>>>>>>>>>
75004>>>>>>>>>>>
75004>>>>>>>>>>>// For FindFirstFile
75004>>>>>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
75004>>>>>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
75004>>>>>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
75004>>>>>>>>>>>
75004>>>>>>>>>>>// The defines below can be used to find out what kind of error has occurred if
75004>>>>>>>>>>>// the API-call ShellExecute is used.
75004>>>>>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
75004>>>>>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
75004>>>>>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
75004>>>>>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
75004>>>>>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
75004>>>>>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
75004>>>>>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
75004>>>>>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
75004>>>>>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
75004>>>>>>>>>>>Define vSE_ERR_FNF             For |CI0002
75004>>>>>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
75004>>>>>>>>>>>Define vSE_ERR_OOM             For |CI0008
75004>>>>>>>>>>>Define vSE_ERR_PNF             For |CI0003
75004>>>>>>>>>>>Define vSE_ERR_SHARE           For |CI0026
75004>>>>>>>>>>>
75004>>>>>>>>>>>
75004>>>>>>>>>>>// C-Structure
75004>>>>>>>>>>>//typedef struct _browseinfo {
75004>>>>>>>>>>>//    HWND hwndOwner;
75004>>>>>>>>>>>//    LPCITEMIDLIST pidlRoot;
75004>>>>>>>>>>>//    LPSTR pszDisplayName;
75004>>>>>>>>>>>//    LPCSTR lpszTitle;
75004>>>>>>>>>>>//    UINT ulFlags;
75004>>>>>>>>>>>//    BFFCALLBACK lpfn;
75004>>>>>>>>>>>//    LPARAM lParam;
75004>>>>>>>>>>>//    int iImage;
75004>>>>>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
75004>>>>>>>>>>>
75004>>>>>>>>>>>//declare C structure struct_browseinfo
75004>>>>>>>>>>>//as documented in MSDN under Windows Shell API
75004>>>>>>>>>>>Struct tvBrowseInfo
75004>>>>>>>>>>>  Handle    hWndOwner
75004>>>>>>>>>>>  Pointer   pIDLRoot
75004>>>>>>>>>>>  Pointer   pszDisplayName
75004>>>>>>>>>>>  Pointer   lpszTitle
75004>>>>>>>>>>>  DWord     ulFlags
75004>>>>>>>>>>>    DWord   BrowseInfoMissingAlignment1
75004>>>>>>>>>>>  Pointer   lpfnCallback
75004>>>>>>>>>>>  LongPtr   lParam
75004>>>>>>>>>>>  DWord     iImage
75004>>>>>>>>>>>    DWord   BrowseInfoMissingAlignment2
75004>>>>>>>>>>>End_Struct // tvBrowseInfo
75004>>>>>>>>>>>
75004>>>>>>>>>>>// Browsing for directory.
75004>>>>>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
75004>>>>>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
75004>>>>>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
75004>>>>>>>>>>>                                            // The callback function can set the status text by
75004>>>>>>>>>>>                                            // sending messages to the dialog box.
75004>>>>>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
75004>>>>>>>>>>>
75004>>>>>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
75004>>>>>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
75004>>>>>>>>>>>
75004>>>>>>>>>>>// message from browser
75004>>>>>>>>>>>//Define BFFM_INITIALIZED        1
75004>>>>>>>>>>>//Define BFFM_SELCHANGED         2
75004>>>>>>>>>>>
75004>>>>>>>>>>>// messages to browser
75004>>>>>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
75004>>>>>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
75004>>>>>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
75004>>>>>>>>>>>
75004>>>>>>>>>>>
75004>>>>>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolderW" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
75005>>>>>>>>>>>
75005>>>>>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDListW" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
75006>>>>>>>>>>>
75006>>>>>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
75007>>>>>>>>>>>
75007>>>>>>>>>>>
75007>>>>>>>>>>>
75007>>>>>>>>>>>
75007>>>>>>>>>>>Struct tvSecurity_attributes
75007>>>>>>>>>>>  DWord   nLength
75007>>>>>>>>>>>    DWord   Security_attributesMissingAlignment1
75007>>>>>>>>>>>  Pointer lpDescriptor
75007>>>>>>>>>>>  Integer bInheritHandle
75007>>>>>>>>>>>    Integer Security_attributesMissingAlignment2
75007>>>>>>>>>>>End_Struct // tvSecurity_attributes
75007>>>>>>>>>>>
75007>>>>>>>>>>>//nLength:
75007>>>>>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
75007>>>>>>>>>>>// SECURITY_ATTRIBUTES structure.
75007>>>>>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
75007>>>>>>>>>>>// value of the nLength member. However, an application should still set it properly.
75007>>>>>>>>>>>// That ensures current, future, and cross-platform compatibility.
75007>>>>>>>>>>>//
75007>>>>>>>>>>>//lpSecurityDescriptor:
75007>>>>>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
75007>>>>>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
75007>>>>>>>>>>>// descriptor of the calling process.
75007>>>>>>>>>>>//
75007>>>>>>>>>>>//bInheritHandle:
75007>>>>>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
75007>>>>>>>>>>>// If this member is TRUE, the new process inherits the handle.
75007>>>>>>>>>>>
75007>>>>>>>>>>>
75007>>>>>>>>>>>// BOOL CreateDirectory(
75007>>>>>>>>>>>//    LPCTSTR lpPathName,
75007>>>>>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
75007>>>>>>>>>>>//   );
75007>>>>>>>>>>>//
75007>>>>>>>>>>>// lpPathName
75007>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
75007>>>>>>>>>>>//  to be created.
75007>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
75007>>>>>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
75007>>>>>>>>>>>// lpSecurityAttributes
75007>>>>>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
75007>>>>>>>>>>>//  determines whether the returned handle can be inherited by child processes.
75007>>>>>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
75007>>>>>>>>>>>// Returns:
75007>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
75007>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
75007>>>>>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryW" kernel32.dll ;  WString sPathName Pointer lpSecurity_Attributes Returns Integer
75008>>>>>>>>>>>
75008>>>>>>>>>>>
75008>>>>>>>>>>>// lpPathName
75008>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
75008>>>>>>>>>>>//  to be removed.
75008>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
75008>>>>>>>>>>>// Returns:
75008>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
75008>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
75008>>>>>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryW" kernel32.dll ;  WString sPathName Returns Integer
75009>>>>>>>>>>>
75009>>>>>>>>>>>
75009>>>>>>>>>>>
75009>>>>>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
75009>>>>>>>>>>>// executable file or a document file.
75009>>>>>>>>>>>//
75009>>>>>>>>>>>// Operation can be one of the following:
75009>>>>>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
75009>>>>>>>>>>>//            The file can be an executable file or a document file.
75009>>>>>>>>>>>//            The file can be a folder to open.
75009>>>>>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
75009>>>>>>>>>>>//            The file should be a document file. If the file is an executable file,
75009>>>>>>>>>>>//            the function opens the file, as if "open" had been specified.
75009>>>>>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
75009>>>>>>>>>>>//
75009>>>>>>>>>>>// Return Values:
75009>>>>>>>>>>>//
75009>>>>>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
75009>>>>>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
75009>>>>>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
75009>>>>>>>>>>>//
75009>>>>>>>>>>>// The following table lists these error values:
75009>>>>>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
75009>>>>>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
75009>>>>>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
75009>>>>>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
75009>>>>>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
75009>>>>>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
75009>>>>>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
75009>>>>>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
75009>>>>>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
75009>>>>>>>>>>>// Public Const SE_ERR_FNF = 2
75009>>>>>>>>>>>// Public Const SE_ERR_NOASSOC = 31
75009>>>>>>>>>>>// Public Const SE_ERR_OOM = 8
75009>>>>>>>>>>>// Public Const SE_ERR_PNF = 3
75009>>>>>>>>>>>// Public Const SE_ERR_SHARE = 26
75009>>>>>>>>>>>
75009>>>>>>>>>>>
75009>>>>>>>>>>>
75009>>>>>>>>>>>// Code to open the program that is associated with the selected file.
75009>>>>>>>>>>>//
75009>>>>>>>>>>>// External function call used in Procedure DoStartDocument
75009>>>>>>>>>>>External_function vWin32_ShellExecute "ShellExecuteW" shell32.dll ;  Handle  hWnd ;  WString wsOperation ;  WString wsFile ;  WString wsParameters ;  WString wsDirectory ;  Dword   iShowCmd Returns Handle
75010>>>>>>>>>>>
75010>>>>>>>>>>>
75010>>>>>>>>>>>
75010>>>>>>>>>>>
75010>>>>>>>>>>>Define vFO_MOVE                For |CI$0001
75010>>>>>>>>>>>Define vFO_COPY                For |CI$0002
75010>>>>>>>>>>>Define vFO_DELETE              For |CI$0003
75010>>>>>>>>>>>Define vFO_RENAME              For |CI$0004
75010>>>>>>>>>>>
75010>>>>>>>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
75010>>>>>>>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
75010>>>>>>>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
75010>>>>>>>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
75010>>>>>>>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
75010>>>>>>>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
75010>>>>>>>>>>>                                          // Must be freed using SHFreeNameMappings
75010>>>>>>>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
75010>>>>>>>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
75010>>>>>>>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
75010>>>>>>>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
75010>>>>>>>>>>>
75010>>>>>>>>>>>Struct tvShFileOpStruct
75010>>>>>>>>>>>  Handle   hWnd
75010>>>>>>>>>>>  UInteger wFunc
75010>>>>>>>>>>>    UInteger ShFileOpStructMissingAlignment1
75010>>>>>>>>>>>  Pointer  pFrom
75010>>>>>>>>>>>  Pointer  pTo
75010>>>>>>>>>>>  Short    fFlags
75010>>>>>>>>>>>  Integer  fAnyOperationsAborted
75010>>>>>>>>>>>    Short  ShFileOpStructMissingAlignment2
75010>>>>>>>>>>>  Pointer  hNameMappings
75010>>>>>>>>>>>  Pointer  lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
75010>>>>>>>>>>>End_Struct // tvShFileOpStruct
75010>>>>>>>>>>>
75010>>>>>>>>>>>// hwnd
75010>>>>>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
75010>>>>>>>>>>>
75010>>>>>>>>>>>// wFunc
75010>>>>>>>>>>>//   Operation to perform. This member can be one of the following values:
75010>>>>>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
75010>>>>>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
75010>>>>>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
75010>>>>>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
75010>>>>>>>>>>>
75010>>>>>>>>>>>// pFrom
75010>>>>>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
75010>>>>>>>>>>>//   be null-separated. The list of names must be double null-terminated.
75010>>>>>>>>>>>
75010>>>>>>>>>>>// pTo
75010>>>>>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
75010>>>>>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
75010>>>>>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
75010>>>>>>>>>>>//   double null-terminated.
75010>>>>>>>>>>>
75010>>>>>>>>>>>// fAnyOperationsAborted
75010>>>>>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
75010>>>>>>>>>>>//   were completed or FALSE otherwise.
75010>>>>>>>>>>>
75010>>>>>>>>>>>
75010>>>>>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
75010>>>>>>>>>>>// This can be a file or a folder.
75010>>>>>>>>>>>// With thanks to Andrew S Kaplan
75010>>>>>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationW" Shell32.dll ;        Pointer lpFileOp Returns Integer
75011>>>>>>>>>>>
75011>>>>>>>>>>>
75011>>>>>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
75011>>>>>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryW" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
75012>>>>>>>>>>>
75012>>>>>>>>>>>
75012>>>>>>>>>>>
75012>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75012>>>>>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
75012>>>>>>>>>>>//   Pointer lpPathName ;
75012>>>>>>>>>>>//   Pointer lpPrefixString ;
75012>>>>>>>>>>>//   Integer uUnique ;
75012>>>>>>>>>>>//   Pointer lpTempFileName ;
75012>>>>>>>>>>>//   Returns Integer
75012>>>>>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
75012>>>>>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameW" kernel32.dll WString sPath ;        WString sPrefix Integer iUnique Pointer lpTempFileName Returns Integer
75013>>>>>>>>>>>
75013>>>>>>>>>>>External_function vWin32_GetTempPath "GetTempPathW" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
75014>>>>>>>>>>>
75014>>>>>>>>>>>External_function vWin32_DeleteFile "DeleteFileW" Kernel32.Dll ;   WString sFileName ;   Returns Integer
75015>>>>>>>>>>>
75015>>>>>>>>>>>// from:
75015>>>>>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
75015>>>>>>>>>>>//
75015>>>>>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
75015>>>>>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
75015>>>>>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
75015>>>>>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
75015>>>>>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
75015>>>>>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
75015>>>>>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
75015>>>>>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
75015>>>>>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
75015>>>>>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
75015>>>>>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
75015>>>>>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
75015>>>>>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
75015>>>>>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
75015>>>>>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
75015>>>>>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
75015>>>>>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
75015>>>>>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
75015>>>>>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
75015>>>>>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
75015>>>>>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
75015>>>>>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
75015>>>>>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
75015>>>>>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
75015>>>>>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
75015>>>>>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
75015>>>>>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
75015>>>>>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
75015>>>>>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
75015>>>>>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
75015>>>>>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
75015>>>>>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
75015>>>>>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
75015>>>>>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
75015>>>>>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
75015>>>>>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
75015>>>>>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
75015>>>>>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
75015>>>>>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
75015>>>>>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
75015>>>>>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
75015>>>>>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
75015>>>>>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
75015>>>>>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
75015>>>>>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
75015>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
75015>>>>>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
75015>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
75015>>>>>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
75015>>>>>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
75015>>>>>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
75015>>>>>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
75015>>>>>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
75015>>>>>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
75015>>>>>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
75015>>>>>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
75015>>>>>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
75015>>>>>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
75015>>>>>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
75015>>>>>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
75015>>>>>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
75015>>>>>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
75015>>>>>>>>>>>
75015>>>>>>>>>>>
75015>>>>>>>>>>>//HRESULT SHGetFolderPath(
75015>>>>>>>>>>>//    HWND hwndOwner,
75015>>>>>>>>>>>//    int nFolder,
75015>>>>>>>>>>>//    HANDLE hToken,
75015>>>>>>>>>>>//    DWORD dwFlags,
75015>>>>>>>>>>>//    LPTSTR pszPath
75015>>>>>>>>>>>//);
75015>>>>>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
75015>>>>>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
75015>>>>>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
75015>>>>>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
75015>>>>>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
75015>>>>>>>>>>>//
75015>>>>>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathW" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
75016>>>>>>>>>>>
75016>>>>>>>>>>>
75016>>>>>>>>>>>
75016>>>>>>>>>>>Struct tvWin32FindData
75016>>>>>>>>>>> Dword            dwFileAttributes
75016>>>>>>>>>>> Dword            ftCreationLowDateTime
75016>>>>>>>>>>> Dword            ftCreationHighDateTime
75016>>>>>>>>>>> dword            ftLastAccessLowDateTime
75016>>>>>>>>>>> Dword            ftLastAccessHighDateTime
75016>>>>>>>>>>> Dword            ftLastWriteLowDateTime
75016>>>>>>>>>>> Dword            ftLastWriteHighDateTime
75016>>>>>>>>>>> Dword            nFileSizeHigh
75016>>>>>>>>>>> Dword            nFileSizeLow
75016>>>>>>>>>>> Dword            dwReserved0
75016>>>>>>>>>>> Dword            dwReserved1
75016>>>>>>>>>>> Short[vMax_Path] cFileName
75016>>>>>>>>>>> Short[14]        cAlternateFileName
75016>>>>>>>>>>>End_Struct
75016>>>>>>>>>>>
75016>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75016>>>>>>>>>>>// lpFileName      : address of name of file to search for
75016>>>>>>>>>>>// lpFindFileData  : address of returned information
75016>>>>>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileW"  Kernel32.dll WString sFileName ;          Pointer lpFindFileData Returns Handle
75017>>>>>>>>>>>
75017>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75017>>>>>>>>>>>// hFindFile       : handle of search
75017>>>>>>>>>>>// lpFindFileData  : address of structure for data on found file
75017>>>>>>>>>>>External_function vWin32_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
75018>>>>>>>>>>>
75018>>>>>>>>>>>
75018>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75018>>>>>>>>>>>//  hFindFile      : file search handle
75018>>>>>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
75019>>>>>>>>>>>
75019>>>>>>>>>>>
75019>>>>>>>>>>>
75019>>>>>>>>>>>Struct tvFileTime
75019>>>>>>>>>>>  DWord dwLowDateTime
75019>>>>>>>>>>>  DWord dwHighDateTime
75019>>>>>>>>>>>End_Struct
75019>>>>>>>>>>>
75019>>>>>>>>>>>
75019>>>>>>>>>>>Struct tvSystemTime
75019>>>>>>>>>>>  UShort wYear
75019>>>>>>>>>>>  UShort wMonth
75019>>>>>>>>>>>  UShort wDayOfWeek
75019>>>>>>>>>>>  UShort wDay
75019>>>>>>>>>>>  UShort wHour
75019>>>>>>>>>>>  UShort wMinute
75019>>>>>>>>>>>  UShort wSecond
75019>>>>>>>>>>>  UShort wMilliSeconds
75019>>>>>>>>>>>End_Struct
75019>>>>>>>>>>>
75019>>>>>>>>>>>
75019>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75019>>>>>>>>>>>//  lpFileTime     : pointer to file time to convert
75019>>>>>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
75019>>>>>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
75020>>>>>>>>>>>
75020>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75020>>>>>>>>>>>// This function formats the time in a picture-string passed
75020>>>>>>>>>>>//
75020>>>>>>>>>>>// Picture      Meaning
75020>>>>>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
75020>>>>>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
75020>>>>>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
75020>>>>>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
75020>>>>>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
75020>>>>>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
75020>>>>>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
75020>>>>>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
75020>>>>>>>>>>>//    t         One character time marker string, such as A or P
75020>>>>>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
75020>>>>>>>>>>>//
75020>>>>>>>>>>>// For example, to get the time string  "11:29:40 PM"
75020>>>>>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
75020>>>>>>>>>>>
75020>>>>>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
75021>>>>>>>>>>>
75021>>>>>>>>>>>
75021>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75021>>>>>>>>>>>// This function formats the date in a picture-string passed
75021>>>>>>>>>>>//
75021>>>>>>>>>>>// Picture      Meaning
75021>>>>>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
75021>>>>>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
75021>>>>>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
75021>>>>>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
75021>>>>>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
75021>>>>>>>>>>>//              value associated with the specified locale.
75021>>>>>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
75021>>>>>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
75021>>>>>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
75021>>>>>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
75021>>>>>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
75021>>>>>>>>>>>//              associated with the specified locale.
75021>>>>>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
75021>>>>>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
75021>>>>>>>>>>>//    yyyy      Year represented hy full four digits.
75021>>>>>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
75021>>>>>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
75021>>>>>>>>>>>//              does not have an associated era or period string.
75021>>>>>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
75021>>>>>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
75021>>>>>>>>>>>
75021>>>>>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
75022>>>>>>>>>>>
75022>>>>>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
75022>>>>>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
75022>>>>>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
75022>>>>>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
75022>>>>>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
75022>>>>>>>>>>>
75022>>>>>>>>>>>//  Date Flags for GetDateFormatW.
75022>>>>>>>>>>>//
75022>>>>>>>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
75022>>>>>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
75022>>>>>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
75022>>>>>>>>>>>
75022>>>>>>>>>>>
75022>>>>>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
75023>>>>>>>>>>>
75023>>>>>>>>>>>
75023>>>>>>>>>>>// **WvA: 20-02-2004
75023>>>>>>>>>>>// While i was testing the format capabilities i stumbled over a very
75023>>>>>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
75023>>>>>>>>>>>// incorrectly into an unsigned integer.
75023>>>>>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
75023>>>>>>>>>>>// It does smell a bit fishy though
75023>>>>>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
75023>>>>>>>>>>>
75023>>>>>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
75023>>>>>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
75023>>>>>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
75023>>>>>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
75023>>>>>>>>>>>
75023>>>>>>>>>>>// Possible errors that can be returned by the shellformat function
75023>>>>>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
75023>>>>>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
75023>>>>>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
75023>>>>>>>>>>>
75023>>>>>>>>>>>
75023>>>>>>>>>>> // Courtesy Of Steve Walter,
75023>>>>>>>>>>> // USA Software, Inc
75023>>>>>>>>>>> // Format a disk
75023>>>>>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
75023>>>>>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
75024>>>>>>>>>>>
75024>>>>>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
75024>>>>>>>>>>>
75024>>>>>>>>>>>// SHCreateDirectoryEx
75024>>>>>>>>>>>
75024>>>>>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
75024>>>>>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
75024>>>>>>>>>>>//
75024>>>>>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
75024>>>>>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
75024>>>>>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
75024>>>>>>>>>>>//
75024>>>>>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
75024>>>>>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
75024>>>>>>>>>>>//        ERROR_CANCELLED.
75024>>>>>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
75024>>>>>>>>>>>
75024>>>>>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
75024>>>>>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
75024>>>>>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
75024>>>>>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
75024>>>>>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
75024>>>>>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
75024>>>>>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
75024>>>>>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
75024>>>>>>>>>>>
75024>>>>>>>>>>>//        int SHCreateDirectoryEx(
75024>>>>>>>>>>>//            HWND hwnd,
75024>>>>>>>>>>>//            LPCTSTR pszPath,
75024>>>>>>>>>>>//            const SECURITY_ATTRIBUTES *psa
75024>>>>>>>>>>>//        );
75024>>>>>>>>>>>
75024>>>>>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExW" shell32.dll Handle hWnd;                  WString wPath  Pointer lpSecurity_Attributes Returns Integer
75025>>>>>>>>>>>
75025>>>>>>>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryW" SHLWAPI.DLL WString wPath Returns Integer
75026>>>>>>>>>
75026>>>>>>>>>
75026>>>>>>>>>
75026>>>>>>>>>// Does the directory exist? - No = false, Yes = True
75026>>>>>>>>>// This also works with UNC path encoding and wildcards
75026>>>>>>>>>Function vFolderExists Global String sFolderName Returns Boolean
75028>>>>>>>>>    Boolean bFolderExists
75028>>>>>>>>>    Boolean bStop
75028>>>>>>>>>    String  sFolder sTmp
75028>>>>>>>>>    Integer iCh
75028>>>>>>>>>
75028>>>>>>>>>    If (sFolderName = "") Begin
75030>>>>>>>>>        Function_Return False
75031>>>>>>>>>    End
75031>>>>>>>>>>
75031>>>>>>>>>
75031>>>>>>>>>    Move True  to bFolderExists
75032>>>>>>>>>    Move False to bStop
75033>>>>>>>>>    Move "dir:" to sFolder
75034>>>>>>>>>    Append sFolder sFolderName
75035>>>>>>>>>    Get Seq_New_Channel to iCh  // get free channel for input
75036>>>>>>>>>    If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75038>>>>>>>>>        Error DFERR_PROGRAM "No I/O channel available for process (vFolderExists)"
75039>>>>>>>>>>
75039>>>>>>>>>        Function_Return False
75040>>>>>>>>>    End
75040>>>>>>>>>>
75040>>>>>>>>>    Direct_Input channel iCh sFolder
75042>>>>>>>>>    Repeat
75042>>>>>>>>>>
75042>>>>>>>>>        Readln channel iCh sTmp
75044>>>>>>>>>        Move (SeqEof) to bStop
75045>>>>>>>>>        If (Trim(sTmp)="") Begin
75047>>>>>>>>>            Move False to bFolderExists
75048>>>>>>>>>        End
75048>>>>>>>>>>
75048>>>>>>>>>        Else Begin
75049>>>>>>>>>            Move True to bFolderExists
75050>>>>>>>>>            Move True to bStop
75051>>>>>>>>>        End
75051>>>>>>>>>>
75051>>>>>>>>>    Until (bStop)
75053>>>>>>>>>    Close_Input channel iCh
75055>>>>>>>>>    Send Seq_Release_Channel iCh
75056>>>>>>>>>    Function_Return bFolderExists
75057>>>>>>>>>End_Function
75058>>>>>>>>>
75058>>>>>>>>>// returns folder name if a folder was selected, otherwise returns ""
75058>>>>>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
75060>>>>>>>>>    String  sPath
75060>>>>>>>>>    WString sFolder sTitle
75060>>>>>>>>>    Pointer lpItemIdList
75060>>>>>>>>>    Integer iFolderSelected iRetval
75060>>>>>>>>>    tvBrowseInfo BrowseInfo
75060>>>>>>>>>    tvBrowseInfo BrowseInfo
75060>>>>>>>>>
75060>>>>>>>>>    Move "" to sPath
75061>>>>>>>>>    If (sDialogTitle<>"") Begin
75063>>>>>>>>>        Move sDialogTitle to sTitle
75064>>>>>>>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
75064>>>>>>>>>        // disables showing some commonly used ascii characters like ascii 137 ()
75064>>>>>>>>>        // These chars are correctly shown if no toansi is used.
75064>>>>>>>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
75064>>>>>>>>>        // selected it will always be valid.
75064>>>>>>>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
75065>>>>>>>>>    End
75065>>>>>>>>>>
75065>>>>>>>>>
75065>>>>>>>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
75066>>>>>>>>>
75066>>>>>>>>>    // Torben Lund added line below. Move handle of focus object to structure before
75066>>>>>>>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
75066>>>>>>>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
75067>>>>>>>>>
75067>>>>>>>>>    // null 128 chars into var (make space)
75067>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
75068>>>>>>>>>
75068>>>>>>>>>    // select folder
75068>>>>>>>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
75069>>>>>>>>>    // get selected folder name
75069>>>>>>>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
75070>>>>>>>>>
75070>>>>>>>>>    // release memory resources that are used by the ItemIdList
75070>>>>>>>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
75071>>>>>>>>>
75071>>>>>>>>>    If (iFolderSelected<>0) Begin
75073>>>>>>>>>        Move (CString(sFolder)) to sPath
75074>>>>>>>>>    End
75074>>>>>>>>>>
75074>>>>>>>>>    Function_Return  sPath
75075>>>>>>>>>End_Function
75076>>>>>>>>>
75076>>>>>>>>>// returns 0 if the folder is created.
75076>>>>>>>>>//         1 if the API-call returned an error.
75076>>>>>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
75078>>>>>>>>>    Integer  iRetval bFolderCreated
75078>>>>>>>>>    WString  sFolder
75078>>>>>>>>>    tvSecurity_attributes SA
75078>>>>>>>>>    tvSecurity_attributes SA
75078>>>>>>>>>
75078>>>>>>>>>    Move False to bFolderCreated
75079>>>>>>>>>    If (sNewFolder <> "") Begin
75081>>>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
75082>>>>>>>>>        Move  0                                  to SA.lpDescriptor
75083>>>>>>>>>        Move  1                                  to SA.bInheritHandle
75084>>>>>>>>>        Move (sNewFolder+Character(0)) to sFolder
75085>>>>>>>>>        Move (vWin32_CreateDirectory(sFolder, AddressOf(SA))) to bFolderCreated
75086>>>>>>>>>    End
75086>>>>>>>>>>
75086>>>>>>>>>
75086>>>>>>>>>    If (bFolderCreated=false) Begin
75088>>>>>>>>>        Move 1 to iRetVal
75089>>>>>>>>>    End
75089>>>>>>>>>>
75089>>>>>>>>>    Function_Return iRetVal
75090>>>>>>>>>End_Function
75091>>>>>>>>>
75091>>>>>>>>>// **WvA: 03-02-2002 Function created.
75091>>>>>>>>>// With this function one can remove a directory.
75091>>>>>>>>>// returns 0 if the folder is removed.
75091>>>>>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
75091>>>>>>>>>//         2 if the folder did not exist
75091>>>>>>>>>//         3 if the sFolder parameter passed is equal to ""
75091>>>>>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
75093>>>>>>>>>    Boolean bRemoved
75093>>>>>>>>>    WString sPath
75093>>>>>>>>>    Integer iRetval
75093>>>>>>>>>
75093>>>>>>>>>    Move 0     to iRetVal
75094>>>>>>>>>    Move False to bRemoved
75095>>>>>>>>>    Move (Trim(sFolder)) to sFolder
75096>>>>>>>>>    If (sFolder="") Begin
75098>>>>>>>>>        Move 3 to iRetVal
75099>>>>>>>>>    End
75099>>>>>>>>>>
75099>>>>>>>>>    If (vFolderExists(sFolder)=False) Begin
75101>>>>>>>>>        Move 2 to iRetVal
75102>>>>>>>>>    End
75102>>>>>>>>>>
75102>>>>>>>>>    If (iRetVal=0) Begin
75104>>>>>>>>>        // null MAX_PATH chars into var (make space)
75104>>>>>>>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
75105>>>>>>>>>        //
75105>>>>>>>>>        Move (Insert(sFolder,sPath,1)) to sPath
75106>>>>>>>>>        Move (vWin32_RemoveDirectory(sPath)) to bRemoved
75107>>>>>>>>>    End
75107>>>>>>>>>>
75107>>>>>>>>>
75107>>>>>>>>>    If (iRetVal=0 And bRemoved=False) Begin
75109>>>>>>>>>        Move 1 to iRetVal
75110>>>>>>>>>    End
75110>>>>>>>>>>
75110>>>>>>>>>    Function_Return iRetVal
75111>>>>>>>>>End_Function
75112>>>>>>>>>
75112>>>>>>>>>// This will perform an operation on a file (e.g. open) with the application
75112>>>>>>>>>// registered in the Windows Registry to open that type of file (via its extension)
75112>>>>>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
75112>>>>>>>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
75114>>>>>>>>>    Handle  hInstance hWnd
75114>>>>>>>>>    // remove any leading/trailing spaces in the string
75114>>>>>>>>>    Move (Trim(sDocument)) to sDocument
75115>>>>>>>>>    Move (Trim(sPath))     to sPath
75116>>>>>>>>>    // Make the strings readable for windows API, by converting them to null-terminated
75116>>>>>>>>>    Append sOperation   (Character(0))
75117>>>>>>>>>    Append sDocument    (Character(0))
75118>>>>>>>>>    Append sParameters  (Character(0))
75119>>>>>>>>>    Append sPath        (Character(0))
75120>>>>>>>>>
75120>>>>>>>>>    Get Window_Handle to hWnd
75121>>>>>>>>>    Move (vWin32_ShellExecute (hWnd, sOperation, sDocument, sParameters, sPath, 1)) to hInstance
75122>>>>>>>>>    If (hInstance <= 32) Begin
75124>>>>>>>>>        Send vDDE_Error_Handler hInstance
75125>>>>>>>>>    End
75125>>>>>>>>>>
75125>>>>>>>>>End_Procedure
75126>>>>>>>>>
75126>>>>>>>>>Class cShellFileOperations is a Array
75127>>>>>>>>>
75127>>>>>>>>>    Procedure Construct_Object
75129>>>>>>>>>        Forward Send Construct_Object
75131>>>>>>>>>        Property Integer piDeleteFlags        0
75132>>>>>>>>>        Property Integer piCopyFlags          0
75133>>>>>>>>>        Property Integer piMoveFlags          0
75134>>>>>>>>>        Property Integer piRenameFlags        0
75135>>>>>>>>>
75135>>>>>>>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
75136>>>>>>>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
75137>>>>>>>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
75138>>>>>>>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
75139>>>>>>>>>    End_Procedure
75140>>>>>>>>>
75140>>>>>>>>>    // This function uses the shell API to perform a file operation on the
75140>>>>>>>>>    // files supplied.
75140>>>>>>>>>    //
75140>>>>>>>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
75142>>>>>>>>>        Integer  iRetVal
75142>>>>>>>>>        Integer  iUserAbort
75142>>>>>>>>>        WString  wsSource wsDestination
75142>>>>>>>>>        tvShFileOpStruct FOS
75142>>>>>>>>>        tvShFileOpStruct FOS
75142>>>>>>>>>
75142>>>>>>>>>        Move (sSource+Character(0)+Character(0))      to wsSource
75143>>>>>>>>>        Move (sDestination+Character(0)+Character(0)) to wsDestination
75144>>>>>>>>>
75144>>>>>>>>>        If (eOperation <> vFO_DELETE) Begin
75146>>>>>>>>>            Move (AddressOf(wsDestination)) to FOS.pTo
75147>>>>>>>>>        End
75147>>>>>>>>>>
75147>>>>>>>>>
75147>>>>>>>>>        Move eOperation            to FOS.wFunc
75148>>>>>>>>>        Move (AddressOf(wsSource)) to FOS.pFrom
75149>>>>>>>>>        Move iFlags                to FOS.fFlags
75150>>>>>>>>>
75150>>>>>>>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
75151>>>>>>>>>        Move FOS.fAnyOperationsAborted to iUserAbort
75152>>>>>>>>>        If (iUserAbort <> 0) Begin
75154>>>>>>>>>            Move 80 to iRetVal  // file Operation Aborted by USER
75155>>>>>>>>>        End
75155>>>>>>>>>>
75155>>>>>>>>>        Function_Return (iRetVal)
75156>>>>>>>>>    End_Function
75157>>>>>>>>>
75157>>>>>>>>>    Function sfoDeleteFile String sFileName Returns Integer
75159>>>>>>>>>        Integer  iRetVal
75159>>>>>>>>>        Integer  iFlags
75159>>>>>>>>>
75159>>>>>>>>>        Get piDeleteFlags to iFlags
75160>>>>>>>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
75161>>>>>>>>>        Function_Return iRetVal
75162>>>>>>>>>    End_Function
75163>>>>>>>>>
75163>>>>>>>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
75165>>>>>>>>>        Integer  iRetVal
75165>>>>>>>>>        Integer  iFlags
75165>>>>>>>>>
75165>>>>>>>>>        Get piCopyFlags to iFlags
75166>>>>>>>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
75167>>>>>>>>>        Function_Return iRetVal
75168>>>>>>>>>    End_Function
75169>>>>>>>>>
75169>>>>>>>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
75171>>>>>>>>>        Integer  iRetVal
75171>>>>>>>>>        Integer  iFlags
75171>>>>>>>>>
75171>>>>>>>>>        Get piMoveFlags to iFlags
75172>>>>>>>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
75173>>>>>>>>>        Function_Return iRetVal
75174>>>>>>>>>    End_Function
75175>>>>>>>>>
75175>>>>>>>>>    // Rename a file or folder
75175>>>>>>>>>    // Returns a nonzero value if the operation failed.
75175>>>>>>>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
75177>>>>>>>>>        Integer  iRetVal
75177>>>>>>>>>        Integer  iFlags
75177>>>>>>>>>
75177>>>>>>>>>        Get piRenameFlags to iFlags
75178>>>>>>>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
75179>>>>>>>>>        Function_Return iRetVal
75180>>>>>>>>>    End_Function
75181>>>>>>>>>
75181>>>>>>>>>
75181>>>>>>>>>    //Example:
75181>>>>>>>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
75181>>>>>>>>>    //                                          mode.
75181>>>>>>>>>
75181>>>>>>>>>End_Class
75182>>>>>>>>>
75182>>>>>>>>>Object oShellFileOperations is a cShellFileOperations
75184>>>>>>>>>End_Object
75185>>>>>>>>>
75185>>>>>>>>>// Restore to the old way of working with the shell file operations.
75185>>>>>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
75185>>>>>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
75185>>>>>>>>>Procedure vWin32fhCompatibilityMode
75187>>>>>>>>>    Integer hoSFO
75187>>>>>>>>>    Integer iFlags
75187>>>>>>>>>
75187>>>>>>>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
75188>>>>>>>>>    Move (oShellFileOperations(Self)) to hoSFO
75189>>>>>>>>>
75189>>>>>>>>>    Set piDeleteFlags of hoSFO to iFlags
75190>>>>>>>>>    Set piCopyFlags   of hoSFO to iFlags
75191>>>>>>>>>    Set piMoveFlags   of hoSFO to iFlags
75192>>>>>>>>>    Set piRenameFlags of hoSFO to iFlags
75193>>>>>>>>>End_Procedure
75194>>>>>>>>>
75194>>>>>>>>>// Delete a file or folder
75194>>>>>>>>>// Returns a nonzero value if the operation failed.
75194>>>>>>>>>Function vDeleteFile Global String sFileName Returns Integer
75196>>>>>>>>>    Integer  iRetVal
75196>>>>>>>>>
75196>>>>>>>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
75197>>>>>>>>>    Function_Return iRetVal
75198>>>>>>>>>End_Function
75199>>>>>>>>>
75199>>>>>>>>>// Copy a file or folder
75199>>>>>>>>>// Returns a nonzero value if the operation failed.
75199>>>>>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
75201>>>>>>>>>    Integer  iRetVal
75201>>>>>>>>>
75201>>>>>>>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75202>>>>>>>>>    Function_Return iRetVal
75203>>>>>>>>>End_Function
75204>>>>>>>>>
75204>>>>>>>>>// Move a file or folder
75204>>>>>>>>>// Returns a nonzero value if the operation failed.
75204>>>>>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
75206>>>>>>>>>    Integer  iRetVal
75206>>>>>>>>>
75206>>>>>>>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75207>>>>>>>>>    Function_Return iRetVal
75208>>>>>>>>>End_Function
75209>>>>>>>>>
75209>>>>>>>>>// Rename a file or folder
75209>>>>>>>>>// Returns a nonzero value if the operation failed.
75209>>>>>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
75211>>>>>>>>>    Integer  iRetVal
75211>>>>>>>>>
75211>>>>>>>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75212>>>>>>>>>    Function_Return iRetVal
75213>>>>>>>>>End_Function
75214>>>>>>>>>
75214>>>>>>>>>Function vGetWindowsDirectory Returns String
75216>>>>>>>>>    WString wDirectory
75216>>>>>>>>>    Integer iRetVal
75216>>>>>>>>>
75216>>>>>>>>>    Move (ZeroString(vMAX_PATH)) to wDirectory
75217>>>>>>>>>    Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), vMAX_PATH)) to iRetVal
75218>>>>>>>>>    If (iRetVal > vMAX_PATH) Begin
75220>>>>>>>>>        Move (ZeroString(iRetval)) to wDirectory
75221>>>>>>>>>        Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), iRetVal)) to iRetVal
75222>>>>>>>>>    End
75222>>>>>>>>>>
75222>>>>>>>>>    Function_Return (CString(wDirectory))
75223>>>>>>>>>End_Function
75224>>>>>>>>>
75224>>>>>>>>>Function vGetTempPath Returns String
75226>>>>>>>>>    Integer iRetVal
75226>>>>>>>>>    WString wTempPath
75226>>>>>>>>>
75226>>>>>>>>>    Move (ZeroString(vMAX_PATH)) to wTempPath
75227>>>>>>>>>    Move (vWin32_GetTempPath(vMAX_PATH, AddressOf(wTempPath))) to iRetVal
75228>>>>>>>>>    If (iRetVal > vMAX_PATH) Begin
75230>>>>>>>>>        Move (ZeroString(iRetval)) to wTempPath
75231>>>>>>>>>        Move (vWin32_GetTempPath(iRetVal, AddressOf(wTempPath))) to iRetVal
75232>>>>>>>>>    End
75232>>>>>>>>>>
75232>>>>>>>>>    Function_Return (CString(wTempPath))
75233>>>>>>>>>End_Function
75234>>>>>>>>>
75234>>>>>>>>>// Courtesy of Marco Kuipers
75234>>>>>>>>>Function vMakeTempFile Returns String
75236>>>>>>>>>    Integer iRetval
75236>>>>>>>>>    String  sTempPath
75236>>>>>>>>>    String  sTempFileName
75236>>>>>>>>>    String  sPrefixString
75236>>>>>>>>>    WString wsTempFileName
75236>>>>>>>>>
75236>>>>>>>>>    Get vGetTempPath to sTempPath
75237>>>>>>>>>    If (sTempPath = "") Begin
75239>>>>>>>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
75240>>>>>>>>>        If (sTempPath<>"") Begin
75242>>>>>>>>>            Move (sTempPath+"\Temp\") to sTempPath
75243>>>>>>>>>        End
75243>>>>>>>>>>
75243>>>>>>>>>    End
75243>>>>>>>>>>
75243>>>>>>>>>
75243>>>>>>>>>    If (sTempPath = "") Begin
75245>>>>>>>>>        // second fallback we really do not want to get here as to be fair using current folder as temp
75245>>>>>>>>>        // makes little sense. Leaving this in as it was old behavior.
75245>>>>>>>>>        Get_Current_Directory to sTempPath
75246>>>>>>>>>    End
75246>>>>>>>>>>
75246>>>>>>>>>
75246>>>>>>>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
75247>>>>>>>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
75249>>>>>>>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
75250>>>>>>>>>>
75250>>>>>>>>>    End
75250>>>>>>>>>>
75250>>>>>>>>>
75250>>>>>>>>>    Move (ZeroString(vMax_Path)) to wsTempFileName
75251>>>>>>>>>    Move ("tmp"+Character(0))    to sPrefixString
75252>>>>>>>>>    Move (vWin32_GetTempFileName (sTempPath, sPrefixString, 0, AddressOf(wsTempFileName))) to iRetval
75253>>>>>>>>>    If (iRetval = 0) Begin  // The api call returns 0 if an error occurs
75255>>>>>>>>>    //Get ShowLastError to iRetval
75255>>>>>>>>>        Move "" to sTempFileName
75256>>>>>>>>>    End
75256>>>>>>>>>>
75256>>>>>>>>>    Move (Cstring(wsTempFileName)) to sTempFileName
75257>>>>>>>>>    Function_Return sTempFileName
75258>>>>>>>>>End_Function
75259>>>>>>>>>
75259>>>>>>>>>// This function creates a uniquely named temporary file in folder sPath
75259>>>>>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
75259>>>>>>>>>// Note that you will have to cleanup the tempfile yourself as the function
75259>>>>>>>>>// does not take care of that.
75259>>>>>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
75261>>>>>>>>>    Integer iRetVal
75261>>>>>>>>>    String  sTempFileName
75261>>>>>>>>>    WString wTempFileName
75261>>>>>>>>>
75261>>>>>>>>>    Move (sPath+Character(0))   to sPath
75262>>>>>>>>>    Move (sPrefix+Character(0)) to sPrefix
75263>>>>>>>>>    Move (Pad("", vMAX_PATH))   to wTempFileName
75264>>>>>>>>>
75264>>>>>>>>>    Move (vWin32_GetTempFileName(sPath, sPrefix, 0, AddressOf(wTempFileName))) to iRetVal
75265>>>>>>>>>    Move (Trim(Cstring(wTempFileName))) to sTempFileName
75266>>>>>>>>>    Function_Return sTempFileName
75267>>>>>>>>>End_Function
75268>>>>>>>>>
75268>>>>>>>>>//
75268>>>>>>>>>// Get a specific shell folder for example to get the desktop folder
75268>>>>>>>>>// simply call this function and pass it vCSIDL_DESKTOP
75268>>>>>>>>>//
75268>>>>>>>>>Function vSHGetFolderPath Integer eFolder Returns String
75270>>>>>>>>>    Integer iVoid
75270>>>>>>>>>    Handle  hWnd
75270>>>>>>>>>    String  sFolder
75270>>>>>>>>>    WString wFolder
75270>>>>>>>>>
75270>>>>>>>>>    Move (Window_Handle(focus(desktop))) to hWnd
75271>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to wFolder
75272>>>>>>>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(wFolder))) To iVoid
75273>>>>>>>>>    Move (CString(wFolder)) to sFolder
75274>>>>>>>>>    Function_Return sFolder
75275>>>>>>>>>End_Function
75276>>>>>>>>>
75276>>>>>>>>>// Courtesy Of Vincent Oorsprong
75276>>>>>>>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
75278>>>>>>>>>    String  sFileDateTime
75278>>>>>>>>>    WString wFormattedTime wFormattedDate
75278>>>>>>>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
75278>>>>>>>>>    tvFileTime   FileTime
75278>>>>>>>>>    tvFileTime   FileTime
75278>>>>>>>>>    tvSystemTime SystemTime
75278>>>>>>>>>    tvSystemTime SystemTime
75278>>>>>>>>>
75278>>>>>>>>>    Move "" to sFileDateTime
75279>>>>>>>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
75280>>>>>>>>>    Move dwHighDateTime to FileTime.dwHighDateTime
75281>>>>>>>>>
75281>>>>>>>>>    Move 0 to SystemTime.wYear
75282>>>>>>>>>
75282>>>>>>>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
75283>>>>>>>>>    If (iSuccess = 1) Begin
75285>>>>>>>>>        Move (ZeroString(255))               to wFormattedTime
75286>>>>>>>>>        Move (SizeOfWString(wFormattedTime)) to iLenCcTime
75287>>>>>>>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedTime), iLenCcTime)) to iDataLength
75288>>>>>>>>>        Move (ZeroString(255))               to wFormattedDate
75289>>>>>>>>>        Move (SizeOfWString(wFormattedDate)) to iLenCcDate
75290>>>>>>>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedDate), iLenCcDate)) to iDataLength
75291>>>>>>>>>        Move (Cstring (wFormattedDate)  * Cstring (wFormattedTime)) to sFileDateTime
75292>>>>>>>>>    End
75292>>>>>>>>>>
75292>>>>>>>>>    Function_Return sFileDateTime
75293>>>>>>>>>End_Function
75294>>>>>>>>>
75294>>>>>>>>>// **WvA:
75294>>>>>>>>>// A windows replacement for the standard function FileExists.
75294>>>>>>>>>// This version will also return (true) for a file when it is open by an application.
75294>>>>>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
75294>>>>>>>>>// Example: Get vFilePathExists "C:\config.sy?"
75294>>>>>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
75294>>>>>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
75296>>>>>>>>>    String  sDirSep
75296>>>>>>>>>    Handle  hFindFile
75296>>>>>>>>>    Integer iVoid
75296>>>>>>>>>    tvWin32FindData FindData
75296>>>>>>>>>    tvWin32FindData FindData
75296>>>>>>>>>
75296>>>>>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
75297>>>>>>>>>    Move (Trim(sFilePathMask)) to sFilePathMask
75298>>>>>>>>>
75298>>>>>>>>>    If (Length(sFilePathMask)>0) Begin
75300>>>>>>>>>        // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
75300>>>>>>>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75301>>>>>>>>>        While (Right(sFilePathMask, 1) = sDirSep)
75305>>>>>>>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
75306>>>>>>>>>        Loop
75307>>>>>>>>>>
75307>>>>>>>>>
75307>>>>>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75308>>>>>>>>>        Move (vWin32_FindFirstFile (sFilePathMask, AddressOf(FindData))) to hFindFile
75309>>>>>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
75310>>>>>>>>>    End
75310>>>>>>>>>>
75310>>>>>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
75311>>>>>>>>>End_Function
75312>>>>>>>>>
75312>>>>>>>>>
75312>>>>>>>>>//
75312>>>>>>>>>// Returns the amount of files in the folder (if it exists)
75312>>>>>>>>>// Returns -1 if folder doesn't exist.
75312>>>>>>>>>// The files "." and ".." are not counted.
75312>>>>>>>>>//
75312>>>>>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
75314>>>>>>>>>    Boolean bFound
75314>>>>>>>>>    Handle  hFindFile
75314>>>>>>>>>    Integer iCount  iVoid
75314>>>>>>>>>    Integer iSuccess
75314>>>>>>>>>    String  sFileName
75314>>>>>>>>>    tvWin32FindData FindData
75314>>>>>>>>>    tvWin32FindData FindData
75314>>>>>>>>>
75314>>>>>>>>>    Move -1 to iCount
75315>>>>>>>>>    Get vFolderFormat sFolderName to sFolderName
75316>>>>>>>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
75317>>>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75318>>>>>>>>>    Move (vWin32_FindFirstFile (sFolderName, AddressOf(FindData))) to hFindFile
75319>>>>>>>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
75320>>>>>>>>>    If (bFound) Begin
75322>>>>>>>>>        Move 0 to iCount
75323>>>>>>>>>    End
75323>>>>>>>>>>
75323>>>>>>>>>    While (bFound)
75327>>>>>>>>>        Increment iCount
75328>>>>>>>>>        Move (PointerToWString(AddressOf(FindData.cFileName))) to sFileName
75329>>>>>>>>>        If (sFileName="." or sFileName="..") Begin
75331>>>>>>>>>            Decrement iCount
75332>>>>>>>>>        End
75332>>>>>>>>>>
75332>>>>>>>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
75333>>>>>>>>>        Move (iSuccess<>0) to bFound
75334>>>>>>>>>    Loop
75335>>>>>>>>>>
75335>>>>>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
75336>>>>>>>>>    Function_Return iCount
75337>>>>>>>>>End_Function
75338>>>>>>>>>
75338>>>>>>>>>// Create the folder, including intermediate directories.
75338>>>>>>>>>// Don't panic if the folder already exists.
75338>>>>>>>>>// Michael Mullan June 2009.
75338>>>>>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
75340>>>>>>>>>    String  sFolder
75340>>>>>>>>>    Integer iRetval iFolderCreated
75340>>>>>>>>>    tvSecurity_attributes SA
75340>>>>>>>>>    tvSecurity_attributes SA
75340>>>>>>>>>
75340>>>>>>>>>    Move 0 to iFolderCreated
75341>>>>>>>>>
75341>>>>>>>>>    // null MAX_PATH chars into var (make space)
75341>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
75342>>>>>>>>>    If (sNewFolder <> "") Begin
75344>>>>>>>>>
75344>>>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
75345>>>>>>>>>        Move  0  to SA.lpDescriptor
75346>>>>>>>>>        Move  1  to SA.bInheritHandle
75347>>>>>>>>>
75347>>>>>>>>>        //
75347>>>>>>>>>        Move (sNewFolder+"") to sFolder
75348>>>>>>>>>        Move (vWin32_SHCreateDirectoryEx(0,sFolder, AddressOf(SA))) to iFolderCreated
75349>>>>>>>>>    End
75349>>>>>>>>>>
75349>>>>>>>>>
75349>>>>>>>>>    If (iFolderCreated <> 0) Begin
75351>>>>>>>>>        Move 1 to iRetVal
75352>>>>>>>>>        Case Begin
75352>>>>>>>>>            Case (iFolderCreated = 161)
75354>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
75355>>>>>>>>>>
75355>>>>>>>>>                Case Break
75356>>>>>>>>>            Case (iFolderCreated = 206)
75359>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
75360>>>>>>>>>>
75360>>>>>>>>>                Case Break
75361>>>>>>>>>            Case (iFolderCreated = 3)
75364>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
75365>>>>>>>>>>
75365>>>>>>>>>                Case Break
75366>>>>>>>>>            Case (iFolderCreated = 80)
75369>>>>>>>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
75370>>>>>>>>>                Case Break
75371>>>>>>>>>            Case (iFolderCreated = 183)
75374>>>>>>>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
75375>>>>>>>>>                Case Break
75376>>>>>>>>>            Case (iFolderCreated = 1223)
75379>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
75380>>>>>>>>>>
75380>>>>>>>>>                Case Break
75381>>>>>>>>>            Case Else
75381>>>>>>>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
75382>>>>>>>>>>
75382>>>>>>>>>        Case End
75382>>>>>>>>>    End
75382>>>>>>>>>>
75382>>>>>>>>>    Function_Return iRetVal
75383>>>>>>>>>End_Function
75384>>>>>>>>>
75384>>>>>>>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
75386>>>>>>>>>    DWord   dwFileSizeHigh dwFileSizeLow
75386>>>>>>>>>    Integer iFileSize iVoid
75386>>>>>>>>>    Handle  hFindFile
75386>>>>>>>>>    tvWin32FindData FindData
75386>>>>>>>>>    tvWin32FindData FindData
75386>>>>>>>>>
75386>>>>>>>>>    Move (sFileName+"") to sFileName
75387>>>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75388>>>>>>>>>    Move (vWin32_FindFirstFile (sFileName, AddressOf(FindData))) to hFindFile
75389>>>>>>>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
75391>>>>>>>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
75392>>>>>>>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
75393>>>>>>>>>    End
75393>>>>>>>>>>
75393>>>>>>>>>    Move (vWin32_FindClose(hFindFile)) to iVoid
75394>>>>>>>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
75395>>>>>>>>>
75395>>>>>>>>>    Function_Return iFileSize
75396>>>>>>>>>End_Function
75397>>>>>>>>>
75397>>>>>>>>>//
75397>>>>>>>>>// Based on code in Peter Crook's Browse folder workspace
75397>>>>>>>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
75397>>>>>>>>>//
75397>>>>>>>>>//=============================================================================
75397>>>>>>>>>// Verifies that a path is a valid directory.
75397>>>>>>>>>//
75397>>>>>>>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
75397>>>>>>>>>//
75397>>>>>>>>>// Parameters:
75397>>>>>>>>>//      sPath - Address of the path to verify.
75397>>>>>>>>>//=============================================================================
75397>>>>>>>>>Function vPathIsDirectory Global String sPath Returns Boolean
75399>>>>>>>>>    Integer iResult
75399>>>>>>>>>    Boolean bRetVal
75399>>>>>>>>>
75399>>>>>>>>>    Move false to bRetVal
75400>>>>>>>>>    Move (sPath - Character (0)) to sPath
75401>>>>>>>>>    Move (vWin32_PathIsDirectory (sPath)) to iResult
75402>>>>>>>>>    If (iResult<>0) Begin
75404>>>>>>>>>        Move True to bRetVal
75405>>>>>>>>>    End
75405>>>>>>>>>>
75405>>>>>>>>>
75405>>>>>>>>>    Function_Return bRetVal
75406>>>>>>>>>End_Function
75407>>>>>>>>>
75407>>>>>>>
75407>>>>>>>//
75407>>>>>>>// Gets the string from the right of the last sStopChar in sFrom
75407>>>>>>>// If sStopChar has no occurences in the string an empty string is
75407>>>>>>>// returned.
75407>>>>>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
75409>>>>>>>    String  sRetVal
75409>>>>>>>    String  sChar
75409>>>>>>>    Integer iLength
75409>>>>>>>    Integer iPos
75409>>>>>>>    Boolean bStopChar
75409>>>>>>>    Move "" to sRetval
75410>>>>>>>    Move (Length(sFrom)) to iLength
75411>>>>>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
75413>>>>>>>        Move iLength   to iPos
75414>>>>>>>        Move (False)   to bStopChar
75415>>>>>>>        While Not bStopChar
75419>>>>>>>            Move (Mid(sFrom,1,iPos)) to sChar
75420>>>>>>>            Decrement iPos
75421>>>>>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
75423>>>>>>>                Move (True) to bStopChar
75424>>>>>>>            End
75424>>>>>>>>
75424>>>>>>>            Else Begin
75425>>>>>>>                Move (sChar+sRetVal) to sRetVal
75426>>>>>>>            End
75426>>>>>>>>
75426>>>>>>>        Loop
75427>>>>>>>>
75427>>>>>>>    End
75427>>>>>>>>
75427>>>>>>>    Function_Return sRetVal
75428>>>>>>>End_Function
75429>>>>>>>
75429>>>>>>>// Pre:  sFileName contains the complete path of the file.
75429>>>>>>>// Post: returns the complete path of the file.
75429>>>>>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
75429>>>>>>>Function ParseFolderName Global String sFileName Returns String
75431>>>>>>>    String sFile
75431>>>>>>>    String sFolderName
75431>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
75431>>>>>>>
75431>>>>>>>    Move "" to sFolderName
75432>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75433>>>>>>>    If sDirSep In sFileName Begin
75435>>>>>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
75436>>>>>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
75437>>>>>>>    End
75437>>>>>>>>
75437>>>>>>>    Else If ":" In sFileName Begin
75440>>>>>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
75441>>>>>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
75442>>>>>>>    End
75442>>>>>>>>
75442>>>>>>>    Function_Return sFolderName
75443>>>>>>>End_Function
75444>>>>>>>
75444>>>>>>>// Pre:  sFileName contains the complete path of the file.
75444>>>>>>>// post: The returned filename has it's path removed, but will have a extension
75444>>>>>>>Function ParseFileName Global String sFileName Returns String
75446>>>>>>>    String sFolderName
75446>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
75446>>>>>>>
75446>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75447>>>>>>>    Get ParseFolderName sFileName to sFolderName
75448>>>>>>>    If (sFolderName <> "") Begin
75450>>>>>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
75451>>>>>>>    End
75451>>>>>>>>
75451>>>>>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
75452>>>>>>>    Function_Return sFilename
75453>>>>>>>End_Function
75454>>>>>>>
75454>>>>>>>// Pre:  sFileName may contain the complete path of the file.
75454>>>>>>>//       or contain multiple dots in the filename, so temp.gif.bak will
75454>>>>>>>//       return "bak" as the extension and not "gif"
75454>>>>>>>// Post: returns the extension only, this extension can be a valid unixlike extension
75454>>>>>>>//       such as "html" or "java"
75454>>>>>>>Function ParseFileExtension Global String sFileName Returns String
75456>>>>>>>    String  sFileExtension
75456>>>>>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
75457>>>>>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
75458>>>>>>>    Function_Return sFileExtension
75459>>>>>>>End_Function
75460>>>>>>>
75460>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
75460>>>>>>>
75460>>>>>>>Function DDE_Error_To_String Integer iErrorID Returns String
75462>>>>>>>    String sMessage
75462>>>>>>>    Case Begin
75462>>>>>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
75464>>>>>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
75465>>>>>>>            Case Break
75466>>>>>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
75469>>>>>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
75470>>>>>>>            Case Break
75471>>>>>>>        Case (iErrorID = vERROR_BAD_FORMAT)
75474>>>>>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
75475>>>>>>>            Case Break
75476>>>>>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
75479>>>>>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
75480>>>>>>>            Case Break
75481>>>>>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
75484>>>>>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
75485>>>>>>>            Case Break
75486>>>>>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
75489>>>>>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
75490>>>>>>>            Case Break
75491>>>>>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
75494>>>>>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
75495>>>>>>>            Case Break
75496>>>>>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
75499>>>>>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
75500>>>>>>>            Case Break
75501>>>>>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
75504>>>>>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
75505>>>>>>>            Case Break
75506>>>>>>>        Case (iErrorID = vSE_ERR_NOASSOC)
75509>>>>>>>            Move CS_DDE_ERR_NOASSOC to sMessage
75510>>>>>>>            Case Break
75511>>>>>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
75514>>>>>>>            Move CS_DDE_ERR_OOM to sMessage
75515>>>>>>>            Case Break
75516>>>>>>>        Case (iErrorID = vSE_ERR_PNF)
75519>>>>>>>            Move CS_DDE_ERR_PNF to sMessage
75520>>>>>>>            Case Break
75521>>>>>>>        Case (iErrorID = vSE_ERR_SHARE)
75524>>>>>>>            Move CS_DDE_ERR_SHARE to sMessage
75525>>>>>>>            Case Break
75526>>>>>>>        Case Else
75526>>>>>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
75527>>>>>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
75528>>>>>>>            Case Break
75529>>>>>>>    Case End
75529>>>>>>>    Function_Return sMessage
75530>>>>>>>End_Function
75531>>>>>>>
75531>>>>>>>Procedure vDDE_Error_Handler Integer iErrorID
75533>>>>>>>    String sMessage
75533>>>>>>>    Get DDE_Error_To_String iErrorID to sMessage
75534>>>>>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
75535>>>>>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
75536>>>>>>>End_Procedure
75537>>>>>>>
75537>>>>>>>
75537>>>>>>>// This function informs the user that he entered a yet unknown folder and
75537>>>>>>>// asks if he/she wants to create the folder (Yes/No)
75537>>>>>>>// Choice: "Yes" - this creates the folder
75537>>>>>>>//                 if successful, the function returns false
75537>>>>>>>//                 else it will be true.
75537>>>>>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
75537>>>>>>>//                 For example: to stop a save
75537>>>>>>>// Precondition: A foldername must be entered. We do not check for empty paths
75537>>>>>>>// This function returns a non-zero value if the folder isn't created afterwards
75537>>>>>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
75539>>>>>>>    Integer bIsNotValid
75539>>>>>>>    Integer iUsers_Choice
75539>>>>>>>    String  sMessage
75539>>>>>>>
75539>>>>>>>    If (vFolderExists(sFolderName) Eq 0) Begin
75541>>>>>>>        Move "The folder '" to sMessage
75542>>>>>>>        Append sMessage sFolderName
75543>>>>>>>        Append sMessage "' does not yet exist,\n"
75544>>>>>>>        Append sMessage "Do you want to create it now?"
75545>>>>>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
75546>>>>>>>        Case Begin
75546>>>>>>>            Case (iUsers_Choice = MBR_Yes)
75548>>>>>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
75549>>>>>>>                If bIsNotValid Begin
75551>>>>>>>                    Move "An error occurred while trying to create folder '" to sMessage
75552>>>>>>>                    Append sMessage sFolderName "'.\n\n"
75554>>>>>>>                    Send Info_Box sMessage "Info"
75555>>>>>>>                End
75555>>>>>>>>
75555>>>>>>>                Case Break
75556>>>>>>>            Case (iUsers_Choice = MBR_No)
75559>>>>>>>                Move dfTrue to bIsNotValid // Cancel the save
75560>>>>>>>                Case Break
75561>>>>>>>        Case End
75561>>>>>>>    End
75561>>>>>>>>
75561>>>>>>>    Function_Return bIsNotValid
75562>>>>>>>End_Function
75563>>>>>>>
75563>>>>>>>// **WvA
75563>>>>>>>// Formats a foldername by first trimming it and after that by sticking a
75563>>>>>>>// directory separator (/\) to the end if it doesn't have one there already.
75563>>>>>>>// The folder may contain a drive letter or UNC encoding.
75563>>>>>>>Function vFolderFormat Global String sFolderName Returns String
75565>>>>>>>    String sDirSep
75565>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
75566>>>>>>>    Move (Trim(sFolderName)) to sFolderName
75567>>>>>>>    If (Right(sFolderName,1)<>sDirSep) Begin
75569>>>>>>>        Move (sFolderName+sDirSep) to sFolderName
75570>>>>>>>    End
75570>>>>>>>>
75570>>>>>>>    Function_Return sFolderName
75571>>>>>>>End_Function
75572>>>>>>>
75572>>>>>>>//
75572>>>>>>>// Gets the parent path of the currently supplied path
75572>>>>>>>// Returns "" when we are at the root folder.
75572>>>>>>>//
75572>>>>>>>Function vParentPath Global String sPath Returns String
75574>>>>>>>    String sStrip sDirSep
75574>>>>>>>
75574>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75575>>>>>>>    Move (Trim(sPath)) to sPath
75576>>>>>>>    If (Right(sPath,1) = sDirSep) Begin
75578>>>>>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
75579>>>>>>>    End
75579>>>>>>>>
75579>>>>>>>    If (Pos(sDirSep, sPath)) Begin
75581>>>>>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
75582>>>>>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
75583>>>>>>>    End
75583>>>>>>>>
75583>>>>>>>    Else Begin
75584>>>>>>>        Move "" to sPath
75585>>>>>>>    End
75585>>>>>>>>
75585>>>>>>>    Function_Return sPath
75586>>>>>>>End_Function
75587>>>>>Use DUFLanguageConstants.inc
75587>>>>>
75587>>>>>Define CS_IntFilesTableLogicalName for "IntFilesTable"
75587>>>>>// Do *not* change this name as it is used by the CheckIntFilesIntegrity
75587>>>>>// procedure and the explicit file name is used with the Include_Resource command.
75587>>>>>Define CS_FilelistBackupFile    for "FilelistBackupFile.cfg"
75587>>>>>
75587>>>>>Struct tDUFIntFile
75587>>>>>    Integer iID
75587>>>>>    String sIntFileName
75587>>>>>    String sIntLineText
75587>>>>>End_Struct
75587>>>>>
75587>>>>>Struct tDbVersionInfo
75587>>>>>    Number nVersionNumber
75587>>>>>    Handle hObject
75587>>>>>End_Struct
75587>>>>>
75587>>>>>Struct tDbUpdateError
75587>>>>>    Number nUpdateVersion
75587>>>>>    Integer iError
75587>>>>>    String  sOrgErrorText
75587>>>>>    String  sErrorText
75587>>>>>    Integer iErrorLine
75587>>>>>    Boolean bError  
75587>>>>>    Handle  hTable 
75587>>>>>    String  sTableRootName
75587>>>>>    Integer iField
75587>>>>>    Boolean bShortFormat
75587>>>>>End_Struct
75587>>>>>
75587>>>>>//  DF_FILE_ALIAS_DEFAULT if no master or alias
75587>>>>>//  DF_FILE_IS_MASTER if master
75587>>>>>//  DF_FILE_IS_ALIAS if alias
75587>>>>>Struct tDbUpdateHandlerMasterAlias
75587>>>>>    Handle hTable
75587>>>>>    Integer iMode
75587>>>>>End_Struct
75587>>>>>
75587>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
75587>>>>>Enumeration_List
75587>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
75587>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
75587>>>>>End_Enumeration_List
75587>>>>>
75587>>>>>    Define DATAFLEX_ID for "DATAFLEX"
75587>>>>>
75587>>>>>// Global handle to a cDatabaseUpdateHandler object that can be used to
75587>>>>>// communicate with the object from anywhere in a program.
75587>>>>>    Global_Variable Handle ghoDbUpdateHandler
75587>>>>>    Move 0 to ghoDbUpdateHandler
75588>>>>>
75588>>>>>// NOTE: If the DbVersion table should _not_ be used and you
75588>>>>>// instead set the "Set Data_File_Field to (RefTable(MyTable)) (RefTable(MyTable.DbUpdateVersion))"
75588>>>>>// in the cDbUpdateHandler object; Add a "Define DUF_Use_DbVersion" to your code,
75588>>>>>// _before_ the "Use cDbUpdateHandler.pkg" line.
75588>>>>>//#IFNDEF DUF_Use_Custom_DbVersion
75588>>>>>//    Declare_Datafile DbVersion
75588>>>>>//#ENDIF
75588>>>Use cDbUpdateLogFile.pkg
Including file: cDbUpdateLogFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateLogFile.pkg)
75588>>>>>//****************************************************************************
75588>>>>>// $Module type: Class
75588>>>>>// $Module name: cDbUpdateLogFile
75588>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75588>>>>>// Web-site    : http://www.rdctools.com
75588>>>>>// Created     : 2016-10-05 @ 18:58 (Military date format: YY-MM-DD)
75588>>>>>//
75588>>>>>// Description : This logic was moved from the cDbUpdateHandler class so that it would
75588>>>>>//               be easier to change to where errors/status messages are written/saved. As it is less likely
75588>>>>>//               that this class is to change; each developer can decide if the errors instead
75588>>>>>//               should be saved to a database table, or something entirely different.
75588>>>>>//               The default is to write the errors to a Ascii-file in the Data folder.
75588>>>>>//
75588>>>>>// $Rev History:
75588>>>>>//    2016-10-05  Module header created
75588>>>>>//****************************************************************************
75588>>>>>Use UI
75588>>>>>Use vWin32fh.pkg
75588>>>>>
75588>>>>>
75588>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
75588>>>>>
75588>>>>>Define CS_SuccessfulUpdate for "The database was updated successfully!"
75588>>>>>
75588>>>>>Class cDbUpdateLogFile is a cObject
75589>>>>>
75589>>>>>    Procedure Construct_Object
75591>>>>>        Forward Send Construct_Object
75593>>>>>
75593>>>>>        // Error handling:
75593>>>>>        Property tDbUpdateError[] paDbUpdateErrorArray
75594>>>>>        Property Integer piChannel -1
75595>>>>>
75595>>>>>        // This property is set by the cDbUpdateHandler object,
75595>>>>>        // when the update process starts.
75595>>>>>        Property DateTime pdtUpdateStart
75596>>>>>
75596>>>>>        // Gets set to False if the log contains data
75596>>>>>        Property Boolean pbEmptyLogFile True
75597>>>>>
75597>>>>>        // Gets set to True after the error log header text
75597>>>>>        // has been written.
75597>>>>>        Property Boolean pbHeaderWritten False
75598>>>>>
75598>>>>>        // If all activities should be logged- not just errors.
75598>>>>>        Property Boolean pbVerboseState False
75599>>>>>
75599>>>>>        // File name for the error log where all errors
75599>>>>>        // after a run is written to (appended).
75599>>>>>        // It is saved in the Data folder.
75599>>>>>        Property String psLogTextFile   "DUFUpdateLog.txt"
75600>>>>>        // If this property is set to "" in object code, the
75600>>>>>        // "shell" command parameter will be used to let Windows decide
75600>>>>>        // with which program to open the logfile.
75600>>>>>        Property String psEditorProgram ""
75601>>>>>
75601>>>>>        Property Boolean pbUseDataTableLog False
75602>>>>>
75602>>>>>        // If true an error will be written to file immediately when
75602>>>>>        // it occurs. This can be handy if a large update generates a lots
75602>>>>>        // of errors and the application crasches before finished, thus
75602>>>>>        // the errors will not be written.
75602>>>>>        Property Boolean pbQuickWrite True
75603>>>>>    End_Procedure
75604>>>>>
75604>>>>>    Procedure End_Construct_Object
75606>>>>>        Forward Send End_Construct_Object
75608>>>>>
75608>>>>>    End_Procedure
75609>>>>>
75609>>>>>    Procedure LogError Number nVersion Integer iError String sErrorText Integer iErrorLine Boolean bError Boolean bShortFormatIn
75611>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
75611>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
75613>>>>>        Boolean bShortFormat
75613>>>>>        Integer iSize
75613>>>>>        Handle hCurrentTable
75613>>>>>        Integer iCurrentField           
75613>>>>>        String sOrgErrorText sTableRootName
75613>>>>>        
75613>>>>>        Move False to bShortFormat
75614>>>>>        If (num_arguments > 5) Begin
75616>>>>>            Move bShortFormatIn to bShortFormat
75617>>>>>        End
75617>>>>>>
75617>>>>>        // Only do once.
75617>>>>>        If (pbHeaderWritten(Self) = False) Begin
75619>>>>>            Send WriteHeaderData
75620>>>>>        End
75620>>>>>>
75620>>>>>
75620>>>>>        Get Private.phCurrentTable to hCurrentTable  
75621>>>>>        Get Private.piCurrentField to iCurrentField  
75622>>>>>        If (iError > 0) Begin
75624>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hCurrentTable to sTableRootName
75627>>>>>            Get FetchErrorDescription iError to sOrgErrorText 
75628>>>>>        End
75628>>>>>>
75628>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
75629>>>>>        Move (SizeOfArray(DbUpdateErrorArray)) to iSize
75630>>>>>        Move nVersion       to DbUpdateErrorArray[iSize].nUpdateVersion
75631>>>>>        Move iError         to DbUpdateErrorArray[iSize].iError
75632>>>>>        Move iErrorLine     to DbUpdateErrorArray[iSize].iErrorLine
75633>>>>>        Move True           to DbUpdateErrorArray[iSize].bError  
75634>>>>>        Move sOrgErrorText  to DbUpdateErrorArray[iSize].sOrgErrorText
75635>>>>>        Move sErrorText     to DbUpdateErrorArray[iSize].sErrorText
75636>>>>>        Move hCurrentTable  to DbUpdateErrorArray[iSize].hTable            
75637>>>>>        Move sTableRootName to DbUpdateErrorArray[iSize].sTableRootName
75638>>>>>        Move iCurrentField  to DbUpdateErrorArray[iSize].iField  
75639>>>>>        Move bShortFormat   to DbUpdateErrorArray[iSize].bShortFormat
75640>>>>>
75640>>>>>        If (bError = False) Begin
75642>>>>>            Move False to DbUpdateErrorArray[iSize].bError
75643>>>>>        End
75643>>>>>>
75643>>>>>        Set paDbUpdateErrorArray to DbUpdateErrorArray
75644>>>>>
75644>>>>>        If (pbUseDataTableLog(Self) = True) Begin
75646>>>>>            If (pbQuickWrite(Self) = True) Begin
75648>>>>>                Send OnWriteRow_DataTable
75649>>>>>                // If we are writing error for error flush the
75649>>>>>                // error array when latest error has been written.
75649>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
75650>>>>>            End
75650>>>>>>
75650>>>>>            Procedure_Return
75651>>>>>        End
75651>>>>>>
75651>>>>>        Else Begin
75652>>>>>            If (pbQuickWrite(Self) = True) Begin
75654>>>>>                Send WriteErrorLog
75655>>>>>                // Flush the error log array
75655>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty 
75656>>>>>            End
75656>>>>>>
75656>>>>>        End
75656>>>>>>
75656>>>>>    End_Procedure   
75657>>>>>    
75657>>>>>    Function FetchErrorDescription Integer iError Returns String
75659>>>>>        String sErrorText         
75659>>>>>        Move "" to sErrorText
75660>>>>>        If (iError > 0) Begin
75662>>>>>            Move (Error_Text(Desktop, iError)) to sErrorText 
75663>>>>>        End
75663>>>>>>
75663>>>>>        Function_Return sErrorText
75664>>>>>    End_Function
75665>>>>>
75665>>>>>    // Hook procedure for writing header text prior starting the update work to
75665>>>>>    // a database table. This does nothing by default.
75665>>>>>    // Don't forget to Open your "error log table" first (!) as all
75665>>>>>    // tables have been closed at this stage. Put anything
75665>>>>>    // you want to indicate that the update process is just started.
75665>>>>>    Procedure OnWriteHeader_DataTable DateTime dtUpdateStart
75667>>>>>        Delegate Send OnErrorWriteHeader_DataTable dtUpdateStart
75669>>>>>    End_Procedure
75670>>>>>
75670>>>>>    Procedure OnWriteRow_DataTable
75672>>>>>        tDbUpdateError[] DbUpdateErrorArray
75672>>>>>        tDbUpdateError[] DbUpdateErrorArray
75673>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
75674>>>>>        If (SizeOfArray(DbUpdateErrorArray) > 0) Begin
75676>>>>>            Delegate Send OnErrorWriteRow_DataTable DbUpdateErrorArray
75678>>>>>        End
75678>>>>>>
75678>>>>>    End_Procedure
75679>>>>>
75679>>>>>    Function psLogTextFileWithPath Returns String
75681>>>>>        String sPath sFileName sFullFileName
75681>>>>>        
75681>>>>>        Get psDataPathFirstPart to sPath
75682>>>>>        Get psLogTextFile to sFileName
75683>>>>>        Move (sPath + sFileName) to sFullFileName
75684>>>>>        Function_Return sFullFileName
75685>>>>>    End_Function                     
75686>>>>>    
75686>>>>>    Procedure WriteHeaderData
75688>>>>>        String sFileName
75688>>>>>        Integer iCh iSize
75688>>>>>        Boolean bQuickWrite
75688>>>>>        DateTime dtUpdateStart
75688>>>>>
75688>>>>>        Move (CurrentDateTime()) to dtUpdateStart
75689>>>>>        If (pbUseDataTableLog(Self) = True) Begin
75691>>>>>            Send OnWriteHeader_DataTable dtUpdateStart
75692>>>>>            Procedure_Return
75693>>>>>        End
75693>>>>>>
75693>>>>>
75693>>>>>        Get piChannel to iCh
75694>>>>>        If (iCh < 0) Begin
75696>>>>>            Get Seq_New_Channel to iCh
75697>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75699>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
75700>>>>>>
75700>>>>>                Procedure_Return
75701>>>>>            End
75701>>>>>>
75701>>>>>            Set piChannel to iCh
75702>>>>>        End
75702>>>>>>
75702>>>>>
75702>>>>>        Get psLogTextFileWithPath to sFileName
75703>>>>>        Get vWin32_APIFileSize sFileName to iSize
75704>>>>>        Get pbQuickWrite to bQuickWrite
75705>>>>>        
75705>>>>>        If (bQuickWrite = True) Begin
75707>>>>>            Append_Output channel iCh sFileName
75709>>>>>                If (bQuickWrite = True) Begin
75711>>>>>                    If (iSize = 0) Begin
75713>>>>>                        Write channel iCh C_BOM_UTF8
75715>>>>>                        Writeln channel iCh CS_DatabaseUpdateFramework
75718>>>>>                        Set pbEmptyLogFile to False
75719>>>>>                    End
75719>>>>>>
75719>>>>>                    Writeln channel iCh
75721>>>>>                    Writeln channel iCh ("*** Database Update Started:      " + String(dtUpdateStart))
75724>>>>>                End
75724>>>>>>
75724>>>>>            Close_Output channel iCh
75726>>>>>            Set pbHeaderWritten to True
75727>>>>>        End
75727>>>>>>
75727>>>>>    End_Procedure
75728>>>>>
75728>>>>>    // Returns the first datapath found in the psDataPath property.
75728>>>>>    // The returned path always ends with a "\"
75728>>>>>    Function psDataPathFirstPart Returns String
75730>>>>>        String sDataPath
75730>>>>>        Integer iCount
75730>>>>>
75730>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
75731>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
75732>>>>>        If (iCount > 1) Begin
75734>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
75735>>>>>        End
75735>>>>>>
75735>>>>>        If (sDataPath <> "") Begin
75737>>>>>            Get vFolderFormat sDataPath to sDataPath
75738>>>>>        End
75738>>>>>>
75738>>>>>
75738>>>>>        Function_Return sDataPath
75739>>>>>    End_Function
75740>>>>>
75740>>>>>    // Called from the cDbUpdateHandler object after all updates have been done.
75740>>>>>    Procedure WriteErrorLog
75742>>>>>        tDbUpdateError[] aDbUpdateErrorArray
75742>>>>>        tDbUpdateError[] aDbUpdateErrorArray
75743>>>>>        String sFileName sErrorNo sVersion sErrorText sText sRootName sOrgErrorText
75743>>>>>        Integer iCount iSize iCh iError iErrorLine iField
75743>>>>>        Boolean bUseDataTable bQuickWrite
75743>>>>>        DateTime dtUpdateStart dtUpdateEnd
75743>>>>>        TimeSpan tsElapsed
75743>>>>>        Number nVersion                                  
75743>>>>>        Handle hTable
75743>>>>>
75743>>>>>        If (pbHeaderWritten(Self) = False) Begin
75745>>>>>            Send WriteHeaderData
75746>>>>>        End
75746>>>>>>
75746>>>>>
75746>>>>>        Get pbUseDataTableLog to bUseDataTable
75747>>>>>        If (bUseDataTable = True) Begin
75749>>>>>            Send OnWriteRow_DataTable
75750>>>>>            Procedure_Return
75751>>>>>        End
75751>>>>>>
75751>>>>>
75751>>>>>        Get piChannel to iCh
75752>>>>>        If (iCh < 0) Begin
75754>>>>>            Get Seq_New_Channel to iCh
75755>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75757>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
75758>>>>>>
75758>>>>>                Procedure_Return
75759>>>>>            End
75759>>>>>>
75759>>>>>            Set piChannel to iCh
75760>>>>>        End
75760>>>>>>
75760>>>>>
75760>>>>>        Get psLogTextFileWithPath to sFileName
75761>>>>>
75761>>>>>        Get paDbUpdateErrorArray to aDbUpdateErrorArray
75762>>>>>        Move (SizeOfArray(aDbUpdateErrorArray)) to iSize
75763>>>>>        Decrement iSize
75764>>>>>
75764>>>>>        Get pdtUpdateStart to dtUpdateStart
75765>>>>>        If (IsNullDateTime(dtUpdateStart) = False) Begin
75767>>>>>            Move (CurrentDateTime()) to dtUpdateEnd
75768>>>>>            Move (dtUpdateEnd - dtUpdateStart) to tsElapsed
75769>>>>>        End
75769>>>>>>
75769>>>>>        Get pbQuickWrite to bQuickWrite
75770>>>>>
75770>>>>>        Append_Output channel iCh sFileName
75772>>>>>        If (bQuickWrite = True and iSize < 0) Begin
75774>>>>>            Writeln channel iCh ("*** Database Update Finished:  " + String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
75777>>>>>        End
75777>>>>>>
75777>>>>>        Else If (bQuickWrite = False) Begin
75780>>>>>            Writeln channel iCh
75782>>>>>            Writeln channel iCh ("*** Database Update Started:" * String(dtUpdateStart) * "and finished at:" * String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
75785>>>>>        End   
75785>>>>>>
75785>>>>>        If (iSize >= 0) Begin
75787>>>>>            If (aDbUpdateErrorArray[0].bShortFormat = False) Begin
75789>>>>>//                Writeln channel iCh "[Err No:] [pnVersionNumber:] [Status Text:]"
75789>>>>>                Writeln channel iCh "[Err No:] [Version:] [Status Text:]"
75792>>>>>            End
75792>>>>>>
75792>>>>>        End
75792>>>>>>
75792>>>>>
75792>>>>>        For iCount from 0 to iSize  
75798>>>>>>
75798>>>>>            Move aDbUpdateErrorArray[iCount].iError         to iError
75799>>>>>            Move aDbUpdateErrorArray[iCount].nUpdateVersion to nVersion
75800>>>>>            Move aDbUpdateErrorArray[iCount].sErrorText     to sErrorText
75801>>>>>            Move aDbUpdateErrorArray[iCount].iErrorLine     to iErrorLine  
75802>>>>>            Move aDbUpdateErrorArray[iCount].hTable         to hTable
75803>>>>>            Move aDbUpdateErrorArray[iCount].sTableRootName to sRootName
75804>>>>>            Move aDbUpdateErrorArray[iCount].iField         to iField
75805>>>>>            
75805>>>>>            Get PadLeft (String(iError)) 8 to sErrorNo
75806>>>>>            If (iError = 0) Begin
75808>>>>>                Move " Info  " to sErrorNo
75809>>>>>            End
75809>>>>>>
75809>>>>>            If (aDbUpdateErrorArray[iCount].bError = True) Begin
75811>>>>>                Get PadLeft (String(nVersion)) (19 - Length(sErrorNo)) to sVersion
75812>>>>>//                Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
75812>>>>>                Move (sErrorNo + sVersion + "   " + sErrorText * "[ErrLine:" * String(iErrorLine) + "]" + "    (Table:" * sRootName * String(hTable) + "." + String(iField) + ")") to sText
75813>>>>>            End
75813>>>>>>
75813>>>>>            Else Begin
75814>>>>>                Get PadLeft (String(nVersion)) (19 - Length(sErrorNo)) to sVersion
75815>>>>>//                Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
75815>>>>>                Move (sErrorNo + sVersion + "   " + sErrorText) to sText
75816>>>>>            End
75816>>>>>>
75816>>>>>            Writeln channel iCh sText
75819>>>>>            If (aDbUpdateErrorArray[iCount].sOrgErrorText <> "") Begin
75821>>>>>                Move ("   (" + aDbUpdateErrorArray[iCount].sOrgErrorText + ")") to sOrgErrorText
75822>>>>>                Move (Utf8ToAnsi(sOrgErrorText)) to sOrgErrorText       
75823>>>>>                Writeln channel iCh sOrgErrorText
75826>>>>>            End
75826>>>>>>
75826>>>>>            If (sText contains CS_SuccessfulUpdate) Begin
75828>>>>>                Writeln channel iCh
75830>>>>>            End
75830>>>>>>
75830>>>>>        Loop
75831>>>>>>
75831>>>>>        Close_Output channel iCh
75833>>>>>
75833>>>>>        Send Seq_Release_Channel iCh
75834>>>>>        Set piChannel to -1
75835>>>>>
75835>>>>>    End_Procedure
75836>>>>>
75836>>>>>    // The character to pad is optional. If nothing, spaces are used.
75836>>>>>    // Example:
75836>>>>>    // Move (PadLeft(45672,10,"0")) to sString -> "0000045672"
75836>>>>>    //  or:
75836>>>>>    // Move (PadLeft("Test",10)) to sString -> " Test"
75836>>>>>    // Courtesy of Pieter van Dieren. Collected from DAWs' Newsgroups.
75836>>>>>    Function PadLeft String sString Integer iLength String sOptChar Returns String
75838>>>>>        String sChar
75838>>>>>
75838>>>>>        If (Num_Arguments >= 3) Begin
75840>>>>>            Move sOptChar to sChar
75841>>>>>        End
75841>>>>>>
75841>>>>>        Else Begin
75842>>>>>            Move " " to sChar
75843>>>>>        End
75843>>>>>>
75843>>>>>
75843>>>>>        While (Length(sString) < iLength)
75847>>>>>            Move (sChar + sString) to sString
75848>>>>>        Loop
75849>>>>>>
75849>>>>>
75849>>>>>        Function_Return sString
75850>>>>>    End_Function
75851>>>>>
75851>>>>>    Procedure ShowErrorLog
75853>>>>>        String sPath sFileName sEditorProgram
75853>>>>>        Boolean bExists
75853>>>>>
75853>>>>>        Get psLogTextFileWithPath to sFileName
75854>>>>>        Get vFilePathExists sFileName to bExists
75855>>>>>        If (bExists = True) Begin
75857>>>>>            Get psEditorProgram to sEditorProgram
75858>>>>>            If (sEditorProgram <> "") Begin
75860>>>>>                Runprogram Background (psEditorProgram(Self)) (sPath + sFileName)
75861>>>>>            End
75861>>>>>>
75861>>>>>            Else Begin
75862>>>>>                Runprogram Shell Background sFileName
75863>>>>>            End
75863>>>>>>
75863>>>>>        End
75863>>>>>>
75863>>>>>        Else Begin
75864>>>>>            Send Info_Box (CS_DUF_LogFileNotFound + String(sFileName))
75865>>>>>        End
75865>>>>>>
75865>>>>>    End_Procedure
75866>>>>>
75866>>>>>End_Class
75867>>>Use cDbUpdateVersion.pkg
Including file: cDbUpdateVersion.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateVersion.pkg)
75867>>>>>//****************************************************************************
75867>>>>>// $Module type: Class
75867>>>>>// $Module name: cDbUpdateVersion
75867>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75867>>>>>// Web-site    : http://www.rdctools.com
75867>>>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
75867>>>>>//
75867>>>>>// Description : Child class to cDbUpdateHandler.
75867>>>>>//               Put an object of this class inside the global ghoDbUpdateHandler object.
75867>>>>>//               Set the pnVersionNumber to a version number.
75867>>>>>//               Inside the cDbUpdateVersion object put a "Use MyNewDbUpdatePackage.pkg"
75867>>>>>//               Add one cVersion object for each update of the database to the ghoDbUpdateHandler object.
75867>>>>>//               Place your code in the "OnUpdate" event that alters the database.
75867>>>>>//
75867>>>>>// $Rev History:
75867>>>>>//    2016-09-27  Module header created
75867>>>>>//****************************************************************************
75867>>>>>Use UI
75867>>>>>Use DUFLanguageConstants.inc
75867>>>>>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
75867>>>>>>>//****************************************************************************
75867>>>>>>>// $Module type: Class
75867>>>>>>>// $Module name: cDbUpdateFunctionLibrary
75867>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75867>>>>>>>// Web-site    : http://www.rdctools.com
75867>>>>>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
75867>>>>>>>//
75867>>>>>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
75867>>>>>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
75867>>>>>>>//               functions to make db changes to Sql databases with DAW drivers,
75867>>>>>>>//               with the help of Sql-scripts.
75867>>>>>>>//
75867>>>>>>>// $Rev History:
75867>>>>>>>//    2014-09-05  Module header created
75867>>>>>>>//
75867>>>>>>>//****************************************************************************
75867>>>>>>>//
75867>>>>>>>// Martin Moleman on SQL Server and DateTime2 (Don't use DataTime any longer !)
75867>>>>>>>// One remark about your change: I would not change to datetime2(7) (7 decimals) but to
75867>>>>>>>// datetime2(3) (3 decimals = milliseconds) or If you don't need the milliseconds datetime2(0).
75867>>>>>>>// The reason is that the DataFlex DateTime type only allows 3 decimals. When using 7
75867>>>>>>>// decimals you may Get truncation that again may cause problems with finding.
75867>>>>>>>//
75867>>>>>>>// Important! The conversion from DateTime to Date or datetime2 will also convert all dummy zero Date values from 1753-01-01 to 0001-01-01.
75867>>>>>>>// This is important to realize. The conversion will actually change the data in the database (done by the driver)
75867>>>>>>>
75867>>>>>>>
75867>>>>>>>// DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA
75867>>>>>>>// Determines for all DataFlex data types, which SQL native types will be used when creating new columns.
75867>>>>>>>// Set_Attribute DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA of {driverNumber} {databaseHandle} ;
75867>>>>>>>// to {MAP_DF_TO_SQL_TYPE_SQL2000|MAP_DF_TO_SQL_TYPE_SQL2005|MAP_DF_TO_SQL_TYPE_SQL2008|MAP_DF_TO_SQL_TYPE_SQL2012}
75867>>>>>>>//
75867>>>>>>>Use cBaseDbUpdateFuncLib.pkg
Including file: cBaseDbUpdateFuncLib.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cBaseDbUpdateFuncLib.pkg)
75867>>>>>>>>>//****************************************************************************
75867>>>>>>>>>// $Module type: Class
75867>>>>>>>>>// $Module name: cBaseDbUpdateFuncLib
75867>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75867>>>>>>>>>// Web-site    : http://www.rdctools.com
75867>>>>>>>>>// Created     : 2023-11-06 @ 09:50 (Military date format: YY-MM-DD)
75867>>>>>>>>>//
75867>>>>>>>>>// Description : The class consists of the basis/parent for the cDbUpdateFunctionLibrary class
75867>>>>>>>>>//               It contains helper functions for the cDbUpdateFunctionLibrary class
75867>>>>>>>>>//
75867>>>>>>>>>// $Rev History:
75867>>>>>>>>>//    2023-11-06  Module header created
75867>>>>>>>>>//
75867>>>>>>>>>//****************************************************************************
75867>>>>>>>>>Use cApplication.pkg
75867>>>>>>>>>Use seq_chnl.pkg
75867>>>>>>>>>Use GlobalFunctionsProcedures.pkg
75867>>>>>>>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
75867>>>>>>>>>Use Dfcursor.pkg
75867>>>>>>>>>Use DUFStatusPanel.pkg
75867>>>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
75867>>>>>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
75867>>>>>>>>>>>//
75867>>>>>>>>>>>// We need to create a mixin class for the library.
75867>>>>>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
75867>>>>>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
75867>>>>>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
75867>>>>>>>>>>>// Note: This class should _not_ have a construct_object defined.
75867>>>>>>>>>>>//
75867>>>>>>>>>>>Use VdfBase.pkg
75867>>>>>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files\DataFlex 24.0\Pkg\WinUuid.pkg)
75867>>>>>>>>>>>>>Use Unicode.Pkg
75867>>>>>>>>>>>>>
75867>>>>>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll ;    Pointer Uuid ;    Returns Integer
75868>>>>>>>>>>>>>
75868>>>>>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringW" Rpcrt4.dll ;    Pointer pUuid ;    Pointer lpUUIDString ;    Returns Integer
75869>>>>>>>>>>>>>
75869>>>>>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll ;    Pointer pUuid ;    Returns Integer
75870>>>>>>>>>>>>>
75870>>>>>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeW" Rpcrt4.dll ;    Pointer pStr ;    Returns Integer
75871>>>>>>>>>>>>>
75871>>>>>>>>>>>>>
75871>>>>>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
75871>>>>>>>>>>>>>Function RandomHexUUID Global Returns String
75873>>>>>>>>>>>>>    Pointer pUUID pUUIDStr
75873>>>>>>>>>>>>>    Integer iRetval iOffset iChar
75873>>>>>>>>>>>>>    String sUUID
75873>>>>>>>>>>>>>    
75873>>>>>>>>>>>>>    Move (Alloc(16)) to pUUID
75874>>>>>>>>>>>>>    
75874>>>>>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
75875>>>>>>>>>>>>>    
75875>>>>>>>>>>>>>    If (iRetval = 0) Begin
75877>>>>>>>>>>>>>        Move 0 to pUUIDStr
75878>>>>>>>>>>>>>        
75878>>>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75879>>>>>>>>>>>>>        If (iRetval = 0) Begin
75881>>>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75882>>>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75883>>>>>>>>>>>>>            
75883>>>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75884>>>>>>>>>>>>>        End
75884>>>>>>>>>>>>>>
75884>>>>>>>>>>>>>    End
75884>>>>>>>>>>>>>>
75884>>>>>>>>>>>>>    
75884>>>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
75885>>>>>>>>>>>>>    
75885>>>>>>>>>>>>>    Function_Return sUUID
75886>>>>>>>>>>>>>End_Function
75887>>>>>>>>>>>>>
75887>>>>>>>>>>>>>
75887>>>>>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
75887>>>>>>>>>>>>>Function SeqHexUUID Global Returns String
75889>>>>>>>>>>>>>    Pointer pUUID pUUIDStr
75889>>>>>>>>>>>>>    Integer iRetval iOffset iChar
75889>>>>>>>>>>>>>    String sUUID
75889>>>>>>>>>>>>>    
75889>>>>>>>>>>>>>    Move (Alloc(16)) to pUUID
75890>>>>>>>>>>>>>    
75890>>>>>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
75891>>>>>>>>>>>>>    
75891>>>>>>>>>>>>>    If (iRetval = 0) Begin
75893>>>>>>>>>>>>>        Move 0 to pUUIDStr
75894>>>>>>>>>>>>>        
75894>>>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75895>>>>>>>>>>>>>        If (iRetval = 0) Begin
75897>>>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75898>>>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75899>>>>>>>>>>>>>            
75899>>>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75900>>>>>>>>>>>>>        End
75900>>>>>>>>>>>>>>
75900>>>>>>>>>>>>>    End
75900>>>>>>>>>>>>>>
75900>>>>>>>>>>>>>    
75900>>>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
75901>>>>>>>>>>>>>    
75901>>>>>>>>>>>>>    Function_Return sUUID
75902>>>>>>>>>>>>>End_Function
75903>>>>>>>>>>>Use cli.pkg
75903>>>>>>>>>>>Use sql.pkg
75903>>>>>>>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSqldrv.pkg)
75903>>>>>>>>>>>>>//     Package that declares MS SQL driver constants and functions.
75903>>>>>>>>>>>>>//     This package can be used by developers who want to add Data Access
75903>>>>>>>>>>>>>//     MS SQL Client specific code to a DataFlex application.
75903>>>>>>>>>>>>>
75903>>>>>>>>>>>>>Use Cli.pkg
75903>>>>>>>>>>>>>Use SQL.pkg
75903>>>>>>>>>>>>>
75903>>>>>>>>>>>>>//   Driver Indentification
75903>>>>>>>>>>>>>
75903>>>>>>>>>>>>>//   Error number constants
75903>>>>>>>>>>>>>
75903>>>>>>>>>>>>>
75903>>>>>>>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
75903>>>>>>>>>>>>>
75903>>>>>>>>>>>>>
75903>>>>>>>>>>>>>
75903>>>>>>>>>>>>>
75903>>>>>>>>>>>>>
75903>>>>>>>>>>>>>
75903>>>>>>>>>>>>>// SQL Server spcific types.
75903>>>>>>>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
75903>>>>>>>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
75903>>>>>>>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
75903>>>>>>>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
75903>>>>>>>>>>>>>
75903>>>>>>>>>>>>>// SQL Server spcific types.
75903>>>>>>>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
75903>>>>>>>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
75903>>>>>>>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
75903>>>>>>>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
75903>>>>>>>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
75903>>>>>>>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
75903>>>>>>>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
75903>>>>>>>>>>>>>
75903>>>>>>>>>>>>>
75903>>>>>>>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
75903>>>>>>>>>>>>>//
75903>>>>>>>>>>>>>//     Setup a constraint for a file.
75903>>>>>>>>>>>>>
75903>>>>>>>>>>>>>
75903>>>>>>>>>>>>>Class cMSSQLHandler is a cCLIHandler
75904>>>>>>>>>>>>>    
75904>>>>>>>>>>>>>    Procedure Construct_Object
75906>>>>>>>>>>>>>        Forward Send Construct_Object
75908>>>>>>>>>>>>>        
75908>>>>>>>>>>>>>        Set psDriverID to MSSQLDRV_ID
75909>>>>>>>>>>>>>    End_Procedure
75910>>>>>>>>>>>>>    
75910>>>>>>>>>>>>>    
75910>>>>>>>>>>>>>    
75910>>>>>>>>>>>>>    //   Extract the list from the out connect string.
75910>>>>>>>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
75912>>>>>>>>>>>>>        String  sItem
75912>>>>>>>>>>>>>        Integer iStart
75912>>>>>>>>>>>>>        Integer iEnd
75912>>>>>>>>>>>>>        
75912>>>>>>>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
75915>>>>>>>>>>>>>        
75915>>>>>>>>>>>>>        Send Delete_Data to hoStore
75916>>>>>>>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
75917>>>>>>>>>>>>>        While (iStart > 0)
75921>>>>>>>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
75922>>>>>>>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
75925>>>>>>>>>>>>>            Else Begin
75926>>>>>>>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
75927>>>>>>>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
75928>>>>>>>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
75931>>>>>>>>>>>>>                
75931>>>>>>>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
75934>>>>>>>>>>>>>                
75934>>>>>>>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
75937>>>>>>>>>>>>>            End
75937>>>>>>>>>>>>>>
75937>>>>>>>>>>>>>        Loop
75938>>>>>>>>>>>>>>
75938>>>>>>>>>>>>>        
75938>>>>>>>>>>>>>        Function_Return (Item_Count(hoStore))
75939>>>>>>>>>>>>>    End_Procedure
75940>>>>>>>>>>>>>    
75940>>>>>>>>>>>>>    
75940>>>>>>>>>>>>>    
75940>>>>>>>>>>>>>    //   Call the driver's browse connect function
75940>>>>>>>>>>>>>    Function BrowseConnect String sInConnStr Returns String
75942>>>>>>>>>>>>>        String  sDriver
75942>>>>>>>>>>>>>        String  sOutConnStr
75942>>>>>>>>>>>>>        Integer iArg
75942>>>>>>>>>>>>>        Integer iRetval
75942>>>>>>>>>>>>>        
75942>>>>>>>>>>>>>        Get psDriverID to sDriver
75943>>>>>>>>>>>>>        If (sDriver <> "") Begin
75945>>>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75946>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75951>>>>>>>>>>>>>        End
75951>>>>>>>>>>>>>>
75951>>>>>>>>>>>>>        
75951>>>>>>>>>>>>>        Function_Return sOutConnStr
75952>>>>>>>>>>>>>    End_Function// BrowseConnect
75953>>>>>>>>>>>>>    
75953>>>>>>>>>>>>>    
75953>>>>>>>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
75955>>>>>>>>>>>>>        String  sDriver
75955>>>>>>>>>>>>>        String  sOutConnStr
75955>>>>>>>>>>>>>        Integer iArg
75955>>>>>>>>>>>>>        Integer iRetval
75955>>>>>>>>>>>>>        
75955>>>>>>>>>>>>>        Move 1 to iArg // Browses only local
75956>>>>>>>>>>>>>        
75956>>>>>>>>>>>>>        Get psDriverID to sDriver
75957>>>>>>>>>>>>>        If (sDriver <> "") Begin
75959>>>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75960>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75965>>>>>>>>>>>>>        End
75965>>>>>>>>>>>>>>
75965>>>>>>>>>>>>>        
75965>>>>>>>>>>>>>        Function_Return sOutConnStr
75966>>>>>>>>>>>>>    End_Function// BrowseConnect
75967>>>>>>>>>>>>>    
75967>>>>>>>>>>>>>    
75967>>>>>>>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
75969>>>>>>>>>>>>>        String  sServerList
75969>>>>>>>>>>>>>        Integer iNumServers
75969>>>>>>>>>>>>>        Integer iDriver
75969>>>>>>>>>>>>>        Integer iClientVersion
75969>>>>>>>>>>>>>        String  sDriver
75969>>>>>>>>>>>>>        
75969>>>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
75970>>>>>>>>>>>>>        
75970>>>>>>>>>>>>>        If (iDriver) Begin
75972>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
75975>>>>>>>>>>>>>            
75975>>>>>>>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
75976>>>>>>>>>>>>>            
75976>>>>>>>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
75977>>>>>>>>>>>>>            If (iNetworkLocal = 0) Begin
75979>>>>>>>>>>>>>                Get BrowseConnect sDriver to sServerList
75980>>>>>>>>>>>>>            End
75980>>>>>>>>>>>>>>
75980>>>>>>>>>>>>>            Else Begin
75981>>>>>>>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
75982>>>>>>>>>>>>>            End
75982>>>>>>>>>>>>>>
75982>>>>>>>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
75983>>>>>>>>>>>>>        End
75983>>>>>>>>>>>>>>
75983>>>>>>>>>>>>>        
75983>>>>>>>>>>>>>        Function_Return iNumServers
75984>>>>>>>>>>>>>    End_Function
75985>>>>>>>>>>>>>    
75985>>>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
75985>>>>>>>>>>>>>    //   This function will return all SQL Server instances on the network.
75985>>>>>>>>>>>>>    //   This may take a long time.
75985>>>>>>>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
75985>>>>>>>>>>>>>    Function EnumerateServers Returns Integer
75987>>>>>>>>>>>>>        Integer iNumServers
75987>>>>>>>>>>>>>        Integer iNetworkLocal
75987>>>>>>>>>>>>>        
75987>>>>>>>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
75988>>>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75989>>>>>>>>>>>>>
75989>>>>>>>>>>>>>        Function_Return iNumServers
75990>>>>>>>>>>>>>    End_Function
75991>>>>>>>>>>>>>    
75991>>>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
75991>>>>>>>>>>>>>    //   This function will return only return SQL Server instance on the local machine
75991>>>>>>>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
75991>>>>>>>>>>>>>    Function EnumerateServersLocal Returns Integer
75993>>>>>>>>>>>>>        Integer iNumServers
75993>>>>>>>>>>>>>        Integer iNetworkLocal
75993>>>>>>>>>>>>>        
75993>>>>>>>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
75994>>>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75995>>>>>>>>>>>>>        
75995>>>>>>>>>>>>>        Function_Return iNumServers
75996>>>>>>>>>>>>>    End_Function
75997>>>>>>>>>>>>>    
75997>>>>>>>>>>>>>    //   Enumerate database in a given server.
75997>>>>>>>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
75999>>>>>>>>>>>>>        Integer hoSQL
75999>>>>>>>>>>>>>        String  sConnect
75999>>>>>>>>>>>>>        String  sDatabase
75999>>>>>>>>>>>>>        Integer hdbc
75999>>>>>>>>>>>>>        Integer hstmt
75999>>>>>>>>>>>>>        Integer iFetchResult iDriver iClientVersion
75999>>>>>>>>>>>>>        
75999>>>>>>>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
76002>>>>>>>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
76005>>>>>>>>>>>>>        
76005>>>>>>>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
76008>>>>>>>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
76010>>>>>>>>>>>>>
76010>>>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
76011>>>>>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
76014>>>>>>>>>>>>>        If (iClientVersion >= 18) Begin
76016>>>>>>>>>>>>>            Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
76017>>>>>>>>>>>>>            Move (Replaces(" ", sConnect, "")) to sConnect
76018>>>>>>>>>>>>>        End
76018>>>>>>>>>>>>>>
76018>>>>>>>>>>>>>        
76018>>>>>>>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
76020>>>>>>>>>>>>>            Move Current_Object to hoSQL
76021>>>>>>>>>>>>>        End_Object
76022>>>>>>>>>>>>>        
76022>>>>>>>>>>>>>        If (hoSQL <> 0) Begin
76024>>>>>>>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
76025>>>>>>>>>>>>>            If (hdbc <> 0) Begin
76027>>>>>>>>>>>>>                Get SQLOpen of hdbc to hstmt
76028>>>>>>>>>>>>>                If (hstmt <> 0) Begin
76030>>>>>>>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
76030>>>>>>>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
76030>>>>>>>>>>>>>                    //   approach in case meta data might change, the stored procedure will
76030>>>>>>>>>>>>>                    //   stay the same.
76030>>>>>>>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
76031>>>>>>>>>>>>>                    Send SQLCall to hstmt
76032>>>>>>>>>>>>>                    Repeat
76032>>>>>>>>>>>>>>
76032>>>>>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
76033>>>>>>>>>>>>>                        If (iFetchResult <> 0) Begin
76035>>>>>>>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
76036>>>>>>>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
76037>>>>>>>>>>>>>                        End
76037>>>>>>>>>>>>>>
76037>>>>>>>>>>>>>                    Until (iFetchResult = 0)
76039>>>>>>>>>>>>>                    
76039>>>>>>>>>>>>>                    Send SQLClose to hstmt
76040>>>>>>>>>>>>>                End
76040>>>>>>>>>>>>>>
76040>>>>>>>>>>>>>                Send SQLDisconnect to hdbc
76041>>>>>>>>>>>>>            End
76041>>>>>>>>>>>>>>
76041>>>>>>>>>>>>>        End
76041>>>>>>>>>>>>>>
76041>>>>>>>>>>>>>        Send Destroy_Object to hoSQL
76042>>>>>>>>>>>>>        
76042>>>>>>>>>>>>>        Function_Return (Item_Count(Current_Object))
76043>>>>>>>>>>>>>    End_Function
76044>>>>>>>>>>>>>    
76044>>>>>>>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
76046>>>>>>>>>>>>>        String  sSqlServerClientVersionName
76046>>>>>>>>>>>>>        
76046>>>>>>>>>>>>>        Case Begin
76046>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
76048>>>>>>>>>>>>>                Move SQLSERVER2019CLIENTNAME to sSqlServerClientVersionName
76049>>>>>>>>>>>>>                Case Break
76050>>>>>>>>>>>>>            
76050>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
76053>>>>>>>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
76054>>>>>>>>>>>>>                Case Break
76055>>>>>>>>>>>>>                
76055>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
76058>>>>>>>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
76059>>>>>>>>>>>>>                Case Break
76060>>>>>>>>>>>>>            
76060>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
76063>>>>>>>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
76064>>>>>>>>>>>>>                Case Break
76065>>>>>>>>>>>>>            
76065>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
76068>>>>>>>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
76069>>>>>>>>>>>>>                Case Break
76070>>>>>>>>>>>>>            
76070>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
76073>>>>>>>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
76074>>>>>>>>>>>>>                Case Break
76075>>>>>>>>>>>>>            
76075>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
76078>>>>>>>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
76079>>>>>>>>>>>>>                Case Break
76080>>>>>>>>>>>>>            
76080>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
76083>>>>>>>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
76084>>>>>>>>>>>>>                Case Break
76085>>>>>>>>>>>>>            
76085>>>>>>>>>>>>>            Case Else
76085>>>>>>>>>>>>>                Move (SFormat("%1 (version %2) ",SQLSERVERUNKNOWNCLIENTNAME,iClientVersion)) to sSqlServerClientVersionName
76086>>>>>>>>>>>>>        Case End
76086>>>>>>>>>>>>>        
76086>>>>>>>>>>>>>        Function_Return sSqlServerClientVersionName
76087>>>>>>>>>>>>>    End_Function
76088>>>>>>>>>>>>>
76088>>>>>>>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
76090>>>>>>>>>>>>>        String  sSqlServerClientDriverName
76090>>>>>>>>>>>>>        
76090>>>>>>>>>>>>>        Case Begin
76090>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
76092>>>>>>>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientDriverName
76093>>>>>>>>>>>>>                Case Break
76094>>>>>>>>>>>>>
76094>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
76097>>>>>>>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
76098>>>>>>>>>>>>>                Case Break
76099>>>>>>>>>>>>>                
76099>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
76102>>>>>>>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
76103>>>>>>>>>>>>>                Case Break
76104>>>>>>>>>>>>>            
76104>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
76107>>>>>>>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
76108>>>>>>>>>>>>>                Case Break
76109>>>>>>>>>>>>>            
76109>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
76112>>>>>>>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
76113>>>>>>>>>>>>>                Case Break
76114>>>>>>>>>>>>>            
76114>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
76117>>>>>>>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
76118>>>>>>>>>>>>>                Case Break
76119>>>>>>>>>>>>>            
76119>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
76122>>>>>>>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
76123>>>>>>>>>>>>>                Case Break
76124>>>>>>>>>>>>>            
76124>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
76127>>>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
76128>>>>>>>>>>>>>                Case Break
76129>>>>>>>>>>>>>            
76129>>>>>>>>>>>>>            Case Else
76129>>>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
76130>>>>>>>>>>>>>        Case End
76130>>>>>>>>>>>>>        
76130>>>>>>>>>>>>>        Function_Return sSqlServerClientDriverName
76131>>>>>>>>>>>>>    End_Function
76132>>>>>>>>>>>>>    
76132>>>>>>>>>>>>>End_Class
76133>>>>>>>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files\DataFlex 24.0\Pkg\db2_drv.pkg)
76133>>>>>>>>>>>>>// DB2_DRV.PKG                                                          
76133>>>>>>>>>>>>>//   Package that declares DB2 driver constants and functions.          
76133>>>>>>>>>>>>>//   This package can be used by developers who want to add DB2 driver  
76133>>>>>>>>>>>>>//   specific code to a DataFlex application.                           
76133>>>>>>>>>>>>>
76133>>>>>>>>>>>>>Use Cli.pkg
76133>>>>>>>>>>>>>
76133>>>>>>>>>>>>>// Driver attributes
76133>>>>>>>>>>>>>
76133>>>>>>>>>>>>>
76133>>>>>>>>>>>>>// Driver Indentification
76133>>>>>>>>>>>>>
76133>>>>>>>>>>>>>// Error number constants
76133>>>>>>>>>>>>>
76133>>>>>>>>>>>>>// Call driver function identifiers
76133>>>>>>>>>>>>>
76133>>>>>>>>>>>>>// DB2 specific data types
76133>>>>>>>>>>>>>Define SQL_CLOB           for   (-99)
76133>>>>>>>>>>>>>Define SQL_BLOB           for   (-98)
76133>>>>>>>>>>>>>Define SQL_XML            for   (-370)
76133>>>>>>>>>>>>>// DB2 Graphic types are Unicode types
76133>>>>>>>>>>>>>Define SQL_GRAPHIC        for   (-95)
76133>>>>>>>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
76133>>>>>>>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
76133>>>>>>>>>>>>>Define SQL_DBCLOB         for   (-350)
76133>>>>>>>>>>>>>
76133>>>>>>>>>>>>>
76133>>>>>>>>>>>>>// Extra DB2 commands
76133>>>>>>>>>>>>>
76133>>>>>>>>>>>>>
76133>>>>>>>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
76133>>>>>>>>>>>>>//   Setup a constraint for a file.                                     
76133>>>>>>>>>>>>>
76133>>>>>>>>>>>>>
76133>>>>>>>>>>>>>
76133>>>>>>>>>>>>>Class cDB2Handler is a cCLIHandler
76134>>>>>>>>>>>>>    
76134>>>>>>>>>>>>>    Procedure Construct_Object
76136>>>>>>>>>>>>>        Forward Send Construct_Object
76138>>>>>>>>>>>>>        
76138>>>>>>>>>>>>>        Set psDriverID to DB2_DRV_ID
76139>>>>>>>>>>>>>    End_Procedure
76140>>>>>>>>>>>>>    
76140>>>>>>>>>>>>>    
76140>>>>>>>>>>>>>    
76140>>>>>>>>>>>>>    // Reset the datasource list to the beginning
76140>>>>>>>>>>>>>    Procedure SeedDataSources
76142>>>>>>>>>>>>>        String  sDriver
76142>>>>>>>>>>>>>        String  sVoid
76142>>>>>>>>>>>>>        Integer iRetval
76142>>>>>>>>>>>>>        
76142>>>>>>>>>>>>>        Get psDriverID to sDriver
76143>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
76150>>>>>>>>>>>>>    End_Procedure
76151>>>>>>>>>>>>>    
76151>>>>>>>>>>>>>    
76151>>>>>>>>>>>>>    
76151>>>>>>>>>>>>>    // Call the driver's data sources function
76151>>>>>>>>>>>>>    Function DataSources Returns String
76153>>>>>>>>>>>>>        String  sDriver
76153>>>>>>>>>>>>>        String  sDataSource
76153>>>>>>>>>>>>>        String  sDescription
76153>>>>>>>>>>>>>        Integer iLength
76153>>>>>>>>>>>>>        Integer iRetval
76153>>>>>>>>>>>>>        
76153>>>>>>>>>>>>>        Get psDriverID to sDriver
76154>>>>>>>>>>>>>        If (sDriver <> "") Begin
76156>>>>>>>>>>>>>            Move 8192 to iLength
76157>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
76158>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
76159>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
76164>>>>>>>>>>>>>        End
76164>>>>>>>>>>>>>>
76164>>>>>>>>>>>>>        
76164>>>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," *  sDescription, "")))
76167>>>>>>>>>>>>>        Else ;            Function_Return ""
76169>>>>>>>>>>>>>    End_Function
76170>>>>>>>>>>>>>    
76170>>>>>>>>>>>>>End_Class
76171>>>>>>>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files\DataFlex 24.0\Pkg\odbc_drv.pkg)
76171>>>>>>>>>>>>>//   Package that declares ODBC driver constants and functions.         
76171>>>>>>>>>>>>>//   This package can be used by developers who want to add Data Access 
76171>>>>>>>>>>>>>//   ODBC Client specific code to a DataFlex application.               
76171>>>>>>>>>>>>>
76171>>>>>>>>>>>>>Use Cli.pkg
76171>>>>>>>>>>>>>
76171>>>>>>>>>>>>>// Driver Indentification
76171>>>>>>>>>>>>>
76171>>>>>>>>>>>>>// Error number constants
76171>>>>>>>>>>>>>
76171>>>>>>>>>>>>>// Call driver function identifiers
76171>>>>>>>>>>>>>
76171>>>>>>>>>>>>>Class cODBCHandler is a cCLIHandler
76172>>>>>>>>>>>>>    
76172>>>>>>>>>>>>>    Procedure Construct_Object
76174>>>>>>>>>>>>>        Forward Send Construct_Object
76176>>>>>>>>>>>>>        
76176>>>>>>>>>>>>>        Set psDriverID to ODBC_DRV_ID
76177>>>>>>>>>>>>>    End_Procedure
76178>>>>>>>>>>>>>    
76178>>>>>>>>>>>>>    
76178>>>>>>>>>>>>>    
76178>>>>>>>>>>>>>    // Setup the type of data sources returned by the datasources function
76178>>>>>>>>>>>>>    Procedure Set DataSourceType Integer iNewType
76180>>>>>>>>>>>>>        String  sDriver
76180>>>>>>>>>>>>>        String  sVoid
76180>>>>>>>>>>>>>        Integer iRetval
76180>>>>>>>>>>>>>        
76180>>>>>>>>>>>>>        Get psDriverID to sDriver
76181>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
76188>>>>>>>>>>>>>    End_Procedure
76189>>>>>>>>>>>>>    
76189>>>>>>>>>>>>>    
76189>>>>>>>>>>>>>    // Call the driver's data sources function
76189>>>>>>>>>>>>>    Function DataSources Returns String
76191>>>>>>>>>>>>>        String  sDriver
76191>>>>>>>>>>>>>        String  sDataSource
76191>>>>>>>>>>>>>        String  sDescription
76191>>>>>>>>>>>>>        Integer iLength
76191>>>>>>>>>>>>>        Integer iRetval
76191>>>>>>>>>>>>>        
76191>>>>>>>>>>>>>        Get psDriverID to sDriver
76192>>>>>>>>>>>>>        If (sDriver <> "") Begin
76194>>>>>>>>>>>>>            Move 8192 to iLength
76195>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
76196>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
76197>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
76202>>>>>>>>>>>>>        End
76202>>>>>>>>>>>>>>
76202>>>>>>>>>>>>>        
76202>>>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," * sDescription, "")))
76205>>>>>>>>>>>>>        Else ;            Function_Return ""
76207>>>>>>>>>>>>>    End_Function
76208>>>>>>>>>>>>>    
76208>>>>>>>>>>>>>End_Class
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files\DataFlex 24.0\Pkg\DFBTRDRV.PKG)
76209>>>>>>>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
76209>>>>>>>>>>>>>// Notice      : This package contains constants and commands, used to call
76209>>>>>>>>>>>>>//               specific functions in the DFBTRDRV.
76209>>>>>>>>>>>>>Use Ui
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>// Driver Indentification
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>// Driver attributes
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>// Call_Driver functions ID's
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>// DFBTRFN_CONVERT_FILE options
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>// DFBTRFN_SET_OWNER options
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>// Command to create all vars which may be needed
76209>>>>>>>>>>>>>// in other commands.
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>// Command to set the owner of a Btrieve file.
76209>>>>>>>>>>>>>// File must have been opened.
76209>>>>>>>>>>>>>// Filenumber needs to be passed.
76209>>>>>>>>>>>>>// To clear set the owner to "".
76209>>>>>>>>>>>>>// Examples:
76209>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
76209>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
76209>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
76209>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
76209>>>>>>>>>>>>>// To clear:
76209>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>// Command to parse DFBTR_SET_OWNVER
76209>>>>>>>>>>>>>// options.
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>// Command to parse for Callback
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>// Command to clear the owner of a Btrieve file.
76209>>>>>>>>>>>>>// File must have been opened.
76209>>>>>>>>>>>>>// Filenumber needs to be passed.
76209>>>>>>>>>>>>>// Examples:
76209>>>>>>>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>// Command to add a owner name to the internal list of ownernames
76209>>>>>>>>>>>>>// which will be tries when opening files.
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>// Command to remove all owners from the internal list of ownernames
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>// Command to set the owner name to be used when opening the DDF files.
76209>>>>>>>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
76209>>>>>>>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
76209>>>>>>>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>// Command to change the transaction type.
76209>>>>>>>>>>>>>// Valid types are:
76209>>>>>>>>>>>>>//     DFBTRTT_NONE
76209>>>>>>>>>>>>>//     DFBTRTT_EXCLUSIVE
76209>>>>>>>>>>>>>//     DFBTRTT_CONCURRENT
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>// Command to get the current transaction type.
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>// Command to set explicit_locking
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>// Command to get explicit locking
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
76209>>>>>>>>>>>>>//
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>// Purpose: An instance of this class can be used as a broker object to
76209>>>>>>>>>>>>>//          call several Dfbtrdrv releated methods.
76209>>>>>>>>>>>>>
76209>>>>>>>>>>>>>Class cDFBtrDrvHandler is an Array
76210>>>>>>>>>>>>>    
76210>>>>>>>>>>>>>    Procedure Construct_Object Integer iImage
76212>>>>>>>>>>>>>        Forward Send Construct_object iImage
76214>>>>>>>>>>>>>        
76214>>>>>>>>>>>>>        Property String  psDriverID "DFBTRDRV"
76215>>>>>>>>>>>>>    End_Procedure
76216>>>>>>>>>>>>>    
76216>>>>>>>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
76216>>>>>>>>>>>>>    //
76216>>>>>>>>>>>>>    
76216>>>>>>>>>>>>>    Function CKRevision Returns String
76218>>>>>>>>>>>>>        String  sDriverID
76218>>>>>>>>>>>>>        String  sRevision
76218>>>>>>>>>>>>>        String  sVoid
76218>>>>>>>>>>>>>        Integer iRetval
76218>>>>>>>>>>>>>        
76218>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76218>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76218>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76218>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76219>>>>>>>>>>>>>        Get psDriverID to sDriverID
76220>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sRevision
76221>>>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
76226>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76227>>>>>>>>>>>>>        If (Trim(sRevision) = "") Begin
76229>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76229>>>>>>>>>>>>>            Move "0.0.0.0" to sRevision
76230>>>>>>>>>>>>>        End
76230>>>>>>>>>>>>>>
76230>>>>>>>>>>>>>        Function_Return sRevision
76231>>>>>>>>>>>>>    End_Function
76232>>>>>>>>>>>>>    
76232>>>>>>>>>>>>>    Function CkUsesUri Returns Integer
76234>>>>>>>>>>>>>        String  sDriverID
76234>>>>>>>>>>>>>        String  sVoid1
76234>>>>>>>>>>>>>        String  sVoid2
76234>>>>>>>>>>>>>        Integer iRetval
76234>>>>>>>>>>>>>        
76234>>>>>>>>>>>>>        Get psDriverID to sDriverID
76235>>>>>>>>>>>>>        
76235>>>>>>>>>>>>>        Move 0 to iRetval
76236>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76236>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76236>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
76236>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76237>>>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
76242>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76243>>>>>>>>>>>>>        
76243>>>>>>>>>>>>>        Function_Return iRetval
76244>>>>>>>>>>>>>    End_Function
76245>>>>>>>>>>>>>    
76245>>>>>>>>>>>>>    
76245>>>>>>>>>>>>>    
76245>>>>>>>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
76245>>>>>>>>>>>>>    //
76245>>>>>>>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
76245>>>>>>>>>>>>>    //
76245>>>>>>>>>>>>>    
76245>>>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
76247>>>>>>>>>>>>>        Integer iPartRev
76247>>>>>>>>>>>>>        Integer iCurrentPart
76247>>>>>>>>>>>>>        Integer iSeparatorPos
76247>>>>>>>>>>>>>        
76247>>>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
76250>>>>>>>>>>>>>        
76250>>>>>>>>>>>>>        Move 0 to iCurrentPart
76251>>>>>>>>>>>>>        Repeat
76251>>>>>>>>>>>>>>
76251>>>>>>>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
76252>>>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
76254>>>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
76255>>>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
76256>>>>>>>>>>>>>                Increment iCurrentPart
76257>>>>>>>>>>>>>            End
76257>>>>>>>>>>>>>>
76257>>>>>>>>>>>>>            Else If (sRevision <> "") Begin
76260>>>>>>>>>>>>>                Move sRevision to iPartRev
76261>>>>>>>>>>>>>                Move "" to sRevision
76262>>>>>>>>>>>>>                Increment iCurrentPart
76263>>>>>>>>>>>>>            End
76263>>>>>>>>>>>>>>
76263>>>>>>>>>>>>>            Else ;                Move -1 to iPartRev
76265>>>>>>>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
76267>>>>>>>>>>>>>        
76267>>>>>>>>>>>>>        Function_Return iPartRev
76268>>>>>>>>>>>>>    End_Function
76269>>>>>>>>>>>>>    
76269>>>>>>>>>>>>>    
76269>>>>>>>>>>>>>    
76269>>>>>>>>>>>>>    //
76269>>>>>>>>>>>>>    //  Returns the major revision of the CK
76269>>>>>>>>>>>>>    //
76269>>>>>>>>>>>>>    
76269>>>>>>>>>>>>>    Function CKMajorRevision Returns Integer
76271>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
76272>>>>>>>>>>>>>    End_Function
76273>>>>>>>>>>>>>    
76273>>>>>>>>>>>>>    
76273>>>>>>>>>>>>>    
76273>>>>>>>>>>>>>    //  Returns the minor revision of the CK
76273>>>>>>>>>>>>>    //
76273>>>>>>>>>>>>>    
76273>>>>>>>>>>>>>    Function CKMinorRevision Returns Integer
76275>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
76276>>>>>>>>>>>>>    End_Function
76277>>>>>>>>>>>>>    
76277>>>>>>>>>>>>>    
76277>>>>>>>>>>>>>    //  Returns the release revision of the CK
76277>>>>>>>>>>>>>    //
76277>>>>>>>>>>>>>    
76277>>>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
76279>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
76280>>>>>>>>>>>>>    End_Function
76281>>>>>>>>>>>>>    
76281>>>>>>>>>>>>>    
76281>>>>>>>>>>>>>    //  Returns the major revision of the CK
76281>>>>>>>>>>>>>    //
76281>>>>>>>>>>>>>    
76281>>>>>>>>>>>>>    Function CKBuildRevision Returns Integer
76283>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
76284>>>>>>>>>>>>>    End_Function
76285>>>>>>>>>>>>>    
76285>>>>>>>>>>>>>    
76285>>>>>>>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
76285>>>>>>>>>>>>>    //
76285>>>>>>>>>>>>>    
76285>>>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
76287>>>>>>>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
76290>>>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
76293>>>>>>>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
76296>>>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
76299>>>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
76302>>>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
76306>>>>>>>>>>>>>            End
76306>>>>>>>>>>>>>>
76306>>>>>>>>>>>>>        End
76306>>>>>>>>>>>>>>
76306>>>>>>>>>>>>>        
76306>>>>>>>>>>>>>        Function_Return (False)
76307>>>>>>>>>>>>>    End_Function
76308>>>>>>>>>>>>>    
76308>>>>>>>>>>>>>    //   Functions to query the Pervasive.SQL version:
76308>>>>>>>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
76308>>>>>>>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
76308>>>>>>>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
76308>>>>>>>>>>>>>    //
76308>>>>>>>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
76308>>>>>>>>>>>>>    //   in the following format:
76308>>>>>>>>>>>>>    //       <version>.<revision>.<type>
76308>>>>>>>>>>>>>    //   possible values for <type>:
76308>>>>>>>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
76308>>>>>>>>>>>>>    //         server using Workgroup authentication mode
76308>>>>>>>>>>>>>    //       C for client cache engine
76308>>>>>>>>>>>>>    //       D for DOS workstation
76308>>>>>>>>>>>>>    //       N for client Requester
76308>>>>>>>>>>>>>    //       S for NetWare server
76308>>>>>>>>>>>>>    //       T for 32-bit Windows server engine
76308>>>>>>>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
76308>>>>>>>>>>>>>    //
76308>>>>>>>>>>>>>    //   example:
76308>>>>>>>>>>>>>    //       8.50.T
76308>>>>>>>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
76308>>>>>>>>>>>>>    //   32-bits Windows server.
76308>>>>>>>>>>>>>    //
76308>>>>>>>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
76308>>>>>>>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
76308>>>>>>>>>>>>>    //
76308>>>>>>>>>>>>>    //   If the version information is not available or can not be obtained
76308>>>>>>>>>>>>>    //   the functions will return "0.0.0"
76308>>>>>>>>>>>>>    
76308>>>>>>>>>>>>>    //  Returns the version information of the
76308>>>>>>>>>>>>>    //           Pervasive.SQL Client requester.
76308>>>>>>>>>>>>>    
76308>>>>>>>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
76310>>>>>>>>>>>>>        
76310>>>>>>>>>>>>>        String  sDriverID
76310>>>>>>>>>>>>>        String  sVersion
76310>>>>>>>>>>>>>        String  sVoid
76310>>>>>>>>>>>>>        Integer iRetval
76310>>>>>>>>>>>>>        
76310>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76310>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76310>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76310>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76311>>>>>>>>>>>>>        Get psDriverID to sDriverID
76312>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76313>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76318>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76319>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76321>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76321>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76322>>>>>>>>>>>>>        End
76322>>>>>>>>>>>>>>
76322>>>>>>>>>>>>>        Function_Return sVersion
76323>>>>>>>>>>>>>    End_Function
76324>>>>>>>>>>>>>    
76324>>>>>>>>>>>>>    //           Pervasive.SQL Engine
76324>>>>>>>>>>>>>    
76324>>>>>>>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
76326>>>>>>>>>>>>>        
76326>>>>>>>>>>>>>        String  sDriverID
76326>>>>>>>>>>>>>        String  sVersion
76326>>>>>>>>>>>>>        String  sVoid
76326>>>>>>>>>>>>>        Integer iRetval
76326>>>>>>>>>>>>>        
76326>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76326>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76326>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76326>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76327>>>>>>>>>>>>>        Get psDriverID to sDriverID
76328>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76329>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76334>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76335>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76337>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76337>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76338>>>>>>>>>>>>>        End
76338>>>>>>>>>>>>>>
76338>>>>>>>>>>>>>        Function_Return sVersion
76339>>>>>>>>>>>>>    End_Function
76340>>>>>>>>>>>>>    
76340>>>>>>>>>>>>>    //  Returns the version information of the
76340>>>>>>>>>>>>>    //           Pervasive.SQL Server Engine
76340>>>>>>>>>>>>>    
76340>>>>>>>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
76342>>>>>>>>>>>>>        
76342>>>>>>>>>>>>>        String  sDriverID
76342>>>>>>>>>>>>>        String  sVersion
76342>>>>>>>>>>>>>        String  sVoid
76342>>>>>>>>>>>>>        Integer iRetval
76342>>>>>>>>>>>>>        
76342>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76342>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76342>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76342>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76343>>>>>>>>>>>>>        Get psDriverID to sDriverID
76344>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76345>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76350>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76351>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76353>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76353>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76354>>>>>>>>>>>>>        End
76354>>>>>>>>>>>>>>
76354>>>>>>>>>>>>>        Function_Return sVersion
76355>>>>>>>>>>>>>    End_Function
76356>>>>>>>>>>>>>    
76356>>>>>>>>>>>>>End_Class
76357>>>>>>>>>>>>>
76357>>>>>>>>>>>>>
76357>>>>>>>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
76357>>>>>>>>>>>>>//****************************************************************************
76357>>>>>>>>>>>>>// $Module type: Include file
76357>>>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.inc
76357>>>>>>>>>>>>>//
76357>>>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
76357>>>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
76357>>>>>>>>>>>>>// E-mail      : support@rdctools.com
76357>>>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76357>>>>>>>>>>>>>//
76357>>>>>>>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
76357>>>>>>>>>>>>>//
76357>>>>>>>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
76357>>>>>>>>>>>>>//
76357>>>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
76357>>>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
76357>>>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
76357>>>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
76357>>>>>>>>>>>>>// in the help folder for more details.
76357>>>>>>>>>>>>>//
76357>>>>>>>>>>>>>Use Winkern.pkg
76357>>>>>>>>>>>>>Use cIniFile.pkg
76357>>>>>>>>>>>>>    Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCryptographerEx.pkg)
76357>>>>>>>>>>>>>>>Use VdfBase.pkg
76357>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 24.0\Pkg\CryptographerConstants.pkg)
76357>>>>>>>>>>>>>>>>>//   Author  : Ulbe Stellema
76357>>>>>>>>>>>>>>>>>// Algorithm classes
76357>>>>>>>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
76357>>>>>>>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
76357>>>>>>>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
76357>>>>>>>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
76357>>>>>>>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
76357>>>>>>>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
76357>>>>>>>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>// Algorithm types
76357>>>>>>>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
76357>>>>>>>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
76357>>>>>>>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
76357>>>>>>>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
76357>>>>>>>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
76357>>>>>>>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
76357>>>>>>>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>// Generic sub-ids
76357>>>>>>>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>// RSA sub-ids
76357>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
76357>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
76357>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
76357>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
76357>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>// DSS sub-ids
76357>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
76357>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
76357>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>// DES sub_ids
76357>>>>>>>>>>>>>>>>>Define ALG_SID_DES                      for 1
76357>>>>>>>>>>>>>>>>>Define ALG_SID_3DES                     for 3
76357>>>>>>>>>>>>>>>>>Define ALG_SID_DESX                     for 4
76357>>>>>>>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
76357>>>>>>>>>>>>>>>>>Define ALG_SID_CAST                     for 6
76357>>>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
76357>>>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
76357>>>>>>>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
76357>>>>>>>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
76357>>>>>>>>>>>>>>>>>Define ALG_SID_RC5                      for 13
76357>>>>>>>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
76357>>>>>>>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
76357>>>>>>>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
76357>>>>>>>>>>>>>>>>>Define ALG_SID_AES                      for 17
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>// Fortezza sub-ids
76357>>>>>>>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
76357>>>>>>>>>>>>>>>>>Define ALG_SID_TEK                      for 11
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>// RC2 sub-ids
76357>>>>>>>>>>>>>>>>>Define ALG_SID_RC2                      for 2
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>// Stream cipher sub-ids
76357>>>>>>>>>>>>>>>>>Define ALG_SID_RC4                      for 1
76357>>>>>>>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>// Diffie-Hellman sub-ids
76357>>>>>>>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
76357>>>>>>>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
76357>>>>>>>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
76357>>>>>>>>>>>>>>>>>Define ALG_SID_KEA                      for 4
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>// Hash sub ids
76357>>>>>>>>>>>>>>>>>Define ALG_SID_MD2                      for 1
76357>>>>>>>>>>>>>>>>>Define ALG_SID_MD4                      for 2
76357>>>>>>>>>>>>>>>>>Define ALG_SID_MD5                      for 3
76357>>>>>>>>>>>>>>>>>Define ALG_SID_SHA                      for 4
76357>>>>>>>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
76357>>>>>>>>>>>>>>>>>Define ALG_SID_MAC                      for 5
76357>>>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
76357>>>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
76357>>>>>>>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
76357>>>>>>>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
76357>>>>>>>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
76357>>>>>>>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
76357>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
76357>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
76357>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>// secure channel sub ids
76357>>>>>>>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
76357>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
76357>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
76357>>>>>>>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
76357>>>>>>>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
76357>>>>>>>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
76357>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>// algorithm identifier definitions
76357>>>>>>>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
76357>>>>>>>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
76357>>>>>>>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
76357>>>>>>>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
76357>>>>>>>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
76357>>>>>>>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
76357>>>>>>>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
76357>>>>>>>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
76357>>>>>>>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
76357>>>>>>>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
76357>>>>>>>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
76357>>>>>>>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
76357>>>>>>>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
76357>>>>>>>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
76357>>>>>>>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
76357>>>>>>>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
76357>>>>>>>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
76357>>>>>>>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
76357>>>>>>>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
76357>>>>>>>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
76357>>>>>>>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
76357>>>>>>>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
76357>>>>>>>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
76357>>>>>>>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
76357>>>>>>>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
76357>>>>>>>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
76357>>>>>>>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
76357>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
76357>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
76357>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
76357>>>>>>>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
76357>>>>>>>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
76357>>>>>>>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
76357>>>>>>>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
76357>>>>>>>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
76357>>>>>>>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
76357>>>>>>>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
76357>>>>>>>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
76357>>>>>>>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
76357>>>>>>>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
76357>>>>>>>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
76357>>>>>>>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
76357>>>>>>>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
76357>>>>>>>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>// Providers
76357>>>>>>>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
76357>>>>>>>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
76357>>>>>>>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
76357>>>>>>>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
76357>>>>>>>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
76357>>>>>>>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
76357>>>>>>>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
76357>>>>>>>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
76357>>>>>>>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
76357>>>>>>>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
76357>>>>>>>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
76357>>>>>>>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
76357>>>>>>>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
76357>>>>>>>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
76357>>>>>>>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
76357>>>>>>>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>// dwFlag definitions for CryptGenKey
76357>>>>>>>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
76357>>>>>>>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
76357>>>>>>>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
76357>>>>>>>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
76357>>>>>>>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
76357>>>>>>>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
76357>>>>>>>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
76357>>>>>>>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
76357>>>>>>>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
76357>>>>>>>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
76357>>>>>>>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
76357>>>>>>>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
76357>>>>>>>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
76357>>>>>>>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
76357>>>>>>>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
76357>>>>>>>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>// Provider types
76357>>>>>>>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
76357>>>>>>>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
76357>>>>>>>>>>>>>>>>>Define PROV_DSS                         for 3
76357>>>>>>>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
76357>>>>>>>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
76357>>>>>>>>>>>>>>>>>Define PROV_SSL                         for 6
76357>>>>>>>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
76357>>>>>>>>>>>>>>>>>Define PROV_DSS_DH                      for 13
76357>>>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
76357>>>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
76357>>>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
76357>>>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
76357>>>>>>>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
76357>>>>>>>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
76357>>>>>>>>>>>>>>>>>Define PROV_RNG                         for 21
76357>>>>>>>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
76357>>>>>>>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
76357>>>>>>>>>>>>>>>>>Define PROV_RSA_AES                     for 24
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>// KP_MODE
76357>>>>>>>>>>>>>>>>>// KP_MODE
76357>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
76357>>>>>>>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
76357>>>>>>>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
76357>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
76357>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
76357>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
76357>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
76357>>>>>>>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
76357>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
76357>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
76357>>>>>>>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
76357>>>>>>>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
76357>>>>>>>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
76357>>>>>>>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
76357>>>>>>>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
76357>>>>>>>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
76357>>>>>>>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
76357>>>>>>>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
76357>>>>>>>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
76357>>>>>>>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
76357>>>>>>>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
76357>>>>>>>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
76357>>>>>>>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
76357>>>>>>>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
76357>>>>>>>>>>>>>>>>>Define KP_Y                             for 15      // Y value
76357>>>>>>>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
76357>>>>>>>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
76357>>>>>>>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
76357>>>>>>>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
76357>>>>>>>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
76357>>>>>>>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
76357>>>>>>>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
76357>>>>>>>>>>>>>>>>>Define KP_RP                            for 23
76357>>>>>>>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
76357>>>>>>>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
76357>>>>>>>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
76357>>>>>>>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
76357>>>>>>>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
76357>>>>>>>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
76357>>>>>>>>>>>>>>>>>Define KP_KEYVAL                        for 30
76357>>>>>>>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
76357>>>>>>>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
76357>>>>>>>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
76357>>>>>>>>>>>>>>>>>Define KP_PREHASH                       for 34
76357>>>>>>>>>>>>>>>>>Define KP_ROUNDS                        for 35
76357>>>>>>>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
76357>>>>>>>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
76357>>>>>>>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
76357>>>>>>>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
76357>>>>>>>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
76357>>>>>>>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
76357>>>>>>>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
76357>>>>>>>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
76357>>>>>>>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
76357>>>>>>>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
76357>>>>>>>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>// key BLOB types
76357>>>>>>>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
76357>>>>>>>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
76357>>>>>>>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
76357>>>>>>>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
76357>>>>>>>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
76357>>>>>>>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
76357>>>>>>>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
76357>>>>>>>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>// KP_PADDING
76357>>>>>>>>>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
76357>>>>>>>>>>>>>>>>>Define RANDOM_PADDING                   for 2
76357>>>>>>>>>>>>>>>>>Define ZERO_PADDING                     for 3
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>//  Structure cryptimportkey
76357>>>>>>>>>>>>>>>>>Struct PUBLICKEYSTRUC
76357>>>>>>>>>>>>>>>>>    UChar    bType
76357>>>>>>>>>>>>>>>>>    UChar    bVersion
76357>>>>>>>>>>>>>>>>>    UShort   reserved
76357>>>>>>>>>>>>>>>>>    UInteger aiKeyAlg
76357>>>>>>>>>>>>>>>>>End_Struct
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
76357>>>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
76357>>>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
76357>>>>>>>>>>>>>>>>>    UInteger       dwKeySize
76357>>>>>>>>>>>>>>>>>//    UChar[]        rgbKeyData
76357>>>>>>>>>>>>>>>>>End_Struct
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
76357>>>>>>>>>>>>>>>>>Struct HMAC_INFO
76357>>>>>>>>>>>>>>>>>    UInteger HashAlgid
76357>>>>>>>>>>>>>>>>>    Pointer pbInnerString
76357>>>>>>>>>>>>>>>>>    DWord cbInnerString
76357>>>>>>>>>>>>>>>>>    Pointer pbOuterString
76357>>>>>>>>>>>>>>>>>    DWord cbOuterString
76357>>>>>>>>>>>>>>>>>End_Struct
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>Struct BLOBHEADER
76357>>>>>>>>>>>>>>>>>    UChar   bType
76357>>>>>>>>>>>>>>>>>    UChar   bVersion
76357>>>>>>>>>>>>>>>>>    Short   reserved
76357>>>>>>>>>>>>>>>>>    Integer aiKeyAlg
76357>>>>>>>>>>>>>>>>>End_Struct
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>Struct CryptoBlob
76357>>>>>>>>>>>>>>>>>    BLOBHEADER  header
76357>>>>>>>>>>>>>>>>>    BLOBHEADER  header
76357>>>>>>>>>>>>>>>>>    Integer     cbKeySize
76357>>>>>>>>>>>>>>>>>    UChar[32]   rgbKeyData
76357>>>>>>>>>>>>>>>>>End_Struct
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>
76357>>>>>>>>>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
76357>>>>>>>>>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
76358>>>>>>>>>>>>>>>>>
76358>>>>>>>>>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
76358>>>>>>>>>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
76360>>>>>>>>>>>>>>>>>    
76360>>>>>>>>>>>>>>>>>    Boolean bResult
76360>>>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
76360>>>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
76360>>>>>>>>>>>>>>>>>
76360>>>>>>>>>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
76361>>>>>>>>>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
76362>>>>>>>>>>>>>>>>>    
76362>>>>>>>>>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
76363>>>>>>>>>>>>>>>>>
76363>>>>>>>>>>>>>>>>>    Function_Return bResult
76364>>>>>>>>>>>>>>>>>End_Function
76365>>>>>>>>>>>>>>>>>
76365>>>>>>>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
76366>>>>>>>>>>>>>>>>>
76366>>>>>>>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
76367>>>>>>>>>>>>>>>>>
76367>>>>>>>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
76368>>>>>>>>>>>>>>>>>
76368>>>>>>>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
76369>>>>>>>>>>>>>>>>>
76369>>>>>>>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76370>>>>>>>>>>>>>>>>>
76370>>>>>>>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
76371>>>>>>>>>>>>>>>>>
76371>>>>>>>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
76372>>>>>>>>>>>>>>>>>
76372>>>>>>>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76373>>>>>>>>>>>>>>>>>
76373>>>>>>>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
76374>>>>>>>>>>>>>>>>>    
76374>>>>>>>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
76375>>>>>>>>>>>>>>>>>
76375>>>>>>>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
76376>>>>>>>>>>>>>>>>>
76376>>>>>>>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
76377>>>>>>>>>>>>>>>>>
76377>>>>>>>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
76378>>>>>>>>>>>>>>>>>    
76378>>>>>>>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
76379>>>>>>>>>>>>>>>>>    
76379>>>>>>>>>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76380>>>>>>>>>>>>>>>>>    
76380>>>>>>>>>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
76381>>>>>>>>>>>>>>>
76381>>>>>>>>>>>>>>>Class cCryptographerEx is a cObject
76382>>>>>>>>>>>>>>>    
76382>>>>>>>>>>>>>>>    Procedure Construct_Object
76384>>>>>>>>>>>>>>>        Forward Send Construct_Object
76386>>>>>>>>>>>>>>>        
76386>>>>>>>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
76387>>>>>>>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
76388>>>>>>>>>>>>>>>        Property Integer    piCipher    CALG_RC4
76389>>>>>>>>>>>>>>>        Property Integer    piHash      CALG_MD5
76390>>>>>>>>>>>>>>>        
76390>>>>>>>>>>>>>>>        // Private properties
76390>>>>>>>>>>>>>>>        Property Handle     Private_phProv
76391>>>>>>>>>>>>>>>        
76391>>>>>>>>>>>>>>>        // Block cipher properties
76391>>>>>>>>>>>>>>>        Property UChar[]    paKey
76392>>>>>>>>>>>>>>>        Property UChar[]    paIV
76393>>>>>>>>>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
76394>>>>>>>>>>>>>>>        Property Integer    piKeyType       CALG_AES_256
76395>>>>>>>>>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
76396>>>>>>>>>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
76397>>>>>>>>>>>>>>>        Property Integer    piBlockSize     16
76398>>>>>>>>>>>>>>>    End_Procedure
76399>>>>>>>>>>>>>>>    
76399>>>>>>>>>>>>>>>    
76399>>>>>>>>>>>>>>>    // Acquire key container handle
76399>>>>>>>>>>>>>>>    Function AcquireContext Returns Handle
76401>>>>>>>>>>>>>>>        Integer iProvider
76401>>>>>>>>>>>>>>>        WString wProvider
76401>>>>>>>>>>>>>>>        Handle hProv
76401>>>>>>>>>>>>>>>        Boolean bOk
76401>>>>>>>>>>>>>>>        Pointer pProv
76401>>>>>>>>>>>>>>>        
76401>>>>>>>>>>>>>>>        Move 0 to hProv
76402>>>>>>>>>>>>>>>        Get piProvider to iProvider
76403>>>>>>>>>>>>>>>        Get psProvider to wProvider
76404>>>>>>>>>>>>>>>        
76404>>>>>>>>>>>>>>>        //  Determine address to be passed as provider
76404>>>>>>>>>>>>>>>        If (Trim(wProvider) <> "") Begin
76406>>>>>>>>>>>>>>>            Move (AddressOf(wProvider)) to pProv
76407>>>>>>>>>>>>>>>        End
76407>>>>>>>>>>>>>>>>
76407>>>>>>>>>>>>>>>        Else Begin
76408>>>>>>>>>>>>>>>            Move 0 to pProv
76409>>>>>>>>>>>>>>>        End
76409>>>>>>>>>>>>>>>>
76409>>>>>>>>>>>>>>>        
76409>>>>>>>>>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
76409>>>>>>>>>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
76410>>>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
76412>>>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
76413>>>>>>>>>>>>>>>        End
76413>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>        
76413>>>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
76415>>>>>>>>>>>>>>>            // Fallback to original
76415>>>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
76416>>>>>>>>>>>>>>>            
76416>>>>>>>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
76418>>>>>>>>>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
76419>>>>>>>>>>>>>>>            End
76419>>>>>>>>>>>>>>>>
76419>>>>>>>>>>>>>>>        End
76419>>>>>>>>>>>>>>>>
76419>>>>>>>>>>>>>>>        Set Private_phProv to hProv
76420>>>>>>>>>>>>>>>        
76420>>>>>>>>>>>>>>>        Function_Return hProv
76421>>>>>>>>>>>>>>>    End_Function
76422>>>>>>>>>>>>>>>    
76422>>>>>>>>>>>>>>>    // Releases key container handle
76422>>>>>>>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
76424>>>>>>>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
76425>>>>>>>>>>>>>>>    End_Function
76426>>>>>>>>>>>>>>>    
76426>>>>>>>>>>>>>>>    // Creates hash object
76426>>>>>>>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
76428>>>>>>>>>>>>>>>        Integer iAlgorithm
76428>>>>>>>>>>>>>>>        Handle hHash
76428>>>>>>>>>>>>>>>        Boolean bOk
76428>>>>>>>>>>>>>>>        
76428>>>>>>>>>>>>>>>        Move 0 to hHash
76429>>>>>>>>>>>>>>>        Get piHash to iAlgorithm
76430>>>>>>>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
76431>>>>>>>>>>>>>>>        
76431>>>>>>>>>>>>>>>        Function_Return hHash
76432>>>>>>>>>>>>>>>    End_Function
76433>>>>>>>>>>>>>>>    
76433>>>>>>>>>>>>>>>    // Destroys the hash object
76433>>>>>>>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
76435>>>>>>>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
76436>>>>>>>>>>>>>>>    End_Function
76437>>>>>>>>>>>>>>>    
76437>>>>>>>>>>>>>>>    // Adds data to hash object
76437>>>>>>>>>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
76439>>>>>>>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
76440>>>>>>>>>>>>>>>    End_Function
76441>>>>>>>>>>>>>>>    
76441>>>>>>>>>>>>>>>    // Generates session key
76441>>>>>>>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
76443>>>>>>>>>>>>>>>        Integer iAlgorithm
76443>>>>>>>>>>>>>>>        Handle hKey
76443>>>>>>>>>>>>>>>        Boolean bOk
76443>>>>>>>>>>>>>>>        
76443>>>>>>>>>>>>>>>        Move 0 to hKey
76444>>>>>>>>>>>>>>>        Get piCipher to iAlgorithm
76445>>>>>>>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
76446>>>>>>>>>>>>>>>        
76446>>>>>>>>>>>>>>>        Function_Return hKey
76447>>>>>>>>>>>>>>>    End_Function
76448>>>>>>>>>>>>>>>    
76448>>>>>>>>>>>>>>>    // Imports a plain text key
76448>>>>>>>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
76450>>>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
76450>>>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
76450>>>>>>>>>>>>>>>        Boolean   bSuccess
76450>>>>>>>>>>>>>>>        Handle    hKey
76450>>>>>>>>>>>>>>>        Integer   iHeadSize iKeySize
76450>>>>>>>>>>>>>>>        UChar[]   ucaKeyblob
76451>>>>>>>>>>>>>>>        Integer iVoid
76451>>>>>>>>>>>>>>>        
76451>>>>>>>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
76452>>>>>>>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
76453>>>>>>>>>>>>>>>        
76453>>>>>>>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
76454>>>>>>>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
76455>>>>>>>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
76456>>>>>>>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
76457>>>>>>>>>>>>>>>        
76457>>>>>>>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
76458>>>>>>>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
76459>>>>>>>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
76460>>>>>>>>>>>>>>>        
76460>>>>>>>>>>>>>>>        Move 0 to hKey
76461>>>>>>>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
76462>>>>>>>>>>>>>>>        If (not(bSuccess)) Begin
76464>>>>>>>>>>>>>>>            Move (ShowLastError()) to iVoid
76465>>>>>>>>>>>>>>>        End
76465>>>>>>>>>>>>>>>>
76465>>>>>>>>>>>>>>>        
76465>>>>>>>>>>>>>>>        Function_Return hKey
76466>>>>>>>>>>>>>>>    End_Function
76467>>>>>>>>>>>>>>>    
76467>>>>>>>>>>>>>>>    // Destroys the key
76467>>>>>>>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
76469>>>>>>>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
76470>>>>>>>>>>>>>>>    End_Function
76471>>>>>>>>>>>>>>>    
76471>>>>>>>>>>>>>>>    // Retrieves key data
76471>>>>>>>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
76473>>>>>>>>>>>>>>>        Integer iBuffer iLen
76473>>>>>>>>>>>>>>>        Boolean bOk
76473>>>>>>>>>>>>>>>        
76473>>>>>>>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
76474>>>>>>>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
76475>>>>>>>>>>>>>>>        Function_Return iBuffer
76476>>>>>>>>>>>>>>>    End_Function
76477>>>>>>>>>>>>>>>    
76477>>>>>>>>>>>>>>>    // Retrieves a hash value
76477>>>>>>>>>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
76479>>>>>>>>>>>>>>>        UChar[] ucHash
76480>>>>>>>>>>>>>>>        Integer liResult
76480>>>>>>>>>>>>>>>        DWord   dwDataLen
76480>>>>>>>>>>>>>>>        
76480>>>>>>>>>>>>>>>        Move 0 to dwDataLen
76481>>>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
76482>>>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
76485>>>>>>>>>>>>>>>        
76485>>>>>>>>>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
76486>>>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
76487>>>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
76490>>>>>>>>>>>>>>>        
76490>>>>>>>>>>>>>>>        Function_Return ucHash
76491>>>>>>>>>>>>>>>    End_Function
76492>>>>>>>>>>>>>>>
76492>>>>>>>>>>>>>>>    // Encrypts data
76492>>>>>>>>>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
76494>>>>>>>>>>>>>>>        Handle hProv hHash hKey
76494>>>>>>>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
76494>>>>>>>>>>>>>>>        Boolean bOk
76494>>>>>>>>>>>>>>>        
76494>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76495>>>>>>>>>>>>>>>        If (hProv) Begin
76497>>>>>>>>>>>>>>>            Get CreateHash hProv to hHash
76498>>>>>>>>>>>>>>>            If (hHash) Begin
76500>>>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
76501>>>>>>>>>>>>>>>                If (bOk) Begin
76503>>>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
76504>>>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
76505>>>>>>>>>>>>>>>                End
76505>>>>>>>>>>>>>>>>
76505>>>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
76506>>>>>>>>>>>>>>>            End
76506>>>>>>>>>>>>>>>>
76506>>>>>>>>>>>>>>>            
76506>>>>>>>>>>>>>>>            If (hKey) Begin
76508>>>>>>>>>>>>>>>                //  First call to determine resulting data size
76508>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
76509>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
76510>>>>>>>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
76511>>>>>>>>>>>>>>>                
76511>>>>>>>>>>>>>>>                //  Reserve space in string
76511>>>>>>>>>>>>>>>                If (iDataLen < iCipherLen) Begin
76513>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
76514>>>>>>>>>>>>>>>                End
76514>>>>>>>>>>>>>>>>
76514>>>>>>>>>>>>>>>                
76514>>>>>>>>>>>>>>>                //  Call to really decrypt
76514>>>>>>>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
76515>>>>>>>>>>>>>>>                //If (not(bOk)) Begin
76515>>>>>>>>>>>>>>>                //Move "" to sData
76515>>>>>>>>>>>>>>>                //Move (GetLastError()) to iErr
76515>>>>>>>>>>>>>>>                //End
76515>>>>>>>>>>>>>>>                
76515>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76516>>>>>>>>>>>>>>>            End 
76516>>>>>>>>>>>>>>>>
76516>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76517>>>>>>>>>>>>>>>        End 
76517>>>>>>>>>>>>>>>>
76517>>>>>>>>>>>>>>>        Function_Return ucData
76518>>>>>>>>>>>>>>>    End_Function
76519>>>>>>>>>>>>>>>    
76519>>>>>>>>>>>>>>>    // Decrypts data
76519>>>>>>>>>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
76521>>>>>>>>>>>>>>>        Handle hProv hHash hKey
76521>>>>>>>>>>>>>>>        Integer iAlgorithm iDataLen
76521>>>>>>>>>>>>>>>        Boolean bOk
76521>>>>>>>>>>>>>>>        
76521>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76522>>>>>>>>>>>>>>>        If (hProv) Begin
76524>>>>>>>>>>>>>>>            Get CreateHash hProv to hHash
76525>>>>>>>>>>>>>>>            If (hHash) Begin
76527>>>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
76528>>>>>>>>>>>>>>>                If (bOk) Begin
76530>>>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
76531>>>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
76532>>>>>>>>>>>>>>>                End
76532>>>>>>>>>>>>>>>>
76532>>>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
76533>>>>>>>>>>>>>>>            End
76533>>>>>>>>>>>>>>>>
76533>>>>>>>>>>>>>>>            
76533>>>>>>>>>>>>>>>            If (hKey) Begin
76535>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
76536>>>>>>>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
76537>>>>>>>>>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
76537>>>>>>>>>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
76539>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
76540>>>>>>>>>>>>>>>                End
76540>>>>>>>>>>>>>>>>
76540>>>>>>>>>>>>>>>                
76540>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76541>>>>>>>>>>>>>>>            End
76541>>>>>>>>>>>>>>>>
76541>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76542>>>>>>>>>>>>>>>        End
76542>>>>>>>>>>>>>>>>
76542>>>>>>>>>>>>>>>        Function_Return ucData
76543>>>>>>>>>>>>>>>    End_Function
76544>>>>>>>>>>>>>>>    
76544>>>>>>>>>>>>>>>    // Creates a key
76544>>>>>>>>>>>>>>>    Function CreateKey Handle hProv Returns Handle
76546>>>>>>>>>>>>>>>        Integer iAlg iType iByte iLength iSize
76546>>>>>>>>>>>>>>>        CryptoBlob keyBlob
76546>>>>>>>>>>>>>>>        CryptoBlob keyBlob
76546>>>>>>>>>>>>>>>        Boolean bOk
76546>>>>>>>>>>>>>>>        Handle hKey
76546>>>>>>>>>>>>>>>        UChar[] aKey
76547>>>>>>>>>>>>>>>
76547>>>>>>>>>>>>>>>        Get paKey to aKey
76548>>>>>>>>>>>>>>>        Get piKeyAlg to iAlg
76549>>>>>>>>>>>>>>>        Get piKeyType to iType
76550>>>>>>>>>>>>>>>        Move iAlg                   to keyBlob.header.bType
76551>>>>>>>>>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
76552>>>>>>>>>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
76553>>>>>>>>>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
76554>>>>>>>>>>>>>>>        
76554>>>>>>>>>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
76555>>>>>>>>>>>>>>>        For iByte from 0 to iLength
76561>>>>>>>>>>>>>>>>
76561>>>>>>>>>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
76562>>>>>>>>>>>>>>>        Loop
76563>>>>>>>>>>>>>>>>
76563>>>>>>>>>>>>>>>        
76563>>>>>>>>>>>>>>>        Move 0 to hKey
76564>>>>>>>>>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
76565>>>>>>>>>>>>>>>        Function_Return hKey
76566>>>>>>>>>>>>>>>    End_Function
76567>>>>>>>>>>>>>>>    
76567>>>>>>>>>>>>>>>    // Sets the key parameters
76567>>>>>>>>>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
76569>>>>>>>>>>>>>>>        Integer iPadding iMode
76569>>>>>>>>>>>>>>>        Boolean bOk
76569>>>>>>>>>>>>>>>        UChar[] aIV
76570>>>>>>>>>>>>>>>        
76570>>>>>>>>>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
76570>>>>>>>>>>>>>>>        //For iByte from 0 to iLength
76570>>>>>>>>>>>>>>>        //    Move iByte to aIV[iByte]
76570>>>>>>>>>>>>>>>        //Loop
76570>>>>>>>>>>>>>>>
76570>>>>>>>>>>>>>>>        // Set initialization vector
76570>>>>>>>>>>>>>>>        Get paIV to aIV
76571>>>>>>>>>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
76572>>>>>>>>>>>>>>>        If (bOk) Begin
76574>>>>>>>>>>>>>>>            // Set padding
76574>>>>>>>>>>>>>>>            Get piKeyPadding to iPadding
76575>>>>>>>>>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
76576>>>>>>>>>>>>>>>            If (bOk) Begin
76578>>>>>>>>>>>>>>>                // Set move
76578>>>>>>>>>>>>>>>                Get piKeyMode to iMode
76579>>>>>>>>>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
76580>>>>>>>>>>>>>>>            End
76580>>>>>>>>>>>>>>>>
76580>>>>>>>>>>>>>>>        End
76580>>>>>>>>>>>>>>>>
76580>>>>>>>>>>>>>>>        Function_Return bOk        
76581>>>>>>>>>>>>>>>    End_Function
76582>>>>>>>>>>>>>>>    
76582>>>>>>>>>>>>>>>    // Encrypts using block cipher
76582>>>>>>>>>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
76584>>>>>>>>>>>>>>>        Handle hProv hKey
76584>>>>>>>>>>>>>>>        Integer iLen iSize iBlocks
76584>>>>>>>>>>>>>>>        Boolean bOk
76584>>>>>>>>>>>>>>>        
76584>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76585>>>>>>>>>>>>>>>        If (hProv) Begin
76587>>>>>>>>>>>>>>>            // Create key
76587>>>>>>>>>>>>>>>            Get CreateKey hProv to hKey
76588>>>>>>>>>>>>>>>            If (hKey) Begin
76590>>>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
76591>>>>>>>>>>>>>>>                If (bOk) Begin
76593>>>>>>>>>>>>>>>                    // Buffer for block ciphers can be up to block length larger
76593>>>>>>>>>>>>>>>                    Get piBlockSize to iSize
76594>>>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76595>>>>>>>>>>>>>>>                    
76595>>>>>>>>>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
76596>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
76597>>>>>>>>>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
76598>>>>>>>>>>>>>>>                End
76598>>>>>>>>>>>>>>>>
76598>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76599>>>>>>>>>>>>>>>            End
76599>>>>>>>>>>>>>>>>
76599>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76600>>>>>>>>>>>>>>>        End
76600>>>>>>>>>>>>>>>>
76600>>>>>>>>>>>>>>>        Function_Return ucData
76601>>>>>>>>>>>>>>>    End_Function
76602>>>>>>>>>>>>>>>    
76602>>>>>>>>>>>>>>>    // Decrypts using block cipher
76602>>>>>>>>>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
76604>>>>>>>>>>>>>>>        Handle hProv hKey
76604>>>>>>>>>>>>>>>        Integer iLen
76604>>>>>>>>>>>>>>>        Boolean bOk
76604>>>>>>>>>>>>>>>        
76604>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76605>>>>>>>>>>>>>>>        If (hProv) Begin
76607>>>>>>>>>>>>>>>            // Create key
76607>>>>>>>>>>>>>>>            Get CreateKey hProv to hKey
76608>>>>>>>>>>>>>>>            If (hKey) Begin
76610>>>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
76611>>>>>>>>>>>>>>>                If (bOk) Begin
76613>>>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76614>>>>>>>>>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
76615>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
76616>>>>>>>>>>>>>>>                End
76616>>>>>>>>>>>>>>>>
76616>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76617>>>>>>>>>>>>>>>            End
76617>>>>>>>>>>>>>>>>
76617>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76618>>>>>>>>>>>>>>>        End
76618>>>>>>>>>>>>>>>>
76618>>>>>>>>>>>>>>>        Function_Return ucData
76619>>>>>>>>>>>>>>>    End_Function
76620>>>>>>>>>>>>>>>    
76620>>>>>>>>>>>>>>>    
76620>>>>>>>>>>>>>>>    //  Generates random data.
76620>>>>>>>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
76622>>>>>>>>>>>>>>>        Handle hProv
76622>>>>>>>>>>>>>>>        UChar[] uaResult
76623>>>>>>>>>>>>>>>        Boolean bRes
76623>>>>>>>>>>>>>>>        
76623>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76624>>>>>>>>>>>>>>>        
76624>>>>>>>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
76625>>>>>>>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
76626>>>>>>>>>>>>>>>        
76626>>>>>>>>>>>>>>>        Get ReleaseContext hProv to bRes
76627>>>>>>>>>>>>>>>        
76627>>>>>>>>>>>>>>>        Function_Return uaResult
76628>>>>>>>>>>>>>>>    End_Function
76629>>>>>>>>>>>>>>>    
76629>>>>>>>>>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
76629>>>>>>>>>>>>>>>    Function GenerateRandomString Integer iLength Returns String
76631>>>>>>>>>>>>>>>        String sResult
76631>>>>>>>>>>>>>>>        UChar[] ucData
76632>>>>>>>>>>>>>>>        Pointer pBase64
76632>>>>>>>>>>>>>>>        Integer iVoid
76632>>>>>>>>>>>>>>>        
76632>>>>>>>>>>>>>>>        Get GenerateRandom iLength to ucData
76633>>>>>>>>>>>>>>>        
76633>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
76634>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76635>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76636>>>>>>>>>>>>>>>        
76636>>>>>>>>>>>>>>>        Function_Return (Left(sResult, iLength))
76637>>>>>>>>>>>>>>>    End_Function
76638>>>>>>>>>>>>>>>    
76638>>>>>>>>>>>>>>>End_Class
76639>>>>>>>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Base64Functions.pkg)
76639>>>>>>>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
76639>>>>>>>>>>>>>>>//>
76639>>>>>>>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
76639>>>>>>>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
76639>>>>>>>>>>>>>>>//>
76639>>>>>>>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
76639>>>>>>>>>>>>>>>//> strings.
76639>>>>>>>>>>>>>>>//>
76639>>>>>>>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
76639>>>>>>>>>>>>>>>//> Base64Decode) that are built into the runtime.
76639>>>>>>>>>>>>>>>//>
76639>>>>>>>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
76639>>>>>>>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
76639>>>>>>>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
76639>>>>>>>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
76639>>>>>>>>>>>>>>>
76639>>>>>>>>>>>>>>>Use VdfBase.pkg
76639>>>>>>>>>>>>>>>
76639>>>>>>>>>>>>>>>// Functions in vdfBase64.dll
76639>>>>>>>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
76640>>>>>>>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
76641>>>>>>>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
76642>>>>>>>>>>>>>>>
76642>>>>>>>>>>>>>>>// Structure
76642>>>>>>>>>>>>>>>Struct txxfBase64Buffer
76642>>>>>>>>>>>>>>>    Pointer pData
76642>>>>>>>>>>>>>>>    Integer iLength
76642>>>>>>>>>>>>>>>End_Struct 
76642>>>>>>>>>>>>>>>
76642>>>>>>>>>>>>>>>Global_Variable Integer oBase64Functions
76642>>>>>>>>>>>>>>>
76642>>>>>>>>>>>>>>>Object _oBase64Functions is a cObject
76644>>>>>>>>>>>>>>>    Move Self to oBase64Functions
76645>>>>>>>>>>>>>>>
76645>>>>>>>>>>>>>>>
76645>>>>>>>>>>>>>>>    Function EncodeString String sValue Returns String
76648>>>>>>>>>>>>>>>        Address pBase64
76648>>>>>>>>>>>>>>>        String sResult
76648>>>>>>>>>>>>>>>        Integer iVoid
76648>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
76649>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76650>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76651>>>>>>>>>>>>>>>        Function_Return sResult
76652>>>>>>>>>>>>>>>    End_Function
76653>>>>>>>>>>>>>>>
76653>>>>>>>>>>>>>>>    Function DecodeString String sValue Returns String
76656>>>>>>>>>>>>>>>        Address pBinary
76656>>>>>>>>>>>>>>>        String sBinary
76656>>>>>>>>>>>>>>>        Integer iVoid iLen
76656>>>>>>>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
76657>>>>>>>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
76658>>>>>>>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
76659>>>>>>>>>>>>>>>        Move (Free(pBinary)) to iVoid
76660>>>>>>>>>>>>>>>        Function_Return sBinary
76661>>>>>>>>>>>>>>>    End_Function
76662>>>>>>>>>>>>>>>
76662>>>>>>>>>>>>>>>End_Object
76663>>>>>>>>>>>>>Use MSSqldrv.pkg
76663>>>>>>>>>>>>>Use db2_drv.pkg
76663>>>>>>>>>>>>>Use odbc_drv.pkg
76663>>>>>>>>>>>>>Use DFBtrDrv.pkg
76663>>>>>>>>>>>>>Use vWin32fh.pkg
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>Use DUFLanguageConstants.inc
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>// Create a new PSQL identifier for the Btrieve driver.
76663>>>>>>>>>>>>>    Define PSQLDRV_ID for "DFBTRDRV"
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
76663>>>>>>>>>>>>>// They can have slightly different SQL keywords.
76663>>>>>>>>>>>>>// Note: If a new type is added to the list,
76663>>>>>>>>>>>>>//       the struct array xxx must be adjusted
76663>>>>>>>>>>>>>//       so that it is filled with all SQL
76663>>>>>>>>>>>>>//       keywords for that new type.
76663>>>>>>>>>>>>>Enum_List  
76663>>>>>>>>>>>>>        Define EN_DbTypeDataFlex   for 0
76663>>>>>>>>>>>>>        Define EN_DbTypeMSSQL      for 1
76663>>>>>>>>>>>>>        Define EN_DbTypeMySQL      for 2
76663>>>>>>>>>>>>>        Define EN_DbTypeOracle     for 3
76663>>>>>>>>>>>>>        Define EN_DbTypeDB2        for 4
76663>>>>>>>>>>>>>        Define EN_DbTypePostgre    for 5
76663>>>>>>>>>>>>>        Define EN_DbTypePervasive  for 6
76663>>>>>>>>>>>>>End_Enum_List
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
76663>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
76663>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
76663>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
76663>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
76663>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
76663>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
76663>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
76663>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
76663>>>>>>>>>>>>>Define CS_DbTypePervasive   for "Pervasive.SQL (Btrieve)"
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>// SQLConnection.ini constants:
76663>>>>>>>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
76663>>>>>>>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
76663>>>>>>>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
76663>>>>>>>>>>>>>Define CS_SQLIniSectionName             for "Connection"
76663>>>>>>>>>>>>>Define CS_SQLODBCIniSectionName         for "ODBC"
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>// DF 19 ini-file settings:
76663>>>>>>>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
76663>>>>>>>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
76663>>>>>>>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
76663>>>>>>>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
76663>>>>>>>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
76663>>>>>>>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
76663>>>>>>>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
76663>>>>>>>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
76663>>>>>>>>>>>>>Define CS_SQLIniFileDSNKeyword          for "FILEDSN"
76663>>>>>>>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
76663>>>>>>>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection" 
76663>>>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>// Database Update Framework extended settings:
76663>>>>>>>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
76663>>>>>>>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
76663>>>>>>>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
76663>>>>>>>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
76663>>>>>>>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
76663>>>>>>>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
76663>>>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
76663>>>>>>>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
76663>>>>>>>>>>>>>Define CS_SQLIniConnectionNo            for "No"
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>Struct tSQLConnection
76663>>>>>>>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
76663>>>>>>>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
76663>>>>>>>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
76663>>>>>>>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. MSSQLDRV, DB2_DRV, ODBC_DRV or PSQLDRV_ID.
76663>>>>>>>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
76663>>>>>>>>>>>>>    String sDatabase                // 6. SQL Database
76663>>>>>>>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
76663>>>>>>>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
76663>>>>>>>>>>>>>    String sUserID                  // 9. User ID
76663>>>>>>>>>>>>>    String sPassword                // 10. Password
76663>>>>>>>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
76663>>>>>>>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
76663>>>>>>>>>>>>>    String sLongTableSpace          // 13. DB2 specific
76663>>>>>>>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
76663>>>>>>>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
76663>>>>>>>>>>>>>    Boolean bError                  // 16. Set to true on error.
76663>>>>>>>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
76663>>>>>>>>>>>>>End_Struct
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>Struct tFilelist
76663>>>>>>>>>>>>>    String sRootName
76663>>>>>>>>>>>>>    String sLogicalName
76663>>>>>>>>>>>>>    String sDisplayName    
76663>>>>>>>>>>>>>    String sNoDriverRootname
76663>>>>>>>>>>>>>    String sDriver
76663>>>>>>>>>>>>>    Handle hTable
76663>>>>>>>>>>>>>    Boolean bIsSystemFile 
76663>>>>>>>>>>>>>    Boolean bErrorOpening
76663>>>>>>>>>>>>>    Boolean bIsAlias
76663>>>>>>>>>>>>>End_Struct
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>Struct tFilelistLogicalName
76663>>>>>>>>>>>>>    String sLogicalName
76663>>>>>>>>>>>>>    String sNoDriverRootname
76663>>>>>>>>>>>>>    String sRootName
76663>>>>>>>>>>>>>    String sDisplayName    
76663>>>>>>>>>>>>>    String sDriver
76663>>>>>>>>>>>>>    Handle hTable
76663>>>>>>>>>>>>>    Boolean bIsSystemFile 
76663>>>>>>>>>>>>>    Boolean bErrorOpening
76663>>>>>>>>>>>>>    Boolean bIsAlias
76663>>>>>>>>>>>>>End_Struct
76663>>>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
76663>>>>>>>>>>>>>Use DUFLanguageConstants.inc
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
76663>>>>>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>    Define CS_OEM_Txt for "OEM"
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>    Define CS_SERVER for "SERVER"
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
76663>>>>>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>    Define CS_DUFBackupDataFolder for "BackupData"
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
76663>>>>>>>>>>>>>
76663>>>>>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary  
76663>>>>>>>>>>>>>    Move 0 to ghoDbUpdateFunctionLibrary
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>Struct tSQLScriptArray
76664>>>>>>>>>>>>>    Boolean bError
76664>>>>>>>>>>>>>    Boolean bArgumentSizeChanged
76664>>>>>>>>>>>>>    Integer iOrgArgumentSize
76664>>>>>>>>>>>>>    String[] sSQLScriptArray
76664>>>>>>>>>>>>>End_Struct
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>Struct tSqlErrorArray
76664>>>>>>>>>>>>>    String[]  sSqlErrorArray
76664>>>>>>>>>>>>>    String[]  sSqlStatementArray
76664>>>>>>>>>>>>>    Integer[] iSqlErrorArray
76664>>>>>>>>>>>>>End_Struct
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>Struct tSqlColumnNew
76664>>>>>>>>>>>>>    String  sBaseColumnName
76664>>>>>>>>>>>>>    String  sBaseTableName
76664>>>>>>>>>>>>>    String  sLabel
76664>>>>>>>>>>>>>    Integer iSqlType
76664>>>>>>>>>>>>>    Integer iSize
76664>>>>>>>>>>>>>    Integer iPrecision
76664>>>>>>>>>>>>>    Integer iDFType
76664>>>>>>>>>>>>>    Integer iDFNativeType
76664>>>>>>>>>>>>>End_Struct
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>Struct tColumnType
76664>>>>>>>>>>>>>    Integer iSQLType
76664>>>>>>>>>>>>>    String  sSQLType
76664>>>>>>>>>>>>>    Boolean bCanEditSize
76664>>>>>>>>>>>>>    Integer iDefaultSize
76664>>>>>>>>>>>>>    Integer iMinSize
76664>>>>>>>>>>>>>    Number  nMaxSize
76664>>>>>>>>>>>>>    String  sDataFlexType
76664>>>>>>>>>>>>>    Integer iDataFlexType
76664>>>>>>>>>>>>>    Boolean bNativeDataType
76664>>>>>>>>>>>>>    String  sPrecision
76664>>>>>>>>>>>>>End_Struct
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
76664>>>>>>>>>>>>>// Various SQL back-ends can have slightly different
76664>>>>>>>>>>>>>// keywords.
76664>>>>>>>>>>>>>Struct tSQLKeyWords
76664>>>>>>>>>>>>>    Integer iSQLWord
76664>>>>>>>>>>>>>    Integer iSQLDbType
76664>>>>>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
76664>>>>>>>>>>>>>End_Struct
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>Struct tSQLRelation
76664>>>>>>>>>>>>>    Integer iFileNumber
76664>>>>>>>>>>>>>    Integer iFieldNumber
76664>>>>>>>>>>>>>    String  sFileName
76664>>>>>>>>>>>>>    String  sFieldName
76664>>>>>>>>>>>>>End_Struct
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>Struct tSQLLoggedInUser
76664>>>>>>>>>>>>>    String sUser
76664>>>>>>>>>>>>>    String sProgram
76664>>>>>>>>>>>>>End_Struct
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
76664>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
76664>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
76664>>>>>>>>>>>>>// They can have slightly different SQL keywords.
76664>>>>>>>>>>>>>// Note: If a new type is added to the list,
76664>>>>>>>>>>>>>//       the struct array xxx must be adjusted
76664>>>>>>>>>>>>>//       so that it is filled with all SQL
76664>>>>>>>>>>>>>//       keywords for that new type.
76664>>>>>>>>>>>>>Enum_List
76664>>>>>>>>>>>>>//    Define EN_DbTypeMSSQL
76664>>>>>>>>>>>>>//    Define EN_DbTypeMySQL
76664>>>>>>>>>>>>>//    Define EN_DbTypeOracle
76664>>>>>>>>>>>>>//    Define EN_DbTypeDB2
76664>>>>>>>>>>>>>//    Define EN_DbTypePostgre
76664>>>>>>>>>>>>>//    Define EN_DbTypeDataFlex // Embedded database.
76664>>>>>>>>>>>>>End_Enum_List
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
76664>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
76664>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
76664>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
76664>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
76664>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
76664>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
76664>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
76664>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
76664>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
76664>>>>>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
76664>>>>>>>>>>>>>Enum_List
76664>>>>>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
76664>>>>>>>>>>>>>    Define DF_BCD_DUF       for -1499
76664>>>>>>>>>>>>>    Define DF_DATE_DUF      for -1498
76664>>>>>>>>>>>>>    Define DF_TEXT_DUF      for -1495
76664>>>>>>>>>>>>>    Define DF_BINARY_DUF    for -1494
76664>>>>>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
76664>>>>>>>>>>>>>End_Enum_List
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
76664>>>>>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
76664>>>>>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>// These are not defined pre DF 18:
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>Struct tSQLIntTableInfo
76664>>>>>>>>>>>>>    String sDriverName
76664>>>>>>>>>>>>>    String sServerName
76664>>>>>>>>>>>>>    String sDatabaseName
76664>>>>>>>>>>>>>    String sSchemaName
76664>>>>>>>>>>>>>    Boolean bRecnumTable
76664>>>>>>>>>>>>>    Integer iPrimaryIndex
76664>>>>>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
76664>>>>>>>>>>>>>    String sTableCharacterFormat
76664>>>>>>>>>>>>>    Boolean bUseDummyZeroDate
76664>>>>>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
76664>>>>>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
76664>>>>>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
76664>>>>>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
76664>>>>>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
76664>>>>>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
76664>>>>>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
76664>>>>>>>>>>>>>    String sFileIndexTablespace
76664>>>>>>>>>>>>>    String sFileLongTablespace
76664>>>>>>>>>>>>>    String sTableTablespace
76664>>>>>>>>>>>>>End_Struct
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>Struct tSQLIntColumnInfo
76664>>>>>>>>>>>>>    Integer iFieldNumber
76664>>>>>>>>>>>>>    Integer iFieldIndex
76664>>>>>>>>>>>>>    Integer iFieldRelatedFile
76664>>>>>>>>>>>>>    Integer iFieldRelatedField
76664>>>>>>>>>>>>>    Integer iIndexNumber
76664>>>>>>>>>>>>>    Integer iIndexNumberSegments
76664>>>>>>>>>>>>>    Integer iIndexSegmentField1
76664>>>>>>>>>>>>>    Integer iIndexSegmentField2
76664>>>>>>>>>>>>>    Integer iIndexSegmentFieldn
76664>>>>>>>>>>>>>    String  sIndexName
76664>>>>>>>>>>>>>End_Struct
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>Struct tAPIColumn
76664>>>>>>>>>>>>>    Integer iFieldNumber
76664>>>>>>>>>>>>>    String  sFieldName
76664>>>>>>>>>>>>>    Integer iType
76664>>>>>>>>>>>>>    String  sType
76664>>>>>>>>>>>>>    Integer iLength
76664>>>>>>>>>>>>>    Integer iPrecision
76664>>>>>>>>>>>>>    Integer iOptions
76664>>>>>>>>>>>>>    Boolean bIsSQLType
76664>>>>>>>>>>>>>    Boolean bAllowNULL
76664>>>>>>>>>>>>>    String  sDefaultValue
76664>>>>>>>>>>>>>    Boolean bShouldChange
76664>>>>>>>>>>>>>    Boolean bCancel
76664>>>>>>>>>>>>>    Boolean bError
76664>>>>>>>>>>>>>End_Struct
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>Struct tAPIColumnCompare
76664>>>>>>>>>>>>>    Integer iFieldNumber
76664>>>>>>>>>>>>>    // FROM database:
76664>>>>>>>>>>>>>    Boolean bExistsFrom
76664>>>>>>>>>>>>>    String  sFieldNameFrom
76664>>>>>>>>>>>>>    Integer iTypeFrom
76664>>>>>>>>>>>>>    String  sTypeFrom
76664>>>>>>>>>>>>>    Integer iLengthFrom
76664>>>>>>>>>>>>>    Integer iPrecisionFrom
76664>>>>>>>>>>>>>    Integer iOptionsFrom
76664>>>>>>>>>>>>>    Boolean bIsSQLTypeFrom
76664>>>>>>>>>>>>>    Boolean bAllowNULLFrom
76664>>>>>>>>>>>>>    String  sDefaultValueFrom
76664>>>>>>>>>>>>>    Boolean bShouldChangeFrom
76664>>>>>>>>>>>>>    Boolean bCancelFrom
76664>>>>>>>>>>>>>    Boolean bErrorFrom
76664>>>>>>>>>>>>>    // TO database:
76664>>>>>>>>>>>>>    Boolean bExistsTo
76664>>>>>>>>>>>>>    Integer iFieldNumberTo
76664>>>>>>>>>>>>>    String  sFieldNameTo
76664>>>>>>>>>>>>>    Integer iTypeTo
76664>>>>>>>>>>>>>    String  sTypeTo
76664>>>>>>>>>>>>>    Integer iLengthTo
76664>>>>>>>>>>>>>    Integer iPrecisionTo
76664>>>>>>>>>>>>>    Integer iOptionsTo
76664>>>>>>>>>>>>>    Boolean bIsSQLTypeTo
76664>>>>>>>>>>>>>    Boolean bAllowNULLTo
76664>>>>>>>>>>>>>    String  sDefaultValueTo
76664>>>>>>>>>>>>>    Boolean bShouldChangeTo
76664>>>>>>>>>>>>>    Boolean bCancelTo
76664>>>>>>>>>>>>>    Boolean bErrorTo
76664>>>>>>>>>>>>>End_Struct
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>Struct tAPIRelation
76664>>>>>>>>>>>>>    Handle  hTableFrom
76664>>>>>>>>>>>>>    Integer iColumnFrom
76664>>>>>>>>>>>>>    Handle  hTableTo
76664>>>>>>>>>>>>>    Integer iColumnTo
76664>>>>>>>>>>>>>    String  sLogicalNameFrom
76664>>>>>>>>>>>>>    String  sLogicalNameTo
76664>>>>>>>>>>>>>    String  sFieldNameFrom
76664>>>>>>>>>>>>>    String  sFieldNameTo
76664>>>>>>>>>>>>>    Boolean bShouldChange
76664>>>>>>>>>>>>>    Boolean bCancel
76664>>>>>>>>>>>>>    Boolean bError
76664>>>>>>>>>>>>>End_Struct
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>Struct tAPIRelationCompare
76664>>>>>>>>>>>>>    // Common:
76664>>>>>>>>>>>>>    Handle  hTableFrom
76664>>>>>>>>>>>>>    Integer iColumnFrom
76664>>>>>>>>>>>>>    Handle  hTableTo
76664>>>>>>>>>>>>>    Integer iColumnTo
76664>>>>>>>>>>>>>    // FROM database:
76664>>>>>>>>>>>>>    Boolean bExistsFrom
76664>>>>>>>>>>>>>    String  sLogicalNameFrom_From
76664>>>>>>>>>>>>>    String  sLogicalNameTo_From
76664>>>>>>>>>>>>>    String  sFieldNameFrom_From
76664>>>>>>>>>>>>>    String  sFieldNameTo_From
76664>>>>>>>>>>>>>    Boolean bShouldChange_From
76664>>>>>>>>>>>>>    Boolean bCancel_From
76664>>>>>>>>>>>>>    Boolean bError_From
76664>>>>>>>>>>>>>    // TO database:
76664>>>>>>>>>>>>>    Boolean bExistsTo
76664>>>>>>>>>>>>>    String  sLogicalNameFrom_To
76664>>>>>>>>>>>>>    String  sLogicalNameTo_To
76664>>>>>>>>>>>>>    String  sFieldNameFrom_To
76664>>>>>>>>>>>>>    String  sFieldNameTo_To
76664>>>>>>>>>>>>>    Boolean bShouldChange_To
76664>>>>>>>>>>>>>    Boolean bCancel_To
76664>>>>>>>>>>>>>    Boolean bError_To
76664>>>>>>>>>>>>>End_Struct
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>Struct tAPIIndexSegment
76664>>>>>>>>>>>>>    Integer iFieldNumber
76664>>>>>>>>>>>>>    String  sFieldName
76664>>>>>>>>>>>>>    Boolean bUppercase
76664>>>>>>>>>>>>>    Boolean bAscending
76664>>>>>>>>>>>>>    Boolean bShouldChange
76664>>>>>>>>>>>>>    Boolean bCancel
76664>>>>>>>>>>>>>    Boolean bError
76664>>>>>>>>>>>>>End_Struct
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>Struct tAPIIndex
76664>>>>>>>>>>>>>    Integer iIndexNumber
76664>>>>>>>>>>>>>    Integer iPrimaryIndex
76664>>>>>>>>>>>>>    String  sSQLIndexName
76664>>>>>>>>>>>>>    Integer iSQLIndexType
76664>>>>>>>>>>>>>    Boolean bIsSQLClustered
76664>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKey
76664>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
76664>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
76664>>>>>>>>>>>>>    Boolean bShouldChange
76664>>>>>>>>>>>>>    Boolean bCancel
76664>>>>>>>>>>>>>    Boolean bError
76664>>>>>>>>>>>>>End_Struct
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>Struct tAPIIndexCompare
76664>>>>>>>>>>>>>    // Common:
76664>>>>>>>>>>>>>    Integer iIndexNumber
76664>>>>>>>>>>>>>    // FROM database:
76664>>>>>>>>>>>>>    Boolean bExistsFrom
76664>>>>>>>>>>>>>    Integer iPrimaryIndexFrom
76664>>>>>>>>>>>>>    String  sSQLIndexNameFrom
76664>>>>>>>>>>>>>    Integer iSQLIndexTypeFrom
76664>>>>>>>>>>>>>    Boolean bIsSQLClusteredFrom
76664>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
76664>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
76664>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
76664>>>>>>>>>>>>>    Boolean bShouldChangeFrom
76664>>>>>>>>>>>>>    Boolean bCancelFrom
76664>>>>>>>>>>>>>    Boolean bErrorFrom
76664>>>>>>>>>>>>>    // TO database:
76664>>>>>>>>>>>>>    Boolean bExistsTo
76664>>>>>>>>>>>>>    Integer iPrimaryIndexTo
76664>>>>>>>>>>>>>    String  sSQLIndexNameTo
76664>>>>>>>>>>>>>    Integer iSQLIndexTypeTo
76664>>>>>>>>>>>>>    Boolean bIsSQLClusteredTo
76664>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
76664>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
76664>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
76664>>>>>>>>>>>>>    Boolean bShouldChangeTo
76664>>>>>>>>>>>>>    Boolean bCancelTo
76664>>>>>>>>>>>>>    Boolean bErrorTo
76664>>>>>>>>>>>>>End_Struct
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>Struct tAPITableNameInfo
76664>>>>>>>>>>>>>    Integer iTableNumber
76664>>>>>>>>>>>>>    String  sRootName
76664>>>>>>>>>>>>>    String  sLogicalName
76664>>>>>>>>>>>>>    String  sDisplayName
76664>>>>>>>>>>>>>    String  sDriverID
76664>>>>>>>>>>>>>    Boolean bIsAlias
76664>>>>>>>>>>>>>    Boolean bIsSQL
76664>>>>>>>>>>>>>    Boolean bIsSystemFile
76664>>>>>>>>>>>>>    Boolean bShouldChange
76664>>>>>>>>>>>>>    Boolean bCancel
76664>>>>>>>>>>>>>    Boolean bError
76664>>>>>>>>>>>>>End_Struct
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>Struct tAPITableNameInfoCompare
76664>>>>>>>>>>>>>    Integer iTableNumber
76664>>>>>>>>>>>>>    // FROM
76664>>>>>>>>>>>>>    Boolean bExistsFrom
76664>>>>>>>>>>>>>    String  sRootNameFrom
76664>>>>>>>>>>>>>    String  sLogicalNameFrom
76664>>>>>>>>>>>>>    String  sDisplayNameFrom
76664>>>>>>>>>>>>>    String  sDriverIDFrom
76664>>>>>>>>>>>>>    Boolean bIsAliasFrom
76664>>>>>>>>>>>>>    Boolean bIsSQLFrom
76664>>>>>>>>>>>>>    Boolean bIsSystemFileFrom
76664>>>>>>>>>>>>>    // TO database:
76664>>>>>>>>>>>>>    Boolean bExistsTo
76664>>>>>>>>>>>>>    String  sRootNameTo
76664>>>>>>>>>>>>>    String  sLogicalNameTo
76664>>>>>>>>>>>>>    String  sDisplayNameTo
76664>>>>>>>>>>>>>    String  sDriverIDTo
76664>>>>>>>>>>>>>    Boolean bIsAliasTo
76664>>>>>>>>>>>>>    Boolean bIsSQLTo
76664>>>>>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
76664>>>>>>>>>>>>>    Boolean bShouldChange
76664>>>>>>>>>>>>>    Boolean bCancel
76664>>>>>>>>>>>>>    Boolean bError
76664>>>>>>>>>>>>>End_Struct
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>Struct tAPITable
76664>>>>>>>>>>>>>    Handle hTable
76664>>>>>>>>>>>>>    Boolean bFromTable
76664>>>>>>>>>>>>>    Boolean bToTable
76664>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
76664>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
76664>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
76664>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
76664>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
76664>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
76664>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
76664>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
76664>>>>>>>>>>>>>    Boolean bShouldChange
76664>>>>>>>>>>>>>    Boolean bCancel
76664>>>>>>>>>>>>>    Boolean bError
76664>>>>>>>>>>>>>End_Struct
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>Struct tAPITableCompare
76664>>>>>>>>>>>>>    Handle hTable
76664>>>>>>>>>>>>>    // FROM database:
76664>>>>>>>>>>>>>    Boolean bExistsFrom
76664>>>>>>>>>>>>>    // TO database:
76664>>>>>>>>>>>>>    Boolean bExistsTo
76664>>>>>>>>>>>>>    // Both:
76664>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
76664>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
76664>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
76664>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
76664>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
76664>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
76664>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
76664>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
76664>>>>>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
76664>>>>>>>>>>>>>    Boolean bCancel         // User cancel
76664>>>>>>>>>>>>>    Boolean bError          // Error occured while collecting data
76664>>>>>>>>>>>>>End_Struct
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>Struct tAPITableBooleans
76664>>>>>>>>>>>>>    Boolean bApiTableUpdateAuto
76664>>>>>>>>>>>>>    Boolean bCompareDate_DateTime
76664>>>>>>>>>>>>>    Boolean bCompareIndexAscending
76664>>>>>>>>>>>>>    Boolean bCompareIndexUppercase
76664>>>>>>>>>>>>>    Boolean bCompareFilelistUppercase
76664>>>>>>>>>>>>>End_Struct
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>Define C_tAPIColumn_None for 0
76664>>>>>>>>>>>>>Define C_tAPIColumn_Identity for 1
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>// SQL Key-Word Constants:  CI_SQLSelect CI_SQLName CI_SQLFrom  CI_SQLSys
76664>>>>>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
76664>>>>>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
76664>>>>>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
76664>>>>>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
76664>>>>>>>>>>>>>Enum_List
76664>>>>>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"
76664>>>>>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
76664>>>>>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
76664>>>>>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
76664>>>>>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
76664>>>>>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
76664>>>>>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
76664>>>>>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
76664>>>>>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
76664>>>>>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
76664>>>>>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
76664>>>>>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
76664>>>>>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
76664>>>>>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
76664>>>>>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
76664>>>>>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
76664>>>>>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
76664>>>>>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
76664>>>>>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
76664>>>>>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
76664>>>>>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
76664>>>>>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
76664>>>>>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
76664>>>>>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
76664>>>>>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
76664>>>>>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
76664>>>>>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
76664>>>>>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
76664>>>>>>>>>>>>>    Define CI_SQLTo                    //for "TO"
76664>>>>>>>>>>>>>    Define CI_SQLGO                    //for "GO"
76664>>>>>>>>>>>>>    Define CI_SQLUse                   //for "USE"
76664>>>>>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>    Define CI_SQLName                  //for "NAME"
76664>>>>>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
76664>>>>>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
76664>>>>>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
76664>>>>>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
76664>>>>>>>>>>>>>    Define CI_SQLID                    //for "ID"
76664>>>>>>>>>>>>>    Define CI_SQLAND                   //for "AND"
76664>>>>>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
76664>>>>>>>>>>>>>    Define CI_SQLSet                   //for "SET"
76664>>>>>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
76664>>>>>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
76664>>>>>>>>>>>>>    Define CI_SQL_SAFE_UPDATES         //for "SQL_SAFE_UPDATES"  
76664>>>>>>>>>>>>>    Define CI_SQLDescription          //for "SELECT name, description from sys.fn_helpcollations()" (Enumerates all collates)
76664>>>>>>>>>>>>>End_Enum_List
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>>>
76664>>>>>>>>>>>
76664>>>>>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
76665>>>>>>>>>>>
76665>>>>>>>>>>>    Procedure CreateDbUpdateLibraryProperties
76667>>>>>>>>>>>        Handle hoSQLManagerMT
76667>>>>>>>>>>>
76667>>>>>>>>>>>        Property String private.psUseDatabase ""
76668>>>>>>>>>>>
76668>>>>>>>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
76668>>>>>>>>>>>        Property Handle  private.phCurrentTable 0
76669>>>>>>>>>>>        Property Integer private.piCurrentField 0
76670>>>>>>>>>>>
76670>>>>>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
76671>>>>>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
76672>>>>>>>>>>>
76672>>>>>>>>>>>        Property Handle phoSQLManagerMT
76673>>>>>>>>>>>
76673>>>>>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
76674>>>>>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
76675>>>>>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
76676>>>>>>>>>>>        Property Handle phoSQLConnectionHandler 0
76677>>>>>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
76678>>>>>>>>>>>
76678>>>>>>>>>>>        Property Boolean pbHandleQueryErrors True
76679>>>>>>>>>>>
76679>>>>>>>>>>>        Property tSqlColumnNew[] paQueryColumns
76680>>>>>>>>>>>        Property String[] paSQLFetchResults
76681>>>>>>>>>>>
76681>>>>>>>>>>>        // Error handling
76681>>>>>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
76682>>>>>>>>>>>        Property Boolean pbSqlError False
76683>>>>>>>>>>>        Property tSqlErrorArray paSqlErrorArray
76684>>>>>>>>>>>        Property Boolean pbProcessingError False
76685>>>>>>>>>>>
76685>>>>>>>>>>>        // Statistics on query
76685>>>>>>>>>>>        Property TimeSpan ptsTotalQueryTime
76686>>>>>>>>>>>        Property TimeSpan ptsQueryExec
76687>>>>>>>>>>>        Property TimeSpan ptsFetchResults
76688>>>>>>>>>>>        Property Integer piColumns 0
76689>>>>>>>>>>>        Property Integer piRows 0
76690>>>>>>>>>>>        Property Integer piRowType 0
76691>>>>>>>>>>>        Property String[] paQueryMessages
76692>>>>>>>>>>>        Property String psSQLStatementString
76693>>>>>>>>>>>
76693>>>>>>>>>>>        Property Integer[] paTableConvertExceptions
76694>>>>>>>>>>>
76694>>>>>>>>>>>        Property Integer[] paTableDateCorrectionExceptions
76695>>>>>>>>>>>
76695>>>>>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
76695>>>>>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
76695>>>>>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
76695>>>>>>>>>>>        Property Integer piChunkMax 500
76696>>>>>>>>>>>
76696>>>>>>>>>>>        // Fill the paSQLKeywordArray array with values;
76696>>>>>>>>>>>        Send SetupSQLKeywordArray
76697>>>>>>>>>>>    End_Procedure
76698>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
76698>>>>>>>>>>>>
76698>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
76700>>>>>>>>>>>>    Integer iStart iEnd
76700>>>>>>>>>>>>    String sRetval
76700>>>>>>>>>>>>
76700>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
76701>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
76702>>>>>>>>>>>>    If (iStart = 0) Begin
76704>>>>>>>>>>>>        Function_Return ""
76705>>>>>>>>>>>>    End
76705>>>>>>>>>>>>>
76705>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
76706>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
76707>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
76709>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
76710>>>>>>>>>>>>    End
76710>>>>>>>>>>>>>
76710>>>>>>>>>>>>    Else Begin
76711>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
76712>>>>>>>>>>>>    End
76712>>>>>>>>>>>>>
76712>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
76714>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
76715>>>>>>>>>>>>        Decrement iEnd
76716>>>>>>>>>>>>    End
76716>>>>>>>>>>>>>
76716>>>>>>>>>>>>    If (iEnd <> 0) Begin
76718>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
76719>>>>>>>>>>>>    End
76719>>>>>>>>>>>>>
76719>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
76720>>>>>>>>>>>>
76720>>>>>>>>>>>>    Function_Return (Trim(sRetval))
76721>>>>>>>>>>>>End_Function
76722>>>>>>>>>>>>
76722>>>>>>>>>>>>
76722>>>>>>>>>>>
76722>>>>>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
76722>>>>>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
76724>>>>>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
76726>>>>>>>>>>>            Function_Return (EQ)
76727>>>>>>>>>>>        End
76727>>>>>>>>>>>>
76727>>>>>>>>>>>        Function_Return (GT)
76728>>>>>>>>>>>    End_Function
76729>>>>>>>>>>>
76729>>>>>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
76729>>>>>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
76731>>>>>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
76734>>>>>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
76737>>>>>>>>>>>
76737>>>>>>>>>>>        Function_Return (EQ)
76738>>>>>>>>>>>    End_Function
76739>>>>>>>>>>>
76739>>>>>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
76741>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
76741>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
76742>>>>>>>>>>>        Integer iSize
76742>>>>>>>>>>>
76742>>>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
76743>>>>>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
76744>>>>>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
76745>>>>>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
76746>>>>>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
76747>>>>>>>>>>>
76747>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
76748>>>>>>>>>>>    End_Procedure
76749>>>>>>>>>>>
76749>>>>>>>>>>>    // Creates a struct array with all SQL keywords
76749>>>>>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
76749>>>>>>>>>>>    // have slightly different wording.
76749>>>>>>>>>>>    // If a new EN_dbTypexxx type is added; additions
76749>>>>>>>>>>>    // needs to be done for every keyword group below.
76749>>>>>>>>>>>    Procedure SetupSQLKeywordArray
76751>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
76751>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
76753>>>>>>>>>>>
76753>>>>>>>>>>>        // This should only be called once; but in case it is
76753>>>>>>>>>>>        // we delete the array first.
76753>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
76754>>>>>>>>>>>
76754>>>>>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
76754>>>>>>>>>>>        //
76754>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
76755>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
76756>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
76757>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
76758>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"
76759>>>>>>>>>>>
76759>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
76760>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
76761>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
76762>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
76763>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"
76764>>>>>>>>>>>
76764>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
76765>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
76766>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
76767>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
76768>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"
76769>>>>>>>>>>>
76769>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
76770>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
76771>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
76772>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
76773>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"
76774>>>>>>>>>>>
76774>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
76775>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
76776>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
76777>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
76778>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"
76779>>>>>>>>>>>
76779>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
76780>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
76781>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
76782>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
76783>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
76784>>>>>>>>>>>
76784>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
76785>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
76786>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
76787>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
76788>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
76789>>>>>>>>>>>
76789>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
76790>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
76791>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
76792>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
76793>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
76794>>>>>>>>>>>
76794>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
76795>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
76796>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
76797>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
76798>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
76799>>>>>>>>>>>
76799>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_DbTypeMSSQL   ""
76800>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeMySQL   "SQL_SAFE_UPDATES"
76801>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeOracle  ""
76802>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeDB2     ""
76803>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypePostgre ""
76804>>>>>>>>>>>
76804>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
76805>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
76806>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
76807>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
76808>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
76809>>>>>>>>>>>
76809>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
76810>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
76811>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
76812>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
76813>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
76814>>>>>>>>>>>
76814>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
76815>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
76816>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
76817>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
76818>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
76819>>>>>>>>>>>
76819>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
76820>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
76821>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
76822>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
76823>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
76824>>>>>>>>>>>
76824>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
76825>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
76826>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
76827>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
76828>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
76829>>>>>>>>>>>
76829>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
76830>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
76831>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
76832>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
76833>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
76834>>>>>>>>>>>
76834>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
76835>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
76836>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
76837>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
76838>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
76839>>>>>>>>>>>
76839>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
76840>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
76841>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
76842>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
76843>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
76844>>>>>>>>>>>
76844>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
76845>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
76846>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
76847>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
76848>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
76849>>>>>>>>>>>
76849>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
76850>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
76851>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
76852>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
76853>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
76854>>>>>>>>>>>
76854>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
76855>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
76856>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
76857>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
76858>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
76859>>>>>>>>>>>
76859>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
76860>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
76861>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
76862>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
76863>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
76864>>>>>>>>>>>
76864>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
76865>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
76866>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
76867>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
76868>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
76869>>>>>>>>>>>
76869>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
76870>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
76871>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
76872>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
76873>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
76874>>>>>>>>>>>
76874>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
76875>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
76876>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
76877>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
76878>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
76879>>>>>>>>>>>
76879>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
76880>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
76881>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
76882>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
76883>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
76884>>>>>>>>>>>
76884>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
76885>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
76886>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
76887>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
76888>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
76889>>>>>>>>>>>
76889>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
76890>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
76891>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
76892>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
76893>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
76894>>>>>>>>>>>
76894>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
76895>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
76896>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
76897>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
76898>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
76899>>>>>>>>>>>
76899>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
76900>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
76901>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
76902>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
76903>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
76904>>>>>>>>>>>
76904>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
76905>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
76906>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
76907>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
76908>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
76909>>>>>>>>>>>
76909>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
76910>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
76911>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
76912>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
76913>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
76914>>>>>>>>>>>
76914>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
76915>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
76916>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
76917>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
76918>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
76919>>>>>>>>>>>
76919>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
76920>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
76921>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
76922>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
76923>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
76924>>>>>>>>>>>
76924>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
76925>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
76926>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
76927>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
76928>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
76929>>>>>>>>>>>
76929>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
76930>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
76931>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
76932>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
76933>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
76934>>>>>>>>>>>
76934>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
76935>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
76936>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
76937>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
76938>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
76939>>>>>>>>>>>
76939>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
76940>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
76941>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
76942>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
76943>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
76944>>>>>>>>>>>
76944>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
76945>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
76946>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
76947>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
76948>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
76949>>>>>>>>>>>
76949>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
76950>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
76951>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
76952>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
76953>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
76954>>>>>>>>>>>
76954>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
76955>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
76956>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
76957>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
76958>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
76959>>>>>>>>>>>
76959>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
76960>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
76961>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
76962>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
76963>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
76964>>>>>>>>>>>
76964>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
76965>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
76966>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
76967>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
76968>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
76969>>>>>>>>>>>
76969>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMSSQL   "DESCRIPTION"
76970>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMySQL   "DESCRIPTION"
76971>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeOracle  "DESCRIPTION"
76972>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeDB2     "DESCRIPTION"
76973>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypePostgre "DESCRIPTION"
76974>>>>>>>>>>>
76974>>>>>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
76974>>>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
76975>>>>>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
76976>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
76977>>>>>>>>>>>
76977>>>>>>>>>>>    End_Procedure
76978>>>>>>>>>>>
76978>>>>>>>>>>>End_Class
76979>>>>>>>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
76979>>>>>>>>>>>//****************************************************************************
76979>>>>>>>>>>>// $Module type: Class
76979>>>>>>>>>>>// $Module name: cSQLConnectionHandler.pkg
76979>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
76979>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76979>>>>>>>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
76979>>>>>>>>>>>//
76979>>>>>>>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
76979>>>>>>>>>>>//
76979>>>>>>>>>>>// $Rev History:
76979>>>>>>>>>>>//    2015-08-11  Module header created
76979>>>>>>>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
76979>>>>>>>>>>>//                Added a new structure for passing connection data back & forth.
76979>>>>>>>>>>>//                Added better error handling.
76979>>>>>>>>>>>//                Added a decompose message for the connection string.
76979>>>>>>>>>>>//    2017-01-09  Added support for Mertech drivers
76979>>>>>>>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
76979>>>>>>>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
76979>>>>>>>>>>>//    2017-02-12  Reworked the whole connection property interface.
76979>>>>>>>>>>>//                Now there is one struct property that is the at cencter of a connection.
76979>>>>>>>>>>>//    2023-11-06 *** REMOVED ALL SUPPORT FOR MERTECH DRIVERS ***
76979>>>>>>>>>>>//****************************************************************************
76979>>>>>>>>>>>Use cli.pkg
76979>>>>>>>>>>>Use MSSqldrv.pkg
76979>>>>>>>>>>>Use db2_drv.pkg
76979>>>>>>>>>>>Use odbc_drv.pkg
76979>>>>>>>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
76979>>>>>>>>>>>>>//****************************************************************************
76979>>>>>>>>>>>>>// $Module type: Class
76979>>>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
76979>>>>>>>>>>>>>//
76979>>>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
76979>>>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
76979>>>>>>>>>>>>>// E-mail      : support@rdctools.com
76979>>>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76979>>>>>>>>>>>>>//
76979>>>>>>>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
76979>>>>>>>>>>>>>//
76979>>>>>>>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
76979>>>>>>>>>>>>>//               properties of that object.
76979>>>>>>>>>>>>>//
76979>>>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
76979>>>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
76979>>>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
76979>>>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
76979>>>>>>>>>>>>>// in the help folder for more details.
76979>>>>>>>>>>>>>//
76979>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
76979>>>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
76979>>>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
76979>>>>>>>>>>>>>>>
76979>>>>>>>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
76980>>>>>>>>>>>>>>>    Procedure Construct_Object
76982>>>>>>>>>>>>>>>        Forward Send Construct_Object
76984>>>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
76985>>>>>>>>>>>>>>>    End_Procedure
76986>>>>>>>>>>>>>>>
76986>>>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
76988>>>>>>>>>>>>>>>        String sRetval
76988>>>>>>>>>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
76990>>>>>>>>>>>>>>>            Move CS_SQLIniFileDSNKeyword to sRetval    
76991>>>>>>>>>>>>>>>        End                                        
76991>>>>>>>>>>>>>>>>
76991>>>>>>>>>>>>>>>        Else Begin
76992>>>>>>>>>>>>>>>            Move CS_SQLIniDSNKeyword to sRetval
76993>>>>>>>>>>>>>>>        End
76993>>>>>>>>>>>>>>>>
76993>>>>>>>>>>>>>>>            
76993>>>>>>>>>>>>>>>        Function_Return sRetval
76994>>>>>>>>>>>>>>>    End_Function
76995>>>>>>>>>>>>>>>
76995>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
76997>>>>>>>>>>>>>>>        String sConnect sServerKeyWord sDriverID
76997>>>>>>>>>>>>>>>        Integer iClientVersion
76997>>>>>>>>>>>>>>>        
76997>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
76998>>>>>>>>>>>>>>>        Get ServerKeyword sServer to sServerKeyWord
76999>>>>>>>>>>>>>>>        Move (sConnect + sServerKeyWord + "=" + sServer) to sConnect
77000>>>>>>>>>>>>>>>        If (sServerKeyWord = CS_SQLIniDSNKeyword or sServerKeyWord = CS_SQLIniFileDSNKeyword) Begin
77002>>>>>>>>>>>>>>>            Move "" to sDatabase
77003>>>>>>>>>>>>>>>        End
77003>>>>>>>>>>>>>>>>
77003>>>>>>>>>>>>>>>        
77003>>>>>>>>>>>>>>>        If (sDatabase <> "") Begin
77005>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77006>>>>>>>>>>>>>>>        End
77006>>>>>>>>>>>>>>>>
77006>>>>>>>>>>>>>>>        If (bTrusted = True) Begin
77008>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
77009>>>>>>>>>>>>>>>        End
77009>>>>>>>>>>>>>>>>
77009>>>>>>>>>>>>>>>        Else Begin
77010>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniUIDKeyword + "=" + sUserID + ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
77011>>>>>>>>>>>>>>>        End
77011>>>>>>>>>>>>>>>>
77011>>>>>>>>>>>>>>>        
77011>>>>>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
77013>>>>>>>>>>>>>>>            Get SQLClientVersionInteger MSSQLDRV_ID to iClientVersion
77014>>>>>>>>>>>>>>>            If (iClientVersion >= 18) Begin
77016>>>>>>>>>>>>>>>                Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
77017>>>>>>>>>>>>>>>                Move (Replaces(" ", sConnect, "")) to sConnect
77018>>>>>>>>>>>>>>>            End
77018>>>>>>>>>>>>>>>>
77018>>>>>>>>>>>>>>>        End
77018>>>>>>>>>>>>>>>>
77018>>>>>>>>>>>>>>>        
77018>>>>>>>>>>>>>>>        Function_Return sConnect
77019>>>>>>>>>>>>>>>    End_Function
77020>>>>>>>>>>>>>>>
77020>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77022>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77022>>>>>>>>>>>>>>>        String sDriverID
77022>>>>>>>>>>>>>>>
77022>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77023>>>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
77025>>>>>>>>>>>>>>>            Function_Return True
77026>>>>>>>>>>>>>>>        End
77026>>>>>>>>>>>>>>>>
77026>>>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
77027>>>>>>>>>>>>>>>        If (bTrusted = False and sDatabase <> "") Begin
77029>>>>>>>>>>>>>>>            Move (SFormat("SERVER=%1;DATABASE=%2", sServer, sDatabase)) to sServer
77030>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
77032>>>>>>>>>>>>>>>        End
77032>>>>>>>>>>>>>>>>
77032>>>>>>>>>>>>>>>        Else Begin
77033>>>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
77035>>>>>>>>>>>>>>>        End
77035>>>>>>>>>>>>>>>>
77035>>>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
77036>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77037>>>>>>>>>>>>>>>    End_Function
77038>>>>>>>>>>>>>>>
77038>>>>>>>>>>>>>>>    Function SQLClientVersionInteger String sDriverID Returns Integer
77040>>>>>>>>>>>>>>>        Integer iNumberOfDrivers iCount iDriver iClientVersion
77040>>>>>>>>>>>>>>>        String sDriver
77040>>>>>>>>>>>>>>>        
77040>>>>>>>>>>>>>>>        Move 0 to iDriver
77041>>>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77044>>>>>>>>>>>>>>>        If (iNumberOfDrivers = 1) Begin
77046>>>>>>>>>>>>>>>            Load_Driver sDriverID
77047>>>>>>>>>>>>>>>            Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77050>>>>>>>>>>>>>>>        End
77050>>>>>>>>>>>>>>>>
77050>>>>>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
77056>>>>>>>>>>>>>>>>
77056>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sDriver
77059>>>>>>>>>>>>>>>            If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
77061>>>>>>>>>>>>>>>                Move iCount to iDriver
77062>>>>>>>>>>>>>>>                Move iNumberOfDrivers to iCount // We're done.
77063>>>>>>>>>>>>>>>            End
77063>>>>>>>>>>>>>>>>
77063>>>>>>>>>>>>>>>        Loop
77064>>>>>>>>>>>>>>>>
77064>>>>>>>>>>>>>>>    
77064>>>>>>>>>>>>>>>        // This info is (at current) only available for the MS SQL driver:
77064>>>>>>>>>>>>>>>        If (iDriver <> 0 and sDriverID = MSSQLDRV_ID) Begin
77066>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
77069>>>>>>>>>>>>>>>        End
77069>>>>>>>>>>>>>>>>
77069>>>>>>>>>>>>>>>        Function_Return iClientVersion
77070>>>>>>>>>>>>>>>    End_Function
77071>>>>>>>>>>>>>>>    
77071>>>>>>>>>>>>>>>End_Class
77072>>>>>>>>>>>>>>>
77072>>>>>>>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
77073>>>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
77075>>>>>>>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
77076>>>>>>>>>>>>>>>    End_Function
77077>>>>>>>>>>>>>>>
77077>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77079>>>>>>>>>>>>>>>        Integer iClientVersion
77079>>>>>>>>>>>>>>>        String sConnect
77079>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77079>>>>>>>>>>>>>>>        
77079>>>>>>>>>>>>>>>        Move (sConnect * "SERVER=" + sServer) to sConnect
77080>>>>>>>>>>>>>>>        If (sDatabase <> "") Begin
77082>>>>>>>>>>>>>>>            Move (sConnect * ";DATABASE=" + sDatabase) to sConnect
77083>>>>>>>>>>>>>>>        End
77083>>>>>>>>>>>>>>>>
77083>>>>>>>>>>>>>>>        If (bTrusted = True) Begin
77085>>>>>>>>>>>>>>>            Move (sConnect * ";TRUSTED_CONNECTION=Yes") to sConnect
77086>>>>>>>>>>>>>>>        End
77086>>>>>>>>>>>>>>>>
77086>>>>>>>>>>>>>>>        Else Begin
77087>>>>>>>>>>>>>>>            Move (sConnect * ";UID=" + sUserID * ";PWD=" + sPassword) to sConnect
77088>>>>>>>>>>>>>>>        End
77088>>>>>>>>>>>>>>>>
77088>>>>>>>>>>>>>>>
77088>>>>>>>>>>>>>>>        Get SQLClientVersionInteger MSSQLDRV_ID to iClientVersion
77089>>>>>>>>>>>>>>>        If (iClientVersion >= 18) Begin
77091>>>>>>>>>>>>>>>            Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
77092>>>>>>>>>>>>>>>            Move (Replaces(" ", sConnect, "")) to sConnect
77093>>>>>>>>>>>>>>>        End
77093>>>>>>>>>>>>>>>>
77093>>>>>>>>>>>>>>>        
77093>>>>>>>>>>>>>>>        Login sConnect "" "" MSSQLDRV_ID
77095>>>>>>>>>>>>>>>
77095>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77096>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77097>>>>>>>>>>>>>>>    End_Function
77098>>>>>>>>>>>>>>>
77098>>>>>>>>>>>>>>>    Function SQLClientVersionInteger String sDriverID Returns Integer
77100>>>>>>>>>>>>>>>        Integer iNumberOfDrivers iCount iDriver iClientVersion
77100>>>>>>>>>>>>>>>        String sDriver
77100>>>>>>>>>>>>>>>        
77100>>>>>>>>>>>>>>>        Move 0 to iDriver
77101>>>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77104>>>>>>>>>>>>>>>        If (iNumberOfDrivers = 1) Begin
77106>>>>>>>>>>>>>>>            Load_Driver sDriverID
77107>>>>>>>>>>>>>>>            Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77110>>>>>>>>>>>>>>>        End
77110>>>>>>>>>>>>>>>>
77110>>>>>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
77116>>>>>>>>>>>>>>>>
77116>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sDriver
77119>>>>>>>>>>>>>>>            If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
77121>>>>>>>>>>>>>>>                Move iCount to iDriver
77122>>>>>>>>>>>>>>>                Move iNumberOfDrivers to iCount // We're done.
77123>>>>>>>>>>>>>>>            End
77123>>>>>>>>>>>>>>>>
77123>>>>>>>>>>>>>>>        Loop
77124>>>>>>>>>>>>>>>>
77124>>>>>>>>>>>>>>>    
77124>>>>>>>>>>>>>>>        // This info is (at current) only available for the MS SQL driver:
77124>>>>>>>>>>>>>>>        If (iDriver <> 0 and sDriverID = MSSQLDRV_ID) Begin
77126>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
77129>>>>>>>>>>>>>>>        End
77129>>>>>>>>>>>>>>>>
77129>>>>>>>>>>>>>>>        Function_Return iClientVersion
77130>>>>>>>>>>>>>>>    End_Function
77131>>>>>>>>>>>>>>>    
77131>>>>>>>>>>>>>>>End_Class
77132>>>>>>>>>>>>>>>
77132>>>>>>>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
77133>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77135>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77135>>>>>>>>>>>>>>>        String sDriverID
77135>>>>>>>>>>>>>>>
77135>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77136>>>>>>>>>>>>>>>        Move (Trim(sDriverID)) to sDriverID
77137>>>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
77139>>>>>>>>>>>>>>>            Function_Return True
77140>>>>>>>>>>>>>>>        End
77140>>>>>>>>>>>>>>>>
77140>>>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
77141>>>>>>>>>>>>>>>        If (bTrusted = False) Begin
77143>>>>>>>>>>>>>>>            If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
77145>>>>>>>>>>>>>>>                Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sServer
77146>>>>>>>>>>>>>>>            End
77146>>>>>>>>>>>>>>>>
77146>>>>>>>>>>>>>>>            Else If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77149>>>>>>>>>>>>>>>                Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77150>>>>>>>>>>>>>>>            End
77150>>>>>>>>>>>>>>>>
77150>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
77152>>>>>>>>>>>>>>>        End
77152>>>>>>>>>>>>>>>>
77152>>>>>>>>>>>>>>>        Else Begin
77153>>>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
77155>>>>>>>>>>>>>>>        End
77155>>>>>>>>>>>>>>>>
77155>>>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
77156>>>>>>>>>>>>>>>
77156>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77157>>>>>>>>>>>>>>>    End_Function
77158>>>>>>>>>>>>>>>End_Class
77159>>>>>>>>>>>>>>>
77159>>>>>>>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
77160>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77162>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77162>>>>>>>>>>>>>>>        String sDriverID
77162>>>>>>>>>>>>>>>
77162>>>>>>>>>>>>>>>        Move False to Err
77163>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77164>>>>>>>>>>>>>>>        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77166>>>>>>>>>>>>>>>            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77167>>>>>>>>>>>>>>>        End
77167>>>>>>>>>>>>>>>>
77167>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
77169>>>>>>>>>>>>>>>
77169>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77170>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77171>>>>>>>>>>>>>>>    End_Function
77172>>>>>>>>>>>>>>>End_Class
77173>>>>>>>>>>>>>>>
77173>>>>>>>>>>>>>>>Class cDbUpdatePSQLDriver is a cDbUpdateGenericDatabaseDriver
77174>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77176>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77176>>>>>>>>>>>>>>>        String sDriverID
77176>>>>>>>>>>>>>>>
77176>>>>>>>>>>>>>>>        Move False to Err
77177>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77178>>>>>>>>>>>>>>>//        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77178>>>>>>>>>>>>>>>//            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77178>>>>>>>>>>>>>>>//        End
77178>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
77180>>>>>>>>>>>>>>>
77180>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77181>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77182>>>>>>>>>>>>>>>    End_Function
77183>>>>>>>>>>>>>>>End_Class
77184>>>>>>>>>>>>>>>
77184>>>>>>>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
77185>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77187>>>>>>>>>>>>>>>        Function_Return ""
77188>>>>>>>>>>>>>>>    End_Function
77189>>>>>>>>>>>>>>>End_Class
77190>>>>>>>>>>>>>>>
77190>>>>>>>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
77191>>>>>>>>>>>>>>>    Procedure Construct_Object
77193>>>>>>>>>>>>>>>        Forward Send Construct_Object
77195>>>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
77196>>>>>>>>>>>>>>>        Property Handle phoDriverSpecificObject 
77197>>>>>>>>>>>>>>>    End_Procedure
77198>>>>>>>>>>>>>>>
77198>>>>>>>>>>>>>>>    Function CreateDriver Returns Handle
77200>>>>>>>>>>>>>>>        String sDriverID sObjectName
77200>>>>>>>>>>>>>>>        Handle hoDriver hcDriverClass
77200>>>>>>>>>>>>>>>
77200>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77201>>>>>>>>>>>>>>>        Case Begin
77201>>>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
77203>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
77204>>>>>>>>>>>>>>>                Move "oDbUpdateMSSQLDriver" to sObjectName
77205>>>>>>>>>>>>>>>                Case Break
77206>>>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
77209>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
77210>>>>>>>>>>>>>>>                Move "oDbUpdateODBCDriver" to sObjectName
77211>>>>>>>>>>>>>>>                Case Break
77212>>>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
77215>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
77216>>>>>>>>>>>>>>>                Move "oDbUpdateDB2Driver" to sObjectName
77217>>>>>>>>>>>>>>>                Case Break               
77218>>>>>>>>>>>>>>>            Case Else
77218>>>>>>>>>>>>>>>                // DATAFLEX_ID = Default driver
77218>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
77219>>>>>>>>>>>>>>>                Move "oDbUpdateDataFlexDriver" to sObjectName
77220>>>>>>>>>>>>>>>                Move DATAFLEX_ID to sDriverID
77221>>>>>>>>>>>>>>>        Case End
77221>>>>>>>>>>>>>>>
77221>>>>>>>>>>>>>>>        Get Create hcDriverClass to hoDriver
77222>>>>>>>>>>>>>>>        Set Name of hoDriver to sObjectName
77223>>>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
77224>>>>>>>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
77225>>>>>>>>>>>>>>>
77225>>>>>>>>>>>>>>>        Function_Return hoDriver
77226>>>>>>>>>>>>>>>    End_Function
77227>>>>>>>>>>>>>>>
77227>>>>>>>>>>>>>>>    Procedure DestroyDriver
77229>>>>>>>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
77231>>>>>>>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
77232>>>>>>>>>>>>>>>        End
77232>>>>>>>>>>>>>>>>
77232>>>>>>>>>>>>>>>    End_Procedure
77233>>>>>>>>>>>>>>>
77233>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77235>>>>>>>>>>>>>>>        String sConnect
77235>>>>>>>>>>>>>>>        Handle hoDriver
77235>>>>>>>>>>>>>>>
77235>>>>>>>>>>>>>>>        Get phoDriverSpecificObject to hoDriver
77236>>>>>>>>>>>>>>>        If (hoDriver = 0) Begin
77238>>>>>>>>>>>>>>>            Get CreateDriver to hoDriver
77239>>>>>>>>>>>>>>>        End
77239>>>>>>>>>>>>>>>>
77239>>>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
77240>>>>>>>>>>>>>>>        Send DestroyDriver
77241>>>>>>>>>>>>>>>        Function_Return sConnect
77242>>>>>>>>>>>>>>>    End_Function
77243>>>>>>>>>>>>>>>
77243>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77245>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77245>>>>>>>>>>>>>>>        Handle hoDriver
77245>>>>>>>>>>>>>>>
77245>>>>>>>>>>>>>>>        Get phoDriverSpecificObject to hoDriver
77246>>>>>>>>>>>>>>>        If (hoDriver = 0) Begin
77248>>>>>>>>>>>>>>>            Get CreateDriver to hoDriver
77249>>>>>>>>>>>>>>>        End
77249>>>>>>>>>>>>>>>>
77249>>>>>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
77250>>>>>>>>>>>>>>>        Send DestroyDriver
77251>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77252>>>>>>>>>>>>>>>    End_Function
77253>>>>>>>>>>>>>>>
77253>>>>>>>>>>>>>>>End_Class
77254>>>>>>>>>>>>>
77254>>>>>>>>>>>>>    Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cLoginEncryption.pkg)
77254>>>>>>>>>>>>>>>Use cCryptographerEx.pkg
77254>>>>>>>>>>>>>>>
77254>>>>>>>>>>>>>>>Class cLoginEncryption is a cObject
77255>>>>>>>>>>>>>>>    
77255>>>>>>>>>>>>>>>    Procedure Construct_Object
77257>>>>>>>>>>>>>>>        Forward Send Construct_Object
77259>>>>>>>>>>>>>>>        // this must be set to a multi (40ish) character random key
77259>>>>>>>>>>>>>>>        Property String psEncryptPassword ""
77260>>>>>>>>>>>>>>>        
77260>>>>>>>>>>>>>>>        Object oDataCrypter is a cCryptographerEx
77262>>>>>>>>>>>>>>>            Set piHash to CALG_SHA_256
77263>>>>>>>>>>>>>>>            Set piCipher to CALG_AES_256
77264>>>>>>>>>>>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
77265>>>>>>>>>>>>>>>            Set piProvider to PROV_RSA_AES
77266>>>>>>>>>>>>>>>        End_Object
77267>>>>>>>>>>>>>>>    End_Procedure
77268>>>>>>>>>>>>>>>    
77268>>>>>>>>>>>>>>>    // This can be augmented to return a password encryption key using any
77268>>>>>>>>>>>>>>>    // hidden mechanism desired.
77268>>>>>>>>>>>>>>>    Function GetEncryptionPassword Returns String
77270>>>>>>>>>>>>>>>        String sPassword
77270>>>>>>>>>>>>>>>        Get psEncryptPassword to sPassword
77271>>>>>>>>>>>>>>>        Function_Return sPassword
77272>>>>>>>>>>>>>>>    End_Function
77273>>>>>>>>>>>>>>>    
77273>>>>>>>>>>>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
77273>>>>>>>>>>>>>>>    //
77273>>>>>>>>>>>>>>>    // Params:
77273>>>>>>>>>>>>>>>    //   sPlainText     String to encrypt.
77273>>>>>>>>>>>>>>>    // Returns:
77273>>>>>>>>>>>>>>>    //   Base64 encoded hash.
77273>>>>>>>>>>>>>>>    Function EncryptPassword String sPlainText Returns String
77275>>>>>>>>>>>>>>>        String sEncryptPassword sBase64
77275>>>>>>>>>>>>>>>        UChar[] ucBinary
77276>>>>>>>>>>>>>>>        Pointer pBase64
77276>>>>>>>>>>>>>>>        Integer iVoid
77276>>>>>>>>>>>>>>>        
77276>>>>>>>>>>>>>>>        //  Encrypt Key
77276>>>>>>>>>>>>>>>        Get GetEncryptionPassword to sEncryptPassword
77277>>>>>>>>>>>>>>>        If (sEncryptPassword = "") Begin
77279>>>>>>>>>>>>>>>            Error DFERR_PROGRAM "No encryption password set"
77280>>>>>>>>>>>>>>>>
77280>>>>>>>>>>>>>>>        End
77280>>>>>>>>>>>>>>>>
77280>>>>>>>>>>>>>>>        
77280>>>>>>>>>>>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
77281>>>>>>>>>>>>>>>        
77281>>>>>>>>>>>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
77283>>>>>>>>>>>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
77284>>>>>>>>>>>>>>>>
77284>>>>>>>>>>>>>>>            Function_Return ""
77285>>>>>>>>>>>>>>>        End
77285>>>>>>>>>>>>>>>>
77285>>>>>>>>>>>>>>>        
77285>>>>>>>>>>>>>>>        //  Encode binary hash to Base64
77285>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
77286>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sBase64
77287>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
77288>>>>>>>>>>>>>>>        
77288>>>>>>>>>>>>>>>        Function_Return sBase64
77289>>>>>>>>>>>>>>>    End_Function
77290>>>>>>>>>>>>>>>    
77290>>>>>>>>>>>>>>>    
77290>>>>>>>>>>>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
77290>>>>>>>>>>>>>>>    //
77290>>>>>>>>>>>>>>>    // Params:
77290>>>>>>>>>>>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
77290>>>>>>>>>>>>>>>    // Returns:
77290>>>>>>>>>>>>>>>    //   Readable plain text password
77290>>>>>>>>>>>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
77292>>>>>>>>>>>>>>>        String sEncryptPassword
77292>>>>>>>>>>>>>>>        UChar[] ucBinary ucPlain
77294>>>>>>>>>>>>>>>        Boolean bIsHex
77294>>>>>>>>>>>>>>>        Integer iLen iVoid
77294>>>>>>>>>>>>>>>        Pointer pBinary
77294>>>>>>>>>>>>>>>        
77294>>>>>>>>>>>>>>>        If (sBase64EncryptedPassword <> "") Begin
77296>>>>>>>>>>>>>>>            //  Decode from Base64
77296>>>>>>>>>>>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
77297>>>>>>>>>>>>>>>            
77297>>>>>>>>>>>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
77298>>>>>>>>>>>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
77299>>>>>>>>>>>>>>>                        
77299>>>>>>>>>>>>>>>            Move (Free(pBinary)) to iVoid
77300>>>>>>>>>>>>>>>            
77300>>>>>>>>>>>>>>>            //  Encrypted binary hash to string
77300>>>>>>>>>>>>>>>            Get GetEncryptionPassword to sEncryptPassword
77301>>>>>>>>>>>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
77302>>>>>>>>>>>>>>>        End
77302>>>>>>>>>>>>>>>>
77302>>>>>>>>>>>>>>>        
77302>>>>>>>>>>>>>>>        Function_Return (UCharArrayToString(ucPlain))
77303>>>>>>>>>>>>>>>    End_Function
77304>>>>>>>>>>>>>>>End_Class
77305>>>>>>>>>>>>>
77305>>>>>>>>>>>>>Class cSQLConnectionIniFile is a cIniFile
77306>>>>>>>>>>>>>    Procedure Construct_Object
77308>>>>>>>>>>>>>        Forward Send Construct_Object
77310>>>>>>>>>>>>>
77310>>>>>>>>>>>>>        Property String Private_psIniFilePath
77311>>>>>>>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
77312>>>>>>>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
77313>>>>>>>>>>>>>
77313>>>>>>>>>>>>>        Property Boolean pbDFConnId False
77314>>>>>>>>>>>>>
77314>>>>>>>>>>>>>        // *** You really want to change this value! ***
77314>>>>>>>>>>>>>        // It is used when encrypting/decrypting passwords.
77314>>>>>>>>>>>>>        Property String psHashString "zx!2139(LI0+?ips7433"
77315>>>>>>>>>>>>>
77315>>>>>>>>>>>>>    End_Procedure
77316>>>>>>>>>>>>>
77316>>>>>>>>>>>>>    Procedure End_Construct_Object
77318>>>>>>>>>>>>>        Forward Send End_Construct_Object
77320>>>>>>>>>>>>>    End_Procedure
77321>>>>>>>>>>>>>
77321>>>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
77323>>>>>>>>>>>>>        String sIniFile
77323>>>>>>>>>>>>>        Get vFolderFormat sPath to sPath
77324>>>>>>>>>>>>>        Set private_psIniFilePath to sPath
77325>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77326>>>>>>>>>>>>>        Set psFileName to (sPath + sIniFile)
77327>>>>>>>>>>>>>    End_Procedure
77328>>>>>>>>>>>>>
77328>>>>>>>>>>>>>    Function psIniFilePath Returns String
77330>>>>>>>>>>>>>        Function_Return (private_psIniFilePath(Self))
77331>>>>>>>>>>>>>    End_Function
77332>>>>>>>>>>>>>
77332>>>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
77334>>>>>>>>>>>>>        String sPath
77334>>>>>>>>>>>>>        Get psIniFilePath to sPath
77335>>>>>>>>>>>>>        Set psFileName to (sPath + sFileName)
77336>>>>>>>>>>>>>        Set private_psIniFileName to sFileName
77337>>>>>>>>>>>>>    End_Procedure
77338>>>>>>>>>>>>>
77338>>>>>>>>>>>>>    Function psIniFileName Returns String
77340>>>>>>>>>>>>>        Function_Return (private_psIniFileName(Self))
77341>>>>>>>>>>>>>    End_Function
77342>>>>>>>>>>>>>
77342>>>>>>>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
77342>>>>>>>>>>>>>    // Sets a value in the program's ini file (write)
77342>>>>>>>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
77342>>>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
77344>>>>>>>>>>>>>        String sIniFile sPath
77344>>>>>>>>>>>>>
77344>>>>>>>>>>>>>        Get psIniFilePath to sPath
77345>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77346>>>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
77347>>>>>>>>>>>>>        Set psFileName to sIniFile
77348>>>>>>>>>>>>>        Send WriteString sSection sValueName sValue
77349>>>>>>>>>>>>>    End_Procedure
77350>>>>>>>>>>>>>
77350>>>>>>>>>>>>>    // Get a value from program's ini-file (read)
77350>>>>>>>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
77350>>>>>>>>>>>>>    // Returns the value
77350>>>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
77352>>>>>>>>>>>>>        String sValue sIniFile sPath
77352>>>>>>>>>>>>>
77352>>>>>>>>>>>>>        Get psIniFilePath to sPath
77353>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77354>>>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
77355>>>>>>>>>>>>>        Set psFileName to sIniFile
77356>>>>>>>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
77357>>>>>>>>>>>>>
77357>>>>>>>>>>>>>        Function_Return sValue
77358>>>>>>>>>>>>>    End_Function
77359>>>>>>>>>>>>>
77359>>>>>>>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
77359>>>>>>>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
77361>>>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
77364>>>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
77367>>>>>>>>>>>>>
77367>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
77370>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
77373>>>>>>>>>>>>>
77373>>>>>>>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
77376>>>>>>>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
77379>>>>>>>>>>>>>
77379>>>>>>>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
77382>>>>>>>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
77385>>>>>>>>>>>>>
77385>>>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
77388>>>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
77391>>>>>>>>>>>>>
77391>>>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
77394>>>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
77397>>>>>>>>>>>>>
77397>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
77400>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
77403>>>>>>>>>>>>>
77403>>>>>>>>>>>>>        Function_Return (EQ)
77404>>>>>>>>>>>>>    End_Function
77405>>>>>>>>>>>>>
77405>>>>>>>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
77407>>>>>>>>>>>>>        Handle hoSections
77407>>>>>>>>>>>>>        Integer iItems
77407>>>>>>>>>>>>>
77407>>>>>>>>>>>>>        Send ReadSections hoSections
77408>>>>>>>>>>>>>        Move (Item_Count(hoSections)) to iItems
77409>>>>>>>>>>>>>        Function_Return iItems
77410>>>>>>>>>>>>>    End_Function
77411>>>>>>>>>>>>>
77411>>>>>>>>>>>>>    // The normal connection string looks something like this;
77411>>>>>>>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
77411>>>>>>>>>>>>>    // ...but the full connection string looks like this;
77411>>>>>>>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
77411>>>>>>>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
77411>>>>>>>>>>>>>//        String sSection
77411>>>>>>>>>>>>>//        Integer iCount
77411>>>>>>>>>>>>>//
77411>>>>>>>>>>>>>//        Move False to Err
77411>>>>>>>>>>>>>//        Get psIniSectionName to sSection
77411>>>>>>>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
77411>>>>>>>>>>>>>//        Increment iCount
77411>>>>>>>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
77411>>>>>>>>>>>>>//
77411>>>>>>>>>>>>>//        Function_Return (Err = False)
77411>>>>>>>>>>>>>//    End_Function
77411>>>>>>>>>>>>>
77411>>>>>>>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
77413>>>>>>>>>>>>>        Integer iCount
77413>>>>>>>>>>>>>        Boolean bExists
77413>>>>>>>>>>>>>        String sSection
77413>>>>>>>>>>>>>
77413>>>>>>>>>>>>>        Move False to Err
77414>>>>>>>>>>>>>        Move 1 to iCount
77415>>>>>>>>>>>>>        Get psIniSectionName to sSection
77416>>>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77417>>>>>>>>>>>>>        While (bExists = True)
77421>>>>>>>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
77422>>>>>>>>>>>>>            Increment iCount
77423>>>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77424>>>>>>>>>>>>>        Loop
77425>>>>>>>>>>>>>>
77425>>>>>>>>>>>>>        Function_Return (Err = False)
77426>>>>>>>>>>>>>    End_Function
77427>>>>>>>>>>>>>
77427>>>>>>>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
77429>>>>>>>>>>>>>        Integer iCount
77429>>>>>>>>>>>>>        String sSection
77429>>>>>>>>>>>>>        Boolean bExists
77429>>>>>>>>>>>>>
77429>>>>>>>>>>>>>        Move False to Err
77430>>>>>>>>>>>>>        Move 1 to iCount
77431>>>>>>>>>>>>>        Get psIniSectionName to sSection
77432>>>>>>>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
77433>>>>>>>>>>>>>        While (bExists = True)
77437>>>>>>>>>>>>>            If (iCount = iItem) Begin
77439>>>>>>>>>>>>>                Send DeleteSection sSection
77440>>>>>>>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
77440>>>>>>>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
77441>>>>>>>>>>>>>            End
77441>>>>>>>>>>>>>>
77441>>>>>>>>>>>>>            Increment iCount
77442>>>>>>>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
77443>>>>>>>>>>>>>        Loop
77444>>>>>>>>>>>>>>
77444>>>>>>>>>>>>>
77444>>>>>>>>>>>>>        Function_Return (Err = False)
77445>>>>>>>>>>>>>    End_Function
77446>>>>>>>>>>>>>
77446>>>>>>>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
77446>>>>>>>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
77446>>>>>>>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
77448>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77448>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77449>>>>>>>>>>>>>        tSQLConnection   SQLConnection
77449>>>>>>>>>>>>>        tSQLConnection   SQLConnection
77449>>>>>>>>>>>>>        Integer iIndex
77449>>>>>>>>>>>>>
77449>>>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
77450>>>>>>>>>>>>>        If (iIndex = -1) Begin
77452>>>>>>>>>>>>>            Move True to SQLConnection.bError
77453>>>>>>>>>>>>>            Function_Return SQLConnection
77454>>>>>>>>>>>>>        End
77454>>>>>>>>>>>>>>
77454>>>>>>>>>>>>>
77454>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77455>>>>>>>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
77456>>>>>>>>>>>>>
77456>>>>>>>>>>>>>        Function_Return SQLConnection
77457>>>>>>>>>>>>>    End_Function
77458>>>>>>>>>>>>>
77458>>>>>>>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
77458>>>>>>>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
77460>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77460>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77461>>>>>>>>>>>>>        Integer iRetval iCount iSize
77461>>>>>>>>>>>>>        String sValue
77461>>>>>>>>>>>>>        Boolean bExists
77461>>>>>>>>>>>>>
77461>>>>>>>>>>>>>        Move -1 to iRetval
77462>>>>>>>>>>>>>
77462>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77463>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77464>>>>>>>>>>>>>        Decrement iSize
77465>>>>>>>>>>>>>        For iCount from 0 to iSize
77471>>>>>>>>>>>>>>
77471>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
77472>>>>>>>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
77473>>>>>>>>>>>>>            If (bExists) Begin
77475>>>>>>>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
77476>>>>>>>>>>>>>                Move iSize to iCount         // We're done!
77477>>>>>>>>>>>>>            End
77477>>>>>>>>>>>>>>
77477>>>>>>>>>>>>>        Loop
77478>>>>>>>>>>>>>>
77478>>>>>>>>>>>>>
77478>>>>>>>>>>>>>        Function_Return iRetval
77479>>>>>>>>>>>>>    End_Function
77480>>>>>>>>>>>>>
77480>>>>>>>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
77480>>>>>>>>>>>>>    // Used to check that ConnectionID's are unique.
77480>>>>>>>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
77482>>>>>>>>>>>>>        Integer iCount iSize iItems
77482>>>>>>>>>>>>>        String sValue
77482>>>>>>>>>>>>>        Boolean bExists
77482>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77482>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77483>>>>>>>>>>>>>
77483>>>>>>>>>>>>>        Move 0 to iItems
77484>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77485>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77486>>>>>>>>>>>>>        Decrement iSize
77487>>>>>>>>>>>>>        For iCount from 0 to iSize
77493>>>>>>>>>>>>>>
77493>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
77494>>>>>>>>>>>>>            Move (sValue = sConnectionID) to bExists
77495>>>>>>>>>>>>>            If (bExists) Begin
77497>>>>>>>>>>>>>                Increment iItems
77498>>>>>>>>>>>>>            End
77498>>>>>>>>>>>>>>
77498>>>>>>>>>>>>>        Loop
77499>>>>>>>>>>>>>>
77499>>>>>>>>>>>>>
77499>>>>>>>>>>>>>        Function_Return (iItems > 1)
77500>>>>>>>>>>>>>    End_Function
77501>>>>>>>>>>>>>
77501>>>>>>>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
77501>>>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
77503>>>>>>>>>>>>>        Boolean bOK
77503>>>>>>>>>>>>>        Integer iSize iCount
77503>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77503>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77504>>>>>>>>>>>>>        tSQLConnection SQLConnection
77504>>>>>>>>>>>>>        tSQLConnection SQLConnection
77504>>>>>>>>>>>>>        String sConnectionString
77504>>>>>>>>>>>>>
77504>>>>>>>>>>>>>        Move False to Err
77505>>>>>>>>>>>>>        Get psConnectionString to sConnectionString
77506>>>>>>>>>>>>>
77506>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77507>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77508>>>>>>>>>>>>>        Decrement iSize
77509>>>>>>>>>>>>>        // Set all current connection to inactive.
77509>>>>>>>>>>>>>        For iCount from 0 to iSize
77515>>>>>>>>>>>>>>
77515>>>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
77516>>>>>>>>>>>>>        Loop
77517>>>>>>>>>>>>>>
77517>>>>>>>>>>>>>
77517>>>>>>>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
77518>>>>>>>>>>>>>        Move True              to SQLConnection.bEnabled
77519>>>>>>>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
77520>>>>>>>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
77521>>>>>>>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
77522>>>>>>>>>>>>>
77522>>>>>>>>>>>>>        Function_Return (bOK = True)
77523>>>>>>>>>>>>>    End_Function
77524>>>>>>>>>>>>>
77524>>>>>>>>>>>>>    // Used for updating an existing connection with new data.
77524>>>>>>>>>>>>>    // Returns True if successful.
77524>>>>>>>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
77526>>>>>>>>>>>>>        Boolean bOK
77526>>>>>>>>>>>>>        Integer iItem iSize iCount
77526>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77526>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77527>>>>>>>>>>>>>
77527>>>>>>>>>>>>>        Move False to Err
77528>>>>>>>>>>>>>        Move -1 to iItem
77529>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77530>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77531>>>>>>>>>>>>>        Decrement iSize
77532>>>>>>>>>>>>>        // Set all current connection to inactive.
77532>>>>>>>>>>>>>        For iCount from 0 to iSize
77538>>>>>>>>>>>>>>
77538>>>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
77539>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
77541>>>>>>>>>>>>>                Move iCount to iItem
77542>>>>>>>>>>>>>            End
77542>>>>>>>>>>>>>>
77542>>>>>>>>>>>>>        Loop
77543>>>>>>>>>>>>>>
77543>>>>>>>>>>>>>
77543>>>>>>>>>>>>>        If (iItem <> -1) Begin
77545>>>>>>>>>>>>>            Move True to SQLConnection.bEnabled
77546>>>>>>>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
77547>>>>>>>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
77548>>>>>>>>>>>>>        End
77548>>>>>>>>>>>>>>
77548>>>>>>>>>>>>>
77548>>>>>>>>>>>>>        Function_Return (bOK = True)
77549>>>>>>>>>>>>>    End_Function
77550>>>>>>>>>>>>>
77550>>>>>>>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
77552>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77552>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77553>>>>>>>>>>>>>        String sSection sValue
77553>>>>>>>>>>>>>        Integer iCount
77553>>>>>>>>>>>>>        Boolean bExists
77553>>>>>>>>>>>>>
77553>>>>>>>>>>>>>        Get psIniSectionName to sSection
77554>>>>>>>>>>>>>        Get SectionExists sSection to bExists
77555>>>>>>>>>>>>>        If (bExists = False) Begin
77557>>>>>>>>>>>>>            Function_Return SQLConnectionsArray
77558>>>>>>>>>>>>>        End
77558>>>>>>>>>>>>>>
77558>>>>>>>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
77559>>>>>>>>>>>>>        If (bExists = True) Begin
77561>>>>>>>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
77562>>>>>>>>>>>>>>
77562>>>>>>>>>>>>>        End
77562>>>>>>>>>>>>>>
77562>>>>>>>>>>>>>
77562>>>>>>>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
77563>>>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77564>>>>>>>>>>>>>
77564>>>>>>>>>>>>>        While (bExists = True)                 
77568>>>>>>>>>>>>>            // 2018-07-14 Change to allow disabling all connections in test environment.
77568>>>>>>>>>>>>>            // We always put the enabled/active connection at the top
77568>>>>>>>>>>>>>//            Move (iCount = 1) to bEnabled
77568>>>>>>>>>>>>>//            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
77568>>>>>>>>>>>>>
77568>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
77569>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
77570>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword     ""        to sValue
77571>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", False, True))                                               to SQLConnectionsArray[iCount].bEnabled
77572>>>>>>>>>>>>>
77572>>>>>>>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
77572>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
77573>>>>>>>>>>>>>            If (sValue = "99") Begin
77575>>>>>>>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
77576>>>>>>>>>>>>>            End
77576>>>>>>>>>>>>>>
77576>>>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
77577>>>>>>>>>>>>>
77577>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
77578>>>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
77579>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
77581>>>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniFileDSNKeyword +"=") to SQLConnectionsArray[iCount].sServer
77582>>>>>>>>>>>>>            End
77582>>>>>>>>>>>>>>
77582>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
77584>>>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
77585>>>>>>>>>>>>>            End
77585>>>>>>>>>>>>>>
77585>>>>>>>>>>>>>
77585>>>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
77586>>>>>>>>>>>>>
77586>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
77587>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
77588>>>>>>>>>>>>>
77588>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
77589>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
77590>>>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
77592>>>>>>>>>>>>>                Get DecryptPassword sValue to sValue
77593>>>>>>>>>>>>>            End
77593>>>>>>>>>>>>>>
77593>>>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
77594>>>>>>>>>>>>>
77594>>>>>>>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
77594>>>>>>>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
77595>>>>>>>>>>>>>
77595>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
77596>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
77597>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
77598>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
77599>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to sValue
77600>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bSilentLogin
77601>>>>>>>>>>>>>
77601>>>>>>>>>>>>>            Increment iCount
77602>>>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77603>>>>>>>>>>>>>        Loop
77604>>>>>>>>>>>>>>
77604>>>>>>>>>>>>>
77604>>>>>>>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
77604>>>>>>>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
77606>>>>>>>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
77607>>>>>>>>>>>>>        End
77607>>>>>>>>>>>>>>
77607>>>>>>>>>>>>>
77607>>>>>>>>>>>>>        Function_Return SQLConnectionsArray
77608>>>>>>>>>>>>>    End_Function
77609>>>>>>>>>>>>>
77609>>>>>>>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
77611>>>>>>>>>>>>>        Integer iCount iSize
77611>>>>>>>>>>>>>        Boolean bOK
77611>>>>>>>>>>>>>        String sSection sValue
77611>>>>>>>>>>>>>
77611>>>>>>>>>>>>>        // First we need to _remove_ all current connections from the ini-file.
77611>>>>>>>>>>>>>        Move 0 to iCount
77612>>>>>>>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
77613>>>>>>>>>>>>>        If (bOK = False) Begin
77615>>>>>>>>>>>>>            Function_Return False
77616>>>>>>>>>>>>>        End
77616>>>>>>>>>>>>>>
77616>>>>>>>>>>>>>
77616>>>>>>>>>>>>>        Move False to Err
77617>>>>>>>>>>>>>        Get psIniSectionName to sSection
77618>>>>>>>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
77618>>>>>>>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
77619>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77620>>>>>>>>>>>>>        Decrement iSize
77621>>>>>>>>>>>>>
77621>>>>>>>>>>>>>        For iCount from 0 to iSize
77627>>>>>>>>>>>>>>
77627>>>>>>>>>>>>>            // DF 19 compatible settings:
77627>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
77628>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
77629>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDisabledKeyword       to (If(SQLConnectionsArray[iCount].bEnabled = 0, "Yes", "No"))
77630>>>>>>>>>>>>>            
77630>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
77631>>>>>>>>>>>>>
77631>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
77632>>>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
77634>>>>>>>>>>>>>                Get EncryptPassword sValue to sValue
77635>>>>>>>>>>>>>            End
77635>>>>>>>>>>>>>>
77635>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
77636>>>>>>>>>>>>>
77636>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
77638>>>>>>>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
77639>>>>>>>>>>>>>            End
77639>>>>>>>>>>>>>>
77639>>>>>>>>>>>>>
77639>>>>>>>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
77640>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
77641>>>>>>>>>>>>>
77641>>>>>>>>>>>>>            // The Database Update Framework extended settings:
77641>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
77642>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
77643>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
77644>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
77645>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
77646>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to (If(SQLConnectionsArray[iCount].bSilentLogin = 1, "Yes", "No"))
77647>>>>>>>>>>>>>        Loop
77648>>>>>>>>>>>>>>
77648>>>>>>>>>>>>>
77648>>>>>>>>>>>>>        Function_Return (bOK and Err = False)
77649>>>>>>>>>>>>>    End_Function
77650>>>>>>>>>>>>>
77650>>>>>>>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
77650>>>>>>>>>>>>>    //
77650>>>>>>>>>>>>>    // SQL utility function that returns a database type (string) constant
77650>>>>>>>>>>>>>    // corresponding to the passed iDbType.
77650>>>>>>>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
77652>>>>>>>>>>>>>        String sRetval
77652>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
77654>>>>>>>>>>>>>            Move CS_dbTypeMSSQL to sRetval
77655>>>>>>>>>>>>>        End
77655>>>>>>>>>>>>>>
77655>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
77657>>>>>>>>>>>>>            Move CS_dbTypeMySQL to sRetval
77658>>>>>>>>>>>>>        End
77658>>>>>>>>>>>>>>
77658>>>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
77660>>>>>>>>>>>>>            Move CS_dbTypeOracle to sRetval
77661>>>>>>>>>>>>>        End
77661>>>>>>>>>>>>>>
77661>>>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
77663>>>>>>>>>>>>>            Move CS_dbTypeDB2 to sRetval
77664>>>>>>>>>>>>>        End
77664>>>>>>>>>>>>>>
77664>>>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
77666>>>>>>>>>>>>>            Move CS_dbTypePostgre to sRetval
77667>>>>>>>>>>>>>        End
77667>>>>>>>>>>>>>>
77667>>>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
77669>>>>>>>>>>>>>            Move CS_DbTypePervasive to sRetval
77670>>>>>>>>>>>>>        End
77670>>>>>>>>>>>>>>
77670>>>>>>>>>>>>>        Function_Return sRetval
77671>>>>>>>>>>>>>    End_Function
77672>>>>>>>>>>>>>
77672>>>>>>>>>>>>>    // SQL utility function that returns a database type constant (integer)
77672>>>>>>>>>>>>>    // corresponding to the passed sDbType string constant.
77672>>>>>>>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
77674>>>>>>>>>>>>>        Integer iRetval
77674>>>>>>>>>>>>>        If (sDbType = CS_DbTypeDataFlex) Begin
77676>>>>>>>>>>>>>            Move EN_DbTypeDataFlex to iRetval
77677>>>>>>>>>>>>>        End
77677>>>>>>>>>>>>>>
77677>>>>>>>>>>>>>        If (sDbType = CS_dbTypeMSSQL) Begin
77679>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77680>>>>>>>>>>>>>        End
77680>>>>>>>>>>>>>>
77680>>>>>>>>>>>>>        If (sDbType = CS_dbTypeMySQL) Begin
77682>>>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
77683>>>>>>>>>>>>>        End
77683>>>>>>>>>>>>>>
77683>>>>>>>>>>>>>        If (sDbType = CS_dbTypeOracle) Begin
77685>>>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
77686>>>>>>>>>>>>>        End
77686>>>>>>>>>>>>>>
77686>>>>>>>>>>>>>        If (sDbType = CS_dbTypeDB2) Begin
77688>>>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
77689>>>>>>>>>>>>>        End
77689>>>>>>>>>>>>>>
77689>>>>>>>>>>>>>        If (sDbType = CS_dbTypePostgre) Begin
77691>>>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
77692>>>>>>>>>>>>>        End
77692>>>>>>>>>>>>>>
77692>>>>>>>>>>>>>        If (sDbType = CS_DbTypePervasive) Begin
77694>>>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
77695>>>>>>>>>>>>>        End
77695>>>>>>>>>>>>>>
77695>>>>>>>>>>>>>        Function_Return iRetval
77696>>>>>>>>>>>>>    End_Function
77697>>>>>>>>>>>>>
77697>>>>>>>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
77697>>>>>>>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
77697>>>>>>>>>>>>>    // the SQL Connection program's grid.
77697>>>>>>>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
77699>>>>>>>>>>>>>        String sRetval
77699>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
77701>>>>>>>>>>>>>            Move "EN_dbTypeMSSQL" to sRetval
77702>>>>>>>>>>>>>        End
77702>>>>>>>>>>>>>>
77702>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
77704>>>>>>>>>>>>>            Move "EN_dbTypeMySQL" to sRetval
77705>>>>>>>>>>>>>        End
77705>>>>>>>>>>>>>>
77705>>>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
77707>>>>>>>>>>>>>            Move "EN_dbTypeOracle" to sRetval
77708>>>>>>>>>>>>>        End
77708>>>>>>>>>>>>>>
77708>>>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
77710>>>>>>>>>>>>>            Move "EN_dbTypeDB2" to sRetval
77711>>>>>>>>>>>>>        End
77711>>>>>>>>>>>>>>
77711>>>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
77713>>>>>>>>>>>>>            Move "EN_dbTypePostgre" to sRetval
77714>>>>>>>>>>>>>        End
77714>>>>>>>>>>>>>>
77714>>>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
77716>>>>>>>>>>>>>            Move "EN_dbTypePervasive" to sRetval
77717>>>>>>>>>>>>>        End
77717>>>>>>>>>>>>>>
77717>>>>>>>>>>>>>        Function_Return sRetval
77718>>>>>>>>>>>>>    End_Function
77719>>>>>>>>>>>>>
77719>>>>>>>>>>>>>    // Pass a driver id and the function will return
77719>>>>>>>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
77719>>>>>>>>>>>>>    // quite work and always returns "MS SQL Server"
77719>>>>>>>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
77721>>>>>>>>>>>>>        Integer iRetval
77721>>>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
77723>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77724>>>>>>>>>>>>>        End
77724>>>>>>>>>>>>>>
77724>>>>>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
77726>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77727>>>>>>>>>>>>>        End
77727>>>>>>>>>>>>>>
77727>>>>>>>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
77729>>>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
77730>>>>>>>>>>>>>        End
77730>>>>>>>>>>>>>>
77730>>>>>>>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
77732>>>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
77733>>>>>>>>>>>>>        End
77733>>>>>>>>>>>>>>
77733>>>>>>>>>>>>>        Function_Return iRetval
77734>>>>>>>>>>>>>    End_Function
77735>>>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
77735>>>>>>>>>>>>>>
77735>>>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
77737>>>>>>>>>>>>>>    Integer iStart iEnd
77737>>>>>>>>>>>>>>    String sRetval
77737>>>>>>>>>>>>>>
77737>>>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
77738>>>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
77739>>>>>>>>>>>>>>    If (iStart = 0) Begin
77741>>>>>>>>>>>>>>        Function_Return ""
77742>>>>>>>>>>>>>>    End
77742>>>>>>>>>>>>>>>
77742>>>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
77743>>>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
77744>>>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
77746>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77747>>>>>>>>>>>>>>    End
77747>>>>>>>>>>>>>>>
77747>>>>>>>>>>>>>>    Else Begin
77748>>>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
77749>>>>>>>>>>>>>>    End
77749>>>>>>>>>>>>>>>
77749>>>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
77751>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77752>>>>>>>>>>>>>>        Decrement iEnd
77753>>>>>>>>>>>>>>    End
77753>>>>>>>>>>>>>>>
77753>>>>>>>>>>>>>>    If (iEnd <> 0) Begin
77755>>>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
77756>>>>>>>>>>>>>>    End
77756>>>>>>>>>>>>>>>
77756>>>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
77757>>>>>>>>>>>>>>
77757>>>>>>>>>>>>>>    Function_Return (Trim(sRetval))
77758>>>>>>>>>>>>>>End_Function
77759>>>>>>>>>>>>>>
77759>>>>>>>>>>>>>>
77759>>>>>>>>>>>>>
77759>>>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77761>>>>>>>>>>>>>        String sConnect
77761>>>>>>>>>>>>>        Handle hoDriver
77761>>>>>>>>>>>>>
77761>>>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver 
77762>>>>>>>>>>>>>        Set Name of hoDriver to "oDbUpdateDatabaseDriver"
77763>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
77764>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
77765>>>>>>>>>>>>>        Send Destroy of hoDriver
77766>>>>>>>>>>>>>
77766>>>>>>>>>>>>>        Function_Return sConnect
77767>>>>>>>>>>>>>    End_Function
77768>>>>>>>>>>>>>
77768>>>>>>>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
77768>>>>>>>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
77770>>>>>>>>>>>>>        String sConnect
77770>>>>>>>>>>>>>
77770>>>>>>>>>>>>>        Case Begin
77770>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
77772>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
77773>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77775>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77776>>>>>>>>>>>>>                End
77776>>>>>>>>>>>>>>
77776>>>>>>>>>>>>>                Case Break
77777>>>>>>>>>>>>>
77777>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
77780>>>>>>>>>>>>>                If (Uppercase(sServer) contains ".DSN") Begin
77782>>>>>>>>>>>>>                    Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sConnect
77783>>>>>>>>>>>>>                End
77783>>>>>>>>>>>>>>
77783>>>>>>>>>>>>>                Else If (not(Uppercase(sServer) contains "DSN")) Begin
77786>>>>>>>>>>>>>                    Move (CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77787>>>>>>>>>>>>>                End
77787>>>>>>>>>>>>>>
77787>>>>>>>>>>>>>
77787>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77789>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77790>>>>>>>>>>>>>                End
77790>>>>>>>>>>>>>>
77790>>>>>>>>>>>>>                Case Break
77791>>>>>>>>>>>>>
77791>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
77794>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77795>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77797>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77798>>>>>>>>>>>>>                End
77798>>>>>>>>>>>>>>
77798>>>>>>>>>>>>>                Case Break
77799>>>>>>>>>>>>>
77799>>>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
77802>>>>>>>>>>>>>                Break
77803>>>>>>>>>>>>>
77803>>>>>>>>>>>>>            Case Else
77803>>>>>>>>>>>>>                Move "" to sConnect
77804>>>>>>>>>>>>>        Case End
77804>>>>>>>>>>>>>
77804>>>>>>>>>>>>>        Function_Return sConnect
77805>>>>>>>>>>>>>    End_Function
77806>>>>>>>>>>>>>
77806>>>>>>>>>>>>>    // Use Base64
77806>>>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
77808>>>>>>>>>>>>>        String sRetval
77808>>>>>>>>>>>>>        Handle hoLoginEncryption
77808>>>>>>>>>>>>>
77808>>>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
77809>>>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
77810>>>>>>>>>>>>>        Get EncryptPassword of hoLoginEncryption sPassword to sRetval
77811>>>>>>>>>>>>>        Send Destroy of hoLoginEncryption
77812>>>>>>>>>>>>>          
77812>>>>>>>>>>>>>        Function_Return sRetval
77813>>>>>>>>>>>>>    End_Function
77814>>>>>>>>>>>>>
77814>>>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
77816>>>>>>>>>>>>>        String sRetval
77816>>>>>>>>>>>>>        Handle hoLoginEncryption
77816>>>>>>>>>>>>>
77816>>>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
77817>>>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
77818>>>>>>>>>>>>>        Get DecryptPassword of hoLoginEncryption sPassword to sRetval
77819>>>>>>>>>>>>>        Send Destroy of hoLoginEncryption
77820>>>>>>>>>>>>>
77820>>>>>>>>>>>>>        Function_Return sRetval
77821>>>>>>>>>>>>>    End_Function
77822>>>>>>>>>>>>>
77822>>>>>>>>>>>>>    // Returns the full path of the Application (no trailing "\")
77822>>>>>>>>>>>>>    Function ApplicationPath Returns String
77824>>>>>>>>>>>>>        String sApplicationFileName sPath
77824>>>>>>>>>>>>>        Integer iNumChars iRetval
77824>>>>>>>>>>>>>
77824>>>>>>>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
77825>>>>>>>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
77826>>>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
77827>>>>>>>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
77828>>>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sPath
77829>>>>>>>>>>>>>
77829>>>>>>>>>>>>>        Function_Return sPath
77830>>>>>>>>>>>>>    End_Function
77831>>>>>>>>>>>>>
77831>>>>>>>>>>>>>    // Pass a filename including the extension. The return value
77831>>>>>>>>>>>>>    // will be the path of of the first found "sSearchFileName in the workspace.
77831>>>>>>>>>>>>>    // If not found in the workspace it will be search "globally" by the Get_File_Path command.
77831>>>>>>>>>>>>>    Function SearchLocallyThenGloballyForFile String sSearchFileName Returns String
77833>>>>>>>>>>>>>        Boolean bExists
77833>>>>>>>>>>>>>        Handle hoPaths hoIniFile
77833>>>>>>>>>>>>>        String[] asWorkSpaceFiles
77834>>>>>>>>>>>>>        String sProgramsPath sSection sFileName sRelativePath sRelativePaths sPath sDirSep sProgramsDir
77834>>>>>>>>>>>>>        Integer iSize iCount iPath iNoOfPaths iCountPath
77834>>>>>>>>>>>>>        
77834>>>>>>>>>>>>>        Get psIniFilePath to sProgramsPath
77835>>>>>>>>>>>>>        Get vFolderFormat sProgramsPath to sProgramsPath 
77836>>>>>>>>>>>>>        Move (Lowercase(sSearchFileName)) to sSearchFileName
77837>>>>>>>>>>>>>        Get vFilePathExists (sProgramsPath + sSearchFileName) to bExists   
77838>>>>>>>>>>>>>        If (bExists = True) Begin
77840>>>>>>>>>>>>>            Function_Return sProgramsPath
77841>>>>>>>>>>>>>        End                      
77841>>>>>>>>>>>>>>
77841>>>>>>>>>>>>>    
77841>>>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
77842>>>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
77844>>>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
77845>>>>>>>>>>>>>        End                                              
77845>>>>>>>>>>>>>>
77845>>>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sProgramsDir
77846>>>>>>>>>>>>>        
77846>>>>>>>>>>>>>        Move False to bExists
77847>>>>>>>>>>>>>        Get Create (RefClass(Array)) to hoPaths
77848>>>>>>>>>>>>>        Get WorkspaceIniFiles sProgramsPath to asWorkspaceFiles
77849>>>>>>>>>>>>>        Move (SizeOfArray(asWorkspaceFiles)) to iSize
77850>>>>>>>>>>>>>        Decrement iSize       
77851>>>>>>>>>>>>>        
77851>>>>>>>>>>>>>        For iCount from 0 to iSize
77857>>>>>>>>>>>>>>
77857>>>>>>>>>>>>>            Move asWorkspaceFiles[iCount] to sFileName
77858>>>>>>>>>>>>>            Get Create (Refclass(cIniFile)) to hoIniFile
77859>>>>>>>>>>>>>            Set psFileName of hoIniFile to sFileName
77860>>>>>>>>>>>>>            Send ReadSection of hoIniFile "Workspace" hoPaths
77861>>>>>>>>>>>>>            For iPath from 0 to (Item_Count(hoPaths) -1)
77867>>>>>>>>>>>>>>
77867>>>>>>>>>>>>>                Get Value of hoPaths iPath to sSection    
77868>>>>>>>>>>>>>                Get ReadString of hoIniFile "Workspace" sSection "" to sRelativePath 
77869>>>>>>>>>>>>>                // Check if there are more than one path specified;
77869>>>>>>>>>>>>>                Get CountOfPaths of (phoWorkspace(ghoApplication)) sRelativePath to iNoOfPaths
77870>>>>>>>>>>>>>                If (iNoOfPaths > 1) Begin         
77872>>>>>>>>>>>>>                    Move sRelativePath to sRelativePaths
77873>>>>>>>>>>>>>                    For iCountPath from 1 to iNoOfPaths
77879>>>>>>>>>>>>>>
77879>>>>>>>>>>>>>                        Get PathAtIndex of (phoWorkspace(ghoApplication)) sRelativePaths iCountPath to sRelativePath
77880>>>>>>>>>>>>>                        Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
77881>>>>>>>>>>>>>                        Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
77882>>>>>>>>>>>>>                        Get vFolderFormat sPath to sPath
77883>>>>>>>>>>>>>                        Get vFilePathExists (sPath + sSearchFileName) to bExists
77884>>>>>>>>>>>>>                        If (bExists = True) Begin
77886>>>>>>>>>>>>>                            Move iNoOfPaths to iCountPath
77887>>>>>>>>>>>>>                            Move (Item_Count(hoPaths)) to iPath // We're done.
77888>>>>>>>>>>>>>                            Move iSize to iCount
77889>>>>>>>>>>>>>                        End                                                    
77889>>>>>>>>>>>>>>
77889>>>>>>>>>>>>>                    Loop
77890>>>>>>>>>>>>>>
77890>>>>>>>>>>>>>                End
77890>>>>>>>>>>>>>>
77890>>>>>>>>>>>>>                Else Begin
77891>>>>>>>>>>>>>                    Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
77892>>>>>>>>>>>>>                    Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
77893>>>>>>>>>>>>>                    Get vFolderFormat sPath to sPath
77894>>>>>>>>>>>>>                    Get vFilePathExists (sPath + sSearchFileName) to bExists
77895>>>>>>>>>>>>>                    If (bExists = True) Begin
77897>>>>>>>>>>>>>                        Move (Item_Count(hoPaths)) to iPath // We're done.
77898>>>>>>>>>>>>>                        Move iSize to iCount
77899>>>>>>>>>>>>>                    End                                                    
77899>>>>>>>>>>>>>>
77899>>>>>>>>>>>>>                End
77899>>>>>>>>>>>>>>
77899>>>>>>>>>>>>>            Loop
77900>>>>>>>>>>>>>>
77900>>>>>>>>>>>>>            If (bExists = False) Begin
77902>>>>>>>>>>>>>                Move "" to sPath    
77903>>>>>>>>>>>>>            End
77903>>>>>>>>>>>>>>
77903>>>>>>>>>>>>>            Send Destroy of hoIniFile          
77904>>>>>>>>>>>>>        Loop        
77905>>>>>>>>>>>>>>
77905>>>>>>>>>>>>>        Send Destroy of hoPaths
77906>>>>>>>>>>>>>        
77906>>>>>>>>>>>>>        // Then not found in workspace, look for the file in DFSysPath;
77906>>>>>>>>>>>>>        If (sPath = "") Begin
77908>>>>>>>>>>>>>            Get_File_Path sSearchFileName to sFileName   
77909>>>>>>>>>>>>>            Get ParseFolderName sFileName to sPath
77910>>>>>>>>>>>>>        End                  
77910>>>>>>>>>>>>>>
77910>>>>>>>>>>>>>        
77910>>>>>>>>>>>>>        Function_Return sPath    
77911>>>>>>>>>>>>>    End_Function
77912>>>>>>>>>>>>>    
77912>>>>>>>>>>>>>    // Pass the path to the workspace Programs folder - returns a string array
77912>>>>>>>>>>>>>    // with one or more .ws file names.
77912>>>>>>>>>>>>>    // First checks if there is a .sws file - and if so reads the name of the
77912>>>>>>>>>>>>>    // workspace file (.ws) and returns it as a string array.
77912>>>>>>>>>>>>>    // If _no_ .sws file is found, enumerates the passed sProgramsPath variable
77912>>>>>>>>>>>>>    Function WorkspaceIniFiles String sProgramsPath Returns String[]
77914>>>>>>>>>>>>>        String[] asSWSFiles asWorkspaceFiles   
77916>>>>>>>>>>>>>        String sFile sHomePath sDirSep
77916>>>>>>>>>>>>>        Integer iCh iSize
77916>>>>>>>>>>>>>        Boolean bExists      
77916>>>>>>>>>>>>>        Handle hoIniFile 
77916>>>>>>>>>>>>>        
77916>>>>>>>>>>>>>        Move (ResizeArray(asSWSFiles, 0)) to asSWSFiles
77917>>>>>>>>>>>>>        Move (ResizeArray(asWorkspaceFiles, 0)) to asWorkspaceFiles
77918>>>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
77920>>>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
77921>>>>>>>>>>>>>        End                                              
77921>>>>>>>>>>>>>>
77921>>>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
77922>>>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sHomePath
77923>>>>>>>>>>>>>        Move (Replace(sHomePath, sProgramsPath, "")) to sHomePath
77924>>>>>>>>>>>>>        Get vFolderFormat sHomePath to sHomePath 
77925>>>>>>>>>>>>>        
77925>>>>>>>>>>>>>        // First check if theres an .sws file. If there is we will open it and
77925>>>>>>>>>>>>>        // read the name of the .ws file name.
77925>>>>>>>>>>>>>        File_Exist (sHomePath + "*.sws") bExists
77926>>>>>>>>>>>>>        If (bExists = True) Begin
77928>>>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sHomePath + "*.sws") to iCh
77929>>>>>>>>>>>>>            If (iCh < 0) Begin
77931>>>>>>>>>>>>>                Function_Return asSWSFiles
77932>>>>>>>>>>>>>            End                                 
77932>>>>>>>>>>>>>>
77932>>>>>>>>>>>>>            
77932>>>>>>>>>>>>>            Repeat
77932>>>>>>>>>>>>>>
77932>>>>>>>>>>>>>                Readln channel iCh sFile
77934>>>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
77936>>>>>>>>>>>>>                    Move sFile to asSWSFiles[SizeOfArray(asSWSFiles)]
77937>>>>>>>>>>>>>                End
77937>>>>>>>>>>>>>>
77937>>>>>>>>>>>>>            Until (SeqEof = True)
77939>>>>>>>>>>>>>            Send Seq_Close_Channel iCh    
77940>>>>>>>>>>>>>            
77940>>>>>>>>>>>>>            Move (SizeOfArray(asSWSFiles)) to iSize
77941>>>>>>>>>>>>>            If (iSize <> 0) Begin
77943>>>>>>>>>>>>>                Get Create (RefClass(cIniFile)) to hoIniFile  
77944>>>>>>>>>>>>>                // Use the file with that is last as it might have the DataFlex version in it,
77944>>>>>>>>>>>>>                // and thus is the latest one and it is more likely it is accurate (?)...
77944>>>>>>>>>>>>>                Move asSWSFiles[SizeOfArray(asSWSFiles) -1] to sFile
77945>>>>>>>>>>>>>                Set psFileName of hoIniFile to (sHomePath + sFile)
77946>>>>>>>>>>>>>                Get ReadString of hoIniFile "WorkspacePaths" "ConfigFile" "" to sFile
77947>>>>>>>>>>>>>                If (sFile <> "") Begin
77949>>>>>>>>>>>>>                    Move (Replace(".", sFile, sHomePath)) to sFile
77950>>>>>>>>>>>>>                    Move (Replace((sDirSep + String(sDirSep)), sFile, sDirSep)) to sFile
77951>>>>>>>>>>>>>                    File_Exist sFile bExists
77952>>>>>>>>>>>>>                    If (bExists = True) Begin
77954>>>>>>>>>>>>>                        Move sFile to asWorkspaceFiles[0] 
77955>>>>>>>>>>>>>                    End
77955>>>>>>>>>>>>>>
77955>>>>>>>>>>>>>                End
77955>>>>>>>>>>>>>>
77955>>>>>>>>>>>>>                Send Destroy of hoIniFile
77956>>>>>>>>>>>>>            End
77956>>>>>>>>>>>>>>
77956>>>>>>>>>>>>>        End
77956>>>>>>>>>>>>>>
77956>>>>>>>>>>>>>        
77956>>>>>>>>>>>>>        // If no .sws file exists, enumerate the .ws files from the Programs folder:    
77956>>>>>>>>>>>>>        If (SizeOfArray(asWorkspaceFiles) = 0) Begin
77958>>>>>>>>>>>>>            Get vFolderFormat sProgramsPath to sProgramsPath 
77959>>>>>>>>>>>>>            File_Exist (sProgramsPath + "*.ws") bExists
77960>>>>>>>>>>>>>            If (bExists = False) Begin
77962>>>>>>>>>>>>>                Function_Return asWorkspaceFiles
77963>>>>>>>>>>>>>            End
77963>>>>>>>>>>>>>>
77963>>>>>>>>>>>>>        
77963>>>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sProgramsPath + "*.ws") to iCh
77964>>>>>>>>>>>>>            If (iCh < 0) Begin
77966>>>>>>>>>>>>>                Function_Return asWorkspaceFiles
77967>>>>>>>>>>>>>            End                                 
77967>>>>>>>>>>>>>>
77967>>>>>>>>>>>>>            
77967>>>>>>>>>>>>>            Repeat
77967>>>>>>>>>>>>>>
77967>>>>>>>>>>>>>                Readln channel iCh sFile
77969>>>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
77971>>>>>>>>>>>>>                    Move sFile to asWorkspaceFiles[SizeOfArray(asWorkspaceFiles)]
77972>>>>>>>>>>>>>                End
77972>>>>>>>>>>>>>>
77972>>>>>>>>>>>>>            Until (SeqEof = True)
77974>>>>>>>>>>>>>            Send Seq_Close_Channel iCh
77975>>>>>>>>>>>>>        End
77975>>>>>>>>>>>>>>
77975>>>>>>>>>>>>>        
77975>>>>>>>>>>>>>        Function_Return asWorkspaceFiles
77976>>>>>>>>>>>>>    End_Function
77977>>>>>>>>>>>>>
77977>>>>>>>>>>>>>End_Class
77978>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
77978>>>>>>>>>>>Use vWin32fh.pkg
77978>>>>>>>>>>>
77978>>>>>>>>>>>// The cConnection class is the new SQL connections class for DF 19.
77978>>>>>>>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
77978>>>>>>>>>>>
77978>>>>>>>>>>>// We're making references to this object handle so we need it defined
77978>>>>>>>>>>>// here as well as for the cDbUpdateHandler class
77978>>>>>>>>>>>
77978>>>>>>>>>>>    Global_Variable Handle ghoSQLConnectionHandler
77978>>>>>>>>>>>    Move 0 to ghoSQLConnectionHandler
77979>>>>>>>>>>>
77979>>>>>>>>>>>Class cSQLConnectionHandler is a cObject
77980>>>>>>>>>>>
77980>>>>>>>>>>>    Procedure Construct_Object
77982>>>>>>>>>>>        Handle ho
77982>>>>>>>>>>>        Forward Send Construct_Object
77984>>>>>>>>>>>        Move Self to ghoSQLConnectionHandler
77985>>>>>>>>>>>
77985>>>>>>>>>>>        Property Handle phoSQLConnectionIniFile 
77986>>>>>>>>>>>        Get  Create (RefClass(cSQLConnectionIniFile)) to ho
77987>>>>>>>>>>>        Set Name of ho to "oSQLConnectionIniFile"
77988>>>>>>>>>>>        Set phoSQLConnectionIniFile to ho
77989>>>>>>>>>>>        
77989>>>>>>>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
77989>>>>>>>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
77989>>>>>>>>>>>        // methods to this class.
77989>>>>>>>>>>>        Property Boolean pbUseConnectionID True
77990>>>>>>>>>>>        Property Boolean pbToANSI          True
77991>>>>>>>>>>>        Property Boolean pbRecnum          True
77992>>>>>>>>>>>        Property Boolean pbCopyData        True
77993>>>>>>>>>>>        Property Boolean pbApiTableUpdateAuto    False
77994>>>>>>>>>>>        Property Boolean pbCompareDate_DateTime  False
77995>>>>>>>>>>>        Property Boolean pbCompareIndexAscending False
77996>>>>>>>>>>>        Property Boolean pbCompareIndexUppercase False
77997>>>>>>>>>>>
77997>>>>>>>>>>>        Property Boolean Private.pbUseDriverCacheFiles True
77998>>>>>>>>>>>        Property Boolean Private.pbIgnoreDriverUcaseSupport True
77999>>>>>>>>>>>        
77999>>>>>>>>>>>        // Driver default value settings:
77999>>>>>>>>>>>        // Note: When the object is created the corresponding values
77999>>>>>>>>>>>        // from the driver .int files are read.
77999>>>>>>>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
77999>>>>>>>>>>>        Property String psDriverDefaultValueASCII    ""
78000>>>>>>>>>>>        Property String psDriverDefaultValueBinary   ""
78001>>>>>>>>>>>        Property String psDriverDefaultValueDate     ""
78002>>>>>>>>>>>        Property String psDriverDefaultValueDateTime ""
78003>>>>>>>>>>>        Property String psDriverDefaultValueNumeric  ""
78004>>>>>>>>>>>        Property String psDriverDefaultValueText     ""
78005>>>>>>>>>>>
78005>>>>>>>>>>>        // Driver "nullability" settings:
78005>>>>>>>>>>>        // Note: When the object is created the corresponding values
78005>>>>>>>>>>>        // from the driver .int files are read.
78005>>>>>>>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
78005>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
78006>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
78007>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableDate     False
78008>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
78009>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
78010>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableText     False
78011>>>>>>>>>>>
78011>>>>>>>>>>>        Property Boolean pbUseCacheFiles                 True
78012>>>>>>>>>>>
78012>>>>>>>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
78012>>>>>>>>>>>        //     It is private because the get/set version also updates the DAW
78012>>>>>>>>>>>        //     driver interfaces.
78012>>>>>>>>>>>        //     There are also procedure/function pairs to set/get individual data members
78012>>>>>>>>>>>        //     of the struct they are all routed throu this struct property.
78012>>>>>>>>>>>        Property tSQLConnection Private.pSQLConnection
78013>>>>>>>>>>>
78013>>>>>>>>>>>    End_Procedure
78014>>>>>>>>>>>
78014>>>>>>>>>>>    Procedure End_Construct_Object
78016>>>>>>>>>>>        tSQLConnection SQLConnection
78016>>>>>>>>>>>        tSQLConnection SQLConnection
78016>>>>>>>>>>>
78016>>>>>>>>>>>        Forward Send End_Construct_Object
78018>>>>>>>>>>>
78018>>>>>>>>>>>        // Now is the time to read and apply SQL connection settings.
78018>>>>>>>>>>>        Get SetupSQLConnection True True to SQLConnection
78019>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78020>>>>>>>>>>>    End_Procedure
78021>>>>>>>>>>>
78021>>>>>>>>>>>    // *** Properties ***
78021>>>>>>>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
78021>>>>>>>>>>>    // private.pSQLConnection struct connection property. These "properties" are
78021>>>>>>>>>>>    // merely here for conveniance.
78021>>>>>>>>>>>    //
78021>>>>>>>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
78021>>>>>>>>>>>    // where we update data to/from the DAW driver interfaces and this framework.
78021>>>>>>>>>>>    // This struct property contains all the connection data.
78021>>>>>>>>>>>    //
78021>>>>>>>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
78023>>>>>>>>>>>        Boolean bOK
78023>>>>>>>>>>>
78023>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78024>>>>>>>>>>>
78024>>>>>>>>>>>        // When starting a program we might not have a connection id yet:
78024>>>>>>>>>>>        If (SQLConnection.sDriverID = DATAFLEX_ID) Begin
78026>>>>>>>>>>>//        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
78026>>>>>>>>>>>            Procedure_Return
78027>>>>>>>>>>>        End
78027>>>>>>>>>>>>
78027>>>>>>>>>>>
78027>>>>>>>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
78027>>>>>>>>>>>        // be logged in already and don't want to do it again.
78027>>>>>>>>>>>        If (SQLConnection.bDAWConnection = False) Begin
78029>>>>>>>>>>>            // After we have set the class property we need to tell the DAW
78029>>>>>>>>>>>            // driver interfaces about the change & make a new login.
78029>>>>>>>>>>>            Get SQLLogin SQLConnection to bOK
78030>>>>>>>>>>>            If (bOK = False) Begin
78032>>>>>>>>>>>                Error DFERR_PROGRAM "Login error."
78033>>>>>>>>>>>>
78033>>>>>>>>>>>            End
78033>>>>>>>>>>>>
78033>>>>>>>>>>>        End
78033>>>>>>>>>>>>
78033>>>>>>>>>>>
78033>>>>>>>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
78033>>>>>>>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
78034>>>>>>>>>>>
78034>>>>>>>>>>>    End_Procedure
78035>>>>>>>>>>>
78035>>>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
78035>>>>>>>>>>>    // attempt to load the driver.
78035>>>>>>>>>>>    // Returns true if the passed driver is SQL based.
78035>>>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
78037>>>>>>>>>>>        Boolean bOK
78037>>>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
78038>>>>>>>>>>>        Function_Return bOK
78039>>>>>>>>>>>    End_Function
78040>>>>>>>>>>>
78040>>>>>>>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
78040>>>>>>>>>>>    Procedure SetupDriverDefaults String sDriverID
78042>>>>>>>>>>>        String sAttributeValue sServer
78042>>>>>>>>>>>        Integer iDriverID
78042>>>>>>>>>>>        Boolean bNULL bSQLDriver
78042>>>>>>>>>>>        Handle hDatabase
78042>>>>>>>>>>>        
78042>>>>>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
78043>>>>>>>>>>>        If (bSQLDriver = False) Begin
78045>>>>>>>>>>>            Procedure_Return
78046>>>>>>>>>>>        End                                      
78046>>>>>>>>>>>>
78046>>>>>>>>>>>        
78046>>>>>>>>>>>        Get DriverIndex sDriverID to iDriverID  
78047>>>>>>>>>>>        // Note: These properties should be set in the cDbUpdateHandler object:
78047>>>>>>>>>>>        //       pbUseDriverCacheFiles and pbIgnoreDriverUcaseSupport
78047>>>>>>>>>>>        If (iDriverID <> 0) Begin
78049>>>>>>>>>>>            Set_Attribute DF_DRIVER_USE_CACHE of iDriverID to (Private.pbUseDriverCacheFiles(Self)) 
78052>>>>>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_UCASE_SUPPORT of iDriverID to (Private.pbIgnoreDriverUcaseSupport(Self))
78055>>>>>>>>>>>        End
78055>>>>>>>>>>>>
78055>>>>>>>>>>>        
78055>>>>>>>>>>>        // ToDo: Testing!
78055>>>>>>>>>>>//        Get psServer of ghoDbUpdateFunctionLibrary to sServer
78055>>>>>>>>>>>//        Get SqlUtilDatabaseHandle of ghoDbUpdateFunctionLibrary sDriverID sServer to hDatabase
78055>>>>>>>>>>>//        Set_Attribute DF_DATABASE_IGNORE_WARNINGS of iDriverID hDatabase to True 
78055>>>>>>>>>>>
78055>>>>>>>>>>>        // Driver default values for various data types:
78055>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
78058>>>>>>>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
78059>>>>>>>>>>>
78059>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
78062>>>>>>>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
78063>>>>>>>>>>>
78063>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
78066>>>>>>>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
78067>>>>>>>>>>>
78067>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
78070>>>>>>>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
78071>>>>>>>>>>>
78071>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
78074>>>>>>>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
78075>>>>>>>>>>>
78075>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
78078>>>>>>>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
78079>>>>>>>>>>>
78079>>>>>>>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
78079>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
78082>>>>>>>>>>>        Set pbDriverDefaultNullableASCII to bNULL
78083>>>>>>>>>>>
78083>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
78086>>>>>>>>>>>        Set pbDriverDefaultNullableBinary to bNULL
78087>>>>>>>>>>>
78087>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
78090>>>>>>>>>>>        Set pbDriverDefaultNullableDate to bNULL
78091>>>>>>>>>>>
78091>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
78094>>>>>>>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
78095>>>>>>>>>>>
78095>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
78098>>>>>>>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
78099>>>>>>>>>>>
78099>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
78102>>>>>>>>>>>        Set pbDriverDefaultNullableText to bNULL
78103>>>>>>>>>>>
78103>>>>>>>>>>>    End_Procedure
78104>>>>>>>>>>>
78104>>>>>>>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
78106>>>>>>>>>>>        Boolean bOK bIsDaw
78106>>>>>>>>>>>        String sConnectionString
78106>>>>>>>>>>>        Handle hoErrorObj hoDriver hoIniFile
78106>>>>>>>>>>>        Integer iDriverID
78106>>>>>>>>>>>
78106>>>>>>>>>>>        Move False to bOK
78107>>>>>>>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
78108>>>>>>>>>>>
78108>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78109>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
78110>>>>>>>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
78111>>>>>>>>>>>        If (iDriverID = 0) Begin
78113>>>>>>>>>>>            Move hoErrorObj to Error_Object_Id
78114>>>>>>>>>>>            Function_Return False
78115>>>>>>>>>>>        End
78115>>>>>>>>>>>>
78115>>>>>>>>>>>
78115>>>>>>>>>>>        Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
78118>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
78119>>>>>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
78120>>>>>>>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
78121>>>>>>>>>>>        Send Destroy   of hoDriver
78122>>>>>>>>>>>
78122>>>>>>>>>>>        Function_Return bOK
78123>>>>>>>>>>>    End_Function
78124>>>>>>>>>>>
78124>>>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
78126>>>>>>>>>>>        tSQLConnection SQLConnection
78126>>>>>>>>>>>        tSQLConnection SQLConnection
78126>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78127>>>>>>>>>>>        Function_Return SQLConnection
78128>>>>>>>>>>>    End_Function
78129>>>>>>>>>>>
78129>>>>>>>>>>>    Procedure Set psConnectionID String sValue
78131>>>>>>>>>>>        tSQLConnection SQLConnection
78131>>>>>>>>>>>        tSQLConnection SQLConnection
78131>>>>>>>>>>>
78131>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78132>>>>>>>>>>>        If (SQLConnection.sConnectionID = "") Begin
78134>>>>>>>>>>>            Move sValue to SQLConnection.sConnectionID
78135>>>>>>>>>>>        End
78135>>>>>>>>>>>>
78135>>>>>>>>>>>
78135>>>>>>>>>>>        // Else we might want to change the current connection ID
78135>>>>>>>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
78138>>>>>>>>>>>            Move False to Err
78139>>>>>>>>>>>            Logout SQLConnection.sDriverID
78140>>>>>>>>>>>            // This will also make a login to the new server.
78140>>>>>>>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
78141>>>>>>>>>>>        End
78141>>>>>>>>>>>>
78141>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78142>>>>>>>>>>>    End_Procedure
78143>>>>>>>>>>>
78143>>>>>>>>>>>    Function psConnectionID Returns String
78145>>>>>>>>>>>        tSQLConnection SQLConnection
78145>>>>>>>>>>>        tSQLConnection SQLConnection
78145>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78146>>>>>>>>>>>        Function_Return SQLConnection.sConnectionID
78147>>>>>>>>>>>    End_Function
78148>>>>>>>>>>>
78148>>>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
78148>>>>>>>>>>>    //       the psDriverID *must* be the first property that is changed!
78148>>>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
78148>>>>>>>>>>>    //       for a connection string has the wrong format for that driver.
78148>>>>>>>>>>>    Procedure Set psDriverID String sValue
78150>>>>>>>>>>>        tSQLConnection SQLConnection
78150>>>>>>>>>>>        tSQLConnection SQLConnection
78150>>>>>>>>>>>        Get pSQLConnection to SQLConnection
78151>>>>>>>>>>>        Move sValue        to SQLConnection.sDriverID
78152>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78153>>>>>>>>>>>        If (sValue <> DATAFLEX_ID) Begin
78155>>>>>>>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78156>>>>>>>>>>>        End
78156>>>>>>>>>>>>
78156>>>>>>>>>>>    End_Procedure
78157>>>>>>>>>>>
78157>>>>>>>>>>>    Function psDriverID Returns String
78159>>>>>>>>>>>        tSQLConnection SQLConnection
78159>>>>>>>>>>>        tSQLConnection SQLConnection
78159>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78160>>>>>>>>>>>        If (SQLConnection.sDriverID = "") Begin
78162>>>>>>>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
78163>>>>>>>>>>>        End
78163>>>>>>>>>>>>
78163>>>>>>>>>>>        Function_Return SQLConnection.sDriverID
78164>>>>>>>>>>>    End_Function
78165>>>>>>>>>>>
78165>>>>>>>>>>>    Procedure Set psConnectionString String sValue
78167>>>>>>>>>>>        tSQLConnection SQLConnection
78167>>>>>>>>>>>        tSQLConnection SQLConnection
78167>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78168>>>>>>>>>>>        Move sValue        to SQLConnection.sConnectionString
78169>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78170>>>>>>>>>>>    End_Procedure
78171>>>>>>>>>>>
78171>>>>>>>>>>>    Function psConnectionString Returns String
78173>>>>>>>>>>>        tSQLConnection SQLConnection
78173>>>>>>>>>>>        tSQLConnection SQLConnection
78173>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78174>>>>>>>>>>>        Function_Return SQLConnection.sConnectionString
78175>>>>>>>>>>>    End_Function
78176>>>>>>>>>>>
78176>>>>>>>>>>>    Procedure Set psServer String sValue
78178>>>>>>>>>>>        tSQLConnection SQLConnection
78178>>>>>>>>>>>        tSQLConnection SQLConnection
78178>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78179>>>>>>>>>>>        Move sValue        to SQLConnection.sServer
78180>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78181>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78182>>>>>>>>>>>    End_Procedure
78183>>>>>>>>>>>
78183>>>>>>>>>>>    Function psServer Returns String
78185>>>>>>>>>>>        tSQLConnection SQLConnection
78185>>>>>>>>>>>        tSQLConnection SQLConnection
78185>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78186>>>>>>>>>>>        Function_Return SQLConnection.sServer
78187>>>>>>>>>>>    End_Function
78188>>>>>>>>>>>
78188>>>>>>>>>>>    Procedure Set psDatabase String sValue
78190>>>>>>>>>>>        tSQLConnection SQLConnection
78190>>>>>>>>>>>        tSQLConnection SQLConnection
78190>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78191>>>>>>>>>>>        Move sValue        to SQLConnection.sDatabase
78192>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78193>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78194>>>>>>>>>>>    End_Procedure
78195>>>>>>>>>>>
78195>>>>>>>>>>>    Function psDatabase Returns String
78197>>>>>>>>>>>        tSQLConnection SQLConnection
78197>>>>>>>>>>>        tSQLConnection SQLConnection
78197>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78198>>>>>>>>>>>        Function_Return SQLConnection.sDatabase
78199>>>>>>>>>>>    End_Function
78200>>>>>>>>>>>
78200>>>>>>>>>>>    Procedure Set psUserID String sValue
78202>>>>>>>>>>>        tSQLConnection SQLConnection
78202>>>>>>>>>>>        tSQLConnection SQLConnection
78202>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78203>>>>>>>>>>>        Move sValue        to SQLConnection.sUserID
78204>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78205>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78206>>>>>>>>>>>    End_Procedure
78207>>>>>>>>>>>
78207>>>>>>>>>>>    Function psUserID Returns String
78209>>>>>>>>>>>        tSQLConnection SQLConnection
78209>>>>>>>>>>>        tSQLConnection SQLConnection
78209>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78210>>>>>>>>>>>        Function_Return SQLConnection.sUserID
78211>>>>>>>>>>>    End_Function
78212>>>>>>>>>>>
78212>>>>>>>>>>>    // This is the uncrypted password
78212>>>>>>>>>>>    Procedure Set psPassword String sValue
78214>>>>>>>>>>>        tSQLConnection SQLConnection
78214>>>>>>>>>>>        tSQLConnection SQLConnection
78214>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78215>>>>>>>>>>>        Move sValue        to SQLConnection.sPassword
78216>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78217>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78218>>>>>>>>>>>    End_Procedure
78219>>>>>>>>>>>
78219>>>>>>>>>>>    Function psPassword Returns String
78221>>>>>>>>>>>        tSQLConnection SQLConnection
78221>>>>>>>>>>>        tSQLConnection SQLConnection
78221>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78222>>>>>>>>>>>        Function_Return SQLConnection.sPassword
78223>>>>>>>>>>>    End_Function
78224>>>>>>>>>>>
78224>>>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
78226>>>>>>>>>>>        tSQLConnection SQLConnection
78226>>>>>>>>>>>        tSQLConnection SQLConnection
78226>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78227>>>>>>>>>>>        Move bValue        to SQLConnection.bTrusted
78228>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78229>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78230>>>>>>>>>>>    End_Procedure
78231>>>>>>>>>>>
78231>>>>>>>>>>>    Function pbTrusted Returns Boolean
78233>>>>>>>>>>>        tSQLConnection SQLConnection
78233>>>>>>>>>>>        tSQLConnection SQLConnection
78233>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78234>>>>>>>>>>>        Function_Return SQLConnection.bTrusted
78235>>>>>>>>>>>    End_Function
78236>>>>>>>>>>>
78236>>>>>>>>>>>    // *** All of these properties are special to the Database Update Framework ***
78236>>>>>>>>>>>    //     Thus they are not propagated to the DAW classes and that is why
78236>>>>>>>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
78236>>>>>>>>>>>    //     the central pSQLConnection "hub".
78236>>>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
78238>>>>>>>>>>>        tSQLConnection SQLConnection
78238>>>>>>>>>>>        tSQLConnection SQLConnection
78238>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78239>>>>>>>>>>>        Move bValue to SQLConnection.bTrusted
78240>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78241>>>>>>>>>>>    End_Procedure
78242>>>>>>>>>>>
78242>>>>>>>>>>>    Function pbSilentLogin Returns Boolean
78244>>>>>>>>>>>        tSQLConnection SQLConnection
78244>>>>>>>>>>>        tSQLConnection SQLConnection
78244>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78245>>>>>>>>>>>        Function_Return SQLConnection.bSilentLogin
78246>>>>>>>>>>>    End_Function
78247>>>>>>>>>>>
78247>>>>>>>>>>>    Procedure Set piDbType Integer iValue
78249>>>>>>>>>>>        tSQLConnection SQLConnection
78249>>>>>>>>>>>        tSQLConnection SQLConnection
78249>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78250>>>>>>>>>>>        Move iValue to SQLConnection.iDbType
78251>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78252>>>>>>>>>>>    End_Procedure
78253>>>>>>>>>>>
78253>>>>>>>>>>>    Function piDbType Returns Integer
78255>>>>>>>>>>>        tSQLConnection SQLConnection
78255>>>>>>>>>>>        tSQLConnection SQLConnection
78255>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78256>>>>>>>>>>>        Function_Return SQLConnection.iDbType
78257>>>>>>>>>>>    End_Function
78258>>>>>>>>>>>
78258>>>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
78260>>>>>>>>>>>        tSQLConnection SQLConnection
78260>>>>>>>>>>>        tSQLConnection SQLConnection
78260>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78261>>>>>>>>>>>        Move sValue to SQLConnection.sBaseTableSpace
78262>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78263>>>>>>>>>>>    End_Procedure
78264>>>>>>>>>>>
78264>>>>>>>>>>>    Function psBaseTableSpace Returns String
78266>>>>>>>>>>>        tSQLConnection SQLConnection
78266>>>>>>>>>>>        tSQLConnection SQLConnection
78266>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78267>>>>>>>>>>>        Function_Return SQLConnection.sBaseTableSpace
78268>>>>>>>>>>>    End_Function
78269>>>>>>>>>>>
78269>>>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
78271>>>>>>>>>>>        tSQLConnection SQLConnection
78271>>>>>>>>>>>        tSQLConnection SQLConnection
78271>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78272>>>>>>>>>>>        Move sValue to SQLConnection.sIndexTableSpace
78273>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78274>>>>>>>>>>>    End_Procedure
78275>>>>>>>>>>>
78275>>>>>>>>>>>    Function psIndexTableSpace Returns String
78277>>>>>>>>>>>        tSQLConnection SQLConnection
78277>>>>>>>>>>>        tSQLConnection SQLConnection
78277>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78278>>>>>>>>>>>        Function_Return SQLConnection.sIndexTableSpace
78279>>>>>>>>>>>    End_Function
78280>>>>>>>>>>>
78280>>>>>>>>>>>    Procedure Set psLongTableSpace String sValue
78282>>>>>>>>>>>        tSQLConnection SQLConnection
78282>>>>>>>>>>>        tSQLConnection SQLConnection
78282>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78283>>>>>>>>>>>        Move sValue to SQLConnection.sLongTableSpace
78284>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78285>>>>>>>>>>>    End_Procedure
78286>>>>>>>>>>>
78286>>>>>>>>>>>    Function psLongTableSpace Returns String
78288>>>>>>>>>>>        tSQLConnection SQLConnection
78288>>>>>>>>>>>        tSQLConnection SQLConnection
78288>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78289>>>>>>>>>>>        Function_Return SQLConnection.sLongTableSpace
78290>>>>>>>>>>>    End_Function
78291>>>>>>>>>>>
78291>>>>>>>>>>>    Procedure Set psSchema String sValue
78293>>>>>>>>>>>        tSQLConnection SQLConnection
78293>>>>>>>>>>>        tSQLConnection SQLConnection
78293>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78294>>>>>>>>>>>        Move sValue to SQLConnection.sSchema
78295>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78296>>>>>>>>>>>    End_Procedure
78297>>>>>>>>>>>
78297>>>>>>>>>>>    Function psSchema Returns String
78299>>>>>>>>>>>        tSQLConnection SQLConnection
78299>>>>>>>>>>>        tSQLConnection SQLConnection
78299>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78300>>>>>>>>>>>        Function_Return SQLConnection.sSchema
78301>>>>>>>>>>>    End_Function
78302>>>>>>>>>>>
78302>>>>>>>>>>>    Procedure Set pbEnabled Boolean bValue
78304>>>>>>>>>>>        tSQLConnection SQLConnection
78304>>>>>>>>>>>        tSQLConnection SQLConnection
78304>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78305>>>>>>>>>>>        Move bValue to SQLConnection.bEnabled
78306>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78307>>>>>>>>>>>    End_Procedure
78308>>>>>>>>>>>
78308>>>>>>>>>>>    Function pbEnabled Returns Boolean
78310>>>>>>>>>>>        tSQLConnection SQLConnection
78310>>>>>>>>>>>        tSQLConnection SQLConnection
78310>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78311>>>>>>>>>>>        Function_Return SQLConnection.bEnabled
78312>>>>>>>>>>>    End_Function
78313>>>>>>>>>>>
78313>>>>>>>>>>>
78313>>>>>>>>>>>    // ************************************
78313>>>>>>>>>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
78315>>>>>>>>>>>        tSQLConnection SQLConnection
78315>>>>>>>>>>>        tSQLConnection SQLConnection
78315>>>>>>>>>>>
78315>>>>>>>>>>>        // If this object was created by the cDbUpdateHandler class we will
78315>>>>>>>>>>>        // deferr reading SQL connection values until later.
78315>>>>>>>>>>>        If (bReadDFConnSettings = True) Begin
78317>>>>>>>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
78317>>>>>>>>>>>            If (ghoConnection > 0) Begin
78319>>>>>>>>>>>                Get ReadcConnections to SQLConnection
78320>>>>>>>>>>>            End
78320>>>>>>>>>>>>
78320>>>>>>>>>>>
78320>>>>>>>>>>>            // In addition to the above; there might be other values set even if a cConnection
78320>>>>>>>>>>>            // object is used.
78320>>>>>>>>>>>            If (bReadSQLConnections = True) Begin
78322>>>>>>>>>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
78323>>>>>>>>>>>            End
78323>>>>>>>>>>>>
78323>>>>>>>>>>>        End
78323>>>>>>>>>>>>
78323>>>>>>>>>>>
78323>>>>>>>>>>>        Function_Return SQLConnection
78324>>>>>>>>>>>    End_Function
78325>>>>>>>>>>>
78325>>>>>>>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
78325>>>>>>>>>>>    Function ReadcConnections Returns tSQLConnection
78327>>>>>>>>>>>        tConnection Connection
78327>>>>>>>>>>>        tConnection Connection
78327>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78327>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78327>>>>>>>>>>>        Integer iRetval iDbType
78327>>>>>>>>>>>        Boolean bOK bConnected
78327>>>>>>>>>>>        String sConnectionID
78327>>>>>>>>>>>
78327>>>>>>>>>>>            tConnection[] Connections
78327>>>>>>>>>>>            tConnection[] Connections
78328>>>>>>>>>>>            // - If the DF 19 cConnection class has been used in the cApplication object
78328>>>>>>>>>>>            // - and there are multiple connection id's defined for the same driver. This is
78328>>>>>>>>>>>            //   because otherwise we can't possibly know which connection id to use... So
78328>>>>>>>>>>>            //   we then generate an error and abort the program...
78328>>>>>>>>>>>            Get IsSinglecConnection (&sConnectionID) to bOK
78329>>>>>>>>>>>            If (bOK = False) Begin
78331>>>>>>>>>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
78332>>>>>>>>>>>>
78332>>>>>>>>>>>                Abort
78333>>>>>>>>>>>>
78333>>>>>>>>>>>            End
78333>>>>>>>>>>>>
78333>>>>>>>>>>>            If (sConnectionID = "") Begin
78335>>>>>>>>>>>                Get ConnectionIDs of ghoConnection to Connections
78336>>>>>>>>>>>                If (SizeOfArray(Connections) > 0) Begin
78338>>>>>>>>>>>                    Move Connections[0].sId to sConnectionID
78339>>>>>>>>>>>                End
78339>>>>>>>>>>>>
78339>>>>>>>>>>>            End
78339>>>>>>>>>>>>
78339>>>>>>>>>>>
78339>>>>>>>>>>>            Move 0 to iRetval
78340>>>>>>>>>>>            // DAW DF19 connection info:
78340>>>>>>>>>>>            // We first check that the connection is OK:
78340>>>>>>>>>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
78341>>>>>>>>>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
78341>>>>>>>>>>>            If (iRetval = -1) Begin
78343>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78344>>>>>>>>>>>            End
78344>>>>>>>>>>>>
78344>>>>>>>>>>>
78344>>>>>>>>>>>            If (sConnectionID <> "") Begin
78346>>>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
78347>>>>>>>>>>>            End
78347>>>>>>>>>>>>
78347>>>>>>>>>>>            If (Connection.sId = "") Begin
78349>>>>>>>>>>>                Move True to SQLConnectionEmpty.bError
78350>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78351>>>>>>>>>>>            End
78351>>>>>>>>>>>>
78351>>>>>>>>>>>
78351>>>>>>>>>>>            // DUF connection info struct property:
78351>>>>>>>>>>>            Get Private.pSQLConnection                       to SQLConnection
78352>>>>>>>>>>>
78352>>>>>>>>>>>            Move Connection.sId to sConnectionID
78353>>>>>>>>>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
78354>>>>>>>>>>>
78354>>>>>>>>>>>            If (bConnected = False) Begin
78356>>>>>>>>>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
78357>>>>>>>>>>>                If (iRetval <> 0) Begin
78359>>>>>>>>>>>                    Send UserError CS_DUF_CannotLoginToServer
78360>>>>>>>>>>>                    Send Exit_Application
78361>>>>>>>>>>>                End
78361>>>>>>>>>>>>
78361>>>>>>>>>>>                Move True                                   to SQLConnection.bDAWConnection
78362>>>>>>>>>>>                // We need to get the DAW connection info again as it might have
78362>>>>>>>>>>>                // been changed in the DAW db login dialog.
78362>>>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
78363>>>>>>>>>>>            End
78363>>>>>>>>>>>>
78363>>>>>>>>>>>
78363>>>>>>>>>>>            Move True                                        to SQLConnection.bEnabled
78364>>>>>>>>>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
78365>>>>>>>>>>>
78365>>>>>>>>>>>            // Not used in DUF:
78365>>>>>>>>>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
78365>>>>>>>>>>>
78365>>>>>>>>>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
78366>>>>>>>>>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
78367>>>>>>>>>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
78368>>>>>>>>>>>            Move Connection.sId                              to SQLConnection.sConnectionID
78369>>>>>>>>>>>            Move Connection.sUID                             to SQLConnection.sUserID
78370>>>>>>>>>>>            Move Connection.sPWD                             to SQLConnection.sPassword
78371>>>>>>>>>>>
78371>>>>>>>>>>>            // Not used in DUF:
78371>>>>>>>>>>>            // Move Connection.sSection to SQLConnection.xxx
78371>>>>>>>>>>>
78371>>>>>>>>>>>            // The rest of the properties of the SQLConnection struct should have been
78371>>>>>>>>>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
78371>>>>>>>>>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
78373>>>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniServerKeyword + "=")       to SQLConnection.sServer
78374>>>>>>>>>>>            End
78374>>>>>>>>>>>>
78374>>>>>>>>>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
78376>>>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniDSNKeyword + "=")          to SQLConnection.sServer
78377>>>>>>>>>>>                If (SQLConnection.sServer = "") Begin
78379>>>>>>>>>>>                    Get ParseKeyWord Connection.sString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78380>>>>>>>>>>>                End
78380>>>>>>>>>>>>
78380>>>>>>>>>>>            End
78380>>>>>>>>>>>>
78380>>>>>>>>>>>
78380>>>>>>>>>>>            Get ParseKeyWord Connection.sString (CS_SQLIniDatabaseKeyword  + "=")        to SQLConnection.sDatabase
78381>>>>>>>>>>>
78381>>>>>>>>>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
78381>>>>>>>>>>>            // the value from the driver id:
78381>>>>>>>>>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
78382>>>>>>>>>>>            If (SQLConnection.iDbType = 0) Begin
78384>>>>>>>>>>>            // ...but in case it has been explicitly set in the object we use that value.
78384>>>>>>>>>>>            Get piDbType                                     to iDbType
78385>>>>>>>>>>>            End
78385>>>>>>>>>>>>
78385>>>>>>>>>>>            If (iDbType > 0 and SQLConnection.iDbType = 0) Begin
78387>>>>>>>>>>>                Move iDbType to SQLConnection.iDbType
78388>>>>>>>>>>>            End
78388>>>>>>>>>>>>
78388>>>>>>>>>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
78389>>>>>>>>>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
78390>>>>>>>>>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
78391>>>>>>>>>>>            Get psSchema                                     to SQLConnection.sSchema
78392>>>>>>>>>>>
78392>>>>>>>>>>>            // We finally set the struct property to the newly fetched values.
78392>>>>>>>>>>>            Set pSQLConnection to SQLConnection
78393>>>>>>>>>>>
78393>>>>>>>>>>>        Function_Return SQLConnection
78394>>>>>>>>>>>    End_Function
78395>>>>>>>>>>>
78395>>>>>>>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
78395>>>>>>>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
78395>>>>>>>>>>>    // connection id for a particular driver.
78395>>>>>>>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
78395>>>>>>>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
78395>>>>>>>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
78395>>>>>>>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
78395>>>>>>>>>>>    // connections of the DAW cConnect class.
78395>>>>>>>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
78397>>>>>>>>>>>        tConnection[] ConnIdArray
78397>>>>>>>>>>>        tConnection[] ConnIdArray
78398>>>>>>>>>>>        Integer iCount iSize iConnectionIDCounter
78398>>>>>>>>>>>        Boolean bEnabled bFound
78398>>>>>>>>>>>        String sConnectionID2 sDriverID sDriverConn
78398>>>>>>>>>>>
78398>>>>>>>>>>>        Move False to bFound
78399>>>>>>>>>>>        If (ghoConnection > 0) Begin
78401>>>>>>>>>>>
78401>>>>>>>>>>>            // The property of the cDbUpdateHandler container object
78401>>>>>>>>>>>            Get psDriverID to sDriverID
78402>>>>>>>>>>>
78402>>>>>>>>>>>            Move 0 to iConnectionIDCounter
78403>>>>>>>>>>>            // This is the the DAW cConnect array with all registered connection id's.
78403>>>>>>>>>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
78404>>>>>>>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
78405>>>>>>>>>>>            Decrement iSize
78406>>>>>>>>>>>            For iCount from 0 to iSize
78412>>>>>>>>>>>>
78412>>>>>>>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
78413>>>>>>>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
78414>>>>>>>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
78415>>>>>>>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
78415>>>>>>>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
78415>>>>>>>>>>>                If (sConnectionID = "") Begin
78417>>>>>>>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
78418>>>>>>>>>>>                End
78418>>>>>>>>>>>>
78418>>>>>>>>>>>                Else Begin
78419>>>>>>>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
78421>>>>>>>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
78422>>>>>>>>>>>                    End
78422>>>>>>>>>>>>
78422>>>>>>>>>>>                End
78422>>>>>>>>>>>>
78422>>>>>>>>>>>
78422>>>>>>>>>>>                If (bFound = True) Begin
78424>>>>>>>>>>>                    Increment iConnectionIDCounter
78425>>>>>>>>>>>                End
78425>>>>>>>>>>>>
78425>>>>>>>>>>>            Loop
78426>>>>>>>>>>>>
78426>>>>>>>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
78427>>>>>>>>>>>            If (bFound = True) Begin
78429>>>>>>>>>>>                Move sConnectionID2 to sConnectionID
78430>>>>>>>>>>>            End
78430>>>>>>>>>>>>
78430>>>>>>>>>>>        End
78430>>>>>>>>>>>>
78430>>>>>>>>>>>
78430>>>>>>>>>>>        // Special case; a cConnection object has been setup in the cApplication,
78430>>>>>>>>>>>        // but no DFConn.ini record has been created.
78430>>>>>>>>>>>        If (iSize = -1) Begin
78432>>>>>>>>>>>            Move True to bFound
78433>>>>>>>>>>>        End
78433>>>>>>>>>>>>
78433>>>>>>>>>>>
78433>>>>>>>>>>>        Function_Return bFound
78434>>>>>>>>>>>    End_Function
78435>>>>>>>>>>>
78435>>>>>>>>>>>    // Send on object creation to read the default connection string settings, and
78435>>>>>>>>>>>    // create a connection to the server.
78435>>>>>>>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
78437>>>>>>>>>>>        String sPath sFileName
78437>>>>>>>>>>>        Boolean bExists bActive
78437>>>>>>>>>>>        tSQLConnection[] SQLConnectionArray
78437>>>>>>>>>>>        tSQLConnection[] SQLConnectionArray
78438>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78438>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78438>>>>>>>>>>>        Handle hoIniFile
78438>>>>>>>>>>>        Integer iSize iCount iRetval
78438>>>>>>>>>>>
78438>>>>>>>>>>>        Get psIniFilePath to sPath
78439>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78440>>>>>>>>>>>        If (sPath = "") Begin
78442>>>>>>>>>>>            Get ApplicationPath of hoIniFile to sPath
78443>>>>>>>>>>>            Set psIniFilePath   of hoIniFile to sPath
78444>>>>>>>>>>>        End
78444>>>>>>>>>>>>
78444>>>>>>>>>>>        Get vFolderFormat sPath to sPath
78445>>>>>>>>>>>        Get psIniFileName to sFileName
78446>>>>>>>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
78447>>>>>>>>>>>
78447>>>>>>>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
78448>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
78449>>>>>>>>>>>        If (iSize = 0) Begin
78451>>>>>>>>>>>            // This may have been set by the "ReadcConnections" function,
78451>>>>>>>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
78451>>>>>>>>>>>            // in the cApplication object.
78451>>>>>>>>>>>            Get pSQLConnection to SQLConnection
78452>>>>>>>>>>>            If (SQLConnection.sConnectionID = "") Begin
78454>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78455>>>>>>>>>>>            End
78455>>>>>>>>>>>>
78455>>>>>>>>>>>            Move SQLConnection to SQLConnectionArray[0] 
78456>>>>>>>>>>>            Move 1 to iSize
78457>>>>>>>>>>>        End
78457>>>>>>>>>>>>
78457>>>>>>>>>>>
78457>>>>>>>>>>>        Move False to bActive
78458>>>>>>>>>>>        // The first connection should be the one that is active, but all connections might have been disabled.
78458>>>>>>>>>>>        Decrement iSize
78459>>>>>>>>>>>        For iCount from 0 to iSize
78465>>>>>>>>>>>>
78465>>>>>>>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
78466>>>>>>>>>>>            If (SQLConnection.bEnabled = True) Begin
78468>>>>>>>>>>>                Move True to bActive
78469>>>>>>>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
78470>>>>>>>>>>>            End
78470>>>>>>>>>>>>
78470>>>>>>>>>>>        Loop
78471>>>>>>>>>>>>
78471>>>>>>>>>>>
78471>>>>>>>>>>>        // In case all connections have been disabled, we're out of here.
78471>>>>>>>>>>>        If (bActive = False) Begin
78473>>>>>>>>>>>            Function_Return SQLConnectionEmpty
78474>>>>>>>>>>>        End
78474>>>>>>>>>>>>
78474>>>>>>>>>>>
78474>>>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin False
78475>>>>>>>>>>>
78475>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78476>>>>>>>>>>>        Get AutoSetConnectionID to iRetval
78477>>>>>>>>>>>
78477>>>>>>>>>>>        Function_Return SQLConnection
78478>>>>>>>>>>>    End_Function
78479>>>>>>>>>>>
78479>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
78481>>>>>>>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
78482>>>>>>>>>>>    End_Procedure
78483>>>>>>>>>>>
78483>>>>>>>>>>>    Function psIniFilePath Returns String
78485>>>>>>>>>>>        String sRetval
78485>>>>>>>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
78486>>>>>>>>>>>        Function_Return sRetval
78487>>>>>>>>>>>    End_Function
78488>>>>>>>>>>>
78488>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
78490>>>>>>>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
78491>>>>>>>>>>>    End_Procedure
78492>>>>>>>>>>>
78492>>>>>>>>>>>    Function psIniFileName Returns String
78494>>>>>>>>>>>        String sRetval
78494>>>>>>>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
78495>>>>>>>>>>>        Function_Return sRetval
78496>>>>>>>>>>>    End_Function
78497>>>>>>>>>>>
78497>>>>>>>>>>>    Procedure Set psIniSectionName String sSection
78499>>>>>>>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
78500>>>>>>>>>>>    End_Procedure
78501>>>>>>>>>>>
78501>>>>>>>>>>>    Function psIniSectionName Returns String
78503>>>>>>>>>>>        String sRetval
78503>>>>>>>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
78504>>>>>>>>>>>        Function_Return sRetval
78505>>>>>>>>>>>    End_Function
78506>>>>>>>>>>>
78506>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
78508>>>>>>>>>>>        Handle ho
78508>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78509>>>>>>>>>>>        Set IniFileValue of ho to sSection sValueName sValue
78510>>>>>>>>>>>    End_Procedure
78511>>>>>>>>>>>
78511>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
78513>>>>>>>>>>>        Handle ho
78513>>>>>>>>>>>        String sRetval
78513>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78514>>>>>>>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
78515>>>>>>>>>>>        Function_Return sRetval
78516>>>>>>>>>>>    End_Function
78517>>>>>>>>>>>
78517>>>>>>>>>>>    Function SectionExists String sSection Returns Boolean
78519>>>>>>>>>>>        Handle ho
78519>>>>>>>>>>>        Boolean bRetval
78519>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78520>>>>>>>>>>>        Get SectionExists of ho sSection to bRetval
78521>>>>>>>>>>>        Function_Return bRetval
78522>>>>>>>>>>>    End_Function
78523>>>>>>>>>>>
78523>>>>>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
78525>>>>>>>>>>>        Handle ho
78525>>>>>>>>>>>        Boolean bRetval
78525>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78526>>>>>>>>>>>        Get KeyExists of ho sSection sKey to bRetval
78527>>>>>>>>>>>        Function_Return bRetval
78528>>>>>>>>>>>    End_Function
78529>>>>>>>>>>>
78529>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
78531>>>>>>>>>>>        Handle ho
78531>>>>>>>>>>>        String sRetval
78531>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78532>>>>>>>>>>>        Get EncryptPassword of ho sPassword to sRetval
78533>>>>>>>>>>>        Function_Return sRetval
78534>>>>>>>>>>>    End_Function
78535>>>>>>>>>>>
78535>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
78537>>>>>>>>>>>        Handle ho
78537>>>>>>>>>>>        String sRetval
78537>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78538>>>>>>>>>>>        Get DecryptPassword of ho sPassword to sRetval
78539>>>>>>>>>>>        Function_Return sRetval
78540>>>>>>>>>>>    End_Function
78541>>>>>>>>>>>
78541>>>>>>>>>>>    // *** Main Connection Message ***
78541>>>>>>>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent Boolean bExitProgram
78543>>>>>>>>>>>        Handle hoDriver
78543>>>>>>>>>>>        String sConnectionString sError
78543>>>>>>>>>>>        Boolean bLoginSuccessful
78543>>>>>>>>>>>
78543>>>>>>>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
78544>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
78545>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
78546>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
78547>>>>>>>>>>>        If (bLoginSuccessful = False) Begin
78549>>>>>>>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)   
78550>>>>>>>>>>>>
78550>>>>>>>>>>>            If (bExitProgram = True) Begin
78552>>>>>>>>>>>                Send Exit_Application
78553>>>>>>>>>>>            End
78553>>>>>>>>>>>>
78553>>>>>>>>>>>        End
78553>>>>>>>>>>>>
78553>>>>>>>>>>>        Send Destroy of hoDriver
78554>>>>>>>>>>>    End_Procedure
78555>>>>>>>>>>>
78555>>>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
78557>>>>>>>>>>>        Integer iRetval
78557>>>>>>>>>>>        Handle hoCLI
78557>>>>>>>>>>>        String sDriverID
78557>>>>>>>>>>>
78557>>>>>>>>>>>        Get psDriverID to sDriverID
78558>>>>>>>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
78559>>>>>>>>>>>        If (hoCLI <> 0) Begin
78561>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78562>>>>>>>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
78563>>>>>>>>>>>            Send Destroy of hoCLI
78564>>>>>>>>>>>        End
78564>>>>>>>>>>>>
78564>>>>>>>>>>>
78564>>>>>>>>>>>        Function_Return iRetval
78565>>>>>>>>>>>    End_Function
78566>>>>>>>>>>>
78566>>>>>>>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
78568>>>>>>>>>>>        tSQLConnection SQLConnection
78568>>>>>>>>>>>        tSQLConnection SQLConnection
78568>>>>>>>>>>>
78568>>>>>>>>>>>        Set psDriverID to sDriverID
78569>>>>>>>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
78570>>>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted False
78571>>>>>>>>>>>    End_Procedure
78572>>>>>>>>>>>
78572>>>>>>>>>>>    // This is needed when e.g. the connection id we have specified in the program code
78572>>>>>>>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
78572>>>>>>>>>>>    // or the one in the DataFlex Bin folder.)
78572>>>>>>>>>>>    // We then need to delete the current one before creating a new one.
78572>>>>>>>>>>>    // This is because the parameters may differ between the program code and the
78572>>>>>>>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
78572>>>>>>>>>>>    // when one tries to create a Connection ID that already exists.
78572>>>>>>>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
78574>>>>>>>>>>>        Integer iResult iDriver iNumConn iConn
78574>>>>>>>>>>>        Handle hoCLI
78574>>>>>>>>>>>        String sID
78574>>>>>>>>>>>
78574>>>>>>>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
78576>>>>>>>>>>>            Procedure_Return
78577>>>>>>>>>>>        End
78577>>>>>>>>>>>>
78577>>>>>>>>>>>
78577>>>>>>>>>>>        Move 0 to iResult
78578>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78579>>>>>>>>>>>        If (hoCLI <> 0) Begin
78581>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78582>>>>>>>>>>>            Get DriverIndex sDriverID to iDriver
78583>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78586>>>>>>>>>>>            Decrement iNumConn
78587>>>>>>>>>>>            For iConn from 0 to iNumConn
78593>>>>>>>>>>>>
78593>>>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78596>>>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78598>>>>>>>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
78599>>>>>>>>>>>                End
78599>>>>>>>>>>>>
78599>>>>>>>>>>>            Loop
78600>>>>>>>>>>>>
78600>>>>>>>>>>>            Send Destroy of hoCLI
78601>>>>>>>>>>>        End
78601>>>>>>>>>>>>
78601>>>>>>>>>>>
78601>>>>>>>>>>>    End_Procedure
78602>>>>>>>>>>>
78602>>>>>>>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
78604>>>>>>>>>>>        Integer iResult iDriver iNumConn iConn
78604>>>>>>>>>>>        Handle hoCLI
78604>>>>>>>>>>>        String sID sConnectionString sVal sDatabase
78604>>>>>>>>>>>        tSQLConnection SQLConnection
78604>>>>>>>>>>>        tSQLConnection SQLConnection
78604>>>>>>>>>>>        Boolean bTrusted
78604>>>>>>>>>>>
78604>>>>>>>>>>>        Move 0 to iResult
78605>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78606>>>>>>>>>>>        If (hoCLI <> 0) Begin
78608>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78609>>>>>>>>>>>            Get DriverIndex sDriverID to iDriver
78610>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78613>>>>>>>>>>>            Decrement iNumConn
78614>>>>>>>>>>>            For iConn from 0 to iNumConn
78620>>>>>>>>>>>>
78620>>>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78623>>>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78625>>>>>>>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
78626>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
78629>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
78632>>>>>>>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
78633>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
78636>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
78637>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
78638>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
78639>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
78640>>>>>>>>>>>
78640>>>>>>>>>>>                    Case Begin
78640>>>>>>>>>>>                        Case (sDriverID = MSSQLDRV_ID)
78642>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
78643>>>>>>>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
78644>>>>>>>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
78645>>>>>>>>>>>                            Case Break
78646>>>>>>>>>>>                        Case (sDriverID = DB2_DRV_ID)
78649>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78650>>>>>>>>>>>                            Case Break
78651>>>>>>>>>>>                        Case (sDriverID = ODBC_DRV_ID)
78654>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78655>>>>>>>>>>>                            If (SQLConnection.sServer = "") Begin
78657>>>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78658>>>>>>>>>>>                            End
78658>>>>>>>>>>>>
78658>>>>>>>>>>>                            Case Break
78659>>>>>>>>>>>                        Case Else
78659>>>>>>>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
78660>>>>>>>>>>>>
78660>>>>>>>>>>>                            Case Break
78661>>>>>>>>>>>                    Case End
78661>>>>>>>>>>>                End
78661>>>>>>>>>>>>
78661>>>>>>>>>>>            Loop
78662>>>>>>>>>>>>
78662>>>>>>>>>>>            Send Destroy of hoCLI
78663>>>>>>>>>>>        End
78663>>>>>>>>>>>>
78663>>>>>>>>>>>
78663>>>>>>>>>>>        Function_Return SQLConnection
78664>>>>>>>>>>>    End_Function
78665>>>>>>>>>>>
78665>>>>>>>>>>>    Function DriverIndex String sDriverID Returns Integer
78667>>>>>>>>>>>        String  sCurrentDriver
78667>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
78667>>>>>>>>>>>
78667>>>>>>>>>>>        Move 0 to iDriver
78668>>>>>>>>>>>        Move 0 to iCount
78669>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
78672>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
78678>>>>>>>>>>>>
78678>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
78681>>>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
78683>>>>>>>>>>>                Function_Return iCount
78684>>>>>>>>>>>            End
78684>>>>>>>>>>>>
78684>>>>>>>>>>>        Loop
78685>>>>>>>>>>>>
78685>>>>>>>>>>>
78685>>>>>>>>>>>        // If driver not previously loaded; attempt to do so now.
78685>>>>>>>>>>>        If (iDriver = 0) Begin
78687>>>>>>>>>>>            Move 0 to LastErr
78688>>>>>>>>>>>            Load_Driver sDriverID
78689>>>>>>>>>>>            // If driver could not be loaded.
78689>>>>>>>>>>>            If (LastErr = DFERR_CANT_LOAD_DLL) Begin
78691>>>>>>>>>>>                Move -1 to iCount
78692>>>>>>>>>>>            End
78692>>>>>>>>>>>>
78692>>>>>>>>>>>        End
78692>>>>>>>>>>>>
78692>>>>>>>>>>>        Function_Return iCount
78693>>>>>>>>>>>    End_Function
78694>>>>>>>>>>>
78694>>>>>>>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
78694>>>>>>>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
78696>>>>>>>>>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
78696>>>>>>>>>>>        Boolean bTrusted bSilent
78696>>>>>>>>>>>        Integer iRetval
78696>>>>>>>>>>>
78696>>>>>>>>>>>        Move SQLConnection.sDriverID     to sDriverID
78697>>>>>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
78698>>>>>>>>>>>        Move SQLConnection.sServer       to sServer
78699>>>>>>>>>>>        Move SQLConnection.sDatabase     to sDatabase
78700>>>>>>>>>>>        Move SQLConnection.bTrusted      to bTrusted
78701>>>>>>>>>>>        Move SQLConnection.sUserID       to sUserID
78702>>>>>>>>>>>        Move SQLConnection.sPassword     to sPassword
78703>>>>>>>>>>>        Move SQLConnection.bSilentLogin  to bSilent
78704>>>>>>>>>>>
78704>>>>>>>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent False
78705>>>>>>>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
78705>>>>>>>>>>>        Get AutoSetConnectionID to iRetval
78706>>>>>>>>>>>    End_Procedure
78707>>>>>>>>>>>
78707>>>>>>>>>>>    // Called when the object is constructed.
78707>>>>>>>>>>>    // It will check the psDriverID for a ConnectionID and save it
78707>>>>>>>>>>>    // as psConnectionID property. It is later used whenever a login to
78707>>>>>>>>>>>    // the database is needed.
78707>>>>>>>>>>>    Function AutoSetConnectionID Returns Boolean
78709>>>>>>>>>>>        String sConnectionID sDriverID sConnectionString
78709>>>>>>>>>>>        Integer iDriver iRetval
78709>>>>>>>>>>>        Handle hoCLI
78709>>>>>>>>>>>        Boolean bOK bSilent
78709>>>>>>>>>>>
78709>>>>>>>>>>>        Get pbSilentLogin      to bSilent
78710>>>>>>>>>>>        Get psConnectionID     to sConnectionID
78711>>>>>>>>>>>        Get psConnectionString to sConnectionString
78712>>>>>>>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
78712>>>>>>>>>>>        Get psDriverID to sDriverID
78713>>>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78714>>>>>>>>>>>        If (bOK = False) Begin
78716>>>>>>>>>>>            Function_Return False
78717>>>>>>>>>>>        End
78717>>>>>>>>>>>>
78717>>>>>>>>>>>
78717>>>>>>>>>>>        Get DriverIndex sDriverID          to iDriver
78718>>>>>>>>>>>        // If driver not loaded; load it.
78718>>>>>>>>>>>        If (iDriver = 0) Begin
78720>>>>>>>>>>>            Load_Driver sDriverID
78721>>>>>>>>>>>            Get DriverIndex sDriverID      to iDriver
78722>>>>>>>>>>>        End
78722>>>>>>>>>>>>
78722>>>>>>>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
78722>>>>>>>>>>>        If (iDriver = 0) Begin
78724>>>>>>>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
78725>>>>>>>>>>>>
78725>>>>>>>>>>>            Function_Return False
78726>>>>>>>>>>>        End           
78726>>>>>>>>>>>>
78726>>>>>>>>>>>            Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to True
78729>>>>>>>>>>>        
78729>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78730>>>>>>>>>>>        Set psDriverID of hoCLI            to sDriverID
78731>>>>>>>>>>>        // Delete the connection first; in case it exists
78731>>>>>>>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
78732>>>>>>>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval 
78733>>>>>>>>>>>        Send Destroy of hoCLI
78734>>>>>>>>>>>
78734>>>>>>>>>>>        Function_Return (iRetval = 0)
78735>>>>>>>>>>>    End_Function
78736>>>>>>>>>>>
78736>>>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
78738>>>>>>>>>>>        Boolean bOK
78738>>>>>>>>>>>
78738>>>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
78739>>>>>>>>>>>
78739>>>>>>>>>>>        If (bOK = False) Begin
78741>>>>>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
78742>>>>>>>>>>>>
78742>>>>>>>>>>>            Function_Return False
78743>>>>>>>>>>>        End
78743>>>>>>>>>>>>
78743>>>>>>>>>>>
78743>>>>>>>>>>>        Function_Return True
78744>>>>>>>>>>>    End_Function
78745>>>>>>>>>>>
78745>>>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
78747>>>>>>>>>>>        Boolean bOK
78747>>>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
78748>>>>>>>>>>>        Function_Return bOK
78749>>>>>>>>>>>    End_Function
78750>>>>>>>>>>>
78750>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
78752>>>>>>>>>>>        Handle hoIniFile
78752>>>>>>>>>>>        String sConnect
78752>>>>>>>>>>>
78752>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78753>>>>>>>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
78754>>>>>>>>>>>
78754>>>>>>>>>>>        Function_Return sConnect
78755>>>>>>>>>>>    End_Function
78756>>>>>>>>>>>
78756>>>>>>>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
78756>>>>>>>>>>>    // Pass a complete driver connection string
78756>>>>>>>>>>>    // Returns the following as a struct:
78756>>>>>>>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
78756>>>>>>>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
78756>>>>>>>>>>>    //
78756>>>>>>>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
78758>>>>>>>>>>>        tSQLConnection SQLConnection
78758>>>>>>>>>>>        tSQLConnection SQLConnection
78758>>>>>>>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
78758>>>>>>>>>>>        Boolean bTrusted bSilent bOK
78758>>>>>>>>>>>        Integer iPos
78758>>>>>>>>>>>
78758>>>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78759>>>>>>>>>>>        If (bOK = False) Begin
78761>>>>>>>>>>>            Function_Return SQLConnection
78762>>>>>>>>>>>        End
78762>>>>>>>>>>>>
78762>>>>>>>>>>>
78762>>>>>>>>>>>        Move False to bTrusted
78763>>>>>>>>>>>        Move False to bSilent
78764>>>>>>>>>>>
78764>>>>>>>>>>>        Case Begin
78764>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
78766>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
78767>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
78768>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78769>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78770>>>>>>>>>>>                If (bTrusted = False) Begin
78772>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78773>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78774>>>>>>>>>>>                End
78774>>>>>>>>>>>>
78774>>>>>>>>>>>                Case Break
78775>>>>>>>>>>>
78775>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
78778>>>>>>>>>>>                If (uppercase(sConnectionString) contains ("." + CS_SQLIniDSNKeyword)) Begin
78780>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword + "=")  to sServer
78781>>>>>>>>>>>                End
78781>>>>>>>>>>>>
78781>>>>>>>>>>>                Else Begin
78782>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78783>>>>>>>>>>>                End
78783>>>>>>>>>>>>
78783>>>>>>>>>>>
78783>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78784>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78785>>>>>>>>>>>                If (bTrusted = False) Begin
78787>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78788>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78789>>>>>>>>>>>                End
78789>>>>>>>>>>>>
78789>>>>>>>>>>>                Case Break
78790>>>>>>>>>>>
78790>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
78793>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78794>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
78795>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
78796>>>>>>>>>>>                Case Break
78797>>>>>>>>>>>
78797>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
78800>>>>>>>>>>>                Break
78801>>>>>>>>>>>        Case End
78801>>>>>>>>>>>
78801>>>>>>>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
78802>>>>>>>>>>>
78802>>>>>>>>>>>        // bSilent?
78802>>>>>>>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
78803>>>>>>>>>>>        If (iPos = 0) Begin
78805>>>>>>>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
78806>>>>>>>>>>>        End
78806>>>>>>>>>>>>
78806>>>>>>>>>>>        If (iPos = 0) Begin
78808>>>>>>>>>>>            Move "0"                                                            to sValue
78809>>>>>>>>>>>        End
78809>>>>>>>>>>>>
78809>>>>>>>>>>>        Else Begin
78810>>>>>>>>>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
78811>>>>>>>>>>>        End
78811>>>>>>>>>>>>
78811>>>>>>>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
78812>>>>>>>>>>>
78812>>>>>>>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
78813>>>>>>>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
78814>>>>>>>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
78815>>>>>>>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
78816>>>>>>>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
78817>>>>>>>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
78818>>>>>>>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
78819>>>>>>>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
78820>>>>>>>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
78821>>>>>>>>>>>
78821>>>>>>>>>>>        Function_Return SQLConnection
78822>>>>>>>>>>>    End_Function
78823>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
78823>>>>>>>>>>>>
78823>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
78825>>>>>>>>>>>>    Integer iStart iEnd
78825>>>>>>>>>>>>    String sRetval
78825>>>>>>>>>>>>
78825>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
78826>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
78827>>>>>>>>>>>>    If (iStart = 0) Begin
78829>>>>>>>>>>>>        Function_Return ""
78830>>>>>>>>>>>>    End
78830>>>>>>>>>>>>>
78830>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
78831>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
78832>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
78834>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78835>>>>>>>>>>>>    End
78835>>>>>>>>>>>>>
78835>>>>>>>>>>>>    Else Begin
78836>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
78837>>>>>>>>>>>>    End
78837>>>>>>>>>>>>>
78837>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
78839>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78840>>>>>>>>>>>>        Decrement iEnd
78841>>>>>>>>>>>>    End
78841>>>>>>>>>>>>>
78841>>>>>>>>>>>>    If (iEnd <> 0) Begin
78843>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
78844>>>>>>>>>>>>    End
78844>>>>>>>>>>>>>
78844>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
78845>>>>>>>>>>>>
78845>>>>>>>>>>>>    Function_Return (Trim(sRetval))
78846>>>>>>>>>>>>End_Function
78847>>>>>>>>>>>>
78847>>>>>>>>>>>>
78847>>>>>>>>>>>
78847>>>>>>>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
78847>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
78849>>>>>>>>>>>        Handle ho
78849>>>>>>>>>>>        Integer iIndex
78849>>>>>>>>>>>        Boolean bRetval bOK
78849>>>>>>>>>>>        tSQLConnection SQLConnection
78849>>>>>>>>>>>        tSQLConnection SQLConnection
78849>>>>>>>>>>>
78849>>>>>>>>>>>        Get pSQLConnection to SQLConnection
78850>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78851>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
78852>>>>>>>>>>>        If (iIndex = -1) Begin
78854>>>>>>>>>>>            Function_Return False
78855>>>>>>>>>>>        End
78855>>>>>>>>>>>>
78855>>>>>>>>>>>
78855>>>>>>>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
78856>>>>>>>>>>>        Send UpdateConnectionString SQLConnection
78857>>>>>>>>>>>        If (ghoConnection > 0) Begin
78859>>>>>>>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
78860>>>>>>>>>>>            If (iIndex <> -1) Begin
78862>>>>>>>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
78863>>>>>>>>>>>            End
78863>>>>>>>>>>>>
78863>>>>>>>>>>>        End
78863>>>>>>>>>>>>
78863>>>>>>>>>>>
78863>>>>>>>>>>>        Function_Return bRetval
78864>>>>>>>>>>>    End_Function
78865>>>>>>>>>>>
78865>>>>>>>>>>>    Procedure Set pbDFConnid Boolean bState
78867>>>>>>>>>>>        Set pbDFConnid of (phoSQLConnectionIniFile(Self)) to bState
78868>>>>>>>>>>>    End_Procedure
78869>>>>>>>>>>>    
78869>>>>>>>>>>>    Function pbDFConnid Returns Boolean
78871>>>>>>>>>>>        Boolean bState
78871>>>>>>>>>>>        Get pbDFConnid of (phoSQLConnectionIniFile(Self)) to bState
78872>>>>>>>>>>>        Function_Return bState
78873>>>>>>>>>>>    End_Function
78874>>>>>>>>>>>
78874>>>>>>>>>>>End_Class
78875>>>>>>>>>Use vWin32fh.pkg
78875>>>>>>>>>Use Dfabout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\DfAbout.pkg)
78875>>>>>>>>>>>Use LanguageText.pkg
78875>>>>>>>>>>>Use Windows.pkg
78875>>>>>>>>>>>Use Dfclient.pkg
78875>>>>>>>>>>>Use DFbitmap.pkg
78875>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
78875>>>>>>>>>>>Use cRichEdit.pkg
78875>>>>>>>>>>>Use cTextEdit.pkg
78875>>>>>>>>>>>Use cRichEdit.pkg
78875>>>>>>>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files\DataFlex 24.0\Pkg\gFormatNumbers.pkg)
78875>>>>>>>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cFormatter.pkg)
78875>>>>>>>>>>>>>>>Use VDFBase.pkg
78875>>>>>>>>>>>>>>>
78875>>>>>>>>>>>>>>>Class cFormatter is an cObject
78876>>>>>>>>>>>>>>>    
78876>>>>>>>>>>>>>>>    Procedure Construct_object
78878>>>>>>>>>>>>>>>        Integer iCh
78878>>>>>>>>>>>>>>>        Forward Send construct_object
78880>>>>>>>>>>>>>>>        Property String  psCurrencySymbol
78881>>>>>>>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
78882>>>>>>>>>>>>>>>        
78882>>>>>>>>>>>>>>>        Property String  psLeft
78883>>>>>>>>>>>>>>>        Property String  psright
78884>>>>>>>>>>>>>>>        Property Integer pbThousandsSep
78885>>>>>>>>>>>>>>>        Property Integer piPoints
78886>>>>>>>>>>>>>>>        
78886>>>>>>>>>>>>>>>        Property String  psCurPosLeft
78887>>>>>>>>>>>>>>>        Property String  psCurPosright
78888>>>>>>>>>>>>>>>        Property Integer pbCurPosThousandsSep
78889>>>>>>>>>>>>>>>        Property Integer piCurPosPoints
78890>>>>>>>>>>>>>>>        
78890>>>>>>>>>>>>>>>        Property String  psCurNegLeft
78891>>>>>>>>>>>>>>>        Property String  psCurNegright
78892>>>>>>>>>>>>>>>        Property Integer pbCurNegThousandsSep
78893>>>>>>>>>>>>>>>        Property Integer piCurNegPoints
78894>>>>>>>>>>>>>>>        
78894>>>>>>>>>>>>>>>        Property String  psNumPosLeft
78895>>>>>>>>>>>>>>>        Property String  psNumPosright
78896>>>>>>>>>>>>>>>        Property Integer pbNumPosThousandsSep
78897>>>>>>>>>>>>>>>        Property Integer piNumPosPoints
78898>>>>>>>>>>>>>>>        
78898>>>>>>>>>>>>>>>        Property String  psNumNegLeft
78899>>>>>>>>>>>>>>>        Property String  psNumNegright
78900>>>>>>>>>>>>>>>        Property Integer pbNumNegThousandsSep
78901>>>>>>>>>>>>>>>        Property Integer piNumNegPoints
78902>>>>>>>>>>>>>>>        
78902>>>>>>>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
78903>>>>>>>>>>>>>>>        Send SetFormat  ",#.*"           False // numeric
78904>>>>>>>>>>>>>>>        
78904>>>>>>>>>>>>>>>    End_Procedure
78905>>>>>>>>>>>>>>>    
78905>>>>>>>>>>>>>>>    // internal
78905>>>>>>>>>>>>>>>    // parse passed format string and set temporary properties with result
78905>>>>>>>>>>>>>>>    Procedure ParseFormat String sFmt
78907>>>>>>>>>>>>>>>        
78907>>>>>>>>>>>>>>>        String sLeft sRight sDigit
78907>>>>>>>>>>>>>>>        Integer bSep iPos i iDigits
78907>>>>>>>>>>>>>>>        
78907>>>>>>>>>>>>>>>        // replace any literals. A "/" followed by anything.
78907>>>>>>>>>>>>>>>        // some literals are special. $ . , / #
78907>>>>>>>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
78908>>>>>>>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
78909>>>>>>>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
78910>>>>>>>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
78911>>>>>>>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
78912>>>>>>>>>>>>>>>        Move (Character(9)) to sDigit
78913>>>>>>>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
78914>>>>>>>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
78915>>>>>>>>>>>>>>>        
78915>>>>>>>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
78916>>>>>>>>>>>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
78919>>>>>>>>>>>>>>>        
78919>>>>>>>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
78920>>>>>>>>>>>>>>>        
78920>>>>>>>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
78921>>>>>>>>>>>>>>>        
78921>>>>>>>>>>>>>>>        // Move all the special literals back into place before parsing
78921>>>>>>>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
78922>>>>>>>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
78923>>>>>>>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
78924>>>>>>>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
78925>>>>>>>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
78926>>>>>>>>>>>>>>>        
78926>>>>>>>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
78928>>>>>>>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
78929>>>>>>>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
78931>>>>>>>>>>>>>>>                Move -2 to iDigits
78932>>>>>>>>>>>>>>>                Increment i
78933>>>>>>>>>>>>>>>            End
78933>>>>>>>>>>>>>>>>
78933>>>>>>>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
78937>>>>>>>>>>>>>>>                Increment i
78938>>>>>>>>>>>>>>>            Loop
78939>>>>>>>>>>>>>>>>
78939>>>>>>>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
78940>>>>>>>>>>>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
78943>>>>>>>>>>>>>>>            //
78943>>>>>>>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
78944>>>>>>>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
78948>>>>>>>>>>>>>>>                Increment i
78949>>>>>>>>>>>>>>>            Loop
78950>>>>>>>>>>>>>>>>
78950>>>>>>>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
78951>>>>>>>>>>>>>>>        End
78951>>>>>>>>>>>>>>>>
78951>>>>>>>>>>>>>>>        Else Begin                             // we have no decinal
78952>>>>>>>>>>>>>>>            Move 0 to iDigits                  // so points is none
78953>>>>>>>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
78954>>>>>>>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
78956>>>>>>>>>>>>>>>                Move sFmt to sLeft
78957>>>>>>>>>>>>>>>                Move ""   to sRight
78958>>>>>>>>>>>>>>>            End
78958>>>>>>>>>>>>>>>>
78958>>>>>>>>>>>>>>>            Else Begin
78959>>>>>>>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
78960>>>>>>>>>>>>>>>                Move 1 to i
78961>>>>>>>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
78965>>>>>>>>>>>>>>>                    Increment i
78966>>>>>>>>>>>>>>>                Loop
78967>>>>>>>>>>>>>>>>
78967>>>>>>>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
78968>>>>>>>>>>>>>>>            End
78968>>>>>>>>>>>>>>>>
78968>>>>>>>>>>>>>>>        End
78968>>>>>>>>>>>>>>>>
78968>>>>>>>>>>>>>>>        // set temporary format properties and exit
78968>>>>>>>>>>>>>>>        Set pbThousandsSep to bSep
78969>>>>>>>>>>>>>>>        Set psLeft         to sLeft
78970>>>>>>>>>>>>>>>        Set psRight        to sRight
78971>>>>>>>>>>>>>>>        Set piPoints       to iDigits
78972>>>>>>>>>>>>>>>    End_Procedure
78973>>>>>>>>>>>>>>>    
78973>>>>>>>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
78973>>>>>>>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
78973>>>>>>>>>>>>>>>    //
78973>>>>>>>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
78973>>>>>>>>>>>>>>>    Procedure SetFormat String sFmt Integer bCurrency
78975>>>>>>>>>>>>>>>        String sPos sNeg
78975>>>>>>>>>>>>>>>        Integer iPos
78975>>>>>>>>>>>>>>>        
78975>>>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
78976>>>>>>>>>>>>>>>        If iPos Begin
78978>>>>>>>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
78979>>>>>>>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
78980>>>>>>>>>>>>>>>        End
78980>>>>>>>>>>>>>>>>
78980>>>>>>>>>>>>>>>        Else Begin
78981>>>>>>>>>>>>>>>            Move sFmt         to sPos
78982>>>>>>>>>>>>>>>            Move ("-" + sFmt) to sNeg
78983>>>>>>>>>>>>>>>        End
78983>>>>>>>>>>>>>>>>
78983>>>>>>>>>>>>>>>        Send ParseFormat sPos
78984>>>>>>>>>>>>>>>        If bCurrency Begin
78986>>>>>>>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
78987>>>>>>>>>>>>>>>            Set psCurPosLeft         to (psLeft(Self))
78988>>>>>>>>>>>>>>>            Set psCurPosRight        to (psRight(Self))
78989>>>>>>>>>>>>>>>            Set piCurPosPoints       to (piPoints(Self))
78990>>>>>>>>>>>>>>>        End
78990>>>>>>>>>>>>>>>>
78990>>>>>>>>>>>>>>>        Else Begin
78991>>>>>>>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
78992>>>>>>>>>>>>>>>            Set psNumPosLeft         to (psLeft(Self))
78993>>>>>>>>>>>>>>>            Set psNumPosRight        to (psRight(Self))
78994>>>>>>>>>>>>>>>            Set piNumPosPoints       to (piPoints(Self))
78995>>>>>>>>>>>>>>>        End
78995>>>>>>>>>>>>>>>>
78995>>>>>>>>>>>>>>>        
78995>>>>>>>>>>>>>>>        Send ParseFormat sNeg
78996>>>>>>>>>>>>>>>        If bCurrency Begin
78998>>>>>>>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
78999>>>>>>>>>>>>>>>            Set psCurNegLeft         to (psLeft(Self))
79000>>>>>>>>>>>>>>>            Set psCurNegRight        to (psRight(Self))
79001>>>>>>>>>>>>>>>            Set piCurNegPoints       to (piPoints(Self))
79002>>>>>>>>>>>>>>>        End
79002>>>>>>>>>>>>>>>>
79002>>>>>>>>>>>>>>>        Else Begin
79003>>>>>>>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
79004>>>>>>>>>>>>>>>            Set psNumNegLeft         to (psLeft(Self))
79005>>>>>>>>>>>>>>>            Set psNumNegRight        to (psRight(Self))
79006>>>>>>>>>>>>>>>            Set piNumNegPoints       to (piPoints(Self))
79007>>>>>>>>>>>>>>>        End
79007>>>>>>>>>>>>>>>>
79007>>>>>>>>>>>>>>>    End_Procedure
79008>>>>>>>>>>>>>>>    
79008>>>>>>>>>>>>>>>    // low level formatting. Pass parameters
79008>>>>>>>>>>>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
79010>>>>>>>>>>>>>>>        String  sLeft sRight sNumber sSep sDec
79010>>>>>>>>>>>>>>>        Integer iDec iLen iCh
79010>>>>>>>>>>>>>>>        
79010>>>>>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
79013>>>>>>>>>>>>>>>        Move (Character(iCh)) to sDec
79014>>>>>>>>>>>>>>>        
79014>>>>>>>>>>>>>>>        Move (abs(nNumber)) to sNumber
79015>>>>>>>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
79016>>>>>>>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
79017>>>>>>>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
79018>>>>>>>>>>>>>>>        // format for decimal separator
79018>>>>>>>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
79021>>>>>>>>>>>>>>>        
79021>>>>>>>>>>>>>>>        // format for thousand sep.
79021>>>>>>>>>>>>>>>        If bSep Begin
79023>>>>>>>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
79026>>>>>>>>>>>>>>>            Move (Character(iCh)) to sSep
79027>>>>>>>>>>>>>>>            Move (Length(sLeft)) to iLen
79028>>>>>>>>>>>>>>>            While (iLen>3)
79032>>>>>>>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
79033>>>>>>>>>>>>>>>                Move (iLen-3) to iLen
79034>>>>>>>>>>>>>>>            Loop
79035>>>>>>>>>>>>>>>>
79035>>>>>>>>>>>>>>>        End
79035>>>>>>>>>>>>>>>>
79035>>>>>>>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
79035>>>>>>>>>>>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
79038>>>>>>>>>>>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
79039>>>>>>>>>>>>>>>    End_Function
79040>>>>>>>>>>>>>>>    
79040>>>>>>>>>>>>>>>    // Public: Format for currency
79040>>>>>>>>>>>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
79042>>>>>>>>>>>>>>>        String  sLeft sRight
79042>>>>>>>>>>>>>>>        Integer bSep
79042>>>>>>>>>>>>>>>        If (nNumber<0) Begin
79044>>>>>>>>>>>>>>>            Get pbCurNegThousandsSep to bSep
79045>>>>>>>>>>>>>>>            Get psCurNegLeft         to sLeft
79046>>>>>>>>>>>>>>>            Get psCurNegRight        to sRight
79047>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
79050>>>>>>>>>>>>>>>        End
79050>>>>>>>>>>>>>>>>
79050>>>>>>>>>>>>>>>        Else Begin
79051>>>>>>>>>>>>>>>            Get pbCurPosThousandsSep to bSep
79052>>>>>>>>>>>>>>>            Get psCurPosLeft         to sLeft
79053>>>>>>>>>>>>>>>            Get psCurPosRight        to sRight
79054>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
79057>>>>>>>>>>>>>>>        End
79057>>>>>>>>>>>>>>>>
79057>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79058>>>>>>>>>>>>>>>    End_Function
79059>>>>>>>>>>>>>>>    
79059>>>>>>>>>>>>>>>    // Public: Format for numeric
79059>>>>>>>>>>>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
79061>>>>>>>>>>>>>>>        String  sLeft sRight
79061>>>>>>>>>>>>>>>        Integer bSep
79061>>>>>>>>>>>>>>>        If (nNumber<0) Begin
79063>>>>>>>>>>>>>>>            Get pbNumNegThousandsSep to bSep
79064>>>>>>>>>>>>>>>            Get psNumNegLeft         to sLeft
79065>>>>>>>>>>>>>>>            Get psNumNegRight        to sRight
79066>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
79069>>>>>>>>>>>>>>>        End
79069>>>>>>>>>>>>>>>>
79069>>>>>>>>>>>>>>>        Else Begin
79070>>>>>>>>>>>>>>>            Get pbNumPosThousandsSep to bSep
79071>>>>>>>>>>>>>>>            Get psNumPosLeft         to sLeft
79072>>>>>>>>>>>>>>>            Get psNumPosRight        to sRight
79073>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
79076>>>>>>>>>>>>>>>        End
79076>>>>>>>>>>>>>>>>
79076>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79077>>>>>>>>>>>>>>>    End_Function
79078>>>>>>>>>>>>>>>    
79078>>>>>>>>>>>>>>>    
79078>>>>>>>>>>>>>>>    // Public: Format passing format string
79078>>>>>>>>>>>>>>>    Function FormatVal Number nNumber String sFmt Returns String
79080>>>>>>>>>>>>>>>        Integer iPos bIsNeg
79080>>>>>>>>>>>>>>>        String  sLeft sRight
79080>>>>>>>>>>>>>>>        Integer iPoints bSep
79080>>>>>>>>>>>>>>>        Move (nNumber<0) to bIsNeg
79081>>>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
79082>>>>>>>>>>>>>>>        Case Begin
79082>>>>>>>>>>>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
79085>>>>>>>>>>>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
79089>>>>>>>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
79093>>>>>>>>>>>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
79095>>>>>>>>>>>>>>>        Case End
79095>>>>>>>>>>>>>>>        Send ParseFormat sFmt
79096>>>>>>>>>>>>>>>        Get pbThousandsSep to bSep
79097>>>>>>>>>>>>>>>        Get psLeft         to sLeft
79098>>>>>>>>>>>>>>>        Get psRight        to sRight
79099>>>>>>>>>>>>>>>        Get piPoints       to iPoints
79100>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79101>>>>>>>>>>>>>>>    End_Function
79102>>>>>>>>>>>>>>>    
79102>>>>>>>>>>>>>>>End_Class
79103>>>>>>>>>>>>>
79103>>>>>>>>>>>>>Global_Variable Handle ghoFormatter
79103>>>>>>>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
79104>>>>>>>>>>>>>
79104>>>>>>>>>>>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
79106>>>>>>>>>>>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
79107>>>>>>>>>>>>>End_Function
79108>>>>>>>>>>>>>
79108>>>>>>>>>>>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
79110>>>>>>>>>>>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
79111>>>>>>>>>>>>>End_Function
79112>>>>>>>>>>>>>
79112>>>>>>>>>>>>>Function FormatValue Global Number nNum String sFmt Returns String
79114>>>>>>>>>>>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
79115>>>>>>>>>>>>>End_Function
79116>>>>>>>>>>>>>
79116>>>>>>>>>>>>>Procedure SetCurrencyFormat Global String sFmt
79118>>>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt True
79119>>>>>>>>>>>>>End_Procedure
79120>>>>>>>>>>>>>
79120>>>>>>>>>>>>>Procedure SetNumberFormat Global String sFmt
79122>>>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt False
79123>>>>>>>>>>>>>End_Procedure
79124>>>>>>>>>>>>>
79124>>>>>>>>>>>>>
79124>>>>>>>>>>>Use tWinStructs.pkg
79124>>>>>>>>>>>
79124>>>>>>>>>>>Use cli.pkg
79124>>>>>>>>>>>Use DFBTRDRV.PKG
79124>>>>>>>>>>>Use MSSqldrv.pkg
79124>>>>>>>>>>>Use db2_drv.pkg
79124>>>>>>>>>>>Use odbc_drv.pkg
79124>>>>>>>>>>>Use seq_chnl.pkg
79124>>>>>>>>>>>
79124>>>>>>>>>>>Register_Function phoWorkspace Returns Handle
79124>>>>>>>>>>>Register_Function Help_filename Returns String
79124>>>>>>>>>>>Register_Function GetHelpFile Returns String
79124>>>>>>>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
79124>>>>>>>>>>>
79124>>>>>>>>>>>// *** Constant Declarations: ***
79124>>>>>>>>>>>//
79124>>>>>>>>>>>
79124>>>>>>>>>>>
79124>>>>>>>>>>>
79124>>>>>>>>>>>
79124>>>>>>>>>>>
79124>>>>>>>>>>>
79124>>>>>>>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
79124>>>>>>>>>>>
79124>>>>>>>>>>>
79124>>>>>>>>>>>
79124>>>>>>>>>>>
79124>>>>>>>>>>>
79124>>>>>>>>>>>
79124>>>>>>>>>>>
79124>>>>>>>>>>>
79124>>>>>>>>>>>
79124>>>>>>>>>>>// System icon menu constants. If the upper left hand
79124>>>>>>>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
79124>>>>>>>>>>>    Define SC_RESTORE  for |CI$F120
79124>>>>>>>>>>>    Define SC_MOVE     for |CI$F010
79124>>>>>>>>>>>    Define SC_SIZE     for |CI$F000
79124>>>>>>>>>>>    Define SC_MINIMIZE for |CI$F020
79124>>>>>>>>>>>    Define SC_MAXIMIZE for |CI$F030
79124>>>>>>>>>>>    Define SC_CLOSE    for |CI$F060
79124>>>>>>>>>>>    Define SC_KEYMENU  for |CI$F100
79124>>>>>>>>>>>    Define SC_NEXTWINDOW for |CI$F040
79124>>>>>>>>>>>    Define SC_PREVWINDOW for |CI$F050
79124>>>>>>>>>>>
79124>>>>>>>>>>>Define CS_SignProgram        for "signtool.exe"
79124>>>>>>>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
79124>>>>>>>>>>>Define CS_VerifyCredentials  for "verify"
79124>>>>>>>>>>>Define CS_VerifyFileParam    for "/a"
79124>>>>>>>>>>>Define CS_DefAuthVerPolicy   for "/pa"
79124>>>>>>>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
79124>>>>>>>>>>>
79124>>>>>>>>>>>// *** Struct Declarations: ***
79124>>>>>>>>>>>Struct AboutSHELLEXECUTEINFO
79124>>>>>>>>>>>    DWord   cbSize
79124>>>>>>>>>>>    Integer fMask
79124>>>>>>>>>>>    Handle  hwnd
79124>>>>>>>>>>>    Pointer lpVerb
79124>>>>>>>>>>>    Pointer lpFile
79124>>>>>>>>>>>    Pointer lpParameters
79124>>>>>>>>>>>    Pointer lpDirectory
79124>>>>>>>>>>>    Integer nShow
79124>>>>>>>>>>>    Integer iMissingAlignment1
79124>>>>>>>>>>>    Pointer hInstApp
79124>>>>>>>>>>>    Pointer lpIDList
79124>>>>>>>>>>>    Pointer lpClass
79124>>>>>>>>>>>    Handle  hkeyClass
79124>>>>>>>>>>>    DWord   dwHotKey
79124>>>>>>>>>>>    Integer iMissingAlignment2
79124>>>>>>>>>>>    Handle  hIconMonitor // Union
79124>>>>>>>>>>>    //Handle  hMonitor     // Union
79124>>>>>>>>>>>    Handle  hProcess
79124>>>>>>>>>>>End_Struct
79124>>>>>>>>>>>
79124>>>>>>>>>>>
79124>>>>>>>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
79124>>>>>>>>>>>//Type MEMORYSTATUS
79124>>>>>>>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
79124>>>>>>>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
79124>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
79124>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
79124>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
79124>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
79124>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
79124>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
79124>>>>>>>>>>>//End_Type
79124>>>>>>>>>>>
79124>>>>>>>>>>>// *** External Function calls: ***
79124>>>>>>>>>>>//
79124>>>>>>>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
79125>>>>>>>>>>>
79125>>>>>>>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
79126>>>>>>>>>>>
79126>>>>>>>>>>>// Do not call directly, use the wrapper function instead
79126>>>>>>>>>>>External_Function WNetGetUserW "WNetGetUserW" MPR.DLL ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
79127>>>>>>>>>>>
79127>>>>>>>>>>>    // Wrapper Function WNetGetUser
79127>>>>>>>>>>>    Function WNetGetUser Global ;        Pointer lpName ;        Pointer lpUser_Name ;        Pointer lpLength ;        Returns DWord
79129>>>>>>>>>>>
79129>>>>>>>>>>>        DWord   dwResult
79129>>>>>>>>>>>        UWide   uwName uwUserName
79129>>>>>>>>>>>        UWide   uwName uwUserName
79129>>>>>>>>>>>
79129>>>>>>>>>>>        Send StringToWide lpName (&uwName)
79130>>>>>>>>>>>
79130>>>>>>>>>>>        Send WideSetBuffer lpUser_Name lpLength (&uwUserName)
79131>>>>>>>>>>>
79131>>>>>>>>>>>        Move (WNetGetUserW (uwName.lpUText, uwUserName.lpUText, lpLength)) to dwResult
79132>>>>>>>>>>>
79132>>>>>>>>>>>        Send WideToString (&uwUserName) lpUser_Name
79133>>>>>>>>>>>
79133>>>>>>>>>>>        Function_Return dwResult
79134>>>>>>>>>>>    End_Function
79135>>>>>>>>>>>
79135>>>>>>>>>>>
79135>>>>>>>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
79136>>>>>>>>>>>
79136>>>>>>>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
79137>>>>>>>>>>>
79137>>>>>>>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
79138>>>>>>>>>>>
79138>>>>>>>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
79139>>>>>>>>>>>
79139>>>>>>>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
79140>>>>>>>>>>>
79140>>>>>>>>>>>// *** Global/Desktop Function Declarations: ***
79140>>>>>>>>>>>
79140>>>>>>>>>>>Function ComputerName Desktop Returns String
79142>>>>>>>>>>>    String sName
79142>>>>>>>>>>>    Get_Environment "COMPUTERNAME" to sName
79143>>>>>>>>>>>>
79143>>>>>>>>>>>    Function_Return sName
79144>>>>>>>>>>>End_Function
79145>>>>>>>>>>>
79145>>>>>>>>>>>Function Network_User_Name Desktop Returns String
79147>>>>>>>>>>>    WString wName
79147>>>>>>>>>>>    Integer iRetval iLength
79147>>>>>>>>>>>
79147>>>>>>>>>>>    Move 0 to iLength
79148>>>>>>>>>>>    Move (WNetGetUserW (0, 0, AddressOf (iLength))) to iRetval
79149>>>>>>>>>>>    Move (ZeroString(iLength)) to wName
79150>>>>>>>>>>>    Move (WNetGetUserW (0, AddressOf (wName), AddressOf (iLength))) to iRetval
79151>>>>>>>>>>>
79151>>>>>>>>>>>    If (iRetval = NO_ERROR) Begin
79153>>>>>>>>>>>        Function_Return (CString (wName))
79154>>>>>>>>>>>    End
79154>>>>>>>>>>>>
79154>>>>>>>>>>>
79154>>>>>>>>>>>    Function_Return "User Unknown"
79155>>>>>>>>>>>End_Function
79156>>>>>>>>>>>
79156>>>>>>>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
79158>>>>>>>>>>>    String sClient sDriver sClientDriver
79158>>>>>>>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
79158>>>>>>>>>>>    Handle hoMsqlDrv
79158>>>>>>>>>>>
79158>>>>>>>>>>>    Move 0 to iDriver
79159>>>>>>>>>>>    Move "" to sClient
79160>>>>>>>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
79163>>>>>>>>>>>    For iCount from 1 to iNumberOfDrivers
79169>>>>>>>>>>>>
79169>>>>>>>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
79172>>>>>>>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
79174>>>>>>>>>>>            Move iCount to iDriver
79175>>>>>>>>>>>            Move iNumberOfDrivers to iCount // We're done.
79176>>>>>>>>>>>        End
79176>>>>>>>>>>>>
79176>>>>>>>>>>>    Loop
79177>>>>>>>>>>>>
79177>>>>>>>>>>>
79177>>>>>>>>>>>    // This info is (at current) only available for the MS SQL driver:
79177>>>>>>>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
79179>>>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
79182>>>>>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
79183>>>>>>>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
79184>>>>>>>>>>>        Send Destroy of hoMsqlDrv
79185>>>>>>>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
79186>>>>>>>>>>>    End
79186>>>>>>>>>>>>
79186>>>>>>>>>>>
79186>>>>>>>>>>>    Function_Return sClient
79187>>>>>>>>>>>End_Function
79188>>>>>>>>>>>
79188>>>>>>>>>>>// *** Class Declarations: ***
79188>>>>>>>>>>>//
79188>>>>>>>>>>>Class cBitmapContainerDFLink is a BitmapContainer
79189>>>>>>>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
79191>>>>>>>>>>>        Send Mouse_Up iWindowNumber iPosition
79192>>>>>>>>>>>    End_Procedure
79193>>>>>>>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
79195>>>>>>>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
79197>>>>>>>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
79198>>>>>>>>>>>    End_Procedure
79199>>>>>>>>>>>End_Class
79200>>>>>>>>>>>
79200>>>>>>>>>>>Class cCopyEditorContentButton is a Button
79201>>>>>>>>>>>    Procedure Construct_Object
79203>>>>>>>>>>>        Forward Send Construct_Object
79205>>>>>>>>>>>        Property Handle phoEditorHandle
79206>>>>>>>>>>>        Set psToolTip to C_$DescCopy
79207>>>>>>>>>>>    End_Procedure
79208>>>>>>>>>>>
79208>>>>>>>>>>>    Procedure CopyToWindowsClipboard
79210>>>>>>>>>>>        Handle hoEditor
79210>>>>>>>>>>>        Boolean bCanCopy
79210>>>>>>>>>>>        Address aEditorAddress
79210>>>>>>>>>>>
79210>>>>>>>>>>>        Get phoEditorHandle to hoEditor
79211>>>>>>>>>>>        Send Select_All of hoEditor
79212>>>>>>>>>>>        Get CanCopy of hoEditor to bCanCopy
79213>>>>>>>>>>>        If (bCanCopy = True) Begin
79215>>>>>>>>>>>            Get paValue of hoEditor to aEditorAddress
79216>>>>>>>>>>>            Send Copy   of hoEditor
79217>>>>>>>>>>>            // Remove the selection after text is copied to the clipboard.
79217>>>>>>>>>>>            Send Beginning_of_Data of hoEditor
79218>>>>>>>>>>>            Send Info_Box C_$CopyToClipboard_Text
79219>>>>>>>>>>>        End
79219>>>>>>>>>>>>
79219>>>>>>>>>>>    End_Procedure
79220>>>>>>>>>>>End_Class
79221>>>>>>>>>>>
79221>>>>>>>>>>>Class SysinfoDisplay is a cTextEdit
79222>>>>>>>>>>>    Procedure Construct_Object
79224>>>>>>>>>>>        Forward Send Construct_Object
79226>>>>>>>>>>>
79226>>>>>>>>>>>        Set Size to 100 245
79227>>>>>>>>>>>        Set Location to 6 6
79228>>>>>>>>>>>        Set Border_Style to Border_None
79229>>>>>>>>>>>        Set Read_Only_State to True
79230>>>>>>>>>>>        Set pbWrap to True
79231>>>>>>>>>>>        Set peAnchors to anAll
79232>>>>>>>>>>>    End_Procedure
79233>>>>>>>>>>>
79233>>>>>>>>>>>    // Augmented class message to adjust certain text strings that are wrong...
79233>>>>>>>>>>>
79233>>>>>>>>>>>    Procedure AppendTextLn String sText
79235>>>>>>>>>>>        String sWorkspaceWSFile
79235>>>>>>>>>>>
79235>>>>>>>>>>>        // Only works for English:
79235>>>>>>>>>>>        If (ghoApplication > 0) Begin
79237>>>>>>>>>>>            If (sText contains "Workspace Name") Begin
79239>>>>>>>>>>>                Move "Workspace Config Filename:" to sText
79240>>>>>>>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
79241>>>>>>>>>>>                Move (sText * sWorkspaceWSFile) to sText
79242>>>>>>>>>>>            End
79242>>>>>>>>>>>>
79242>>>>>>>>>>>        End
79242>>>>>>>>>>>>
79242>>>>>>>>>>>        Send AppendText sText
79243>>>>>>>>>>>        Send AppendText (character(10))
79244>>>>>>>>>>>    End_Procedure
79245>>>>>>>>>>>
79245>>>>>>>>>>>    //    This method will show the name Of the current directory in the system
79245>>>>>>>>>>>    //    information box
79245>>>>>>>>>>>    Procedure Show_Current_Directory
79247>>>>>>>>>>>        String sDir
79247>>>>>>>>>>>
79247>>>>>>>>>>>        Get_Current_Directory To sDir
79248>>>>>>>>>>>
79248>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
79249>>>>>>>>>>>    End_Procedure
79250>>>>>>>>>>>
79250>>>>>>>>>>>    Procedure Show_Windows_Directory
79252>>>>>>>>>>>        String sWindir
79252>>>>>>>>>>>
79252>>>>>>>>>>>        Get_Windows_Directory To sWindir
79253>>>>>>>>>>>
79253>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
79254>>>>>>>>>>>    End_Procedure
79255>>>>>>>>>>>
79255>>>>>>>>>>>    Procedure Show_Current_User
79257>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
79258>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
79259>>>>>>>>>>>    End_Procedure
79260>>>>>>>>>>>
79260>>>>>>>>>>>    Procedure Show_Number_Format
79262>>>>>>>>>>>        Integer iFormat
79262>>>>>>>>>>>        String sFormatText
79262>>>>>>>>>>>
79262>>>>>>>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
79265>>>>>>>>>>>        Move (Character (iFormat)) To sFormatText
79266>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
79267>>>>>>>>>>>
79267>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
79270>>>>>>>>>>>        Move (Character (iFormat)) to sFormatText
79271>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
79272>>>>>>>>>>>    End_Procedure
79273>>>>>>>>>>>
79273>>>>>>>>>>>    Procedure Show_Filelist_Name
79275>>>>>>>>>>>        String sFilename
79275>>>>>>>>>>>
79275>>>>>>>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
79278>>>>>>>>>>>
79278>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
79279>>>>>>>>>>>    End_Procedure
79280>>>>>>>>>>>
79280>>>>>>>>>>>    Procedure Show_Lock_Delay
79282>>>>>>>>>>>        Integer iLockdelay
79282>>>>>>>>>>>
79282>>>>>>>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
79285>>>>>>>>>>>
79285>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
79286>>>>>>>>>>>    End_Procedure
79287>>>>>>>>>>>
79287>>>>>>>>>>>    Procedure Show_Lock_Timeout
79289>>>>>>>>>>>        Integer iLockTimeout
79289>>>>>>>>>>>
79289>>>>>>>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
79292>>>>>>>>>>>
79292>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
79293>>>>>>>>>>>    End_Procedure
79294>>>>>>>>>>>
79294>>>>>>>>>>>    Procedure Show_Screen_Size
79296>>>>>>>>>>>        Integer iYscreensize iXscreensize
79296>>>>>>>>>>>
79296>>>>>>>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
79297>>>>>>>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
79298>>>>>>>>>>>
79298>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
79299>>>>>>>>>>>    End_Procedure
79300>>>>>>>>>>>
79300>>>>>>>>>>>    Procedure Show_Page_Size
79302>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
79303>>>>>>>>>>>    End_procedure
79304>>>>>>>>>>>
79304>>>>>>>>>>>    Procedure Show_Date
79306>>>>>>>>>>>        Date dToday
79306>>>>>>>>>>>
79306>>>>>>>>>>>        Move (CurrentDateTime()) to dToday
79307>>>>>>>>>>>
79307>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
79308>>>>>>>>>>>    End_procedure
79309>>>>>>>>>>>
79309>>>>>>>>>>>    Procedure Show_Date_Format
79311>>>>>>>>>>>        Integer iDateFormat
79311>>>>>>>>>>>        String sDateFormat
79311>>>>>>>>>>>
79311>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
79314>>>>>>>>>>>        Case Begin
79314>>>>>>>>>>>            Case (iDateFormat = DF_DATE_USA)
79316>>>>>>>>>>>                Move C_$USA To sDateFormat
79317>>>>>>>>>>>                Case Break
79318>>>>>>>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
79321>>>>>>>>>>>                Move C_$European To sDateFormat
79322>>>>>>>>>>>                Case Break
79323>>>>>>>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
79326>>>>>>>>>>>                Move C_$Military To sDateFormat
79327>>>>>>>>>>>                Case Break
79328>>>>>>>>>>>            Case Else
79328>>>>>>>>>>>                Move C_$UnknownDateType To sDateFormat
79329>>>>>>>>>>>                Case Break
79330>>>>>>>>>>>        Case End
79330>>>>>>>>>>>
79330>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
79331>>>>>>>>>>>    End_Procedure
79332>>>>>>>>>>>
79332>>>>>>>>>>>    // 2013-08-14 NGS
79332>>>>>>>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
79332>>>>>>>>>>>    Procedure Show_Systemresources
79334>>>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
79334>>>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
79334>>>>>>>>>>>        Integer iRetval
79334>>>>>>>>>>>        Number nValue
79334>>>>>>>>>>>        String sValue
79334>>>>>>>>>>>
79334>>>>>>>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
79335>>>>>>>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
79336>>>>>>>>>>>        If (iRetval = 0) Begin
79338>>>>>>>>>>>            Move (ShowLastError ()) to iRetval
79339>>>>>>>>>>>            Procedure_Return
79340>>>>>>>>>>>        End
79340>>>>>>>>>>>>
79340>>>>>>>>>>>
79340>>>>>>>>>>>        Send AppendTextLn ""
79341>>>>>>>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
79342>>>>>>>>>>>
79342>>>>>>>>>>>        // Show memory in Gigabytes:
79342>>>>>>>>>>>        Move (nValue/1024/1024/1024) to nValue
79343>>>>>>>>>>>        Move (Round(nValue)) to nValue
79344>>>>>>>>>>>        Get FormatNumber nValue 2 to sValue
79345>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
79346>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
79347>>>>>>>>>>>
79347>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
79347>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
79348>>>>>>>>>>>        Move (Round(nValue)) to nValue
79349>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79350>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
79351>>>>>>>>>>>
79351>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
79351>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
79352>>>>>>>>>>>        Move (Round(nValue)) to nValue
79353>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79354>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
79355>>>>>>>>>>>
79355>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
79355>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
79356>>>>>>>>>>>        Move (Round(nValue)) to nValue
79357>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79358>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
79359>>>>>>>>>>>
79359>>>>>>>>>>>        // Add an empty row after the memory information:
79359>>>>>>>>>>>        Send AppendTextLn ""
79360>>>>>>>>>>>    End_Procedure
79361>>>>>>>>>>>
79361>>>>>>>>>>>    Procedure Show_Registration
79363>>>>>>>>>>>        String sRegName
79363>>>>>>>>>>>        Integer iSN iUsersMax iUserCount
79363>>>>>>>>>>>
79363>>>>>>>>>>>        Registration sRegName iSN
79364>>>>>>>>>>>>
79364>>>>>>>>>>>        Get_Licensed_Max_Users to iUsersMax
79365>>>>>>>>>>>        Get_Current_User_Count to iUserCount
79366>>>>>>>>>>>
79366>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
79367>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
79368>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
79369>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
79370>>>>>>>>>>>    End_Procedure
79371>>>>>>>>>>>
79371>>>>>>>>>>>    //****************************************************************************
79371>>>>>>>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
79371>>>>>>>>>>>    // To the workspace object passing the an object and message To send back
79371>>>>>>>>>>>    // To this object. It is expected that the workspace object will send this
79371>>>>>>>>>>>    // message for every line Of information it wants displayed (passing the
79371>>>>>>>>>>>    // information To be displayed
79371>>>>>>>>>>>    //****************************************************************************
79371>>>>>>>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
79371>>>>>>>>>>>
79371>>>>>>>>>>>    Procedure Show_ServicePack
79373>>>>>>>>>>>        String sKey sVersion sDataFlex
79373>>>>>>>>>>>        Handle hoRegistry
79373>>>>>>>>>>>        Boolean bExists bOpened
79373>>>>>>>>>>>
79373>>>>>>>>>>>        Move "DataFlex"        to sDataFlex
79374>>>>>>>>>>>
79374>>>>>>>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
79375>>>>>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
79376>>>>>>>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
79377>>>>>>>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
79378>>>>>>>>>>>
79378>>>>>>>>>>>        If (bExists) Begin
79380>>>>>>>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79381>>>>>>>>>>>        End
79381>>>>>>>>>>>>
79381>>>>>>>>>>>        Else Begin
79382>>>>>>>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79383>>>>>>>>>>>        End
79383>>>>>>>>>>>>
79383>>>>>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
79384>>>>>>>>>>>        If (bExists) Begin
79386>>>>>>>>>>>            Get OpenKey of hoRegistry sKey to bOpened
79387>>>>>>>>>>>            If (bOpened) Begin
79389>>>>>>>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
79390>>>>>>>>>>>                If (bExists) Begin
79392>>>>>>>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
79393>>>>>>>>>>>                End
79393>>>>>>>>>>>>
79393>>>>>>>>>>>                Send CloseKey of hoRegistry
79394>>>>>>>>>>>            End
79394>>>>>>>>>>>>
79394>>>>>>>>>>>        End
79394>>>>>>>>>>>>
79394>>>>>>>>>>>        Send Destroy of hoRegistry
79395>>>>>>>>>>>
79395>>>>>>>>>>>        If (sVersion <> "") Begin
79397>>>>>>>>>>>           Send AppendTextLn sVersion
79398>>>>>>>>>>>           Send AppendTextLn ""
79399>>>>>>>>>>>        End
79399>>>>>>>>>>>>
79399>>>>>>>>>>>    End_Procedure
79400>>>>>>>>>>>
79400>>>>>>>>>>>    Procedure Show_WorkspaceInformation
79402>>>>>>>>>>>        Integer hoWorkspace
79402>>>>>>>>>>>
79402>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79404>>>>>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
79405>>>>>>>>>>>            If (hoWorkspace <> 0) Begin
79407>>>>>>>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
79408>>>>>>>>>>>            End
79408>>>>>>>>>>>>
79408>>>>>>>>>>>        End
79408>>>>>>>>>>>>
79408>>>>>>>>>>>    End_Procedure
79409>>>>>>>>>>>
79409>>>>>>>>>>>    //****************************************************************************
79409>>>>>>>>>>>    // If connection ids are used, we will send the message EnumerateConnections
79409>>>>>>>>>>>    // to the connection manager object passing the an object and message to send
79409>>>>>>>>>>>    // back to this object. It is expected that the connection manager object will
79409>>>>>>>>>>>    // send this message for every line Of information it wants displayed (passing
79409>>>>>>>>>>>    // the information To be displayed
79409>>>>>>>>>>>    //****************************************************************************
79409>>>>>>>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
79409>>>>>>>>>>>
79409>>>>>>>>>>>    Procedure Show_ConnectionIdInformation
79411>>>>>>>>>>>        If (ghoConnection > 0) Begin
79413>>>>>>>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
79414>>>>>>>>>>>            Send AppendTextLn ""
79415>>>>>>>>>>>        End
79415>>>>>>>>>>>>
79415>>>>>>>>>>>    End_Procedure
79416>>>>>>>>>>>
79416>>>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
79418>>>>>>>>>>>        Boolean bOK
79418>>>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
79419>>>>>>>>>>>        Function_Return bOK
79420>>>>>>>>>>>    End_Function
79421>>>>>>>>>>>
79421>>>>>>>>>>>    Procedure Show_ConnectionIdInformation
79423>>>>>>>>>>>        If (ghoConnection > 0) Begin
79425>>>>>>>>>>>            Send AppendTextLn ""
79426>>>>>>>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
79427>>>>>>>>>>>        End
79427>>>>>>>>>>>>
79427>>>>>>>>>>>    End_Procedure
79428>>>>>>>>>>>    
79428>>>>>>>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
79430>>>>>>>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
79431>>>>>>>>>>>    End_Function
79432>>>>>>>>>>>    
79432>>>>>>>>>>>    Procedure Show_Versions
79434>>>>>>>>>>>        Integer iVersion iRevision iBuild
79434>>>>>>>>>>>        
79434>>>>>>>>>>>        Version_Information iVersion iRevision iBuild
79436>>>>>>>>>>>        
79436>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(Self,iVersion,iRevision,iBuild) ))
79437>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(Self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
79438>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(Self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
79439>>>>>>>>>>>    End_Procedure
79440>>>>>>>>>>>    
79440>>>>>>>>>>>    Procedure Show_Platform
79442>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Platform,"64-bit"))
79443>>>>>>>>>>>    End_Procedure
79444>>>>>>>>>>>    
79444>>>>>>>>>>>    Function CKRevisionNumber String sDriverID Returns String
79446>>>>>>>>>>>        Handle hoCLIHandler
79446>>>>>>>>>>>        Handle hoDFBtrDrvHandler
79446>>>>>>>>>>>        String sCKRevision
79446>>>>>>>>>>>        
79446>>>>>>>>>>>        
79446>>>>>>>>>>>        If (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV") Begin
79448>>>>>>>>>>>            Get Create (RefClass(cCLIHandler)) to hoCLIHandler
79449>>>>>>>>>>>            Set psDriverID of hoCLIHandler to sDriverID
79450>>>>>>>>>>>            Move (CKRevision(hoCLIHandler)) to sCKRevision
79451>>>>>>>>>>>            Send Destroy of hoCLIHandler
79452>>>>>>>>>>>        End
79452>>>>>>>>>>>>
79452>>>>>>>>>>>        Else Begin
79453>>>>>>>>>>>            If (sDriverID = "DFBTRDRV") Begin
79455>>>>>>>>>>>                Get Create (RefClass(cDFBtrDrvHandler)) to hoDFBtrDrvHandler
79456>>>>>>>>>>>                Set psDriverID of hoDFBtrDrvHandler to sDriverID
79457>>>>>>>>>>>                Move (CKRevision(hoDFBtrDrvHandler)) to sCKRevision
79458>>>>>>>>>>>                Send Destroy of hoDFBtrDrvHandler
79459>>>>>>>>>>>            End
79459>>>>>>>>>>>>
79459>>>>>>>>>>>        End
79459>>>>>>>>>>>>
79459>>>>>>>>>>>        
79459>>>>>>>>>>>        Function_Return sCKRevision
79460>>>>>>>>>>>    End_Function    
79461>>>>>>>>>>>    
79461>>>>>>>>>>>    Function IsDataAccessCK String sDriverID Returns Boolean
79463>>>>>>>>>>>        
79463>>>>>>>>>>>        If (sDriverID = "DATAFLEX") Begin
79465>>>>>>>>>>>            Function_Return False
79466>>>>>>>>>>>        End
79466>>>>>>>>>>>>
79466>>>>>>>>>>>        
79466>>>>>>>>>>>        Function_Return (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV" or sDriverID = "DFBTRDRV")
79467>>>>>>>>>>>    End_Function
79468>>>>>>>>>>>    
79468>>>>>>>>>>>    Procedure Show_Drivers
79470>>>>>>>>>>>        String sDriverID sVersion sClient sValue
79470>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
79470>>>>>>>>>>>        Handle hoCLIHandler hoBtrvHandler
79470>>>>>>>>>>>        Boolean bStudioLicense bIsDAWDriver
79470>>>>>>>>>>>
79470>>>>>>>>>>>        Move False to bStudioLicense
79471>>>>>>>>>>>
79471>>>>>>>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
79472>>>>>>>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
79473>>>>>>>>>>>
79473>>>>>>>>>>>        // For testing purposes:
79473>>>>>>>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79473>>>>>>>>>>>//        Load_Driver MSSQLDRV_ID
79473>>>>>>>>>>>//        Load_Driver ODBC_DRV_ID
79473>>>>>>>>>>>//        Load_Driver DB2_DRV_ID
79473>>>>>>>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79473>>>>>>>>>>>//
79473>>>>>>>>>>>        Move False to Err
79474>>>>>>>>>>>
79474>>>>>>>>>>>        // Loop through all loaded drivers.
79474>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
79477>>>>>>>>>>>        If (iNumberOfDrivers > 1) Begin
79479>>>>>>>>>>>            Send AppendTextLn ""
79480>>>>>>>>>>>        End
79480>>>>>>>>>>>>
79480>>>>>>>>>>>        For iDriver from 1 to iNumberOfDrivers
79486>>>>>>>>>>>>
79486>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
79487>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
79490>>>>>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
79491>>>>>>>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
79492>>>>>>>>>>>
79492>>>>>>>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True) Begin
79494>>>>>>>>>>>
79494>>>>>>>>>>>                // Pervasive/Btrieve database
79494>>>>>>>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
79496>>>>>>>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
79497>>>>>>>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
79498>>>>>>>>>>>                    If (sClient <> "0.0.0") Begin
79500>>>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
79501>>>>>>>>>>>                    End
79501>>>>>>>>>>>>
79501>>>>>>>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
79502>>>>>>>>>>>                    If (sClient <> "0.0.0") Begin
79504>>>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
79505>>>>>>>>>>>                    End
79505>>>>>>>>>>>>
79505>>>>>>>>>>>                End
79505>>>>>>>>>>>>
79505>>>>>>>>>>>
79505>>>>>>>>>>>                Else Begin
79506>>>>>>>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
79507>>>>>>>>>>>                    Move 0 to iNumServers
79508>>>>>>>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
79510>>>>>>>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
79513>>>>>>>>>>>                    End
79513>>>>>>>>>>>>
79513>>>>>>>>>>>
79513>>>>>>>>>>>                    If (bIsDAWDriver = True) Begin
79515>>>>>>>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
79517>>>>>>>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
79518>>>>>>>>>>>                        End
79518>>>>>>>>>>>>
79518>>>>>>>>>>>                        Get CKRevision of hoCLIHandler to sVersion
79519>>>>>>>>>>>                    End
79519>>>>>>>>>>>>
79519>>>>>>>>>>>
79519>>>>>>>>>>>                    // If the serialnumber is = 0, it means that the
79519>>>>>>>>>>>                    // Studio licens is in use and there is no
79519>>>>>>>>>>>                    // number of max users defined because the driver is
79519>>>>>>>>>>>                    // relying on the info from the VDF license.
79519>>>>>>>>>>>                    If (bStudioLicense = False) Begin
79521>>>>>>>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
79522>>>>>>>>>>>                        Move (iSerialNo = 0) to bStudioLicense
79523>>>>>>>>>>>                    End
79523>>>>>>>>>>>>
79523>>>>>>>>>>>                End
79523>>>>>>>>>>>>
79523>>>>>>>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
79524>>>>>>>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
79526>>>>>>>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
79527>>>>>>>>>>>                End
79527>>>>>>>>>>>>
79527>>>>>>>>>>>                If (iNumServers <> 0) Begin
79529>>>>>>>>>>>                    For iCount from 1 to iNumServers
79535>>>>>>>>>>>>
79535>>>>>>>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
79538>>>>>>>>>>>                        If (not(sValue contains ";PWD=")) Begin
79540>>>>>>>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
79541>>>>>>>>>>>                        End
79541>>>>>>>>>>>>
79541>>>>>>>>>>>                    Loop
79542>>>>>>>>>>>>
79542>>>>>>>>>>>                End
79542>>>>>>>>>>>>
79542>>>>>>>>>>>            End
79542>>>>>>>>>>>>
79542>>>>>>>>>>>        Loop
79543>>>>>>>>>>>>
79543>>>>>>>>>>>
79543>>>>>>>>>>>        Send AppendTextLn ""
79544>>>>>>>>>>>        If (bStudioLicense = False) Begin
79546>>>>>>>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
79547>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
79548>>>>>>>>>>>        End
79548>>>>>>>>>>>>
79548>>>>>>>>>>>        Else Begin
79549>>>>>>>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
79550>>>>>>>>>>>        End
79550>>>>>>>>>>>>
79550>>>>>>>>>>>        Send Destroy of hoCLIHandler
79551>>>>>>>>>>>        Send Destroy of hoBtrvHandler
79552>>>>>>>>>>>    End_Procedure
79553>>>>>>>>>>>
79553>>>>>>>>>>>    Procedure Show_HelpFile
79555>>>>>>>>>>>        String sHelpFile
79555>>>>>>>>>>>        Integer eHelpType
79555>>>>>>>>>>>
79555>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79557>>>>>>>>>>>            Get peHelpType Of ghoApplication To eHelpType
79558>>>>>>>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
79560>>>>>>>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
79561>>>>>>>>>>>            End
79561>>>>>>>>>>>>
79561>>>>>>>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
79564>>>>>>>>>>>                Get Help_filename Of Help_object_id To sHelpFile
79565>>>>>>>>>>>            End
79565>>>>>>>>>>>>
79565>>>>>>>>>>>            Else Begin
79566>>>>>>>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
79567>>>>>>>>>>>            End
79567>>>>>>>>>>>>
79567>>>>>>>>>>>
79567>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
79568>>>>>>>>>>>        End
79568>>>>>>>>>>>>
79568>>>>>>>>>>>    End_Procedure
79569>>>>>>>>>>>
79569>>>>>>>>>>>    Procedure Show_EnterAsTab
79571>>>>>>>>>>>        Boolean bEnterKeyAsTabKey
79571>>>>>>>>>>>        String sText
79571>>>>>>>>>>>
79571>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79573>>>>>>>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
79574>>>>>>>>>>>            If (bEnterKeyAsTabKey) Begin
79576>>>>>>>>>>>                Move "True" To sText
79577>>>>>>>>>>>            End
79577>>>>>>>>>>>>
79577>>>>>>>>>>>            Else Begin
79578>>>>>>>>>>>                Move "False" To sText
79579>>>>>>>>>>>            End
79579>>>>>>>>>>>>
79579>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
79580>>>>>>>>>>>        End
79580>>>>>>>>>>>>
79580>>>>>>>>>>>    End_Procedure
79581>>>>>>>>>>>
79581>>>>>>>>>>>    //    During activation we will remove the old information and add the newly
79581>>>>>>>>>>>    //    found systeminformation
79581>>>>>>>>>>>    Procedure Add_Focus Integer hoRoot
79583>>>>>>>>>>>        Forward Send Add_Focus hoRoot
79585>>>>>>>>>>>
79585>>>>>>>>>>>        Send Delete_Data
79586>>>>>>>>>>>
79586>>>>>>>>>>>        Set Changed_State To False
79587>>>>>>>>>>>        Set Read_Only_State To True
79588>>>>>>>>>>>
79588>>>>>>>>>>>        Send Show_Registration
79589>>>>>>>>>>>        Send Show_Drivers
79590>>>>>>>>>>>        Send Show_ServicePack
79591>>>>>>>>>>>        Send Show_Versions
79592>>>>>>>>>>>        Send Show_Platform
79593>>>>>>>>>>>        Send AppendTextLn ""
79594>>>>>>>>>>>
79594>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79596>>>>>>>>>>>            Send Show_WorkSpaceInformation
79597>>>>>>>>>>>            Send Show_HelpFile
79598>>>>>>>>>>>            Send AppendTextLn ""
79599>>>>>>>>>>>        End
79599>>>>>>>>>>>>
79599>>>>>>>>>>>        Else Begin
79600>>>>>>>>>>>            Send AppendTextLn ""
79601>>>>>>>>>>>        End
79601>>>>>>>>>>>>
79601>>>>>>>>>>>
79601>>>>>>>>>>>        If (ghoConnection <> 0) Begin
79603>>>>>>>>>>>            Send Show_ConnectionIdInformation
79604>>>>>>>>>>>        End
79604>>>>>>>>>>>>
79604>>>>>>>>>>>
79604>>>>>>>>>>>        Send Show_Current_User
79605>>>>>>>>>>>        Send Show_Windows_Directory
79606>>>>>>>>>>>        Send Show_Current_Directory
79607>>>>>>>>>>>
79607>>>>>>>>>>>        // This is already shown in the workspace details,
79607>>>>>>>>>>>        // unless no workspace object is present:
79607>>>>>>>>>>>        If (ghoApplication = 0) Begin
79609>>>>>>>>>>>            Send Show_Filelist_Name
79610>>>>>>>>>>>        End
79610>>>>>>>>>>>>
79610>>>>>>>>>>>
79610>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79612>>>>>>>>>>>            Send AppendTextLn ""
79613>>>>>>>>>>>            Send Show_EnterAsTab
79614>>>>>>>>>>>        End
79614>>>>>>>>>>>>
79614>>>>>>>>>>>
79614>>>>>>>>>>>        Send Show_Screen_Size
79615>>>>>>>>>>>        Send Show_Page_Size
79616>>>>>>>>>>>        Send Show_Number_Format
79617>>>>>>>>>>>        Send Show_Date_Format
79618>>>>>>>>>>>        Send Show_Lock_Delay
79619>>>>>>>>>>>        Send Show_Lock_Timeout
79620>>>>>>>>>>>        Send Show_Date
79621>>>>>>>>>>>        Send Show_Systemresources
79622>>>>>>>>>>>        Send Beginning_of_Data
79623>>>>>>>>>>>
79623>>>>>>>>>>>        Set Icon to 'default.ico'
79624>>>>>>>>>>>    End_Procedure
79625>>>>>>>>>>>End_Class
79626>>>>>>>>>>>
79626>>>>>>>>>>>Class SysInfoDialog is a ModalPanel
79627>>>>>>>>>>>    Procedure Construct_Object
79629>>>>>>>>>>>        Forward Send Construct_Object
79631>>>>>>>>>>>
79631>>>>>>>>>>>        Set Label to C_$SystemInformation
79632>>>>>>>>>>>        Set Size to 140 267
79633>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79634>>>>>>>>>>>        Set Border_Style to Border_Thick
79635>>>>>>>>>>>        Set Sysmenu_Icon to False
79636>>>>>>>>>>>
79636>>>>>>>>>>>        // "+1" will make the panel to paint correctly.
79636>>>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
79637>>>>>>>>>>>
79637>>>>>>>>>>>        // 2014-09-14 NGS
79637>>>>>>>>>>>        // Added a container object around the cTexteditor
79637>>>>>>>>>>>        // object to get a border around the text.
79637>>>>>>>>>>>        Object oSysinfoDisplayContainer is a Container3d
79639>>>>>>>>>>>            Set Location to 2 4
79640>>>>>>>>>>>            Set Size to 110 255
79641>>>>>>>>>>>            Set Border_Style to Border_ClientEdge
79642>>>>>>>>>>>            Set Color to clWhite
79643>>>>>>>>>>>            Set peAnchors to anAll
79644>>>>>>>>>>>
79644>>>>>>>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
79646>>>>>>>>>>>            End_Object
79647>>>>>>>>>>>
79647>>>>>>>>>>>        End_Object
79648>>>>>>>>>>>
79648>>>>>>>>>>>        Object oCloseButton is a Button
79650>>>>>>>>>>>            Set Label to C_$Close
79651>>>>>>>>>>>            Set Location to 120 210
79652>>>>>>>>>>>            CompilerWarnings Off
79652>>>>>>>>>>>            Set Message Item 0 to msg_Close_Panel
79653>>>>>>>>>>>            CompilerWarnings On
79653>>>>>>>>>>>            Set Default_State To True
79654>>>>>>>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
79654>>>>>>>>>>>            // and changes its peAnchors, we might as well prepare this object
79654>>>>>>>>>>>            // for that situation.
79654>>>>>>>>>>>            Set peAnchors to anBottomRight
79655>>>>>>>>>>>        End_Object
79656>>>>>>>>>>>
79656>>>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79658>>>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79659>>>>>>>>>>>            Set Size to 14 50
79660>>>>>>>>>>>            Set Location to 120 158
79661>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79661>>>>>>>>>>>            // we might as well prepare the object for it.
79661>>>>>>>>>>>            Set peAnchors to anBottomRight
79662>>>>>>>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
79663>>>>>>>>>>>        End_Object
79664>>>>>>>>>>>
79664>>>>>>>>>>>        On_Key kCancel Send Close_Panel
79665>>>>>>>>>>>    End_Procedure
79666>>>>>>>>>>>
79666>>>>>>>>>>>    Procedure Page Integer iPageObject
79668>>>>>>>>>>>        Handle hMenu
79668>>>>>>>>>>>        Integer iPrevState
79668>>>>>>>>>>>
79668>>>>>>>>>>>        Forward Send Page iPageObject
79670>>>>>>>>>>>
79670>>>>>>>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
79670>>>>>>>>>>>        //
79670>>>>>>>>>>>    End_Procedure
79671>>>>>>>>>>>
79671>>>>>>>>>>>End_Class
79672>>>>>>>>>>>
79672>>>>>>>>>>>Class cAboutEdit is an cRichEdit
79673>>>>>>>>>>>    Procedure Construct_Object
79675>>>>>>>>>>>        Forward Send Construct_Object
79677>>>>>>>>>>>
79677>>>>>>>>>>>        Property String psContentText
79678>>>>>>>>>>>
79678>>>>>>>>>>>        Set Size to 77 153
79679>>>>>>>>>>>        Set Location to 8 60
79680>>>>>>>>>>>        Set Read_Only_State to True
79681>>>>>>>>>>>        Set Skip_State to True
79682>>>>>>>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
79682>>>>>>>>>>>        // or 1/20 of a printer's point.
79682>>>>>>>>>>>        Set piRightMargin to (0.1 * 1440)
79683>>>>>>>>>>>        Set Border_Style  to Border_None
79684>>>>>>>>>>>    End_Procedure
79685>>>>>>>>>>>
79685>>>>>>>>>>>    // Adds a line of text to the edit object
79685>>>>>>>>>>>    Procedure Add_Line String sText
79687>>>>>>>>>>>        String sContentText
79687>>>>>>>>>>>        Get psContentText to sContentText
79688>>>>>>>>>>>        Move (sContentText + String(sText)) to sContentText
79689>>>>>>>>>>>        Set psContentText to sContentText
79690>>>>>>>>>>>    End_Procedure
79691>>>>>>>>>>>
79691>>>>>>>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
79691>>>>>>>>>>>    // Note that we use a property psContentText and add to it,
79691>>>>>>>>>>>    // because the object isn't paged yet when we add these
79691>>>>>>>>>>>    // values and the COM edit object needs to be paged
79691>>>>>>>>>>>    // for the text to become visible. See Also: Procedure Page below.
79691>>>>>>>>>>>    Procedure Add_LineLn String sText
79693>>>>>>>>>>>        String sContentText sCR
79693>>>>>>>>>>>
79693>>>>>>>>>>>        Move (Character(10) + String(Character(13))) to sCR
79694>>>>>>>>>>>        Get psContentText to sContentText
79695>>>>>>>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
79696>>>>>>>>>>>        Set psContentText to sContentText
79697>>>>>>>>>>>    End_Procedure
79698>>>>>>>>>>>
79698>>>>>>>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
79700>>>>>>>>>>>        String sLinkText
79700>>>>>>>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
79701>>>>>>>>>>>        Send Show_HomePage sLinkText
79702>>>>>>>>>>>    End_Procedure
79703>>>>>>>>>>>
79703>>>>>>>>>>>    Procedure Page Integer iPageObject
79705>>>>>>>>>>>        String sContentText
79705>>>>>>>>>>>
79705>>>>>>>>>>>        Forward Send Page iPageObject
79707>>>>>>>>>>>        Get psContentText to sContentText
79708>>>>>>>>>>>        Send AppendText sContentText
79709>>>>>>>>>>>        send Beginning_of_Data
79710>>>>>>>>>>>    End_Procedure
79711>>>>>>>>>>>
79711>>>>>>>>>>>End_Class
79712>>>>>>>>>>>
79712>>>>>>>>>>>Class AboutDialog is a ModalPanel
79713>>>>>>>>>>>    Procedure Construct_Object
79715>>>>>>>>>>>
79715>>>>>>>>>>>        Forward Send Construct_Object
79717>>>>>>>>>>>
79717>>>>>>>>>>>        Set Label to C_$About
79718>>>>>>>>>>>        Set Size to 118 230
79719>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79720>>>>>>>>>>>        Set Border_Style to Border_Thick
79721>>>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
79722>>>>>>>>>>>
79722>>>>>>>>>>>        Object oSysInfoDialog is a SysInfoDialog
79724>>>>>>>>>>>        End_Object
79725>>>>>>>>>>>
79725>>>>>>>>>>>        Object oBox is a Container3d
79727>>>>>>>>>>>            Set Border_Style to Border_Normal
79728>>>>>>>>>>>            Set Size to 90 220
79729>>>>>>>>>>>            Set Location to 4 5
79730>>>>>>>>>>>            Set Color to clWhite
79731>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79731>>>>>>>>>>>            // we might as well prepare the object for it.
79731>>>>>>>>>>>            Set peAnchors to anAll
79732>>>>>>>>>>>
79732>>>>>>>>>>>            Object oAboutGraphic is a BitmapContainer
79734>>>>>>>>>>>                Set Border_Style To Border_None
79735>>>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
79736>>>>>>>>>>>                Set Color to clWhite
79737>>>>>>>>>>>                Set Size to 45 50
79738>>>>>>>>>>>                Set Location to 0 3
79739>>>>>>>>>>>            End_Object
79740>>>>>>>>>>>
79740>>>>>>>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
79742>>>>>>>>>>>                Set Border_Style to Border_None
79743>>>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
79744>>>>>>>>>>>                Set Color to clWhite
79745>>>>>>>>>>>                Set Size to 30 55
79746>>>>>>>>>>>                Set Location to 50 3
79747>>>>>>>>>>>            End_Object
79748>>>>>>>>>>>
79748>>>>>>>>>>>            Object oInfoList_Editor is an cAboutEdit
79750>>>>>>>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
79750>>>>>>>>>>>                // we might as well prepare the object for it.
79750>>>>>>>>>>>                Set peAnchors to anAll
79751>>>>>>>>>>>            End_Object
79752>>>>>>>>>>>
79752>>>>>>>>>>>            // These objects are here for backwards compatability only.
79752>>>>>>>>>>>            // They are not used.
79752>>>>>>>>>>>            Object oProductName is a TextBox
79754>>>>>>>>>>>                Set Label To C_$ProductName
79755>>>>>>>>>>>                Set Size To 10 45
79756>>>>>>>>>>>                Set Location To 8 53
79757>>>>>>>>>>>                Set Visible_State to False
79758>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79759>>>>>>>>>>>            End_Object
79760>>>>>>>>>>>
79760>>>>>>>>>>>            Object oVersion is a TextBox
79762>>>>>>>>>>>                Set Label To C_$Version
79763>>>>>>>>>>>                Set Size To 10 25
79764>>>>>>>>>>>                Set Location To 21 53
79765>>>>>>>>>>>                Set Visible_State to False
79766>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79767>>>>>>>>>>>            End_Object
79768>>>>>>>>>>>
79768>>>>>>>>>>>            Object oCopyright is a TextBox
79770>>>>>>>>>>>                Set Label To C_$Copyright
79771>>>>>>>>>>>                Set Size To 10 31
79772>>>>>>>>>>>                Set Location To 34 53
79773>>>>>>>>>>>                Set Visible_State to False
79774>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79775>>>>>>>>>>>            End_Object
79776>>>>>>>>>>>
79776>>>>>>>>>>>            Object oAuthor is a TextBox
79778>>>>>>>>>>>                Set Label To C_$Author
79779>>>>>>>>>>>                Set Size To 10 22
79780>>>>>>>>>>>                Set Location To 46 53
79781>>>>>>>>>>>                Set Visible_State to False
79782>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79783>>>>>>>>>>>            End_Object
79784>>>>>>>>>>>
79784>>>>>>>>>>>        End_Object
79785>>>>>>>>>>>
79785>>>>>>>>>>>        Object oOKButton is a Button
79787>>>>>>>>>>>            On_Item C_$Close Send Close_Panel
79788>>>>>>>>>>>            Set Location to 98 176
79789>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79789>>>>>>>>>>>            // we might as well prepare the object for it.
79789>>>>>>>>>>>            Set peAnchors to anBottomRight
79790>>>>>>>>>>>        End_Object
79791>>>>>>>>>>>
79791>>>>>>>>>>>        Object oSysInfoButton is a Button
79793>>>>>>>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
79794>>>>>>>>>>>            Set Location to 98 123
79795>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79795>>>>>>>>>>>            // we might as well prepare the object for it.
79795>>>>>>>>>>>            Set peAnchors to anBottomRight
79796>>>>>>>>>>>        End_Object
79797>>>>>>>>>>>
79797>>>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79799>>>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79800>>>>>>>>>>>            Set Size to 14 50
79801>>>>>>>>>>>            Set Location to 98 70
79802>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79802>>>>>>>>>>>            // we might as well prepare the object for it.
79802>>>>>>>>>>>            Set peAnchors to anBottomRight
79803>>>>>>>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
79804>>>>>>>>>>>        End_Object
79805>>>>>>>>>>>
79805>>>>>>>>>>>        On_Key Kcancel Send KeyAction of oOKButton
79806>>>>>>>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
79807>>>>>>>>>>>        Set LogoDF to "DF32.bmp"
79808>>>>>>>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
79808>>>>>>>>>>>    End_Procedure
79809>>>>>>>>>>>
79809>>>>>>>>>>>    Procedure Page Integer iPageObject
79811>>>>>>>>>>>        Handle hMenu
79811>>>>>>>>>>>        Integer iPrevState
79811>>>>>>>>>>>
79811>>>>>>>>>>>        Forward Send Page iPageObject
79813>>>>>>>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
79813>>>>>>>>>>>        Set Icon to "Default.ico"
79814>>>>>>>>>>>
79814>>>>>>>>>>>        // Shadow upper left corner menu items: (icon menu items)
79814>>>>>>>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
79815>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79816>>>>>>>>>>>        // The "Move" menu command may come in handy to have.
79816>>>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79816>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79817>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79818>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79819>>>>>>>>>>>        // The "Close" menu command may be good to have.
79819>>>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79819>>>>>>>>>>>    End_Procedure
79820>>>>>>>>>>>
79820>>>>>>>>>>>    Procedure Set ProductName String sText
79822>>>>>>>>>>>        Set Value of oProductName to sText
79823>>>>>>>>>>>    End_Procedure
79824>>>>>>>>>>>
79824>>>>>>>>>>>    Procedure Set Copyright String sText
79826>>>>>>>>>>>        Set Value of oCopyright to sText
79827>>>>>>>>>>>    End_Procedure
79828>>>>>>>>>>>
79828>>>>>>>>>>>    Procedure Set Author String sText
79830>>>>>>>>>>>        Set Value of oAuthor to sText
79831>>>>>>>>>>>    End_Procedure
79832>>>>>>>>>>>
79832>>>>>>>>>>>    // This is used by the About object to display the compile date & time:
79832>>>>>>>>>>>    // Note: It relies on that each project (program) has been setup to use the "WriteDateTimeHeaderFile64.exe"
79832>>>>>>>>>>>    //       program as a pre-compile!
79832>>>>>>>>>>>    //       Add it here: "Before Compilation Process:" (See Studio's: Project - Project Properties - Compiler tab-page)
79832>>>>>>>>>>>    Include_Resource CompileHeader.h as res_CompileHeader type DF_RESOURCE_TYPE_LINE
79832>>>>>>>>>>>
79832>>>>>>>>>>>    Procedure Set Version String sVersion
79834>>>>>>>>>>>        Handle hoVersionInfo
79834>>>>>>>>>>>        Boolean bIncluded
79834>>>>>>>>>>>        Integer iMajor iMinor iRelease iBuild iPos
79834>>>>>>>>>>>        String sCertInfo sCompileDateAndTime
79834>>>>>>>>>>>
79834>>>>>>>>>>>        If (sVersion = "") Begin
79836>>>>>>>>>>>            // This automatically shows the program version of the program, if available.
79836>>>>>>>>>>>            // It will be displayed as the second item in the edit object.
79836>>>>>>>>>>>            If (ghoApplication <> 0) Begin
79838>>>>>>>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
79839>>>>>>>>>>>                If (hoVersionInfo <> 0) Begin
79841>>>>>>>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
79842>>>>>>>>>>>                    If (bIncluded) Begin
79844>>>>>>>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
79845>>>>>>>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
79846>>>>>>>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
79847>>>>>>>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
79848>>>>>>>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
79849>>>>>>>>>>>                    End
79849>>>>>>>>>>>>
79849>>>>>>>>>>>                End
79849>>>>>>>>>>>>
79849>>>>>>>>>>>            End
79849>>>>>>>>>>>>
79849>>>>>>>>>>>        End
79849>>>>>>>>>>>>
79849>>>>>>>>>>>
79849>>>>>>>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
79849>>>>>>>>>>>        Direct_Input "resource: res_CompileHeader"
79850>>>>>>>>>>>        Readln sCompileDateAndTime
79851>>>>>>>>>>>        Move (Pos('"', sCompileDateAndTime)) to iPos
79852>>>>>>>>>>>        If (iPos <> 0) Begin
79854>>>>>>>>>>>            Move (Mid(sCompileDateAndTime, Length(sCompileDateAndTime), (iPos + 1))) to sCompileDateAndTime
79855>>>>>>>>>>>            Move (Replaces('"', sCompileDateAndTime, '')) to sCompileDateAndTime
79856>>>>>>>>>>>        End
79856>>>>>>>>>>>>
79856>>>>>>>>>>>        Close_Input
79857>>>>>>>>>>>
79857>>>>>>>>>>>        If (sCompileDateAndTime <> "") Begin
79859>>>>>>>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(sCompileDateAndTime))
79860>>>>>>>>>>>        End
79860>>>>>>>>>>>>
79860>>>>>>>>>>>
79860>>>>>>>>>>>        Get IsProgramDigitallySigned to sCertInfo
79861>>>>>>>>>>>        If (sCertInfo <> "-1") Begin
79863>>>>>>>>>>>            If (sCertInfo <> "") Begin
79865>>>>>>>>>>>                Send Add_LineLn sCertInfo
79866>>>>>>>>>>>            End
79866>>>>>>>>>>>>
79866>>>>>>>>>>>            Else Begin
79867>>>>>>>>>>>//                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
79867>>>>>>>>>>>            End
79867>>>>>>>>>>>>
79867>>>>>>>>>>>        End
79867>>>>>>>>>>>>
79867>>>>>>>>>>>    End_Procedure
79868>>>>>>>>>>>
79868>>>>>>>>>>>    Function IsDate String sDate Returns Boolean
79870>>>>>>>>>>>        Boolean bIsDate
79870>>>>>>>>>>>        String sGoodCharacters sChar
79870>>>>>>>>>>>        Integer iCount iLength
79870>>>>>>>>>>>
79870>>>>>>>>>>>        Move True to bIsDate
79871>>>>>>>>>>>        Move "0123456789-/" to sGoodCharacters
79872>>>>>>>>>>>        Move (Length(sDate)) to iLength
79873>>>>>>>>>>>        For iCount from 1 to iLength
79879>>>>>>>>>>>>
79879>>>>>>>>>>>            Move (Left(sDate, 1)) to sChar
79880>>>>>>>>>>>            Move (Mid(sDate, 12, 2)) to sDate
79881>>>>>>>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
79882>>>>>>>>>>>            If (bIsDate = False) Begin
79884>>>>>>>>>>>                Move iLength to iCount
79885>>>>>>>>>>>            End
79885>>>>>>>>>>>>
79885>>>>>>>>>>>        Loop
79886>>>>>>>>>>>>
79886>>>>>>>>>>>        Function_Return bIsDate
79887>>>>>>>>>>>    End_Function
79888>>>>>>>>>>>
79888>>>>>>>>>>>    Function GetCompileDate Returns Date
79890>>>>>>>>>>>        Date dCompileDate
79890>>>>>>>>>>>        String sAppFilename sProgram sData sCompileDate
79890>>>>>>>>>>>        Integer iChannel iPos iDateFormat iCount iSize
79890>>>>>>>>>>>        Boolean bIsValid   
79890>>>>>>>>>>>        
79890>>>>>>>>>>>        Move 0 to dCompileDate
79891>>>>>>>>>>>        // Get full path to the current running executable
79891>>>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
79892>>>>>>>>>>>        Get GetApplicationName     of ghoApplication to sProgram
79893>>>>>>>>>>>
79893>>>>>>>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
79893>>>>>>>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
79894>>>>>>>>>>>
79894>>>>>>>>>>>        Read_Block channel iChannel sData 9000000   // This must be big enough to reach the compile date location
79896>>>>>>>>>>>        Move (Pos(sProgram, sData)) to iPos
79897>>>>>>>>>>>        If (iPos > 0) Begin
79899>>>>>>>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
79899>>>>>>>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
79900>>>>>>>>>>>
79900>>>>>>>>>>>            // If the current date format is non US, we need to temporary
79900>>>>>>>>>>>            // change the format and then move the string to the date variable.
79900>>>>>>>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
79903>>>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA  
79906>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id 16 
79907>>>>>>>>>>>            If (Left(sCompileDate, 1) = "0") Begin
79909>>>>>>>>>>>                Move ("1" + String(sCompileDate)) to sCompileDate
79910>>>>>>>>>>>            End
79910>>>>>>>>>>>>
79910>>>>>>>>>>>            Move (Date(sCompileDate))    to dCompileDate
79911>>>>>>>>>>>            Send Trap_Error of Error_Object_Id 16
79912>>>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
79915>>>>>>>>>>>        End
79915>>>>>>>>>>>>
79915>>>>>>>>>>>        Else Begin
79916>>>>>>>>>>>            Error DFERR_PROGRAM "Compile Date location in .exe not found"
79917>>>>>>>>>>>>
79917>>>>>>>>>>>        End
79917>>>>>>>>>>>>
79917>>>>>>>>>>>
79917>>>>>>>>>>>        Send Seq_Close_Channel iChannel
79918>>>>>>>>>>>
79918>>>>>>>>>>>        Function_Return dCompileDate
79919>>>>>>>>>>>    End_Function
79920>>>>>>>>>>>
79920>>>>>>>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
79920>>>>>>>>>>>    // (the passed program), has been finished
79920>>>>>>>>>>>    // The DOS box does also _not_ flash briefly.
79920>>>>>>>>>>>    Procedure RunProgramWait String sProgram String sParameter
79922>>>>>>>>>>>        Handle hProcess
79922>>>>>>>>>>>        Integer iVoid
79922>>>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79922>>>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79922>>>>>>>>>>>
79922>>>>>>>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
79923>>>>>>>>>>>
79923>>>>>>>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
79924>>>>>>>>>>>        Move SW_SHOW                 to sInfo.nShow
79925>>>>>>>>>>>
79925>>>>>>>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
79926>>>>>>>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
79927>>>>>>>>>>>        // This will "hide" the DOS box from showing (no flasing box):
79927>>>>>>>>>>>        Move 0                       to sInfo.nShow
79928>>>>>>>>>>>
79928>>>>>>>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
79929>>>>>>>>>>>        Move sInfo.hProcess to hProcess
79930>>>>>>>>>>>        If (hProcess) Begin
79932>>>>>>>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
79933>>>>>>>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
79934>>>>>>>>>>>        End
79934>>>>>>>>>>>>
79934>>>>>>>>>>>    End_Procedure
79935>>>>>>>>>>>
79935>>>>>>>>>>>    Function AddFolderDelimiter String sPath Returns String
79937>>>>>>>>>>>        String sDirSep
79937>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
79938>>>>>>>>>>>        Move (Trim(sPath)) to sPath
79939>>>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
79941>>>>>>>>>>>            Move (sPath + sDirSep) to sPath
79942>>>>>>>>>>>        End
79942>>>>>>>>>>>>
79942>>>>>>>>>>>        Function_Return sPath
79943>>>>>>>>>>>    End_Function
79944>>>>>>>>>>>
79944>>>>>>>>>>>    // Returns an empty string if the current program is not digitally signed,
79944>>>>>>>>>>>    // or there is a problem with the certificate.
79944>>>>>>>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
79944>>>>>>>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
79944>>>>>>>>>>>    Function IsProgramDigitallySigned Returns String
79946>>>>>>>>>>>        Boolean bExists
79946>>>>>>>>>>>        String sPath sProgram sParams sRetval
79946>>>>>>>>>>>        Integer iCh
79946>>>>>>>>>>>
79946>>>>>>>>>>>        Move "" to sRetval
79947>>>>>>>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
79948>>>>>>>>>>>        Get AddFolderDelimiter sPath to sPath
79949>>>>>>>>>>>        File_Exist (sPath + CS_SignProgram) bExists
79950>>>>>>>>>>>        If (bExists = False) Begin
79952>>>>>>>>>>>            Function_Return "-1"
79953>>>>>>>>>>>        End
79953>>>>>>>>>>>>
79953>>>>>>>>>>>
79953>>>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
79954>>>>>>>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
79955>>>>>>>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
79956>>>>>>>>>>>        Move (sParams * String("| clip"))    to sParams
79957>>>>>>>>>>>        Get Seq_New_Channel to iCh
79958>>>>>>>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
79960>>>>>>>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
79963>>>>>>>>>>>        Close_Output channel iCh
79965>>>>>>>>>>>        // New ShellExecute based message that waits for the passed process to end.
79965>>>>>>>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
79966>>>>>>>>>>>        Direct_Input channel iCh "CLIPBOARD:"
79968>>>>>>>>>>>            Readln channel iCh sRetval
79970>>>>>>>>>>>            Readln channel iCh sRetval
79972>>>>>>>>>>>            Readln channel iCh sRetval
79974>>>>>>>>>>>            Readln channel iCh sRetval
79976>>>>>>>>>>>        Close_Input channel iCh
79978>>>>>>>>>>>        Send Seq_Release_Channel iCh
79979>>>>>>>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
79981>>>>>>>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
79982>>>>>>>>>>>        End
79982>>>>>>>>>>>>
79982>>>>>>>>>>>        Else Begin
79983>>>>>>>>>>>            Move "" to sRetval
79984>>>>>>>>>>>        End
79984>>>>>>>>>>>>
79984>>>>>>>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
79984>>>>>>>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
79985>>>>>>>>>>>>
79985>>>>>>>>>>>        Function_Return sRetval
79986>>>>>>>>>>>    End_Function
79987>>>>>>>>>>>
79987>>>>>>>>>>>    Procedure Add_LineLn String sValue
79989>>>>>>>>>>>        Send Add_LineLn of oInfoList_Editor sValue
79990>>>>>>>>>>>    End_Procedure
79991>>>>>>>>>>>
79991>>>>>>>>>>>    Procedure Add_Line String sValue
79993>>>>>>>>>>>        Send Add_Line of oInfoList_Editor sValue
79994>>>>>>>>>>>    End_Procedure
79995>>>>>>>>>>>
79995>>>>>>>>>>>    Procedure Set Logo string sLogo
79997>>>>>>>>>>>        // Square bitmaps of 80x80 work best
79997>>>>>>>>>>>        Set Bitmap of oAboutGraphic to sLogo
79998>>>>>>>>>>>    End_Procedure
79999>>>>>>>>>>>
79999>>>>>>>>>>>    Procedure Set LogoDF String sLogo
80001>>>>>>>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
80002>>>>>>>>>>>    End_Procedure
80003>>>>>>>>>>>
80003>>>>>>>>>>>    Procedure Show_Sysinfo
80005>>>>>>>>>>>        Send Popup_Modal of oSysinfoDialog
80006>>>>>>>>>>>    End_Procedure
80007>>>>>>>>>>>
80007>>>>>>>>>>>    Procedure Show_HomePage String sWebpage
80009>>>>>>>>>>>        Handle hWnd
80009>>>>>>>>>>>        Get Window_Handle to hWnd
80010>>>>>>>>>>>        Runprogram Shell Background (Trim(sWebpage))
80011>>>>>>>>>>>    End_Procedure
80012>>>>>>>>>>>
80012>>>>>>>>>>>End_Class
80013>>>>>>>>>
80013>>>>>>>>>    Function piOrgErrorHandlerID Returns Integer
80015>>>>>>>>>    End_Function
80016>>>>>>>>>
80016>>>>>>>>>Register_Procedure Set Private.pbProcessingError Boolean bProcessingError
80016>>>>>>>>>
80016>>>>>>>>>Class cBaseDbUpdateFuncLib is a cObject
80017>>>>>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
80018>>>>>>>>>>
80018>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
80020>>>>>>>>>>    Integer iStart iEnd
80020>>>>>>>>>>    String sRetval
80020>>>>>>>>>>
80020>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
80021>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
80022>>>>>>>>>>    If (iStart = 0) Begin
80024>>>>>>>>>>        Function_Return ""
80025>>>>>>>>>>    End
80025>>>>>>>>>>>
80025>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
80026>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
80027>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
80029>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
80030>>>>>>>>>>    End
80030>>>>>>>>>>>
80030>>>>>>>>>>    Else Begin
80031>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
80032>>>>>>>>>>    End
80032>>>>>>>>>>>
80032>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
80034>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
80035>>>>>>>>>>        Decrement iEnd
80036>>>>>>>>>>    End
80036>>>>>>>>>>>
80036>>>>>>>>>>    If (iEnd <> 0) Begin
80038>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
80039>>>>>>>>>>    End
80039>>>>>>>>>>>
80039>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
80040>>>>>>>>>>
80040>>>>>>>>>>    Function_Return (Trim(sRetval))
80041>>>>>>>>>>End_Function
80042>>>>>>>>>>
80042>>>>>>>>>>
80042>>>>>>>>>    
80042>>>>>>>>>    Procedure Construct_Object
80044>>>>>>>>>        Handle ho
80044>>>>>>>>>        Forward Send Construct_Object
80046>>>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
80047>>>>>>>>>        
80047>>>>>>>>>        Send CreateDbUpdateLibraryProperties
80048>>>>>>>>>        Property String private.psCollation "Latin1_General_CS_AS"
80049>>>>>>>>>        Property String[] pasSQLDataTables
80050>>>>>>>>>        Property tFilelist[] pFileListArray  
80051>>>>>>>>>        Property tFilelist[] pErrorTables
80052>>>>>>>>>
80052>>>>>>>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
80052>>>>>>>>>        // we will create one as it is used for all ConnectionID, ConnectionString
80052>>>>>>>>>        // etc settings.
80052>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80054>>>>>>>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
80055>>>>>>>>>            Set Name of ho to "oSQLConnectionHandler"
80056>>>>>>>>>            Set phoSQLConnectionHandler to ho
80057>>>>>>>>>        End
80057>>>>>>>>>>
80057>>>>>>>>>
80057>>>>>>>>>    End_Procedure
80058>>>>>>>>>
80058>>>>>>>>>    Procedure End_Construct_Object
80060>>>>>>>>>        Forward Send End_Construct_Object
80062>>>>>>>>>
80062>>>>>>>>>    End_Procedure
80063>>>>>>>>>
80063>>>>>>>>>    // Latin1_General_CI_AS = General Insensitive collation
80063>>>>>>>>>    // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.
80063>>>>>>>>>    // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
80063>>>>>>>>>    // Good read about which collation to select:
80063>>>>>>>>>    // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
80063>>>>>>>>>    Procedure Set psCollation String sCollation
80065>>>>>>>>>        Set private.psCollation to sCollation
80066>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
80068>>>>>>>>>            Set psCollation of ghoDbUpdateHandler to sCollation
80069>>>>>>>>>        End
80069>>>>>>>>>>
80069>>>>>>>>>    End_Procedure
80070>>>>>>>>>
80070>>>>>>>>>    Function psCollation Returns String
80072>>>>>>>>>        String sCollation
80072>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
80074>>>>>>>>>            Get psCollation of ghoDbUpdateHandler to sCollation
80075>>>>>>>>>        End   
80075>>>>>>>>>>
80075>>>>>>>>>        Else Begin
80076>>>>>>>>>            Get private.psCollation to sCollation
80077>>>>>>>>>        End
80077>>>>>>>>>>
80077>>>>>>>>>        Function_Return sCollation
80078>>>>>>>>>    End_Function
80079>>>>>>>>>
80079>>>>>>>>>    // Array sorting helper functions:
80079>>>>>>>>>    Function __UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
80081>>>>>>>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
80083>>>>>>>>>            Function_Return (EQ)
80084>>>>>>>>>        End
80084>>>>>>>>>>
80084>>>>>>>>>
80084>>>>>>>>>        Function_Return (GT)
80085>>>>>>>>>    End_Function
80086>>>>>>>>>
80086>>>>>>>>>    Function __SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
80088>>>>>>>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
80091>>>>>>>>>
80091>>>>>>>>>        Function_Return (GT)
80092>>>>>>>>>    End_Function
80093>>>>>>>>>
80093>>>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
80093>>>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
80093>>>>>>>>>    Function _ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
80095>>>>>>>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
80095>>>>>>>>>        Handle hTable
80095>>>>>>>>>        Boolean bIsSame
80095>>>>>>>>>
80095>>>>>>>>>        Move APITableInfo.iTableNumber      to hTable
80096>>>>>>>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
80097>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
80100>>>>>>>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
80101>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
80104>>>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
80107>>>>>>>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
80108>>>>>>>>>
80108>>>>>>>>>        If (bCompareFilelistUppercase = True) Begin
80110>>>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
80111>>>>>>>>>        End
80111>>>>>>>>>>
80111>>>>>>>>>        Else Begin
80112>>>>>>>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
80113>>>>>>>>>        End
80113>>>>>>>>>>
80113>>>>>>>>>
80113>>>>>>>>>        Function_Return bIsSame
80114>>>>>>>>>    End_Function
80115>>>>>>>>>
80115>>>>>>>>>    Function AutoSetConnectionID String sConnectionID Returns Boolean
80117>>>>>>>>>        Integer iRetval
80117>>>>>>>>>        Move 1 to iRetval
80118>>>>>>>>>        If (ghoSQLConnectionHandler <> 0) Begin
80120>>>>>>>>>            Set psConnectionID of ghoSQLConnectionHandler to sConnectionID
80121>>>>>>>>>            Get AutoSetConnectionID of ghoSQLConnectionHandler to iRetval
80122>>>>>>>>>        End
80122>>>>>>>>>>
80122>>>>>>>>>        Function_Return (iRetval = 0)
80123>>>>>>>>>    End_Function
80124>>>>>>>>>
80124>>>>>>>>>    Function _AddFolderDelimiter String sPath Returns String
80126>>>>>>>>>        String sDirSep
80126>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
80127>>>>>>>>>        Move (Trim(sPath)) to sPath
80128>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
80130>>>>>>>>>            Move (sPath + sDirSep) to sPath
80131>>>>>>>>>        End
80131>>>>>>>>>>
80131>>>>>>>>>        Function_Return sPath
80132>>>>>>>>>    End_Function
80133>>>>>>>>>
80133>>>>>>>>>    Procedure _SqlColumnInfo Handle hoStmt
80135>>>>>>>>>        Integer i iCols iItem
80135>>>>>>>>>        tSqlColumnNew[] aQueryColumns
80135>>>>>>>>>        tSqlColumnNew[] aQueryColumns
80136>>>>>>>>>
80136>>>>>>>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
80137>>>>>>>>>        For i from 1 to iCols
80143>>>>>>>>>>
80143>>>>>>>>>            Move (SizeOfArray(aQueryColumns)) to iItem
80144>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
80145>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
80146>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
80147>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
80148>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
80149>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
80150>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
80151>>>>>>>>>        Loop
80152>>>>>>>>>>
80152>>>>>>>>>        Set piColumns to iCols
80153>>>>>>>>>        Set paQueryColumns to aQueryColumns
80154>>>>>>>>>    End_Procedure
80155>>>>>>>>>
80155>>>>>>>>>    // *** Property Messages ***
80155>>>>>>>>>    //
80155>>>>>>>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
80155>>>>>>>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
80155>>>>>>>>>    //
80155>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
80157>>>>>>>>>        tSQLConnection SQLConnection
80157>>>>>>>>>        tSQLConnection SQLConnection
80157>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80159>>>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
80159>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80160>>>>>>>>>>
80160>>>>>>>>>            Function_Return
80161>>>>>>>>>        End
80161>>>>>>>>>>
80161>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
80162>>>>>>>>>        Function_Return SQLConnection
80163>>>>>>>>>    End_Function
80164>>>>>>>>>
80164>>>>>>>>>    // * Dummy function for the Studio's Code Explorer *
80164>>>>>>>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
80166>>>>>>>>>        Function_Return False
80167>>>>>>>>>    End_Function
80168>>>>>>>>>
80168>>>>>>>>>    Procedure Set psServer String sValue
80170>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80172>>>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
80172>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80173>>>>>>>>>>
80173>>>>>>>>>            Procedure_Return
80174>>>>>>>>>        End
80174>>>>>>>>>>
80174>>>>>>>>>        Set psServer of ghoSQLConnectionHandler to sValue
80175>>>>>>>>>    End_Procedure
80176>>>>>>>>>
80176>>>>>>>>>    Function psServer Returns String
80178>>>>>>>>>        String sValue
80178>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80180>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80181>>>>>>>>>>
80181>>>>>>>>>            Function_Return
80182>>>>>>>>>        End
80182>>>>>>>>>>
80182>>>>>>>>>        Get psServer of ghoSQLConnectionHandler to sValue
80183>>>>>>>>>        Function_Return sValue
80184>>>>>>>>>    End_Function
80185>>>>>>>>>
80185>>>>>>>>>    Procedure Set psDatabase String sValue
80187>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80189>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80190>>>>>>>>>>
80190>>>>>>>>>            Procedure_Return
80191>>>>>>>>>        End
80191>>>>>>>>>>
80191>>>>>>>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
80192>>>>>>>>>    End_Procedure
80193>>>>>>>>>
80193>>>>>>>>>    Function psDatabase Returns String
80195>>>>>>>>>        String sValue
80195>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80197>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80198>>>>>>>>>>
80198>>>>>>>>>            Function_Return
80199>>>>>>>>>        End
80199>>>>>>>>>>
80199>>>>>>>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
80200>>>>>>>>>        Function_Return sValue
80201>>>>>>>>>    End_Function
80202>>>>>>>>>
80202>>>>>>>>>    Procedure Set psUserID String sValue
80204>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80206>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80207>>>>>>>>>>
80207>>>>>>>>>            Procedure_Return
80208>>>>>>>>>        End
80208>>>>>>>>>>
80208>>>>>>>>>        Set psUserID of ghoSQLConnectionHandler to sValue
80209>>>>>>>>>    End_Procedure
80210>>>>>>>>>
80210>>>>>>>>>    Function psUserID Returns String
80212>>>>>>>>>        String sValue
80212>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80214>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80215>>>>>>>>>>
80215>>>>>>>>>            Function_Return
80216>>>>>>>>>        End
80216>>>>>>>>>>
80216>>>>>>>>>        Get psUserID of ghoSQLConnectionHandler to sValue
80217>>>>>>>>>        Function_Return sValue
80218>>>>>>>>>    End_Function
80219>>>>>>>>>
80219>>>>>>>>>    Procedure Set psPassword String sValue
80221>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80223>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80224>>>>>>>>>>
80224>>>>>>>>>            Procedure_Return
80225>>>>>>>>>        End
80225>>>>>>>>>>
80225>>>>>>>>>        Set psPassword of ghoSQLConnectionHandler to sValue
80226>>>>>>>>>    End_Procedure
80227>>>>>>>>>
80227>>>>>>>>>    Function psPassword Returns String
80229>>>>>>>>>        String sValue
80229>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80231>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80232>>>>>>>>>>
80232>>>>>>>>>            Function_Return
80233>>>>>>>>>        End
80233>>>>>>>>>>
80233>>>>>>>>>        Get psPassword of ghoSQLConnectionHandler to sValue
80234>>>>>>>>>        Function_Return sValue
80235>>>>>>>>>    End_Function
80236>>>>>>>>>
80236>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
80238>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80240>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80241>>>>>>>>>>
80241>>>>>>>>>            Procedure_Return
80242>>>>>>>>>        End
80242>>>>>>>>>>
80242>>>>>>>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
80243>>>>>>>>>    End_Procedure
80244>>>>>>>>>
80244>>>>>>>>>    Function pbTrusted Returns Boolean
80246>>>>>>>>>        Boolean bValue
80246>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80248>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80249>>>>>>>>>>
80249>>>>>>>>>            Function_Return
80250>>>>>>>>>        End
80250>>>>>>>>>>
80250>>>>>>>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
80251>>>>>>>>>        Function_Return bValue
80252>>>>>>>>>    End_Function
80253>>>>>>>>>
80253>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
80255>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80257>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80258>>>>>>>>>>
80258>>>>>>>>>            Procedure_Return
80259>>>>>>>>>        End
80259>>>>>>>>>>
80259>>>>>>>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
80260>>>>>>>>>    End_Procedure
80261>>>>>>>>>
80261>>>>>>>>>    Function pbSilentLogin Returns Boolean
80263>>>>>>>>>        Boolean bValue
80263>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80265>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80266>>>>>>>>>>
80266>>>>>>>>>            Function_Return
80267>>>>>>>>>        End
80267>>>>>>>>>>
80267>>>>>>>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
80268>>>>>>>>>        Function_Return bValue
80269>>>>>>>>>    End_Function
80270>>>>>>>>>
80270>>>>>>>>>    Procedure Set psConnectionID String sValue
80272>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80274>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80275>>>>>>>>>>
80275>>>>>>>>>            Procedure_Return
80276>>>>>>>>>        End
80276>>>>>>>>>>
80276>>>>>>>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
80277>>>>>>>>>    End_Procedure
80278>>>>>>>>>
80278>>>>>>>>>    Function psConnectionID Returns String
80280>>>>>>>>>        String sValue
80280>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80282>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80283>>>>>>>>>>
80283>>>>>>>>>            Function_Return
80284>>>>>>>>>        End
80284>>>>>>>>>>
80284>>>>>>>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
80285>>>>>>>>>        Function_Return sValue
80286>>>>>>>>>    End_Function
80287>>>>>>>>>
80287>>>>>>>>>    Procedure Set psConnectionString String sValue
80289>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80291>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80292>>>>>>>>>>
80292>>>>>>>>>            Procedure_Return
80293>>>>>>>>>        End
80293>>>>>>>>>>
80293>>>>>>>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
80294>>>>>>>>>    End_Procedure
80295>>>>>>>>>
80295>>>>>>>>>    Function psConnectionString Returns String
80297>>>>>>>>>        String sValue
80297>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80299>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80300>>>>>>>>>>
80300>>>>>>>>>            Function_Return
80301>>>>>>>>>        End
80301>>>>>>>>>>
80301>>>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
80302>>>>>>>>>        Function_Return sValue
80303>>>>>>>>>    End_Function
80304>>>>>>>>>
80304>>>>>>>>>    // The normal connection string looks something like this;
80304>>>>>>>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
80304>>>>>>>>>    // ...and the full connection string looks like this;
80304>>>>>>>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
80304>>>>>>>>>    Function psFullConnectionString Returns String
80306>>>>>>>>>        String sConnectionID sConnectionString
80306>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80308>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80309>>>>>>>>>>
80309>>>>>>>>>            Function_Return
80310>>>>>>>>>        End
80310>>>>>>>>>>
80310>>>>>>>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
80311>>>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
80312>>>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
80313>>>>>>>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
80314>>>>>>>>>    End_Function
80315>>>>>>>>>
80315>>>>>>>>>    Function piConnectionOptions Returns Integer
80317>>>>>>>>>        Integer iValue
80317>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80319>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80320>>>>>>>>>>
80320>>>>>>>>>            Function_Return
80321>>>>>>>>>        End
80321>>>>>>>>>>
80321>>>>>>>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
80322>>>>>>>>>        Function_Return iValue
80323>>>>>>>>>    End_Function
80324>>>>>>>>>
80324>>>>>>>>>    Procedure Set psSchema String sValue
80326>>>>>>>>>        tSQLConnection SQLConnection
80326>>>>>>>>>        tSQLConnection SQLConnection
80326>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80328>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80329>>>>>>>>>>
80329>>>>>>>>>            Procedure_Return
80330>>>>>>>>>        End
80330>>>>>>>>>>
80330>>>>>>>>>        Set psSchema of ghoSQLConnectionHandler to sValue
80331>>>>>>>>>    End_Procedure
80332>>>>>>>>>
80332>>>>>>>>>    Function psSchema Returns String
80334>>>>>>>>>        String sRetval
80334>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80336>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80337>>>>>>>>>>
80337>>>>>>>>>            Function_Return
80338>>>>>>>>>        End
80338>>>>>>>>>>
80338>>>>>>>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
80339>>>>>>>>>        Function_Return sRetval
80340>>>>>>>>>    End_Function
80341>>>>>>>>>
80341>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
80343>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80345>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80346>>>>>>>>>>
80346>>>>>>>>>            Procedure_Return
80347>>>>>>>>>        End
80347>>>>>>>>>>
80347>>>>>>>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
80348>>>>>>>>>    End_Procedure
80349>>>>>>>>>
80349>>>>>>>>>    Function psBaseTableSpace Returns String
80351>>>>>>>>>        String sRetval
80351>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80353>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80354>>>>>>>>>>
80354>>>>>>>>>            Function_Return
80355>>>>>>>>>        End
80355>>>>>>>>>>
80355>>>>>>>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
80356>>>>>>>>>        Function_Return sRetval
80357>>>>>>>>>    End_Function
80358>>>>>>>>>
80358>>>>>>>>>    Procedure Set psLongTableSpace String sValue
80360>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80362>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80363>>>>>>>>>>
80363>>>>>>>>>            Procedure_Return
80364>>>>>>>>>        End
80364>>>>>>>>>>
80364>>>>>>>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
80365>>>>>>>>>    End_Procedure
80366>>>>>>>>>
80366>>>>>>>>>    Function psLongTableSpace Returns String
80368>>>>>>>>>        String sRetval
80368>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80370>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80371>>>>>>>>>>
80371>>>>>>>>>            Function_Return
80372>>>>>>>>>        End
80372>>>>>>>>>>
80372>>>>>>>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
80373>>>>>>>>>        Function_Return sRetval
80374>>>>>>>>>    End_Function
80375>>>>>>>>>
80375>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
80377>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80379>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80380>>>>>>>>>>
80380>>>>>>>>>            Procedure_Return
80381>>>>>>>>>        End
80381>>>>>>>>>>
80381>>>>>>>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
80382>>>>>>>>>    End_Procedure
80383>>>>>>>>>
80383>>>>>>>>>    Function psIndexTableSpace Returns String
80385>>>>>>>>>        String sRetval
80385>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80387>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80388>>>>>>>>>>
80388>>>>>>>>>            Function_Return
80389>>>>>>>>>        End
80389>>>>>>>>>>
80389>>>>>>>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
80390>>>>>>>>>        Function_Return sRetval
80391>>>>>>>>>    End_Function
80392>>>>>>>>>
80392>>>>>>>>>    Procedure Set pbUseConnectionID Boolean bState
80394>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80396>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80397>>>>>>>>>>
80397>>>>>>>>>            Procedure_Return
80398>>>>>>>>>        End
80398>>>>>>>>>>
80398>>>>>>>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
80399>>>>>>>>>    End_Procedure
80400>>>>>>>>>
80400>>>>>>>>>    Function pbUseConnectionID Returns Boolean
80402>>>>>>>>>        Boolean bState
80402>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80404>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80405>>>>>>>>>>
80405>>>>>>>>>            Function_Return
80406>>>>>>>>>        End
80406>>>>>>>>>>
80406>>>>>>>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
80407>>>>>>>>>        Function_Return bState
80408>>>>>>>>>    End_Function
80409>>>>>>>>>
80409>>>>>>>>>    Procedure Set pbToANSI Boolean bState
80411>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80413>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80414>>>>>>>>>>
80414>>>>>>>>>            Procedure_Return
80415>>>>>>>>>        End
80415>>>>>>>>>>
80415>>>>>>>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
80416>>>>>>>>>    End_Procedure
80417>>>>>>>>>
80417>>>>>>>>>    Function pbToANSI Returns Boolean
80419>>>>>>>>>        Boolean bState
80419>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80421>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80422>>>>>>>>>>
80422>>>>>>>>>            Function_Return
80423>>>>>>>>>        End
80423>>>>>>>>>>
80423>>>>>>>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
80424>>>>>>>>>        Function_Return bState
80425>>>>>>>>>    End_Function
80426>>>>>>>>>
80426>>>>>>>>>    Procedure Set pbRecnum Boolean bState
80428>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80430>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80431>>>>>>>>>>
80431>>>>>>>>>            Procedure_Return
80432>>>>>>>>>        End
80432>>>>>>>>>>
80432>>>>>>>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
80433>>>>>>>>>    End_Procedure
80434>>>>>>>>>
80434>>>>>>>>>    Function pbRecnum Returns Boolean
80436>>>>>>>>>        Boolean bState
80436>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80438>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80439>>>>>>>>>>
80439>>>>>>>>>            Function_Return
80440>>>>>>>>>        End
80440>>>>>>>>>>
80440>>>>>>>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
80441>>>>>>>>>        Function_Return bState
80442>>>>>>>>>    End_Function
80443>>>>>>>>>
80443>>>>>>>>>    Procedure Set pbCopyData Boolean bState
80445>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80447>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80448>>>>>>>>>>
80448>>>>>>>>>            Procedure_Return
80449>>>>>>>>>        End
80449>>>>>>>>>>
80449>>>>>>>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
80450>>>>>>>>>    End_Procedure
80451>>>>>>>>>
80451>>>>>>>>>    Function pbCopyData Returns Boolean
80453>>>>>>>>>        Boolean bState
80453>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80455>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80456>>>>>>>>>>
80456>>>>>>>>>            Function_Return
80457>>>>>>>>>        End
80457>>>>>>>>>>
80457>>>>>>>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
80458>>>>>>>>>        Function_Return bState
80459>>>>>>>>>    End_Function
80460>>>>>>>>>
80460>>>>>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
80462>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80464>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80465>>>>>>>>>>
80465>>>>>>>>>            Procedure_Return
80466>>>>>>>>>        End
80466>>>>>>>>>>
80466>>>>>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
80467>>>>>>>>>    End_Procedure
80468>>>>>>>>>
80468>>>>>>>>>    Function pbApiTableUpdateAuto Returns Boolean
80470>>>>>>>>>        Boolean bState
80470>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80472>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80473>>>>>>>>>>
80473>>>>>>>>>            Function_Return
80474>>>>>>>>>        End
80474>>>>>>>>>>
80474>>>>>>>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
80475>>>>>>>>>        Function_Return bState
80476>>>>>>>>>    End_Function
80477>>>>>>>>>
80477>>>>>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
80479>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80481>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80482>>>>>>>>>>
80482>>>>>>>>>            Procedure_Return
80483>>>>>>>>>        End
80483>>>>>>>>>>
80483>>>>>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
80484>>>>>>>>>    End_Procedure
80485>>>>>>>>>
80485>>>>>>>>>    Function pbCompareDate_DateTime Returns Boolean
80487>>>>>>>>>        Boolean bState
80487>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80489>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80490>>>>>>>>>>
80490>>>>>>>>>            Function_Return
80491>>>>>>>>>        End
80491>>>>>>>>>>
80491>>>>>>>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
80492>>>>>>>>>        Function_Return bState
80493>>>>>>>>>    End_Function
80494>>>>>>>>>
80494>>>>>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
80496>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80498>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80499>>>>>>>>>>
80499>>>>>>>>>            Procedure_Return
80500>>>>>>>>>        End
80500>>>>>>>>>>
80500>>>>>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
80501>>>>>>>>>    End_Procedure
80502>>>>>>>>>
80502>>>>>>>>>    Function pbCompareIndexAscending Returns Boolean
80504>>>>>>>>>        Boolean bState
80504>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80506>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80507>>>>>>>>>>
80507>>>>>>>>>            Function_Return
80508>>>>>>>>>        End
80508>>>>>>>>>>
80508>>>>>>>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
80509>>>>>>>>>        Function_Return bState
80510>>>>>>>>>    End_Function
80511>>>>>>>>>
80511>>>>>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
80513>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80515>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80516>>>>>>>>>>
80516>>>>>>>>>            Procedure_Return
80517>>>>>>>>>        End
80517>>>>>>>>>>
80517>>>>>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
80518>>>>>>>>>    End_Procedure
80519>>>>>>>>>
80519>>>>>>>>>    Function pbCompareIndexUppercase Returns Boolean
80521>>>>>>>>>        Boolean bState
80521>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80523>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80524>>>>>>>>>>
80524>>>>>>>>>            Function_Return
80525>>>>>>>>>        End
80525>>>>>>>>>>
80525>>>>>>>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
80526>>>>>>>>>        Function_Return bState
80527>>>>>>>>>    End_Function
80528>>>>>>>>>
80528>>>>>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
80530>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80532>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80533>>>>>>>>>>
80533>>>>>>>>>            Procedure_Return
80534>>>>>>>>>        End
80534>>>>>>>>>>
80534>>>>>>>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
80535>>>>>>>>>    End_Procedure
80536>>>>>>>>>
80536>>>>>>>>>    Function psDriverDefaultValueASCII Returns String
80538>>>>>>>>>        String sRetval
80538>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80540>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80541>>>>>>>>>>
80541>>>>>>>>>            Function_Return
80542>>>>>>>>>        End
80542>>>>>>>>>>
80542>>>>>>>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
80543>>>>>>>>>        Function_Return sRetval
80544>>>>>>>>>    End_Function
80545>>>>>>>>>
80545>>>>>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
80547>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80549>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80550>>>>>>>>>>
80550>>>>>>>>>            Procedure_Return
80551>>>>>>>>>        End
80551>>>>>>>>>>
80551>>>>>>>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
80552>>>>>>>>>    End_Procedure
80553>>>>>>>>>
80553>>>>>>>>>    Function psDriverDefaultValueBinary Returns String
80555>>>>>>>>>        String sRetval
80555>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80557>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80558>>>>>>>>>>
80558>>>>>>>>>            Function_Return
80559>>>>>>>>>        End
80559>>>>>>>>>>
80559>>>>>>>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
80560>>>>>>>>>        Function_Return sRetval
80561>>>>>>>>>    End_Function
80562>>>>>>>>>
80562>>>>>>>>>    Procedure Set psDriverDefaultValueDate String sValue
80564>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80566>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80567>>>>>>>>>>
80567>>>>>>>>>            Procedure_Return
80568>>>>>>>>>        End
80568>>>>>>>>>>
80568>>>>>>>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
80569>>>>>>>>>    End_Procedure
80570>>>>>>>>>
80570>>>>>>>>>    Function psDriverDefaultValueDate Returns String
80572>>>>>>>>>        String sRetval
80572>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80574>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80575>>>>>>>>>>
80575>>>>>>>>>            Function_Return
80576>>>>>>>>>        End
80576>>>>>>>>>>
80576>>>>>>>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
80577>>>>>>>>>        Function_Return sRetval
80578>>>>>>>>>    End_Function
80579>>>>>>>>>
80579>>>>>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
80581>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80583>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80584>>>>>>>>>>
80584>>>>>>>>>            Procedure_Return
80585>>>>>>>>>        End
80585>>>>>>>>>>
80585>>>>>>>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
80586>>>>>>>>>    End_Procedure
80587>>>>>>>>>
80587>>>>>>>>>    Function psDriverDefaultValueDateTime Returns String
80589>>>>>>>>>        String sRetval
80589>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80591>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80592>>>>>>>>>>
80592>>>>>>>>>            Function_Return
80593>>>>>>>>>        End
80593>>>>>>>>>>
80593>>>>>>>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
80594>>>>>>>>>        Function_Return sRetval
80595>>>>>>>>>    End_Function
80596>>>>>>>>>
80596>>>>>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
80598>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80600>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80601>>>>>>>>>>
80601>>>>>>>>>            Procedure_Return
80602>>>>>>>>>        End
80602>>>>>>>>>>
80602>>>>>>>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
80603>>>>>>>>>    End_Procedure
80604>>>>>>>>>
80604>>>>>>>>>    Function psDriverDefaultValueNumeric Returns String
80606>>>>>>>>>        String sRetval
80606>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80608>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80609>>>>>>>>>>
80609>>>>>>>>>            Function_Return
80610>>>>>>>>>        End
80610>>>>>>>>>>
80610>>>>>>>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
80611>>>>>>>>>        Function_Return sRetval
80612>>>>>>>>>    End_Function
80613>>>>>>>>>
80613>>>>>>>>>    Procedure Set psDriverDefaultValueText String sValue
80615>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80617>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80618>>>>>>>>>>
80618>>>>>>>>>            Procedure_Return
80619>>>>>>>>>        End
80619>>>>>>>>>>
80619>>>>>>>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
80620>>>>>>>>>    End_Procedure
80621>>>>>>>>>
80621>>>>>>>>>    Function psDriverDefaultValueText Returns String
80623>>>>>>>>>        String sRetval
80623>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80625>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80626>>>>>>>>>>
80626>>>>>>>>>            Function_Return
80627>>>>>>>>>        End
80627>>>>>>>>>>
80627>>>>>>>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
80628>>>>>>>>>        Function_Return sRetval
80629>>>>>>>>>    End_Function
80630>>>>>>>>>
80630>>>>>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
80632>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80634>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80635>>>>>>>>>>
80635>>>>>>>>>            Procedure_Return
80636>>>>>>>>>        End
80636>>>>>>>>>>
80636>>>>>>>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
80637>>>>>>>>>    End_Procedure
80638>>>>>>>>>
80638>>>>>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
80640>>>>>>>>>        Boolean bState
80640>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80642>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80643>>>>>>>>>>
80643>>>>>>>>>            Function_Return
80644>>>>>>>>>        End
80644>>>>>>>>>>
80644>>>>>>>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
80645>>>>>>>>>        Function_Return bState
80646>>>>>>>>>    End_Function
80647>>>>>>>>>
80647>>>>>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
80649>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80651>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80652>>>>>>>>>>
80652>>>>>>>>>            Procedure_Return
80653>>>>>>>>>        End
80653>>>>>>>>>>
80653>>>>>>>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
80654>>>>>>>>>    End_Procedure
80655>>>>>>>>>
80655>>>>>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
80657>>>>>>>>>        Boolean bState
80657>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80659>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80660>>>>>>>>>>
80660>>>>>>>>>            Function_Return
80661>>>>>>>>>        End
80661>>>>>>>>>>
80661>>>>>>>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
80662>>>>>>>>>        Function_Return bState
80663>>>>>>>>>    End_Function
80664>>>>>>>>>
80664>>>>>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
80666>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80668>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80669>>>>>>>>>>
80669>>>>>>>>>            Procedure_Return
80670>>>>>>>>>        End
80670>>>>>>>>>>
80670>>>>>>>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
80671>>>>>>>>>    End_Procedure
80672>>>>>>>>>
80672>>>>>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
80674>>>>>>>>>        Boolean bState
80674>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80676>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80677>>>>>>>>>>
80677>>>>>>>>>            Function_Return
80678>>>>>>>>>        End
80678>>>>>>>>>>
80678>>>>>>>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
80679>>>>>>>>>        Function_Return bState
80680>>>>>>>>>    End_Function
80681>>>>>>>>>
80681>>>>>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
80683>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80685>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80686>>>>>>>>>>
80686>>>>>>>>>            Procedure_Return
80687>>>>>>>>>        End
80687>>>>>>>>>>
80687>>>>>>>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
80688>>>>>>>>>    End_Procedure
80689>>>>>>>>>
80689>>>>>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
80691>>>>>>>>>        Boolean bState
80691>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80693>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80694>>>>>>>>>>
80694>>>>>>>>>            Function_Return
80695>>>>>>>>>        End
80695>>>>>>>>>>
80695>>>>>>>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
80696>>>>>>>>>        Function_Return bState
80697>>>>>>>>>    End_Function
80698>>>>>>>>>
80698>>>>>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
80700>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80702>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80703>>>>>>>>>>
80703>>>>>>>>>            Procedure_Return
80704>>>>>>>>>        End
80704>>>>>>>>>>
80704>>>>>>>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
80705>>>>>>>>>    End_Procedure
80706>>>>>>>>>
80706>>>>>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
80708>>>>>>>>>        Boolean bState
80708>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80710>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80711>>>>>>>>>>
80711>>>>>>>>>            Function_Return
80712>>>>>>>>>        End
80712>>>>>>>>>>
80712>>>>>>>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
80713>>>>>>>>>        Function_Return bState
80714>>>>>>>>>    End_Function
80715>>>>>>>>>
80715>>>>>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
80717>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80719>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80720>>>>>>>>>>
80720>>>>>>>>>            Procedure_Return
80721>>>>>>>>>        End
80721>>>>>>>>>>
80721>>>>>>>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
80722>>>>>>>>>    End_Procedure
80723>>>>>>>>>
80723>>>>>>>>>    Function pbDriverDefaultNullableText Returns Boolean
80725>>>>>>>>>        Boolean bState
80725>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80727>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80728>>>>>>>>>>
80728>>>>>>>>>            Function_Return
80729>>>>>>>>>        End
80729>>>>>>>>>>
80729>>>>>>>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
80730>>>>>>>>>        Function_Return bState
80731>>>>>>>>>    End_Function
80732>>>>>>>>>
80732>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
80732>>>>>>>>>    //       the psDriverID *must* be the first property that gets changed!
80732>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
80732>>>>>>>>>    //       for a connection string has the wrong format for that driver.
80732>>>>>>>>>    Procedure Set psDriverID String sValue
80734>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80735>>>>>>>>>        Delegate Set psDriverID to sValue
80737>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80738>>>>>>>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
80739>>>>>>>>>    End_Procedure
80740>>>>>>>>>
80740>>>>>>>>>    Function psDriverID Returns String
80742>>>>>>>>>        String sDriverID
80742>>>>>>>>>
80742>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80743>>>>>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
80743>>>>>>>>>        Delegate Get psDriverID to sDriverID
80745>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80746>>>>>>>>>        Move False to Err
80747>>>>>>>>>
80747>>>>>>>>>        // ...and in case it didn't use property of this class. Then the library is
80747>>>>>>>>>        // probably used as "utilites" from a special made program and
80747>>>>>>>>>        // the ghoSQLConnectionHandler must have been setup
80747>>>>>>>>>        If (sDriverID = "") Begin
80749>>>>>>>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
80750>>>>>>>>>        End
80750>>>>>>>>>>
80750>>>>>>>>>        Function_Return sDriverID
80751>>>>>>>>>    End_Function
80752>>>>>>>>>
80752>>>>>>>>>    Procedure Set piDbType Integer iValue
80754>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80755>>>>>>>>>        Delegate Set piDbType to iValue
80757>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80758>>>>>>>>>        Set piDbType of ghoSQLConnectionHandler to iValue
80759>>>>>>>>>    End_Procedure
80760>>>>>>>>>
80760>>>>>>>>>    Function piDbType Returns Integer
80762>>>>>>>>>        Integer iRetval
80762>>>>>>>>>        Get piDbType of ghoSQLConnectionHandler to iRetval
80763>>>>>>>>>        Function_Return iRetval
80764>>>>>>>>>    End_Function
80765>>>>>>>>>
80765>>>>>>>>>    // Returns the index for the passed sTableName
80765>>>>>>>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
80765>>>>>>>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
80767>>>>>>>>>        Integer iIndex iSize iCount iItem
80767>>>>>>>>>        String[] asTablesArray
80768>>>>>>>>>        String sDatabase sSchema sVal sConnectionString
80768>>>>>>>>>
80768>>>>>>>>>        Move -1 to iIndex
80769>>>>>>>>>        Get psConnectionString to sConnectionString
80770>>>>>>>>>        Get psDatabase to sDatabase
80771>>>>>>>>>        Get psSchema   to sSchema
80772>>>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to asTablesArray
80773>>>>>>>>>        Move (SearchArray(sTableName, asTablesArray, Desktop, (RefFunc(DFSTRICMP)))) to iItem
80774>>>>>>>>>        If (iItem <> -1) Begin
80776>>>>>>>>>            Move iItem to iIndex
80777>>>>>>>>>        End
80777>>>>>>>>>>
80777>>>>>>>>>        Function_Return iIndex
80778>>>>>>>>>    End_Function
80779>>>>>>>>>
80779>>>>>>>>>    // Returns all schemas as a string array for the passed driver id.
80779>>>>>>>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
80781>>>>>>>>>        String[] sReturnArray
80782>>>>>>>>>        Boolean bOK
80782>>>>>>>>>
80782>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80783>>>>>>>>>        If (bOK = False) Begin
80785>>>>>>>>>            Function_Return sReturnArray
80786>>>>>>>>>        End
80786>>>>>>>>>>
80786>>>>>>>>>
80786>>>>>>>>>        Case Begin
80786>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80788>>>>>>>>>                Get _SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
80789>>>>>>>>>                Case Break
80790>>>>>>>>>
80790>>>>>>>>>            Case Else
80790>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
80791>>>>>>>>>>
80791>>>>>>>>>                Case Break
80792>>>>>>>>>        Case End
80792>>>>>>>>>
80792>>>>>>>>>        Function_Return sReturnArray
80793>>>>>>>>>    End_Function
80794>>>>>>>>>
80794>>>>>>>>>    // Returns a string array with all tables for the current database.
80794>>>>>>>>>    Function _SqlUtilEnumerateTables String sDriverID String sDatabase String sSchema Returns String[]
80796>>>>>>>>>        String[] asReturnArray
80797>>>>>>>>>        String sConnectionString sSelect
80797>>>>>>>>>        Integer iSize iCount iDbType
80797>>>>>>>>>        Boolean bOK
80797>>>>>>>>>
80797>>>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
80799>>>>>>>>>            Function_Return asReturnArray
80800>>>>>>>>>        End
80800>>>>>>>>>>
80800>>>>>>>>>
80800>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80801>>>>>>>>>        If (bOK = False) Begin
80803>>>>>>>>>            Function_Return asReturnArray
80804>>>>>>>>>        End
80804>>>>>>>>>>
80804>>>>>>>>>        If (sSchema = "") Begin
80806>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
80807>>>>>>>>>        End
80807>>>>>>>>>>
80807>>>>>>>>>
80807>>>>>>>>>        Get psConnectionString to sConnectionString
80808>>>>>>>>>
80808>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
80808>>>>>>>>>        // the dbType.
80808>>>>>>>>>        Get piDbType to iDbType
80809>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
80811>>>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
80813>>>>>>>>>                Move MSSQLDRV_ID to sDriverID
80814>>>>>>>>>            End
80814>>>>>>>>>>
80814>>>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
80816>>>>>>>>>                Move DB2_DRV_ID to sDriverID
80817>>>>>>>>>            End
80817>>>>>>>>>>
80817>>>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
80819>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
80820>>>>>>>>>            End
80820>>>>>>>>>>
80820>>>>>>>>>        End
80820>>>>>>>>>>
80820>>>>>>>>>
80820>>>>>>>>>        Case Begin
80820>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80822>>>>>>>>>                Get _SqlTableArrayDAW to asReturnArray
80823>>>>>>>>>                Case Break
80824>>>>>>>>>
80824>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80827>>>>>>>>>                Get _SqlTableArrayDAW to asReturnArray
80828>>>>>>>>>                Case Break
80829>>>>>>>>>
80829>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
80832>>>>>>>>>                Get _SqlTableArrayDAW to asReturnArray
80833>>>>>>>>>                Case Break
80834>>>>>>>>>
80834>>>>>>>>>            Case Else
80834>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTables function."
80835>>>>>>>>>>
80835>>>>>>>>>                Case Break
80836>>>>>>>>>        Case End
80836>>>>>>>>>
80836>>>>>>>>>        Function_Return asReturnArray
80837>>>>>>>>>    End_Function
80838>>>>>>>>>
80838>>>>>>>>>    // Returns all table spaces as a string array for the passed driver id.
80838>>>>>>>>>    Function _SqlUtilEnumerateTablespaces String sDriverID Returns String[]
80840>>>>>>>>>        String[] sReturnArray
80841>>>>>>>>>        Boolean bOK
80841>>>>>>>>>
80841>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80842>>>>>>>>>        If (bOK = False) Begin
80844>>>>>>>>>            Function_Return sReturnArray
80845>>>>>>>>>        End
80845>>>>>>>>>>
80845>>>>>>>>>
80845>>>>>>>>>        Case Begin
80845>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80847>>>>>>>>>                Get _SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
80848>>>>>>>>>                Case Break
80849>>>>>>>>>
80849>>>>>>>>>            Case Else
80849>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTablespaces function."
80850>>>>>>>>>>
80850>>>>>>>>>                Case Break
80851>>>>>>>>>        Case End
80851>>>>>>>>>
80851>>>>>>>>>        Function_Return sReturnArray
80852>>>>>>>>>    End_Function
80853>>>>>>>>>
80853>>>>>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
80853>>>>>>>>>    Function _SqlUtilEnumerateColumnsByHandle String sDriverID Handle hTable Returns String[]
80855>>>>>>>>>        String[] asReturnArray
80856>>>>>>>>>        String sRootName sTableName
80856>>>>>>>>>        
80856>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
80859>>>>>>>>>        Get _TableNameOnly sRootName to sTableName
80860>>>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to asReturnArray
80861>>>>>>>>>        Function_Return asReturnArray
80862>>>>>>>>>    End_Function
80863>>>>>>>>>
80863>>>>>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
80863>>>>>>>>>    Function _SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
80865>>>>>>>>>        String[] sReturnArray
80866>>>>>>>>>        String sConnectionString sSelect sSchema
80866>>>>>>>>>        Boolean bOK
80866>>>>>>>>>        Integer iDbType
80866>>>>>>>>>
80866>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80867>>>>>>>>>        If (bOK = False) Begin
80869>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80870>>>>>>>>>>
80870>>>>>>>>>            Function_Return sReturnArray
80871>>>>>>>>>        End
80871>>>>>>>>>>
80871>>>>>>>>>
80871>>>>>>>>>        Get psConnectionString to sConnectionString
80872>>>>>>>>>        Get psSchema to sSchema
80873>>>>>>>>>
80873>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
80873>>>>>>>>>        // the dbType.
80873>>>>>>>>>        Get piDbType to iDbType
80874>>>>>>>>>
80874>>>>>>>>>        Case Begin
80874>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
80876>>>>>>>>>                If (iDbType = EN_DbTypeMySQL) Begin
80878>>>>>>>>>                    Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
80879>>>>>>>>>                End
80879>>>>>>>>>>
80879>>>>>>>>>                If (iDbType = EN_DbTypePostgre) Begin
80881>>>>>>>>>                    Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
80882>>>>>>>>>                End
80882>>>>>>>>>>
80882>>>>>>>>>                If (iDbType = EN_DbTypeMSSQL) Begin
80884>>>>>>>>>                    Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
80885>>>>>>>>>                End
80885>>>>>>>>>>
80885>>>>>>>>>
80885>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80886>>>>>>>>>                Case Break
80887>>>>>>>>>
80887>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80890>>>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
80891>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80892>>>>>>>>>                Case Break
80893>>>>>>>>>
80893>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80896>>>>>>>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
80897>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80898>>>>>>>>>                Case Break
80899>>>>>>>>>
80899>>>>>>>>>            Case Else
80899>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateColumns function."
80900>>>>>>>>>>
80900>>>>>>>>>                Case Break
80901>>>>>>>>>        Case End
80901>>>>>>>>>
80901>>>>>>>>>        Function_Return sReturnArray
80902>>>>>>>>>    End_Function
80903>>>>>>>>>
80903>>>>>>>>>
80903>>>>>>>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
80903>>>>>>>>>    Function _SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
80905>>>>>>>>>        String[] asReturnArray asReturnArray2
80907>>>>>>>>>        String sConnectionString sSelect sSchema
80907>>>>>>>>>        Boolean bOK
80907>>>>>>>>>        Integer iCount iSize
80907>>>>>>>>>
80907>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80908>>>>>>>>>        If (bOK = False) Begin
80910>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80911>>>>>>>>>>
80911>>>>>>>>>            Function_Return asReturnArray
80912>>>>>>>>>        End
80912>>>>>>>>>>
80912>>>>>>>>>
80912>>>>>>>>>        Get psConnectionString to sConnectionString
80913>>>>>>>>>        Get psSchema to sSchema
80914>>>>>>>>>
80914>>>>>>>>>        Case Begin
80914>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80916>>>>>>>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
80917>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to asReturnArray
80918>>>>>>>>>                Case Break
80919>>>>>>>>>
80919>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80922>>>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
80923>>>>>>>>>>
80923>>>>>>>>>//                Move () to sSelect
80923>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to asReturnArray
80923>>>>>>>>>                Case Break
80924>>>>>>>>>
80924>>>>>>>>>            Case Else
80924>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateIndexes function."
80925>>>>>>>>>>
80925>>>>>>>>>                Case Break
80926>>>>>>>>>        Case End
80926>>>>>>>>>
80926>>>>>>>>>        Move (SizeOfArray(asReturnArray)) to iSize
80927>>>>>>>>>        Decrement iSize
80928>>>>>>>>>        For iCount from 0 to iSize
80934>>>>>>>>>>
80934>>>>>>>>>            If (Trim(asReturnArray[iCount]) <> "") Begin
80936>>>>>>>>>                Move asReturnArray[iCount] to asReturnArray2[SizeOfArray(asReturnArray2)]
80937>>>>>>>>>            End
80937>>>>>>>>>>
80937>>>>>>>>>        Loop
80938>>>>>>>>>>
80938>>>>>>>>>
80938>>>>>>>>>        Function_Return asReturnArray2
80939>>>>>>>>>    End_Function
80940>>>>>>>>>
80940>>>>>>>>>    // Returns a string array with all table names the passed table handle has relation ships with.
80940>>>>>>>>>    // The format of the array is "TableName.FieldName"
80940>>>>>>>>>    Function _SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
80942>>>>>>>>>        String[] sFileNameArray sFieldNameArray
80944>>>>>>>>>        tSQLRelation[] sRelationsArray
80944>>>>>>>>>        tSQLRelation[] sRelationsArray
80945>>>>>>>>>        String sConnectionString sSelect sSchema sFileName sFieldName
80945>>>>>>>>>        Boolean bOK
80945>>>>>>>>>        Integer iCount iSize iLength
80945>>>>>>>>>
80945>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80946>>>>>>>>>        If (bOK = False) Begin
80948>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80949>>>>>>>>>>
80949>>>>>>>>>            Function_Return sRelationsArray
80950>>>>>>>>>        End
80950>>>>>>>>>>
80950>>>>>>>>>
80950>>>>>>>>>        Get psConnectionString to sConnectionString
80951>>>>>>>>>        Get psSchema to sSchema
80952>>>>>>>>>
80952>>>>>>>>>        Case Begin
80952>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80954>>>>>>>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
80955>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
80956>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
80957>>>>>>>>>                Case Break
80958>>>>>>>>>
80958>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80961>>>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
80962>>>>>>>>>>
80962>>>>>>>>>//                Move () to sSelect
80962>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80962>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
80962>>>>>>>>>                Case Break
80963>>>>>>>>>
80963>>>>>>>>>            Case Else
80963>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to the _SqlUtilEnumerateRelations function."
80964>>>>>>>>>>
80964>>>>>>>>>                Case Break
80965>>>>>>>>>        Case End
80965>>>>>>>>>
80965>>>>>>>>>        Move (Length(sTableName)) to iLength
80966>>>>>>>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
80967>>>>>>>>>        Move (SizeOfArray(sFileNameArray)) to iSize
80968>>>>>>>>>        Decrement iSize
80969>>>>>>>>>        For iCount from 0 to iSize
80975>>>>>>>>>>
80975>>>>>>>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
80977>>>>>>>>>                Move sFileNameArray[iCount]         to sFileName
80978>>>>>>>>>                Move sFieldNameArray[iCount]        to sFieldName
80979>>>>>>>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
80980>>>>>>>>>                Move sFileName  to sRelationsArray[iCount].sFileName
80981>>>>>>>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
80982>>>>>>>>>            End
80982>>>>>>>>>>
80982>>>>>>>>>        Loop
80983>>>>>>>>>>
80983>>>>>>>>>
80983>>>>>>>>>        Function_Return sRelationsArray
80984>>>>>>>>>    End_Function
80985>>>>>>>>>
80985>>>>>>>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
80987>>>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
80987>>>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
80988>>>>>>>>>        String[] sUsers sPrograms
80990>>>>>>>>>        String sSelect
80990>>>>>>>>>        Integer iSize iCount
80990>>>>>>>>>
80990>>>>>>>>>        Case Begin
80990>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80992>>>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
80993>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sUsers
80994>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sPrograms
80995>>>>>>>>>                Case Break
80996>>>>>>>>>            Case Else
80996>>>>>>>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
80997>>>>>>>>>>
80997>>>>>>>>>        Case End
80997>>>>>>>>>
80997>>>>>>>>>        Move (SizeOfArray(sUsers)) to iSize
80998>>>>>>>>>        Decrement iSize
80999>>>>>>>>>        For iCount from 0 to iSize
81005>>>>>>>>>>
81005>>>>>>>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
81006>>>>>>>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
81007>>>>>>>>>        Loop
81008>>>>>>>>>>
81008>>>>>>>>>
81008>>>>>>>>>        Function_Return SQLLoggedInUser
81009>>>>>>>>>    End_Function
81010>>>>>>>>>
81010>>>>>>>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
81010>>>>>>>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
81010>>>>>>>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
81012>>>>>>>>>        String[] sFilesData
81013>>>>>>>>>        Boolean bExists
81013>>>>>>>>>        Integer iCh
81013>>>>>>>>>        String sFileName sExt
81013>>>>>>>>>
81013>>>>>>>>>        Get vFolderExists sDataPath to bExists
81014>>>>>>>>>        If (bExists = True) Begin
81016>>>>>>>>>            Move (Utf8ToAnsi(Trim(sDataPath))) to sDataPath
81017>>>>>>>>>            Move ("dir:" + sDataPath)      to sDataPath
81018>>>>>>>>>            Get Seq_New_Channel to iCh  // get free channel for input
81019>>>>>>>>>            Direct_Input channel iCh sDataPath
81021>>>>>>>>>                Repeat
81021>>>>>>>>>>
81021>>>>>>>>>                    Readln channel iCh sFileName
81023>>>>>>>>>                    Get ParseFileExtension sFileName to sExt
81024>>>>>>>>>                    If (Uppercase(sExt) = "INT") Begin
81026>>>>>>>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
81028>>>>>>>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
81029>>>>>>>>>                        End
81029>>>>>>>>>>
81029>>>>>>>>>                    End
81029>>>>>>>>>>
81029>>>>>>>>>                Until (SeqEof = True)
81031>>>>>>>>>            Close_Input channel iCh
81033>>>>>>>>>            Send Seq_Release_Channel iCh
81034>>>>>>>>>        End
81034>>>>>>>>>>
81034>>>>>>>>>        Function_Return sFilesData
81035>>>>>>>>>    End_Function
81036>>>>>>>>>
81036>>>>>>>>>    // Only done for MSSQLDRV_ID so far...
81036>>>>>>>>>    Function _SqlEnumerateDatabaseCollations String sDriverID Returns String[]
81038>>>>>>>>>        String sSQL sConnectionID sConnectionString sSelect sName sPre
81038>>>>>>>>>        String sDescription sFrom sSys sValue sPrevious
81038>>>>>>>>>        Handle hStmt hoSQLManager hoSQLConnect
81038>>>>>>>>>        Integer iFetchResult iRows iColumn iPos
81038>>>>>>>>>        tSQLConnection SQLConnection
81038>>>>>>>>>        tSQLConnection SQLConnection
81038>>>>>>>>>        String[] asCollations
81039>>>>>>>>>        
81039>>>>>>>>>        If (sDriverID = "") Begin
81041>>>>>>>>>            Error DFERR_PROGRAM "The database driver ID was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
81042>>>>>>>>>>
81042>>>>>>>>>            Function_Return asCollations
81043>>>>>>>>>        End
81043>>>>>>>>>>
81043>>>>>>>>>
81043>>>>>>>>>        // Only done for MSSQLDRV_ID so far...
81043>>>>>>>>>        If (sDriverID <> MSSQLDRV_ID) Begin
81045>>>>>>>>>            Function_Return asCollations
81046>>>>>>>>>        End                 
81046>>>>>>>>>>
81046>>>>>>>>>
81046>>>>>>>>>        Get phoSQLManager to hoSQLManager
81047>>>>>>>>>        Get psConnectionID     to sConnectionID
81048>>>>>>>>>        Get psConnectionString to sConnectionString
81049>>>>>>>>>        Move 0 to LastErr
81050>>>>>>>>>
81050>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81051>>>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hoSQLConnect
81052>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81053>>>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
81055>>>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
81056>>>>>>>>>>
81056>>>>>>>>>            Function_Return asCollations
81057>>>>>>>>>        End
81057>>>>>>>>>>
81057>>>>>>>>>
81057>>>>>>>>>        Get SqlOpen of hoSQLConnect to hStmt
81058>>>>>>>>>
81058>>>>>>>>>        If (hStmt = 0) Begin
81060>>>>>>>>>            Send SqlDisconnect of hoSQLManager
81061>>>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
81062>>>>>>>>>>
81062>>>>>>>>>            Function_Return asCollations
81063>>>>>>>>>        End
81063>>>>>>>>>>
81063>>>>>>>>>
81063>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect      to sSelect
81064>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName        to sName
81065>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDescription to sDescription
81066>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom        to sFrom
81067>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys         to sSys
81068>>>>>>>>>
81068>>>>>>>>>        // MS-SQL Syntax:  
81068>>>>>>>>>        // SELECT name, description
81068>>>>>>>>>        //   from sys.fn_helpcollations();
81068>>>>>>>>>        Move (sSelect  * String(sName) * String(",") * String(sDescription) * String(sFrom) * String(sSys) * String(".fn_helpcollations();")) to sSQL
81069>>>>>>>>>
81069>>>>>>>>>        Move 1 to iColumn
81070>>>>>>>>>        Send SqlExecDirect of hStmt sSQL
81071>>>>>>>>>        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
81072>>>>>>>>>        Repeat
81072>>>>>>>>>>
81072>>>>>>>>>            Get SQLFetch of hStmt to iFetchResult
81073>>>>>>>>>            If (iFetchResult <> 0) Begin
81075>>>>>>>>>                Get SQLColumnValue of hStmt iColumn to sValue 
81076>>>>>>>>>                If (sValue <> sPrevious) Begin         
81078>>>>>>>>>                    // We need to skip all collations starting with "SQL" because they
81078>>>>>>>>>                    // are obsolete and for pre-SQL Server 2000.
81078>>>>>>>>>                    Move (Pos("SQL", Uppercase(sValue))) to iPos
81079>>>>>>>>>                    If (iPos <> 1) Begin
81081>>>>>>>>>                        Move (Trim(sValue)) to asCollations[SizeOfArray(asCollations)
81082>>>>>>>>>                    End
81082>>>>>>>>>>
81082>>>>>>>>>                End
81082>>>>>>>>>>
81082>>>>>>>>>                Move sValue to sPrevious
81083>>>>>>>>>            End
81083>>>>>>>>>>
81083>>>>>>>>>        Until (iFetchResult = 0)
81085>>>>>>>>>        Send SQLClose of hStmt
81086>>>>>>>>>        Send SQLDisconnect of hoSQLConnect
81087>>>>>>>>>
81087>>>>>>>>>        Function_Return asCollations
81088>>>>>>>>>    End_Function
81089>>>>>>>>>
81089>>>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
81089>>>>>>>>>    // for DAW drivers.
81089>>>>>>>>>    // Returns: A string array.
81089>>>>>>>>>    Function _SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
81091>>>>>>>>>        String[] sReturnArray
81092>>>>>>>>>        String sValue sPrevious
81092>>>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
81092>>>>>>>>>        Integer iFetchResult iRows
81092>>>>>>>>>        tSQLConnection SQLConnection
81092>>>>>>>>>        tSQLConnection SQLConnection
81092>>>>>>>>>
81092>>>>>>>>>        Get phoSQLManager to hoSQLHandler
81093>>>>>>>>>
81093>>>>>>>>>        If (hoSQLHandler <> 0) Begin
81095>>>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81096>>>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
81097>>>>>>>>>
81097>>>>>>>>>            If (hoSQLConnect <> 0) Begin
81099>>>>>>>>>                Get SQLOpen of hoSQLConnect to hstmt
81100>>>>>>>>>                If (hstmt <> 0) Begin
81102>>>>>>>>>                    Send SqlExecDirect of hstmt sStmt
81103>>>>>>>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
81104>>>>>>>>>                    Repeat
81104>>>>>>>>>>
81104>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
81105>>>>>>>>>                        If (iFetchResult <> 0) Begin
81107>>>>>>>>>                            Get SQLColumnValue of hstmt iColumn to sValue
81108>>>>>>>>>                            If (sValue <> sPrevious) Begin
81110>>>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
81111>>>>>>>>>                            End
81111>>>>>>>>>>
81111>>>>>>>>>                            Move sValue to sPrevious
81112>>>>>>>>>                        End
81112>>>>>>>>>>
81112>>>>>>>>>                    Until (iFetchResult = 0)
81114>>>>>>>>>                    Send SQLClose of hstmt
81115>>>>>>>>>                End
81115>>>>>>>>>>
81115>>>>>>>>>                Send SQLDisconnect of hoSQLConnect
81116>>>>>>>>>            End
81116>>>>>>>>>>
81116>>>>>>>>>        End
81116>>>>>>>>>>
81116>>>>>>>>>
81116>>>>>>>>>        Function_Return sReturnArray
81117>>>>>>>>>    End_Function
81118>>>>>>>>>
81118>>>>>>>>>    Function _SqlDatabasesArrayDB2 Returns String[]
81120>>>>>>>>>        String[] sReturnArray
81121>>>>>>>>>        String sDataSource
81121>>>>>>>>>        Handle hoSQLHandler
81121>>>>>>>>>        Integer iItem
81121>>>>>>>>>
81121>>>>>>>>>        Get phoDB2SQLHandler to hoSQLHandler
81122>>>>>>>>>        Send SeedDataSources of hoSQLHandler
81123>>>>>>>>>
81123>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81124>>>>>>>>>
81124>>>>>>>>>        Repeat
81124>>>>>>>>>>
81124>>>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
81125>>>>>>>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
81126>>>>>>>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
81127>>>>>>>>>            Increment iItem
81128>>>>>>>>>        Until (sDataSource = "")
81130>>>>>>>>>
81130>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81131>>>>>>>>>
81131>>>>>>>>>        Function_Return sReturnArray
81132>>>>>>>>>    End_Function
81133>>>>>>>>>
81133>>>>>>>>>    Function _SqlDatabaseSourcesArrayODBC Returns String[]
81135>>>>>>>>>        String[] sReturnArray
81136>>>>>>>>>        String sDataSource
81136>>>>>>>>>        Handle hoSQLHandler
81136>>>>>>>>>        Integer iItem
81136>>>>>>>>>
81136>>>>>>>>>        Get phoODBCSQLHandler to hoSQLHandler
81137>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81138>>>>>>>>>
81138>>>>>>>>>        Send SeedDataSources of hoSQLHandler
81139>>>>>>>>>
81139>>>>>>>>>        Repeat
81139>>>>>>>>>>
81139>>>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
81140>>>>>>>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
81142>>>>>>>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
81143>>>>>>>>>                Increment iItem
81144>>>>>>>>>            End
81144>>>>>>>>>>
81144>>>>>>>>>        Until (sDataSource = "")
81146>>>>>>>>>
81146>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81147>>>>>>>>>
81147>>>>>>>>>        Function_Return sReturnArray
81148>>>>>>>>>    End_Function
81149>>>>>>>>>
81149>>>>>>>>>    Function _SqlDatabasesArrayODBC Returns tSQLIntTableInfo[]
81151>>>>>>>>>        String[] sDataSources
81152>>>>>>>>>        tSQLConnection SQLConnection
81152>>>>>>>>>        tSQLConnection SQLConnection
81152>>>>>>>>>        tSQLIntTableInfo[] sReturnArray
81152>>>>>>>>>        tSQLIntTableInfo[] sReturnArray
81153>>>>>>>>>        Integer iDataSources iCount iItem
81153>>>>>>>>>        String sConnection sServer sDatabase sKey sSubKey
81153>>>>>>>>>        Handle hoIniFile hoRegistry hoODBCDataSources
81153>>>>>>>>>        Boolean bExists bKeyOpened
81153>>>>>>>>>
81153>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81154>>>>>>>>>        Move SQLConnection.sConnectionString to sConnection
81155>>>>>>>>>        Move SQLConnection.sServer           to sServer
81156>>>>>>>>>
81156>>>>>>>>>        // FileDSN - read DATABASE name from DSN ini-file
81156>>>>>>>>>        If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
81158>>>>>>>>>            Get Create (RefClass(cIniFile)) to hoIniFile
81159>>>>>>>>>            Set psFileName of hoIniFile to sServer
81160>>>>>>>>>            Get ReadString of hoIniFile CS_SQLODBCIniSectionName CS_SQLIniDatabaseKeyword "" to sDatabase
81161>>>>>>>>>            Move sDatabase to sReturnArray[0].sDatabaseName
81162>>>>>>>>>            Send Destroy of hoIniFile
81163>>>>>>>>>        End
81163>>>>>>>>>>
81163>>>>>>>>>
81163>>>>>>>>>        // DSN - read DATABASE name from the registry
81163>>>>>>>>>        Else Begin
81164>>>>>>>>>            Get Create (RefClass(cRegistry)) to hoRegistry
81165>>>>>>>>>
81165>>>>>>>>>            // We start with checking the "System DNS" area in the registry as it is the
81165>>>>>>>>>            // most probably place the info is kept that we're after.
81165>>>>>>>>>            Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
81166>>>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
81167>>>>>>>>>            Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
81168>>>>>>>>>            If (bExists = True) Begin
81170>>>>>>>>>                Move "SOFTWARE\Wow6432Node\ODBC\ODBC.INI" to sKey
81171>>>>>>>>>            End
81171>>>>>>>>>>
81171>>>>>>>>>            Else Begin
81172>>>>>>>>>                Move "SOFTWARE\ODBC\ODBC.INI" to sKey
81173>>>>>>>>>            End
81173>>>>>>>>>>
81173>>>>>>>>>
81173>>>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
81174>>>>>>>>>            If (bExists) Begin
81176>>>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
81177>>>>>>>>>                If (bKeyOpened) Begin
81179>>>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
81180>>>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
81181>>>>>>>>>                    If (iDataSources > 0) Begin
81183>>>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
81184>>>>>>>>>                        Decrement iDataSources
81185>>>>>>>>>                        for iCount from 0 to iDataSources
81191>>>>>>>>>>
81191>>>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
81192>>>>>>>>>                        Loop
81193>>>>>>>>>>
81193>>>>>>>>>                        Move 0 to iItem
81194>>>>>>>>>                        for iCount from 0 to iDataSources
81200>>>>>>>>>>
81200>>>>>>>>>                            Move sDataSources[iCount] to sSubKey
81201>>>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
81202>>>>>>>>>                            If (bKeyOpened = True) Begin
81204>>>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
81205>>>>>>>>>                                If (bExists = True) Begin
81207>>>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
81208>>>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
81209>>>>>>>>>                                    Increment iItem
81210>>>>>>>>>                                End
81210>>>>>>>>>>
81210>>>>>>>>>                            End
81210>>>>>>>>>>
81210>>>>>>>>>                        Loop
81211>>>>>>>>>>
81211>>>>>>>>>                    End
81211>>>>>>>>>>
81211>>>>>>>>>                    Send CloseKey of hoRegistry
81212>>>>>>>>>                    Send Destroy of hoODBCDataSources
81213>>>>>>>>>                End
81213>>>>>>>>>>
81213>>>>>>>>>            End
81213>>>>>>>>>>
81213>>>>>>>>>
81213>>>>>>>>>            // We then check the "User DNS" area in the registry.
81213>>>>>>>>>            Set phRootKey of hoRegistry to HKEY_CURRENT_USER
81214>>>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
81215>>>>>>>>>            Move "SOFTWARE\ODBC\ODBC.INI" to sKey
81216>>>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
81217>>>>>>>>>
81217>>>>>>>>>            If (bExists) Begin
81219>>>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
81220>>>>>>>>>                If (bKeyOpened) Begin
81222>>>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
81223>>>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
81224>>>>>>>>>                    If (iDataSources > 0) Begin
81226>>>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
81227>>>>>>>>>                        Decrement iDataSources
81228>>>>>>>>>                        for iCount from 0 to iDataSources
81234>>>>>>>>>>
81234>>>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
81235>>>>>>>>>                        Loop
81236>>>>>>>>>>
81236>>>>>>>>>                        for iCount from 0 to iDataSources
81242>>>>>>>>>>
81242>>>>>>>>>                            Move sDataSources[iCount] to sSubKey
81243>>>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
81244>>>>>>>>>                            If (bKeyOpened = True) Begin
81246>>>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
81247>>>>>>>>>                                If (bExists = True) Begin
81249>>>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
81250>>>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
81251>>>>>>>>>                                    Increment iItem
81252>>>>>>>>>                                End
81252>>>>>>>>>>
81252>>>>>>>>>                            End
81252>>>>>>>>>>
81252>>>>>>>>>                        Loop
81253>>>>>>>>>>
81253>>>>>>>>>                    End
81253>>>>>>>>>>
81253>>>>>>>>>                    Send CloseKey of hoRegistry
81254>>>>>>>>>                    Send Destroy of hoODBCDataSources
81255>>>>>>>>>                End
81255>>>>>>>>>>
81255>>>>>>>>>            End
81255>>>>>>>>>>
81255>>>>>>>>>
81255>>>>>>>>>            Send Destroy of hoRegistry
81256>>>>>>>>>        End
81256>>>>>>>>>>
81256>>>>>>>>>
81256>>>>>>>>>        Function_Return sReturnArray
81257>>>>>>>>>    End_Function
81258>>>>>>>>>
81258>>>>>>>>>    // We might have a split Sql script where the info about which database to use is
81258>>>>>>>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
81258>>>>>>>>>    // insert it for scriplets to come after the first one.
81258>>>>>>>>>    Function _SqlFormatStatement String sStmt Returns String
81260>>>>>>>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
81260>>>>>>>>>        Integer iStart iEnd iDbType
81260>>>>>>>>>        Boolean bOK
81260>>>>>>>>>
81260>>>>>>>>>        Get piDbType to iDbType
81261>>>>>>>>>        Get psDriverID to sDriverID
81262>>>>>>>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
81263>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
81264>>>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
81265>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
81266>>>>>>>>>        Move (Replaces(" ", sStmt, "")) to sTmp
81267>>>>>>>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
81269>>>>>>>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
81270>>>>>>>>>            Move (Pos("]", sTmp)) to iEnd
81271>>>>>>>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
81272>>>>>>>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
81273>>>>>>>>>            Set Private.psUseDatabase to sUseDatabase
81274>>>>>>>>>        End
81274>>>>>>>>>>
81274>>>>>>>>>        Else Begin
81275>>>>>>>>>            Move (Uppercase(sStmt)) to sTmp
81276>>>>>>>>>
81276>>>>>>>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
81276>>>>>>>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
81278>>>>>>>>>                Get Private.psUseDatabase to sUseDatabase
81279>>>>>>>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
81280>>>>>>>>>            End
81280>>>>>>>>>>
81280>>>>>>>>>
81280>>>>>>>>>            // This is a bit special to place here but was done so because it was easier that way.
81280>>>>>>>>>            // We will get an error when trying to create a view if it already exists.
81280>>>>>>>>>            // So to avoid such errors; we first remove it & then recreate it.
81280>>>>>>>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
81283>>>>>>>>>                // Make sure we only have one space between statements/words.
81283>>>>>>>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
81284>>>>>>>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
81285>>>>>>>>>                Move (Trim(sTmp)) to sTmp
81286>>>>>>>>>                Move (Pos(" ", sTmp)) to iEnd
81287>>>>>>>>>                Move (Left(sTmp, iEnd)) to sTmp
81288>>>>>>>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
81290>>>>>>>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
81291>>>>>>>>>                End
81291>>>>>>>>>>
81291>>>>>>>>>                Move (Trim(sTmp)) to sTmp
81292>>>>>>>>>                // Remove data view as it already exists!
81292>>>>>>>>>                Get _SqlViewRemove sDriverID sTmp to bOK
81293>>>>>>>>>            End
81293>>>>>>>>>>
81293>>>>>>>>>        End
81293>>>>>>>>>>
81293>>>>>>>>>
81293>>>>>>>>>        Function_Return sStmt
81294>>>>>>>>>    End_Function
81295>>>>>>>>>
81295>>>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
81295>>>>>>>>>    Function _SqlViewRemove String sDataView Returns Boolean
81297>>>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
81297>>>>>>>>>        Integer iRetval
81297>>>>>>>>>        Boolean bOK
81297>>>>>>>>>
81297>>>>>>>>>        Get psDriverID to sDriverID
81298>>>>>>>>>        Get _UtilDeleteCacheFile sDataView to iRetval
81299>>>>>>>>>
81299>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
81300>>>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
81301>>>>>>>>>        Set psSQLStatementString to sSQLString
81302>>>>>>>>>
81302>>>>>>>>>        // As we don't check if the view exist or not, it might happen
81302>>>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
81302>>>>>>>>>        Move False to Err
81303>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
81304>>>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
81305>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
81306>>>>>>>>>        Move 0 to LastErr
81307>>>>>>>>>
81307>>>>>>>>>        // We also need to remove the cache-file since the table has been changed
81307>>>>>>>>>        Get _UtilDeleteCacheFile sDataView to bOK
81308>>>>>>>>>        Send ResetFillSQLTables
81309>>>>>>>>>
81309>>>>>>>>>        Function_Return (Err = False)
81310>>>>>>>>>    End_Function
81311>>>>>>>>>
81311>>>>>>>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
81311>>>>>>>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
81313>>>>>>>>>        String sRetval
81313>>>>>>>>>        Integer iDbType iIndex
81313>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
81313>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
81314>>>>>>>>>        tSQLKeyWords   SQLKeyWords
81314>>>>>>>>>        tSQLKeyWords   SQLKeyWords
81314>>>>>>>>>
81314>>>>>>>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
81314>>>>>>>>>        Move "" to sRetval
81315>>>>>>>>>        Get piDbType to iDbType
81316>>>>>>>>>        Move iDbType             to SQLKeyWords.iSQLDbType
81317>>>>>>>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
81318>>>>>>>>>
81318>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
81319>>>>>>>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
81320>>>>>>>>>        If (iIndex >= 0) Begin
81322>>>>>>>>>            Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
81323>>>>>>>>>        End
81323>>>>>>>>>>
81323>>>>>>>>>
81323>>>>>>>>>        Function_Return sRetval
81324>>>>>>>>>    End_Function
81325>>>>>>>>>
81325>>>>>>>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
81325>>>>>>>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
81327>>>>>>>>>        String[] sSQLScriptArray
81328>>>>>>>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
81328>>>>>>>>>        Integer iSize iCount
81328>>>>>>>>>        Boolean bCommentStart bCommentEnd bDashComment
81328>>>>>>>>>
81328>>>>>>>>>        Move False to bCommentStart
81329>>>>>>>>>        Move False to bCommentEnd
81330>>>>>>>>>        Move False to bDashComment
81331>>>>>>>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
81332>>>>>>>>>        Move "*/"  to sCommentEnd
81333>>>>>>>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
81334>>>>>>>>>
81334>>>>>>>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
81335>>>>>>>>>        Decrement iSize
81336>>>>>>>>>        Move "" to sText
81337>>>>>>>>>
81337>>>>>>>>>        for iCount from 0 to iSize
81343>>>>>>>>>>
81343>>>>>>>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
81344>>>>>>>>>            Move (Trim(sLine)) to sTmp
81345>>>>>>>>>            If (sTmp <> "") Begin
81347>>>>>>>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
81348>>>>>>>>>                If (bCommentStart = False) Begin
81350>>>>>>>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
81351>>>>>>>>>                    If (bCommentStart = False) Begin
81353>>>>>>>>>                    End
81353>>>>>>>>>>
81353>>>>>>>>>                End
81353>>>>>>>>>>
81353>>>>>>>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
81354>>>>>>>>>                If (bCommentEnd = True) Begin
81356>>>>>>>>>                    Move False to bCommentStart
81357>>>>>>>>>                End
81357>>>>>>>>>>
81357>>>>>>>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
81359>>>>>>>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
81360>>>>>>>>>                End
81360>>>>>>>>>>
81360>>>>>>>>>            End
81360>>>>>>>>>>
81360>>>>>>>>>        Loop
81361>>>>>>>>>>
81361>>>>>>>>>
81361>>>>>>>>>        // Update the retval struct array:
81361>>>>>>>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
81362>>>>>>>>>        Function_Return SqlScriptArray
81363>>>>>>>>>    End_Function
81364>>>>>>>>>
81364>>>>>>>>>    // Helper function that builds a string like;
81364>>>>>>>>>    // "SELECT name from [Master].[sys].[databases] where name"
81364>>>>>>>>>    Function _SqlSelectFromWhereName Returns String
81366>>>>>>>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
81366>>>>>>>>>
81366>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
81367>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName         to sName
81368>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
81369>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
81370>>>>>>>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
81371>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
81372>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
81373>>>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
81374>>>>>>>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
81375>>>>>>>>>        Function_Return sRetval
81376>>>>>>>>>    End_Function
81377>>>>>>>>>
81377>>>>>>>>>    // Helper function to create a SQL statement like;
81377>>>>>>>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
81377>>>>>>>>>    // Used for checking if an index exists.
81377>>>>>>>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
81379>>>>>>>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
81379>>>>>>>>>
81379>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
81380>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
81381>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
81382>>>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
81383>>>>>>>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
81384>>>>>>>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
81385>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName to sName
81386>>>>>>>>>
81386>>>>>>>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
81387>>>>>>>>>
81387>>>>>>>>>        Function_Return sRetval
81388>>>>>>>>>    End_Function
81389>>>>>>>>>
81389>>>>>>>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
81389>>>>>>>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
81389>>>>>>>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
81391>>>>>>>>>        String sRetval
81391>>>>>>>>>        If (iLength <> 0) Begin
81393>>>>>>>>>            Move ("(" + String(iLength)) to sRetval
81394>>>>>>>>>            If (iDecimals <> 0) Begin
81396>>>>>>>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
81397>>>>>>>>>            End
81397>>>>>>>>>>
81397>>>>>>>>>            Move (sRetval + ")") to sRetval
81398>>>>>>>>>        End
81398>>>>>>>>>>
81398>>>>>>>>>        Function_Return sRetval
81399>>>>>>>>>    End_Function
81400>>>>>>>>>
81400>>>>>>>>>    // Checks that the passed sDriverID is defined.
81400>>>>>>>>>    // Also checks if the driver has been loaded; else it gets loaded.
81400>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
81402>>>>>>>>>        Boolean bOK
81402>>>>>>>>>        Integer iDriver
81402>>>>>>>>>
81402>>>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
81404>>>>>>>>>            Function_Return False
81405>>>>>>>>>        End
81405>>>>>>>>>>
81405>>>>>>>>>
81405>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
81406>>>>>>>>>
81406>>>>>>>>>        If (bOK = False) Begin
81408>>>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, or ODBC_DRV"
81409>>>>>>>>>>
81409>>>>>>>>>            Function_Return False
81410>>>>>>>>>        End
81410>>>>>>>>>>
81410>>>>>>>>>
81410>>>>>>>>>        Get DriverIndex sDriverID to iDriver
81411>>>>>>>>>        If (iDriver = 0) Begin
81413>>>>>>>>>            Load_Driver sDriverID
81414>>>>>>>>>        End
81414>>>>>>>>>>
81414>>>>>>>>>
81414>>>>>>>>>        Function_Return True
81415>>>>>>>>>    End_Function
81416>>>>>>>>>
81416>>>>>>>>>    // Checks that the length parameter has been passed correctly.
81416>>>>>>>>>    // This is only of concern for certain SQL data types.
81416>>>>>>>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
81418>>>>>>>>>        Integer iLength
81418>>>>>>>>>        Boolean bOK bCheckTypeLength
81418>>>>>>>>>
81418>>>>>>>>>        If (num_arguments > 1) Begin
81420>>>>>>>>>            Move iLen to iLength
81421>>>>>>>>>        End
81421>>>>>>>>>>
81421>>>>>>>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
81422>>>>>>>>>
81422>>>>>>>>>        If (bCheckTypeLength = True) Begin
81424>>>>>>>>>            Move (iLength > 0) to bOK
81425>>>>>>>>>        End
81425>>>>>>>>>>
81425>>>>>>>>>
81425>>>>>>>>>        Function_Return (bOK = True)
81426>>>>>>>>>    End_Function
81427>>>>>>>>>
81427>>>>>>>>>    Function _SqlProperTableName String sTableName Returns String
81429>>>>>>>>>        String sVal sSchema sDriverID
81429>>>>>>>>>        Integer iDbType
81429>>>>>>>>>
81429>>>>>>>>>        If (Trim(sTableName) = "") Begin
81431>>>>>>>>>            Function_Return ""
81432>>>>>>>>>        End
81432>>>>>>>>>>
81432>>>>>>>>>
81432>>>>>>>>>        Get psDriverID to sDriverID
81433>>>>>>>>>        Get piDbType   to iDbType
81434>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
81436>>>>>>>>>            Get psUserID to sSchema
81437>>>>>>>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
81437>>>>>>>>>            Move (Uppercase(sSchema)) to sSchema
81438>>>>>>>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
81439>>>>>>>>>            Function_Return sTableName
81440>>>>>>>>>        End
81440>>>>>>>>>>
81440>>>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
81442>>>>>>>>>            Get psDatabase to sVal
81443>>>>>>>>>            Move (sVal + "." + sTableName) to sTableName
81444>>>>>>>>>            Function_Return sTableName
81445>>>>>>>>>        End
81445>>>>>>>>>>
81445>>>>>>>>>        If (iDbType = EN_DbTypePostgre) Begin
81447>>>>>>>>>            Move ('"' + sTableName + '"') to sTableName
81448>>>>>>>>>            Function_Return sTableName
81449>>>>>>>>>        End
81449>>>>>>>>>>
81449>>>>>>>>>
81449>>>>>>>>>        Get psSchema to sSchema
81450>>>>>>>>>        If (sSchema = "") Begin
81452>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
81453>>>>>>>>>        End
81453>>>>>>>>>>
81453>>>>>>>>>
81453>>>>>>>>>        Move (Uppercase(sTableName)) to sVal
81454>>>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
81456>>>>>>>>>            If (iDbType = EN_dbTypeDB2) Begin
81458>>>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
81459>>>>>>>>>            End
81459>>>>>>>>>>
81459>>>>>>>>>            Else Begin
81460>>>>>>>>>                Move (sSchema + "." + sTableName) to sTableName
81461>>>>>>>>>            End
81461>>>>>>>>>>
81461>>>>>>>>>        End
81461>>>>>>>>>>
81461>>>>>>>>>
81461>>>>>>>>>        Function_Return sTableName
81462>>>>>>>>>    End_Function
81463>>>>>>>>>
81463>>>>>>>>>    // SQL column names can be case-sensitive. This function is used to check that
81463>>>>>>>>>    // the passed sFieldName has the correct spelling.
81463>>>>>>>>>    // Used with Embedded SQL statement calls.
81463>>>>>>>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
81463>>>>>>>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
81465>>>>>>>>>        String sRetval sValue sDriverID
81465>>>>>>>>>        String[] sColumnNamesArray
81466>>>>>>>>>        Integer iCount iColumns
81466>>>>>>>>>
81466>>>>>>>>>        Move "" to sRetval
81467>>>>>>>>>        Get psDriverID to sDriverID
81468>>>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
81469>>>>>>>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
81470>>>>>>>>>        Decrement iColumns
81471>>>>>>>>>
81471>>>>>>>>>        For iCount from 0 to iColumns
81477>>>>>>>>>>
81477>>>>>>>>>            Move sColumnNamesArray[iCount] to sValue
81478>>>>>>>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
81480>>>>>>>>>                Move sValue to sRetval
81481>>>>>>>>>                Move iColumns to iCount // We're done.
81482>>>>>>>>>            End
81482>>>>>>>>>>
81482>>>>>>>>>        Loop
81483>>>>>>>>>>
81483>>>>>>>>>
81483>>>>>>>>>        Function_Return sRetval
81484>>>>>>>>>    End_Function
81485>>>>>>>>>
81485>>>>>>>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
81487>>>>>>>>>        String[] sReturnArray
81488>>>>>>>>>        Handle hoSQLHandler
81488>>>>>>>>>        Integer iCount iSize iItem
81488>>>>>>>>>        String sServer
81488>>>>>>>>>        tSQLConnection SQLConnection
81488>>>>>>>>>        tSQLConnection SQLConnection
81488>>>>>>>>>
81488>>>>>>>>>        Get phoMSSQLHandler to hoSQLHandler
81489>>>>>>>>>        Send Delete_Data    of hoSQLHandler
81490>>>>>>>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
81491>>>>>>>>>
81491>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81492>>>>>>>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
81493>>>>>>>>>        Decrement iSize
81494>>>>>>>>>
81494>>>>>>>>>        For iCount from 0 to iSize
81500>>>>>>>>>>
81500>>>>>>>>>            Get String_Value of hoSQLHandler iCount to sServer
81501>>>>>>>>>            Move (Trim(sServer)) to sReturnArray[iItem]
81502>>>>>>>>>            Increment iItem
81503>>>>>>>>>        Loop
81504>>>>>>>>>>
81504>>>>>>>>>
81504>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81505>>>>>>>>>
81505>>>>>>>>>        Function_Return sReturnArray
81506>>>>>>>>>    End_Function
81507>>>>>>>>>
81507>>>>>>>>>    Function _SqlTableArrayDAW Returns String[]
81509>>>>>>>>>        String[] asSQLTables
81510>>>>>>>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord sConnectionString
81510>>>>>>>>>        Handle hoSQLHandler
81510>>>>>>>>>        Integer iCount iSize iItem iPos
81510>>>>>>>>>        Boolean bOK
81510>>>>>>>>>        tSQLConnection SQLConnection
81510>>>>>>>>>        tSQLConnection SQLConnection
81510>>>>>>>>>
81510>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81511>>>>>>>>>        If (SQLConnection.sConnectionString = "") Begin
81513>>>>>>>>>            Function_Return asSQLTables
81514>>>>>>>>>        End
81514>>>>>>>>>>
81514>>>>>>>>>
81514>>>>>>>>>        Move SQLConnection.sSchema      to sDefSchema
81515>>>>>>>>>        Move (Uppercase(sDefSchema))    to sDefSchema
81516>>>>>>>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
81517>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
81518>>>>>>>>>
81518>>>>>>>>>        Get phoCLIHandler to hoSQLHandler
81519>>>>>>>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
81520>>>>>>>>>        Send Delete_Data  of hoSQLHandler
81521>>>>>>>>>
81521>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81522>>>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
81523>>>>>>>>>        // 2020-03-14 This was not correct when testing a MS-SQL ODBC driver connection from CMOS.
81523>>>>>>>>>//        If (SQLConnection.sDriverID = ODBC_DRV_ID) Begin
81523>>>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
81523>>>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
81523>>>>>>>>>//                If (iPos > 0) Begin
81523>>>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
81523>>>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
81523>>>>>>>>>//                End
81523>>>>>>>>>//            End
81523>>>>>>>>>//        End
81523>>>>>>>>>
81523>>>>>>>>>        Get pasSQLDataTables to asSQLTables
81524>>>>>>>>>        If (SizeOfArray(asSQLTables) <> 0) Begin
81526>>>>>>>>>            Function_Return asSQLTables
81527>>>>>>>>>        End
81527>>>>>>>>>>
81527>>>>>>>>>
81527>>>>>>>>>        Get EnumerateTables of hoSQLHandler sConnectionString to iSize
81528>>>>>>>>>        Move False to Err
81529>>>>>>>>>        Move 0 to iItem
81530>>>>>>>>>
81530>>>>>>>>>        // Note that the enumeration starts from table no 1. (not zero)
81530>>>>>>>>>        For iCount from 1 to iSize
81536>>>>>>>>>>
81536>>>>>>>>>            Get TableName    of hoSQLHandler iCount to sTable
81537>>>>>>>>>            Get TableType    of hoSQLHandler iCount to sTableType
81538>>>>>>>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
81539>>>>>>>>>            If (sSchema = "") Begin
81541>>>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
81542>>>>>>>>>            End
81542>>>>>>>>>>
81542>>>>>>>>>            Get TableComment of hoSQLHandler iCount to sComment
81543>>>>>>>>>            Move (Trim(sTable)) to sTable
81544>>>>>>>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
81546>>>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
81547>>>>>>>>>            End
81547>>>>>>>>>>
81547>>>>>>>>>            Else Begin
81548>>>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
81549>>>>>>>>>            End
81549>>>>>>>>>>
81549>>>>>>>>>            If (bOK = True) Begin
81551>>>>>>>>>                Move sTable to asSQLTables[iItem]
81552>>>>>>>>>                Increment iItem
81553>>>>>>>>>            End
81553>>>>>>>>>>
81553>>>>>>>>>        Loop
81554>>>>>>>>>>
81554>>>>>>>>>
81554>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81555>>>>>>>>>
81555>>>>>>>>>        Set pasSQLDataTables to asSQLTables
81556>>>>>>>>>        Function_Return asSQLTables
81557>>>>>>>>>    End_Function
81558>>>>>>>>>
81558>>>>>>>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
81560>>>>>>>>>        String[] sReturnArray
81561>>>>>>>>>        String sValue
81561>>>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
81561>>>>>>>>>        Integer iRetval iCols iFetchResult
81561>>>>>>>>>        tSQLConnection SQLConnection
81561>>>>>>>>>        tSQLConnection SQLConnection
81561>>>>>>>>>
81561>>>>>>>>>        Get phoSQLManager to hoSQLHandler
81562>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81563>>>>>>>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
81564>>>>>>>>>
81564>>>>>>>>>        If (hoSQLConnect <> 0) Begin
81566>>>>>>>>>            Get SqlOpen of hoSQLConnect to hStmt
81567>>>>>>>>>            If (hStmt <> 0) Begin
81569>>>>>>>>>                Send SqlSetProcedurename of hStmt sStmt
81570>>>>>>>>>                If (sArgument <> "") Begin
81572>>>>>>>>>                    Send SqlSetArgument  of hStmt 1 sArgument
81573>>>>>>>>>                End
81573>>>>>>>>>>
81573>>>>>>>>>
81573>>>>>>>>>                Send SqlCall             of hStmt
81574>>>>>>>>>                Get SqlReturnValue       of hStmt to iRetval
81575>>>>>>>>>                If (iRetval = 0) Begin
81577>>>>>>>>>                    Repeat
81577>>>>>>>>>>
81577>>>>>>>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
81578>>>>>>>>>                        If (iCols > 0) Begin
81580>>>>>>>>>                            Repeat
81580>>>>>>>>>>
81580>>>>>>>>>                                Get SqlFetch of hStmt to iFetchResult
81581>>>>>>>>>                                If (iFetchResult <> 0) Begin
81583>>>>>>>>>                                    Get SqlColumnValue of hStmt 1 to sValue
81584>>>>>>>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
81585>>>>>>>>>                                End
81585>>>>>>>>>>
81585>>>>>>>>>                            Until (iFetchResult = 0)
81587>>>>>>>>>                        End
81587>>>>>>>>>>
81587>>>>>>>>>                        Get SqlNextResultSet of hStmt to iRetval
81588>>>>>>>>>                    Until (iRetval = 0)
81590>>>>>>>>>                    Send SqlClose of hStmt
81591>>>>>>>>>                End
81591>>>>>>>>>>
81591>>>>>>>>>            End
81591>>>>>>>>>>
81591>>>>>>>>>            Send SqlDisconnect of hoSQLConnect
81592>>>>>>>>>        End
81592>>>>>>>>>>
81592>>>>>>>>>        Function_Return sReturnArray
81593>>>>>>>>>    End_Function
81594>>>>>>>>>
81594>>>>>>>>>    Function _SqlUtilUpdateIntFile Integer hTable Returns Boolean
81596>>>>>>>>>        String sOrgFormat sNewFormat sRootName sTableName sPhysicalFileName sDriverID sDataPath
81596>>>>>>>>>        Boolean bOpened bOK
81596>>>>>>>>>
81596>>>>>>>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
81596>>>>>>>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
81596>>>>>>>>>        // which makes the program unable to run because they can't be opened.
81596>>>>>>>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
81596>>>>>>>>>        // proper .int files for the two tables.
81596>>>>>>>>>//        If (Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST") Begin
81596>>>>>>>>>//            Function_Return True
81596>>>>>>>>>//        End
81596>>>>>>>>>
81596>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81599>>>>>>>>>        Get _TableNameOnly sRootName to sTableName
81600>>>>>>>>>        Move CS_OEM_Txt  to sOrgFormat
81601>>>>>>>>>        Move CS_ANSI_Txt to sNewFormat
81602>>>>>>>>>        Get AutoConnectionIDLogin to bOK
81603>>>>>>>>>
81603>>>>>>>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
81603>>>>>>>>>//        Sleep 1  
81603>>>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
81604>>>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
81607>>>>>>>>>        If (bOpened = False) Begin
81609>>>>>>>>>            Open hTable
81611>>>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
81614>>>>>>>>>        End
81614>>>>>>>>>>
81614>>>>>>>>>        If (bOpened = False) Begin
81616>>>>>>>>>            Function_Return False
81617>>>>>>>>>        End
81617>>>>>>>>>>
81617>>>>>>>>>
81617>>>>>>>>>        Get psDriverID to sDriverID
81618>>>>>>>>>
81618>>>>>>>>>        Move False to Err
81619>>>>>>>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81622>>>>>>>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
81623>>>>>>>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
81623>>>>>>>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
81623>>>>>>>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
81624>>>>>>>>>
81624>>>>>>>>>        Move False to Err
81625>>>>>>>>>
81625>>>>>>>>>        If (hTable > 0) Begin
81627>>>>>>>>>            Structure_Start hTable
81628>>>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81631>>>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81634>>>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
81636>>>>>>>>>        End
81636>>>>>>>>>>
81636>>>>>>>>>        Else Begin
81637>>>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81640>>>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81643>>>>>>>>>        End
81643>>>>>>>>>>
81643>>>>>>>>>        Function_Return (Err = False)
81644>>>>>>>>>    End_Function
81645>>>>>>>>>
81645>>>>>>>>>    // Subfunction to the ApiTableUpdate function (et al)
81645>>>>>>>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
81647>>>>>>>>>        Handle hTable
81647>>>>>>>>>        String sConnectionID sRootName sLogicalName sDisplayName
81647>>>>>>>>>        Boolean bTableExists bSameTableNames bANSI bOK
81647>>>>>>>>>
81647>>>>>>>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
81648>>>>>>>>>        If (bSameTableNames = True) Begin
81650>>>>>>>>>            Function_Return True
81651>>>>>>>>>        End
81651>>>>>>>>>>
81651>>>>>>>>>
81651>>>>>>>>>        Move True to bOK
81652>>>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
81653>>>>>>>>>        Set Private.phCurrentTable              to hTable
81654>>>>>>>>>        
81654>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME         of hTable to sRootName
81657>>>>>>>>>        If (sRootName <> APITableNameInfoFrom.sRootName) Begin
81659>>>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to APITableNameInfoFrom.sRootName
81662>>>>>>>>>        End
81662>>>>>>>>>>
81662>>>>>>>>>        
81662>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME      of hTable to sLogicalName
81665>>>>>>>>>        If (sLogicalName <> APITableNameInfoFrom.sLogicalName) Begin
81667>>>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to APITableNameInfoFrom.sLogicalName
81670>>>>>>>>>        End
81670>>>>>>>>>>
81670>>>>>>>>>        
81670>>>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME      of hTable to sDisplayName
81673>>>>>>>>>        If (sDisplayName <> APITableNameInfoFrom.sDisplayName) Begin
81675>>>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to APITableNameInfoFrom.sDisplayName
81678>>>>>>>>>        End
81678>>>>>>>>>>
81678>>>>>>>>>
81678>>>>>>>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
81680>>>>>>>>>            Get psConnectionID to sConnectionID
81681>>>>>>>>>            Get _UtilTableExists hTable to bTableExists
81682>>>>>>>>>            If (bTableExists = True) Begin
81684>>>>>>>>>                Get _SqlUtilUpdateIntFile hTable to bOK
81685>>>>>>>>>            End
81685>>>>>>>>>>
81685>>>>>>>>>            Else Begin
81686>>>>>>>>>                Get pbToANSI to bANSI
81687>>>>>>>>>                Get _SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False True to bOK
81688>>>>>>>>>            End
81688>>>>>>>>>>
81688>>>>>>>>>        End
81688>>>>>>>>>>
81688>>>>>>>>>
81688>>>>>>>>>        Function_Return bOK
81689>>>>>>>>>    End_Function
81690>>>>>>>>>
81690>>>>>>>>>    // The table must already exist in the filelist for this function to work.
81690>>>>>>>>>    // It creates an .int file in the first Data folder of the psDataPath property. 
81690>>>>>>>>>    // It is important that the hTable can be opened.
81690>>>>>>>>>    Function _SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Boolean bBackup Returns Boolean
81692>>>>>>>>>        Boolean bOK bExists bUseConnectionID 
81692>>>>>>>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sTableName sSchemaName sANSI_OEM 
81692>>>>>>>>>        String[] asIndexArray
81693>>>>>>>>>        Integer iCount iCh iSize iPos
81693>>>>>>>>>
81693>>>>>>>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
81694>>>>>>>>>        Get psConnectionString to sConnectionString
81695>>>>>>>>>
81695>>>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
81696>>>>>>>>>        If (bANSI = False) Begin
81698>>>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
81699>>>>>>>>>        End
81699>>>>>>>>>>
81699>>>>>>>>>
81699>>>>>>>>>        Get psDataPathFirstPart to sDataPath
81700>>>>>>>>>        Get vFolderExists sDataPath to bOK
81701>>>>>>>>>        If (bOK = False) Begin
81703>>>>>>>>>            Error DFERR_PROGRAM "Function _SqlUtilCreateIntFile; psDataPath not found!"
81704>>>>>>>>>>
81704>>>>>>>>>            Function_Return False
81705>>>>>>>>>        End
81705>>>>>>>>>>
81705>>>>>>>>>        Get vFolderFormat sDataPath to sDataPath
81706>>>>>>>>>
81706>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81709>>>>>>>>>        Get _TableNameOnly sRootName to sTableName
81710>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
81713>>>>>>>>>        Move sLogicalName  to sPhysicalFileName
81714>>>>>>>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
81715>>>>>>>>>
81715>>>>>>>>>        Get psSchema hTable to sSchemaName
81716>>>>>>>>>        If (sSchemaName = "") Begin
81718>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
81719>>>>>>>>>        End
81719>>>>>>>>>>
81719>>>>>>>>>        
81719>>>>>>>>>        If (bBackup = True) Begin
81721>>>>>>>>>            // If the .int file already exists; we rename it to "FileName" + ".bak"
81721>>>>>>>>>            Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
81722>>>>>>>>>            If (bExists = True) Begin
81724>>>>>>>>>                Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
81725>>>>>>>>>            End
81725>>>>>>>>>>
81725>>>>>>>>>        End
81725>>>>>>>>>>
81725>>>>>>>>>
81725>>>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
81726>>>>>>>>>        Get _SqlUtilEnumerateIndexes sTableName sDriverID to asIndexArray
81727>>>>>>>>>
81727>>>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
81728>>>>>>>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
81733>>>>>>>>>            If (bUseConnectionID = True) Begin
81735>>>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
81742>>>>>>>>>            End
81742>>>>>>>>>>
81742>>>>>>>>>            Else Begin
81743>>>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
81750>>>>>>>>>            End
81750>>>>>>>>>>
81750>>>>>>>>>            Writeln channel iCh CS_DATABASE_NAME          " " sTableName
81755>>>>>>>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
81760>>>>>>>>>            // There seems to be a new order how these are set from DF19.
81760>>>>>>>>>            If (bSysFile = True) Begin
81762>>>>>>>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
81767>>>>>>>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
81772>>>>>>>>>            End
81772>>>>>>>>>>
81772>>>>>>>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
81777>>>>>>>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
81782>>>>>>>>>
81782>>>>>>>>>            If (bSysFile = False) Begin
81784>>>>>>>>>                Move (SizeOfArray(asIndexArray)) to iSize
81785>>>>>>>>>                Move (SortArray(asIndexArray)) to asIndexArray
81786>>>>>>>>>                If (iSize > 0) Begin
81788>>>>>>>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
81791>>>>>>>>>                    Writeln channel iCh // Just an empty line
81793>>>>>>>>>                End
81793>>>>>>>>>>
81793>>>>>>>>>                Decrement iSize
81794>>>>>>>>>                for iCount from 0 to iSize
81800>>>>>>>>>>
81800>>>>>>>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
81803>>>>>>>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(asIndexArray[iCount]))
81806>>>>>>>>>                    Writeln channel iCh
81808>>>>>>>>>                Loop
81809>>>>>>>>>>
81809>>>>>>>>>            End
81809>>>>>>>>>>
81809>>>>>>>>>        Send Seq_Close_Channel iCh 
81810>>>>>>>>>        
81810>>>>>>>>>        Open hTable
81812>>>>>>>>>        Structure_Start hTable sDriverID
81813>>>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_FORCE
81815>>>>>>>>>
81815>>>>>>>>>        // Wait a sec for Windows to finish writing the file:
81815>>>>>>>>>//        Sleep 1
81815>>>>>>>>>
81815>>>>>>>>>        Function_Return (bOK = True)
81816>>>>>>>>>    End_Function 
81817>>>>>>>>>    
81817>>>>>>>>>    // Simplier version of the _SqlUtilCreateIntFile. It can be used if there is something wrong with the .int file and it needs
81817>>>>>>>>>    // to be refreshed by the driver. 
81817>>>>>>>>>    Function _SqlUtilRefreshIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean        
81819>>>>>>>>>        String sOrgFormat sNewFormat
81819>>>>>>>>>        
81819>>>>>>>>>        Move False to Err
81820>>>>>>>>>        Open hTable
81822>>>>>>>>>        If (Err = True) Begin
81824>>>>>>>>>            Function_Return False
81825>>>>>>>>>        End
81825>>>>>>>>>>
81825>>>>>>>>>        
81825>>>>>>>>>        Structure_Start hTable
81826>>>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
81828>>>>>>>>>    End_Function
81829>>>>>>>>>
81829>>>>>>>>>    Function _UtilDeleteCacheFile String sTableName Returns Boolean
81831>>>>>>>>>        String sDataPath sDriverID
81831>>>>>>>>>        Boolean bOK
81831>>>>>>>>>        Integer iPos
81831>>>>>>>>>
81831>>>>>>>>>        If (sTableName contains ".") Begin
81833>>>>>>>>>            Move (Pos(".", sTableName)) to iPos
81834>>>>>>>>>            Move (Mid(sTableName, Length(sTableName), (iPos +1))) to sTableName
81835>>>>>>>>>        End
81835>>>>>>>>>>
81835>>>>>>>>>
81835>>>>>>>>>        Get psDriverID to sDriverID
81836>>>>>>>>>        Get psDataPathFirstPart to sDataPath
81837>>>>>>>>>        // First delete the cache file:
81837>>>>>>>>>        Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
81838>>>>>>>>>
81838>>>>>>>>>        Function_Return bOK
81839>>>>>>>>>    End_Function
81840>>>>>>>>>
81840>>>>>>>>>    // Collects all tables from the SQL Database backend and sets the pasSQLTables property.
81840>>>>>>>>>    Procedure UtilFillSQLTables
81842>>>>>>>>>        String[] asSQLTables
81843>>>>>>>>>        String sDataBase
81843>>>>>>>>>        Integer iSize iCount
81843>>>>>>>>>
81843>>>>>>>>>        Get psDatabase to sDataBase
81844>>>>>>>>>        Get _SqlUtilEnumerateTables MSSQLDRV_ID sDataBase "" to asSQLTables
81845>>>>>>>>>        Set pasSQLDataTables to asSQLTables
81846>>>>>>>>>    End_Procedure  
81847>>>>>>>>>    
81847>>>>>>>>>    Procedure ResetFillSQLTables
81849>>>>>>>>>        String[] asSQLTables
81850>>>>>>>>>        Set pasSQLDataTables to asSQLTables
81851>>>>>>>>>    End_Procedure
81852>>>>>>>>>    
81852>>>>>>>>>    // This collects *all* filelist entries and sets the pFileListArray struct property.
81852>>>>>>>>>    Procedure UtilFillFileListStruct
81854>>>>>>>>>        tFilelist[] Tables
81854>>>>>>>>>        tFilelist[] Tables
81855>>>>>>>>>        String sRootName sLogicalName sDisplayName sDriver sNoDriverRootname
81855>>>>>>>>>        Handle hTable
81855>>>>>>>>>        Integer iItem iCount
81855>>>>>>>>>        Boolean bIsSystem bIsAlias bOpened
81855>>>>>>>>>        
81855>>>>>>>>>        Move 0 to iItem
81856>>>>>>>>>        Move 0 to hTable 
81857>>>>>>>>>        Repeat
81857>>>>>>>>>>
81857>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81860>>>>>>>>>            // 0 = no more table in Filelist.cfg, 50 = Flexerrs.
81860>>>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin  
81862>>>>>>>>>                Move False to Err
81863>>>>>>>>>                Move False to bIsSystem
81864>>>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
81867>>>>>>>>>                Get _DriverIDFromRootName sRootName to sDriver
81868>>>>>>>>>                Set Message_Text of ghoStatusPanel to ("Reading table" * String(hTable) * "RootName =" * sRootName)
81869>>>>>>>>>                Send DoAdvance of ghoProgressBar
81870>>>>>>>>>                Send Ignore_All of Error_Object_Id
81871>>>>>>>>>                Open hTable
81873>>>>>>>>>                Get_Attribute DF_FILE_OPENED         of hTable to bOpened
81876>>>>>>>>>                Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bIsSystem
81879>>>>>>>>>                Send Trap_All of Error_Object_Id
81880>>>>>>>>>                Close hTable
81881>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
81884>>>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
81887>>>>>>>>>                Get _TableNameOnly sRootName to sNoDriverRootname
81888>>>>>>>>>                Move hTable              to Tables[iItem].hTable
81889>>>>>>>>>                Move sRootName           to Tables[iItem].sRootName
81890>>>>>>>>>                Move sLogicalName        to Tables[iItem].sLogicalName
81891>>>>>>>>>                Move sDisplayName        to Tables[iItem].sDisplayName
81892>>>>>>>>>                Move sNoDriverRootname   to Tables[iItem].sNoDriverRootname
81893>>>>>>>>>                Move sDriver             to Tables[iItem].sDriver 
81894>>>>>>>>>                Move bIsSystem           to Tables[iItem].bIsSystemFile
81895>>>>>>>>>                Move (bOpened = False)   to Tables[iItem].bErrorOpening
81896>>>>>>>>>                Get _IsAliasTable hTable to Tables[iItem].bIsAlias 
81897>>>>>>>>>                Move False to Err
81898>>>>>>>>>                Increment iItem
81899>>>>>>>>>            End
81899>>>>>>>>>>
81899>>>>>>>>>        Until (hTable = 0)
81901>>>>>>>>>        
81901>>>>>>>>>        Set Message_Text of ghoStatusPanel to ""
81902>>>>>>>>>        Set pFileListArray to Tables
81903>>>>>>>>>    End_Procedure   
81904>>>>>>>>>    
81904>>>>>>>>>    // Special array search function for the tFilelistLogicalName struct.
81904>>>>>>>>>    // Used by e.g. UtilAliasToMasterTableHandle
81904>>>>>>>>>    Function CompareFileListTable tFilelistLogicalName FileListTable1 tFilelistLogicalName FileListTable2 Returns Integer
81906>>>>>>>>>        If (Lowercase(FileListTable1.sLogicalName) < Lowercase(FileListTable2.sLogicalName)) ;            Function_Return (LT)
81909>>>>>>>>>        If (Lowercase(FileListTable1.sLogicalName) > Lowercase(FileListTable2.sLogicalName)) ;            Function_Return (GT)
81912>>>>>>>>>
81912>>>>>>>>>        If (Lowercase(FileListTable1.sNoDriverRootname) < Lowercase(FileListTable2.sNoDriverRootname)) ;            Function_Return (LT)
81915>>>>>>>>>        If (Lowercase(FileListTable1.sNoDriverRootname) > Lowercase(FileListTable2.sNoDriverRootname)) ;            Function_Return (GT)
81918>>>>>>>>>            
81918>>>>>>>>>        Function_Return (EQ)
81919>>>>>>>>>    End_Function
81920>>>>>>>>>
81920>>>>>>>>>    // Finds the corresponding Master table for the passed Alias handle
81920>>>>>>>>>    Function UtilAliasToMasterTableHandle Handle hTable Returns Handle
81922>>>>>>>>>        Handle hMasterTable
81922>>>>>>>>>        String sDriver sRootNameAlias sNoDriverRootnameAlias
81922>>>>>>>>>        Boolean bIsAlias bFound bIsIntTable
81922>>>>>>>>>        Integer iSize iCount iItem 
81922>>>>>>>>>        tFilelistLogicalName[] FilelistLogicalTables
81922>>>>>>>>>        tFilelistLogicalName[] FilelistLogicalTables
81923>>>>>>>>>        tFilelistLogicalName FileListTable
81923>>>>>>>>>        tFilelistLogicalName FileListTable
81923>>>>>>>>>        
81923>>>>>>>>>        Get _IsAliasTable hTable to bIsAlias
81924>>>>>>>>>        If (bIsAlias = False) Begin
81926>>>>>>>>>            Function_Return 0
81927>>>>>>>>>        End
81927>>>>>>>>>>
81927>>>>>>>>>        
81927>>>>>>>>>        Move 0 to hMasterTable
81928>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameAlias 
81931>>>>>>>>>        Get _TableNameOnly sRootNameAlias to sNoDriverRootnameAlias
81932>>>>>>>>>        Get _IsIntEntry hTable to bIsIntTable
81933>>>>>>>>>        Get pFilelistLogicalTables  to FilelistLogicalTables
81934>>>>>>>>>        Move sNoDriverRootnameAlias to FileListTable.sLogicalName
81935>>>>>>>>>        Move sNoDriverRootnameAlias to FileListTable.sNoDriverRootname
81936>>>>>>>>>        Move (SearchArray(FileListTable, FilelistLogicalTables, Self, (RefFunc(CompareFileListTable)))) to iItem
81937>>>>>>>>>        If (iItem = -1) Begin
81939>>>>>>>>>            Function_Return 0
81940>>>>>>>>>        End
81940>>>>>>>>>>
81940>>>>>>>>>        Move (Lowercase(sNoDriverRootnameAlias) = Lowercase(FilelistLogicalTables[iItem].sNoDriverRootname) and Lowercase(FilelistLogicalTables[iItem].sNoDriverRootname) = Lowercase(FilelistLogicalTables[iItem].sLogicalName)) to bFound
81941>>>>>>>>>        If (bFound = True) Begin
81943>>>>>>>>>            Move FilelistLogicalTables[iItem].hTable to hMasterTable
81944>>>>>>>>>            Function_Return hMasterTable
81945>>>>>>>>>        End
81945>>>>>>>>>>
81945>>>>>>>>>        
81945>>>>>>>>>        Function_Return hMasterTable
81946>>>>>>>>>    End_Function
81947>>>>>>>>>     
81947>>>>>>>>>    Function pFilelistLogicalTables Returns tFilelistLogicalName
81949>>>>>>>>>        tFilelistLogicalName[] FilelistLogicalTables
81949>>>>>>>>>        tFilelistLogicalName[] FilelistLogicalTables
81950>>>>>>>>>        tFilelist[] FileListTables
81950>>>>>>>>>        tFilelist[] FileListTables
81951>>>>>>>>>        Integer iSize iCount
81951>>>>>>>>>        
81951>>>>>>>>>        Get pFileListArray to FileListTables
81952>>>>>>>>>        Move (SizeOfArray(FileListTables)) to iSize
81953>>>>>>>>>        Decrement iSize
81954>>>>>>>>>        for iCount from 0 to iSize
81960>>>>>>>>>>
81960>>>>>>>>>            Move FileListTables[iCount].bErrorOpening       to FilelistLogicalTables[iCount].bErrorOpening    
81961>>>>>>>>>            Move FileListTables[iCount].bIsAlias            to FilelistLogicalTables[iCount].bIsAlias
81962>>>>>>>>>            Move FileListTables[iCount].bIsSystemFile       to FilelistLogicalTables[iCount].bIsSystemFile
81963>>>>>>>>>            Move FileListTables[iCount].hTable              to FilelistLogicalTables[iCount].hTable
81964>>>>>>>>>            Move FileListTables[iCount].sDisplayName        to FilelistLogicalTables[iCount].sDisplayName
81965>>>>>>>>>            Move FileListTables[iCount].sDriver             to FilelistLogicalTables[iCount].sDriver
81966>>>>>>>>>            Move FileListTables[iCount].sLogicalName        to FilelistLogicalTables[iCount].sLogicalName
81967>>>>>>>>>            Move FileListTables[iCount].sNoDriverRootname   to FilelistLogicalTables[iCount].sNoDriverRootname
81968>>>>>>>>>            Move FileListTables[iCount].sRootName           to FilelistLogicalTables[iCount].sRootName
81969>>>>>>>>>        Loop
81970>>>>>>>>>>
81970>>>>>>>>>        Move (SortArray(FilelistLogicalTables)) to FilelistLogicalTables
81971>>>>>>>>>        Function_Return FilelistLogicalTables
81972>>>>>>>>>    End_Function 
81973>>>>>>>>>    
81973>>>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
81973>>>>>>>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
81973>>>>>>>>>    // if it is an SQL table
81973>>>>>>>>>    Function _UtilTableExists Handle hTable Returns Boolean
81975>>>>>>>>>        Boolean bExists bIsSQLTable
81975>>>>>>>>>        String sDataPath sRootName
81975>>>>>>>>>
81975>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
81976>>>>>>>>>        If (bExists = False) Begin
81978>>>>>>>>>            Function_Return False
81979>>>>>>>>>        End
81979>>>>>>>>>>
81979>>>>>>>>>
81979>>>>>>>>>        Move False to bIsSQLTable
81980>>>>>>>>>        If (hTable > 0) Begin
81982>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81985>>>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
81986>>>>>>>>>        End
81986>>>>>>>>>>
81986>>>>>>>>>        If (bIsSQLTable = True) Begin
81988>>>>>>>>>            Get _UtilTableIsSql hTable to bExists
81989>>>>>>>>>            Function_Return bExists
81990>>>>>>>>>        End
81990>>>>>>>>>>
81990>>>>>>>>>        Else Begin
81991>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
81992>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
81993>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
81994>>>>>>>>>        End
81994>>>>>>>>>>
81994>>>>>>>>>
81994>>>>>>>>>        Function_Return bExists
81995>>>>>>>>>    End_Function
81996>>>>>>>>>
81996>>>>>>>>>    // Note: This variant uses the pasSQLDataTables property!
81996>>>>>>>>>    //       Thus, that property needs to have been initialized before
81996>>>>>>>>>    //       calling.
81996>>>>>>>>>    // It checks that the SQL table exists on the SQL end, *or*
81996>>>>>>>>>    // if embedded database, that the .dat file exists on disk.
81996>>>>>>>>>    Function _UtilTableExists_Ex Handle hTable Returns Boolean
81998>>>>>>>>>        Boolean bExists bIsSQLTable
81998>>>>>>>>>        String sDataPath sRootName
81998>>>>>>>>>
81998>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
81999>>>>>>>>>        If (bExists = False) Begin
82001>>>>>>>>>            Function_Return False
82002>>>>>>>>>        End
82002>>>>>>>>>>
82002>>>>>>>>>
82002>>>>>>>>>        Move False to bIsSQLTable
82003>>>>>>>>>        If (hTable > 0) Begin
82005>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
82008>>>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
82009>>>>>>>>>        End
82009>>>>>>>>>>
82009>>>>>>>>>        If (bIsSQLTable = True) Begin
82011>>>>>>>>>            Get _UtilTableIsSql_Ex hTable to bExists
82012>>>>>>>>>            Function_Return bExists
82013>>>>>>>>>        End
82013>>>>>>>>>>
82013>>>>>>>>>        Else Begin
82014>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
82015>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
82016>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
82017>>>>>>>>>        End
82017>>>>>>>>>>
82017>>>>>>>>>
82017>>>>>>>>>        Function_Return bExists
82018>>>>>>>>>    End_Function
82019>>>>>>>>>
82019>>>>>>>>>    // Pass a table handle
82019>>>>>>>>>    // Returns True if the table exists in filelist.cfg.
82019>>>>>>>>>    Function _UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
82021>>>>>>>>>        Handle hTable
82021>>>>>>>>>        Boolean bFound
82021>>>>>>>>>
82021>>>>>>>>>        Move False to bFound
82022>>>>>>>>>        Move 0 to hTable
82023>>>>>>>>>        Repeat
82023>>>>>>>>>>
82023>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
82026>>>>>>>>>            If (hTable > 0) Begin
82028>>>>>>>>>                If (hTable = hCheckTable) Begin
82030>>>>>>>>>                    Move True to bFound
82031>>>>>>>>>                End
82031>>>>>>>>>>
82031>>>>>>>>>            End
82031>>>>>>>>>>
82031>>>>>>>>>            If (bFound = True) ;                Break
82034>>>>>>>>>        Until (hTable = 0)
82036>>>>>>>>>
82036>>>>>>>>>        Function_Return bFound
82037>>>>>>>>>    End_Function
82038>>>>>>>>>
82038>>>>>>>>>    // Returns number of tables in filelist.cfg.
82038>>>>>>>>>    Function _UtilNumberOfFileListTables Returns Boolean
82040>>>>>>>>>        Handle hTable
82040>>>>>>>>>        Integer iCount
82040>>>>>>>>>
82040>>>>>>>>>        Move 0 to iCount
82041>>>>>>>>>        Move 0 to hTable
82042>>>>>>>>>        Repeat
82042>>>>>>>>>>
82042>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
82045>>>>>>>>>            If (hTable > 0) Begin
82047>>>>>>>>>                Increment iCount
82048>>>>>>>>>            End
82048>>>>>>>>>>
82048>>>>>>>>>        Until (hTable = 0)
82050>>>>>>>>>
82050>>>>>>>>>        Function_Return iCount
82051>>>>>>>>>    End_Function
82052>>>>>>>>>
82052>>>>>>>>>    // DataFlex Embedded Database Data Types:
82052>>>>>>>>>    // Helper function for _UtilEnumerateColumnTypes
82052>>>>>>>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
82054>>>>>>>>>        tColumnType[] ColumnType
82054>>>>>>>>>        tColumnType[] ColumnType
82055>>>>>>>>>        Integer i
82055>>>>>>>>>
82055>>>>>>>>>        Move DF_ASCII           to ColumnType[i].iSQLType
82056>>>>>>>>>        Move "ASCII"            to ColumnType[i].sSQLType
82057>>>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
82058>>>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
82059>>>>>>>>>        Move "254"              to ColumnType[i].sPrecision
82060>>>>>>>>>        Increment i
82061>>>>>>>>>
82061>>>>>>>>>        Move DF_BCD             to ColumnType[i].iSQLType
82062>>>>>>>>>        Move "Numeric"          to ColumnType[i].sSQLType
82063>>>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
82064>>>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
82065>>>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
82066>>>>>>>>>        Increment i
82067>>>>>>>>>
82067>>>>>>>>>        Move DF_DATE            to ColumnType[i].iSQLType
82068>>>>>>>>>        Move "Date"             to ColumnType[i].sSQLType
82069>>>>>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
82070>>>>>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
82071>>>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
82072>>>>>>>>>        Move True               to ColumnType[i].bCanEditSize
82073>>>>>>>>>        Increment i
82074>>>>>>>>>
82074>>>>>>>>>        Move DF_TEXT            to ColumnType[i].iSQLType
82075>>>>>>>>>        Move "Text"             to ColumnType[i].sSQLType
82076>>>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
82077>>>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
82078>>>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
82079>>>>>>>>>        Increment i
82080>>>>>>>>>
82080>>>>>>>>>        Move DF_BINARY          to ColumnType[i].iSQLType
82081>>>>>>>>>        Move "Binary"           to ColumnType[i].sSQLType
82082>>>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
82083>>>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
82084>>>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
82085>>>>>>>>>        Increment i
82086>>>>>>>>>
82086>>>>>>>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
82087>>>>>>>>>        Move "DateTime"         to ColumnType[i].sSQLType
82088>>>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82089>>>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
82090>>>>>>>>>        Move "23"               to ColumnType[i].sPrecision
82091>>>>>>>>>        Move True               to ColumnType[i].bCanEditSize
82092>>>>>>>>>        Increment i
82093>>>>>>>>>
82093>>>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
82094>>>>>>>>>        Move "Overlap"          to ColumnType[i].sSQLType
82095>>>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
82096>>>>>>>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
82097>>>>>>>>>        Move "0.0"              to ColumnType[i].sPrecision
82098>>>>>>>>>
82098>>>>>>>>>        Function_Return ColumnType
82099>>>>>>>>>    End_Function
82100>>>>>>>>>
82100>>>>>>>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
82102>>>>>>>>>        tColumnType[] aColumnType
82102>>>>>>>>>        tColumnType[] aColumnType
82103>>>>>>>>>        Integer i
82103>>>>>>>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DB2_DRV_DriverDef.inc)
82103>>>>>>>>>>// Generated By The Database Update Framework
82103>>>>>>>>>>// Driver XML File: C:\Program Files\DataFlex 24.0\Lib\DB2_DRV_DriverDef.xml
82103>>>>>>>>>>// Driver COLUMN DATA TYPES
82103>>>>>>>>>>//
82103>>>>>>>>>>// Created: 2024-10-15 10:49:58,567
82103>>>>>>>>>>
82103>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82104>>>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
82105>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82106>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82107>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82108>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82109>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82110>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82111>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82112>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82113>>>>>>>>>>            Increment i
82114>>>>>>>>>>
82114>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
82115>>>>>>>>>>            Move -98                                     to aColumnType[i].iSQLType
82116>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82117>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82118>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82119>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82120>>>>>>>>>>            Move 2147483647                              to aColumnType[i].nMaxSize
82121>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82122>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82123>>>>>>>>>>            Move 2147483647                              to aColumnType[i].sPrecision
82124>>>>>>>>>>            Increment i
82125>>>>>>>>>>
82125>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82126>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82127>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82128>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82129>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82130>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82131>>>>>>>>>>            Move 254                                     to aColumnType[i].nMaxSize
82132>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82133>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82134>>>>>>>>>>            Move 254                                     to aColumnType[i].sPrecision
82135>>>>>>>>>>            Increment i
82136>>>>>>>>>>
82136>>>>>>>>>>            Move "char for bit data"                     to aColumnType[i].sSQLType
82137>>>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
82138>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82139>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82140>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82141>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82142>>>>>>>>>>            Move 254                                     to aColumnType[i].nMaxSize
82143>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82144>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82145>>>>>>>>>>            Move 254                                     to aColumnType[i].sPrecision
82146>>>>>>>>>>            Increment i
82147>>>>>>>>>>
82147>>>>>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
82148>>>>>>>>>>            Move -99                                     to aColumnType[i].iSQLType
82149>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82150>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82151>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82152>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82153>>>>>>>>>>            Move 2147483647                              to aColumnType[i].nMaxSize
82154>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82155>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82156>>>>>>>>>>            Move 2147483647                              to aColumnType[i].sPrecision
82157>>>>>>>>>>            Increment i
82158>>>>>>>>>>
82158>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82159>>>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
82160>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82161>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82162>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82163>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82164>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82165>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82166>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82167>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82168>>>>>>>>>>            Increment i
82169>>>>>>>>>>
82169>>>>>>>>>>            Move "dbclob"                                to aColumnType[i].sSQLType
82170>>>>>>>>>>            Move -350                                    to aColumnType[i].iSQLType
82171>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82172>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82173>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82174>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82175>>>>>>>>>>            Move 1073741823                              to aColumnType[i].nMaxSize
82176>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82177>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82178>>>>>>>>>>            Move 1073741823                              to aColumnType[i].sPrecision
82179>>>>>>>>>>            Increment i
82180>>>>>>>>>>
82180>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82181>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82182>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82183>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82184>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82185>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82186>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82187>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82188>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82189>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82190>>>>>>>>>>            Increment i
82191>>>>>>>>>>
82191>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
82192>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
82193>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82194>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82195>>>>>>>>>>            Move 192898100                               to aColumnType[i].iDefaultSize
82196>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82197>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82198>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82199>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82200>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82201>>>>>>>>>>            Increment i
82202>>>>>>>>>>
82202>>>>>>>>>>            Move "graphic"                               to aColumnType[i].sSQLType
82203>>>>>>>>>>            Move -95                                     to aColumnType[i].iSQLType
82204>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82205>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82206>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82207>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82208>>>>>>>>>>            Move 127                                     to aColumnType[i].nMaxSize
82209>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82210>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82211>>>>>>>>>>            Move 127                                     to aColumnType[i].sPrecision
82212>>>>>>>>>>            Increment i
82213>>>>>>>>>>
82213>>>>>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
82214>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82215>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82216>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82217>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82218>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82219>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82220>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82221>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82222>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82223>>>>>>>>>>            Increment i
82224>>>>>>>>>>
82224>>>>>>>>>>            Move "long varchar"                          to aColumnType[i].sSQLType
82225>>>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
82226>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82227>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82228>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82229>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82230>>>>>>>>>>            Move 32000                                   to aColumnType[i].nMaxSize
82231>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82232>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82233>>>>>>>>>>            Move 32000                                   to aColumnType[i].sPrecision
82234>>>>>>>>>>            Increment i
82235>>>>>>>>>>
82235>>>>>>>>>>            Move "long varchar for bit data"             to aColumnType[i].sSQLType
82236>>>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
82237>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82238>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82239>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82240>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82241>>>>>>>>>>            Move 32700                                   to aColumnType[i].nMaxSize
82242>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82243>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82244>>>>>>>>>>            Move 32700                                   to aColumnType[i].sPrecision
82245>>>>>>>>>>            Increment i
82246>>>>>>>>>>
82246>>>>>>>>>>            Move "long vargraphic"                       to aColumnType[i].sSQLType
82247>>>>>>>>>>            Move -97                                     to aColumnType[i].iSQLType
82248>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82249>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82250>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82251>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82252>>>>>>>>>>            Move 16350                                   to aColumnType[i].nMaxSize
82253>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82254>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82255>>>>>>>>>>            Move 16350                                   to aColumnType[i].sPrecision
82256>>>>>>>>>>            Increment i
82257>>>>>>>>>>
82257>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
82258>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82259>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82260>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82261>>>>>>>>>>            Move 192897884                               to aColumnType[i].iDefaultSize
82262>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82263>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82264>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82265>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82266>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82267>>>>>>>>>>            Increment i
82268>>>>>>>>>>
82268>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82269>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82270>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82271>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82272>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82273>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82274>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82275>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82276>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82277>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82278>>>>>>>>>>            Increment i
82279>>>>>>>>>>
82279>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82280>>>>>>>>>>            Move 92                                      to aColumnType[i].iSQLType
82281>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82282>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82283>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82284>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82285>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82286>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82287>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82288>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82289>>>>>>>>>>            Increment i
82290>>>>>>>>>>
82290>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
82291>>>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
82292>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82293>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82294>>>>>>>>>>            Move 192898868                               to aColumnType[i].iDefaultSize
82295>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
82296>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82297>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82298>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82299>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82300>>>>>>>>>>            Increment i
82301>>>>>>>>>>
82301>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82302>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82303>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82304>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82305>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82306>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82307>>>>>>>>>>            Move 32672                                   to aColumnType[i].nMaxSize
82308>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82309>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82310>>>>>>>>>>            Move 32672                                   to aColumnType[i].sPrecision
82311>>>>>>>>>>            Increment i
82312>>>>>>>>>>
82312>>>>>>>>>>            Move "varchar for bit data"                  to aColumnType[i].sSQLType
82313>>>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
82314>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82315>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82316>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82317>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82318>>>>>>>>>>            Move 32672                                   to aColumnType[i].nMaxSize
82319>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82320>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82321>>>>>>>>>>            Move 32672                                   to aColumnType[i].sPrecision
82322>>>>>>>>>>            Increment i
82323>>>>>>>>>>
82323>>>>>>>>>>            Move "vargraphic"                            to aColumnType[i].sSQLType
82324>>>>>>>>>>            Move -96                                     to aColumnType[i].iSQLType
82325>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82326>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82327>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82328>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82329>>>>>>>>>>            Move 16336                                   to aColumnType[i].nMaxSize
82330>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82331>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82332>>>>>>>>>>            Move 16336                                   to aColumnType[i].sPrecision
82333>>>>>>>>>>            Increment i
82334>>>>>>>>>>
82334>>>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
82335>>>>>>>>>>            Move -370                                    to aColumnType[i].iSQLType
82336>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82337>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82338>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82339>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82340>>>>>>>>>>            Move 2147483647                              to aColumnType[i].nMaxSize
82341>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82342>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82343>>>>>>>>>>            Move 2147483647                              to aColumnType[i].sPrecision
82344>>>>>>>>>>            Increment i
82345>>>>>>>>>>
82345>>>>>>>>>>
82345>>>>>>>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
82345>>>>>>>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
82345>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82345>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82345>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82345>>>>>>>>>//        Increment i
82345>>>>>>>>>//
82345>>>>>>>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
82345>>>>>>>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
82345>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82345>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82345>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82345>>>>>>>>>//        Increment i
82345>>>>>>>>>//
82345>>>>>>>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
82345>>>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
82345>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82345>>>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
82345>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82345>>>>>>>>>//        Increment i
82345>>>>>>>>>//
82345>>>>>>>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
82345>>>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
82345>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82345>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82345>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82345>>>>>>>>>//        Increment i
82345>>>>>>>>>//
82345>>>>>>>>>//        // ToDo: We need to change the sType when using this!
82345>>>>>>>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
82345>>>>>>>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
82345>>>>>>>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
82345>>>>>>>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
82345>>>>>>>>>//        Move "254"                  to ColumnType[i].sPrecision
82345>>>>>>>>>//        Increment i
82345>>>>>>>>>//
82345>>>>>>>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
82345>>>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
82345>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
82345>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82345>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82345>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82345>>>>>>>>>//        Increment i
82345>>>>>>>>>//
82345>>>>>>>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
82345>>>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
82345>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82345>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82345>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82345>>>>>>>>>//        Increment i
82345>>>>>>>>>//
82345>>>>>>>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
82345>>>>>>>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
82345>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82345>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82345>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82345>>>>>>>>>//        Increment i
82345>>>>>>>>>//
82345>>>>>>>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
82345>>>>>>>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
82345>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82345>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82345>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82345>>>>>>>>>//        Increment i
82345>>>>>>>>>//
82345>>>>>>>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
82345>>>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
82345>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82345>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82345>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82345>>>>>>>>>//        Increment i
82345>>>>>>>>>//
82345>>>>>>>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
82345>>>>>>>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
82345>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82345>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82345>>>>>>>>>//        Move "255"              to ColumnType[i].sPrecision
82345>>>>>>>>>//        Increment i
82345>>>>>>>>>//
82345>>>>>>>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
82345>>>>>>>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
82345>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82345>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82345>>>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
82345>>>>>>>>>//        Increment i
82345>>>>>>>>>//
82345>>>>>>>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
82345>>>>>>>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
82345>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82345>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82345>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82345>>>>>>>>>//        Increment i
82345>>>>>>>>>//
82345>>>>>>>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
82345>>>>>>>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
82345>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82345>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82345>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82345>>>>>>>>>//        Increment i
82345>>>>>>>>>//
82345>>>>>>>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
82345>>>>>>>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
82345>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82345>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82345>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82345>>>>>>>>>//        Increment i
82345>>>>>>>>>//
82345>>>>>>>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
82345>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
82345>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82345>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82345>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82345>>>>>>>>>//        Increment i
82345>>>>>>>>>//
82345>>>>>>>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
82345>>>>>>>>>//        Move "REAL"             to ColumnType[i].sSQLType
82345>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82345>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82345>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82345>>>>>>>>>//        Increment i
82345>>>>>>>>>//
82345>>>>>>>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
82345>>>>>>>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
82345>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82345>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82345>>>>>>>>>//        Move "5.0"              to ColumnType[i].sPrecision
82345>>>>>>>>>//        Increment i
82345>>>>>>>>>//
82345>>>>>>>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
82345>>>>>>>>>//        Move "TIME"             to ColumnType[i].sSQLType
82345>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82345>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82345>>>>>>>>>//        Move "19.0"             to ColumnType[i].sPrecision
82345>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82345>>>>>>>>>//        Increment i
82345>>>>>>>>>//
82345>>>>>>>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
82345>>>>>>>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
82345>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82345>>>>>>>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
82345>>>>>>>>>//        Move "23.6"             to ColumnType[i].sPrecision
82345>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82345>>>>>>>>>//        Increment i
82345>>>>>>>>>//
82345>>>>>>>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
82345>>>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
82345>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82345>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82345>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82345>>>>>>>>>//        Increment i
82345>>>>>>>>>//
82345>>>>>>>>>//        // ToDo: We need to change the sType when using this!
82345>>>>>>>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
82345>>>>>>>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
82345>>>>>>>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
82345>>>>>>>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
82345>>>>>>>>>//        Move "16384"                to ColumnType[i].sPrecision
82345>>>>>>>>>//        Increment i
82345>>>>>>>>>//
82345>>>>>>>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
82345>>>>>>>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
82345>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82345>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82345>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82345>>>>>>>>>//
82345>>>>>>>>>//        Move SQL_XML            to ColumnType[i].iSQLType
82345>>>>>>>>>//        Move "XML"              to ColumnType[i].sSQLType
82345>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82345>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82345>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82345>>>>>>>>>
82345>>>>>>>>>        Function_Return aColumnType
82346>>>>>>>>>    End_Function
82347>>>>>>>>>
82347>>>>>>>>>    // Microsoft SQL Server Database Data Types:
82347>>>>>>>>>    // Helper function for _UtilEnumerateColumnTypes
82347>>>>>>>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
82349>>>>>>>>>        tColumnType[] aColumnType
82349>>>>>>>>>        tColumnType[] aColumnType
82350>>>>>>>>>        Integer i
82350>>>>>>>>>
82350>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSQLDRV_DriverDef.inc)
82352>>>>>>>>>>// Generated By The Database Update Framework
82352>>>>>>>>>>// Driver XML File: C:\Program Files\DataFlex 24.0\Lib\MSSQLDRV_DriverDef.xml
82352>>>>>>>>>>// Driver COLUMN DATA TYPES
82352>>>>>>>>>>//
82352>>>>>>>>>>// Created: 2024-10-15 10:49:25,717
82352>>>>>>>>>>
82352>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82353>>>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
82354>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82355>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82356>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82357>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82358>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82359>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82360>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82361>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82362>>>>>>>>>>            Increment i
82363>>>>>>>>>>
82363>>>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
82364>>>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
82365>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82366>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82367>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82368>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82369>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82370>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82371>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82372>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82373>>>>>>>>>>            Increment i
82374>>>>>>>>>>
82374>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82375>>>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
82376>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82377>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82378>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82379>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82380>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82381>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82382>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82383>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82384>>>>>>>>>>            Increment i
82385>>>>>>>>>>
82385>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82386>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82387>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82388>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82389>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82390>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82391>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82392>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82393>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82394>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82395>>>>>>>>>>            Increment i
82396>>>>>>>>>>
82396>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82397>>>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
82398>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82399>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82400>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82401>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82402>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82403>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82404>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82405>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82406>>>>>>>>>>            Increment i
82407>>>>>>>>>>
82407>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
82408>>>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
82409>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82410>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82411>>>>>>>>>>            Move 115808772                               to aColumnType[i].iDefaultSize
82412>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
82413>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82414>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82415>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82416>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82417>>>>>>>>>>            Increment i
82418>>>>>>>>>>
82418>>>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
82419>>>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
82420>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82421>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82422>>>>>>>>>>            Move 115808868                               to aColumnType[i].iDefaultSize
82423>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
82424>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82425>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82426>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82427>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82428>>>>>>>>>>            Increment i
82429>>>>>>>>>>
82429>>>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
82430>>>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
82431>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82432>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82433>>>>>>>>>>            Move 115808964                               to aColumnType[i].iDefaultSize
82434>>>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
82435>>>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
82436>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82437>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82438>>>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
82439>>>>>>>>>>            Increment i
82440>>>>>>>>>>
82440>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82441>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82442>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82443>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82444>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82445>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82446>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82447>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82448>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82449>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82450>>>>>>>>>>            Increment i
82451>>>>>>>>>>
82451>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82452>>>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
82453>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82454>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82455>>>>>>>>>>            Move 115808508                               to aColumnType[i].iDefaultSize
82456>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82457>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82458>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82459>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82460>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82461>>>>>>>>>>            Increment i
82462>>>>>>>>>>
82462>>>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
82463>>>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
82464>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82465>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82466>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82467>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82468>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82469>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82470>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82471>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82472>>>>>>>>>>            Increment i
82473>>>>>>>>>>
82473>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82474>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82475>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82476>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82477>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82478>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82479>>>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
82480>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82481>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82482>>>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
82483>>>>>>>>>>            Increment i
82484>>>>>>>>>>
82484>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
82485>>>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
82486>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82487>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82488>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82489>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82490>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82491>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82492>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82493>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82494>>>>>>>>>>            Increment i
82495>>>>>>>>>>
82495>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
82496>>>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
82497>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82498>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82499>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82500>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82501>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82502>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82503>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82504>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82505>>>>>>>>>>            Increment i
82506>>>>>>>>>>
82506>>>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
82507>>>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
82508>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82509>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82510>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82511>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82512>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82513>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82514>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82515>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82516>>>>>>>>>>            Increment i
82517>>>>>>>>>>
82517>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
82518>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82519>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82520>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82521>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82522>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82523>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82524>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82525>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82526>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82527>>>>>>>>>>            Increment i
82528>>>>>>>>>>
82528>>>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
82529>>>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
82530>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82531>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82532>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82533>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82534>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82535>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82536>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82537>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82538>>>>>>>>>>            Increment i
82539>>>>>>>>>>
82539>>>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
82540>>>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
82541>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82542>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82543>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82544>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82545>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82546>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82547>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82548>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82549>>>>>>>>>>            Increment i
82550>>>>>>>>>>
82550>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
82551>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82552>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82553>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82554>>>>>>>>>>            Move 115809924                               to aColumnType[i].iDefaultSize
82555>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82556>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82557>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82558>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82559>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82560>>>>>>>>>>            Increment i
82561>>>>>>>>>>
82561>>>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
82562>>>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
82563>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82564>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82565>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82566>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82567>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82568>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82569>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82570>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82571>>>>>>>>>>            Increment i
82572>>>>>>>>>>
82572>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82573>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82574>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82575>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82576>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82577>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82578>>>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
82579>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82580>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82581>>>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
82582>>>>>>>>>>            Increment i
82583>>>>>>>>>>
82583>>>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
82584>>>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
82585>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82586>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82587>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82588>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82589>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82590>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82591>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82592>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82593>>>>>>>>>>            Increment i
82594>>>>>>>>>>
82594>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82595>>>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
82596>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82597>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82598>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82599>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82600>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82601>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82602>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82603>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82604>>>>>>>>>>            Increment i
82605>>>>>>>>>>
82605>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82606>>>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
82607>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82608>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82609>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82610>>>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
82611>>>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
82612>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82613>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82614>>>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
82615>>>>>>>>>>            Increment i
82616>>>>>>>>>>
82616>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82617>>>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
82618>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82619>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82620>>>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
82621>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82622>>>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
82623>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82624>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82625>>>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
82626>>>>>>>>>>            Increment i
82627>>>>>>>>>>
82627>>>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
82628>>>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
82629>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82630>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82631>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82632>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82633>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82634>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82635>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82636>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82637>>>>>>>>>>            Increment i
82638>>>>>>>>>>
82638>>>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
82639>>>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
82640>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82641>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82642>>>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
82643>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82644>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82645>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82646>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82647>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82648>>>>>>>>>>            Increment i
82649>>>>>>>>>>
82649>>>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
82650>>>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
82651>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82652>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82653>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82654>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82655>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82656>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82657>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82658>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82659>>>>>>>>>>            Increment i
82660>>>>>>>>>>
82660>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82661>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82662>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82663>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82664>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82665>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82666>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82667>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82668>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82669>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82670>>>>>>>>>>            Increment i
82671>>>>>>>>>>
82671>>>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
82672>>>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
82673>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82674>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82675>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82676>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82677>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82678>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82679>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82680>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82681>>>>>>>>>>            Increment i
82682>>>>>>>>>>
82682>>>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
82683>>>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
82684>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82685>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82686>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82687>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82688>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82689>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82690>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82691>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82692>>>>>>>>>>            Increment i
82693>>>>>>>>>>
82693>>>>>>>>>>
82693>>>>>>>>>
82693>>>>>>>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "bigint"           to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
82693>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "binary"           to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "bit"              to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
82693>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "char"             to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "date"             to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
82693>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "23.3"             to ColumnType[i].sPrecision
82693>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "datetime2"         to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "23.6"              to ColumnType[i].sPrecision
82693>>>>>>>>>//            Move True                to ColumnType[i].bCanEditSize
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "34.0"                 to ColumnType[i].sPrecision
82693>>>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "decimal"          to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "float"            to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "int"              to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "8.0"              to ColumnType[i].sPrecision
82693>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "money"            to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "nchar"            to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "ntext"            to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "numeric"          to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82693>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "real"             to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "23.0"                 to ColumnType[i].sPrecision
82693>>>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "smallint"         to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "4.0"              to ColumnType[i].sPrecision
82693>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "10.0"              to ColumnType[i].sPrecision
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "text"             to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82693>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "19.0"             to ColumnType[i].sPrecision
82693>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "tinyint"          to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "2.0"              to ColumnType[i].sPrecision
82693>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "36"               to ColumnType[i].sPrecision
82693>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "varbinary"        to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82693>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "varchar"          to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
82693>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82693>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "xml"              to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "DATE"             to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "date"             to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
82693>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "8.7"              to ColumnType[i].sPrecision
82693>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>//
82693>>>>>>>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
82693>>>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
82693>>>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
82693>>>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
82693>>>>>>>>>//            Move "23.6"             to ColumnType[i].sPrecision
82693>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82693>>>>>>>>>//            Increment i
82693>>>>>>>>>
82693>>>>>>>>>        End
82693>>>>>>>>>>
82693>>>>>>>>>
82693>>>>>>>>>        Function_Return aColumnType
82694>>>>>>>>>    End_Function
82695>>>>>>>>>
82695>>>>>>>>>    // MySQL Data Types
82695>>>>>>>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
82697>>>>>>>>>        tColumnType[] aColumnType
82697>>>>>>>>>        tColumnType[] aColumnType
82698>>>>>>>>>        Integer i
82698>>>>>>>>>
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdsmysql_DriverDef.inc)
82698>>>>>>>>>>// Generated By The Database Update Framework
82698>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
82698>>>>>>>>>>// Driver COLUMN DATA TYPES
82698>>>>>>>>>>//
82698>>>>>>>>>>// Created: 2018-03-14 23:46:49.593
82698>>>>>>>>>>
82698>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82699>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
82700>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82701>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82702>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82703>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82704>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82705>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82706>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82707>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82708>>>>>>>>>>            Increment i
82709>>>>>>>>>>
82709>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82710>>>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
82711>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82712>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82713>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82714>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82715>>>>>>>>>>            Move 64                                      to aColumnType[i].nMaxSize
82716>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82717>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82718>>>>>>>>>>            Move 64                                      to aColumnType[i].sPrecision
82719>>>>>>>>>>            Increment i
82720>>>>>>>>>>
82720>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
82721>>>>>>>>>>            Move 252                                     to aColumnType[i].iSQLType
82722>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82723>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82724>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82725>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82726>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82727>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82728>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82729>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82730>>>>>>>>>>            Increment i
82731>>>>>>>>>>
82731>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82732>>>>>>>>>>            Move 254                                     to aColumnType[i].iSQLType
82733>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82734>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82735>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82736>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82737>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82738>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82739>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82740>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82741>>>>>>>>>>            Increment i
82742>>>>>>>>>>
82742>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82743>>>>>>>>>>            Move 10                                      to aColumnType[i].iSQLType
82744>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82745>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82746>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82747>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82748>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82749>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82750>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82751>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82752>>>>>>>>>>            Increment i
82753>>>>>>>>>>
82753>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
82754>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82755>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82756>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82757>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82758>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82759>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82760>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82761>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82762>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82763>>>>>>>>>>            Increment i
82764>>>>>>>>>>
82764>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82765>>>>>>>>>>            Move 246                                     to aColumnType[i].iSQLType
82766>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82767>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82768>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82769>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82770>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82771>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82772>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82773>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82774>>>>>>>>>>            Increment i
82775>>>>>>>>>>
82775>>>>>>>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
82776>>>>>>>>>>            Move 0                                       to aColumnType[i].iSQLType
82777>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82778>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82779>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82780>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82781>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82782>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82783>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82784>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82785>>>>>>>>>>            Increment i
82786>>>>>>>>>>
82786>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
82787>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82788>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82789>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82790>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82791>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82792>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82793>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82794>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82795>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82796>>>>>>>>>>            Increment i
82797>>>>>>>>>>
82797>>>>>>>>>>            Move "enum"                                  to aColumnType[i].sSQLType
82798>>>>>>>>>>            Move 247                                     to aColumnType[i].iSQLType
82799>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82800>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82801>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82802>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82803>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82804>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82805>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82806>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82807>>>>>>>>>>            Increment i
82808>>>>>>>>>>
82808>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82809>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82810>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82811>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82812>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82813>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82814>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82815>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82816>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82817>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82818>>>>>>>>>>            Increment i
82819>>>>>>>>>>
82819>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82820>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82821>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82822>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82823>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82824>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82825>>>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
82826>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82827>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82828>>>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
82829>>>>>>>>>>            Increment i
82830>>>>>>>>>>
82830>>>>>>>>>>            Move "longblob"                              to aColumnType[i].sSQLType
82831>>>>>>>>>>            Move 251                                     to aColumnType[i].iSQLType
82832>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82833>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82834>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82835>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82836>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82837>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82838>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82839>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82840>>>>>>>>>>            Increment i
82841>>>>>>>>>>
82841>>>>>>>>>>            Move "longtext"                              to aColumnType[i].sSQLType
82842>>>>>>>>>>            Move -251                                    to aColumnType[i].iSQLType
82843>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82844>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82845>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82846>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82847>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82848>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82849>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82850>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82851>>>>>>>>>>            Increment i
82852>>>>>>>>>>
82852>>>>>>>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
82853>>>>>>>>>>            Move 250                                     to aColumnType[i].iSQLType
82854>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82855>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82856>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82857>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82858>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82859>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82860>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82861>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82862>>>>>>>>>>            Increment i
82863>>>>>>>>>>
82863>>>>>>>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
82864>>>>>>>>>>            Move 9                                       to aColumnType[i].iSQLType
82865>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82866>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82867>>>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
82868>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82869>>>>>>>>>>            Move 9                                       to aColumnType[i].nMaxSize
82870>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82871>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82872>>>>>>>>>>            Move 9                                       to aColumnType[i].sPrecision
82873>>>>>>>>>>            Increment i
82874>>>>>>>>>>
82874>>>>>>>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
82875>>>>>>>>>>            Move -250                                    to aColumnType[i].iSQLType
82876>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82877>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82878>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82879>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82880>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82881>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82882>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82883>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82884>>>>>>>>>>            Increment i
82885>>>>>>>>>>
82885>>>>>>>>>>            Move "set"                                   to aColumnType[i].sSQLType
82886>>>>>>>>>>            Move 248                                     to aColumnType[i].iSQLType
82887>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82888>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82889>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82890>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82891>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82892>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82893>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82894>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82895>>>>>>>>>>            Increment i
82896>>>>>>>>>>
82896>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82897>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82898>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82899>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82900>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82901>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82902>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
82903>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82904>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82905>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82906>>>>>>>>>>            Increment i
82907>>>>>>>>>>
82907>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82908>>>>>>>>>>            Move -252                                    to aColumnType[i].iSQLType
82909>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82910>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82911>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82912>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82913>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82914>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82915>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82916>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82917>>>>>>>>>>            Increment i
82918>>>>>>>>>>
82918>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82919>>>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
82920>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82921>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82922>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82923>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82924>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82925>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82926>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82927>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82928>>>>>>>>>>            Increment i
82929>>>>>>>>>>
82929>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
82930>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82931>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82932>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82933>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82934>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82935>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82936>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82937>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82938>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82939>>>>>>>>>>            Increment i
82940>>>>>>>>>>
82940>>>>>>>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
82941>>>>>>>>>>            Move 249                                     to aColumnType[i].iSQLType
82942>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82943>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82944>>>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
82945>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82946>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82947>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82948>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82949>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82950>>>>>>>>>>            Increment i
82951>>>>>>>>>>
82951>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82952>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82953>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82954>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82955>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82956>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82957>>>>>>>>>>            Move 4                                       to aColumnType[i].nMaxSize
82958>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82959>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82960>>>>>>>>>>            Move 4                                       to aColumnType[i].sPrecision
82961>>>>>>>>>>            Increment i
82962>>>>>>>>>>
82962>>>>>>>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
82963>>>>>>>>>>            Move -249                                    to aColumnType[i].iSQLType
82964>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82965>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82966>>>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
82967>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82968>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82969>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82970>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82971>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82972>>>>>>>>>>            Increment i
82973>>>>>>>>>>
82973>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82974>>>>>>>>>>            Move 253                                     to aColumnType[i].iSQLType
82975>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82976>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82977>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82978>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82979>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82980>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82981>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82982>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82983>>>>>>>>>>            Increment i
82984>>>>>>>>>>
82984>>>>>>>>>>            Move "year"                                  to aColumnType[i].sSQLType
82985>>>>>>>>>>            Move 13                                      to aColumnType[i].iSQLType
82986>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82987>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82988>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82989>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82990>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82991>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82992>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82993>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82994>>>>>>>>>>            Increment i
82995>>>>>>>>>>
82995>>>>>>>>>>
82995>>>>>>>>>
82995>>>>>>>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
82995>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "blob"             to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82995>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "datetime"         to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82995>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "enum"             to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "float"            to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "int"              to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "longblob"         to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "longtext"         to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "mediumint"        to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "set"              to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "10.0"             to ColumnType[i].sPrecision
82995>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82995>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "tinyint"          to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "tinytext"         to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>//
82995>>>>>>>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
82995>>>>>>>>>//        Move "year"             to ColumnType[i].sSQLType
82995>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82995>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82995>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
82995>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82995>>>>>>>>>//        Increment i
82995>>>>>>>>>
82995>>>>>>>>>        Function_Return aColumnType
82996>>>>>>>>>    End_Function
82997>>>>>>>>>
82997>>>>>>>>>    // Oracle Data Types
82997>>>>>>>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
82999>>>>>>>>>        tColumnType[] aColumnType
82999>>>>>>>>>        tColumnType[] aColumnType
83000>>>>>>>>>        Integer i
83000>>>>>>>>>
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ora_drv_DriverDef.inc)
83000>>>>>>>>>>// Generated By The Database Update Framework
83000>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
83000>>>>>>>>>>// Driver COLUMN DATA TYPES
83000>>>>>>>>>>//
83000>>>>>>>>>>// Created: 2018-03-14 23:47:34.82
83000>>>>>>>>>>
83000>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
83001>>>>>>>>>>            Move 113                                     to aColumnType[i].iSQLType
83002>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83003>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83004>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83005>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83006>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83007>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83008>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83009>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83010>>>>>>>>>>            Increment i
83011>>>>>>>>>>
83011>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
83012>>>>>>>>>>            Move 96                                      to aColumnType[i].iSQLType
83013>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83014>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83015>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83016>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83017>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
83018>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83019>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83020>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
83021>>>>>>>>>>            Increment i
83022>>>>>>>>>>
83022>>>>>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
83023>>>>>>>>>>            Move 112                                     to aColumnType[i].iSQLType
83024>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83025>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83026>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83027>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83028>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83029>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
83030>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
83031>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83032>>>>>>>>>>            Increment i
83033>>>>>>>>>>
83033>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
83034>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
83035>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83036>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83037>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83038>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
83039>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
83040>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
83041>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
83042>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83043>>>>>>>>>>            Increment i
83044>>>>>>>>>>
83044>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
83045>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
83046>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83047>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83048>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83049>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83050>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83051>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83052>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83053>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83054>>>>>>>>>>            Increment i
83055>>>>>>>>>>
83055>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
83056>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
83057>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83058>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83059>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83060>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83061>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83062>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83063>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83064>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83065>>>>>>>>>>            Increment i
83066>>>>>>>>>>
83066>>>>>>>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
83067>>>>>>>>>>            Move 190                                     to aColumnType[i].iSQLType
83068>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83069>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83070>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83071>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83072>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83073>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83074>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83075>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83076>>>>>>>>>>            Increment i
83077>>>>>>>>>>
83077>>>>>>>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
83078>>>>>>>>>>            Move 189                                     to aColumnType[i].iSQLType
83079>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83080>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83081>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83082>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83083>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83084>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83085>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83086>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83087>>>>>>>>>>            Increment i
83088>>>>>>>>>>
83088>>>>>>>>>>            Move "long"                                  to aColumnType[i].sSQLType
83089>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
83090>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83091>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83092>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83093>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83094>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83095>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83096>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83097>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83098>>>>>>>>>>            Increment i
83099>>>>>>>>>>
83099>>>>>>>>>>            Move "longraw"                               to aColumnType[i].sSQLType
83100>>>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
83101>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83102>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83103>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83104>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83105>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83106>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83107>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83108>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83109>>>>>>>>>>            Increment i
83110>>>>>>>>>>
83110>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
83111>>>>>>>>>>            Move 286                                     to aColumnType[i].iSQLType
83112>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83113>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83114>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83115>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83116>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
83117>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83118>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83119>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
83120>>>>>>>>>>            Increment i
83121>>>>>>>>>>
83121>>>>>>>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
83122>>>>>>>>>>            Move 288                                     to aColumnType[i].iSQLType
83123>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83124>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83125>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83126>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83127>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83128>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
83129>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
83130>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83131>>>>>>>>>>            Increment i
83132>>>>>>>>>>
83132>>>>>>>>>>            Move "number"                                to aColumnType[i].sSQLType
83133>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
83134>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83135>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83136>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83137>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83138>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83139>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83140>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83141>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83142>>>>>>>>>>            Increment i
83143>>>>>>>>>>
83143>>>>>>>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
83144>>>>>>>>>>            Move 287                                     to aColumnType[i].iSQLType
83145>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83146>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83147>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83148>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83149>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
83150>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83151>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83152>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
83153>>>>>>>>>>            Increment i
83154>>>>>>>>>>
83154>>>>>>>>>>            Move "raw"                                   to aColumnType[i].sSQLType
83155>>>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
83156>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83157>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83158>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83159>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83160>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
83161>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83162>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83163>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
83164>>>>>>>>>>            Increment i
83165>>>>>>>>>>
83165>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
83166>>>>>>>>>>            Move 187                                     to aColumnType[i].iSQLType
83167>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83168>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83169>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83170>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83171>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83172>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83173>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83174>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83175>>>>>>>>>>            Increment i
83176>>>>>>>>>>
83176>>>>>>>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
83177>>>>>>>>>>            Move 232                                     to aColumnType[i].iSQLType
83178>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83179>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83180>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83181>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83182>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83183>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83184>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83185>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83186>>>>>>>>>>            Increment i
83187>>>>>>>>>>
83187>>>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
83188>>>>>>>>>>            Move 188                                     to aColumnType[i].iSQLType
83189>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83190>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83191>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83192>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83193>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83194>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83195>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83196>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83197>>>>>>>>>>            Increment i
83198>>>>>>>>>>
83198>>>>>>>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
83199>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
83200>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83201>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83202>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83203>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83204>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
83205>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83206>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83207>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
83208>>>>>>>>>>            Increment i
83209>>>>>>>>>>
83209>>>>>>>>>>
83209>>>>>>>>>
83209>>>>>>>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
83209>>>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
83209>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83209>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83209>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83209>>>>>>>>>//        Increment i
83209>>>>>>>>>//
83209>>>>>>>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
83209>>>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
83209>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83209>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83209>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83209>>>>>>>>>//        Increment i
83209>>>>>>>>>//
83209>>>>>>>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
83209>>>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
83209>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83209>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83209>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83209>>>>>>>>>//        Increment i
83209>>>>>>>>>//
83209>>>>>>>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
83209>>>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
83209>>>>>>>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
83209>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
83209>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83209>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83209>>>>>>>>>//        Increment i
83209>>>>>>>>>//
83209>>>>>>>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
83209>>>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
83209>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83209>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
83209>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83209>>>>>>>>>//        Increment i
83209>>>>>>>>>//
83209>>>>>>>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
83209>>>>>>>>>//        Move "INT"              to ColumnType[i].sSQLType
83209>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83209>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
83209>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
83209>>>>>>>>>//        Increment i
83209>>>>>>>>>//
83209>>>>>>>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
83209>>>>>>>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
83209>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83209>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83209>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
83209>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83209>>>>>>>>>//        Increment i
83209>>>>>>>>>//
83209>>>>>>>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
83209>>>>>>>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
83209>>>>>>>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
83209>>>>>>>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
83209>>>>>>>>>//        Move "23.0"              to ColumnType[i].sPrecision
83209>>>>>>>>>//        Move True                to ColumnType[i].bCanEditSize
83209>>>>>>>>>//        Increment i
83209>>>>>>>>>//
83209>>>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
83209>>>>>>>>>//        Move "LONG"             to ColumnType[i].sSQLType
83209>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83209>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83209>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83209>>>>>>>>>//        Increment i
83209>>>>>>>>>//
83209>>>>>>>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
83209>>>>>>>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
83209>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83209>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83209>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83209>>>>>>>>>//        Increment i
83209>>>>>>>>>//
83209>>>>>>>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
83209>>>>>>>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
83209>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83209>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83209>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83209>>>>>>>>>//        Increment i
83209>>>>>>>>>//
83209>>>>>>>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
83209>>>>>>>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
83209>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83209>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83209>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83209>>>>>>>>>//        Increment i
83209>>>>>>>>>//
83209>>>>>>>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
83209>>>>>>>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
83209>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83209>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
83209>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83209>>>>>>>>>//        Increment i
83209>>>>>>>>>//
83209>>>>>>>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
83209>>>>>>>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
83209>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83209>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83209>>>>>>>>>//        Move "4000"             to ColumnType[i].sPrecision
83209>>>>>>>>>//        Increment i
83209>>>>>>>>>//
83209>>>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
83209>>>>>>>>>//        Move "RAW"              to ColumnType[i].sSQLType
83209>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83209>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83209>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83209>>>>>>>>>//        Increment i
83209>>>>>>>>>//
83209>>>>>>>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
83209>>>>>>>>>//        Move "ROWID"            to ColumnType[i].sSQLType
83209>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83209>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83209>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83209>>>>>>>>>//        Increment i
83209>>>>>>>>>//
83209>>>>>>>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
83209>>>>>>>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
83209>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83209>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83209>>>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
83209>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83209>>>>>>>>>//        Increment i
83209>>>>>>>>>//
83209>>>>>>>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
83209>>>>>>>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
83209>>>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
83209>>>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
83209>>>>>>>>>//        Move "13.0"                 to ColumnType[i].sPrecision
83209>>>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
83209>>>>>>>>>//        Increment i
83209>>>>>>>>>//
83209>>>>>>>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
83209>>>>>>>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
83209>>>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
83209>>>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
83209>>>>>>>>>//        Move "11.0"                 to ColumnType[i].sPrecision
83209>>>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
83209>>>>>>>>>//        Increment i
83209>>>>>>>>>//
83209>>>>>>>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
83209>>>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
83209>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83209>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83209>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83209>>>>>>>>>
83209>>>>>>>>>        Function_Return aColumnType
83210>>>>>>>>>    End_Function
83211>>>>>>>>>
83211>>>>>>>>>    // PostgreSQL Data Types
83211>>>>>>>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
83213>>>>>>>>>        tColumnType[] aColumnType
83213>>>>>>>>>        tColumnType[] aColumnType
83214>>>>>>>>>        Integer i
83214>>>>>>>>>
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdspgsql_DriverDef.inc)
83214>>>>>>>>>>// Generated By The Database Update Framework
83214>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
83214>>>>>>>>>>// Driver COLUMN DATA TYPES
83214>>>>>>>>>>//
83214>>>>>>>>>>// Created: 2018-03-14 23:47:02.984
83214>>>>>>>>>>
83214>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
83215>>>>>>>>>>            Move 20                                      to aColumnType[i].iSQLType
83216>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83217>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83218>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83219>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83220>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83221>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83222>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83223>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83224>>>>>>>>>>            Increment i
83225>>>>>>>>>>
83225>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
83226>>>>>>>>>>            Move 1560                                    to aColumnType[i].iSQLType
83227>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83228>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83229>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83230>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83231>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83232>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83233>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83234>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83235>>>>>>>>>>            Increment i
83236>>>>>>>>>>
83236>>>>>>>>>>            Move "boolean"                               to aColumnType[i].sSQLType
83237>>>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
83238>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83239>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83240>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83241>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83242>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83243>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83244>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83245>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83246>>>>>>>>>>            Increment i
83247>>>>>>>>>>
83247>>>>>>>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
83248>>>>>>>>>>            Move 17                                      to aColumnType[i].iSQLType
83249>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83250>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83251>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83252>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83253>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83254>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83255>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83256>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83257>>>>>>>>>>            Increment i
83258>>>>>>>>>>
83258>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
83259>>>>>>>>>>            Move 18                                      to aColumnType[i].iSQLType
83260>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83261>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83262>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83263>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83264>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83265>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83266>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83267>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83268>>>>>>>>>>            Increment i
83269>>>>>>>>>>
83269>>>>>>>>>>            Move "citext"                                to aColumnType[i].sSQLType
83270>>>>>>>>>>            Move -25                                     to aColumnType[i].iSQLType
83271>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83272>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83273>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83274>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83275>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83276>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83277>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83278>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83279>>>>>>>>>>            Increment i
83280>>>>>>>>>>
83280>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
83281>>>>>>>>>>            Move 1082                                    to aColumnType[i].iSQLType
83282>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83283>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83284>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83285>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83286>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83287>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
83288>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
83289>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83290>>>>>>>>>>            Increment i
83291>>>>>>>>>>
83291>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
83292>>>>>>>>>>            Move 701                                     to aColumnType[i].iSQLType
83293>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83294>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83295>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83296>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83297>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83298>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83299>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83300>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83301>>>>>>>>>>            Increment i
83302>>>>>>>>>>
83302>>>>>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
83303>>>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
83304>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83305>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83306>>>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
83307>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83308>>>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
83309>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83310>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83311>>>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
83312>>>>>>>>>>            Increment i
83313>>>>>>>>>>
83313>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
83314>>>>>>>>>>            Move 790                                     to aColumnType[i].iSQLType
83315>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83316>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83317>>>>>>>>>>            Move 30                                      to aColumnType[i].iDefaultSize
83318>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83319>>>>>>>>>>            Move 30                                      to aColumnType[i].nMaxSize
83320>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83321>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83322>>>>>>>>>>            Move 30                                      to aColumnType[i].sPrecision
83323>>>>>>>>>>            Increment i
83324>>>>>>>>>>
83324>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
83325>>>>>>>>>>            Move 1700                                    to aColumnType[i].iSQLType
83326>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83327>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83328>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83329>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83330>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83331>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83332>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83333>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83334>>>>>>>>>>            Increment i
83335>>>>>>>>>>
83335>>>>>>>>>>            Move "oid"                                   to aColumnType[i].sSQLType
83336>>>>>>>>>>            Move 26                                      to aColumnType[i].iSQLType
83337>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83338>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83339>>>>>>>>>>            Move 20                                      to aColumnType[i].iDefaultSize
83340>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83341>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83342>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83343>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83344>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83345>>>>>>>>>>            Increment i
83346>>>>>>>>>>
83346>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
83347>>>>>>>>>>            Move 700                                     to aColumnType[i].iSQLType
83348>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83349>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83350>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83351>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83352>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
83353>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83354>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83355>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83356>>>>>>>>>>            Increment i
83357>>>>>>>>>>
83357>>>>>>>>>>            Move "regproc"                               to aColumnType[i].sSQLType
83358>>>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
83359>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83360>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83361>>>>>>>>>>            Move 64                                      to aColumnType[i].iDefaultSize
83362>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83363>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83364>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83365>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83366>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83367>>>>>>>>>>            Increment i
83368>>>>>>>>>>
83368>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
83369>>>>>>>>>>            Move 21                                      to aColumnType[i].iSQLType
83370>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83371>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83372>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83373>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83374>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
83375>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83376>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83377>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83378>>>>>>>>>>            Increment i
83379>>>>>>>>>>
83379>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
83380>>>>>>>>>>            Move 25                                      to aColumnType[i].iSQLType
83381>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83382>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83383>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83384>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83385>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83386>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83387>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83388>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83389>>>>>>>>>>            Increment i
83390>>>>>>>>>>
83390>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
83391>>>>>>>>>>            Move 1083                                    to aColumnType[i].iSQLType
83392>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83393>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83394>>>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
83395>>>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
83396>>>>>>>>>>            Move 15                                      to aColumnType[i].nMaxSize
83397>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83398>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83399>>>>>>>>>>            Move 15                                      to aColumnType[i].sPrecision
83400>>>>>>>>>>            Increment i
83401>>>>>>>>>>
83401>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
83402>>>>>>>>>>            Move 1114                                    to aColumnType[i].iSQLType
83403>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83404>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83405>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83406>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83407>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83408>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83409>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83410>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83411>>>>>>>>>>            Increment i
83412>>>>>>>>>>
83412>>>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
83413>>>>>>>>>>            Move 1184                                    to aColumnType[i].iSQLType
83414>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83415>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83416>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83417>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83418>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83419>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83420>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83421>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83422>>>>>>>>>>            Increment i
83423>>>>>>>>>>
83423>>>>>>>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
83424>>>>>>>>>>            Move 2950                                    to aColumnType[i].iSQLType
83425>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83426>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83427>>>>>>>>>>            Move 40                                      to aColumnType[i].iDefaultSize
83428>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83429>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83430>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83431>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83432>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83433>>>>>>>>>>            Increment i
83434>>>>>>>>>>
83434>>>>>>>>>>            Move "varbit"                                to aColumnType[i].sSQLType
83435>>>>>>>>>>            Move 1562                                    to aColumnType[i].iSQLType
83436>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83437>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83438>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83439>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83440>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83441>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83442>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83443>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83444>>>>>>>>>>            Increment i
83445>>>>>>>>>>
83445>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
83446>>>>>>>>>>            Move 1043                                    to aColumnType[i].iSQLType
83447>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83448>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83449>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83450>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83451>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83452>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83453>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83454>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83455>>>>>>>>>>            Increment i
83456>>>>>>>>>>
83456>>>>>>>>>>
83456>>>>>>>>>
83456>>>>>>>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
83456>>>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
83456>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83456>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83456>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
83456>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83456>>>>>>>>>//        Increment i
83456>>>>>>>>>//
83456>>>>>>>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
83456>>>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
83456>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83456>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83456>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83456>>>>>>>>>//        Increment i
83456>>>>>>>>>//
83456>>>>>>>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
83456>>>>>>>>>//        Move "boolean"          to ColumnType[i].sSQLType
83456>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83456>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83456>>>>>>>>>//        Move "1"                to ColumnType[i].sPrecision
83456>>>>>>>>>//        Increment i
83456>>>>>>>>>//
83456>>>>>>>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
83456>>>>>>>>>//        Move "bytea"            to ColumnType[i].sSQLType
83456>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83456>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83456>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83456>>>>>>>>>//        Increment i
83456>>>>>>>>>//
83456>>>>>>>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
83456>>>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
83456>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83456>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83456>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83456>>>>>>>>>//        Increment i
83456>>>>>>>>>//
83456>>>>>>>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
83456>>>>>>>>>//        Move "citext"           to ColumnType[i].sSQLType
83456>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83456>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83456>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
83456>>>>>>>>>//        Increment i
83456>>>>>>>>>//
83456>>>>>>>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
83456>>>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
83456>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
83456>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
83456>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83456>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83456>>>>>>>>>//        Increment i
83456>>>>>>>>>//
83456>>>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
83456>>>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
83456>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83456>>>>>>>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
83456>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83456>>>>>>>>>//        Increment i
83456>>>>>>>>>//
83456>>>>>>>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
83456>>>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
83456>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83456>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83456>>>>>>>>>//        Move "22"               to ColumnType[i].sPrecision
83456>>>>>>>>>//        Increment i
83456>>>>>>>>>//
83456>>>>>>>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
83456>>>>>>>>>//        Move "integer"          to ColumnType[i].sSQLType
83456>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83456>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83456>>>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
83456>>>>>>>>>//        Increment i
83456>>>>>>>>>//
83456>>>>>>>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
83456>>>>>>>>>//        Move "money"            to ColumnType[i].sSQLType
83456>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83456>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83456>>>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
83456>>>>>>>>>//        Increment i
83456>>>>>>>>>//
83456>>>>>>>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
83456>>>>>>>>>//        Move "oid"              to ColumnType[i].sSQLType
83456>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83456>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83456>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83456>>>>>>>>>//        Increment i
83456>>>>>>>>>//
83456>>>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
83456>>>>>>>>>//        Move "real"             to ColumnType[i].sSQLType
83456>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83456>>>>>>>>>//        Move "Real"             to ColumnType[i].sDataFlexType
83456>>>>>>>>>//        Move "6.6"              to ColumnType[i].sPrecision
83456>>>>>>>>>//        Increment i
83456>>>>>>>>>//
83456>>>>>>>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
83456>>>>>>>>>//        Move "regproc"          to ColumnType[i].sSQLType
83456>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83456>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83456>>>>>>>>>//        Move "64"               to ColumnType[i].sPrecision
83456>>>>>>>>>//        Increment i
83456>>>>>>>>>//
83456>>>>>>>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
83456>>>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
83456>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83456>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83456>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83456>>>>>>>>>//        Increment i
83456>>>>>>>>>//
83456>>>>>>>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
83456>>>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
83456>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83456>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83456>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83456>>>>>>>>>//        Increment i
83456>>>>>>>>>//
83456>>>>>>>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
83456>>>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
83456>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83456>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83456>>>>>>>>>//        Move "15.0"             to ColumnType[i].sPrecision
83456>>>>>>>>>//        Increment i
83456>>>>>>>>>//
83456>>>>>>>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
83456>>>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
83456>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83456>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83456>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
83456>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83456>>>>>>>>>//        Increment i
83456>>>>>>>>>//
83456>>>>>>>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
83456>>>>>>>>>//        Move "uuid"             to ColumnType[i].sSQLType
83456>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83456>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83456>>>>>>>>>//        Move "40"               to ColumnType[i].sPrecision
83456>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83456>>>>>>>>>//        Increment i
83456>>>>>>>>>//
83456>>>>>>>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
83456>>>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
83456>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83456>>>>>>>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
83456>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83456>>>>>>>>>//        Increment i
83456>>>>>>>>>
83456>>>>>>>>>        Function_Return aColumnType
83457>>>>>>>>>    End_Function
83458>>>>>>>>>
83458>>>>>>>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
83458>>>>>>>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
83460>>>>>>>>>        Integer iValue iSize iCount iStart iItem
83460>>>>>>>>>        tColumnType[] ColumnTypeArray
83460>>>>>>>>>        tColumnType[] ColumnTypeArray
83461>>>>>>>>>        tColumnType RetvalType
83461>>>>>>>>>        tColumnType RetvalType
83461>>>>>>>>>        String sValue
83461>>>>>>>>>        Boolean bFrameworkDataFlexType
83461>>>>>>>>>
83461>>>>>>>>>        Move "Undefined" to RetvalType.sSQLType
83462>>>>>>>>>        Move -1999       to RetvalType.iSQLType
83463>>>>>>>>>
83463>>>>>>>>>        Move 0 to iStart
83464>>>>>>>>>        Move (Uppercase(sType)) to sType
83465>>>>>>>>>        Move (iType <= -1490) to bFrameworkDataFlexType
83466>>>>>>>>>        If (bFrameworkDataFlexType = True) Begin
83468>>>>>>>>>            Get _UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
83469>>>>>>>>>            Function_Return RetvalType
83470>>>>>>>>>        End
83470>>>>>>>>>>
83470>>>>>>>>>
83470>>>>>>>>>        Get _UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
83471>>>>>>>>>        Move iType to RetvalType.iSQLType
83472>>>>>>>>>        Move sType to RetvalType.sSQLType 
83473>>>>>>>>>        Move (SearchArray(RetvalType, ColumnTypeArray)) to iItem
83474>>>>>>>>>        
83474>>>>>>>>>        If (iItem = -1) Begin
83476>>>>>>>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
83477>>>>>>>>>            Move (SearchArray(RetvalType, ColumnTypeArray)) to iItem
83478>>>>>>>>>        End
83478>>>>>>>>>>
83478>>>>>>>>>        If (iItem <> -1) Begin
83480>>>>>>>>>            Move ColumnTypeArray[iItem].sSQLType       to RetvalType.sSQLType
83481>>>>>>>>>            Move ColumnTypeArray[iItem].iSQLType       to RetvalType.iSQLType
83482>>>>>>>>>            Move ColumnTypeArray[iItem].sDataFlexType  to RetvalType.sDataFlexType
83483>>>>>>>>>            Move ColumnTypeArray[iItem].iDataFlexType  to RetvalType.iDataFlexType
83484>>>>>>>>>            Move ColumnTypeArray[iItem].sPrecision     to RetvalType.sPrecision
83485>>>>>>>>>            Move ColumnTypeArray[iItem].bCanEditSize   to RetvalType.bCanEditSize
83486>>>>>>>>>        End
83486>>>>>>>>>>
83486>>>>>>>>>
83486>>>>>>>>>        Function_Return RetvalType
83487>>>>>>>>>    End_Function
83488>>>>>>>>>
83488>>>>>>>>>    // Returns a struct array with all data types for the passed driver & dbtype.
83488>>>>>>>>>    Function _UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
83490>>>>>>>>>        tColumnType[] ColumnType
83490>>>>>>>>>        tColumnType[] ColumnType
83491>>>>>>>>>
83491>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
83491>>>>>>>>>        // the dbType.
83491>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83493>>>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
83495>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
83496>>>>>>>>>            End
83496>>>>>>>>>>
83496>>>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
83498>>>>>>>>>                Move MSSQLDRV_ID to sDriverID
83499>>>>>>>>>            End
83499>>>>>>>>>>
83499>>>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
83501>>>>>>>>>                Move DB2_DRV_ID to sDriverID
83502>>>>>>>>>            End
83502>>>>>>>>>>
83502>>>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
83504>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
83505>>>>>>>>>            End
83505>>>>>>>>>>
83505>>>>>>>>>        End
83505>>>>>>>>>>
83505>>>>>>>>>
83505>>>>>>>>>        Case Begin
83505>>>>>>>>>            Case (iDbType = EN_dbTypeDataFlex)
83507>>>>>>>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
83508>>>>>>>>>                Case Break
83509>>>>>>>>>
83509>>>>>>>>>            Case (iDbType = EN_DbTypeDB2)
83512>>>>>>>>>                Get _UtilEnumerateDB2Types to ColumnType
83513>>>>>>>>>                Case Break
83514>>>>>>>>>
83514>>>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
83517>>>>>>>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
83518>>>>>>>>>                Case Break
83519>>>>>>>>>        Case End
83519>>>>>>>>>
83519>>>>>>>>>        Function_Return ColumnType
83520>>>>>>>>>    End_Function
83521>>>>>>>>>
83521>>>>>>>>>    // Returns a struct with the default column types for the SQL back-end and how they
83521>>>>>>>>>    // are mapped to a DUF data type.
83521>>>>>>>>>    Function _UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
83523>>>>>>>>>        tColumnType ColumnType
83523>>>>>>>>>        tColumnType ColumnType
83523>>>>>>>>>        String sDataType
83523>>>>>>>>>        Integer iDriverID iCount
83523>>>>>>>>>
83523>>>>>>>>>        Move 0 to iCount
83524>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
83525>>>>>>>>>
83525>>>>>>>>>        Case Begin
83525>>>>>>>>>            // DF_ASCII
83525>>>>>>>>>            Case (iType = DF_ASCII_DUF)
83527>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83529>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
83532>>>>>>>>>                End
83532>>>>>>>>>>
83532>>>>>>>>>                Else Begin
83533>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
83536>>>>>>>>>                End
83536>>>>>>>>>>
83536>>>>>>>>>                Move DF_ASCII    to ColumnType.iDataFlexType
83537>>>>>>>>>                Move "ASCII"     to ColumnType.sDataFlexType
83538>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83539>>>>>>>>>                Move DF_ASCII    to ColumnType.iSQLType
83540>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83541>>>>>>>>>                Case Break
83542>>>>>>>>>
83542>>>>>>>>>            // DF_BINARY
83542>>>>>>>>>            Case (iType = DF_BINARY_DUF)
83545>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83547>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
83550>>>>>>>>>                End
83550>>>>>>>>>>
83550>>>>>>>>>                Else Begin
83551>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
83554>>>>>>>>>                End
83554>>>>>>>>>>
83554>>>>>>>>>                Move DF_BINARY   to ColumnType.iDataFlexType
83555>>>>>>>>>                Move "Binary"    to ColumnType.sDataFlexType
83556>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83557>>>>>>>>>                Move DF_BINARY   to ColumnType.iSQLType
83558>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83559>>>>>>>>>                Case Break
83560>>>>>>>>>
83560>>>>>>>>>            // DF_DATE
83560>>>>>>>>>            Case (iType = DF_DATE_DUF)
83563>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83565>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83568>>>>>>>>>                End
83568>>>>>>>>>>
83568>>>>>>>>>                Else Begin
83569>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83572>>>>>>>>>                End
83572>>>>>>>>>>
83572>>>>>>>>>                Move DF_DATE     to ColumnType.iDataFlexType
83573>>>>>>>>>                Move "Date"      to ColumnType.sDataFlexType
83574>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83575>>>>>>>>>                Move DF_DATE     to ColumnType.iSQLType
83576>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83577>>>>>>>>>                Case Break
83578>>>>>>>>>
83578>>>>>>>>>            // DF_DATETIME
83578>>>>>>>>>            Case (iType = DF_DATETIME_DUF)
83581>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83583>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
83586>>>>>>>>>                End
83586>>>>>>>>>>
83586>>>>>>>>>                Else Begin
83587>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
83590>>>>>>>>>                End
83590>>>>>>>>>>
83590>>>>>>>>>                Move DF_DATETIME to ColumnType.iDataFlexType
83591>>>>>>>>>                Move "DateTime"  to ColumnType.sDataFlexType
83592>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83593>>>>>>>>>                Move DF_DATETIME to ColumnType.iSQLType
83594>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83595>>>>>>>>>                Case Break
83596>>>>>>>>>
83596>>>>>>>>>            // DF_NUMERIC
83596>>>>>>>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
83596>>>>>>>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
83596>>>>>>>>>            // we make them here all "Numeric"...
83596>>>>>>>>>            // If (sDriverID = ODBC_DRV_ID) Begin
83596>>>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83596>>>>>>>>>            // End
83596>>>>>>>>>            // Else Begin
83596>>>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83596>>>>>>>>>            // End
83596>>>>>>>>>            // ToDo: How should we find the best "Numeric" data type here?
83596>>>>>>>>>            Case (iType = DF_BCD_DUF)
83599>>>>>>>>>                Move DF_BCD      to ColumnType.iDataFlexType
83600>>>>>>>>>                Move "Numeric"   to ColumnType.sDataFlexType
83601>>>>>>>>>                Move "Numeric"   to ColumnType.sSQLType
83602>>>>>>>>>                Move SQL_NUMERIC to ColumnType.iSQLType
83603>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83604>>>>>>>>>                Case Break
83605>>>>>>>>>
83605>>>>>>>>>            // DF_TEXT
83605>>>>>>>>>            Case (iType = DF_TEXT_DUF)
83608>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83610>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
83613>>>>>>>>>                End
83613>>>>>>>>>>
83613>>>>>>>>>                Else Begin
83614>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
83617>>>>>>>>>                End
83617>>>>>>>>>>
83617>>>>>>>>>                Move DF_TEXT     to ColumnType.iDataFlexType
83618>>>>>>>>>                Move "Text"      to ColumnType.sDataFlexType
83619>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83620>>>>>>>>>                Move DF_TEXT     to ColumnType.iSQLType
83621>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83622>>>>>>>>>                Case Break
83623>>>>>>>>>
83623>>>>>>>>>            Case Else
83623>>>>>>>>>                Move -1999       to ColumnType.iDataFlexType
83624>>>>>>>>>                Move "Undefined" to ColumnType.sDataFlexType
83625>>>>>>>>>                Move "Undefined" to ColumnType.sSQLType
83626>>>>>>>>>                Move -1999       to ColumnType.iSQLType
83627>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83628>>>>>>>>>
83628>>>>>>>>>        Case End
83628>>>>>>>>>
83628>>>>>>>>>        Function_Return ColumnType
83629>>>>>>>>>    End_Function
83630>>>>>>>>>
83630>>>>>>>>>    Function _AllTablesToConvert Returns Integer[]
83632>>>>>>>>>        Integer[] aTableConvertExceptions iTablesArray
83634>>>>>>>>>        Handle hTable
83634>>>>>>>>>        Integer iIndex
83634>>>>>>>>>        String sTableName
83634>>>>>>>>>        Boolean bFlexErrs
83634>>>>>>>>>
83634>>>>>>>>>        // a) Get the exception table array the developer has specified
83634>>>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
83635>>>>>>>>>
83635>>>>>>>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
83635>>>>>>>>>        Repeat
83635>>>>>>>>>>
83635>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83638>>>>>>>>>            If (hTable <> 0) Begin
83640>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83643>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83644>>>>>>>>>                If (bFlexErrs = False) Begin
83646>>>>>>>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
83648>>>>>>>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
83649>>>>>>>>>                        If (iIndex = -1) Begin
83651>>>>>>>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
83652>>>>>>>>>                        End
83652>>>>>>>>>>
83652>>>>>>>>>                    End
83652>>>>>>>>>>
83652>>>>>>>>>                End
83652>>>>>>>>>>
83652>>>>>>>>>            End
83652>>>>>>>>>>
83652>>>>>>>>>        Until (hTable = 0)
83654>>>>>>>>>
83654>>>>>>>>>        Move 0 to hTable
83655>>>>>>>>>
83655>>>>>>>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
83655>>>>>>>>>        Repeat
83655>>>>>>>>>>
83655>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83658>>>>>>>>>            If (hTable > 0) Begin
83660>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83663>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83664>>>>>>>>>                If (bFlexErrs = False) Begin
83666>>>>>>>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
83667>>>>>>>>>                    If (iIndex = -1) Begin
83669>>>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
83670>>>>>>>>>                    End
83670>>>>>>>>>>
83670>>>>>>>>>                End
83670>>>>>>>>>>
83670>>>>>>>>>            End
83670>>>>>>>>>>
83670>>>>>>>>>        Until (hTable = 0)
83672>>>>>>>>>
83672>>>>>>>>>        Function_Return iTablesArray
83673>>>>>>>>>    End_Function
83674>>>>>>>>>
83674>>>>>>>>>    Function _AllTablesDateCorrections Returns Integer[]
83676>>>>>>>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
83678>>>>>>>>>        Handle hTable
83678>>>>>>>>>        Integer iIndex
83678>>>>>>>>>        String sTableName
83678>>>>>>>>>        Boolean bFlexErrs
83678>>>>>>>>>
83678>>>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
83679>>>>>>>>>        Move 0 to hTable
83680>>>>>>>>>
83680>>>>>>>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
83680>>>>>>>>>        Repeat
83680>>>>>>>>>>
83680>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83683>>>>>>>>>            If (hTable > 0) Begin
83685>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83688>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83689>>>>>>>>>                If (bFlexErrs = False) Begin
83691>>>>>>>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
83692>>>>>>>>>                    If (iIndex = -1) Begin
83694>>>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
83695>>>>>>>>>                    End
83695>>>>>>>>>>
83695>>>>>>>>>                End
83695>>>>>>>>>>
83695>>>>>>>>>            End
83695>>>>>>>>>>
83695>>>>>>>>>        Until (hTable = 0)
83697>>>>>>>>>
83697>>>>>>>>>        Function_Return iTablesArray
83698>>>>>>>>>    End_Function
83699>>>>>>>>>
83699>>>>>>>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
83701>>>>>>>>>        tAPIColumn NewAPIColumn
83701>>>>>>>>>        tAPIColumn NewAPIColumn
83701>>>>>>>>>
83701>>>>>>>>>        Move sFieldName to NewAPIColumn.sFieldName
83702>>>>>>>>>        Move iType      to NewAPIColumn.iType
83703>>>>>>>>>        Move iLength    to NewAPIColumn.iLength
83704>>>>>>>>>        Move iPrecision to NewAPIColumn.iPrecision
83705>>>>>>>>>        Move iOptions   to NewAPIColumn.iOptions
83706>>>>>>>>>
83706>>>>>>>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
83707>>>>>>>>>
83707>>>>>>>>>        Function_Return aCurrent
83708>>>>>>>>>    End_Function
83709>>>>>>>>>
83709>>>>>>>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
83711>>>>>>>>>        String sRetval sFieldName
83711>>>>>>>>>        Integer iCount iSize
83711>>>>>>>>>
83711>>>>>>>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
83712>>>>>>>>>        Decrement iSize
83713>>>>>>>>>        For iCount from 0 to iSize
83719>>>>>>>>>>
83719>>>>>>>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
83720>>>>>>>>>            Move (sRetval * (String(sFieldName))) to sRetval
83721>>>>>>>>>        Loop
83722>>>>>>>>>>
83722>>>>>>>>>        Move (Trim(sRetval)) to sRetval
83723>>>>>>>>>
83723>>>>>>>>>        Function_Return sRetval
83724>>>>>>>>>    End_Function
83725>>>>>>>>>
83725>>>>>>>>>    // *** Miscellaneous other functions ***
83725>>>>>>>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
83725>>>>>>>>>    //
83725>>>>>>>>>
83725>>>>>>>>>    // Callback functionality used when e.g. calling driver functions directly.
83725>>>>>>>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
83727>>>>>>>>>        Integer iPerc
83727>>>>>>>>>        Number nReady nTotal
83727>>>>>>>>>
83727>>>>>>>>>        Send DoAdvance of ghoProgressBar
83728>>>>>>>>>
83728>>>>>>>>>        If (sCallback_Text contains "Copy records") Begin
83730>>>>>>>>>            Move CS_DUF_CopyingData to sCallback_Text
83731>>>>>>>>>        End
83731>>>>>>>>>>
83731>>>>>>>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
83733>>>>>>>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
83734>>>>>>>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
83735>>>>>>>>>        End
83735>>>>>>>>>>
83735>>>>>>>>>        If (sCallback_Text contains "Creating index") Begin
83737>>>>>>>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
83738>>>>>>>>>        End
83738>>>>>>>>>>
83738>>>>>>>>>
83738>>>>>>>>>        Case Begin
83738>>>>>>>>>            Case (iCallback_Type = DF_Message_Text)
83740>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83741>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83742>>>>>>>>>                Case Break
83743>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_1)
83746>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83747>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83748>>>>>>>>>                Case Break
83749>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_2)
83752>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83753>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83754>>>>>>>>>                Case Break
83755>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_3)
83758>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83759>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83760>>>>>>>>>                Case Break
83761>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_4)
83764>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83765>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83766>>>>>>>>>                Case Break
83767>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_5)
83770>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83771>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83772>>>>>>>>>                Case Break
83773>>>>>>>>>            Case (iCallback_Type = DF_Message_Warning)
83776>>>>>>>>>                Send None
83777>>>>>>>>>                Case Break
83778>>>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Title)
83781>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83782>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83783>>>>>>>>>                Case Break
83784>>>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Value)
83787>>>>>>>>>                //*** Interpret numbers
83787>>>>>>>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
83788>>>>>>>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
83789>>>>>>>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
83790>>>>>>>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
83791>>>>>>>>>                Case Break
83792>>>>>>>>>            Case Else
83792>>>>>>>>>                Set Message_Text to ""
83793>>>>>>>>>                Set Action_Text  to ""
83794>>>>>>>>>        Case End
83794>>>>>>>>>
83794>>>>>>>>>        Send ProcessEvents of ghoStatusPanel
83795>>>>>>>>>        Function_Return False
83796>>>>>>>>>    End_Function
83797>>>>>>>>>
83797>>>>>>>>>    // * Dummy function for the Studio's Code Explorer *
83797>>>>>>>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
83799>>>>>>>>>        Function_Return False
83800>>>>>>>>>    End_Function
83801>>>>>>>>>
83801>>>>>>>>>    // *** Helper functions with compiled sql script code ***
83801>>>>>>>>>    //
83801>>>>>>>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
83801>>>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
83801>>>>>>>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
83801>>>>>>>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
83801>>>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
83801>>>>>>>>>    //   ALTER TABLE MyTable
83801>>>>>>>>>    //       REBUILD
83801>>>>>>>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
83803>>>>>>>>>        Boolean bOK
83803>>>>>>>>>
83803>>>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
83805>>>>>>>>>            Function_Return False
83806>>>>>>>>>        End
83806>>>>>>>>>>
83806>>>>>>>>>
83806>>>>>>>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
83806>>>>>>>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
83807>>>>>>>>>
83807>>>>>>>>>        Function_Return (bOK = True)
83808>>>>>>>>>    End_Function
83809>>>>>>>>>
83809>>>>>>>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
83809>>>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
83809>>>>>>>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
83809>>>>>>>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
83809>>>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
83809>>>>>>>>>    //   ALTER TABLE MyTable
83809>>>>>>>>>    //       REBUILD
83809>>>>>>>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
83811>>>>>>>>>        tSQLScriptArray SQLScriptArray
83811>>>>>>>>>        tSQLScriptArray SQLScriptArray
83811>>>>>>>>>        String sDriverID
83811>>>>>>>>>        Boolean bOK
83811>>>>>>>>>        Integer iSize iCount
83811>>>>>>>>>
83811>>>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
83813>>>>>>>>>            Function_Return False
83814>>>>>>>>>        End
83814>>>>>>>>>>
83814>>>>>>>>>
83814>>>>>>>>>        Get psDriverID to sDriverID
83815>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83816>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
83818>>>>>>>>>            Function_Return False
83819>>>>>>>>>        End
83819>>>>>>>>>>
83819>>>>>>>>>
83819>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83820>>>>>>>>>        Decrement iSize
83821>>>>>>>>>
83821>>>>>>>>>        For iCount from 0 to iSize
83827>>>>>>>>>>
83827>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
83829>>>>>>>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
83830>>>>>>>>>            End
83830>>>>>>>>>>
83830>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
83832>>>>>>>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
83833>>>>>>>>>            End
83833>>>>>>>>>>
83833>>>>>>>>>        Loop
83834>>>>>>>>>>
83834>>>>>>>>>
83834>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83835>>>>>>>>>
83835>>>>>>>>>        Function_Return (bOK = True)
83836>>>>>>>>>    End_Function
83837>>>>>>>>>
83837>>>>>>>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
83837>>>>>>>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
83837>>>>>>>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
83837>>>>>>>>>    Function _SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
83839>>>>>>>>>        Integer iChannel iArgumentSize iCount
83839>>>>>>>>>        Number nByteCount
83839>>>>>>>>>        String sSQLScript
83839>>>>>>>>>        tSQLScriptArray SqlScriptArray
83839>>>>>>>>>        tSQLScriptArray SqlScriptArray
83839>>>>>>>>>        UChar[] uCharData
83840>>>>>>>>>
83840>>>>>>>>>        Move False to Err
83841>>>>>>>>>        Get Seq_New_Channel to iChannel
83842>>>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83844>>>>>>>>>            Error DFERR_PROGRAM 'No channel available...'
83845>>>>>>>>>>
83845>>>>>>>>>            Move True to SqlScriptArray.bError
83846>>>>>>>>>            Function_Return SqlScriptArray
83847>>>>>>>>>        End
83847>>>>>>>>>>
83847>>>>>>>>>
83847>>>>>>>>>        // First decide the size of the script
83847>>>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83849>>>>>>>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
83851>>>>>>>>>        Close_Input channel iChannel
83853>>>>>>>>>
83853>>>>>>>>>        Move (SizeOfArray(uCharData)) to nByteCount
83854>>>>>>>>>        If (nByteCount  < 1) Begin
83856>>>>>>>>>            Send Seq_Release_Channel iChannel
83857>>>>>>>>>            Move True to SqlScriptArray.bError
83858>>>>>>>>>            Function_Return SqlScriptArray
83859>>>>>>>>>        End
83859>>>>>>>>>>
83859>>>>>>>>>
83859>>>>>>>>>        // If necessary change the string argument_size
83859>>>>>>>>>        // Read the script file from memory line-by-line
83859>>>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83861>>>>>>>>>            Move 0 to iCount
83862>>>>>>>>>            Repeat
83862>>>>>>>>>>
83862>>>>>>>>>                Readln channel iChannel sSQLScript
83864>>>>>>>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
83865>>>>>>>>>                Increment iCount
83866>>>>>>>>>            Until (SeqEof = True)
83868>>>>>>>>>        Close_Input channel iChannel
83870>>>>>>>>>        Send Seq_Release_Channel iChannel
83871>>>>>>>>>
83871>>>>>>>>>        // Finally "sanitize" the script by removing all comments.
83871>>>>>>>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
83872>>>>>>>>>
83872>>>>>>>>>        Function_Return SqlScriptArray
83873>>>>>>>>>    End_Function
83874>>>>>>>>>
83874>>>>>>>>>    Function _SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
83876>>>>>>>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
83876>>>>>>>>>        Handle hoSql hoSQLConnect hoStmt hoError
83876>>>>>>>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage iPos
83876>>>>>>>>>        String[] sMsg aSQLQueryMessages
83878>>>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd
83878>>>>>>>>>        TimeSpan tsQuery
83878>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83878>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83878>>>>>>>>>        tSQLConnection SQLConnection
83878>>>>>>>>>        tSQLConnection SQLConnection
83878>>>>>>>>>        Boolean bShowProgress
83878>>>>>>>>>
83878>>>>>>>>>        If (num_arguments > 4) Begin
83880>>>>>>>>>            Move bShowProgr to bShowProgress
83881>>>>>>>>>        End
83881>>>>>>>>>>
83881>>>>>>>>>        Get phoSQLManager to hoSql
83882>>>>>>>>>
83882>>>>>>>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
83883>>>>>>>>>        // There seems to be a problem to pass strings when their value gets really big, aka
83883>>>>>>>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
83883>>>>>>>>>        // or later SqlExecDirect stops working correctly with no error messages!
83883>>>>>>>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
83883>>>>>>>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
83883>>>>>>>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
83883>>>>>>>>>        Get piChunkMax to iChunkMax
83884>>>>>>>>>        Move 0 to iChunkCounter
83885>>>>>>>>>        Move "" to sStmt
83886>>>>>>>>>
83886>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
83887>>>>>>>>>        Move (Character(13) + Character(10)) to sCR
83888>>>>>>>>>
83888>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
83889>>>>>>>>>
83889>>>>>>>>>        Get phoSQLManager  to hoSQL
83890>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83892>>>>>>>>>            If (Uppercase(SQLConnection.sConnectionString) contains CS_SQLIniDSNKeyword) Begin
83894>>>>>>>>>                Move (Pos(";", SQLConnection.sConnectionString)) to iPos
83895>>>>>>>>>                If (iPos > 0) Begin
83897>>>>>>>>>                    Move (Left(SQLConnection.sConnectionString, (iPos - 1))) to SQLConnection.sConnectionString
83898>>>>>>>>>                    Move (Trim(SQLConnection.sConnectionString)) to SQLConnection.sConnectionString
83899>>>>>>>>>                End
83899>>>>>>>>>>
83899>>>>>>>>>            End
83899>>>>>>>>>>
83899>>>>>>>>>        End
83899>>>>>>>>>>
83899>>>>>>>>>        Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
83900>>>>>>>>>        Get SqlConnect     of hoSQL "" "" to hoSQLConnect
83901>>>>>>>>>
83901>>>>>>>>>        If (hoSQLConnect <> 0) Begin
83903>>>>>>>>>            Move False to Err
83904>>>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
83905>>>>>>>>>            If (hoStmt <> 0) Begin
83907>>>>>>>>>
83907>>>>>>>>>                // If the embedded resource should be written as a script file to disk:
83907>>>>>>>>>                If (bCreateScriptFile = True) Begin
83909>>>>>>>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
83910>>>>>>>>>                    Get vFolderFormat sExportFile to sExportFile
83911>>>>>>>>>                    Move (sExportFile + sMemFileName) to sExportFile
83912>>>>>>>>>                    Get Seq_New_Channel to iOut
83913>>>>>>>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83915>>>>>>>>>                        Direct_Output channel iOut sExportFile
83917>>>>>>>>>                    End
83917>>>>>>>>>>
83917>>>>>>>>>                End
83917>>>>>>>>>>
83917>>>>>>>>>
83917>>>>>>>>>                // Record starting date/time stamp
83917>>>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
83918>>>>>>>>>                // Turn on error handling if enabled
83918>>>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
83920>>>>>>>>>                    Set pbSqlError to False
83921>>>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
83922>>>>>>>>>                    Move Error_Object_Id to hoError
83923>>>>>>>>>                    Move Self to Error_Object_Id
83924>>>>>>>>>                End
83924>>>>>>>>>>
83924>>>>>>>>>
83924>>>>>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
83925>>>>>>>>>                Decrement iRows
83926>>>>>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
83928>>>>>>>>>                    Move (sNoCountKeyWord + sCR) to sStmt
83929>>>>>>>>>                End
83929>>>>>>>>>>
83929>>>>>>>>>
83929>>>>>>>>>                for iCount from 0 to iRows
83935>>>>>>>>>>
83935>>>>>>>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
83936>>>>>>>>>
83936>>>>>>>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
83938>>>>>>>>>                        If (sSQLVal <> "") Begin
83940>>>>>>>>>                            Move (sSQLVal + sCR) to sSQLVal
83941>>>>>>>>>                        End
83941>>>>>>>>>>
83941>>>>>>>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
83942>>>>>>>>>                    End
83942>>>>>>>>>>
83942>>>>>>>>>
83942>>>>>>>>>                    // - Each time we encounter a "GO" statement we execute it,
83942>>>>>>>>>                    // or if at the very end of the script.
83942>>>>>>>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
83944>>>>>>>>>
83944>>>>>>>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
83944>>>>>>>>>                        // instead of all in one go.
83944>>>>>>>>>                        Send SqlExecDirect of hoStmt sStmt
83945>>>>>>>>>
83945>>>>>>>>>                        If (bCreateScriptFile = True) Begin
83947>>>>>>>>>                            Write channel iOut sStmt
83949>>>>>>>>>                        End
83949>>>>>>>>>>
83949>>>>>>>>>                        Move "" to sStmt
83950>>>>>>>>>                        Move 0 to iChunkCounter
83951>>>>>>>>>                    End
83951>>>>>>>>>>
83951>>>>>>>>>                    Increment iChunkCounter
83952>>>>>>>>>                Loop
83953>>>>>>>>>>
83953>>>>>>>>>
83953>>>>>>>>>                Repeat
83953>>>>>>>>>>
83953>>>>>>>>>                    If (pbHandleQueryErrors(Self)) Begin
83955>>>>>>>>>                        Move hoError to Error_Object_Id
83956>>>>>>>>>                    End
83956>>>>>>>>>>
83956>>>>>>>>>                    Move (CurrentDateTime()) to dtQueryExecEnd
83957>>>>>>>>>
83957>>>>>>>>>                    Send _SqlColumnInfo hoStmt
83958>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
83959>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
83960>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
83961>>>>>>>>>                    Set piRows    to iRows
83962>>>>>>>>>                    Set piRowType to iRowType
83963>>>>>>>>>
83963>>>>>>>>>                    If (iMsgs <> 0) Begin
83965>>>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
83967>>>>>>>>>                            Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83968>>>>>>>>>                        End
83968>>>>>>>>>>
83968>>>>>>>>>                        for i from 1 to iMsgs
83974>>>>>>>>>>
83974>>>>>>>>>                            Get SqlGetMessage of hoStmt i to sMessage
83975>>>>>>>>>                            Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
83976>>>>>>>>>                            If (bShowProgress = True) Begin
83978>>>>>>>>>                                If (Active_State(ghoStatusPanel)) Begin
83980>>>>>>>>>                                    Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
83981>>>>>>>>>                                End
83981>>>>>>>>>>
83981>>>>>>>>>                                Else Begin
83982>>>>>>>>>                                    Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
83984>>>>>>>>>                                End
83984>>>>>>>>>>
83984>>>>>>>>>                            End
83984>>>>>>>>>>
83984>>>>>>>>>                            Move sMessage to sMsg[SizeOfArray(sMsg)]
83985>>>>>>>>>                            Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
83986>>>>>>>>>                        Loop
83987>>>>>>>>>>
83987>>>>>>>>>
83987>>>>>>>>>
83987>>>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
83989>>>>>>>>>                            Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83990>>>>>>>>>                        End
83990>>>>>>>>>>
83990>>>>>>>>>                        Set paQueryMessages to sMsg
83991>>>>>>>>>                    End
83991>>>>>>>>>>
83991>>>>>>>>>
83991>>>>>>>>>                    Get SQLNextResultSet of hoStmt to iNextSet
83992>>>>>>>>>                Until (iNextSet = 0)
83994>>>>>>>>>
83994>>>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
83995>>>>>>>>>            End
83995>>>>>>>>>>
83995>>>>>>>>>
83995>>>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
83996>>>>>>>>>            Set ptsQueryExec to tsQuery
83997>>>>>>>>>            Send SqlClose of hoStmt
83998>>>>>>>>>
83998>>>>>>>>>            If (bCreateScriptFile = True) Begin
84000>>>>>>>>>                Close_Output channel iOut
84002>>>>>>>>>                Send Seq_Release_Channel iOut
84003>>>>>>>>>            End
84003>>>>>>>>>>
84003>>>>>>>>>        End
84003>>>>>>>>>>
84003>>>>>>>>>        Send SqlDisconnect of hoSQLConnect
84004>>>>>>>>>
84004>>>>>>>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
84005>>>>>>>>>    End_Function
84006>>>>>>>>>
84006>>>>>>>>>    Function _SqlUtilCreatePostGreSQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
84008>>>>>>>>>        tSQLScriptArray SQLScriptArray
84008>>>>>>>>>        tSQLScriptArray SQLScriptArray
84008>>>>>>>>>        String sDriverID sCollation
84008>>>>>>>>>        Boolean bOK
84008>>>>>>>>>        Integer iSize iCount
84008>>>>>>>>>
84008>>>>>>>>>        If (Trim(sDatabaseName) = "") Begin
84010>>>>>>>>>            Function_Return False
84011>>>>>>>>>        End
84011>>>>>>>>>>
84011>>>>>>>>>
84011>>>>>>>>>        Get psDriverID  to sDriverID
84012>>>>>>>>>        Get psCollation to sCollation
84013>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
84014>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
84016>>>>>>>>>            Function_Return False
84017>>>>>>>>>        End
84017>>>>>>>>>>
84017>>>>>>>>>
84017>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
84018>>>>>>>>>        Decrement iSize
84019>>>>>>>>>
84019>>>>>>>>>        For iCount from 0 to iSize
84025>>>>>>>>>>
84025>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
84027>>>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
84028>>>>>>>>>            End
84028>>>>>>>>>>
84028>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
84030>>>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
84031>>>>>>>>>            End
84031>>>>>>>>>>
84031>>>>>>>>>        Loop
84032>>>>>>>>>>
84032>>>>>>>>>
84032>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
84033>>>>>>>>>
84033>>>>>>>>>        Function_Return (bOK = True)
84034>>>>>>>>>    End_Function
84035>>>>>>>>>
84035>>>>>>>>>    Function _SqlUtilCreateMySQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
84037>>>>>>>>>        tSQLScriptArray SQLScriptArray
84037>>>>>>>>>        tSQLScriptArray SQLScriptArray
84037>>>>>>>>>        String sDriverID sCollation
84037>>>>>>>>>        Boolean bOK
84037>>>>>>>>>        Integer iSize iCount
84037>>>>>>>>>
84037>>>>>>>>>        If (Trim(sDatabaseName) = "") Begin
84039>>>>>>>>>            Function_Return False
84040>>>>>>>>>        End
84040>>>>>>>>>>
84040>>>>>>>>>
84040>>>>>>>>>        Get psDriverID  to sDriverID
84041>>>>>>>>>        Get psCollation to sCollation
84042>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
84043>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
84045>>>>>>>>>            Function_Return False
84046>>>>>>>>>        End
84046>>>>>>>>>>
84046>>>>>>>>>
84046>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
84047>>>>>>>>>        Decrement iSize
84048>>>>>>>>>
84048>>>>>>>>>        For iCount from 0 to iSize
84054>>>>>>>>>>
84054>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
84056>>>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
84057>>>>>>>>>            End
84057>>>>>>>>>>
84057>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
84059>>>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
84060>>>>>>>>>            End
84060>>>>>>>>>>
84060>>>>>>>>>        Loop
84061>>>>>>>>>>
84061>>>>>>>>>        // ToDo: THIS FAILS BUT THE SQL SCRIPT WORKS IN MYSQL!
84061>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
84062>>>>>>>>>
84062>>>>>>>>>        Function_Return (bOK = True)
84063>>>>>>>>>    End_Function
84064>>>>>>>>>
84064>>>>>>>>>    Function _StrToFieldNumber Integer iFile String sField Returns Integer
84066>>>>>>>>>        Integer iMax iPos
84066>>>>>>>>>        String sName
84066>>>>>>>>>
84066>>>>>>>>>        Move (Lowercase(sField)) to sField
84067>>>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
84070>>>>>>>>>        For iPos from 0 to iMax
84076>>>>>>>>>>
84076>>>>>>>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
84079>>>>>>>>>            Move (Lowercase(sName)) to sName
84080>>>>>>>>>            If (sName = sField) Begin
84082>>>>>>>>>                Function_Return iPos
84083>>>>>>>>>            End
84083>>>>>>>>>>
84083>>>>>>>>>        Loop
84084>>>>>>>>>>
84084>>>>>>>>>        Function_Return -1
84085>>>>>>>>>    End_Function
84086>>>>>>>>>
84086>>>>>>>>>    // Checks if the passed connection id exists in the CLI interface.
84086>>>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
84086>>>>>>>>>    // the connection id hasn't been established with the driver's CLI interface.
84086>>>>>>>>>    // NOTE: Only applicable for DAW drivers.
84086>>>>>>>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
84088>>>>>>>>>        String sID sConnString
84088>>>>>>>>>        Integer iDriver iNumConn iCount
84088>>>>>>>>>        Handle hoCLI
84088>>>>>>>>>        Boolean bOK
84088>>>>>>>>>
84088>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
84089>>>>>>>>>        If (bOK = False) Begin
84091>>>>>>>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers."
84092>>>>>>>>>>
84092>>>>>>>>>            Function_Return False
84093>>>>>>>>>        End
84093>>>>>>>>>>
84093>>>>>>>>>
84093>>>>>>>>>        Move False to bOK
84094>>>>>>>>>        Get phoCLIHandler to hoCLI
84095>>>>>>>>>        If (hoCLI <> 0) Begin
84097>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
84098>>>>>>>>>            Get DriverIndex of hoCLI sDriverID to iDriver
84099>>>>>>>>>
84099>>>>>>>>>            // If driver not loaded; load it.
84099>>>>>>>>>            If (iDriver = 0) Begin
84101>>>>>>>>>                Load_Driver sDriverID
84102>>>>>>>>>                Get DriverIndex sDriverID to iDriver
84103>>>>>>>>>            End
84103>>>>>>>>>>
84103>>>>>>>>>            If (iDriver <> 0) Begin
84105>>>>>>>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
84108>>>>>>>>>                Decrement iNumConn
84109>>>>>>>>>                For iCount from 0 to iNumConn
84115>>>>>>>>>>
84115>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
84118>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
84121>>>>>>>>>                    If (sID = sConnectionID) Begin
84123>>>>>>>>>                        Move True to bOK
84124>>>>>>>>>                    End
84124>>>>>>>>>>
84124>>>>>>>>>                Loop
84125>>>>>>>>>>
84125>>>>>>>>>            End
84125>>>>>>>>>>
84125>>>>>>>>>        End
84125>>>>>>>>>>
84125>>>>>>>>>
84125>>>>>>>>>        Function_Return bOK
84126>>>>>>>>>    End_Function
84127>>>>>>>>>
84127>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
84129>>>>>>>>>        Boolean bOK
84129>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
84130>>>>>>>>>        Function_Return bOK
84131>>>>>>>>>    End_Function
84132>>>>>>>>>
84132>>>>>>>>>    Function IsMSSQLDriver Returns Boolean
84134>>>>>>>>>        Integer iDriverIndex
84134>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
84135>>>>>>>>>        Function_Return (iDriverIndex <> 0)
84136>>>>>>>>>    End_Function
84137>>>>>>>>>
84137>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
84137>>>>>>>>>    // attempt to load the driver.
84137>>>>>>>>>    // Returns true if the passed driver is SQL based.
84137>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
84139>>>>>>>>>        Boolean bOK
84139>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
84140>>>>>>>>>        Function_Return bOK
84141>>>>>>>>>    End_Function
84142>>>>>>>>>
84142>>>>>>>>>    // *** Error Handler ***
84142>>>>>>>>>    //
84142>>>>>>>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
84142>>>>>>>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
84142>>>>>>>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
84144>>>>>>>>>        Integer iSize iErrorMode
84144>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84144>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84144>>>>>>>>>
84144>>>>>>>>>        If (pbProcessingError(Self)) Begin
84146>>>>>>>>>            Procedure_Return
84147>>>>>>>>>        End
84147>>>>>>>>>>
84147>>>>>>>>>
84147>>>>>>>>>        Get Error_Report_Mode to iErrorMode
84148>>>>>>>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
84150>>>>>>>>>            Set Private.pbProcessingError to False
84151>>>>>>>>>            Procedure_Return
84152>>>>>>>>>        End
84152>>>>>>>>>>
84152>>>>>>>>>
84152>>>>>>>>>        Set pbProcessingError to True
84153>>>>>>>>>        Set pbSqlError to True
84154>>>>>>>>>        Get paSqlErrorArray      to aSqlErrorArray
84155>>>>>>>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
84156>>>>>>>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
84157>>>>>>>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
84158>>>>>>>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
84159>>>>>>>>>        Set paSqlErrorArray      to aSqlErrorArray
84160>>>>>>>>>        Set pbProcessingError to False
84161>>>>>>>>>    End_Procedure
84162>>>>>>>>>
84162>>>>>>>>>    // *** Miscellanous Helper Functions ***
84162>>>>>>>>>    //
84162>>>>>>>>>    // Helper function. Takes a DF_FILE_ROOT_NAME value as parameter and
84162>>>>>>>>>    // returns the table name only; stripped of any prefix, path or filename extension.
84162>>>>>>>>>    Function _TableNameOnly String sTableName Returns String
84164>>>>>>>>>        Integer iPos
84164>>>>>>>>>        Move (Pos(":", sTableName)) to iPos
84165>>>>>>>>>        If (iPos <> 0) Begin
84167>>>>>>>>>            Move (Mid(sTableName, Length(sTableName), (iPos +1))) to sTableName
84168>>>>>>>>>        End  
84168>>>>>>>>>>
84168>>>>>>>>>        Move (Pos(".int", Lowercase(sTableName))) to iPos
84169>>>>>>>>>        If (iPos <> 0) Begin
84171>>>>>>>>>            Move (Left(sTableName, (iPos -1))) to sTableName
84172>>>>>>>>>        End  
84172>>>>>>>>>>
84172>>>>>>>>>        Function_Return sTableName
84173>>>>>>>>>    End_Function
84174>>>>>>>>>
84174>>>>>>>>>    // Removes any prefix from a table name.
84174>>>>>>>>>    // Example mssqldrv:mytable returns mytable
84174>>>>>>>>>    //         dbo.mytable returns mytable
84174>>>>>>>>>    Function _TableNoPrefix String sName Returns String
84176>>>>>>>>>        Integer iPos
84176>>>>>>>>>        Move (Pos(":", sName)) to iPos
84177>>>>>>>>>        If (iPos <> 0) Begin
84179>>>>>>>>>            Move (Mid(sName, Length(sName), (iPos + 1))) to sName
84180>>>>>>>>>        End
84180>>>>>>>>>>
84180>>>>>>>>>        Move (Pos(".", sName)) to iPos
84181>>>>>>>>>        If (iPos <> 0) Begin
84183>>>>>>>>>            Move (Mid(sName, Length(sName), (iPos + 1))) to sName
84184>>>>>>>>>        End
84184>>>>>>>>>>
84184>>>>>>>>>        Function_Return sName
84185>>>>>>>>>    End_Function
84186>>>>>>>>>    
84186>>>>>>>>>    Function _DriverIDFromRootName String sRootName Returns String
84188>>>>>>>>>        String sDriverID
84188>>>>>>>>>        Integer iPos
84188>>>>>>>>>        Move DATAFLEX_ID to sDriverID
84189>>>>>>>>>        Move (Pos(":", sRootName)) to iPos
84190>>>>>>>>>        If (iPos <> 0) Begin
84192>>>>>>>>>            Move (Left(sRootName, (iPos -1))) to sDriverID
84193>>>>>>>>>        End
84193>>>>>>>>>>
84193>>>>>>>>>        Function_Return sDriverID
84194>>>>>>>>>    End_Function
84195>>>>>>>>>    // Does the Rootname points to a .dat file?
84195>>>>>>>>>    Function _IsDatEntry Handle hTable Returns Boolean
84197>>>>>>>>>        Boolean bFound bIsIntEntry
84197>>>>>>>>>        String sRootName sNoDriverRootname sDriver
84197>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84200>>>>>>>>>        Get _DriverIDFromRootName sRootName to sDriver
84201>>>>>>>>>        Get _TableNameOnly sRootName to sNoDriverRootname
84202>>>>>>>>>        Get _IsIntEntry hTable to bIsIntEntry
84203>>>>>>>>>        Move (bIsIntEntry = False and sDriver = DATAFLEX_ID) to bFound
84204>>>>>>>>>        Function_Return bFound
84205>>>>>>>>>    End_Function
84206>>>>>>>>>
84206>>>>>>>>>    // Checks that the RootName points to a .dat file and that the .dat file exists on disk.
84206>>>>>>>>>    Function _DatFileExists Handle hTable Returns Boolean
84208>>>>>>>>>        Boolean bExists
84208>>>>>>>>>        String sDataPath sRootName sNoDriverRootname
84208>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84211>>>>>>>>>        Get _TableNameOnly sRootName to sNoDriverRootname
84212>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84213>>>>>>>>>        File_Exist (sDataPath + "\" + sNoDriverRootname + ".dat") bExists
84214>>>>>>>>>        Function_Return bExists
84215>>>>>>>>>    End_Function
84216>>>>>>>>>    
84216>>>>>>>>>    // Does the Rootname contain a ".int" suffix.
84216>>>>>>>>>    Function _IsIntEntry Handle hTable Returns Boolean
84218>>>>>>>>>        Boolean bFound
84218>>>>>>>>>        String sRootName
84218>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84221>>>>>>>>>        Move (Lowercase(sRootName) contains ".int") to bFound
84222>>>>>>>>>        Function_Return bFound
84223>>>>>>>>>    End_Function
84224>>>>>>>>>
84224>>>>>>>>>    // Checks to see if the .int file actually exists in the Data folder.
84224>>>>>>>>>    Function _IntFileExists Handle hTable Returns Boolean
84226>>>>>>>>>        Boolean bExists bIsIntFile
84226>>>>>>>>>        String sDataPath sIntFileName
84226>>>>>>>>>        Integer iPos
84226>>>>>>>>>        
84226>>>>>>>>>        Move False to bExists
84227>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84228>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName
84231>>>>>>>>>        Get _TableNameOnly sIntFileName to sIntFileName
84232>>>>>>>>>        Move (Pos(".int", Lowercase(sIntFileName))) to iPos
84233>>>>>>>>>        If (iPos = 0) Begin
84235>>>>>>>>>            Move (sIntFileName + ".int") to sIntFileName
84236>>>>>>>>>        End
84236>>>>>>>>>>
84236>>>>>>>>>        File_Exist (sDataPath + "\" + sIntFileName) bExists
84237>>>>>>>>>        Function_Return bExists    
84238>>>>>>>>>    End_Function
84239>>>>>>>>>        
84239>>>>>>>>>    // Returns True if the hTable's RootName has a driver <> DataFlex
84239>>>>>>>>>    Function _IsSQLEntry Handle hTable Returns Boolean
84241>>>>>>>>>        Boolean bFound bIsIntFile
84241>>>>>>>>>        String sLogicalName sRootName sNoDriverRootname sDriver
84241>>>>>>>>>        
84241>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84244>>>>>>>>>        Get _DriverIDFromRootName sRootName to sDriver
84245>>>>>>>>>        Get _IsIntEntry hTable to bIsIntFile
84246>>>>>>>>>        Get _TableNameOnly sRootName to sNoDriverRootname
84247>>>>>>>>>        Move (bIsIntFile = True or sDriver <> DATAFLEX_ID) to bFound
84248>>>>>>>>>        Function_Return bFound
84249>>>>>>>>>    End_Function
84250>>>>>>>>>
84250>>>>>>>>>    // This is used in place of the DF_FILE_OPENED table attribute, because
84250>>>>>>>>>    // the table then needs to be open, which takes time.
84250>>>>>>>>>    Function _IsAliasTable Handle hTable Returns Boolean
84252>>>>>>>>>        Boolean bFound bIsIntTable
84252>>>>>>>>>        String sLogicalName sRootName sNoDriverRootname
84252>>>>>>>>>        
84252>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
84255>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84258>>>>>>>>>        Get _TableNameOnly sRootName to sNoDriverRootname
84259>>>>>>>>>        Get _IsIntEntry hTable to bIsIntTable
84260>>>>>>>>>        // Do we have an Alias table?
84260>>>>>>>>>        Move (Lowercase(sLogicalName) <> Lowercase(sNoDriverRootname)) to bFound
84261>>>>>>>>>        Function_Return bFound
84262>>>>>>>>>    End_Function
84263>>>>>>>>>
84263>>>>>>>>>    // If the SQL table cannot be opened, we do this checking a bit different.
84263>>>>>>>>>    Function _IsSystemFile Handle hTable Returns Boolean
84265>>>>>>>>>        Boolean bIsSystem bIsSQL bExists
84265>>>>>>>>>        String sRootName sDataPath sDriver
84265>>>>>>>>>        String[] asIndexes
84266>>>>>>>>>        Move False to bIsSystem
84267>>>>>>>>>        
84267>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84270>>>>>>>>>        Get _DriverIDFromRootName sRootName to sDriver
84271>>>>>>>>>        Get _TableNameOnly sRootName to sRootName
84272>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84273>>>>>>>>>        Get _IsSQLEntry hTable to bIsSQL
84274>>>>>>>>>        If (bIsSQL = False) Begin
84276>>>>>>>>>            File_Exist (sDataPath + "\" + sRootName + ".dat") bExists
84277>>>>>>>>>            If (bExists = True) Begin
84279>>>>>>>>>                Open (sDataPath + "\" + sRootName + ".dat") as hTable
84281>>>>>>>>>                Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bIsSystem 
84284>>>>>>>>>                Close hTable
84285>>>>>>>>>            End
84285>>>>>>>>>>
84285>>>>>>>>>        End 
84285>>>>>>>>>>
84285>>>>>>>>>        Else Begin
84286>>>>>>>>>            Get _SqlUtilEnumerateIndexes sRootName sDriver to asIndexes
84287>>>>>>>>>            Move (SizeOfArray(asIndexes) = 0) to bIsSystem
84288>>>>>>>>>        End
84288>>>>>>>>>>
84288>>>>>>>>>        Function_Return bIsSystem
84289>>>>>>>>>    End_Function
84290>>>>>>>>>                          
84290>>>>>>>>>    // Removes any driver prefix and any .int suffix from the Rootname
84290>>>>>>>>>    // If any driver found, it will be placed in the ByRef param: sDriver.
84290>>>>>>>>>    Function _RemoveDriverFromRootName String sRootname String ByRef sDriver Returns String
84292>>>>>>>>>        String sNoDriverRootname
84292>>>>>>>>>        Integer iPos
84292>>>>>>>>>        
84292>>>>>>>>>        Move sRootname to sNoDriverRootname
84293>>>>>>>>>        Move (Pos(":", sRootname)) to iPos
84294>>>>>>>>>        If (iPos <> 0) Begin
84296>>>>>>>>>            Move (Left(sRootname, iPos -1)) to sDriver
84297>>>>>>>>>            Move (Mid(sRootname, Length(sRootname), iPos +1)) to sNoDriverRootname    
84298>>>>>>>>>        End
84298>>>>>>>>>>
84298>>>>>>>>>        Else Begin
84299>>>>>>>>>            Move DATAFLEX_ID to sDriver
84300>>>>>>>>>        End
84300>>>>>>>>>>
84300>>>>>>>>>        Move (Pos(".int", Lowercase(sNoDriverRootname))) to iPos
84301>>>>>>>>>        If (iPos <> 0) Begin
84303>>>>>>>>>            Move (Left(sNoDriverRootname, iPos -1)) to sNoDriverRootname
84304>>>>>>>>>        End
84304>>>>>>>>>>
84304>>>>>>>>>        Function_Return sNoDriverRootname    
84305>>>>>>>>>    End_Function
84306>>>>>>>>>
84306>>>>>>>>>    Function _CountFilelistSystemTables Returns Integer
84308>>>>>>>>>        tFilelist[] FileListTables
84308>>>>>>>>>        tFilelist[] FileListTables
84309>>>>>>>>>        Integer iCount iSize iItems
84309>>>>>>>>>        
84309>>>>>>>>>        Move 0 to iItems
84310>>>>>>>>>        Get pFileListArray to FileListTables
84311>>>>>>>>>        Move (SizeOfArray(FileListTables)) to iSize
84312>>>>>>>>>        If (iSize <> 0) Begin
84314>>>>>>>>>            Decrement iSize
84315>>>>>>>>>            for iCount from 0 to iSize
84321>>>>>>>>>>
84321>>>>>>>>>                If (FileListTables[iCount].bIsSystemFile = True) Begin
84323>>>>>>>>>                    Increment iItems
84324>>>>>>>>>                End
84324>>>>>>>>>>
84324>>>>>>>>>            Loop
84325>>>>>>>>>>
84325>>>>>>>>>        End
84325>>>>>>>>>>
84325>>>>>>>>>        Function_Return iItems    
84326>>>>>>>>>    End_Function
84327>>>>>>>>>
84327>>>>>>>>>    Function _CountFileListAliasTables Returns Integer
84329>>>>>>>>>        tFilelist[] FileListTables
84329>>>>>>>>>        tFilelist[] FileListTables
84330>>>>>>>>>        Integer iCount iSize iItems
84330>>>>>>>>>        
84330>>>>>>>>>        Move 0 to iItems
84331>>>>>>>>>        Get pFileListArray to FileListTables
84332>>>>>>>>>        Move (SizeOfArray(FileListTables)) to iSize
84333>>>>>>>>>        If (iSize <> 0) Begin
84335>>>>>>>>>            Decrement iSize
84336>>>>>>>>>            for iCount from 0 to iSize
84342>>>>>>>>>>
84342>>>>>>>>>                If (FileListTables[iCount].bIsAlias = True) Begin
84344>>>>>>>>>                    Increment iItems
84345>>>>>>>>>                End
84345>>>>>>>>>>
84345>>>>>>>>>            Loop
84346>>>>>>>>>>
84346>>>>>>>>>        End
84346>>>>>>>>>>
84346>>>>>>>>>        Function_Return iItems    
84347>>>>>>>>>    End_Function
84348>>>>>>>>>
84348>>>>>>>>>    Function _CountFileListMasterTables Returns Integer
84350>>>>>>>>>        String sRootName sLogicalName sDriver sNoDriverRootname
84350>>>>>>>>>        Handle hTable
84350>>>>>>>>>        Integer iSize iItems
84350>>>>>>>>>        Boolean bIsAlias bIsIntTable
84350>>>>>>>>>        
84350>>>>>>>>>        Move 0 to iItems
84351>>>>>>>>>        Move 0 to hTable 
84352>>>>>>>>>        Repeat
84352>>>>>>>>>>
84352>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
84355>>>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin
84357>>>>>>>>>                Get _IsAliasTable hTable to bIsAlias
84358>>>>>>>>>                If (bIsAlias = False) Begin
84360>>>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84363>>>>>>>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName                    
84366>>>>>>>>>                    Get _RemoveDriverFromRootName sRootName (&sDriver) to sNoDriverRootname
84367>>>>>>>>>                    Get _IsIntEntry hTable to bIsIntTable
84368>>>>>>>>>                    If (sDriver <> DATAFLEX_ID and Lowercase(sNoDriverRootname) = Lowercase(sLogicalName)) Begin
84370>>>>>>>>>                        Increment iItems
84371>>>>>>>>>                    End
84371>>>>>>>>>>
84371>>>>>>>>>                End
84371>>>>>>>>>>
84371>>>>>>>>>            End
84371>>>>>>>>>>
84371>>>>>>>>>        Until (hTable = 0)
84373>>>>>>>>>        
84373>>>>>>>>>        Function_Return iItems
84374>>>>>>>>>    End_Function
84375>>>>>>>>>
84375>>>>>>>>>    Function _CountFileListOpenErrors Returns Integer
84377>>>>>>>>>        tFilelist[] FileListTables
84377>>>>>>>>>        tFilelist[] FileListTables
84378>>>>>>>>>        Integer iCount iSize iItems
84378>>>>>>>>>        
84378>>>>>>>>>        Move 0 to iItems
84379>>>>>>>>>        Get pFileListArray to FileListTables
84380>>>>>>>>>        Move (SizeOfArray(FileListTables)) to iSize
84381>>>>>>>>>        If (iSize <> 0) Begin
84383>>>>>>>>>            Decrement iSize
84384>>>>>>>>>            for iCount from 0 to iSize
84390>>>>>>>>>>
84390>>>>>>>>>                If (FileListTables[iCount].bErrorOpening = True) Begin
84392>>>>>>>>>                    Increment iItems
84393>>>>>>>>>                End
84393>>>>>>>>>>
84393>>>>>>>>>            Loop
84394>>>>>>>>>>
84394>>>>>>>>>        End
84394>>>>>>>>>>
84394>>>>>>>>>        Function_Return iItems    
84395>>>>>>>>>    End_Function 
84396>>>>>>>>>
84396>>>>>>>>>    // Checks all Alias Filelist entries for errors,
84396>>>>>>>>>    // and return them as a string array of RootNames.
84396>>>>>>>>>    Function _CountFileListAliasErrors Returns tFilelist[]
84398>>>>>>>>>        Integer iCount iItem
84398>>>>>>>>>        Handle hTable
84398>>>>>>>>>        Boolean bIsAlias bOK
84398>>>>>>>>>        String sRootName
84398>>>>>>>>>        tFilelist[] FileListArray
84398>>>>>>>>>        tFilelist[] FileListArray
84399>>>>>>>>>        
84399>>>>>>>>>        Move 0 to iCount
84400>>>>>>>>>        Move 0 to hTable
84401>>>>>>>>>        Repeat
84401>>>>>>>>>>
84401>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
84404>>>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin
84406>>>>>>>>>                Get _IsAliasTable hTable to bIsAlias
84407>>>>>>>>>                If (bIsAlias = True) Begin
84409>>>>>>>>>                    Get _FindAliasEntryError hTable to iItem
84410>>>>>>>>>                    If (iItem <> 0) Begin
84412>>>>>>>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84415>>>>>>>>>                        Move hTable    to FileListArray[iCount].hTable
84416>>>>>>>>>                        Move sRootName to FileListArray[iCount].sRootName
84417>>>>>>>>>                    End
84417>>>>>>>>>>
84417>>>>>>>>>                    Add iItem to iCount
84418>>>>>>>>>                End
84418>>>>>>>>>>
84418>>>>>>>>>            End
84418>>>>>>>>>>
84418>>>>>>>>>        Until (hTable = 0)
84420>>>>>>>>>        
84420>>>>>>>>>        Function_Return FileListArray
84421>>>>>>>>>    End_Function
84422>>>>>>>>>
84422>>>>>>>>>    // Helper function for _CountFileListAliasErrors.
84422>>>>>>>>>    // Checks to see if an Alias Filelist entry is correct
84422>>>>>>>>>    // What it does:
84422>>>>>>>>>    //  1. Checks that the Filelist entry is an Alias table
84422>>>>>>>>>    //  2. If an Alias, checks if the RootName points to a valid Table
84422>>>>>>>>>    Function _FindAliasEntryError Handle hTable Returns Integer
84424>>>>>>>>>        Handle hMasterTable
84424>>>>>>>>>        String sDataPath sDriver sLogicalNameAlias sRootNameAlias sNoDriverRootnameAlias sLogicalNameMaster sRootNameMaster sNoDriverRootnameMaster
84424>>>>>>>>>        Boolean bOK bFound bIsAlias bIsAliasSQL bIsMasterSQL bIsIntFile
84424>>>>>>>>>        Integer iRetval
84424>>>>>>>>>        
84424>>>>>>>>>        Get _IsAliasTable hTable to bIsAlias
84425>>>>>>>>>        If (bIsAlias = False) Begin
84427>>>>>>>>>            Function_Return 0
84428>>>>>>>>>        End
84428>>>>>>>>>>
84428>>>>>>>>>        
84428>>>>>>>>>        Move 0 to iRetval
84429>>>>>>>>>        Move False to bOK
84430>>>>>>>>>        Move False to bIsAliasSQL
84431>>>>>>>>>        Move False to bIsMasterSQL
84432>>>>>>>>>
84432>>>>>>>>>        Get _IsIntEntry hTable to bIsIntFile
84433>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootNameAlias
84436>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameAlias
84439>>>>>>>>>        Get _TableNameOnly sRootNameAlias to sNoDriverRootnameAlias
84440>>>>>>>>>        Get UtilAliasToMasterTableHandle hTable to hMasterTable
84441>>>>>>>>>        Move (hMasterTable <> 0) to bOK
84442>>>>>>>>>        If (bOK = True) Begin
84444>>>>>>>>>            Get _IsSQLEntry hTable       to bIsAliasSQL
84445>>>>>>>>>            Get _IsSQLEntry hMasterTable to bIsMasterSQL 
84446>>>>>>>>>            Move (bIsAliasSQL = bIsMasterSQL) to bOK
84447>>>>>>>>>        End
84447>>>>>>>>>>
84447>>>>>>>>>        
84447>>>>>>>>>        // Checks that the .int file exists in the Data folder
84447>>>>>>>>>        If (bIsIntFile = True) Begin
84449>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84450>>>>>>>>>            File_Exist (sDataPath + "\" + sNoDriverRootnameAlias) bOK
84451>>>>>>>>>        End
84451>>>>>>>>>>
84451>>>>>>>>>
84451>>>>>>>>>        If (bOK = False) Begin
84453>>>>>>>>>            Move 1 to iRetval
84454>>>>>>>>>        End
84454>>>>>>>>>>
84454>>>>>>>>>        Function_Return iRetval
84455>>>>>>>>>    End_Function
84456>>>>>>>>>        
84456>>>>>>>>>    // Returns the first datapath found in the psDataPath property.
84456>>>>>>>>>    // The returned path always ends with a "\"
84456>>>>>>>>>    Function psDataPathFirstPart Returns String
84458>>>>>>>>>        String sDataPath
84458>>>>>>>>>        Integer iCount
84458>>>>>>>>>
84458>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84459>>>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
84460>>>>>>>>>        If (iCount > 1) Begin
84462>>>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
84463>>>>>>>>>        End
84463>>>>>>>>>>
84463>>>>>>>>>        If (sDataPath <> "") Begin
84465>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
84466>>>>>>>>>        End
84466>>>>>>>>>>
84466>>>>>>>>>
84466>>>>>>>>>        Function_Return sDataPath
84467>>>>>>>>>    End_Function
84468>>>>>>>>>
84468>>>>>>>>>    Function psLogTextFileWithPath Returns String
84470>>>>>>>>>        String sFileName
84470>>>>>>>>>        Handle hoLogFile
84470>>>>>>>>>        Get phoLogFile to hoLogFile
84471>>>>>>>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
84472>>>>>>>>>        Function_Return sFileName
84473>>>>>>>>>    End_Function
84474>>>>>>>>>
84474>>>>>>>>>    Function phoLogFile Returns Handle
84476>>>>>>>>>        Handle hoLogFile   
84476>>>>>>>>>        Boolean bErr
84476>>>>>>>>>        
84476>>>>>>>>>        Move Err to bErr
84477>>>>>>>>>        Move 0 to hoLogFile
84478>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
84479>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
84480>>>>>>>>>        Delegate Get phoLogFile to hoLogFile
84482>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
84483>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84484>>>>>>>>>        Move bErr to Err
84485>>>>>>>>>        
84485>>>>>>>>>        Function_Return hoLogFile
84486>>>>>>>>>    End_Function
84487>>>>>>>>>
84487>>>>>>>>>    Function pnCurrentVersionUpdate Returns Number
84489>>>>>>>>>        Number nCurrentVersionUpdate
84489>>>>>>>>>
84489>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84490>>>>>>>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
84492>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84493>>>>>>>>>
84493>>>>>>>>>        Function_Return nCurrentVersionUpdate
84494>>>>>>>>>    End_Function
84495>>>>>>>>>
84495>>>>>>>>>    Procedure LogError String sText Boolean bError
84497>>>>>>>>>        Handle hoLogFile
84497>>>>>>>>>        Number nCurrentVersionUpdate
84497>>>>>>>>>
84497>>>>>>>>>        Get phoLogFile to hoLogFile
84498>>>>>>>>>        If (hoLogFile = 0) Begin
84500>>>>>>>>>            Procedure_Return
84501>>>>>>>>>        End
84501>>>>>>>>>>
84501>>>>>>>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
84502>>>>>>>>>
84502>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84503>>>>>>>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
84504>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84505>>>>>>>>>    End_Procedure
84506>>>>>>>>>
84506>>>>>>>>>    Function pbContinueOnError Returns Boolean
84508>>>>>>>>>        Boolean bContinueOnError
84508>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
84510>>>>>>>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
84511>>>>>>>>>        End
84511>>>>>>>>>>
84511>>>>>>>>>        Function_Return bContinueOnError
84512>>>>>>>>>    End_Function
84513>>>>>>>>>
84513>>>>>>>>>
84513>>>>>>>>>    Function _UtilUpdateTAGFile String sFullTAGFileName String sColumnName Returns Boolean
84515>>>>>>>>>        Integer iChIn iChOut // iCount
84515>>>>>>>>>        Boolean bExists
84515>>>>>>>>>        String sExistingColumn
84515>>>>>>>>>
84515>>>>>>>>>        Move False to bExists
84516>>>>>>>>>        Get Seq_New_Channel to iChIn
84517>>>>>>>>>        Get Seq_New_Channel to iChOut
84518>>>>>>>>>        If (iChIn = DF_SEQ_CHANNEL_NOT_AVAILABLE or iChOut = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
84520>>>>>>>>>            Function_Return True
84521>>>>>>>>>        End
84521>>>>>>>>>>
84521>>>>>>>>>
84521>>>>>>>>>        Move False to Err
84522>>>>>>>>>        // The following line should also use the channel attribute. (Thank you, Hans van de Laar)
84522>>>>>>>>>        Direct_Input channel iChIn ("'" + sFullTAGFileName + "'")
84524>>>>>>>>>        While (not(SeqEof))
84528>>>>>>>>>            Readln channel iChIn sExistingColumn
84530>>>>>>>>>            If (Uppercase(sExistingColumn) = Uppercase(sColumnName)) Begin
84532>>>>>>>>>                Move True to bExists
84533>>>>>>>>>            End
84533>>>>>>>>>>
84533>>>>>>>>>            If (Trim(sExistingColumn) = "") Begin
84535>>>>>>>>>                Move True to SeqEof
84536>>>>>>>>>            End
84536>>>>>>>>>>
84536>>>>>>>>>        Loop
84537>>>>>>>>>>
84537>>>>>>>>>        Close_Input channel iChIn
84539>>>>>>>>>        Send Seq_Release_Channel iChIn
84540>>>>>>>>>
84540>>>>>>>>>        If (bExists = False) Begin
84542>>>>>>>>>            Append_Output channel iChOut sFullTAGFileName
84544>>>>>>>>>            Writeln channel iChOut sColumnName
84547>>>>>>>>>            Close_Output channel iChOut
84549>>>>>>>>>            Send Seq_Release_Channel iChOut
84550>>>>>>>>>        End
84550>>>>>>>>>>
84550>>>>>>>>>
84550>>>>>>>>>        Function_Return (Err = False)
84551>>>>>>>>>    End_Function
84552>>>>>>>>>
84552>>>>>>>>>    // Changes source code files.
84552>>>>>>>>>    // Pass a file name with full path and a value to search for, together with the value
84552>>>>>>>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
84552>>>>>>>>>    // to use a Connection ID.
84552>>>>>>>>>    // Sample: Get _UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
84552>>>>>>>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
84552>>>>>>>>>    // Returns True if no errors occured.
84552>>>>>>>>>    Function _UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
84554>>>>>>>>>        Integer iCh iRow iItems iCount
84554>>>>>>>>>        String sValue sRow
84554>>>>>>>>>        String[] sFileArray
84555>>>>>>>>>        Boolean bExists bIsActive bFileChange
84555>>>>>>>>>
84555>>>>>>>>>        Move False to Err
84556>>>>>>>>>        Move 0 to iRow
84557>>>>>>>>>        Move False to bFileChange
84558>>>>>>>>>
84558>>>>>>>>>        If (ghoStatusPanel <> 0) Begin
84560>>>>>>>>>            Get Active_state of ghoStatusPanel to bIsActive
84561>>>>>>>>>        End
84561>>>>>>>>>>
84561>>>>>>>>>
84561>>>>>>>>>        Get vFilePathExists sFileName to bExists
84562>>>>>>>>>        If (bExists = False) Begin
84564>>>>>>>>>            If (bShowResult = True) Begin
84566>>>>>>>>>                If (bIsActive = True) Begin
84568>>>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
84569>>>>>>>>>                End
84569>>>>>>>>>>
84569>>>>>>>>>                Else Begin
84570>>>>>>>>>                    Showln "File does not exist: " sFileName
84573>>>>>>>>>                End
84573>>>>>>>>>>
84573>>>>>>>>>            End
84573>>>>>>>>>>
84573>>>>>>>>>            Function_Return False
84574>>>>>>>>>        End
84574>>>>>>>>>>
84574>>>>>>>>>
84574>>>>>>>>>        Get Seq_Open_Input_Channel sFileName to iCh
84575>>>>>>>>>        If (iCh < 1) Begin
84577>>>>>>>>>            Function_Return False
84578>>>>>>>>>        End
84578>>>>>>>>>>
84578>>>>>>>>>
84578>>>>>>>>>        If (bShowResult = True) Begin
84580>>>>>>>>>            If (ghoStatusPanel <> 0) Begin
84582>>>>>>>>>                Get Active_state of ghoStatusPanel to bIsActive
84583>>>>>>>>>                If (bIsActive = True) Begin
84585>>>>>>>>>                    Set Message_Text of ghoStatusPanel to sFileName
84586>>>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
84587>>>>>>>>>                    Send DoAdvance of ghoProgressBar
84588>>>>>>>>>                End
84588>>>>>>>>>>
84588>>>>>>>>>            End
84588>>>>>>>>>>
84588>>>>>>>>>            Else Begin
84589>>>>>>>>>                Showln ""
84591>>>>>>>>>                Showln "sFileName = " sFileName
84594>>>>>>>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
84599>>>>>>>>>            End
84599>>>>>>>>>>
84599>>>>>>>>>        End
84599>>>>>>>>>>
84599>>>>>>>>>
84599>>>>>>>>>        While (not(SeqEof))
84603>>>>>>>>>            Readln channel iCh sRow
84605>>>>>>>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
84607>>>>>>>>>                // Change the whole line to the new connection id:
84607>>>>>>>>>                Move sChangeTo to sRow 
84608>>>>>>>>>                Move True to bFileChange
84609>>>>>>>>>            End
84609>>>>>>>>>>
84609>>>>>>>>>            Move sRow to sFileArray[iRow]
84610>>>>>>>>>            Increment iRow
84611>>>>>>>>>        Loop
84612>>>>>>>>>>
84612>>>>>>>>>        Send Seq_Close_Channel iCh
84613>>>>>>>>>
84613>>>>>>>>>//        Sleep 1 // Wait for Windows to close the file
84613>>>>>>>>>
84613>>>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
84614>>>>>>>>>        If (iCh < 1) Begin
84616>>>>>>>>>            Function_Return False
84617>>>>>>>>>        End
84617>>>>>>>>>>
84617>>>>>>>>>        Move (SizeOfArray(sFileArray)) to iItems
84618>>>>>>>>>        Decrement iItems
84619>>>>>>>>>
84619>>>>>>>>>        for iCount from 0 to iItems
84625>>>>>>>>>>
84625>>>>>>>>>            Move sFileArray[iCount] to sValue
84626>>>>>>>>>            Writeln channel iCh sValue
84629>>>>>>>>>        Loop
84630>>>>>>>>>>
84630>>>>>>>>>        Send Seq_Close_Channel iCh
84631>>>>>>>>>
84631>>>>>>>>>        Function_Return bFileChange
84632>>>>>>>>>    End_Function
84633>>>>>>>>>
84633>>>>>>>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
84633>>>>>>>>>    // and opens it in "notepad.exe".
84633>>>>>>>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
84633>>>>>>>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
84633>>>>>>>>>    Procedure _UtilShowErrorList
84635>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84635>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84635>>>>>>>>>        Integer iRows iCount iCh iErrorNum
84635>>>>>>>>>        String sPath sFileName sErrorTxt sStatement
84635>>>>>>>>>
84635>>>>>>>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
84636>>>>>>>>>        Get vFolderFormat sPath to sPath
84637>>>>>>>>>        Move "SQLErrorLog.txt"  to sFileName
84638>>>>>>>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
84639>>>>>>>>>            Get paSqlErrorArray to aSqlErrorArray
84640>>>>>>>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
84641>>>>>>>>>            If (iRows > 0) Begin
84643>>>>>>>>>                Decrement iRows
84644>>>>>>>>>                for iCount from 0 to iRows
84650>>>>>>>>>>
84650>>>>>>>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
84651>>>>>>>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
84652>>>>>>>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
84653>>>>>>>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
84659>>>>>>>>>                    Writeln channel iCh "SQL Statement: " sStatement
84663>>>>>>>>>                Loop
84664>>>>>>>>>>
84664>>>>>>>>>            End
84664>>>>>>>>>>
84664>>>>>>>>>        Send Seq_Close_Channel iCh
84665>>>>>>>>>
84665>>>>>>>>>        If (iRows > 0) Begin
84667>>>>>>>>>            Runprogram Shell Background (sPath + sFileName)
84668>>>>>>>>>        End
84668>>>>>>>>>>
84668>>>>>>>>>    End_Procedure
84669>>>>>>>>>
84669>>>>>>>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
84669>>>>>>>>>    // and the table needs to exist as an SQL table.
84669>>>>>>>>>    Function _UtilTableIsSql Handle hTable Returns Boolean
84671>>>>>>>>>        String sRootName sDriverID
84671>>>>>>>>>        Boolean bIsSQL
84671>>>>>>>>>
84671>>>>>>>>>        Move False to bIsSQL
84672>>>>>>>>>        If (hTable > 0) Begin
84674>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84677>>>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQL
84678>>>>>>>>>            If (bIsSQL = True) Begin
84680>>>>>>>>>                Get psDriverID to sDriverID
84681>>>>>>>>>                Get _TableNameOnly sRootName to sRootName
84682>>>>>>>>>                Get _SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
84683>>>>>>>>>            End
84683>>>>>>>>>>
84683>>>>>>>>>        End
84683>>>>>>>>>>
84683>>>>>>>>>
84683>>>>>>>>>        Function_Return bIsSQL
84684>>>>>>>>>    End_Function
84685>>>>>>>>>
84685>>>>>>>>>    // Note: This version uses the pasSQLDataTables array(!)
84685>>>>>>>>>    //       Thus that property needs to have been initialized before
84685>>>>>>>>>    //       calling this function.
84685>>>>>>>>>    Function _UtilTableIsSql_Ex Handle hTable Returns Boolean
84687>>>>>>>>>        String sRootName sDriverID
84687>>>>>>>>>        Boolean bIsSQL
84687>>>>>>>>>
84687>>>>>>>>>        Move False to bIsSQL
84688>>>>>>>>>        If (hTable > 0) Begin
84690>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84693>>>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQL
84694>>>>>>>>>            If (bIsSQL = True) Begin
84696>>>>>>>>>                Get psDriverID to sDriverID
84697>>>>>>>>>                Get _TableNameOnly sRootName to sRootName
84698>>>>>>>>>                Get _SqlUtilCheckIfTableNameExists_Ex sRootName sDriverID to bIsSQL
84699>>>>>>>>>            End
84699>>>>>>>>>>
84699>>>>>>>>>        End
84699>>>>>>>>>>
84699>>>>>>>>>
84699>>>>>>>>>        Function_Return bIsSQL
84700>>>>>>>>>    End_Function
84701>>>>>>>>>
84701>>>>>>>>>    Function _UtilTableIsSqlByRootName String sRootName Returns Boolean
84703>>>>>>>>>        Boolean bIsSQL
84703>>>>>>>>>        Move (sRootName contains ":") to bIsSQL
84704>>>>>>>>>        Function_Return bIsSQL
84705>>>>>>>>>    End_Function
84706>>>>>>>>>
84706>>>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
84706>>>>>>>>>    Function _SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
84708>>>>>>>>>        String sDatabase sSchema sVal
84708>>>>>>>>>        Boolean bExists
84708>>>>>>>>>        String[] asTablesArray
84709>>>>>>>>>        Integer iItem
84709>>>>>>>>>
84709>>>>>>>>>        Move False to bExists
84710>>>>>>>>>        Get psDatabase to sDatabase
84711>>>>>>>>>        Get psSchema   to sSchema
84712>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDatabase = "") Begin
84714>>>>>>>>>            Error DFERR_PROGRAM ("Function _SqlUtilCheckIfTableNameExists: psDatabase =" * String(sDatabase) * "psDriver =" * String(sDriverID))
84715>>>>>>>>>>
84715>>>>>>>>>            Function_Return False
84716>>>>>>>>>        End
84716>>>>>>>>>>
84716>>>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to asTablesArray
84717>>>>>>>>>        Move (SearchArray(sTableName, asTablesArray, Desktop, (RefFunc(DFSTRICMP)))) to iItem
84718>>>>>>>>>        If (iItem <> -1) Begin
84720>>>>>>>>>            Move True to bExists
84721>>>>>>>>>        End
84721>>>>>>>>>>
84721>>>>>>>>>        Function_Return bExists
84722>>>>>>>>>    End_Function
84723>>>>>>>>>
84723>>>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
84723>>>>>>>>>    // This alternative is much faster as it first enumerates all SQL tables
84723>>>>>>>>>    Function _SqlUtilCheckIfTableNameExists_Ex String sTableName String sDriverID Returns Boolean
84725>>>>>>>>>        String sDatabase sSchema sVal
84725>>>>>>>>>        Boolean bExists
84725>>>>>>>>>        String[] asTablesArray
84726>>>>>>>>>        Integer iItem
84726>>>>>>>>>
84726>>>>>>>>>        Move False to bExists
84727>>>>>>>>>        Get psDatabase to sDatabase
84728>>>>>>>>>        Get psSchema   to sSchema
84729>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDatabase = "") Begin
84731>>>>>>>>>            Error DFERR_PROGRAM ("Function _SqlUtilCheckIfTableNameExists: psDatabase =" * String(sDatabase) * "psDriver =" * String(sDriverID))
84732>>>>>>>>>>
84732>>>>>>>>>            Function_Return False
84733>>>>>>>>>        End
84733>>>>>>>>>>
84733>>>>>>>>>        Get pasSQLDataTables to asTablesArray
84734>>>>>>>>>        Move (SearchArray(sTableName, asTablesArray, Desktop, (RefFunc(DFSTRICMP)))) to iItem
84735>>>>>>>>>        If (iItem <> -1) Begin
84737>>>>>>>>>            Move True to bExists
84738>>>>>>>>>        End
84738>>>>>>>>>>
84738>>>>>>>>>        Function_Return bExists
84739>>>>>>>>>    End_Function
84740>>>>>>>>>
84740>>>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
84740>>>>>>>>>    // that the embedded .dat file exists on disk.
84740>>>>>>>>>    Function _UtilTableIsEmbedded Handle hTable Returns Boolean
84742>>>>>>>>>        Boolean bExists bIsEmbedded
84742>>>>>>>>>        String sDataPath sRootName
84742>>>>>>>>>
84742>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
84743>>>>>>>>>        If (bExists = False) Begin
84745>>>>>>>>>            Function_Return False
84746>>>>>>>>>        End
84746>>>>>>>>>>
84746>>>>>>>>>
84746>>>>>>>>>        Move False to bIsEmbedded
84747>>>>>>>>>        If (hTable > 0) Begin
84749>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84752>>>>>>>>>            Move (not(sRootName contains ":")) to bIsEmbedded
84753>>>>>>>>>        End
84753>>>>>>>>>>
84753>>>>>>>>>        If (bIsEmbedded = True) Begin
84755>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84756>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
84757>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bIsEmbedded
84758>>>>>>>>>        End
84758>>>>>>>>>>
84758>>>>>>>>>
84758>>>>>>>>>        Function_Return bIsEmbedded
84759>>>>>>>>>    End_Function
84760>>>>>>>>>
84760>>>>>>>>>    // Returns the DateTime of the passed file name was modified, with seconds (only) precision.
84760>>>>>>>>>    Function FileModTime String sFileName Returns DateTime
84762>>>>>>>>>        Date dDate
84762>>>>>>>>>        Integer iYY iHH iMM iSS
84762>>>>>>>>>        Boolean bExists
84762>>>>>>>>>        DateTime dtFileDateTime
84762>>>>>>>>>
84762>>>>>>>>>        Move (NullDateTime()) to dtFileDateTime
84763>>>>>>>>>        Get vFilePathExists sFileName to bExists
84764>>>>>>>>>        If (bExists = True) Begin
84766>>>>>>>>>            Get_File_Mod_Time sFileName to dDate iHH iMM iSS
84770>>>>>>>>>            Move dDate            to dtFileDateTime
84771>>>>>>>>>            Move (DateGetYear       (dtFileDateTime))      to iYY
84772>>>>>>>>>            Move (DateSetYear       (dtFileDateTime, iYY)) to dtFileDateTime
84773>>>>>>>>>            Move (DateSetHour       (dtFileDateTime, iHH)) to dtFileDateTime
84774>>>>>>>>>            Move (DateSetMinute     (dtFileDateTime, iMM)) to dtFileDateTime
84775>>>>>>>>>            Move (DateSetSecond     (dtFileDateTime, iSS)) to dtFileDateTime
84776>>>>>>>>>            Move (DateSetMillisecond(dtFileDateTime, 0))   to dtFileDateTime
84777>>>>>>>>>        End
84777>>>>>>>>>>
84777>>>>>>>>>
84777>>>>>>>>>        Function_Return dtFileDateTime
84778>>>>>>>>>    End_Function
84779>>>>>>>>>
84779>>>>>>>>>    // Returns True if the file passed as sFileName1 is newer than sFileName2.
84779>>>>>>>>>    Function IsFileTimeNewer String sFileName1 String sFileName2 Returns Boolean
84781>>>>>>>>>        Boolean bExists bIsNewer
84781>>>>>>>>>        DateTime dtFileDateTime1 dtFileDateTime2
84781>>>>>>>>>
84781>>>>>>>>>        Move False to bIsNewer
84782>>>>>>>>>        Get vFilePathExists sFileName1 to bExists
84783>>>>>>>>>        If (bExists = True) Begin
84785>>>>>>>>>            Get FileModTime sFileName1  to dtFileDateTime1
84786>>>>>>>>>            Get FileModTime sFileName2  to dtFileDateTime2
84787>>>>>>>>>            Move (dtFileDateTime1 > dtFileDateTime2) to bIsNewer
84788>>>>>>>>>        End
84788>>>>>>>>>>
84788>>>>>>>>>        Function_Return bIsNewer
84789>>>>>>>>>    End_Function
84790>>>>>>>>>
84790>>>>>>>>>End_Class
84791>>>>>>>
84791>>>>>>>Register_Function pbExitIfDebuggerActive Returns Boolean
84791>>>>>>>Class cDbUpdateFunctionLibrary is a cBaseDbUpdateFuncLib
84792>>>>>>>
84792>>>>>>>    Procedure Construct_Object
84794>>>>>>>        Forward Send Construct_Object
84796>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
84797>>>>>>>    End_Procedure
84798>>>>>>>
84798>>>>>>>    Procedure End_Construct_Object
84800>>>>>>>        Forward Send End_Construct_Object
84802>>>>>>>    End_Procedure
84803>>>>>>>
84803>>>>>>>    // *** SQL Messages for making changes to the SQL back-end ***
84803>>>>>>>    //
84803>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84803>>>>>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
84805>>>>>>>        Function_Return False
84806>>>>>>>    End_Function
84807>>>>>>>
84807>>>>>>>    // Function for creating a new *Database*.
84807>>>>>>>    // Note: This is for creating SQL DATABASES - not tables!
84807>>>>>>>    // Returns True if successful.
84807>>>>>>>    // ToDo: Currently only works for MS-SQL...
84807>>>>>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
84809>>>>>>>        String sSQL sSQL1 sConnectionID sConnectionString
84809>>>>>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
84809>>>>>>>        Handle hConnection hStmt hoSQLManager
84809>>>>>>>        Integer iFetchResult iDbType
84809>>>>>>>        Boolean bOK bExists
84809>>>>>>>
84809>>>>>>>        Get piDbType to iDbType
84810>>>>>>>        If (iDbType <> EN_DbTypeMSSQL and iDbType <> EN_DbTypeDB2 and iDbType <> EN_DbTypeMySQL and iDbType <> EN_DbTypePostgre) Begin
84812>>>>>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL, MySQL & PostGre and DB2 drivers"
84813>>>>>>>>
84813>>>>>>>            Function_Return False
84814>>>>>>>        End
84814>>>>>>>>
84814>>>>>>>
84814>>>>>>>        Get SqlUtilCheckIfDatabaseExists sDatabase to bExists
84815>>>>>>>        If (bExists = True) Begin
84817>>>>>>>            Function_Return True
84818>>>>>>>        End
84818>>>>>>>>
84818>>>>>>>
84818>>>>>>>        Get phoSQLManager to hoSQLManager
84819>>>>>>>
84819>>>>>>>        Get psConnectionID     to sConnectionID
84820>>>>>>>        Get psConnectionString to sConnectionString
84821>>>>>>>        Move 0 to LastErr
84822>>>>>>>
84822>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
84824>>>>>>>            // If an ODBC data source (DSN) we cannot pass the UID & PWD; so strip them from the connection string.
84824>>>>>>>            // ToDo: 2018-08-11 I think this is wrong and the uid & pw should be there.
84824>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
84824>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
84824>>>>>>>//                If (iPos > 0) Begin
84824>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
84824>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
84824>>>>>>>//                End
84824>>>>>>>//            End
84824>>>>>>>        End
84824>>>>>>>>
84824>>>>>>>
84824>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84825>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84826>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84827>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84829>>>>>>>            Error DFERR_PROGRAM (CS_DUF_LoginToDbServerFailed + "\n" + sConnectionString)
84830>>>>>>>>
84830>>>>>>>            Function_Return False
84831>>>>>>>        End
84831>>>>>>>>
84831>>>>>>>
84831>>>>>>>        Get SqlOpen of hConnection to hStmt
84832>>>>>>>
84832>>>>>>>        If (hStmt = 0) Begin
84834>>>>>>>            Send SqlDisconnect of hoSQLManager
84835>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
84836>>>>>>>>
84836>>>>>>>            Function_Return False
84837>>>>>>>        End
84837>>>>>>>>
84837>>>>>>>
84837>>>>>>>        Get psCollation to sCollation
84838>>>>>>>
84838>>>>>>>        Case Begin
84838>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
84840>>>>>>>                Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
84841>>>>>>>                Get _SqlSelectFromWhereName to sSelectFromWhereName
84842>>>>>>>                Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
84843>>>>>>>
84843>>>>>>>                // Check if database exists
84843>>>>>>>                Send SqlExecDirect of hStmt sSQL
84844>>>>>>>                Get SqlFetch of hStmt to iFetchResult
84845>>>>>>>                Send SqlClose of hStmt
84846>>>>>>>                Send SqlDisconnect of hConnection
84847>>>>>>>                // If database already exists we're out of here!
84847>>>>>>>                // Note that we return True as this is not an error.
84847>>>>>>>                If (iFetchResult > 0) Begin
84849>>>>>>>                    Function_Return True
84850>>>>>>>                End
84850>>>>>>>>
84850>>>>>>>                // Database doesn't exist, create it.
84850>>>>>>>                If (iFetchResult = 0) Begin
84852>>>>>>>                    Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
84853>>>>>>>                    Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84854>>>>>>>                    If (sCollation <> "") Begin
84856>>>>>>>                        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
84857>>>>>>>                        Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
84858>>>>>>>                    End
84858>>>>>>>>
84858>>>>>>>                    Send SqlUtilExecuteQuery sSQL1 sDriverID
84859>>>>>>>                    Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84860>>>>>>>                    If (LastErr = CLIERR_GENERAL_ERROR) Begin
84862>>>>>>>                        Function_Return False
84863>>>>>>>                    End
84863>>>>>>>>
84863>>>>>>>                    // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
84863>>>>>>>                    Sleep 1
84864>>>>>>>                    Send SqlUtilExecuteQuery sSQL sDriverID
84865>>>>>>>                End
84865>>>>>>>>
84865>>>>>>>                Case Break
84866>>>>>>>
84866>>>>>>>            Case (iDbType = EN_DbTypeMySQL and sDriverID = ODBC_DRV_ID)
84869>>>>>>>                // ToDo: How should this be set/checked?
84869>>>>>>>//                If (Lowercase(Left(sCollation, 3)) <> "utf") Begin
84869>>>>>>>//                    Set psCollation to "utf8"
84869>>>>>>>//                End
84869>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreateMySQLDatabase.sql as CreateMySQLDatabase.sql
84869>>>>>>>                Get _SqlUtilCreateMySQLDatabaseByScript "CreateMySQLDatabase.sql" sDatabase to bOK
84870>>>>>>>                Case Break
84871>>>>>>>
84871>>>>>>>            Case Else
84871>>>>>>>                Error DFERR_PROGRAM "Unsupported database type"
84872>>>>>>>>
84872>>>>>>>        Case End
84872>>>>>>>
84872>>>>>>>        If (Err = False) Begin
84874>>>>>>>            Send LogError ("The Database:" * String(sDatabase) * "was created successfully for driver:" * String(sDriverID)) False
84875>>>>>>>        End
84875>>>>>>>>
84875>>>>>>>        // If used in e.g. the cDbUpdateHandler we want to change the login database name to
84875>>>>>>>        // the one we just created.
84875>>>>>>>        If (bUpdateConnectionString = True and Err = False) Begin
84877>>>>>>>            Set psDatabase to sDatabase
84878>>>>>>>            //...and perhaps also the SQLConnections.ini file setting.
84878>>>>>>>            If (bPermanantly = True) Begin
84880>>>>>>>                If (ghoSQLConnectionHandler <> 0) Begin
84882>>>>>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
84883>>>>>>>                End
84883>>>>>>>>
84883>>>>>>>            End
84883>>>>>>>>
84883>>>>>>>        End
84883>>>>>>>>
84883>>>>>>>
84883>>>>>>>        If (Err = False) Begin
84885>>>>>>>            Send ResetFillSQLTables
84886>>>>>>>        End
84886>>>>>>>>
84886>>>>>>>        Function_Return (Err = False)
84887>>>>>>>    End_Function
84888>>>>>>>
84888>>>>>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
84888>>>>>>>    // will be used.
84888>>>>>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
84890>>>>>>>        Boolean bOK bExists bShowProgress bErr
84890>>>>>>>        String sStatement sDriverID
84890>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84890>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84890>>>>>>>        Integer iDbType
84890>>>>>>>
84890>>>>>>>        If (sDatabase = "") Begin
84892>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84893>>>>>>>>
84893>>>>>>>            Function_Return False
84894>>>>>>>        End
84894>>>>>>>>
84894>>>>>>>        If (sBackupName = "") Begin
84896>>>>>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84897>>>>>>>>
84897>>>>>>>            Function_Return False
84898>>>>>>>        End
84898>>>>>>>>
84898>>>>>>>
84898>>>>>>>        // Create backup-folder if it doesn't exist
84898>>>>>>>        Get vFolderExists sPath to bExists
84899>>>>>>>        If (bExists = False) Begin
84901>>>>>>>            Get vCreateDirectory sPath to bErr
84902>>>>>>>            If (bErr = True) Begin
84904>>>>>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
84905>>>>>>>>
84905>>>>>>>                Function_Return False
84906>>>>>>>            End
84906>>>>>>>>
84906>>>>>>>        End
84906>>>>>>>>
84906>>>>>>>        // Make sure the path ends with a back-slash
84906>>>>>>>        If (sPath <> "") Begin
84908>>>>>>>            Get vFolderFormat sPath to sPath
84909>>>>>>>        End
84909>>>>>>>>
84909>>>>>>>
84909>>>>>>>        Get psDriverID to sDriverID
84910>>>>>>>        Get piDbType   to iDbType
84911>>>>>>>        If (num_arguments > 3) Begin
84913>>>>>>>            Move bShowProg to bShowProgress
84914>>>>>>>        End
84914>>>>>>>>
84914>>>>>>>
84914>>>>>>>        Case Begin
84914>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84916>>>>>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
84916>>>>>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
84916>>>>>>>                Get _SqlUtilReadResource  "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
84917>>>>>>>                Get _SqlUtilReadResource "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
84918>>>>>>>
84918>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84919>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
84920>>>>>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
84921>>>>>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
84922>>>>>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
84923>>>>>>>                Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" bShowProgress to bOK
84924>>>>>>>                Case Break
84925>>>>>>>            Case Else
84925>>>>>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
84926>>>>>>>        Case End
84926>>>>>>>
84926>>>>>>>        Function_Return bOK
84927>>>>>>>    End_Function
84928>>>>>>>
84928>>>>>>>    Function SqlDatabaseCollationQuery String sDatabase Boolean bSilent Returns String
84930>>>>>>>        String sStatement sDriverID sRetval //sPrevious
84930>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84930>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84930>>>>>>>        Integer iDbType iRows iFetchResult //iColumn
84930>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
84930>>>>>>>        tSQLConnection SQLConnection
84930>>>>>>>        tSQLConnection SQLConnection
84930>>>>>>>
84930>>>>>>>        If (sDatabase = "") Begin
84932>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
84933>>>>>>>>
84933>>>>>>>            Function_Return ""
84934>>>>>>>        End
84934>>>>>>>>
84934>>>>>>>
84934>>>>>>>        Move "" to sRetval
84935>>>>>>>        Get psDriverID to sDriverID
84936>>>>>>>        Get piDbType   to iDbType
84937>>>>>>>
84937>>>>>>>        Case Begin
84937>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84939>>>>>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
84939>>>>>>>                Get _SqlUtilReadResource "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
84940>>>>>>>
84940>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84941>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
84942>>>>>>>                Get phoSQLManager to hoSQLHandler
84943>>>>>>>
84943>>>>>>>                If (hoSQLHandler <> 0) Begin
84945>>>>>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
84946>>>>>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
84947>>>>>>>
84947>>>>>>>                    If (hoSQLConnect <> 0) Begin
84949>>>>>>>                        Get SQLOpen of hoSQLConnect to hstmt
84950>>>>>>>                        If (hstmt <> 0) Begin
84952>>>>>>>                            Send SqlExecDirect of hstmt sStatement
84953>>>>>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
84954>>>>>>>                            Get SQLFetch of hstmt to iFetchResult
84955>>>>>>>                            If (iFetchResult <> 0) Begin
84957>>>>>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
84958>>>>>>>                            End
84958>>>>>>>>
84958>>>>>>>                            Send SQLClose of hstmt
84959>>>>>>>                        End
84959>>>>>>>>
84959>>>>>>>                        Send SQLDisconnect of hoSQLConnect
84960>>>>>>>                    End
84960>>>>>>>>
84960>>>>>>>                End
84960>>>>>>>>
84960>>>>>>>                Case Break
84961>>>>>>>            Case Else
84961>>>>>>>                If (bSilent = False) Begin
84963>>>>>>>                    Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for this driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
84964>>>>>>>                End
84964>>>>>>>>
84964>>>>>>>        Case End
84964>>>>>>>
84964>>>>>>>        Function_Return sRetval
84965>>>>>>>    End_Function
84966>>>>>>>
84966>>>>>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
84968>>>>>>>        String sDriverID sSQL sConnectionID sConnectionString sSet sWith // sSQL1 
84968>>>>>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
84968>>>>>>>        Handle hConnection hStmt hoSQLManager
84968>>>>>>>        Integer iDbType // iFetchResult
84968>>>>>>>
84968>>>>>>>        If (sDatabase = "") Begin
84970>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84971>>>>>>>>
84971>>>>>>>            Function_Return False
84972>>>>>>>        End
84972>>>>>>>>
84972>>>>>>>
84972>>>>>>>        If (sSQLCollation = "") Begin
84974>>>>>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84975>>>>>>>>
84975>>>>>>>            Function_Return False
84976>>>>>>>        End
84976>>>>>>>>
84976>>>>>>>
84976>>>>>>>        Get psDriverID to sDriverID
84977>>>>>>>        Get piDbType   to iDbType
84978>>>>>>>
84978>>>>>>>        Get phoSQLManager to hoSQLManager
84979>>>>>>>        Get psConnectionID     to sConnectionID
84980>>>>>>>        Get psConnectionString to sConnectionString
84981>>>>>>>        Move 0 to LastErr
84982>>>>>>>
84982>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84983>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84984>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84985>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84987>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
84988>>>>>>>>
84988>>>>>>>            Function_Return False
84989>>>>>>>        End
84989>>>>>>>>
84989>>>>>>>
84989>>>>>>>        Get SqlOpen of hConnection to hStmt
84990>>>>>>>
84990>>>>>>>        If (hStmt = 0) Begin
84992>>>>>>>            Send SqlDisconnect of hoSQLManager
84993>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
84994>>>>>>>>
84994>>>>>>>            Function_Return False
84995>>>>>>>        End
84995>>>>>>>>
84995>>>>>>>
84995>>>>>>>        // Check if collation already exists
84995>>>>>>>        Get SqlDatabaseCollationQuery sDatabase False to sSQLCollationCheck
84996>>>>>>>        // If the current collate is the same as the new; do nothing.
84996>>>>>>>        If (sSQLCollation = sSQLCollationCheck) Begin
84998>>>>>>>            Function_Return True
84999>>>>>>>        End
84999>>>>>>>>
84999>>>>>>>
84999>>>>>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
85000>>>>>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
85001>>>>>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
85002>>>>>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
85003>>>>>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
85004>>>>>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
85005>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
85006>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
85007>>>>>>>
85007>>>>>>>        // MS-SQL Syntax:
85007>>>>>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
85007>>>>>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
85007>>>>>>>        // ALTER DATABASE [database] SET MULTI_USER;
85007>>>>>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
85008>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
85009>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
85010>>>>>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
85010>>>>>>>
85010>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85011>>>>>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
85012>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85013>>>>>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
85015>>>>>>>           Function_Return False
85016>>>>>>>        End
85016>>>>>>>>
85016>>>>>>>
85016>>>>>>>        Function_Return (Err = False)
85017>>>>>>>    End_Function
85018>>>>>>>
85018>>>>>>>
85018>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85018>>>>>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
85020>>>>>>>        Function_Return False
85021>>>>>>>    End_Function
85022>>>>>>>
85022>>>>>>>    // Converts from SQL to Embedded (DataFlex .dat files).
85022>>>>>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
85022>>>>>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
85022>>>>>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
85022>>>>>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
85022>>>>>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
85024>>>>>>>        Handle hToTable
85024>>>>>>>        Boolean bOK bExists bOpened bCopyData
85024>>>>>>>        String sDriverID sPhysicalName sRootName sDisplayName
85024>>>>>>>        tSQLConnection SQLConnection
85024>>>>>>>        tSQLConnection SQLConnection
85024>>>>>>>        Integer iPos iMaxRecords
85024>>>>>>>
85024>>>>>>>        Get psDriverID to sDriverID
85025>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
85026>>>>>>>        If (bExists = False) Begin
85028>>>>>>>            Function_Return False
85029>>>>>>>        End
85029>>>>>>>>
85029>>>>>>>
85029>>>>>>>        If (num_arguments > 1) Begin
85031>>>>>>>            Move bCpyDat to bCopyData
85032>>>>>>>        End
85032>>>>>>>>
85032>>>>>>>        Else Begin
85033>>>>>>>            Move False to bCopyData
85034>>>>>>>        End
85034>>>>>>>>
85034>>>>>>>
85034>>>>>>>        Open hTable
85036>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85039>>>>>>>        If (bOpened = False) Begin
85041>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
85042>>>>>>>>
85042>>>>>>>            Function_Return False
85043>>>>>>>        End
85043>>>>>>>>
85043>>>>>>>        Move 0 to hToTable
85044>>>>>>>
85044>>>>>>>        Move 16711679 to iMaxRecords
85045>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85048>>>>>>>        Move (Pos(".", sDisplayName)) to iPos
85049>>>>>>>        If (iPos > 0) Begin
85051>>>>>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
85052>>>>>>>        End
85052>>>>>>>>
85052>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85055>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
85056>>>>>>>        Move (sRootName + ".dat")                    to sPhysicalName
85057>>>>>>>
85057>>>>>>>        If (ghoProgressBar <> 0) Begin
85059>>>>>>>            Send DoAdvance of ghoProgressBar
85060>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
85061>>>>>>>        End
85061>>>>>>>>
85061>>>>>>>
85061>>>>>>>        Move False to Err
85062>>>>>>>
85062>>>>>>>        Structure_Start hToTable DATAFLEX_ID
85063>>>>>>>            Structure_Copy hTable to hToTable
85064>>>>>>>
85064>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
85067>>>>>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
85070>>>>>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
85073>>>>>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
85076>>>>>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
85079>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85080>>>>>>>
85080>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85082>>>>>>>
85082>>>>>>>        Set Action_Text of ghoStatusPanel to ""
85083>>>>>>>        Move (not(Err)) to bOK
85084>>>>>>>        If (bOK = True and bCopyData = True) Begin
85086>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
85087>>>>>>>        End
85087>>>>>>>>
85087>>>>>>>
85087>>>>>>>        // This must be after copying data...
85087>>>>>>>        If (Err = False) Begin
85089>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85092>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85095>>>>>>>        End
85095>>>>>>>>
85095>>>>>>>        Move (not(Err)) to bOK
85096>>>>>>>
85096>>>>>>>        Function_Return (bOK = True)
85097>>>>>>>    End_Function
85098>>>>>>>
85098>>>>>>>    // Creates an SQL Table at the SQL end by its filelist number;
85098>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
85098>>>>>>>    Function SqlTableCreate Integer hTable Returns Boolean
85100>>>>>>>        String sTableName sSQLString sPath sCreateTable sDriverID
85100>>>>>>>        Integer iDbType
85100>>>>>>>        Boolean bExists
85100>>>>>>>
85100>>>>>>>        Get psDriverID to sDriverID
85101>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85102>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
85103>>>>>>>        If (bExists = True) Begin
85105>>>>>>>            Function_Return False
85106>>>>>>>        End
85106>>>>>>>>
85106>>>>>>>
85106>>>>>>>        Get psDataPathFirstPart to sPath
85107>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
85108>>>>>>>
85108>>>>>>>        Get piDbType to iDbType
85109>>>>>>>        Get _SqlProperTableName sTableName to sTableName
85110>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
85111>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
85112>>>>>>>
85112>>>>>>>        Move False to Err
85113>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85114>>>>>>>
85114>>>>>>>        If (Err = False) Begin
85116>>>>>>>            Send ResetFillSQLTables
85117>>>>>>>        End
85117>>>>>>>>
85117>>>>>>>        Function_Return (Err = False)
85118>>>>>>>    End_Function
85119>>>>>>>
85119>>>>>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
85119>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
85119>>>>>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
85121>>>>>>>        String sSQLString sPath sCreateTable sDriverID
85121>>>>>>>        Integer iDbType
85121>>>>>>>        Boolean bExists
85121>>>>>>>
85121>>>>>>>        Get psDriverID to sDriverID
85122>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
85123>>>>>>>        If (bExists = True) Begin
85125>>>>>>>            Function_Return False
85126>>>>>>>        End
85126>>>>>>>>
85126>>>>>>>
85126>>>>>>>        Get psDataPathFirstPart to sPath
85127>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
85128>>>>>>>        If (bExists = True) Begin
85130>>>>>>>            // ToDo: What should we do if an .int file already exists?
85130>>>>>>>        End
85130>>>>>>>>
85130>>>>>>>
85130>>>>>>>        Get piDbType to iDbType
85131>>>>>>>        Get _SqlProperTableName sTableName to sTableName
85132>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
85133>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
85134>>>>>>>
85134>>>>>>>        Move False to Err
85135>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85136>>>>>>>
85136>>>>>>>        If (Err = False) Begin
85138>>>>>>>            Send ResetFillSQLTables
85139>>>>>>>        End
85139>>>>>>>>
85139>>>>>>>        Function_Return (Err = False)
85140>>>>>>>    End_Function
85141>>>>>>>    
85141>>>>>>>    // ToDo: 2019-09-23 This needs to be finilized 
85141>>>>>>>    // It resets SQL constraints after a Structure_End, if necessary.
85141>>>>>>>    Function SqlTableRecreateConstraints Handle hTable Returns Boolean
85143>>>>>>>        Boolean bOK                                                            
85143>>>>>>>        String sStatement
85143>>>>>>>        Move "ALTER TABLE [dbo].[THREADS] ADD  DEFAULT ((0)) FOR [SEGMENTS]" to sStatement
85144>>>>>>>        Function_Return bOK
85145>>>>>>>    End_Function
85146>>>>>>>    
85146>>>>>>>    // First deletes the data cache file and then drops the passed SQL table.
85146>>>>>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
85146>>>>>>>    //       else try using the SqlTableRemoveByTableName message.
85146>>>>>>>    Function SqlTableRemove Handle hTable Returns Boolean
85148>>>>>>>        String sSQLString sPath sDropTable sTableName sDriverID
85148>>>>>>>        Integer iRetval iDbType
85148>>>>>>>        Boolean bExists bOK
85148>>>>>>>
85148>>>>>>>        Get psDriverID to sDriverID
85149>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85150>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
85151>>>>>>>        If (bExists = False) Begin
85153>>>>>>>            Function_Return False
85154>>>>>>>        End
85154>>>>>>>>
85154>>>>>>>
85154>>>>>>>        Get psDataPathFirstPart to sPath
85155>>>>>>>        Get _UtilDeleteCacheFile sTableName to iRetval
85156>>>>>>>
85156>>>>>>>        Get piDbType to iDbType
85157>>>>>>>        Get _SqlProperTableName sTableName to sTableName
85158>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
85159>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
85160>>>>>>>
85160>>>>>>>        Move False to Err
85161>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85162>>>>>>>
85162>>>>>>>        // We also need to remove the cache-file since the table has been changed
85162>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85163>>>>>>>
85163>>>>>>>        If (Err = False) Begin
85165>>>>>>>            Send ResetFillSQLTables
85166>>>>>>>        End
85166>>>>>>>>
85166>>>>>>>        Function_Return (Err = False)
85167>>>>>>>    End_Function
85168>>>>>>>
85168>>>>>>>    // First deletes the data cache file and then drops the passed data table.
85168>>>>>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
85170>>>>>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
85170>>>>>>>        Integer iRetval iDbType
85170>>>>>>>        Boolean bOK
85170>>>>>>>
85170>>>>>>>        Get psDriverID to sDriverID
85171>>>>>>>        Get psDataPathFirstPart to sPath
85172>>>>>>>        Get _UtilDeleteCacheFile sTableName to iRetval
85173>>>>>>>
85173>>>>>>>        Get piDbType to iDbType
85174>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
85175>>>>>>>        Get psSchema to sSchema
85176>>>>>>>        If (sSchema = "") Begin
85178>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
85179>>>>>>>        End
85179>>>>>>>>
85179>>>>>>>        Move (Uppercase(sTableName)) to sVal
85180>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
85182>>>>>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
85183>>>>>>>        End
85183>>>>>>>>
85183>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
85184>>>>>>>
85184>>>>>>>        Move False to Err
85185>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85186>>>>>>>
85186>>>>>>>        // We also need to remove the cache-file since the table has been changed
85186>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85187>>>>>>>
85187>>>>>>>        Function_Return (Err = False)
85188>>>>>>>    End_Function
85189>>>>>>>
85189>>>>>>>    // *** Sql View Messages ***
85189>>>>>>>
85189>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
85189>>>>>>>    Function SqlViewRemove String sDataView Returns Boolean
85191>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
85191>>>>>>>        Integer iRetval
85191>>>>>>>        Boolean bOK
85191>>>>>>>
85191>>>>>>>        Get psDriverID to sDriverID
85192>>>>>>>        Get _UtilDeleteCacheFile sDataView to iRetval
85193>>>>>>>
85193>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
85194>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
85195>>>>>>>        Set psSQLStatementString to sSQLString
85196>>>>>>>
85196>>>>>>>        // As we don't check if the view exist or not, it might happen
85196>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
85196>>>>>>>        Move False to Err
85197>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85198>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85199>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85200>>>>>>>        Move 0 to LastErr
85201>>>>>>>
85201>>>>>>>        // We also need to remove the cache-file since the table has been changed
85201>>>>>>>        Get _UtilDeleteCacheFile sDataView to bOK
85202>>>>>>>
85202>>>>>>>        Function_Return (Err = False)
85203>>>>>>>    End_Function
85204>>>>>>>
85204>>>>>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
85206>>>>>>>        Boolean bOK
85206>>>>>>>        Integer iDbType
85206>>>>>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
85206>>>>>>>
85206>>>>>>>        Get psDriverID to sDriverID
85207>>>>>>>        Get piDbType   to iDbType
85208>>>>>>>
85208>>>>>>>        Case Begin
85208>>>>>>>            Case (iDbType = EN_DbTypeDB2)
85210>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85211>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85212>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
85213>>>>>>>            Break
85214>>>>>>>
85214>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
85217>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85218>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85219>>>>>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - String(sNewtTableName) - "'") to sSQLString
85220>>>>>>>            Break
85221>>>>>>>
85221>>>>>>>            Case (iDbType = EN_DbTypeOracle)
85224>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85225>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85226>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
85227>>>>>>>            Break
85228>>>>>>>
85228>>>>>>>            Case (iDbType = EN_DbTypePostgre)
85231>>>>>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
85232>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85233>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85234>>>>>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * String(sNewtTableName)) to sSQLString
85235>>>>>>>            Break
85236>>>>>>>
85236>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
85239>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
85240>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
85241>>>>>>>                Move (Replaces("-", sNewtTableName, "_")) to sNewtTableName
85242>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
85243>>>>>>>            Break
85244>>>>>>>        Case End
85244>>>>>>>
85244>>>>>>>        Move False to Err
85245>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
85246>>>>>>>        Move (Err = False) to bOK
85247>>>>>>>
85247>>>>>>>        Function_Return bOK
85248>>>>>>>    End_Function
85249>>>>>>>
85249>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85249>>>>>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
85251>>>>>>>        Function_Return False
85252>>>>>>>    End_Function
85253>>>>>>>
85253>>>>>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
85253>>>>>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
85255>>>>>>>        Integer iLength iDecimals
85255>>>>>>>        String sColumnValue
85255>>>>>>>        String sTableName sDriverID
85255>>>>>>>        Boolean bOK bInitializeValue
85255>>>>>>>
85255>>>>>>>        Get psDriverID to sDriverID
85256>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85257>>>>>>>        If (bOK = False) Begin
85259>>>>>>>            Function_Return False
85260>>>>>>>        End
85260>>>>>>>>
85260>>>>>>>
85260>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85261>>>>>>>        If (sTableName = "") Begin
85263>>>>>>>            Function_Return False
85264>>>>>>>        End
85264>>>>>>>>
85264>>>>>>>
85264>>>>>>>        If (num_arguments > 3) Begin
85266>>>>>>>            Move iLen     to iLength
85267>>>>>>>            Move iDec     to iDecimals
85268>>>>>>>            Move bInitVal to bInitializeValue
85269>>>>>>>            Move sColVal  to sColumnValue
85270>>>>>>>        End
85270>>>>>>>>
85270>>>>>>>
85270>>>>>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
85271>>>>>>>
85271>>>>>>>        Function_Return (bOK = True)
85272>>>>>>>    End_Function
85273>>>>>>>
85273>>>>>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
85273>>>>>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
85275>>>>>>>        Integer iDbType iLength iDecimals iDriver
85275>>>>>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
85275>>>>>>>        String sDriverID sNotNull
85275>>>>>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState
85275>>>>>>>        Handle hTable
85275>>>>>>>
85275>>>>>>>        Get psDriverID to sDriverID
85276>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85277>>>>>>>        If (bOK = False) Begin
85279>>>>>>>            Function_Return True
85280>>>>>>>        End
85280>>>>>>>>
85280>>>>>>>
85280>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
85281>>>>>>>        If (hTable = 0) Begin
85283>>>>>>>            Get NextFreeFilelistSlot to hTable
85284>>>>>>>        End
85284>>>>>>>>
85284>>>>>>>
85284>>>>>>>        Get piDbType to iDbType
85285>>>>>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
85285>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
85286>>>>>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
85288>>>>>>>            Function_Return True
85289>>>>>>>        End
85289>>>>>>>>
85289>>>>>>>
85289>>>>>>>        Get DriverIndex sDriverID to iDriver
85290>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85293>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
85296>>>>>>>
85296>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
85297>>>>>>>        If (num_arguments > 3) Begin
85299>>>>>>>            Move iLen     to iLength
85300>>>>>>>            Move iDec     to iDecimals
85301>>>>>>>            Move bInitVal to bInitializeValue
85302>>>>>>>            Move sColVal  to sColumnValue
85303>>>>>>>        End
85303>>>>>>>>
85303>>>>>>>
85303>>>>>>>        Get _SqlProperTableName sTableName   to sTableName
85304>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
85305>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
85306>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
85307>>>>>>>
85307>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
85308>>>>>>>        If (bFixed = False) Begin
85310>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
85311>>>>>>>        End
85311>>>>>>>>
85311>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
85312>>>>>>>
85312>>>>>>>        Move False to Err
85313>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85314>>>>>>>
85314>>>>>>>        If (bInitializeValue = True and Err = False) Begin
85316>>>>>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
85317>>>>>>>        End
85317>>>>>>>>
85317>>>>>>>
85317>>>>>>>        If (Err = False) Begin
85319>>>>>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
85320>>>>>>>        End
85320>>>>>>>>
85320>>>>>>>
85320>>>>>>>        Move (not(Err)) to bRetval
85321>>>>>>>
85321>>>>>>>        // We also need to remove the cache-file since the table has been changed
85321>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85322>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85325>>>>>>>
85325>>>>>>>        Function_Return bRetval
85326>>>>>>>    End_Function
85327>>>>>>>
85327>>>>>>>    // To update all current rows for a table column with a common value.
85327>>>>>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
85329>>>>>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sSqlSafe_Updates sStmt
85329>>>>>>>        Boolean bRetval bSQLDriver
85329>>>>>>>        Integer iCurrErr iDbType
85329>>>>>>>
85329>>>>>>>        Move False to bRetval
85330>>>>>>>        Get piDbType to iDbType
85331>>>>>>>        Get psDriverID to sDriverID
85332>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
85333>>>>>>>        If (bSQLDriver = False) Begin
85335>>>>>>>            Function_Return bRetval
85336>>>>>>>        End
85336>>>>>>>>
85336>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85337>>>>>>>
85337>>>>>>>        Move Err to iCurrErr
85338>>>>>>>        Move False to Err
85339>>>>>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
85340>>>>>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
85341>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
85342>>>>>>>        // If MySQL and DAW's ODBC driver is used we need to do it slightly different.
85342>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
85344>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
85345>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
85346>>>>>>>        End
85346>>>>>>>>
85346>>>>>>>        Else Begin
85347>>>>>>>            Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
85348>>>>>>>        End
85348>>>>>>>>
85348>>>>>>>
85348>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85349>>>>>>>        Move (Err = False) to bRetval
85350>>>>>>>        Move iCurrErr to Err
85351>>>>>>>
85351>>>>>>>        Function_Return bRetval
85352>>>>>>>    End_Function
85353>>>>>>>
85353>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
85353>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
85353>>>>>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
85355>>>>>>>        String sDriverID sTableName
85355>>>>>>>        Boolean bOK
85355>>>>>>>
85355>>>>>>>        Get psDriverID to sDriverID
85356>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85357>>>>>>>        If (bOK = False) Begin
85359>>>>>>>            Function_Return False
85360>>>>>>>        End
85360>>>>>>>>
85360>>>>>>>
85360>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85361>>>>>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
85362>>>>>>>
85362>>>>>>>        Function_Return (Err = False)
85363>>>>>>>    End_Function
85364>>>>>>>
85364>>>>>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
85364>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
85364>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
85364>>>>>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
85366>>>>>>>        Integer iDbType iLength iDecimals
85366>>>>>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
85366>>>>>>>        Boolean bExists bOK bFixed
85366>>>>>>>        Handle hTable
85366>>>>>>>
85366>>>>>>>        Get psDriverID to sDriverID
85367>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85368>>>>>>>        If (bOK = False) Begin
85370>>>>>>>            Function_Return False
85371>>>>>>>        End
85371>>>>>>>>
85371>>>>>>>
85371>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
85372>>>>>>>        If (hTable = 0) Begin
85374>>>>>>>            Get NextFreeFilelistSlot to hTable
85375>>>>>>>        End
85375>>>>>>>>
85375>>>>>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
85376>>>>>>>        If (bExists = False) Begin
85378>>>>>>>            Function_Return False
85379>>>>>>>        End
85379>>>>>>>>
85379>>>>>>>
85379>>>>>>>        If (num_arguments > 3) Begin
85381>>>>>>>            Move iLen to iLength
85382>>>>>>>        End
85382>>>>>>>>
85382>>>>>>>        If (num_arguments > 4) Begin
85384>>>>>>>            Move iDec to iDecimals
85385>>>>>>>        End
85385>>>>>>>>
85385>>>>>>>
85385>>>>>>>        Get piDbType to iDbType
85386>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
85387>>>>>>>
85387>>>>>>>        Move False to Err
85388>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
85389>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
85390>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
85391>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
85392>>>>>>>
85392>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
85393>>>>>>>        If (bFixed = False) Begin
85395>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
85396>>>>>>>        End
85396>>>>>>>>
85396>>>>>>>
85396>>>>>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
85397>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85398>>>>>>>
85398>>>>>>>        // We also need to remove the cache-file since the table has been changed
85398>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85399>>>>>>>
85399>>>>>>>        Function_Return (Err = False)
85400>>>>>>>    End_Function
85401>>>>>>>
85401>>>>>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
85403>>>>>>>        Boolean bOK bErr bIsSQLDriver
85403>>>>>>>        String sDriverID
85403>>>>>>>        Integer iDataType
85403>>>>>>>
85403>>>>>>>        Get psDriverID to sDriverID
85404>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
85405>>>>>>>        If (bIsSQLDriver = False) Begin
85407>>>>>>>            Function_Return False
85408>>>>>>>        End
85408>>>>>>>>
85408>>>>>>>
85408>>>>>>>        Move Err to bErr
85409>>>>>>>        Move False to bErr
85410>>>>>>>
85410>>>>>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
85410>>>>>>>        // inserts randomly character(10) and spaces, so we correct from that here:
85410>>>>>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
85411>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType
85414>>>>>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
85416>>>>>>>            Move ("[" + String(sValue) + "]") to sValue
85417>>>>>>>        End
85417>>>>>>>>
85417>>>>>>>
85417>>>>>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
85420>>>>>>>        Move (not(Err)) to bOK
85421>>>>>>>        Move bErr to Err
85422>>>>>>>
85422>>>>>>>        Function_Return bOK
85423>>>>>>>    End_Function
85424>>>>>>>
85424>>>>>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
85426>>>>>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
85426>>>>>>>        String sDriverID
85426>>>>>>>
85426>>>>>>>        Get psDriverID to sDriverID
85427>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
85428>>>>>>>        If (bIsSQLDriver = False) Begin
85430>>>>>>>            Function_Return False
85431>>>>>>>        End
85431>>>>>>>>
85431>>>>>>>
85431>>>>>>>        Move Err to bErr
85432>>>>>>>        Move False to bErr
85433>>>>>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
85436>>>>>>>        If (bNullable = bCurrentState) Begin
85438>>>>>>>            Function_Return True
85439>>>>>>>        End
85439>>>>>>>>
85439>>>>>>>
85439>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
85442>>>>>>>        If (bOpen = False) Begin
85444>>>>>>>            Get AutoConnectionIDLogin to bOK
85445>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
85446>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
85447>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85448>>>>>>>            Open hTable
85450>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
85451>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
85452>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85453>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
85456>>>>>>>        End
85456>>>>>>>>
85456>>>>>>>        If (bOpen = True) Begin
85458>>>>>>>            Structure_Start hTable sDriverID
85459>>>>>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
85462>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
85463>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85465>>>>>>>            Set Action_Text of ghoStatusPanel to ""
85466>>>>>>>        End
85466>>>>>>>>
85466>>>>>>>
85466>>>>>>>        Move (not(Err)) to bOK
85467>>>>>>>        Move bErr to Err
85468>>>>>>>
85468>>>>>>>        Function_Return bOK
85469>>>>>>>    End_Function
85470>>>>>>>
85470>>>>>>>    // Drop column by its table handle
85470>>>>>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
85472>>>>>>>        String sDriverID sTableName
85472>>>>>>>        Boolean bOK
85472>>>>>>>
85472>>>>>>>        Get psDriverID to sDriverID
85473>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85474>>>>>>>        If (bOK = False) Begin
85476>>>>>>>            Function_Return False
85477>>>>>>>        End
85477>>>>>>>>
85477>>>>>>>
85477>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85478>>>>>>>        If (sTableName = "") Begin
85480>>>>>>>            Function_Return False
85481>>>>>>>        End
85481>>>>>>>>
85481>>>>>>>
85481>>>>>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
85482>>>>>>>
85482>>>>>>>        Function_Return (bOK = True)
85483>>>>>>>    End_Function
85484>>>>>>>
85484>>>>>>>    // Drop column by its table name as a string.
85484>>>>>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
85486>>>>>>>        Integer iDbType iDriver
85486>>>>>>>        String sDriverID sStmt sAlterTable sDropColumn
85486>>>>>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
85486>>>>>>>        Handle hTable
85486>>>>>>>
85486>>>>>>>        Get psDriverID to sDriverID
85487>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85488>>>>>>>        If (bOK = False) Begin
85490>>>>>>>            Function_Return False
85491>>>>>>>        End
85491>>>>>>>>
85491>>>>>>>
85491>>>>>>>        Get DriverIndex sDriverID to iDriver
85492>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85495>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
85498>>>>>>>
85498>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
85499>>>>>>>        If (hTable <> 0) Begin
85501>>>>>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
85502>>>>>>>            If (bExists = False) Begin
85504>>>>>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85507>>>>>>>                Function_Return False
85508>>>>>>>            End
85508>>>>>>>>
85508>>>>>>>        End
85508>>>>>>>>
85508>>>>>>>
85508>>>>>>>        Get piDbType to iDbType
85509>>>>>>>        If (iDbType = EN_DbTypeMSSQL) Begin
85511>>>>>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
85512>>>>>>>            Get _UtilDeleteCacheFile sTableName to bOK
85513>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85516>>>>>>>            Function_Return bOK
85517>>>>>>>        End
85517>>>>>>>>
85517>>>>>>>
85517>>>>>>>        Move False to Err
85518>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
85519>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
85520>>>>>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
85521>>>>>>>
85521>>>>>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
85522>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85523>>>>>>>        Move (not(Err)) to bRetval
85524>>>>>>>
85524>>>>>>>        // We also need to remove the cache-file since the table has been changed
85524>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85525>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85528>>>>>>>
85528>>>>>>>        Function_Return bRetval
85529>>>>>>>    End_Function
85530>>>>>>>
85530>>>>>>>    // Rename a field/column by table handle (filelist number)
85530>>>>>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
85532>>>>>>>        String sDriverID sTableName
85532>>>>>>>        Boolean bOK
85532>>>>>>>
85532>>>>>>>        Get psDriverID to sDriverID
85533>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85534>>>>>>>        If (bOK = False) Begin
85536>>>>>>>            Function_Return False
85537>>>>>>>        End
85537>>>>>>>>
85537>>>>>>>
85537>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85538>>>>>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
85539>>>>>>>
85539>>>>>>>        Function_Return (Err = False)
85540>>>>>>>    End_Function
85541>>>>>>>
85541>>>>>>>    // Rename a field/column by table name.
85541>>>>>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
85543>>>>>>>        Integer iDbType iDataType
85543>>>>>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
85543>>>>>>>        Boolean bOK bRetval
85543>>>>>>>        Handle hTable
85543>>>>>>>
85543>>>>>>>        Move sTableName to sOrgTableName
85544>>>>>>>        Get psDriverID to sDriverID
85545>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85546>>>>>>>        If (bOK = False) Begin
85548>>>>>>>            Function_Return False
85549>>>>>>>        End
85549>>>>>>>>
85549>>>>>>>
85549>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
85550>>>>>>>        If (sVal = "") Begin
85552>>>>>>>            Function_Return False
85553>>>>>>>        End
85553>>>>>>>>
85553>>>>>>>
85553>>>>>>>        Get piDbType to iDbType
85554>>>>>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
85555>>>>>>>        Get _SqlProperTableName sTableName     to sTableName
85556>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
85557>>>>>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
85558>>>>>>>
85558>>>>>>>        Case Begin
85558>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
85560>>>>>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
85561>>>>>>>                Case Break
85562>>>>>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
85562>>>>>>>            Case (iDbType = EN_dbTypeOracle)
85565>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85566>>>>>>>                Case Break
85567>>>>>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
85567>>>>>>>            Case (iDbType = EN_dbTypeDB2)
85570>>>>>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85571>>>>>>>                Case Break
85572>>>>>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
85572>>>>>>>            Case (iDbType = EN_dbTypePostgre)
85575>>>>>>>                Move sOrgTableName to sTableName
85576>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85577>>>>>>>                Case Break
85578>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
85581>>>>>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
85581>>>>>>>                Move sOrgTableName to sTableName
85582>>>>>>>                Get psDatabase to sDatabase
85583>>>>>>>                Get UtilTableNameToHandle sTableName to hTable
85584>>>>>>>                If (hTable = 0) Begin
85586>>>>>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
85587>>>>>>>                    If (bOK = False) Begin
85589>>>>>>>                        Function_Return False
85590>>>>>>>                    End
85590>>>>>>>>
85590>>>>>>>                    Get NextFreeFilelistSlot to hTable
85591>>>>>>>                End
85591>>>>>>>>
85591>>>>>>>                Else Begin
85592>>>>>>>                    Open hTable
85594>>>>>>>                End
85594>>>>>>>>
85594>>>>>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
85595>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
85596>>>>>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
85597>>>>>>>                Case Break
85598>>>>>>>            Case Else
85598>>>>>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
85599>>>>>>>        Case End
85599>>>>>>>
85599>>>>>>>        Move False to Err
85600>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85601>>>>>>>        Move (Err = False) to bRetval
85602>>>>>>>        // We also need to remove the cache-file since the table has been changed
85602>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85603>>>>>>>
85603>>>>>>>        Function_Return bRetval
85604>>>>>>>    End_Function
85605>>>>>>>
85605>>>>>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
85607>>>>>>>        Handle hoSQLHandler hSQLConnect hStmt
85607>>>>>>>        Integer iNumCols iCount iDataType
85607>>>>>>>        String sValue
85607>>>>>>>
85607>>>>>>>        Get phoSQLManager to hoSQLHandler
85608>>>>>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
85609>>>>>>>        If (hSQLConnect <> 0) Begin
85611>>>>>>>            Get SQLOpen of hSQLConnect to hStmt
85612>>>>>>>            If (hStmt <> 0) Begin
85614>>>>>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
85615>>>>>>>
85615>>>>>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
85616>>>>>>>                For iCount from 1 to iNumCols
85622>>>>>>>>
85622>>>>>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
85623>>>>>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
85625>>>>>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
85626>>>>>>>                        Move iNumCols to iCount // We're out of here
85627>>>>>>>                    End
85627>>>>>>>>
85627>>>>>>>                Loop
85628>>>>>>>>
85628>>>>>>>
85628>>>>>>>                Send SQLClose of hStmt
85629>>>>>>>            End
85629>>>>>>>>
85629>>>>>>>            Send SQLDisconnect of hSQLConnect
85630>>>>>>>        End
85630>>>>>>>>
85630>>>>>>>
85630>>>>>>>        Function_Return iDataType
85631>>>>>>>    End_Function
85632>>>>>>>
85632>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85632>>>>>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
85634>>>>>>>        Function_Return False
85635>>>>>>>    End_Function
85636>>>>>>>
85636>>>>>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
85638>>>>>>>        String sMessage // sConnectionString
85638>>>>>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
85638>>>>>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
85638>>>>>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
85641>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
85641>>>>>>>        TimeSpan tsQuery tsFetch
85641>>>>>>>        tSqlErrorArray aSqlErrorArray
85641>>>>>>>        tSqlErrorArray aSqlErrorArray
85641>>>>>>>        Boolean bOK bShowProgress
85641>>>>>>>        tSQLConnection SQLConnection
85641>>>>>>>        tSQLConnection SQLConnection
85641>>>>>>>
85641>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85642>>>>>>>        If (bOK = False) Begin
85644>>>>>>>            Procedure_Return
85645>>>>>>>        End
85645>>>>>>>>
85645>>>>>>>
85645>>>>>>>        If (num_arguments > 2) Begin
85647>>>>>>>            Move bShowProgr to bShowProgress
85648>>>>>>>        End
85648>>>>>>>>
85648>>>>>>>
85648>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85649>>>>>>>        Get phoSQLManager to hoSqlHandler
85650>>>>>>>        Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
85651>>>>>>>        Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
85652>>>>>>>
85652>>>>>>>        If (hoSQLConnect <> 0) Begin
85654>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
85655>>>>>>>            If (hoStmt <> 0) Begin
85657>>>>>>>                // record starting date/time stamp
85657>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
85658>>>>>>>                // turn on error handling if enabled
85658>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85660>>>>>>>                    Set pbSqlError to False
85661>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
85662>>>>>>>                    Move Error_Object_Id to hoError
85663>>>>>>>                    If (ghoDbUpdateHandler <> 0) Begin
85665>>>>>>>                        Move ghoDbUpdateHandler to Error_Object_Id
85666>>>>>>>                    End
85666>>>>>>>>
85666>>>>>>>                    Else Begin
85667>>>>>>>                        Move Self to Error_Object_Id
85668>>>>>>>                    End
85668>>>>>>>>
85668>>>>>>>                End
85668>>>>>>>>
85668>>>>>>>
85668>>>>>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
85668>>>>>>>                Set psSQLStatementString to sStmt
85669>>>>>>>                Send Cursor_Wait of Cursor_Control
85670>>>>>>>                Send SqlExecDirect of hoStmt sStmt
85671>>>>>>>                Send Cursor_Ready of Cursor_Control
85672>>>>>>>
85672>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85674>>>>>>>                    Move hoError to Error_Object_Id
85675>>>>>>>                End
85675>>>>>>>>
85675>>>>>>>
85675>>>>>>>                Move 0 to iMsgs
85676>>>>>>>                Move Err to iErr
85677>>>>>>>                Move LastErr to iLastErr
85678>>>>>>>                Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
85679>>>>>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
85680>>>>>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
85681>>>>>>>                Send _SqlColumnInfo hoStmt
85682>>>>>>>                Send Ignore_Error of Error_Object_Id 12289
85683>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85684>>>>>>>                Repeat
85684>>>>>>>>
85684>>>>>>>                    Get SqlFetch of hoStmt to iFetchResult
85685>>>>>>>                    If (iFetchResult <> 0) Begin
85687>>>>>>>                        Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
85688>>>>>>>                    End
85688>>>>>>>>
85688>>>>>>>                Until (iFetchResult = 0)
85690>>>>>>>                Send Trap_Error of Error_Object_Id 12289
85691>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
85692>>>>>>>                Move iErr to Err
85693>>>>>>>                Move iLastErr to LastErr
85694>>>>>>>                Set paSQLFetchResults to aSQLFetchResults
85695>>>>>>>
85695>>>>>>>                Set piRows    to iRows
85696>>>>>>>                Set piRowType to iRowType
85697>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
85698>>>>>>>                Move (CurrentDateTime()) to dtFetchStart
85699>>>>>>>
85699>>>>>>>                If (iMsgs <> 0) Begin
85701>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
85703>>>>>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85704>>>>>>>                    End
85704>>>>>>>>
85704>>>>>>>                    For i from 1 to iMsgs
85710>>>>>>>>
85710>>>>>>>                        Get SqlGetMessage of hoStmt i to sMessage
85711>>>>>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
85712>>>>>>>                        If (bShowProgress = True) Begin
85714>>>>>>>                            If (Active_State(ghoStatusPanel)) Begin
85716>>>>>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85717>>>>>>>                            End
85717>>>>>>>>
85717>>>>>>>                            Else Begin
85718>>>>>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85720>>>>>>>                            End
85720>>>>>>>>
85720>>>>>>>                        End
85720>>>>>>>>
85720>>>>>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
85721>>>>>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
85722>>>>>>>                    Loop
85723>>>>>>>>
85723>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
85725>>>>>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85726>>>>>>>                    End
85726>>>>>>>>
85726>>>>>>>                    Set paQueryMessages to sMsg
85727>>>>>>>                End
85727>>>>>>>>
85727>>>>>>>                Else Begin
85728>>>>>>>                    If (bShowProgress = True) Begin
85730>>>>>>>                        Get paSqlErrorArray to aSqlErrorArray
85731>>>>>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
85733>>>>>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
85734>>>>>>>                            Decrement iMsgs
85735>>>>>>>                            For i from 0 to iMsgs
85741>>>>>>>>
85741>>>>>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
85744>>>>>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
85747>>>>>>>                            Loop
85748>>>>>>>>
85748>>>>>>>                        End
85748>>>>>>>>
85748>>>>>>>                    End
85748>>>>>>>>
85748>>>>>>>                End
85748>>>>>>>>
85748>>>>>>>                Move (CurrentDateTime()) to dtFetchEnd
85749>>>>>>>            End
85749>>>>>>>>
85749>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
85750>>>>>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
85751>>>>>>>            Set ptsQueryExec to tsQuery
85752>>>>>>>            Set ptsFetchResults to tsFetch
85753>>>>>>>            Send SqlClose of hoStmt
85754>>>>>>>        End
85754>>>>>>>>
85754>>>>>>>
85754>>>>>>>        Send SqlDisconnect of hoSQLConnect
85755>>>>>>>    End_Procedure
85756>>>>>>>
85756>>>>>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
85756>>>>>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
85756>>>>>>>    // Returns False if no error occured.
85756>>>>>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
85758>>>>>>>        Boolean bOK bShowProgress
85758>>>>>>>        tSQLScriptArray SQLScriptArray
85758>>>>>>>        tSQLScriptArray SQLScriptArray
85758>>>>>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
85758>>>>>>>        TimeSpan tsTotalTime
85758>>>>>>>
85758>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryStart
85759>>>>>>>        Get _SqlUtilReadResource sMemFileName to SQLScriptArray
85760>>>>>>>        If (SQLScriptArray.bError = True) Begin
85762>>>>>>>            Function_Return False
85763>>>>>>>        End
85763>>>>>>>>
85763>>>>>>>
85763>>>>>>>        If (num_arguments > 3) Begin
85765>>>>>>>            Move bShowProgr to bShowProgress
85766>>>>>>>        End
85766>>>>>>>>
85766>>>>>>>
85766>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85767>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
85768>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85769>>>>>>>
85769>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
85770>>>>>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
85771>>>>>>>        Set ptsTotalQueryTime to tsTotalTime
85772>>>>>>>
85772>>>>>>>        Function_Return bOK
85773>>>>>>>    End_Function
85774>>>>>>>
85774>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85774>>>>>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
85776>>>>>>>        Function_Return False
85777>>>>>>>    End_Function
85778>>>>>>>
85778>>>>>>>    // Does three things with auxilirary files;
85778>>>>>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
85778>>>>>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
85778>>>>>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
85778>>>>>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
85780>>>>>>>        String sDataPath sDDSrcPath sDriverID
85780>>>>>>>        Boolean bOK bExists
85780>>>>>>>        Integer iCount iCh iPos
85780>>>>>>>
85780>>>>>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
85780>>>>>>>        If (sTableName contains ".") Begin
85782>>>>>>>            Move (Pos(".", sTableName)) to iPos
85783>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
85784>>>>>>>        End
85784>>>>>>>>
85784>>>>>>>
85784>>>>>>>        Get psDriverID to sDriverID
85785>>>>>>>        Get psDataPathFirstPart to sDataPath
85786>>>>>>>        Get vFolderExists sDataPath to bOK
85787>>>>>>>        If (bOK = False) Begin
85789>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
85790>>>>>>>>
85790>>>>>>>            Function_Return False
85791>>>>>>>        End
85791>>>>>>>>
85791>>>>>>>
85791>>>>>>>        // First delete the cache file:
85791>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85792>>>>>>>
85792>>>>>>>        Get Seq_New_Channel to iCh
85793>>>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
85795>>>>>>>            Function_Return False
85796>>>>>>>        End
85796>>>>>>>>
85796>>>>>>>
85796>>>>>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
85797>>>>>>>        If (bExists = False) Begin
85799>>>>>>>            Function_Return False
85800>>>>>>>        End
85800>>>>>>>>
85800>>>>>>>
85800>>>>>>>        Get _SqlUtilUpdateIntFile hTable to bOK
85801>>>>>>>        // Add the new column name to the .tag filen (if it doesn't exist):
85801>>>>>>>        Get _UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sColumnName to bOK
85802>>>>>>>
85802>>>>>>>        // If in development environment; output new .fd file:
85802>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
85803>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
85804>>>>>>>        If (iCount > 1) Begin
85806>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
85807>>>>>>>        End
85807>>>>>>>>
85807>>>>>>>        Get vFolderExists sDDSrcPath to bExists
85808>>>>>>>        If (bExists = True) Begin
85810>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
85811>>>>>>>            Move False to Err
85812>>>>>>>            Get AutoConnectionIDLogin to bOK
85813>>>>>>>            If (hTable <> 0) Begin
85815>>>>>>>                Open hTable
85817>>>>>>>            End
85817>>>>>>>>
85817>>>>>>>            Else Begin
85818>>>>>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
85819>>>>>>>            End
85819>>>>>>>>
85819>>>>>>>
85819>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
85822>>>>>>>            If (bOK = True) Begin
85824>>>>>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
85826>>>>>>>            End
85826>>>>>>>>
85826>>>>>>>            If (Err = True) Begin
85828>>>>>>>                Move False to bOK
85829>>>>>>>            End
85829>>>>>>>>
85829>>>>>>>        End
85829>>>>>>>>
85829>>>>>>>
85829>>>>>>>        Function_Return (bOK = True)
85830>>>>>>>    End_Function
85831>>>>>>>
85831>>>>>>>    // Message for changing .int files to use connection ID's
85831>>>>>>>    //
85831>>>>>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
85831>>>>>>>    // OR changes an existing connection id to a new id.
85831>>>>>>>    // Pass the full path to the data folder and the name of the connection id (string value).
85831>>>>>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
85831>>>>>>>    Function SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult Returns String[] 
85833>>>>>>>        String sFileName sDriverID sDriverFile sConnectionString sPath
85833>>>>>>>        String[] sFilesData asFileChanges
85835>>>>>>>        Boolean bOK bCancel bChange
85835>>>>>>>        Integer iSize iCount
85835>>>>>>>
85835>>>>>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
85836>>>>>>>        Move (SizeOfArray(sFilesData))    to iSize
85837>>>>>>>        If (iSize = 0) Begin
85839>>>>>>>            If (ghoStatusPanel <> 0) Begin
85841>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
85843>>>>>>>                    Send Stop_StatusPanel of ghoStatusPanel
85844>>>>>>>                End
85844>>>>>>>>
85844>>>>>>>            End
85844>>>>>>>>
85844>>>>>>>            Send Info_Box CS_DUF_NoIntFilesFound
85845>>>>>>>            Function_Return 0
85846>>>>>>>        End
85846>>>>>>>>
85846>>>>>>>
85846>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
85847>>>>>>>        Get vFolderFormat sDataPath to sDataPath
85848>>>>>>>        Decrement iSize
85849>>>>>>>        For iCount from 0 to iSize
85855>>>>>>>>
85855>>>>>>>            Move sFilesData[iCount] to sFileName
85856>>>>>>>            If (Lowercase(sFileName) <> "mssqldrv.int" and Lowercase(sFileName) <> "db2_drv.int" and Lowercase(sFileName) <> "odbc_drv.int") Begin
85858>>>>>>>            // This makes sure that we also can change an existing connection id to something new:
85858>>>>>>>            Get _UtilChangeSourceCodeLine (sDataPath + sFileName) (CS_SERVER_NAME * CS_SERVER) (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bChange
85859>>>>>>>            If (bChange = True) Begin
85861>>>>>>>                Move sFileName to asFileChanges[SizeOfArray(asFileChanges)]
85862>>>>>>>            End
85862>>>>>>>>
85862>>>>>>>            If (ghoStatusPanel <> 0) Begin
85864>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
85866>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
85867>>>>>>>                    If (bCancel = True) Begin
85869>>>>>>>                        Send Deactivate of ghoStatusPanel
85870>>>>>>>                        Function_Return asFileChanges
85871>>>>>>>                        End
85871>>>>>>>>
85871>>>>>>>                    End
85871>>>>>>>>
85871>>>>>>>                End
85871>>>>>>>>
85871>>>>>>>            End
85871>>>>>>>>
85871>>>>>>>        Loop
85872>>>>>>>>
85872>>>>>>>
85872>>>>>>>         // ToDo: Not sure at all we want to do this automatically:
85872>>>>>>>//        Get psDriverID to sDriverID
85872>>>>>>>//         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
85872>>>>>>>//        Move "" to sFileName
85872>>>>>>>//        If (sDriverID = MSSQLDRV_ID) Begin
85872>>>>>>>//            Move "MSSQLDrv.int" to sFileName
85872>>>>>>>//        End
85872>>>>>>>//        If (sDriverID = DB2_DRV_ID) Begin
85872>>>>>>>//            Move "DB2_Drv.int" to sFileName
85872>>>>>>>//        End
85872>>>>>>>//        If (sDriverID = ODBC_DRV_ID) Begin
85872>>>>>>>//            Move "ODBC_Drv.int" to sFileName
85872>>>>>>>//        End
85872>>>>>>>//        If (sFileName <> "") Begin
85872>>>>>>>//            Move "" to sDriverFile
85872>>>>>>>//            Get_File_Path sFileName to sDriverFile
85872>>>>>>>//            Get ParseFolderName sDriverFile to sPath
85872>>>>>>>//            If (sDataPath <> sPath) Begin
85872>>>>>>>//                Move "" to sDriverFile
85872>>>>>>>//            End
85872>>>>>>>//            If (sDriverFile <> "") Begin
85872>>>>>>>//                Get psConnectionString to sConnectionString
85872>>>>>>>//                Get _UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
85872>>>>>>>//            End
85872>>>>>>>//        End     
85872>>>>>>>        
85872>>>>>>>        Function_Return asFileChanges
85873>>>>>>>    End_Function
85874>>>>>>>
85874>>>>>>>    // Checks if the database exists in SQL. Returns = True if it does.
85874>>>>>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
85876>>>>>>>        String[] sDatabaseArray
85877>>>>>>>        String sVal sServer sDriverID
85877>>>>>>>        Integer iCount iSize iPos
85877>>>>>>>        Boolean bExists
85877>>>>>>>        tSQLConnection SQLConnection
85877>>>>>>>        tSQLConnection SQLConnection
85877>>>>>>>
85877>>>>>>>        Move False to bExists
85878>>>>>>>        Get psDriverID to sDriverID
85879>>>>>>>        // DB2 doesn't have a "Database" name, so we always return True.
85879>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
85881>>>>>>>            Function_Return bExists
85882>>>>>>>        End
85882>>>>>>>>
85882>>>>>>>
85882>>>>>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
85883>>>>>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
85885>>>>>>>            Function_Return False
85886>>>>>>>        End
85886>>>>>>>>
85886>>>>>>>
85886>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85887>>>>>>>        Move SQLConnection.sServer to sServer
85888>>>>>>>
85888>>>>>>>        // Special code to handle a FILEDSN that also can contain "/"
85888>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
85890>>>>>>>            Move sDatabaseArray[0] to sVal  // Dummy!
85891>>>>>>>        End
85891>>>>>>>>
85891>>>>>>>        Else If (sServer contains "/") Begin
85894>>>>>>>            Move (Pos("/", sServer)) to iPos
85895>>>>>>>            Move (Mid(sServer, 999, (iPos +1))) to sDatabase
85896>>>>>>>        End
85896>>>>>>>>
85896>>>>>>>
85896>>>>>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
85897>>>>>>>        Decrement iSize
85898>>>>>>>        For iCount from 0 to iSize
85904>>>>>>>>
85904>>>>>>>            Move sDatabaseArray[iCount] to sVal
85905>>>>>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
85907>>>>>>>                Move True to bExists
85908>>>>>>>                If (bExists = True) Begin
85910>>>>>>>                    Move iSize to iCount // We're done.
85911>>>>>>>                End
85911>>>>>>>>
85911>>>>>>>            End
85911>>>>>>>>
85911>>>>>>>        Loop
85912>>>>>>>>
85912>>>>>>>
85912>>>>>>>        Function_Return bExists
85913>>>>>>>    End_Function
85914>>>>>>>
85914>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
85914>>>>>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
85916>>>>>>>        String sDatabase sSchema sTableName sVal
85916>>>>>>>        Boolean bExists
85916>>>>>>>        String[] sTablesArray
85917>>>>>>>        Integer iSize iCount
85917>>>>>>>
85917>>>>>>>        Move False to bExists
85918>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85919>>>>>>>        Get psDatabase to sDatabase
85920>>>>>>>        Get psSchema   to sSchema
85921>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
85922>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
85923>>>>>>>        Decrement iSize
85924>>>>>>>        For iCount from 0 to iSize
85930>>>>>>>>
85930>>>>>>>            Move sTablesArray[iCount] to sVal
85931>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85933>>>>>>>                Move True to bExists
85934>>>>>>>                Move iSize to iCount // We're done!
85935>>>>>>>            End
85935>>>>>>>>
85935>>>>>>>        Loop
85936>>>>>>>>
85936>>>>>>>
85936>>>>>>>        Function_Return bExists
85937>>>>>>>    End_Function
85938>>>>>>>
85938>>>>>>>    Function SqlUtilCheckIfTableNameSpelling String sDriverID String sDatabase String sTableName String sSchema Returns String
85940>>>>>>>        String sVal sTableSpelledCorrectly
85940>>>>>>>        Boolean bExists
85940>>>>>>>        String[] sTablesArray
85941>>>>>>>        Integer iSize iCount
85941>>>>>>>
85941>>>>>>>        Move False to bExists
85942>>>>>>>        Move sTableName to sTableSpelledCorrectly
85943>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
85944>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
85945>>>>>>>        Decrement iSize
85946>>>>>>>        For iCount from 0 to iSize
85952>>>>>>>>
85952>>>>>>>            Move sTablesArray[iCount] to sVal
85953>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85955>>>>>>>                Move sVal to sTableSpelledCorrectly
85956>>>>>>>                Move iSize to iCount // We're done!
85957>>>>>>>            End
85957>>>>>>>>
85957>>>>>>>        Loop
85958>>>>>>>>
85958>>>>>>>
85958>>>>>>>        Function_Return sTableSpelledCorrectly
85959>>>>>>>    End_Function
85960>>>>>>>
85960>>>>>>>    // ToDo: This index name function needs to be finished...
85960>>>>>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
85962>>>>>>>        String sSchema sTableName sDriverID
85962>>>>>>>        Boolean bExists
85962>>>>>>>
85962>>>>>>>        Get psDriverID to sDriverID
85963>>>>>>>        Get psSchema to sSchema
85964>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85965>>>>>>>
85965>>>>>>>        Function_Return bExists
85966>>>>>>>    End_Function
85967>>>>>>>
85967>>>>>>>    // Checks if a column/field name exists in a SQL table definition
85967>>>>>>>    // Returns True if it does
85967>>>>>>>    // Sample:
85967>>>>>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
85967>>>>>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
85969>>>>>>>        Integer iNumColumns iColumn
85969>>>>>>>        String sColumn sDriverID
85969>>>>>>>        String[] sColumnsArray
85970>>>>>>>        Boolean bExists bOK
85970>>>>>>>
85970>>>>>>>        Move False to bExists
85971>>>>>>>        Get AutoConnectionIDLogin to bOK
85972>>>>>>>        Get psDriverID to sDriverID
85973>>>>>>>
85973>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
85974>>>>>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
85975>>>>>>>        Decrement iNumColumns
85976>>>>>>>        For iColumn from 0 to iNumColumns
85982>>>>>>>>
85982>>>>>>>            Move sColumnsArray[iColumn] to sColumn
85983>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
85985>>>>>>>                Move True to bExists
85986>>>>>>>                Move iNumColumns to iColumn // We're out of here
85987>>>>>>>            End
85987>>>>>>>>
85987>>>>>>>        Loop
85988>>>>>>>>
85988>>>>>>>
85988>>>>>>>        Function_Return bExists
85989>>>>>>>    End_Function
85990>>>>>>>
85990>>>>>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
85992>>>>>>>        Integer iNumColumns iColumn iDFType iNativeType
85992>>>>>>>        Boolean bOpened bOK
85992>>>>>>>        String sColumnName sNativeTypeName
85992>>>>>>>
85992>>>>>>>        Get AutoConnectionIDLogin to bOK
85993>>>>>>>        Get OpenTableExclusive hTable to bOK
85994>>>>>>>        If (bOK = False) Begin
85996>>>>>>>            Function_Return False
85997>>>>>>>        End
85997>>>>>>>>
85997>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86000>>>>>>>        If (bOpened = False) Begin
86002>>>>>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
86003>>>>>>>>
86003>>>>>>>            Function_Return False
86004>>>>>>>        End
86004>>>>>>>>
86004>>>>>>>
86004>>>>>>>        Move False to Err
86005>>>>>>>
86005>>>>>>>        Structure_Start hTable
86006>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
86009>>>>>>>
86009>>>>>>>            For iColumn from 1 to iNumColumns
86015>>>>>>>>
86015>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
86018>>>>>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
86021>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
86024>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
86027>>>>>>>
86027>>>>>>>                Case Begin
86027>>>>>>>                    Case (iDFType = DF_DATE)
86029>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
86031>>>>>>>                            // Convert datetime to date
86031>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
86034>>>>>>>                        End
86034>>>>>>>>
86034>>>>>>>                        Case Break
86035>>>>>>>                    Case (iDFType = DF_DATETIME)
86038>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
86040>>>>>>>                            // Convert datetime to datetime2
86040>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
86043>>>>>>>                        End
86043>>>>>>>>
86043>>>>>>>                        Case Break
86044>>>>>>>                    Case (iDFType = DF_ASCII)
86047>>>>>>>                        If (iNativeType = SQL_CHAR) Begin
86049>>>>>>>                            // Convert char to varchar
86049>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
86052>>>>>>>                        End
86052>>>>>>>>
86052>>>>>>>                        Case Break
86053>>>>>>>                    Case (iDFType = DF_TEXT)
86056>>>>>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
86058>>>>>>>                            // Convert text to varchar(max)
86058>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
86061>>>>>>>                        End
86061>>>>>>>>
86061>>>>>>>                        Case Break
86062>>>>>>>                    Case (iDFType = DF_BINARY)
86065>>>>>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
86067>>>>>>>                            // Convert image to varbinary(max)
86067>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
86070>>>>>>>                        End
86070>>>>>>>>
86070>>>>>>>                        Case Break
86071>>>>>>>                Case End
86071>>>>>>>            Loop
86072>>>>>>>>
86072>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86073>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86075>>>>>>>
86075>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86076>>>>>>>        Function_Return (Err = False)
86077>>>>>>>    End_Function
86078>>>>>>>
86078>>>>>>>
86078>>>>>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
86078>>>>>>>    // the DbUpdateVersion database revision in.
86078>>>>>>>    // Also pass the file number of the current (embedded?) table number used in development.
86078>>>>>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
86078>>>>>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
86080>>>>>>>        Boolean bOK bOpened
86080>>>>>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
86080>>>>>>>
86080>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
86083>>>>>>>        Get _TableNameOnly sTableName to sTableName
86084>>>>>>>        If (sTableName = "") Begin
86086>>>>>>>            Function_Return False
86087>>>>>>>        End
86087>>>>>>>>
86087>>>>>>>
86087>>>>>>>        // This just creates the table and a "dummy" column.
86087>>>>>>>        Get SqlTableCreate hTable sDriverID to bOK
86088>>>>>>>        If (bOK = False) Begin
86090>>>>>>>            Function_Return False
86091>>>>>>>        End
86091>>>>>>>>
86091>>>>>>>
86091>>>>>>>        Close hTable
86092>>>>>>>        Move False to Err
86093>>>>>>>
86093>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
86094>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
86095>>>>>>>        Move "Decimal" to sDataType
86096>>>>>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
86097>>>>>>>
86097>>>>>>>        // Adds the "sColumnName" passed to the function
86097>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
86098>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
86099>>>>>>>
86099>>>>>>>        // Now we can delete the dummy column:
86099>>>>>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
86100>>>>>>>
86100>>>>>>>        // Finally, we attach to the newly created table.
86100>>>>>>>        If (Err = False) Begin
86102>>>>>>>            Get ApiTableAttachToSQL hTable True to bOK
86103>>>>>>>        End
86103>>>>>>>>
86103>>>>>>>        Open hTable
86105>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86108>>>>>>>
86108>>>>>>>        Function_Return (Err = False and bOK = True and bOpened = True)
86109>>>>>>>    End_Function
86110>>>>>>>
86110>>>>>>>    // Returns a handle to the SQL server associated with the passed driver ID.
86110>>>>>>>    // Pass e.g. the psServer property to determine the current connection server.
86110>>>>>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
86110>>>>>>>    // This handle can be used to obtain attributes about the server, such as default
86110>>>>>>>    // column types.
86110>>>>>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
86112>>>>>>>        Handle hDatabase
86112>>>>>>>        Integer iDriver iServers iCount
86112>>>>>>>        String sValue
86112>>>>>>>
86112>>>>>>>        If (sServer = "") Begin
86114>>>>>>>            Function_Return 0
86115>>>>>>>        End
86115>>>>>>>>
86115>>>>>>>
86115>>>>>>>        Get DriverIndex sDriverID to iDriver
86116>>>>>>>        If (iDriver = 0) Begin
86118>>>>>>>            Function_Return 0
86119>>>>>>>        End
86119>>>>>>>>
86119>>>>>>>
86119>>>>>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
86122>>>>>>>        For iCount from 1 to iServers
86128>>>>>>>>
86128>>>>>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
86131>>>>>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
86133>>>>>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
86136>>>>>>>            End
86136>>>>>>>>
86136>>>>>>>        Loop
86137>>>>>>>>
86137>>>>>>>
86137>>>>>>>        Function_Return hDatabase
86138>>>>>>>    End_Function
86139>>>>>>>
86139>>>>>>>    // Removes all driver identifications (e.g. "MSSQLDRV:MyTable")
86139>>>>>>>    // from the passed filelist.
86139>>>>>>>    // Returns the number of tables affected.
86139>>>>>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
86141>>>>>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
86141>>>>>>>        Integer iRetval
86141>>>>>>>        Handle hTable
86141>>>>>>>
86141>>>>>>>        // We first save the current filelist as the passed filelist name
86141>>>>>>>        // may come from another workspace, to restore it when we're ready.
86141>>>>>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
86144>>>>>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
86147>>>>>>>        Move 0 to hTable
86148>>>>>>>        Move 0 to iRetval
86149>>>>>>>
86149>>>>>>>        Repeat
86149>>>>>>>>
86149>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
86152>>>>>>>            If (hTable <> 0) Begin
86154>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
86157>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86160>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86163>>>>>>>                Move (Uppercase(sRootName)) to sVal
86164>>>>>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
86166>>>>>>>                    // Prefixes:
86166>>>>>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
86167>>>>>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
86168>>>>>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
86169>>>>>>>                    // Suffixes:
86169>>>>>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
86170>>>>>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
86171>>>>>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
86172>>>>>>>
86172>>>>>>>                    // Change Filelist entry:
86172>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
86175>>>>>>>
86175>>>>>>>                    Move (Lowercase(sDisplayName)) to sVal
86176>>>>>>>                    If (sVal contains "dbo.") Begin
86178>>>>>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
86179>>>>>>>
86179>>>>>>>                        // Change Filelist entry:
86179>>>>>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
86182>>>>>>>                    End
86182>>>>>>>>
86182>>>>>>>                    Increment iRetval
86183>>>>>>>                End
86183>>>>>>>>
86183>>>>>>>            End
86183>>>>>>>>
86183>>>>>>>        Until (hTable = 0)
86185>>>>>>>
86185>>>>>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
86188>>>>>>>
86188>>>>>>>        Function_Return iRetval
86189>>>>>>>    End_Function
86190>>>>>>>
86190>>>>>>>    // To open all Sql based tables in Filelist.cfg
86190>>>>>>>    Procedure SqlUtilOpenAllTables
86192>>>>>>>        Handle hTable
86192>>>>>>>        String sRoot sDriverID
86192>>>>>>>        Boolean bOK
86192>>>>>>>
86192>>>>>>>        Move 0 to hTable
86193>>>>>>>        Move "" to sDriverID
86194>>>>>>>        Get AutoConnectionIDLogin to bOK
86195>>>>>>>
86195>>>>>>>        Repeat
86195>>>>>>>>
86195>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
86198>>>>>>>            If (hTable > 0) Begin
86200>>>>>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
86203>>>>>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
86205>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
86208>>>>>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
86210>>>>>>>                        Open hTable
86212>>>>>>>                    End
86212>>>>>>>>
86212>>>>>>>                End
86212>>>>>>>>
86212>>>>>>>            End
86212>>>>>>>>
86212>>>>>>>
86212>>>>>>>        Until (hTable = 0)
86214>>>>>>>    End_Procedure
86215>>>>>>>
86215>>>>>>>//    Function SqlUtilSchemaName Handle hTable Returns String
86215>>>>>>>//        String sRetval sDriverID
86215>>>>>>>//        String sTableName
86215>>>>>>>//        Integer iDbType iIndex
86215>>>>>>>//        Boolean bOK
86215>>>>>>>//
86215>>>>>>>//        Get psDriverID to sDriverID
86215>>>>>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
86215>>>>>>>//        If (hTable = 0 or bOK = False) Begin
86215>>>>>>>//            Function_Return ""
86215>>>>>>>//        End
86215>>>>>>>//
86215>>>>>>>//        Move False to Err
86215>>>>>>>//        Get UtilTableHandleToString hTable to sTableName
86215>>>>>>>//        Get piDbType to iDbType
86215>>>>>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
86215>>>>>>>//        If (iIndex = -1) Begin
86215>>>>>>>//            Function_Return ""
86215>>>>>>>//        End
86215>>>>>>>//
86215>>>>>>>//        Function_Return sRetval
86215>>>>>>>//    End_Function
86215>>>>>>>
86215>>>>>>>    // Checks if the passed Table;
86215>>>>>>>    // 1) Already has a Filelist entry that points to SQL and
86215>>>>>>>    // 2) It has an .int file.
86215>>>>>>>    // If both is True it should already be connected to SQL
86215>>>>>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
86217>>>>>>>        Boolean bExists bRootName
86217>>>>>>>        String sRootName sDataPath
86217>>>>>>>
86217>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86220>>>>>>>        Move (sRootName contains sDriverID) to bRootName
86221>>>>>>>
86221>>>>>>>        Get psDataPathFirstPart to sDataPath
86222>>>>>>>        Get vFolderExists sDataPath to bExists
86223>>>>>>>        If (bExists = False) Begin
86225>>>>>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
86225>>>>>>>            Function_Return False
86226>>>>>>>        End
86226>>>>>>>>
86226>>>>>>>
86226>>>>>>>        Get vFolderFormat sDataPath to sDataPath
86227>>>>>>>        Get _TableNameOnly sRootName to sRootName
86228>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
86229>>>>>>>
86229>>>>>>>        Function_Return (bRootName = True and bExists = True)
86230>>>>>>>    End_Function
86231>>>>>>>
86231>>>>>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
86233>>>>>>>        Boolean bViewTableType bOpen bOK
86233>>>>>>>        Integer iTableCount iNumTables
86233>>>>>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
86233>>>>>>>        Handle hoCliHandler
86233>>>>>>>        tSQLConnection SQLConnection
86233>>>>>>>        tSQLConnection SQLConnection
86233>>>>>>>
86233>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
86236>>>>>>>        If (bOpen = False) Begin
86238>>>>>>>            Get AutoConnectionIDLogin to bOK
86239>>>>>>>            Open hTable
86241>>>>>>>        End
86241>>>>>>>>
86241>>>>>>>
86241>>>>>>>        Get pSQLConnection to SQLConnection
86242>>>>>>>        Get phoCLIHandler to hoCliHandler
86243>>>>>>>        Set psDriverID of hoCliHandler to sDriverID
86244>>>>>>>
86244>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
86247>>>>>>>        Get _TableNameOnly sTableName to sTableName
86248>>>>>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
86251>>>>>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
86252>>>>>>>
86252>>>>>>>        For iTableCount from 1 to iNumTables
86258>>>>>>>>
86258>>>>>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
86259>>>>>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
86260>>>>>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
86262>>>>>>>                Get TableType of hoCliHandler iTableCount to sTableType
86263>>>>>>>                Move iNumTables to iTableCount // We're done.
86264>>>>>>>            End
86264>>>>>>>>
86264>>>>>>>        Loop
86265>>>>>>>>
86265>>>>>>>
86265>>>>>>>        Move (sTableType = "VIEW") to bViewTableType
86266>>>>>>>        If (bOpen = False) Begin
86268>>>>>>>            Close hTable
86269>>>>>>>        End
86269>>>>>>>>
86269>>>>>>>
86269>>>>>>>        Function_Return bViewTableType
86270>>>>>>>    End_Function
86271>>>>>>>
86271>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
86271>>>>>>>    //
86271>>>>>>>    // SQL utility function that returns a database type (string) constant
86271>>>>>>>    // corresponding to the passed iDbType.
86271>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
86273>>>>>>>        String sRetval
86273>>>>>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
86274>>>>>>>        Function_Return sRetval
86275>>>>>>>    End_Function
86276>>>>>>>
86276>>>>>>>    // SQL utility function that returns a database type constant (integer)
86276>>>>>>>    // corresponding to the passed sDbType string constant.
86276>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
86278>>>>>>>        Integer iRetval
86278>>>>>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
86279>>>>>>>        Function_Return iRetval
86280>>>>>>>    End_Function
86281>>>>>>>
86281>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
86281>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
86281>>>>>>>    // the SQL Connection program's grid.
86281>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
86283>>>>>>>        String sRetval
86283>>>>>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
86284>>>>>>>        Function_Return sRetval
86285>>>>>>>    End_Function
86286>>>>>>>
86286>>>>>>>    // Pass a driver name as a string and the function will return
86286>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
86286>>>>>>>    // quite work and always returns "MS SQL Server"
86286>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
86288>>>>>>>        Integer iRetval
86288>>>>>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
86289>>>>>>>        Function_Return iRetval
86290>>>>>>>    End_Function
86291>>>>>>>
86291>>>>>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
86291>>>>>>>    // that "fits" in the max allowed length for table names.
86291>>>>>>>    // Max number of characters allowed for table names;
86291>>>>>>>    // IBM DB2      = 128
86291>>>>>>>    // MS-SQL       = 128
86291>>>>>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
86291>>>>>>>    // MySQL        = 64
86291>>>>>>>    // PostgreSQL   = 64
86291>>>>>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
86293>>>>>>>        String sGUIDName
86293>>>>>>>        Integer iDbType iLength
86293>>>>>>>
86293>>>>>>>        Get piDbType to iDbType
86294>>>>>>>        Move (RandomHexUUID()) to sGUIDName
86295>>>>>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
86296>>>>>>>        Move (Length(sGUIDName)) to iLength
86297>>>>>>>
86297>>>>>>>        Case Begin
86297>>>>>>>            Case (iDbType = EN_DbTypeDB2)
86299>>>>>>>            If (iLength > 128) Begin
86301>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
86302>>>>>>>            End
86302>>>>>>>>
86302>>>>>>>            Case Break
86303>>>>>>>
86303>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
86306>>>>>>>            If (iLength > 128) Begin
86308>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
86309>>>>>>>            End
86309>>>>>>>>
86309>>>>>>>            Case Break
86310>>>>>>>
86310>>>>>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
86313>>>>>>>            If (iLength > 128) Begin
86315>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
86316>>>>>>>            End
86316>>>>>>>>
86316>>>>>>>            Case Break
86317>>>>>>>
86317>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
86320>>>>>>>            If (iLength > 64) Begin
86322>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
86323>>>>>>>            End
86323>>>>>>>>
86323>>>>>>>            Case Break
86324>>>>>>>
86324>>>>>>>            Case (iDbType = EN_DbTypePostgre)
86327>>>>>>>            If (iLength > 64) Begin
86329>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
86330>>>>>>>            End
86330>>>>>>>>
86330>>>>>>>        Case End
86330>>>>>>>
86330>>>>>>>        Function_Return sGUIDName
86331>>>>>>>    End_Function
86332>>>>>>>
86332>>>>>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
86332>>>>>>>    // Pass the memory resource file reference and the filename to be created,
86332>>>>>>>    // including full path.
86332>>>>>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
86334>>>>>>>        String sText
86334>>>>>>>        Integer iCh iSize iArgSize
86334>>>>>>>
86334>>>>>>>        Move ("Resource:" + sMemFileName) to sMemFileName
86335>>>>>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
86336>>>>>>>        Get_Channel_Size iCh to iSize
86337>>>>>>>        Read_Block channel iCh sText iSize
86339>>>>>>>        Send Seq_Close_Channel iCh
86340>>>>>>>
86340>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
86341>>>>>>>            Write channel iCh sText
86343>>>>>>>        Send Seq_Close_Channel iCh
86344>>>>>>>
86344>>>>>>>        // Wait for file to be written to disk.
86344>>>>>>>        Sleep 2
86345>>>>>>>    End_Procedure
86346>>>>>>>
86346>>>>>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
86348>>>>>>>        String sNotNull sRetval sDefaultValue
86348>>>>>>>        Boolean bOK
86348>>>>>>>
86348>>>>>>>        Get IsSQLDriver sDriverID to bOK
86349>>>>>>>        If (bOK = False) Begin
86351>>>>>>>            Function_Return ""
86352>>>>>>>        End
86352>>>>>>>>
86352>>>>>>>
86352>>>>>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
86353>>>>>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
86354>>>>>>>
86354>>>>>>>        Case Begin
86354>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
86356>>>>>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
86357>>>>>>>                Case Break
86358>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
86361>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
86362>>>>>>>                Case Break
86363>>>>>>>            Case (iDbType = EN_dbTypePostgre)
86366>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
86367>>>>>>>                Case Break
86368>>>>>>>            Case (iDbType = EN_dbTypeDB2)
86371>>>>>>>                Move (String(sNotNull))                                     to sRetval
86372>>>>>>>                Case Break
86373>>>>>>>
86373>>>>>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
86373>>>>>>>            // ToDo: We need to look deeper into how Oracle handles NULL
86373>>>>>>>            Case (iDbType = EN_dbTypeOracle)
86376>>>>>>>                Move  ""                                                    to sRetval
86377>>>>>>>                Case Break
86378>>>>>>>
86378>>>>>>>            Case Else
86378>>>>>>>                Move  ""                                                    to sRetval
86379>>>>>>>        Case End
86379>>>>>>>
86379>>>>>>>        Function_Return sRetval
86380>>>>>>>    End_Function
86381>>>>>>>
86381>>>>>>>    // * Dummy function for the Studio's Code Explorer *
86381>>>>>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
86383>>>>>>>        Function_Return False
86384>>>>>>>    End_Function
86385>>>>>>>
86385>>>>>>>    // Enumerate SQL Servers.
86385>>>>>>>    // Pass a driver id. Returns a string array.
86385>>>>>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
86385>>>>>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
86385>>>>>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
86387>>>>>>>        String[] sReturnArray
86388>>>>>>>        Handle hoSQLHandler
86388>>>>>>>        String sServer
86388>>>>>>>        Integer iCount iNumItems iDataSourceType
86388>>>>>>>
86388>>>>>>>        If (num_arguments > 1) Begin
86390>>>>>>>            Move iDatSrcType to iDataSourceType
86391>>>>>>>        End
86391>>>>>>>>
86391>>>>>>>
86391>>>>>>>        Case Begin
86391>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86393>>>>>>>                Get phoMSSQLHandler to hoSQLHandler 
86394>>>>>>>                Get EnumerateServersLocal of hoSQLHandler to iNumItems
86395>>>>>>>                If (iNumItems = 0) Begin
86397>>>>>>>                    Get EnumerateServers of hoSQLHandler to iNumItems 
86398>>>>>>>                End
86398>>>>>>>>
86398>>>>>>>                For iCount from 0 to (iNumItems - 1)
86404>>>>>>>>
86404>>>>>>>                    Get String_Value of hoSQLHandler iCount to sServer
86405>>>>>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
86406>>>>>>>                Loop
86407>>>>>>>>
86407>>>>>>>                Case Break
86408>>>>>>>
86408>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86411>>>>>>>                Get phoDB2SQLHandler to hoSQLHandler
86412>>>>>>>                Send SeedDataSources of hoSQLHandler
86413>>>>>>>                Move 0 to iCount
86414>>>>>>>                Repeat
86414>>>>>>>>
86414>>>>>>>                    Get DataSources of hoSQLHandler to sServer
86415>>>>>>>                    If (sServer <> "") Begin
86417>>>>>>>                        Move (Replace(",", sServer, "")) to sServer
86418>>>>>>>                        Move sServer to sReturnArray[iCount]
86419>>>>>>>                    End
86419>>>>>>>>
86419>>>>>>>                    Increment iCount
86420>>>>>>>                Until (sServer = "")
86422>>>>>>>                Case Break
86423>>>>>>>
86423>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86426>>>>>>>                Get phoODBCSQLHandler to hoSQLHandler
86427>>>>>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
86428>>>>>>>                Move 0 to iCount
86429>>>>>>>                Repeat
86429>>>>>>>>
86429>>>>>>>                    Get DataSources of hoSQLHandler to sServer
86430>>>>>>>                    If (sServer <> "") Begin
86432>>>>>>>                        Move (Replace(",", sServer, ", ")) to sServer
86433>>>>>>>                        Move sServer to sReturnArray[iCount]
86434>>>>>>>                    End
86434>>>>>>>>
86434>>>>>>>                    Increment iCount
86435>>>>>>>                Until (sServer = "")
86437>>>>>>>                Case Break
86438>>>>>>>
86438>>>>>>>            Case Else
86438>>>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
86439>>>>>>>>
86439>>>>>>>        Case End
86439>>>>>>>
86439>>>>>>>        Function_Return sReturnArray
86440>>>>>>>    End_Function
86441>>>>>>>
86441>>>>>>>    // Returns all databases as a string array for the passed driver id.
86441>>>>>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
86443>>>>>>>        String[] sReturnArray
86444>>>>>>>        String sServer sVal
86444>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
86444>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
86445>>>>>>>        tSQLConnection SQLConnection
86445>>>>>>>        tSQLConnection SQLConnection
86445>>>>>>>        Boolean bOK
86445>>>>>>>        Integer iCount iSize
86445>>>>>>>
86445>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86446>>>>>>>        If (bOK = False) Begin
86448>>>>>>>            Function_Return sReturnArray
86449>>>>>>>        End
86449>>>>>>>>
86449>>>>>>>
86449>>>>>>>        Case Begin
86449>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86451>>>>>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
86452>>>>>>>                Case Break
86453>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86456>>>>>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
86457>>>>>>>                Case Break
86458>>>>>>>
86458>>>>>>>            // This is needed to be able to check if a database exists or not.
86458>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86461>>>>>>>                Get _SqlDatabasesArrayODBC to sReturnStructArray
86462>>>>>>>                If (SizeOfArray(sReturnStructArray)) Begin
86464>>>>>>>                    If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
86466>>>>>>>                        // If a FILEDSN: (can only be one database name)
86466>>>>>>>                        Move sReturnStructArray[0].sDatabaseName to sReturnArray[0]
86467>>>>>>>                    End
86467>>>>>>>>
86467>>>>>>>                    Else Begin
86468>>>>>>>                        // Else the DSN's were read from the registry.
86468>>>>>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86469>>>>>>>                        Move SQLConnection.sServer to sServer
86470>>>>>>>                        Move (SizeOfArray(sReturnStructArray)) to iSize
86471>>>>>>>                        Decrement iSize
86472>>>>>>>                        for iCount from 0 to iSize
86478>>>>>>>>
86478>>>>>>>                            Move (sReturnStructArray[iCount].sServerName) to sVal
86479>>>>>>>                            If (Uppercase(sServer) = Uppercase(sVal)) Begin
86481>>>>>>>                                Move sReturnStructArray[iCount].sDatabaseName to sReturnArray[0]
86482>>>>>>>                                Move iSize to iCount // We're done.
86483>>>>>>>                            End
86483>>>>>>>>
86483>>>>>>>                        Loop
86484>>>>>>>>
86484>>>>>>>                    End
86484>>>>>>>>
86484>>>>>>>                End
86484>>>>>>>>
86484>>>>>>>                Case Break
86485>>>>>>>
86485>>>>>>>            Case Else
86485>>>>>>>//                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
86485>>>>>>>        Case End
86485>>>>>>>
86485>>>>>>>        Function_Return sReturnArray
86486>>>>>>>    End_Function
86487>>>>>>>
86487>>>>>>>    
86487>>>>>>>    // *** Database API Functions: ***
86487>>>>>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
86487>>>>>>>    // make changes/updates to the database.
86487>>>>>>>
86487>>>>>>>    // * Dummy function for the Studio's Code Explorer *
86487>>>>>>>    Function API_TABLE_FUNCTIONS Returns Boolean
86489>>>>>>>        Function_Return False
86490>>>>>>>    End_Function
86491>>>>>>>
86491>>>>>>>    // This might not do what you think - Here's what it does:
86491>>>>>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
86491>>>>>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
86491>>>>>>>    // to the SQL table.
86491>>>>>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
86491>>>>>>>    // already exists in SQL.
86491>>>>>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
86491>>>>>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
86491>>>>>>>    // restructuring an existing table.
86491>>>>>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
86493>>>>>>>        Boolean bExists bOpened bOK bSystemFile bUseConnectionID bIsAlias
86493>>>>>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
86493>>>>>>>        Handle hToTable
86493>>>>>>>
86493>>>>>>>        Move True to bUseConnectionID
86494>>>>>>>        If (num_arguments > 1) Begin
86496>>>>>>>            Move bUseConnID to bUseConnectionID
86497>>>>>>>        End
86497>>>>>>>>
86497>>>>>>>
86497>>>>>>>        Get psDriverID to sDriverID
86498>>>>>>>        // If the table doesn't exist on the SQL back-end we do nothing.
86498>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86499>>>>>>>        If (bExists = False) Begin
86501>>>>>>>            Function_Return False
86502>>>>>>>        End
86502>>>>>>>>
86502>>>>>>>
86502>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
86503>>>>>>>
86503>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86504>>>>>>>        If (bOK = False) Begin
86506>>>>>>>            Function_Return False
86507>>>>>>>        End
86507>>>>>>>>
86507>>>>>>>
86507>>>>>>>        // Then we need to check that the function hasn't been called before; which in case
86507>>>>>>>        // we do nothing
86507>>>>>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
86508>>>>>>>        If (bExists = True) Begin
86510>>>>>>>            Function_Return False
86511>>>>>>>        End
86511>>>>>>>>
86511>>>>>>>
86511>>>>>>>        Get psConnectionID     to sConnectionID
86512>>>>>>>        Get psConnectionString to sConnectionString
86513>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
86515>>>>>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
86516>>>>>>>>
86516>>>>>>>            Function_Return False
86517>>>>>>>        End
86517>>>>>>>>
86517>>>>>>>
86517>>>>>>>        Set Private.phCurrentTable to hTable
86518>>>>>>>        Get psSchema to sSchema
86519>>>>>>>        If (sSchema = "") Begin
86521>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
86522>>>>>>>        End
86522>>>>>>>>
86522>>>>>>>
86522>>>>>>>        // If we should use a connection id we need to check it exists;
86522>>>>>>>        // else we create it before attempting creating the table
86522>>>>>>>        If (bUseConnectionID = True) Begin
86524>>>>>>>            Get AutoConnectionIDLogin to bOK
86525>>>>>>>            If (bOk = False) Begin
86527>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
86528>>>>>>>>
86528>>>>>>>                Function_Return False
86529>>>>>>>            End
86529>>>>>>>>
86529>>>>>>>        End
86529>>>>>>>>
86529>>>>>>>
86529>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86532>>>>>>>        Get _TableNameOnly sRootName to sRootName
86533>>>>>>>        If (sRootName = "") Begin
86535>>>>>>>            Function_Return False
86536>>>>>>>        End
86536>>>>>>>>
86536>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
86537>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86540>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86543>>>>>>>
86543>>>>>>>        // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
86543>>>>>>>        //
86543>>>>>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
86543>>>>>>>        // because then the table should not be visible to users.
86543>>>>>>>//        Move (Pos("@", sDisplayName)) to iPos
86543>>>>>>>//        If (iPos <> 1) Begin
86543>>>>>>>//            If (sDisplayName contains ".") Begin
86543>>>>>>>//                Move (Pos(".", sDisplayName)) to iPos
86543>>>>>>>//                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
86543>>>>>>>//                Move (sSchema + "." + sDisplayName)       to sDisplayName
86543>>>>>>>//            End
86543>>>>>>>//            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86543>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
86543>>>>>>>//            End
86543>>>>>>>//        End
86543>>>>>>>
86543>>>>>>>        If (bIsAlias = False) Begin
86545>>>>>>>            Get OpenTableExclusive hTable to bOpened
86546>>>>>>>            If (bOpened = False) Begin
86548>>>>>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
86549>>>>>>>>
86549>>>>>>>                Function_Return False
86550>>>>>>>            End
86550>>>>>>>>
86550>>>>>>>        End
86550>>>>>>>>
86550>>>>>>>
86550>>>>>>>        If (ghoProgressBar <> 0) Begin
86552>>>>>>>            Send DoAdvance of ghoProgressBar
86553>>>>>>>            Set Message_Text of ghoStatusPanel to ""
86554>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
86555>>>>>>>        End
86555>>>>>>>>
86555>>>>>>>        // Note: The hToTable will get changed by the Structure_xxx command...
86555>>>>>>>        Move hTable to hToTable
86556>>>>>>>        Move False to Err
86557>>>>>>>
86557>>>>>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
86557>>>>>>>        // then we do a pseudo .int file change with the "_SqlUtilUpdateIntFile" function. After that we have
86557>>>>>>>        // a proper and updated .int file.
86557>>>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
86560>>>>>>>        Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile True to bOK
86561>>>>>>>
86561>>>>>>>        If (bIsAlias = False) Begin
86563>>>>>>>            Structure_Start hToTable sDriverID
86564>>>>>>>                Set Private.phCurrentTable to hTable
86565>>>>>>>                If (bUseConnectionID = True) Begin
86567>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
86570>>>>>>>                End
86570>>>>>>>>
86570>>>>>>>                Else Begin
86571>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
86574>>>>>>>                End
86574>>>>>>>>
86574>>>>>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
86577>>>>>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
86577>>>>>>>                Move False to Err
86578>>>>>>>                Move 0 to LastErr
86579>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
86580>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86582>>>>>>>            Set Action_Text of ghoStatusPanel to ""
86583>>>>>>>        End
86583>>>>>>>>
86583>>>>>>>
86583>>>>>>>        Move (not(Err)) to bOK
86584>>>>>>>        If (bOK = True) Begin
86586>>>>>>>            // The attributes set above will always trigger an error
86586>>>>>>>            // We also adjust the Filelist entries
86586>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
86589>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86592>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86595>>>>>>>
86595>>>>>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
86595>>>>>>>            Get _SqlUtilUpdateIntFile hTable to bOK
86596>>>>>>>        End
86596>>>>>>>>
86596>>>>>>>
86596>>>>>>>        If (bOK = True) Begin
86598>>>>>>>            Send ResetFillSQLTables
86599>>>>>>>        End
86599>>>>>>>>
86599>>>>>>>        Function_Return (bOK = True)
86600>>>>>>>    End_Function
86601>>>>>>>
86601>>>>>>>    // Sample usage:
86601>>>>>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
86601>>>>>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
86601>>>>>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
86603>>>>>>>        Boolean bOK bIsSQLTable
86603>>>>>>>
86603>>>>>>>        Get AutoConnectionIDLogin to bOK
86604>>>>>>>        Move False to Err
86605>>>>>>>        Get OpenTableExclusive hTable to bOK
86606>>>>>>>        If (bOK = False) Begin
86608>>>>>>>            Function_Return False
86609>>>>>>>        End
86609>>>>>>>>
86609>>>>>>>
86609>>>>>>>        // ToDo: Add to all table change functions!
86609>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
86610>>>>>>>            If (bIsSQLTable = True) Begin
86612>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
86615>>>>>>>            End
86615>>>>>>>>
86615>>>>>>>
86615>>>>>>>        Set Private.phCurrentTable to hTable
86616>>>>>>>        Structure_Start hTable
86617>>>>>>>            Set_Attribute iAttribute of hTable to iValue
86620>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86621>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86623>>>>>>>
86623>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86624>>>>>>>        Function_Return (Err = False)
86625>>>>>>>    End_Function
86626>>>>>>>
86626>>>>>>>    Function ApiTableMoveFileListEntry String sRootName String sLogicalName String sDisplayName Handle hFromSlot Handle hToSlot String sDriverID Returns Boolean
86628>>>>>>>        Boolean bOK
86628>>>>>>>        
86628>>>>>>>        Get ApiTableChangeFileListSlot sRootName sLogicalName sDisplayName hToSlot sDriverID to bOK
86629>>>>>>>        If (bOK = True) Begin
86631>>>>>>>            Get ApiTableChangeFileListSlot "" "" "" hFromSlot sDriverID to bOK
86632>>>>>>>        End
86632>>>>>>>>
86632>>>>>>>        
86632>>>>>>>        Function_Return (bOK = True)
86633>>>>>>>    End_Function
86634>>>>>>>    
86634>>>>>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
86634>>>>>>>    // or to change the filelist slot names.
86634>>>>>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
86636>>>>>>>        String sFileListName
86636>>>>>>>        
86636>>>>>>>        Move False to Err
86637>>>>>>>
86637>>>>>>>        If (ghoProgressBar <> 0) Begin
86639>>>>>>>            Send DoAdvance of ghoProgressBar
86640>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
86641>>>>>>>        End
86641>>>>>>>>
86641>>>>>>>        // If all strings are empty it means that we should remove this entry from filelist.
86641>>>>>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
86643>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
86646>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
86649>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
86652>>>>>>>            Function_Return (Err = False) // And we're done.
86653>>>>>>>        End
86653>>>>>>>>
86653>>>>>>>
86653>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86655>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86655>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
86656>>>>>>>        End
86656>>>>>>>>
86656>>>>>>>//        Else Begin
86656>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86656>>>>>>>//        End
86656>>>>>>>//
86656>>>>>>>//        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86656>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86656>>>>>>>
86656>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86659>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86662>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86665>>>>>>>        
86665>>>>>>>        Function_Return (Err = False)
86666>>>>>>>    End_Function
86667>>>>>>>
86667>>>>>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
86669>>>>>>>        Boolean bOK
86669>>>>>>>
86669>>>>>>>        Get AutoConnectionIDLogin to bOK
86670>>>>>>>        Move False to Err
86671>>>>>>>        Get OpenTableExclusive hTable to bOK
86672>>>>>>>        If (bOK = False) Begin
86674>>>>>>>            Function_Return False
86675>>>>>>>        End
86675>>>>>>>>
86675>>>>>>>
86675>>>>>>>        Set Private.phCurrentTable to hTable
86676>>>>>>>        Structure_Start hTable
86677>>>>>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
86680>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86681>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86683>>>>>>>
86683>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86684>>>>>>>        Function_Return (Err = False)
86685>>>>>>>    End_Function
86686>>>>>>>
86686>>>>>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
86688>>>>>>>        Boolean bOK bIsSQLTable
86688>>>>>>>
86688>>>>>>>        Move False to Err
86689>>>>>>>        Get AutoConnectionIDLogin to bOK
86690>>>>>>>        Open hToTable
86692>>>>>>>        Get OpenTableExclusive hTable to bOK
86693>>>>>>>        If (bOK = False) Begin
86695>>>>>>>            Function_Return False
86696>>>>>>>        End
86696>>>>>>>>
86696>>>>>>>
86696>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
86697>>>>>>>            If (bIsSQLTable = True) Begin
86699>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
86702>>>>>>>            End
86702>>>>>>>>
86702>>>>>>>
86702>>>>>>>        Set Private.phCurrentTable to hTable
86703>>>>>>>        Structure_Start hTable
86704>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
86707>>>>>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
86710>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86711>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86713>>>>>>>
86713>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86714>>>>>>>        Function_Return (Err = False)
86715>>>>>>>    End_Function
86716>>>>>>>
86716>>>>>>>    Procedure ApiTableConvertAllAddException Integer hTable
86718>>>>>>>        Integer[] aTableConvertExceptions
86719>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
86720>>>>>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
86721>>>>>>>        Set paTableConvertExceptions to aTableConvertExceptions
86722>>>>>>>    End_Procedure
86723>>>>>>>
86723>>>>>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
86725>>>>>>>        Integer[] aTableDateCorrectionExceptions
86726>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
86727>>>>>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
86728>>>>>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
86729>>>>>>>    End_Procedure
86730>>>>>>>
86730>>>>>>>    Procedure ApiTableConvertALLToSql
86732>>>>>>>        Integer[] iTablesArray
86733>>>>>>>        Integer iSize iCount
86733>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
86733>>>>>>>        String sDriverID
86733>>>>>>>
86733>>>>>>>        Get psDriverID to sDriverID
86734>>>>>>>        Get pbUseConnectionID to bUseConnectionID
86735>>>>>>>        Get pbToANSI          to bToANSI
86736>>>>>>>        Get pbRecnum          to bRecnum
86737>>>>>>>        Get pbCopyData        to bCopyData
86738>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
86740>>>>>>>            Get pbContinueOnError to bContinueOnError
86741>>>>>>>        End
86741>>>>>>>>
86741>>>>>>>
86741>>>>>>>        Get _AllTablesToConvert to iTablesArray
86742>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
86743>>>>>>>        Set pbVisible   of ghoProgressBarOverall to True
86744>>>>>>>        Set piPosition  of ghoProgressBarOverall to 0
86745>>>>>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
86746>>>>>>>        Set piMaximum   of ghoProgressBarOverall to iSize
86747>>>>>>>
86747>>>>>>>        Decrement iSize
86748>>>>>>>        For iCount from 0 to iSize
86754>>>>>>>>
86754>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
86755>>>>>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
86756>>>>>>>            // Probably the right logic here is to just continue trying to convert every table even
86756>>>>>>>            // if there was an error converting one table...
86756>>>>>>>            //If (bContinueOnError = False and bOK = False) Break
86756>>>>>>>        Loop
86757>>>>>>>>
86757>>>>>>>
86757>>>>>>>    End_Procedure
86758>>>>>>>
86758>>>>>>>    Procedure ApiTableAttachALLToSql
86760>>>>>>>        Integer[] iTablesArray
86761>>>>>>>        Integer iSize iCount
86761>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
86761>>>>>>>        String sDriverID
86761>>>>>>>
86761>>>>>>>        Get psDriverID to sDriverID
86762>>>>>>>        Get pbUseConnectionID to bUseConnectionID
86763>>>>>>>        Get pbToANSI          to bToANSI
86764>>>>>>>        Get pbRecnum          to bRecnum
86765>>>>>>>        Get pbCopyData        to bCopyData
86766>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
86768>>>>>>>            Get pbContinueOnError to bContinueOnError
86769>>>>>>>        End
86769>>>>>>>>
86769>>>>>>>
86769>>>>>>>        Get _AllTablesToConvert to iTablesArray
86770>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
86771>>>>>>>        Decrement iSize
86772>>>>>>>        For iCount from 0 to iSize
86778>>>>>>>>
86778>>>>>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
86779>>>>>>>        Loop
86780>>>>>>>>
86780>>>>>>>
86780>>>>>>>    End_Procedure
86781>>>>>>>
86781>>>>>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
86783>>>>>>>        Handle hToTable hoLogFile
86783>>>>>>>        Boolean bOK bExists bOpened bDAWDriver bContinueOnError bIsAlias
86783>>>>>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
86783>>>>>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
86783>>>>>>>        tSQLConnection SQLConnection
86783>>>>>>>        tSQLConnection SQLConnection
86783>>>>>>>        
86783>>>>>>>        // ToDo: Remake logic. Instead create the new table!?
86783>>>>>>>        Get _UtilTableExists hTable to bExists
86784>>>>>>>        If (bExists = False) Begin
86786>>>>>>>            Set Private.phCurrentTable to hTable
86787>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end.(Or Filelist.cfg contains a driver but the table doesn't exists on the SQL back-end)"
86788>>>>>>>>
86788>>>>>>>            Function_Return False
86789>>>>>>>        End
86789>>>>>>>>
86789>>>>>>>
86789>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
86790>>>>>>>        // If this is an Alias file there is nothing to convert to SQL.
86790>>>>>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
86790>>>>>>>        If (bIsAlias = True) Begin
86792>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86795>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
86797>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86800>>>>>>>                Get psConnectionID to sConnectionID
86801>>>>>>>                Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True False False to bOK
86802>>>>>>>            End
86802>>>>>>>>
86802>>>>>>>            Function_Return True
86803>>>>>>>        End
86803>>>>>>>>
86803>>>>>>>
86803>>>>>>>        Set Private.phCurrentTable to hTable
86804>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
86807>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86810>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86813>>>>>>>
86813>>>>>>>        If (ghoProgressBar <> 0) Begin
86815>>>>>>>            Send DoAdvance of ghoProgressBar
86816>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
86817>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
86818>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
86819>>>>>>>        End
86819>>>>>>>>
86819>>>>>>>
86819>>>>>>>        // Marco Kuipers suggestion;
86819>>>>>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
86819>>>>>>>        // an SQL table; Instead of creating the table in SQL, attach it to the existing
86819>>>>>>>        // SQL table.
86819>>>>>>>        Get _UtilTableIsSql hTable to bOK
86820>>>>>>>        If (bOK = False) Begin
86822>>>>>>>            Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86823>>>>>>>            If (bExists = True) Begin
86825>>>>>>>//                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86825>>>>>>>//                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86825>>>>>>>                Get phoLogFile to hoLogFile
86826>>>>>>>                If (hoLogFile <> 0) Begin          
86828>>>>>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The table was NOT converted to SQL but instead ATTACHED to the existing SQL table.") to sWarning
86829>>>>>>>//                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
86829>>>>>>>                    Send LogError sWarning False
86830>>>>>>>                End
86830>>>>>>>>
86830>>>>>>>                Else Begin
86831>>>>>>>                    Error DFERR_PROGRAM sWarning
86832>>>>>>>>
86832>>>>>>>                End                                                       
86832>>>>>>>>
86832>>>>>>>                Get ApiTableAttachToSql hTable bUseConnectionID to bOK
86833>>>>>>>                Function_Return bOK // We're done (We have attached to an existing SQL table instead of converting it.
86834>>>>>>>            End
86834>>>>>>>>
86834>>>>>>>        End
86834>>>>>>>>
86834>>>>>>>
86834>>>>>>>        // Does the rootname contain a driver?
86834>>>>>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
86836>>>>>>>            // Does the table already exist as an SQL table?
86836>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86837>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
86837>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
86837>>>>>>>            If (bExists = False) Begin
86839>>>>>>>                Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86840>>>>>>>            End
86840>>>>>>>>
86840>>>>>>>            If (bExists = True) Begin
86842>>>>>>>                Set TableName_Text of ghoStatusPanel to ""
86843>>>>>>>                Function_Return False
86844>>>>>>>            End
86844>>>>>>>>
86844>>>>>>>        End
86844>>>>>>>>
86844>>>>>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
86845>>>>>>>
86845>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
86846>>>>>>>//        If (bUseConnectionID = True) Begin
86846>>>>>>>//            Move False to bUseConnectionID
86846>>>>>>>//        End
86846>>>>>>>
86846>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86847>>>>>>>        Move SQLConnection.sSchema           to sSchema
86848>>>>>>>        If (sSchema = "") Begin
86850>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
86851>>>>>>>            Move (Lowercase(sSchema))        to sSchema
86852>>>>>>>        End
86852>>>>>>>>
86852>>>>>>>
86852>>>>>>>        Move SQLConnection.sDatabase         to sDatabase
86853>>>>>>>        Move SQLConnection.sConnectionID     to sConnectionID
86854>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
86855>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
86857>>>>>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
86858>>>>>>>>
86858>>>>>>>            Function_Return False
86859>>>>>>>        End
86859>>>>>>>>
86859>>>>>>>
86859>>>>>>>        Get AutoConnectionIDLogin to bOK
86860>>>>>>>        Open hTable
86862>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86865>>>>>>>        If (bOpened = False) Begin
86867>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
86868>>>>>>>>
86868>>>>>>>            Function_Return False
86869>>>>>>>        End
86869>>>>>>>>
86869>>>>>>>
86869>>>>>>>        If (ghoProgressBar <> 0) Begin
86871>>>>>>>            Send DoAdvance of ghoProgressBar
86872>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
86873>>>>>>>        End
86873>>>>>>>>
86873>>>>>>>
86873>>>>>>>        Move 0 to hToTable
86874>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
86875>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
86876>>>>>>>
86876>>>>>>>        Case Begin
86876>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86878>>>>>>>                Case Break
86879>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86882>>>>>>>                Case Break
86883>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86886>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
86887>>>>>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
86888>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
86889>>>>>>>                Case Break
86890>>>>>>>            Case (sDriverID = DATAFLEX_ID)
86893>>>>>>>                Case Break
86894>>>>>>>            Case Else
86894>>>>>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
86895>>>>>>>>
86895>>>>>>>                Case Break
86896>>>>>>>        Case End
86896>>>>>>>
86896>>>>>>>        Move False to Err
86897>>>>>>>
86897>>>>>>>        Structure_Start hToTable sDriverID
86898>>>>>>>            Structure_Copy hTable to hToTable
86899>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
86902>>>>>>>
86902>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
86904>>>>>>>                If (bUseConnectionID = True) Begin
86906>>>>>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to (CS_DFCONNID + "=" + sConnectionID)
86909>>>>>>>                End
86909>>>>>>>>
86909>>>>>>>                Else Begin
86910>>>>>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to sConnectionString
86913>>>>>>>                End
86913>>>>>>>>
86913>>>>>>>
86913>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE of hToTable to bRecnum
86916>>>>>>>
86916>>>>>>>                If (sSchema <> "") Begin
86918>>>>>>>                    Set_Attribute DF_FILE_OWNER of hToTable to sSchema
86921>>>>>>>                End
86921>>>>>>>>
86921>>>>>>>
86921>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
86923>>>>>>>                    If (sLongTableSpace <> "") Begin
86925>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
86928>>>>>>>                    End
86928>>>>>>>>
86928>>>>>>>                    If (sBaseTableSpace <> "") Begin
86930>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
86933>>>>>>>                    End
86933>>>>>>>>
86933>>>>>>>                    If (sIndexTableSpace <> "") Begin
86935>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
86938>>>>>>>                    End
86938>>>>>>>>
86938>>>>>>>                End
86938>>>>>>>>
86938>>>>>>>            End
86938>>>>>>>>
86938>>>>>>>
86938>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86939>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86941>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86942>>>>>>>
86942>>>>>>>        Move (not(Err)) to bOK
86943>>>>>>>
86943>>>>>>>        If (bOK = True and bCopyData = True) Begin
86945>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
86946>>>>>>>
86946>>>>>>>            If (ghoDbUpdateHandler > 0) Begin
86948>>>>>>>                Get pbContinueOnError to bContinueOnError
86949>>>>>>>            End
86949>>>>>>>>
86949>>>>>>>            // If the data copy failed we will keep the newly created SQL table but
86949>>>>>>>            // rename it by adding a GUID to the end of the table name
86949>>>>>>>            // - or as much as "fit" because different SQL back-ends have
86949>>>>>>>            // different rules how long a table name can be.
86949>>>>>>>            // The new table will probably contain data but something went
86949>>>>>>>            // wrong while converting the data from embedded to SQL.
86949>>>>>>>            If (bOK = False and bContinueOnError = False) Begin
86951>>>>>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86952>>>>>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86953>>>>>>>                Error DFERR_PROGRAM ("Copying of" * sLogicalName * " data failed due to bad data. Either duplicate records and/or bad e.g Date/DateTime data. The SQL table was renamed to:" * String(sGUIDName) * "and its Filelist.cfg entry was NOT changed.")
86954>>>>>>>>
86954>>>>>>>            End
86954>>>>>>>>
86954>>>>>>>        End
86954>>>>>>>>
86954>>>>>>>
86954>>>>>>>        // This must be after copying data...
86954>>>>>>>        If (Err = False) Begin
86956>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86959>>>>>>>            // It seems the Studio does not do this any more, so commented out.
86959>>>>>>>            // We also adjust the display name by prefixing it by the schema name;
86959>>>>>>>            //            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86959>>>>>>>            //                // The max length for the display_name is 31 characters...
86959>>>>>>>            //                If (Length(sSchema + "." + sDisplayName) < 31) Begin
86959>>>>>>>            //                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
86959>>>>>>>            //                End
86959>>>>>>>            //            End
86959>>>>>>>        End
86959>>>>>>>>
86959>>>>>>>
86959>>>>>>>        Close hTable
86960>>>>>>>        Move (not(Err)) to bOK
86961>>>>>>>        If (bOK = True) Begin
86963>>>>>>>            Send ResetFillSQLTables
86964>>>>>>>        End
86964>>>>>>>>
86964>>>>>>>        Function_Return bOK
86965>>>>>>>    End_Function
86966>>>>>>>
86966>>>>>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
86966>>>>>>>    // It will first drop all indicies, copy the data and then recreate indicies.
86966>>>>>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
86966>>>>>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
86968>>>>>>>        Boolean bOpened bOK
86968>>>>>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
86968>>>>>>>        String sErrorFile sEmpty sPath
86968>>>>>>>
86968>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
86971>>>>>>>        Get AutoConnectionIDLogin to bOK
86972>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
86974>>>>>>>            Send IncreaseSortBufferSize
86975>>>>>>>//            Send SetAllIndexesToBatch hToTable
86975>>>>>>>        End
86975>>>>>>>>
86975>>>>>>>
86975>>>>>>>        Move False to Err
86976>>>>>>>        Open sPhysicalName as hToTable
86978>>>>>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
86981>>>>>>>        If (bOpened = False) Begin
86983>>>>>>>            Function_Return False
86984>>>>>>>        End
86984>>>>>>>>
86984>>>>>>>
86984>>>>>>>        If (ghoStatusPanel <> 0) Begin
86986>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
86987>>>>>>>            Set piMinimum of ghoProgressBar to 0
86988>>>>>>>            Set piMaximum of ghoProgressBar to 100 // 100%
86989>>>>>>>        End
86989>>>>>>>>
86989>>>>>>>
86989>>>>>>>        Move "" to sEmpty
86990>>>>>>>        Move False to Err
86991>>>>>>>        Move True to bOK
86992>>>>>>>        Set Private.phCurrentTable to hToTable
86993>>>>>>>
86993>>>>>>>        // No need to get the record identifier
86993>>>>>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False
86996>>>>>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86999>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87001>>>>>>>            // Remove all indices to speed up copying of data:
87001>>>>>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
87006>>>>>>>            If (iRetval <> 0) Begin       
87008>>>>>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
87009>>>>>>>>
87009>>>>>>>                Close hToTable
87010>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87013>>>>>>>                Function_Return False
87014>>>>>>>            End
87014>>>>>>>>
87014>>>>>>>        End
87014>>>>>>>>
87014>>>>>>>
87014>>>>>>>        Move (sRootName + ".err") to sErrorFile
87015>>>>>>>        Move 0 to iIndex
87016>>>>>>>        Move False to Err
87017>>>>>>>
87017>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
87019>>>>>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
87022>>>>>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
87027>>>>>>>            If (iRetval <> 0) Begin
87029>>>>>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
87030>>>>>>>>
87030>>>>>>>                Close hToTable
87031>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87034>>>>>>>                Function_Return False
87035>>>>>>>            End
87035>>>>>>>>
87035>>>>>>>        End
87035>>>>>>>>
87035>>>>>>>        Else Begin
87036>>>>>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
87039>>>>>>>        End
87039>>>>>>>>
87039>>>>>>>
87039>>>>>>>        If (Err = False) Begin
87041>>>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
87042>>>>>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
87043>>>>>>>        End
87043>>>>>>>>
87043>>>>>>>
87043>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87045>>>>>>>            // Recreate indices:
87045>>>>>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
87050>>>>>>>            If (iRetval <> 0) Begin
87052>>>>>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
87053>>>>>>>>
87053>>>>>>>                Close hToTable
87054>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87057>>>>>>>                Function_Return False
87058>>>>>>>            End
87058>>>>>>>>
87058>>>>>>>        End
87058>>>>>>>>
87058>>>>>>>
87058>>>>>>>        Close hToTable
87059>>>>>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87062>>>>>>>
87062>>>>>>>        If (bOK = True) Begin
87064>>>>>>>            Move (not(Err)) to bOK
87065>>>>>>>        End
87065>>>>>>>>
87065>>>>>>>
87065>>>>>>>        If (ghoStatusPanel <> 0) Begin
87067>>>>>>>            Set TableName_Text of ghoStatusPanel to ""
87068>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
87069>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
87070>>>>>>>        End
87070>>>>>>>>
87070>>>>>>>
87070>>>>>>>        Function_Return (bOK = True)
87071>>>>>>>    End_Function
87072>>>>>>>
87072>>>>>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
87072>>>>>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
87072>>>>>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
87074>>>>>>>        Handle hFile
87074>>>>>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
87074>>>>>>>        Integer iIdentityType iDataType iDbType iCount iSize
87074>>>>>>>        Boolean bOk bExists bSqlDriver bDeleteDummy bExistsInFilelist bSysFile
87074>>>>>>>        tSQLConnection SQLConnection
87074>>>>>>>        tSQLConnection SQLConnection
87074>>>>>>>        tAPIColumn[] aColumns
87074>>>>>>>        tAPIColumn[] aColumns
87075>>>>>>>        tColumnType ColumnType
87075>>>>>>>        tColumnType ColumnType
87075>>>>>>>
87075>>>>>>>        // First check if the passed filenumber already exists; in case we do nothing
87075>>>>>>>        Get _UtilTableExists hTable to bOk
87076>>>>>>>        If (bOk = True) Begin
87078>>>>>>>            Function_Return False
87079>>>>>>>        End
87079>>>>>>>>
87079>>>>>>>
87079>>>>>>>        Set Private.phCurrentTable to hTable
87080>>>>>>>        Move sLogicalName to sTableName
87081>>>>>>>        If (ghoProgressBar <> 0) Begin
87083>>>>>>>            Send DoAdvance of ghoProgressBar
87084>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
87085>>>>>>>        End
87085>>>>>>>>
87085>>>>>>>
87085>>>>>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
87086>>>>>>>        Get psDriverID to sDriverID
87087>>>>>>>        Get IsSQLDriver sDriverID to bSqlDriver
87088>>>>>>>        Get piDbType to iDbType
87089>>>>>>>
87089>>>>>>>        // If no columns passed in, we need to create a "dummy" column
87089>>>>>>>        Move False to bDeleteDummy
87090>>>>>>>        If (Num_Arguments = 8) Begin
87092>>>>>>>            Move aColumnIn to aColumns
87093>>>>>>>        End
87093>>>>>>>>
87093>>>>>>>        If ((SizeOfArray(aColumns)) = 0) Begin
87095>>>>>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
87096>>>>>>>            Move ColumnType.iSQLType to iDataType
87097>>>>>>>            If (bRecnum = False) Begin
87099>>>>>>>                Move C_tAPIColumn_Identity to iIdentityType
87100>>>>>>>            End
87100>>>>>>>>
87100>>>>>>>            Else Begin
87101>>>>>>>                Move C_tAPIColumn_None     to iIdentityType
87102>>>>>>>            End
87102>>>>>>>>
87102>>>>>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
87103>>>>>>>            Move True to bDeleteDummy
87104>>>>>>>        End
87104>>>>>>>>
87104>>>>>>>
87104>>>>>>>        // If columns have been passed as an array we need to check if an identity column
87104>>>>>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
87104>>>>>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
87104>>>>>>>        // two identity columns and SQL doesn't like that and throws an error.
87104>>>>>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
87106>>>>>>>            Move (SizeOfArray(aColumns)) to iSize
87107>>>>>>>            Decrement iSize
87108>>>>>>>            for iCount from 0 to iSize
87114>>>>>>>>
87114>>>>>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
87116>>>>>>>                    Move False to bRecnum
87117>>>>>>>                    Move iSize to iCount
87118>>>>>>>                End
87118>>>>>>>>
87118>>>>>>>            Loop
87119>>>>>>>>
87119>>>>>>>        End
87119>>>>>>>>
87119>>>>>>>
87119>>>>>>>        // If this is a SQL based driver we also check if the table exists
87119>>>>>>>        // in the SQL back end; in case we do nothing.
87119>>>>>>>        If (bSqlDriver = True) Begin
87121>>>>>>>            // Get all connection properties
87121>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
87122>>>>>>>            Move SQLConnection.sSchema to sSchema
87123>>>>>>>            If (sSchema = "") Begin
87125>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
87126>>>>>>>            End
87126>>>>>>>>
87126>>>>>>>
87126>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
87127>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
87127>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
87127>>>>>>>            If (bExists = False) Begin
87129>>>>>>>                Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
87130>>>>>>>            End
87130>>>>>>>>
87130>>>>>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
87130>>>>>>>            // we will just add it to Filelist.cfg
87130>>>>>>>            If (bExists = True) Begin
87132>>>>>>>                If (bExistsInFilelist = False) Begin
87134>>>>>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
87136>>>>>>>                        Move (sDriverID + ":" + sRootName) to sRootName
87137>>>>>>>                    End
87137>>>>>>>>
87137>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87140>>>>>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87143>>>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87146>>>>>>>                    Move False to bSysFile
87147>>>>>>>                    Get _SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile False to bOK
87148>>>>>>>                End
87148>>>>>>>>
87148>>>>>>>                Function_Return False
87149>>>>>>>            End
87149>>>>>>>>
87149>>>>>>>        End
87149>>>>>>>>
87149>>>>>>>
87149>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
87150>>>>>>>        If (num_arguments > 6) Begin
87152>>>>>>>            If (bANSI = False) Begin
87154>>>>>>>                Move CS_OEM_Txt to sANSI_OEM
87155>>>>>>>            End
87155>>>>>>>>
87155>>>>>>>        End
87155>>>>>>>>
87155>>>>>>>
87155>>>>>>>        Move False to Err
87156>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
87158>>>>>>>            Move sRootName to sPhysicalFile
87159>>>>>>>        End
87159>>>>>>>>
87159>>>>>>>
87159>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87161>>>>>>>            Move SQLConnection.sConnectionID to sConnectionID
87162>>>>>>>
87162>>>>>>>            // If DAW driver and we should use a connection id we need to
87162>>>>>>>            // check if the connection ID exists; else we create it before attempting creating the table
87162>>>>>>>            If (bUseConnectionID = True) Begin
87164>>>>>>>                Get IsConnectionID sConnectionID sDriverID to bExists
87165>>>>>>>                If (bExists = False) Begin
87167>>>>>>>                    Get AutoSetConnectionID sConnectionID to bOk
87168>>>>>>>                    If (bOk = False) Begin
87170>>>>>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
87171>>>>>>>>
87171>>>>>>>                        Function_Return False
87172>>>>>>>                    End
87172>>>>>>>>
87172>>>>>>>                End
87172>>>>>>>>
87172>>>>>>>            End
87172>>>>>>>>
87172>>>>>>>
87172>>>>>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
87174>>>>>>>                Move (sTableName + ".int") to sPhysicalFile
87175>>>>>>>            End
87175>>>>>>>>
87175>>>>>>>            Else Begin
87176>>>>>>>                Move (sRootName + ".int") to sPhysicalFile
87177>>>>>>>            End
87177>>>>>>>>
87177>>>>>>>            Move (Uppercase(sDisplayName)) to sVal
87178>>>>>>>//            If (not(sVal contains (sSchema + "."))) Begin
87178>>>>>>>//                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
87178>>>>>>>//            End
87178>>>>>>>        End
87178>>>>>>>>
87178>>>>>>>        Move False to Err
87179>>>>>>>        Move 0 to hFile
87180>>>>>>>
87180>>>>>>>        Structure_Start hFile sDriverID
87181>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
87183>>>>>>>                If (bUseConnectionID = True) Begin
87185>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
87188>>>>>>>                End
87188>>>>>>>>
87188>>>>>>>                Else Begin
87189>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
87192>>>>>>>                End
87192>>>>>>>>
87192>>>>>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
87195>>>>>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
87198>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
87201>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
87204>>>>>>>
87204>>>>>>>                If (sSchema <> "") Begin
87206>>>>>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
87209>>>>>>>                End
87209>>>>>>>>
87209>>>>>>>
87209>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
87211>>>>>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
87213>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
87216>>>>>>>                    End
87216>>>>>>>>
87216>>>>>>>                End
87216>>>>>>>>
87216>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
87218>>>>>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
87220>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
87223>>>>>>>                    End
87223>>>>>>>>
87223>>>>>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
87225>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
87228>>>>>>>                    End
87228>>>>>>>>
87228>>>>>>>                End
87228>>>>>>>>
87228>>>>>>>            End
87228>>>>>>>>
87228>>>>>>>
87228>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
87231>>>>>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
87232>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87233>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87235>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87236>>>>>>>
87236>>>>>>>        Move (not(Err)) to bOK
87237>>>>>>>        If (bOk = True) Begin
87239>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
87241>>>>>>>                Move (sDriverID + ":" + sRootName) to sRootName
87242>>>>>>>            End
87242>>>>>>>>
87242>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87245>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87248>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87251>>>>>>>
87251>>>>>>>            // Lastly we remove the temporary column we created above, if all went well.
87251>>>>>>>            If (bDeleteDummy) Begin
87253>>>>>>>                Get ApiColumnRemove hTable "temp" to bOk
87254>>>>>>>            End
87254>>>>>>>>
87254>>>>>>>        End
87254>>>>>>>>
87254>>>>>>>
87254>>>>>>>        If (bOk = True and sDriverID <> DATAFLEX_ID) Begin
87256>>>>>>>            Send ResetFillSQLTables
87257>>>>>>>        End
87257>>>>>>>>
87257>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
87258>>>>>>>        Close hTable
87259>>>>>>>        Function_Return bOK
87260>>>>>>>    End_Function
87261>>>>>>>
87261>>>>>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
87263>>>>>>>        Move False to Err
87264>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
87267>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
87270>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
87273>>>>>>>
87273>>>>>>>        Function_Return (Err = False)
87274>>>>>>>    End_Function
87275>>>>>>>
87275>>>>>>>    // ToDo: Needs to be revised
87275>>>>>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
87277>>>>>>>        Handle hTable
87277>>>>>>>        String sDEFName sDataPath
87277>>>>>>>        Boolean bExists
87277>>>>>>>
87277>>>>>>>        // Do nothing if MSSQL Driver.
87277>>>>>>>//        Get IsMSSQLDriver to bExists
87277>>>>>>>//        If (bExists = True) Begin
87277>>>>>>>//            Procedure_Return
87277>>>>>>>//        End
87277>>>>>>>
87277>>>>>>>        Get psDataPathFirstPart to sDataPath
87278>>>>>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
87279>>>>>>>        If (bExists = True) Begin
87281>>>>>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
87281>>>>>>>            // still be missing from the filelist and needs to be added.
87281>>>>>>>            Get _UtilTableNumberIsInUse iFilelistSlot to bExists
87282>>>>>>>            If (bExists = True) Begin
87284>>>>>>>                Procedure_Return
87285>>>>>>>            End
87285>>>>>>>>
87285>>>>>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
87285>>>>>>>            Else Begin
87286>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
87289>>>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
87292>>>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
87295>>>>>>>                Procedure_Return
87296>>>>>>>            End
87296>>>>>>>>
87296>>>>>>>        End
87296>>>>>>>>
87296>>>>>>>
87296>>>>>>>        Move (sPath + sFileName + ".def") to sDEFName
87297>>>>>>>        Move 0 to hTable
87298>>>>>>>        Move False to Err
87299>>>>>>>
87299>>>>>>>        Structure_Start hTable DATAFLEX_ID
87300>>>>>>>            Load_Def sDEFName Onto hTable
87301>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
87304>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87305>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87307>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87308>>>>>>>
87308>>>>>>>        Move iFilelistSlot to hTable
87309>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
87312>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
87315>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
87318>>>>>>>
87318>>>>>>>    End_Procedure
87319>>>>>>>
87319>>>>>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
87321>>>>>>>        Boolean bTmp bErr bOK
87321>>>>>>>        String sTableName sDisplayName sFileName
87321>>>>>>>
87321>>>>>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
87321>>>>>>>        Move Err to bTmp
87322>>>>>>>        Move False to Err
87323>>>>>>>
87323>>>>>>>        Get AutoConnectionIDLogin to bOK
87324>>>>>>>        // First get the info for the current filelist slot:
87324>>>>>>>        Open iFromFileSlot
87326>>>>>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
87329>>>>>>>        If (bOK = True) Begin
87331>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
87334>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
87337>>>>>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
87340>>>>>>>
87340>>>>>>>            //...then move it.
87340>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
87343>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
87346>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
87349>>>>>>>
87349>>>>>>>            //...and finally remove the old filelist values.
87349>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
87352>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
87355>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
87358>>>>>>>        End
87358>>>>>>>>
87358>>>>>>>        Close iFromFileSlot
87359>>>>>>>
87359>>>>>>>        Move Err to bErr
87360>>>>>>>        Move bTmp to Err
87361>>>>>>>        Function_Return (bErr = False)
87362>>>>>>>    End_Function
87363>>>>>>>
87363>>>>>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
87365>>>>>>>        Handle hTable
87365>>>>>>>        Boolean bOK
87365>>>>>>>        String sDriverID
87365>>>>>>>
87365>>>>>>>        Get _UtilTableExists hTableFrom to bOK
87366>>>>>>>        If (bOK = False) Begin
87368>>>>>>>            Set Private.phCurrentTable to hTableFrom
87369>>>>>>>            Error DFERR_PROGRAM ("Func: ApiTableRelate. From Table:" * String(hTableFrom) * "exists in Filelist.cfg but not on disk or SQL back-end.")
87370>>>>>>>>
87370>>>>>>>            Function_Return False
87371>>>>>>>        End
87371>>>>>>>>
87371>>>>>>>
87371>>>>>>>        Get _UtilTableExists hTableTo to bOK
87372>>>>>>>        If (bOK = False) Begin
87374>>>>>>>            Set Private.phCurrentTable to hTableTo
87375>>>>>>>            Error DFERR_PROGRAM ("Func: ApiTableRelate. To Table:" * String(hTableTo) * "exists in Filelist.cfg but not on disk or SQL back-end.")
87376>>>>>>>>
87376>>>>>>>            Function_Return False
87377>>>>>>>        End
87377>>>>>>>>
87377>>>>>>>
87377>>>>>>>        Get AutoConnectionIDLogin to bOK
87378>>>>>>>        Get UtilTableOpen hTableFrom "" DF_EXCLUSIVE to bOK
87379>>>>>>>        If (bOK = False) Begin
87381>>>>>>>            Function_Return False
87382>>>>>>>        End
87382>>>>>>>>
87382>>>>>>>
87382>>>>>>>        Move False to Err
87383>>>>>>>        Open hTableTo
87385>>>>>>>
87385>>>>>>>        Move hTableFrom to hTable
87386>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87389>>>>>>>        Set Private.phCurrentTable to hTable
87390>>>>>>>
87390>>>>>>>        Structure_Start hTable sDriverID
87391>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
87394>>>>>>>            If (iColumnTo <> 0) Begin
87396>>>>>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
87399>>>>>>>            End
87399>>>>>>>>
87399>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87400>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87402>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87403>>>>>>>
87403>>>>>>>        If (hTableTo > 0) Begin
87405>>>>>>>            Close hTableTo
87406>>>>>>>        End
87406>>>>>>>>
87406>>>>>>>
87406>>>>>>>        Function_Return (Err = False)
87407>>>>>>>    End_Function
87408>>>>>>>
87408>>>>>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
87408>>>>>>>    Function ApiTableRemove Handle hTable Returns Boolean
87410>>>>>>>        String sTableName sDriverID
87410>>>>>>>        Boolean bOk
87410>>>>>>>        String sDataPath
87410>>>>>>>
87410>>>>>>>        Get AutoConnectionIDLogin to bOK
87411>>>>>>>        Move False to Err
87412>>>>>>>        Get psDriverID to sDriverID
87413>>>>>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
87414>>>>>>>        If (sTableName = "") Begin
87416>>>>>>>            Function_Return False
87417>>>>>>>        End
87417>>>>>>>>
87417>>>>>>>
87417>>>>>>>        Set Private.phCurrentTable to hTable
87418>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
87419>>>>>>>        Delete_db sTableName
87420>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
87421>>>>>>>
87421>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87423>>>>>>>//            Get SqlTableRemoveByTableName sTableName to bOk  // We don't have to do this because the database is already removed by 'delete_db' above
87423>>>>>>>            Get psDataPathFirstPart to sDataPath
87424>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
87425>>>>>>>        End
87425>>>>>>>>
87425>>>>>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
87425>>>>>>>        If (hTable <> 0) Begin
87427>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
87430>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
87433>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
87436>>>>>>>        End
87436>>>>>>>>
87436>>>>>>>
87436>>>>>>>        If (hTable <> 0 and sDriverID <> DATAFLEX_ID) Begin
87438>>>>>>>            Send ResetFillSQLTables
87439>>>>>>>        End
87439>>>>>>>>
87439>>>>>>>        Close hTable
87440>>>>>>>        Function_Return (hTable <> 0)
87441>>>>>>>    End_Function
87442>>>>>>>
87442>>>>>>>    Function ApiTableRemoveRelation Handle hTableFrom Integer iColumn Returns Boolean
87444>>>>>>>        Handle hTable
87444>>>>>>>        Boolean bOK
87444>>>>>>>
87444>>>>>>>        Get AutoConnectionIDLogin to bOK
87445>>>>>>>        Move False to Err
87446>>>>>>>        Open hTableFrom Mode DF_EXCLUSIVE
87448>>>>>>>        Move hTableFrom to hTable
87449>>>>>>>
87449>>>>>>>        Structure_Start hTable
87450>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
87453>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87454>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87456>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87457>>>>>>>
87457>>>>>>>        Close hTableFrom
87458>>>>>>>        Function_Return (Err = False)
87459>>>>>>>    End_Function
87460>>>>>>>
87460>>>>>>>    Function ApiTableRename Handle hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
87462>>>>>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
87462>>>>>>>        Boolean bOK bExists bOpened
87462>>>>>>>        tAPITableNameInfo APITableNameInfo
87462>>>>>>>        tAPITableNameInfo APITableNameInfo
87462>>>>>>>
87462>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
87465>>>>>>>        If (bOpened = False) Begin
87467>>>>>>>            Get OpenTableExclusive hTable to bOpened
87468>>>>>>>            If (bOpened = False) Begin
87470>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
87471>>>>>>>                Function_Return False
87472>>>>>>>            End
87472>>>>>>>>
87472>>>>>>>        End
87472>>>>>>>>
87472>>>>>>>
87472>>>>>>>        Set Private.phCurrentTable to hTable
87473>>>>>>>        Move hTable         to APITableNameInfo.iTableNumber
87474>>>>>>>        Move sRootName      to APITableNameInfo.sRootName
87475>>>>>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
87476>>>>>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
87477>>>>>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfo to bExists
87478>>>>>>>        If (bExists = True) Begin
87480>>>>>>>            Function_Return True
87481>>>>>>>        End
87481>>>>>>>>
87481>>>>>>>
87481>>>>>>>        Set Private.phCurrentTable to hTable
87482>>>>>>>        Move False to Err
87483>>>>>>>        Get psDataPathFirstPart to sDataPath
87484>>>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
87487>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
87490>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
87493>>>>>>>
87493>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87496>>>>>>>        Close hTable
87497>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
87499>>>>>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
87500>>>>>>>            If (bExists = True) Begin
87502>>>>>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
87504>>>>>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
87507>>>>>>>                    // We need a short break here before attempting to delete the physical old files or Windows
87507>>>>>>>                    // might report "File in use..." and the deletion will fail.
87507>>>>>>>                    Sleep 2
87508>>>>>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
87509>>>>>>>                End
87509>>>>>>>>
87509>>>>>>>            End
87509>>>>>>>>
87509>>>>>>>        End
87509>>>>>>>>
87509>>>>>>>
87509>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87511>>>>>>>            If (not(sPhysicalName contains ".")) Begin
87513>>>>>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
87514>>>>>>>            End
87514>>>>>>>>
87514>>>>>>>
87514>>>>>>>            // Change the table name in the .int file to the new table new:
87514>>>>>>>            Get _UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
87515>>>>>>>            If (bOK = False) Begin
87517>>>>>>>                Function_Return False
87518>>>>>>>            End
87518>>>>>>>>
87518>>>>>>>
87518>>>>>>>            // Change table name at the SQL side:
87518>>>>>>>            Get psSchema to sSchema
87519>>>>>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK
87520>>>>>>>
87520>>>>>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
87521>>>>>>>            // Remove cache file and Rename the physical file names:
87521>>>>>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK
87522>>>>>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
87523>>>>>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
87524>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
87525>>>>>>>
87525>>>>>>>            // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
87525>>>>>>>//            If (not(sDisplayName contains ".")) Begin
87525>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
87525>>>>>>>//            End
87525>>>>>>>        End
87525>>>>>>>>
87525>>>>>>>
87525>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87528>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87531>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87534>>>>>>>
87534>>>>>>>        Function_Return (Err = False)
87535>>>>>>>    End_Function
87536>>>>>>>
87536>>>>>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
87538>>>>>>>        Move False to Err
87539>>>>>>>        Set Private.phCurrentTable to hTable
87540>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87543>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87546>>>>>>>
87546>>>>>>>        Function_Return (Err = False)
87547>>>>>>>    End_Function
87548>>>>>>>
87548>>>>>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
87550>>>>>>>        Handle hTable
87550>>>>>>>        String sTableName
87550>>>>>>>        String sDriverIDFrom sDriverIDTo sLogicalNameTo
87550>>>>>>>        Integer iDbType
87550>>>>>>>        Boolean bOk bOpened bApiTableUpdateAuto bLogicalNameOK bSysfile
87550>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
87550>>>>>>>        Boolean bIsSame bFilelistError bIsAliasFrom bIsSQLTableFrom bIsSQLTableTo
87550>>>>>>>        tSQLConnection SQLConnection
87550>>>>>>>        tSQLConnection SQLConnection
87550>>>>>>>        tAPITable      APITableFrom APITableTo
87550>>>>>>>        tAPITable      APITableFrom APITableTo
87550>>>>>>>        tColumnType    ColumnType
87550>>>>>>>        tColumnType    ColumnType
87550>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
87550>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
87551>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
87551>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
87552>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
87552>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
87553>>>>>>>
87553>>>>>>>        // We don't allow changes to the framework's DbVersion table.
87553>>>>>>>        If (Lowercase(sTableName) = "dbversion") Begin
87555>>>>>>>            Function_Return False
87556>>>>>>>        End
87556>>>>>>>>
87556>>>>>>>        
87556>>>>>>>        Move True to bOk
87557>>>>>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
87558>>>>>>>        Get piDbType                            to iDbType
87559>>>>>>>        Get pbRecnum                            to bRecnum
87560>>>>>>>        Get pbToANSI                            to bToANSI
87561>>>>>>>        Get pbCopyData                          to bCopyData
87562>>>>>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
87563>>>>>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
87564>>>>>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
87565>>>>>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase
87566>>>>>>>        Get pbUseConnectionID                   to bUseConnectionID
87567>>>>>>>
87567>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
87568>>>>>>>        Set Private.phCurrentTable              to hTable
87569>>>>>>>        Get _UtilTableExists  hTable            to bTableExists
87570>>>>>>>
87570>>>>>>>        If (ghoProgressBar <> 0) Begin
87572>>>>>>>            Send DoAdvance of ghoProgressBar
87573>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
87574>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
87575>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
87576>>>>>>>        End
87576>>>>>>>>
87576>>>>>>>
87576>>>>>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
87577>>>>>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
87578>>>>>>>        Get _UtilTableIsSql hTable              to bIsSQLTableTo
87579>>>>>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
87580>>>>>>>        Move True                               to APITableFrom.bFromTable
87581>>>>>>>        Move hTable                             to APITableFrom.hTable
87582>>>>>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
87583>>>>>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
87584>>>>>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
87585>>>>>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
87586>>>>>>>
87586>>>>>>>        // Check both the Filelist slot AND the LogicalName are the same! Else declare an error and break out of here!
87586>>>>>>>        If (bTableExists = True and sDriverIDTo <> DATAFLEX_ID) Begin
87588>>>>>>>            Get _SqlUtilCheckIfTableNameExists APITableFrom.ApiTableInfo.sLogicalName sDriverIDTo to bLogicalNameOK
87589>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
87590>>>>>>>            If (bOk = True and bLogicalNameOK = False) Begin
87592>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameTo
87595>>>>>>>                Error DFERR_PROGRAM ("The Filelist slot:" * String(hTable) * "exists on the client, but the Logical names are differnt! New Logical Name:" ;                                      * String(APITableFrom.ApiTableInfo.sLogicalName) * "existing Logical Name:" * String(sLogicalNameTo) * "- The file needs to be manually moved to another file slot (or removed) before this process can be started!")
87596>>>>>>>>
87596>>>>>>>                Function_Return False
87597>>>>>>>            End
87597>>>>>>>>
87597>>>>>>>        End
87597>>>>>>>>
87597>>>>>>>
87597>>>>>>>        If (bTableExists = True) Begin
87599>>>>>>>            If (bIsSQLTableTo = True) Begin
87601>>>>>>>                Get _UtilDeleteCacheFile APITableFrom.ApiTableInfo.sLogicalName to bOk
87602>>>>>>>            End
87602>>>>>>>>
87602>>>>>>>            Get OpenTableExclusive hTable to bOpened
87603>>>>>>>            If (bOpened = False) Begin
87605>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
87606>>>>>>>                Function_Return False
87607>>>>>>>            End
87607>>>>>>>>
87607>>>>>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
87608>>>>>>>            Get UtilColumnCombineFromAndToArrays   APITableFrom.aApiColumns   APITableTo.aApiColumns    to aAPIColumnCompare
87609>>>>>>>            Get UtilIndexCombineFromAndToArrays    APITableFrom.aApiIndexes   APITableTo.aApiIndexes    to aAPIIndexCompare
87610>>>>>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
87611>>>>>>>        End
87611>>>>>>>>
87611>>>>>>>
87611>>>>>>>        Move True to bOk
87612>>>>>>>        Move False to Err
87613>>>>>>>        Case Begin
87613>>>>>>>            // Alias table:
87613>>>>>>>            Case (bIsAliasFrom = True)
87615>>>>>>>                // Do nothing. Get _UtilTableCheckChangeFilelistNames is called below
87615>>>>>>>                Case Break
87616>>>>>>>
87616>>>>>>>            Case (bIsSQLTableFrom = True and bIsSQLTableTo = False and bTableExists = True)
87619>>>>>>>                    Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOk
87620>>>>>>>                    If (bOk = True) Begin
87622>>>>>>>                        Send LogError ("DataFlex table:" * String(APITableNameInfoFrom.sLogicalName) * "successfully converted to use driver:" * String(sDriverIDFrom)) False
87623>>>>>>>                    End
87623>>>>>>>>
87623>>>>>>>                Case Break
87624>>>>>>>            // New Table:
87624>>>>>>>            Case (bTableExists = False)
87627>>>>>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
87628>>>>>>>                //LR 20191112 Begin: Make file a system file if bIsSystemFile = True
87628>>>>>>>                If (APITableNameInfoFrom.bIsSystemFile) Begin
87630>>>>>>>                    Get ApiTableChangeAttribute hTable DF_FILE_IS_SYSTEM_FILE True to bOK
87631>>>>>>>                End                                                                 
87631>>>>>>>>
87631>>>>>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
87632>>>>>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
87633>>>>>>>                Case Break
87634>>>>>>>
87634>>>>>>>            // Update table:
87634>>>>>>>            Case (bTableExists = True)
87637>>>>>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
87638>>>>>>>                If (bIsSame = True) Begin
87640>>>>>>>                    Case Break
87641>>>>>>>                End
87641>>>>>>>>
87641>>>>>>>                If (bFilelistError = True) Begin
87643>>>>>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
87644>>>>>>>                    If (bOk = False) Begin
87646>>>>>>>                        Case Break
87647>>>>>>>                    End
87647>>>>>>>>
87647>>>>>>>                End
87647>>>>>>>>
87647>>>>>>>
87647>>>>>>>                If (ghoProgressBar <> 0) Begin
87649>>>>>>>                    Send DoAdvance of ghoProgressBar
87650>>>>>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
87651>>>>>>>                End
87651>>>>>>>>
87651>>>>>>>
87651>>>>>>>                // Columns:
87651>>>>>>>                Move True to bOk
87652>>>>>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
87653>>>>>>>                If (bIsSame = False) Begin
87655>>>>>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
87656>>>>>>>                End
87656>>>>>>>>
87656>>>>>>>                If (bOk = False) Begin
87658>>>>>>>                    Case Break
87659>>>>>>>                End
87659>>>>>>>>
87659>>>>>>>
87659>>>>>>>                // Indexes:
87659>>>>>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
87660>>>>>>>                If (bIsSame = False) Begin
87662>>>>>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
87663>>>>>>>                End
87663>>>>>>>>
87663>>>>>>>
87663>>>>>>>                // Relations:
87663>>>>>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
87664>>>>>>>                If (bIsSame = False) Begin
87666>>>>>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
87667>>>>>>>                    If (bOk = False) Begin
87669>>>>>>>                        Case Break
87670>>>>>>>                    End
87670>>>>>>>>
87670>>>>>>>                End
87670>>>>>>>>
87670>>>>>>>
87670>>>>>>>                Case Break
87671>>>>>>>
87671>>>>>>>            Case Else
87671>>>>>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
87672>>>>>>>>
87672>>>>>>>                Move False to bOk
87673>>>>>>>        Case End
87673>>>>>>>        
87673>>>>>>>        If (bOk = True) Begin
87675>>>>>>>            // Note: If the from table was SQL; we should either connect to an existing SQL to table,
87675>>>>>>>            // or convert an embedded table to SQL
87675>>>>>>>            If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87677>>>>>>>                Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
87678>>>>>>>                If (bOk = False) Begin
87680>>>>>>>                    Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOK
87681>>>>>>>                End
87681>>>>>>>>
87681>>>>>>>            End
87681>>>>>>>>
87681>>>>>>>            Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
87684>>>>>>>                Get SqlTableConvertToEmbedded hTable True to bOk
87685>>>>>>>            End
87685>>>>>>>>
87685>>>>>>>            
87685>>>>>>>            // Filelist Names:
87685>>>>>>>            Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
87686>>>>>>>        End
87686>>>>>>>>
87686>>>>>>>        
87686>>>>>>>        // Refresh .int file: 
87686>>>>>>>        If (bIsSQLTableTo = True) Begin
87688>>>>>>>            Open hTable
87690>>>>>>>            Structure_Start hTable
87691>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
87693>>>>>>>            Send ResetFillSQLTables
87694>>>>>>>        End
87694>>>>>>>>
87694>>>>>>>
87694>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
87695>>>>>>>
87695>>>>>>>        Function_Return bOK
87696>>>>>>>    End_Function
87697>>>>>>>
87697>>>>>>>    // * Dummy function for the Studio's Code Explorer *
87697>>>>>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
87699>>>>>>>        Function_Return False
87700>>>>>>>    End_Function
87701>>>>>>>
87701>>>>>>>    // Adds a column name to the passed table number.
87701>>>>>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
87703>>>>>>>        Integer iColumn iCount iFile iPrecision iLastErr
87703>>>>>>>        Boolean bExists bOK bInitializeValue bRetval
87703>>>>>>>        String sDataPath sDdSrcPath sTableName sColumnValue sDriverID
87703>>>>>>>
87703>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
87704>>>>>>>        If (bExists = True) Begin
87706>>>>>>>            Function_Return False
87707>>>>>>>        End
87707>>>>>>>>
87707>>>>>>>
87707>>>>>>>        Move False to Err
87708>>>>>>>        If (num_arguments > 4) Begin
87710>>>>>>>            Move iPrec to iPrecision
87711>>>>>>>        End
87711>>>>>>>>
87711>>>>>>>        If (num_arguments > 6) Begin
87713>>>>>>>            Move bInitVal to bInitializeValue
87714>>>>>>>            Move sColVal  to sColumnValue
87715>>>>>>>        End
87715>>>>>>>>
87715>>>>>>>        If (iType < -1490) Begin
87717>>>>>>>            Move (iType + 1500) to iType
87718>>>>>>>        End
87718>>>>>>>>
87718>>>>>>>
87718>>>>>>>        Move hTable to iFile
87719>>>>>>>        Get psDriverID to sDriverID
87720>>>>>>>        Get AutoConnectionIDLogin to bOK
87721>>>>>>>        Move False to Err
87722>>>>>>>        Move LastErr to iLastErr
87723>>>>>>>        Get OpenTableExclusive iFile to bOK
87724>>>>>>>        Set Private.phCurrentTable to hTable
87725>>>>>>>
87725>>>>>>>        Structure_Start iFile sDriverID
87726>>>>>>>            Move 0 to iColumn
87727>>>>>>>            Set Private.piCurrentField to iColumn
87728>>>>>>>            Create_Field hTable At iColumn
87729>>>>>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
87732>>>>>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
87735>>>>>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
87738>>>>>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
87741>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87742>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87744>>>>>>>
87744>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87745>>>>>>>
87745>>>>>>>        // If in development environment; create .fd file:
87745>>>>>>>        Open hTable
87747>>>>>>>        Get psDdSrcPath  of (phoWorkspace(ghoApplication)) to sDDSrcPath
87748>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87749>>>>>>>        If (iCount > 1) Begin
87751>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87752>>>>>>>        End
87752>>>>>>>>
87752>>>>>>>        Get vFolderExists sDDSrcPath to bExists
87753>>>>>>>        If (bExists = True) Begin
87755>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87756>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87759>>>>>>>            Get _TableNameOnly sTableName to sTableName
87760>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87762>>>>>>>        End
87762>>>>>>>>
87762>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin  // We only want a tag if DataFlex embedded db
87764>>>>>>>            Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
87765>>>>>>>            Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
87766>>>>>>>            If (iCount > 1) Begin
87768>>>>>>>                Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
87769>>>>>>>            End
87769>>>>>>>>
87769>>>>>>>            Get vFolderFormat sDataPath to sDataPath
87770>>>>>>>            // Add the new column name to the .tag filen (if it doesn't exist):
87770>>>>>>>            // The following line should not be necexxary for the DataFlex driver. (Thank you, Hans van de Laar)
87770>>>>>>>            //Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sFieldName to bOK
87770>>>>>>>        End
87770>>>>>>>>
87770>>>>>>>        // Check for a default value
87770>>>>>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
87772>>>>>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
87773>>>>>>>        End
87773>>>>>>>>
87773>>>>>>>        Close hTable
87774>>>>>>>
87774>>>>>>>        Function_Return (Err = False)
87775>>>>>>>    End_Function
87776>>>>>>>
87776>>>>>>>    // Adds a column name to the passed table number.
87776>>>>>>>    Function ApiColumnInsert String sDriverIDFrom Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
87778>>>>>>>        Integer iCount iFile iPrecision iNumberOfFields iDbType
87778>>>>>>>        Boolean bExists bOK bIsDateType bIsSQLTypeTo
87778>>>>>>>        String sDdSrcPath sTableName
87778>>>>>>>
87778>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
87779>>>>>>>        Move False to Err
87780>>>>>>>        If (bExists = True) Begin
87782>>>>>>>            Function_Return False
87783>>>>>>>        End
87783>>>>>>>>
87783>>>>>>>        If (num_arguments > 4) Begin
87785>>>>>>>            Move iPrec to iPrecision
87786>>>>>>>        End
87786>>>>>>>>
87786>>>>>>>        If (iType < -1490) Begin
87788>>>>>>>            Move (iType + 1500) to iType
87789>>>>>>>        End
87789>>>>>>>>
87789>>>>>>>
87789>>>>>>>        Get AutoConnectionIDLogin to bOK
87790>>>>>>>        Move False to Err
87791>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTypeTo
87792>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
87792>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types. 
87792>>>>>>>        Get piDbType to iDbType
87793>>>>>>>        If (bIsSQLTypeTo = False) Begin
87795>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iType iLength to iType
87796>>>>>>>            If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87798>>>>>>>                Move DF_DATE to iType
87799>>>>>>>            End
87799>>>>>>>>
87799>>>>>>>        End
87799>>>>>>>>
87799>>>>>>>
87799>>>>>>>        // Structure_start will change the value of hTable...
87799>>>>>>>        Move hTable to iFile
87800>>>>>>>        Get OpenTableExclusive iFile to bOK
87801>>>>>>>        If (bOK = False) Begin
87803>>>>>>>            Function_Return False
87804>>>>>>>        End
87804>>>>>>>>
87804>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
87807>>>>>>>
87807>>>>>>>        // If the passed column number is higher than the current number of fields
87807>>>>>>>        // in the table, this means we should _not_ insert a field but rather add
87807>>>>>>>        // a new field to the end:
87807>>>>>>>        If (iColumn > iNumberOfFields) Begin
87809>>>>>>>            Move 0 to iColumn
87810>>>>>>>        End
87810>>>>>>>>
87810>>>>>>>
87810>>>>>>>        Set Private.phCurrentTable to hTable
87811>>>>>>>        Set Private.piCurrentField to iColumn
87812>>>>>>>
87812>>>>>>>        Structure_Start iFile
87813>>>>>>>            Create_Field iFile At iColumn
87814>>>>>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
87817>>>>>>>            If (bIsSQLTypeTo = False) Begin
87819>>>>>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
87822>>>>>>>            End
87822>>>>>>>>
87822>>>>>>>            Else Begin
87823>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
87826>>>>>>>            End
87826>>>>>>>>
87826>>>>>>>            Get UtilColumnIsDateType iType bIsSQLTypeTo to bIsDateType
87827>>>>>>>            If (bIsDateType = False) Begin
87829>>>>>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
87832>>>>>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
87835>>>>>>>            End
87835>>>>>>>>
87835>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87836>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87838>>>>>>>
87838>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87839>>>>>>>        // If in development environment; create .fd file:
87839>>>>>>>        Open hTable
87841>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
87842>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87843>>>>>>>        If (iCount > 1) Begin
87845>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87846>>>>>>>        End
87846>>>>>>>>
87846>>>>>>>        Get vFolderExists sDDSrcPath to bExists
87847>>>>>>>        If (bExists = True) Begin
87849>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87850>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87853>>>>>>>            Get _TableNameOnly sTableName to sTableName
87854>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87856>>>>>>>        End
87856>>>>>>>>
87856>>>>>>>
87856>>>>>>>        // Check for a default value
87856>>>>>>>        Close hTable
87857>>>>>>>
87857>>>>>>>        Function_Return (Err = False)
87858>>>>>>>    End_Function
87859>>>>>>>
87859>>>>>>>    // To update all records for a table column with a fixed value.
87859>>>>>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
87861>>>>>>>        Integer iRecs iCurrErr iField iRecord
87861>>>>>>>        Boolean bRetval bOpen
87861>>>>>>>
87861>>>>>>>        Move 0 to iRecs
87862>>>>>>>        Move False to bRetval
87863>>>>>>>        Move Err to iCurrErr
87864>>>>>>>        Move False to Err
87865>>>>>>>
87865>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
87868>>>>>>>        If (bOpen = False) Begin
87870>>>>>>>            Open hTable
87872>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
87875>>>>>>>            If (bOpen = False) Begin
87877>>>>>>>                Function_Return bRetval
87878>>>>>>>            End
87878>>>>>>>>
87878>>>>>>>        End
87878>>>>>>>>
87878>>>>>>>
87878>>>>>>>        Field_Map hTable sFieldName to iField
87880>>>>>>>        If (iField <> 0) Begin
87882>>>>>>>            Set Private.phCurrentTable to hTable
87883>>>>>>>            Set Private.piCurrentField to iField
87884>>>>>>>            Clear hTable
87885>>>>>>>            Repeat
87885>>>>>>>>
87885>>>>>>>                Vfind hTable 0 GT
87887>>>>>>>                If (Found) Begin
87889>>>>>>>                    If (ghoStatusPanel <> 0) Begin
87891>>>>>>>                        Get_Field_Value hTable 0 to iRecord
87894>>>>>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_DUF_UpdateVersion * String(iRecord))
87895>>>>>>>                    End
87895>>>>>>>>
87895>>>>>>>                    Reread hTable
87899>>>>>>>                        Set_Field_Value hTable iField to sColumnValue
87902>>>>>>>                        SaveRecord hTable
87903>>>>>>>                    Unlock
87904>>>>>>>>
87904>>>>>>>                End
87904>>>>>>>>
87904>>>>>>>           Until (not(Found))
87906>>>>>>>        End
87906>>>>>>>>
87906>>>>>>>
87906>>>>>>>        Move (Err = False) to bRetval
87907>>>>>>>        Move iCurrErr to Err
87908>>>>>>>
87908>>>>>>>        Function_Return bRetval
87909>>>>>>>    End_Function
87910>>>>>>>
87910>>>>>>>    // Note: This can only be used from within a Structure_Start/End construct.
87910>>>>>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
87912>>>>>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
87912>>>>>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
87912>>>>>>>        String sFieldName sDriverID sTableName sDefaultValue
87912>>>>>>>
87912>>>>>>>        Get psDriverID to sDriverID
87913>>>>>>>        Get piDbType to iDbType
87914>>>>>>>        Get UtilTableHandleToString hTable to sTableName
87915>>>>>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
87916>>>>>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
87917>>>>>>>        Get _UtilTableIsSql hTable to bIsSqlTable
87918>>>>>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
87920>>>>>>>            Move True to bIsSqlTable
87921>>>>>>>        End
87921>>>>>>>>
87921>>>>>>>        Move False to bIsOpen
87922>>>>>>>        If (hTable > 0) Begin
87924>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87927>>>>>>>        End
87927>>>>>>>>
87927>>>>>>>        If (bIsOpen = True) Begin
87929>>>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
87932>>>>>>>        End
87932>>>>>>>>
87932>>>>>>>        Else Begin
87933>>>>>>>            Get pbRecnum to bRecnumTable
87934>>>>>>>        End
87934>>>>>>>>
87934>>>>>>>
87934>>>>>>>        Move False to Err
87935>>>>>>>        Move (SizeOfArray(aColumns)) to iSize
87936>>>>>>>        Decrement iSize
87937>>>>>>>        for iCount from 0 to iSize
87943>>>>>>>>
87943>>>>>>>            Move aColumns[iCount].sFieldName to sFieldName
87944>>>>>>>            If (hTable > 0) Begin
87946>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87947>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87948>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
87951>>>>>>>                Move (Trim(sFieldName) <> "") to bFieldExists
87952>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
87953>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87954>>>>>>>            End
87954>>>>>>>>
87954>>>>>>>            Else Begin
87955>>>>>>>                Move False to bFieldExists
87956>>>>>>>            End
87956>>>>>>>>
87956>>>>>>>
87956>>>>>>>            If (bFieldExists = False) Begin
87958>>>>>>>                Move 0 to iColumn
87959>>>>>>>                Create_Field hTable At iColumn
87960>>>>>>>            End
87960>>>>>>>>
87960>>>>>>>            Else Begin
87961>>>>>>>                Move iCount to iColumn
87962>>>>>>>            End
87962>>>>>>>>
87962>>>>>>>
87962>>>>>>>            Set Private.piCurrentField to iColumn
87963>>>>>>>
87963>>>>>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
87964>>>>>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
87967>>>>>>>
87967>>>>>>>            Move aColumns[iCount].iType to iType
87968>>>>>>>            Move (not(iType < -1490)) to bNativeType
87969>>>>>>>            If (iType < -1490) Begin
87971>>>>>>>                Move (iType + 1500) to iType
87972>>>>>>>            End
87972>>>>>>>>
87972>>>>>>>
87972>>>>>>>            If (bIsSqlTable = True) Begin
87974>>>>>>>                If (aColumns[iCount].bIsSQLType = True) Begin
87976>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
87977>>>>>>>//                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
87977>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType
87980>>>>>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
87983>>>>>>>
87983>>>>>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
87984>>>>>>>                    If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
87986>>>>>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
87987>>>>>>>                    End
87987>>>>>>>>
87987>>>>>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue
87990>>>>>>>
87990>>>>>>>                End
87990>>>>>>>>
87990>>>>>>>                Else Begin
87991>>>>>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
87994>>>>>>>                End
87994>>>>>>>>
87994>>>>>>>            End
87994>>>>>>>>
87994>>>>>>>            Else Begin
87995>>>>>>>                If (bCreating = False) Begin
87997>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
87998>>>>>>>                    If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88000>>>>>>>                        Move DF_DATE to iType
88001>>>>>>>                    End
88001>>>>>>>>
88001>>>>>>>                End
88001>>>>>>>>
88001>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
88004>>>>>>>            End
88004>>>>>>>>
88004>>>>>>>
88004>>>>>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
88005>>>>>>>            If (bIsDateType = False) Begin
88007>>>>>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
88010>>>>>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
88013>>>>>>>            End
88013>>>>>>>>
88013>>>>>>>
88013>>>>>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
88015>>>>>>>                Move 0 to iIndex
88016>>>>>>>                Create_Index hTable at iIndex
88017>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
88020>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
88023>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
88026>>>>>>>
88026>>>>>>>                // If we have an identity table - we must create a primary_key table.
88026>>>>>>>                If (bIsSqlTable = True) Begin
88028>>>>>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to True
88031>>>>>>>                        Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True
88034>>>>>>>                End
88034>>>>>>>>
88034>>>>>>>            End
88034>>>>>>>>
88034>>>>>>>        Loop
88035>>>>>>>>
88035>>>>>>>
88035>>>>>>>        Function_Return (Err = False)
88036>>>>>>>    End_Function
88037>>>>>>>
88037>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
88037>>>>>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
88039>>>>>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
88039>>>>>>>        Boolean bOK bIsSqlTable
88039>>>>>>>        String sFieldNameTo
88039>>>>>>>
88039>>>>>>>        If (num_arguments > 4) Begin
88041>>>>>>>            Move iPrec to iPrecFrom
88042>>>>>>>        End
88042>>>>>>>>
88042>>>>>>>        If (iTypeFrom < -1490) Begin
88044>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
88045>>>>>>>        End
88045>>>>>>>>
88045>>>>>>>
88045>>>>>>>        Get AutoConnectionIDLogin to bOK
88046>>>>>>>        Move False to Err
88047>>>>>>>        Get OpenTableExclusive hTable to bOK
88048>>>>>>>        If (bOK = False) Begin
88050>>>>>>>            Function_Return False
88051>>>>>>>        End
88051>>>>>>>>
88051>>>>>>>
88051>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88052>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88053>>>>>>>        Field_Map hTable sFieldNameFrom to iColumn
88055>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88056>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88057>>>>>>>        If (Err = True) Begin
88059>>>>>>>            Function_Return False
88060>>>>>>>        End
88060>>>>>>>>
88060>>>>>>>
88060>>>>>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
88063>>>>>>>        Get _UtilTableIsSql hTable to bIsSqlTable
88064>>>>>>>        If (bIsSqlTable = False) Begin
88066>>>>>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
88069>>>>>>>        End
88069>>>>>>>>
88069>>>>>>>        Else Begin
88070>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
88073>>>>>>>        End
88073>>>>>>>>
88073>>>>>>>        // Let the driver decide the other values;
88073>>>>>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
88076>>>>>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
88079>>>>>>>
88079>>>>>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
88081>>>>>>>            Function_Return False
88082>>>>>>>        End
88082>>>>>>>>
88082>>>>>>>
88082>>>>>>>        Set Private.phCurrentTable to hTable
88083>>>>>>>        Set Private.piCurrentField to iColumn
88084>>>>>>>
88084>>>>>>>        Structure_Start hTable
88085>>>>>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
88088>>>>>>>            If (bIsSqlTable = False) Begin
88090>>>>>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
88093>>>>>>>            End
88093>>>>>>>>
88093>>>>>>>            Else Begin
88094>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
88097>>>>>>>            End
88097>>>>>>>>
88097>>>>>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to (iLengthFrom + iPrecFrom)
88100>>>>>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
88103>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88104>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88106>>>>>>>
88106>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88107>>>>>>>        Function_Return (Err = False)
88108>>>>>>>    End_Function
88109>>>>>>>
88109>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
88109>>>>>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
88111>>>>>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
88111>>>>>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
88111>>>>>>>        String sFieldNameTo sDriverIDTo
88111>>>>>>>        tColumnType ColumnType
88111>>>>>>>        tColumnType ColumnType
88111>>>>>>>
88111>>>>>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
88112>>>>>>>        Get piDbType to iDbType
88113>>>>>>>        If (num_arguments > 4) Begin
88115>>>>>>>            Move iPrec to iPrecFrom
88116>>>>>>>            Move iOpt  to iOptionFrom
88117>>>>>>>        End
88117>>>>>>>>
88117>>>>>>>        If (iTypeFrom < -1490) Begin
88119>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
88120>>>>>>>        End
88120>>>>>>>>
88120>>>>>>>
88120>>>>>>>        Get AutoConnectionIDLogin to bOK
88121>>>>>>>        Move False to Err
88122>>>>>>>        Close hTable
88123>>>>>>>        Get OpenTableExclusive hTable to bOK
88124>>>>>>>        If (bOK = False) Begin
88126>>>>>>>            Function_Return False
88127>>>>>>>        End
88127>>>>>>>>
88127>>>>>>>
88127>>>>>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
88130>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
88133>>>>>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
88134>>>>>>>        If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88136>>>>>>>            Move DF_DATE to iDataFlexType
88137>>>>>>>        End
88137>>>>>>>>
88137>>>>>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
88140>>>>>>>
88140>>>>>>>        If (bIsSQLTableTo = True) Begin
88142>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeTo
88145>>>>>>>        End
88145>>>>>>>>
88145>>>>>>>        Else Begin
88146>>>>>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
88149>>>>>>>        End
88149>>>>>>>>
88149>>>>>>>
88149>>>>>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
88152>>>>>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
88155>>>>>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo
88158>>>>>>>
88158>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
88158>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types.
88158>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
88160>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeTo
88161>>>>>>>            If (iTypeTo = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88163>>>>>>>                Move DF_DATE to iTypeTo  
88164>>>>>>>            End
88164>>>>>>>>
88164>>>>>>>        End
88164>>>>>>>>
88164>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
88167>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeFrom
88168>>>>>>>        End
88168>>>>>>>>
88168>>>>>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
88169>>>>>>>
88169>>>>>>>        If (bCompareDate_DateTime = False) Begin
88171>>>>>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
88172>>>>>>>            If (bSkip = True) Begin
88174>>>>>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
88176>>>>>>>                    Function_Return True
88177>>>>>>>                End
88177>>>>>>>>
88177>>>>>>>            End
88177>>>>>>>>
88177>>>>>>>        End
88177>>>>>>>>
88177>>>>>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
88180>>>>>>>            Function_Return True
88181>>>>>>>        End
88181>>>>>>>>
88181>>>>>>>
88181>>>>>>>        Set Private.phCurrentTable to hTable
88182>>>>>>>        Set Private.piCurrentField to iColumn
88183>>>>>>>
88183>>>>>>>        Structure_Start hTable
88184>>>>>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
88186>>>>>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
88189>>>>>>>            End
88189>>>>>>>>
88189>>>>>>>
88189>>>>>>>            If (bIsSameDataType = False) Begin
88191>>>>>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
88194>>>>>>>                If (bIsSQLTableTo = True) Begin
88196>>>>>>>                        Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iTypeFrom
88199>>>>>>>                End
88199>>>>>>>>
88199>>>>>>>            End
88199>>>>>>>>
88199>>>>>>>
88199>>>>>>>            If (iLengthFrom <> iLengthTo) Begin
88201>>>>>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
88204>>>>>>>            End
88204>>>>>>>>
88204>>>>>>>            If (iPrecFrom <> iPrecTo) Begin
88206>>>>>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
88209>>>>>>>            End
88209>>>>>>>>
88209>>>>>>>
88209>>>>>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
88211>>>>>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
88211>>>>>>>                If (bRecnumTable = True) Begin
88213>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
88216>>>>>>>                End
88216>>>>>>>>
88216>>>>>>>
88216>>>>>>>                // We might need to create an index here.
88216>>>>>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
88216>>>>>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
88216>>>>>>>                // index update checking logic.
88216>>>>>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
88219>>>>>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
88221>>>>>>>                    Create_Index hTable At iIndex
88222>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
88225>>>>>>>                End
88225>>>>>>>>
88225>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
88228>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
88231>>>>>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
88234>>>>>>>                If (bIsSQLTableTo = True) Begin
88236>>>>>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
88239>>>>>>>                End
88239>>>>>>>>
88239>>>>>>>            End
88239>>>>>>>>
88239>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88240>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88242>>>>>>>
88242>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88243>>>>>>>        Function_Return (Err = False)
88244>>>>>>>    End_Function
88245>>>>>>>
88245>>>>>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
88247>>>>>>>        Boolean bOK
88247>>>>>>>
88247>>>>>>>        Get AutoConnectionIDLogin to bOK
88248>>>>>>>        Move False to Err
88249>>>>>>>        Get OpenTableExclusive hTable to bOK
88250>>>>>>>        If (bOK = False) Begin
88252>>>>>>>            Function_Return False
88253>>>>>>>        End
88253>>>>>>>>
88253>>>>>>>
88253>>>>>>>        Structure_Start hTable
88254>>>>>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
88257>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88258>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88260>>>>>>>
88260>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88261>>>>>>>        Function_Return (Err = False)
88262>>>>>>>    End_Function
88263>>>>>>>
88263>>>>>>>    // To move an existing field to another position in a table.
88263>>>>>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Integer iLength Integer iPrecision Returns Boolean
88265>>>>>>>        String sColumn sDriverID
88265>>>>>>>        Integer iType iSQLType
88265>>>>>>>        Boolean bOK bIsDate
88265>>>>>>>
88265>>>>>>>        Close hTable
88266>>>>>>>        Get AutoConnectionIDLogin to bOK
88267>>>>>>>        Get OpenTableExclusive hTable to bOK
88268>>>>>>>        If (bOK = False) Begin
88270>>>>>>>            Function_Return False
88271>>>>>>>        End
88271>>>>>>>>
88271>>>>>>>
88271>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88274>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
88276>>>>>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
88277>>>>>>>>
88277>>>>>>>            Function_Return False
88278>>>>>>>        End
88278>>>>>>>>
88278>>>>>>>
88278>>>>>>>        Set Action_Text of ghoStatusPanel to "Restructures table..."
88279>>>>>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
88282>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
88285>>>>>>>        If (bIsSQLType = True) Begin
88287>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iOld to iSQLType
88290>>>>>>>            Get UtilColumnIsDateType iSQLType bIsSQLType  to bIsDate
88291>>>>>>>        End
88291>>>>>>>>
88291>>>>>>>        Else Begin
88292>>>>>>>            Get UtilColumnIsDateType iType bIsSQLType  to bIsDate
88293>>>>>>>        End
88293>>>>>>>>
88293>>>>>>>
88293>>>>>>>        Set Private.phCurrentTable to hTable
88294>>>>>>>        Set Private.piCurrentField to iOld
88295>>>>>>>
88295>>>>>>>        Move False to Err
88296>>>>>>>
88296>>>>>>>        Structure_Start hTable
88297>>>>>>>            Delete_Field hTable iOld
88298>>>>>>>            Create_Field hTable At iNew
88299>>>>>>>            
88299>>>>>>>            // This one is the crucial line:
88299>>>>>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
88302>>>>>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
88305>>>>>>>            
88305>>>>>>>            // If SQL table it is important that we don't try to change the field type, as MS-SQL then will generate an error.
88305>>>>>>>            If (bIsSQLType = True and bIsDate = False) Begin
88307>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType
88310>>>>>>>            End
88310>>>>>>>>
88310>>>>>>>            If (bIsDate = False) Begin
88312>>>>>>>                Set_Attribute DF_FIELD_TYPE   of hTable iNew to iType
88315>>>>>>>                Set_Attribute DF_FIELD_LENGTH of hTable iNew to iLength
88318>>>>>>>            End
88318>>>>>>>>
88318>>>>>>>            If (iType = DF_BCD) Begin
88320>>>>>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
88323>>>>>>>            End
88323>>>>>>>>
88323>>>>>>>
88323>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88325>>>>>>>
88325>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88326>>>>>>>        Move (not(Err)) to bOK
88327>>>>>>>        Move False to Err
88328>>>>>>>        Move 0 to LastErr
88329>>>>>>>        Function_Return bOK
88330>>>>>>>    End_Function 
88331>>>>>>>    
88331>>>>>>>    // Deletes a column name for the passed table number (and column number).
88331>>>>>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
88333>>>>>>>        Integer iColumn
88333>>>>>>>        Boolean bOK
88333>>>>>>>
88333>>>>>>>        Get AutoConnectionIDLogin to bOK
88334>>>>>>>        Move False to Err
88335>>>>>>>        Close hTable
88336>>>>>>>        Get OpenTableExclusive hTable to bOK
88337>>>>>>>        If (bOK = False) Begin
88339>>>>>>>            Function_Return False
88340>>>>>>>        End
88340>>>>>>>>
88340>>>>>>>
88340>>>>>>>        If (not(Err)) Begin
88342>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88343>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88344>>>>>>>            Field_Map hTable sFieldName to iColumn
88346>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
88347>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88348>>>>>>>            If (iColumn = 0) Begin
88350>>>>>>>                Move 0 to LastErr
88351>>>>>>>                Function_Return False
88352>>>>>>>            End
88352>>>>>>>>
88352>>>>>>>            Move False to Err
88353>>>>>>>
88353>>>>>>>            Set Private.phCurrentTable to hTable
88354>>>>>>>            Set Private.piCurrentField to iColumn
88355>>>>>>>
88355>>>>>>>            Structure_Start hTable
88356>>>>>>>                Delete_Field hTable iColumn
88357>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88358>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88360>>>>>>>            Set Action_Text of ghoStatusPanel to ""
88361>>>>>>>        End
88361>>>>>>>>
88361>>>>>>>        Else Begin
88362>>>>>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
88363>>>>>>>>
88363>>>>>>>        End
88363>>>>>>>>
88363>>>>>>>
88363>>>>>>>        Function_Return (Err = False)
88364>>>>>>>    End_Function
88365>>>>>>>
88365>>>>>>>    // Renames a field for the passed table number & old field name & new field name
88365>>>>>>>    // Returns True if no errors occured.
88365>>>>>>>    // Sample usage:
88365>>>>>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
88365>>>>>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
88367>>>>>>>        Integer iField
88367>>>>>>>        Boolean bOK bExists bIsOpen
88367>>>>>>>
88367>>>>>>>        Get UtilColumnExists hTable sNewFieldName to bExists
88368>>>>>>>        If (bExists = True) Begin
88370>>>>>>>            Function_Return False
88371>>>>>>>        End
88371>>>>>>>>
88371>>>>>>>
88371>>>>>>>        // Note: The Field_Map command does _not_ work if the table has been
88371>>>>>>>        //       opened exclusively, so we first open it in normal mode.
88371>>>>>>>        Close hTable
88372>>>>>>>        Open hTable
88374>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88377>>>>>>>        If (bIsOpen = False) Begin
88379>>>>>>>            Function_Return False
88380>>>>>>>        End
88380>>>>>>>>
88380>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88381>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88382>>>>>>>        Field_Map hTable sOldFieldName to iField
88384>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88385>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88386>>>>>>>
88386>>>>>>>        Get AutoConnectionIDLogin to bOK
88387>>>>>>>        Get OpenTableExclusive hTable to bOK
88388>>>>>>>        If (bOK = False) Begin
88390>>>>>>>            Function_Return False
88391>>>>>>>        End
88391>>>>>>>>
88391>>>>>>>
88391>>>>>>>        Move False to Err
88392>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
88393>>>>>>>        Set Private.phCurrentTable to hTable
88394>>>>>>>        Set Private.piCurrentField to iField
88395>>>>>>>
88395>>>>>>>        If (iField > 0) Begin
88397>>>>>>>            Structure_Start hTable
88398>>>>>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
88401>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88402>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88404>>>>>>>        End
88404>>>>>>>>
88404>>>>>>>        Else Begin
88405>>>>>>>            Move 0 to LastErr
88406>>>>>>>            Move False to Err
88407>>>>>>>        End
88407>>>>>>>>
88407>>>>>>>
88407>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88408>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
88409>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88410>>>>>>>
88410>>>>>>>        Function_Return (Err = False)
88411>>>>>>>    End_Function
88412>>>>>>>
88412>>>>>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
88414>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
88414>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
88415>>>>>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo iColumnNumber
88415>>>>>>>        Boolean bRenameField
88415>>>>>>>
88415>>>>>>>        Open hTable
88417>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88418>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88419>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88420>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
88423>>>>>>>        Move (iSize max iNumberOfFieldsTo) to iSize
88424>>>>>>>        Decrement iSize
88425>>>>>>>        for iCount from 0 to iSize
88431>>>>>>>>
88431>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
88433>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88434>>>>>>>
88434>>>>>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
88436>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iFieldTo = 0) Begin
88438>>>>>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iColumnNumber
88439>>>>>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount]      to bRenameField
88440>>>>>>>                    If (iColumnNumber = -1 and bRenameField = False) Begin
88442>>>>>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber
88443>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
88444>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom
88445>>>>>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
88446>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
88447>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
88448>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
88449>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
88450>>>>>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
88451>>>>>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
88452>>>>>>>                        Increment iItem
88453>>>>>>>                    End
88453>>>>>>>>
88453>>>>>>>                End
88453>>>>>>>>
88453>>>>>>>            End
88453>>>>>>>>
88453>>>>>>>        Loop
88454>>>>>>>>
88454>>>>>>>
88454>>>>>>>        Move False to Err
88455>>>>>>>        Move 0 to LastErr
88456>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88457>>>>>>>        Function_Return aAPIColumnsToInsert
88458>>>>>>>    End_Function
88459>>>>>>>
88459>>>>>>>    Function UtilColumnsInsert String sDriverIDFrom Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
88461>>>>>>>        Integer iSize iCount
88461>>>>>>>        Boolean bOK
88461>>>>>>>        tAPIColumn[] aColumnsTo
88461>>>>>>>        tAPIColumn[] aColumnsTo
88462>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88462>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88463>>>>>>>
88463>>>>>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
88464>>>>>>>        If (iSize = 0) Begin
88466>>>>>>>            Function_Return True
88467>>>>>>>        End
88467>>>>>>>>
88467>>>>>>>
88467>>>>>>>        Move False to Err
88468>>>>>>>        Decrement iSize
88469>>>>>>>        for iCount from 0 to iSize
88475>>>>>>>>
88475>>>>>>>            Get ApiColumnInsert sDriverIDFrom hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
88476>>>>>>>        Loop
88477>>>>>>>>
88477>>>>>>>
88477>>>>>>>        Function_Return bOK
88478>>>>>>>    End_Function
88479>>>>>>>
88479>>>>>>>    // Returns a struct array with fields that has the same names but different field numbers.
88479>>>>>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
88481>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
88481>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
88482>>>>>>>        Integer iSize iCount iItem iShouldMove
88482>>>>>>>
88482>>>>>>>        Move 0 to iItem
88483>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88484>>>>>>>        Decrement iSize
88485>>>>>>>        for iCount from 0 to iSize
88491>>>>>>>>
88491>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
88493>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
88494>>>>>>>                If (iShouldMove <> -1) Begin
88496>>>>>>>                    Move aAPIColumnCompare[iCount] to aAPIColumnsToMove[iItem]
88497>>>>>>>                    Move iShouldMove               to aAPIColumnsToMove[iItem].iFieldNumberTo
88498>>>>>>>                    Move aAPIColumnCompare[iShouldMove - 1].sFieldNameTo to aAPIColumnsToMove[iItem].sFieldNameTo
88499>>>>>>>                    Increment iItem
88500>>>>>>>                End
88500>>>>>>>>
88500>>>>>>>            End
88500>>>>>>>>
88500>>>>>>>        Loop
88501>>>>>>>>
88501>>>>>>>
88501>>>>>>>        Move False to Err
88502>>>>>>>        Move 0 to LastErr
88503>>>>>>>        Function_Return aAPIColumnsToMove
88504>>>>>>>    End_Function
88505>>>>>>>
88505>>>>>>>    Function UtilColumnsMove Handle hTable tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
88507>>>>>>>        Integer iSize iCount
88507>>>>>>>        Boolean bOK
88507>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88507>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88508>>>>>>>
88508>>>>>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
88509>>>>>>>        If (iSize = 0) Begin
88511>>>>>>>            Function_Return True
88512>>>>>>>        End
88512>>>>>>>>
88512>>>>>>>
88512>>>>>>>        Move False to Err
88513>>>>>>>        Decrement iSize
88514>>>>>>>        for iCount from 0 to iSize
88520>>>>>>>>
88520>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88521>>>>>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
88523>>>>>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom aAPIColumnsToMove[iCount].iLengthFrom aAPIColumnsToMove[iCount].iPrecisionFrom to bOK
88524>>>>>>>                If (bOK = True) Begin
88526>>>>>>>                    Get UtilColumnsStructFill hTable to aColumnsTo
88527>>>>>>>                    Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88528>>>>>>>                    Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIColumnsToMove
88529>>>>>>>                    If (SizeOfArray(aAPIColumnsToMove)) Begin
88531>>>>>>>                        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
88532>>>>>>>                        Decrement iSize
88533>>>>>>>                        Move 0 to iCount
88534>>>>>>>                    End
88534>>>>>>>>
88534>>>>>>>                End
88534>>>>>>>>
88534>>>>>>>                Else Begin
88535>>>>>>>                    Move iSize to iCount // We're out of here! Else there will be an error generated for each field.
88536>>>>>>>                End
88536>>>>>>>>
88536>>>>>>>            End
88536>>>>>>>>
88536>>>>>>>        Loop
88537>>>>>>>>
88537>>>>>>>
88537>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88538>>>>>>>        If (LastErr = DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) Begin
88540>>>>>>>            Move 0 to LastErr
88541>>>>>>>        End
88541>>>>>>>>
88541>>>>>>>        Function_Return bOK
88542>>>>>>>    End_Function
88543>>>>>>>
88543>>>>>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
88543>>>>>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
88543>>>>>>>    // - The "FROM" field name is <> "TO" field name
88543>>>>>>>    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
88543>>>>>>>    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
88543>>>>>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
88545>>>>>>>        Boolean bShouldRename
88545>>>>>>>        String sFieldNameFrom sFieldNameTo
88545>>>>>>>
88545>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
88546>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo
88547>>>>>>>        If (sFieldNameFrom = sFieldNameTo) Begin
88549>>>>>>>            Function_Return False
88550>>>>>>>        End
88550>>>>>>>>
88550>>>>>>>
88550>>>>>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
88551>>>>>>>//        If (bShouldRename = False) Begin
88551>>>>>>>//            Function_Return False
88551>>>>>>>//        End
88551>>>>>>>//
88551>>>>>>>//        If (sFieldNameFrom contains sFieldNameTo) Begin
88551>>>>>>>//            Function_Return True
88551>>>>>>>//        End
88551>>>>>>>
88551>>>>>>>        Function_Return bShouldRename
88552>>>>>>>    End_Function
88553>>>>>>>
88553>>>>>>>    // Returns -1 if the passed iColumn number doesn't exist with the same name in the aAPIColumnCompare struct array.
88553>>>>>>>    // Else it returns the column/field number of the field that exists in another position.
88553>>>>>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Integer
88555>>>>>>>        Integer iCount iSize iRetval
88555>>>>>>>        String sFieldNameFrom
88555>>>>>>>
88555>>>>>>>        Move -1 to iRetval
88556>>>>>>>        If (aAPIColumnCompare[iColumn].bExistsFrom = False or aAPIColumnCompare[iColumn].bExistsTo = False) Begin
88558>>>>>>>            Function_Return iRetval
88559>>>>>>>        End
88559>>>>>>>>
88559>>>>>>>
88559>>>>>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
88560>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88561>>>>>>>        Decrement iSize
88562>>>>>>>        for iCount from 0 to iSize
88568>>>>>>>>
88568>>>>>>>            // We're only interested in fields other than the passed field/column number:
88568>>>>>>>            If (iCount <> iColumn) Begin
88570>>>>>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
88572>>>>>>>                    Move (iCount + 1) to iRetval
88573>>>>>>>                End
88573>>>>>>>>
88573>>>>>>>            End
88573>>>>>>>>
88573>>>>>>>        Loop
88574>>>>>>>>
88574>>>>>>>
88574>>>>>>>        Move 0 to LastErr
88575>>>>>>>        Function_Return iRetval
88576>>>>>>>    End_Function
88577>>>>>>>
88577>>>>>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
88579>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
88579>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
88580>>>>>>>        Integer iSize iCount iItem iFieldTo iShouldMove
88580>>>>>>>        Boolean bRenameField
88580>>>>>>>
88580>>>>>>>        Open hTable
88582>>>>>>>        Move 0 to iItem
88583>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88584>>>>>>>        Decrement iSize
88585>>>>>>>        for iCount from 0 to iSize
88591>>>>>>>>
88591>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
88593>>>>>>>                // Check if the field exists in another position (other field number)
88593>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
88594>>>>>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
88595>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iShouldMove = -1 and bRenameField = True) Begin
88597>>>>>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber
88598>>>>>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo
88599>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
88600>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
88601>>>>>>>                    Increment iItem
88602>>>>>>>                End
88602>>>>>>>>
88602>>>>>>>            End
88602>>>>>>>>
88602>>>>>>>        Loop
88603>>>>>>>>
88603>>>>>>>
88603>>>>>>>        Move False to Err
88604>>>>>>>        Move 0 to LastErr
88605>>>>>>>        Function_Return aAPIColumnsToRename
88606>>>>>>>    End_Function
88607>>>>>>>
88607>>>>>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
88609>>>>>>>        Integer iSize iCount
88609>>>>>>>        Boolean bOK
88609>>>>>>>        tAPIColumn[] aColumnsTo
88609>>>>>>>        tAPIColumn[] aColumnsTo
88610>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88610>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88611>>>>>>>
88611>>>>>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
88612>>>>>>>        If (iSize = 0) Begin
88614>>>>>>>            Function_Return True
88615>>>>>>>        End
88615>>>>>>>>
88615>>>>>>>
88615>>>>>>>        Move False to Err
88616>>>>>>>        Decrement iSize
88617>>>>>>>        For iCount from 0 to iSize
88623>>>>>>>>
88623>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88624>>>>>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK
88625>>>>>>>        Loop
88626>>>>>>>>
88626>>>>>>>
88626>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88627>>>>>>>        Function_Return bOK
88628>>>>>>>    End_Function
88629>>>>>>>
88629>>>>>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
88631>>>>>>>        Boolean bDateType
88631>>>>>>>
88631>>>>>>>        If (bIsSQLTableTo = True) Begin
88633>>>>>>>            Move (iType = SQL_DATE or iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
88634>>>>>>>        End
88634>>>>>>>>
88634>>>>>>>        Else Begin
88635>>>>>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
88636>>>>>>>        End
88636>>>>>>>>
88636>>>>>>>
88636>>>>>>>        Function_Return bDateType
88637>>>>>>>    End_Function
88638>>>>>>>
88638>>>>>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
88640>>>>>>>        Integer iCount iColumns iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
88640>>>>>>>        Integer iCount2 iColumn2
88640>>>>>>>        Handle hFile
88640>>>>>>>        Boolean bFieldExistsFrom bFieldExistsTo bIsSQLDriver bIsSame bOK bSkip
88640>>>>>>>        Boolean bRecnum bIsSQLTableTo bRecnumTable bIsOpen bSkipTypeChange bIsDateType
88640>>>>>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
88640>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
88640>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
88645>>>>>>>        tColumnType ColumnType
88645>>>>>>>        tColumnType ColumnType
88645>>>>>>>
88645>>>>>>>        Move False to Err
88646>>>>>>>        Close hTable
88647>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88648>>>>>>>        If (bIsOpen = False) Begin
88650>>>>>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
88651>>>>>>>>
88651>>>>>>>            Function_Return False
88652>>>>>>>        End 
88652>>>>>>>>
88652>>>>>>>        
88652>>>>>>>        Get piDbType to iDbType
88653>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
88656>>>>>>>        Move bIsSQLTableFrom to bIsSQLDriver
88657>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
88658>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
88661>>>>>>>
88661>>>>>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88662>>>>>>>
88662>>>>>>>        // Before we start to change the table we need to do three things;
88662>>>>>>>        // 1) Insert any new fields
88662>>>>>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
88663>>>>>>>        If (SizeOfArray(aApiInsertColumns)) Begin
88665>>>>>>>            Get UtilColumnsInsert sDriverIDFrom hTable aApiInsertColumns to bOK
88666>>>>>>>            If (bOK = False) Begin
88668>>>>>>>                Function_Return False
88669>>>>>>>            End
88669>>>>>>>>
88669>>>>>>>            // Update info with changes made.
88669>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88670>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88671>>>>>>>        End
88671>>>>>>>>
88671>>>>>>>
88671>>>>>>>        // 2) Move fields with same names
88671>>>>>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
88672>>>>>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
88674>>>>>>>            Get UtilColumnsMove hTable aColumnsFrom aColumnsTo aAPIMoveColumns to bOK
88675>>>>>>>            If (bOK = False) Begin
88677>>>>>>>                Function_Return False
88678>>>>>>>            End
88678>>>>>>>>
88678>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88679>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88680>>>>>>>        End
88680>>>>>>>>
88680>>>>>>>        
88680>>>>>>>        // 3) Rename fields
88680>>>>>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
88681>>>>>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
88683>>>>>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
88684>>>>>>>            If (bOK = False) Begin
88686>>>>>>>                Function_Return False
88687>>>>>>>            End
88687>>>>>>>>
88687>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88688>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88689>>>>>>>        End
88689>>>>>>>>
88689>>>>>>>
88689>>>>>>>        // Note: Fields will be removed if needed in the Structure_Start/End below.
88689>>>>>>>        // Get utilColumnsCheckForRemoves hTable aAPIColumnCompare to aAPIRemoveColumns
88689>>>>>>>
88689>>>>>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again:
88689>>>>>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
88691>>>>>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
88692>>>>>>>            If (bIsSame = True) Begin
88694>>>>>>>                Function_Return True
88695>>>>>>>            End
88695>>>>>>>>
88695>>>>>>>        End
88695>>>>>>>>
88695>>>>>>>
88695>>>>>>>        Move False to Err
88696>>>>>>>        // We can now continue to make standard field changes:
88696>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88697>>>>>>>        Set Private.phCurrentTable to hTable
88698>>>>>>>        Move hTable to hFile
88699>>>>>>>        Structure_Start hFile sDriverIDTo
88700>>>>>>>
88700>>>>>>>            Move (SizeOfArray(aAPIColumnCompare)) to iColumns
88701>>>>>>>            Decrement iColumns
88702>>>>>>>            for iCount from 0 to iColumns
88708>>>>>>>>
88708>>>>>>>                Send DoAdvance of ghoProgressBar
88709>>>>>>>
88709>>>>>>>                Move aAPIColumnCompare[iCount].iFieldNumber to iColumn
88710>>>>>>>                Set Private.piCurrentField                  to iColumn
88711>>>>>>>                Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom aAPIColumnCompare[iCount].bIsSQLTypeTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
88712>>>>>>>                If (bIsSame = False) Begin
88714>>>>>>>
88714>>>>>>>                    Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
88715>>>>>>>                    If (bFieldExistsFrom = True) Begin
88717>>>>>>>                        Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
88718>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
88719>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom
88720>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
88721>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
88722>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
88723>>>>>>>
88723>>>>>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
88724>>>>>>>                        If (iTypeFrom < -1490) Begin
88726>>>>>>>                            Move (iTypeFrom + 1500)                     to iTypeFrom
88727>>>>>>>                        End
88727>>>>>>>>
88727>>>>>>>
88727>>>>>>>                        // If one of the two tables are SQL and the other Embedded we need to "translate"
88727>>>>>>>                        // data types between Embedded and SQL, else we can't compare the data types.
88727>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
88729>>>>>>>                            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
88730>>>>>>>                            If (iTypeFrom = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88732>>>>>>>                                Move DF_DATE to iTypeFrom
88733>>>>>>>                            End
88733>>>>>>>>
88733>>>>>>>                        End
88733>>>>>>>>
88733>>>>>>>                        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
88736>>>>>>>                            Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
88737>>>>>>>                        End
88737>>>>>>>>
88737>>>>>>>
88737>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
88738>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
88739>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
88740>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
88741>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
88742>>>>>>>
88742>>>>>>>                        Move False to bSkipTypeChange
88743>>>>>>>                        If (bCompareDate_DateTime = False) Begin
88745>>>>>>>                            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
88746>>>>>>>                        End
88746>>>>>>>>
88746>>>>>>>
88746>>>>>>>                        If (bFieldExistsTo = False) Begin
88748>>>>>>>                            Move 0 to iColumn
88749>>>>>>>                            Create_Field hFile At iColumn
88750>>>>>>>                            Set Private.piCurrentField to iColumn
88751>>>>>>>                        End
88751>>>>>>>>
88751>>>>>>>
88751>>>>>>>                        If (sFieldNameFrom <> sFieldNameTo) Begin
88753>>>>>>>                            Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
88756>>>>>>>                        End
88756>>>>>>>>
88756>>>>>>>
88756>>>>>>>                        // Note: In MS-SQL it is vital that *nothing* gets changed for e.g. a "datetime" column, else error: 22018 is generated by the SQL backend:
88756>>>>>>>                        //       "Explicit conversion from data type int to datetime2 is not allowed", which will make the update to fail, and all changes for the table is rollbacked. 
88756>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity and bSkipTypeChange = False) Begin
88758>>>>>>>                            Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
88761>>>>>>>                            Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
88762>>>>>>>                            If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
88764>>>>>>>                                Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
88765>>>>>>>                            End
88765>>>>>>>>
88765>>>>>>>                            Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
88768>>>>>>>                        End
88768>>>>>>>>
88768>>>>>>>
88768>>>>>>>                        If (bSkipTypeChange = False) Begin
88770>>>>>>>                            If (iTypeFrom <> iTypeTo) Begin
88772>>>>>>>                                If (bIsSQLTableTo = True) Begin
88774>>>>>>>                                    Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iTypeFrom
88777>>>>>>>                                End
88777>>>>>>>>
88777>>>>>>>                                Else Begin                                                   
88778>>>>>>>                                    If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88780>>>>>>>                                        Move DF_DATE to iDataFlexType  // Date
88781>>>>>>>                                    End
88781>>>>>>>>
88781>>>>>>>                                    Set_Attribute DF_FIELD_TYPE of hFile iColumn to iDataFlexType
88784>>>>>>>                                End
88784>>>>>>>>
88784>>>>>>>                            End
88784>>>>>>>>
88784>>>>>>>                        End
88784>>>>>>>>
88784>>>>>>>
88784>>>>>>>                        Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType
88785>>>>>>>                        // We can't set the length or precision for Date type columns (they are fixed).
88785>>>>>>>                        If (bIsDateType = False and iLengthFrom <> iLengthTo) Begin
88787>>>>>>>                            Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
88790>>>>>>>                        End
88790>>>>>>>>
88790>>>>>>>                        // We do want to set the precision for e.g. DateTime2 (can be 3 or 7, but DataFlex can just handle "3").
88790>>>>>>>                        If (iPrecisionFrom <> iPrecisionTo) Begin
88792>>>>>>>                            Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
88795>>>>>>>                        End
88795>>>>>>>>
88795>>>>>>>
88795>>>>>>>                        If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
88797>>>>>>>                            // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
88797>>>>>>>                            If (bRecnumTable = True) Begin
88799>>>>>>>                                Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
88802>>>>>>>                            End
88802>>>>>>>>
88802>>>>>>>
88802>>>>>>>                            // We might need to create an index here.
88802>>>>>>>                            // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
88802>>>>>>>                            // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
88802>>>>>>>                            // index update checking logic.
88802>>>>>>>                            Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
88805>>>>>>>                            If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
88807>>>>>>>                                Create_Index hFile at iIndex
88808>>>>>>>                                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
88811>>>>>>>                            End
88811>>>>>>>>
88811>>>>>>>
88811>>>>>>>                            Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
88814>>>>>>>                            Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
88817>>>>>>>                                // Note: The order here is crucial!
88817>>>>>>>                                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
88820>>>>>>>                                Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
88823>>>>>>>                        End
88823>>>>>>>>
88823>>>>>>>                    End
88823>>>>>>>>
88823>>>>>>>                    Else Begin
88824>>>>>>>                        Delete_Field hFile iColumn
88825>>>>>>>                        Move (RemoveFromArray(aColumnsTo, iCount)) to aColumnsTo
88826>>>>>>>                        Move (SizeOfArray(aColumnsTo)) to iCount2
88827>>>>>>>                        Decrement iCount2
88828>>>>>>>                        // We need to adjust FieldNumbers in the array with one, as we just deleted a field,
88828>>>>>>>                        // starting with the array number we just deleted the field for.
88828>>>>>>>                        for iColumn2 from iCount to iCount2
88834>>>>>>>>
88834>>>>>>>                            Move (aColumnsTo[iColumn2].iFieldNumber - 1) to aColumnsTo[iColumn2].iFieldNumber
88835>>>>>>>                        Loop
88836>>>>>>>>
88836>>>>>>>                        Decrement iCount
88837>>>>>>>                        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88838>>>>>>>                        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
88839>>>>>>>                        If (SizeOfArray(aColumnsFrom) = SizeOfArray(aColumnsTo)) Begin
88841>>>>>>>                            Move iColumns to iCount 
88842>>>>>>>                        End
88842>>>>>>>>
88842>>>>>>>                    End
88842>>>>>>>>
88842>>>>>>>                End 
88842>>>>>>>>
88842>>>>>>>                If (Err = True) Begin 
88844>>>>>>>                    Move False to bOK
88845>>>>>>>                    Move iColumns to iCount
88846>>>>>>>                End
88846>>>>>>>>
88846>>>>>>>            Loop
88847>>>>>>>>
88847>>>>>>>
88847>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructuring table..."
88848>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88850>>>>>>>
88850>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88851>>>>>>>        Function_Return (Not(Err))
88852>>>>>>>    End_Function
88853>>>>>>>
88853>>>>>>>    // * Dummy function for the Studio's Code Explorer *
88853>>>>>>>    Function API_INDEX_FUNCTIONS Returns Boolean
88855>>>>>>>        Function_Return False
88856>>>>>>>    End_Function
88857>>>>>>>
88857>>>>>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
88857>>>>>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
88857>>>>>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
88857>>>>>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
88859>>>>>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10  iIndexSegments
88859>>>>>>>        String sDriverID
88859>>>>>>>        Boolean bOK bExists bIsSQLTable
88859>>>>>>>
88859>>>>>>>        Get AutoConnectionIDLogin to bOK
88860>>>>>>>        Get OpenTableExclusive hTable to bOK
88861>>>>>>>        If (bOK = False) Begin
88863>>>>>>>            Function_Return False
88864>>>>>>>        End
88864>>>>>>>>
88864>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88867>>>>>>>
88867>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88868>>>>>>>            If (bIsSQLTable = True) Begin
88870>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88873>>>>>>>            End
88873>>>>>>>>
88873>>>>>>>
88873>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iIndexSegments
88876>>>>>>>        Move (iIndexSegments > 0) to bExists
88877>>>>>>>        If (bExists = True) Begin
88879>>>>>>>            Function_Return True
88880>>>>>>>        End
88880>>>>>>>>
88880>>>>>>>
88880>>>>>>>        Move -1 to iSegment1
88881>>>>>>>        Move -1 to iSegment2
88882>>>>>>>        Move -1 to iSegment3
88883>>>>>>>        Move -1 to iSegment4
88884>>>>>>>        Move -1 to iSegment5
88885>>>>>>>        Move -1 to iSegment6
88886>>>>>>>        Move -1 to iSegment7
88887>>>>>>>        Move -1 to iSegment8
88888>>>>>>>        Move -1 to iSegment9
88889>>>>>>>        Move -1 to iSegment10
88890>>>>>>>
88890>>>>>>>        If (num_arguments > 3) Begin
88892>>>>>>>            Move iSgmnt1 to iSegment1
88893>>>>>>>        End
88893>>>>>>>>
88893>>>>>>>        If (num_arguments > 4) Begin
88895>>>>>>>            Move iSgmnt2 to iSegment2
88896>>>>>>>        End
88896>>>>>>>>
88896>>>>>>>        If (num_arguments > 5) Begin
88898>>>>>>>            Move iSgmnt3 to iSegment3
88899>>>>>>>        End
88899>>>>>>>>
88899>>>>>>>        If (num_arguments > 6) Begin
88901>>>>>>>            Move iSgmnt4 to iSegment4
88902>>>>>>>        End
88902>>>>>>>>
88902>>>>>>>        If (num_arguments > 7) Begin
88904>>>>>>>            Move iSgmnt5 to iSegment5
88905>>>>>>>        End
88905>>>>>>>>
88905>>>>>>>        If (num_arguments > 8) Begin
88907>>>>>>>            Move iSgmnt6 to iSegment6
88908>>>>>>>        End
88908>>>>>>>>
88908>>>>>>>        If (num_arguments > 9) Begin
88910>>>>>>>            Move iSgmnt7 to iSegment7
88911>>>>>>>        End
88911>>>>>>>>
88911>>>>>>>        If (num_arguments > 10) Begin
88913>>>>>>>            Move iSgmnt8 to iSegment8
88914>>>>>>>        End
88914>>>>>>>>
88914>>>>>>>        If (num_arguments > 11) Begin
88916>>>>>>>            Move iSgmnt9 to iSegment9
88917>>>>>>>        End
88917>>>>>>>>
88917>>>>>>>        If (num_arguments > 12) Begin
88919>>>>>>>            Move iSgmnt10 to iSegment10
88920>>>>>>>        End
88920>>>>>>>>
88920>>>>>>>
88920>>>>>>>        Move False to Err
88921>>>>>>>        Move hTable to iTableNo
88922>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88923>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88924>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88925>>>>>>>
88925>>>>>>>        // We start by deleting the index, if it exists.
88925>>>>>>>        If (bExists = True) Begin
88927>>>>>>>            Structure_Start hTable sDriverID
88928>>>>>>>                Delete_Index iTableNo iIndex
88929>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88930>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88932>>>>>>>        End
88932>>>>>>>>
88932>>>>>>>
88932>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88933>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88934>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88935>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88936>>>>>>>        Move False to Err
88937>>>>>>>        Move 0 to LastErr
88938>>>>>>>
88938>>>>>>>        // Need to re-open if index deleted.
88938>>>>>>>        Move iTableNo to hTable
88939>>>>>>>        Get OpenTableExclusive hTable to bOK
88940>>>>>>>        If (bOK = False) Begin
88942>>>>>>>            Function_Return False
88943>>>>>>>        End
88943>>>>>>>>
88943>>>>>>>
88943>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88944>>>>>>>        Structure_Start hTable sDriverID
88945>>>>>>>            Create_Index hTable At iIndex
88946>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
88949>>>>>>>
88949>>>>>>>            If (iSgmnt1 <> -1) Begin
88951>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
88954>>>>>>>            End
88954>>>>>>>>
88954>>>>>>>            If (iSegment2 <> -1) Begin
88956>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
88959>>>>>>>            End
88959>>>>>>>>
88959>>>>>>>            If (iSegment3 <> -1) Begin
88961>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
88964>>>>>>>            End
88964>>>>>>>>
88964>>>>>>>            If (iSegment4 <> -1) Begin
88966>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
88969>>>>>>>            End
88969>>>>>>>>
88969>>>>>>>            If (iSegment5 <> -1) Begin
88971>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
88974>>>>>>>            End
88974>>>>>>>>
88974>>>>>>>            If (iSegment6 <> -1) Begin
88976>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
88979>>>>>>>            End
88979>>>>>>>>
88979>>>>>>>            If (iSegment7 <> -1) Begin
88981>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
88984>>>>>>>            End
88984>>>>>>>>
88984>>>>>>>            If (iSegment8 <> -1) Begin
88986>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
88989>>>>>>>            End
88989>>>>>>>>
88989>>>>>>>            If (iSegment9 <> -1) Begin
88991>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
88994>>>>>>>            End
88994>>>>>>>>
88994>>>>>>>            If (iSegment10 <> -1) Begin
88996>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
88999>>>>>>>            End
88999>>>>>>>>
88999>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89000>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89002>>>>>>>
89002>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89003>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89004>>>>>>>
89004>>>>>>>        Function_Return (Err = False)
89005>>>>>>>    End_Function
89006>>>>>>>
89006>>>>>>>    // Example:
89006>>>>>>>    // Get ApiIndexCreateEx hTable 1 (StrSplitToArray("1,5,6,7,8,2,3,4,10,9,11", ",")) to bOk
89006>>>>>>>    // Note: The StrSplitToArray function was introduced with DataFlex 18.2
89006>>>>>>>    Function ApiIndexCreateEx Handle hTable Integer iIndex Integer[] iSgmnts Returns Boolean
89008>>>>>>>        Integer iTableNo iNumSgmnt iNumSgmnts
89008>>>>>>>        String sDriverID
89008>>>>>>>        Boolean bOK bIsSQLTable
89008>>>>>>>
89008>>>>>>>        Get AutoConnectionIDLogin to bOK
89009>>>>>>>
89009>>>>>>>        Move False to Err
89010>>>>>>>        Move hTable to iTableNo
89011>>>>>>>        Get OpenTableExclusive hTable to bOK
89012>>>>>>>        If (bOK = False) Begin
89014>>>>>>>            Function_Return False
89015>>>>>>>        End
89015>>>>>>>>
89015>>>>>>>
89015>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89018>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89019>>>>>>>            If (bIsSQLTable = True) Begin
89021>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89024>>>>>>>            End
89024>>>>>>>>
89024>>>>>>>
89024>>>>>>>        // We start by deleting the index
89024>>>>>>>        Structure_Start hTable sDriverID
89025>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89026>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
89027>>>>>>>            Delete_Index iTableNo iIndex
89028>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
89029>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
89030>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
89032>>>>>>>
89032>>>>>>>        Move False to Err
89033>>>>>>>        Move iTableNo to hTable
89034>>>>>>>        Get OpenTableExclusive hTable to bOK
89035>>>>>>>        If (bOK = False) Begin
89037>>>>>>>            Function_Return False
89038>>>>>>>        End
89038>>>>>>>>
89038>>>>>>>
89038>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89039>>>>>>>        Structure_Start hTable sDriverID
89040>>>>>>>            Move (SizeOfArray(iSgmnts)) to iNumSgmnts
89041>>>>>>>
89041>>>>>>>            Create_Index hTable at iIndex
89042>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSgmnts
89045>>>>>>>
89045>>>>>>>            for iNumSgmnt from 0 to (iNumSgmnts - 1)
89051>>>>>>>>
89051>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iNumSgmnt + 1) to iSgmnts[iNumSgmnt]
89054>>>>>>>            Loop
89055>>>>>>>>
89055>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
89057>>>>>>>
89057>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89058>>>>>>>
89058>>>>>>>        Function_Return (Err = False)
89059>>>>>>>    End_Function
89060>>>>>>>
89060>>>>>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
89062>>>>>>>        Integer iCount iSegmentsFrom iFieldFrom iSegmentsTo iSQLIndexType iTableNo
89062>>>>>>>        String sDriverID sSQLIndexName
89062>>>>>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
89062>>>>>>>
89062>>>>>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
89063>>>>>>>        If (iSegmentsFrom = 0) Begin
89065>>>>>>>            Function_Return False
89066>>>>>>>        End
89066>>>>>>>>
89066>>>>>>>
89066>>>>>>>        Get AutoConnectionIDLogin to bOK
89067>>>>>>>        Move False to Err
89068>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
89069>>>>>>>        If (bIsOpen = False) Begin
89071>>>>>>>            Function_Return False
89072>>>>>>>        End
89072>>>>>>>>
89072>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89075>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
89076>>>>>>>            If (bIsSQLTable = True) Begin
89078>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89081>>>>>>>            End
89081>>>>>>>>
89081>>>>>>>
89081>>>>>>>        Move 0     to iSegmentsTo
89082>>>>>>>        Move 0     to iSQLIndexType
89083>>>>>>>        Move ""    to sSQLIndexName
89084>>>>>>>        Move False to bIsSQLTemporaryIndex
89085>>>>>>>        Move False to bIsSQLPrimaryKey
89086>>>>>>>        Move False to bIsSQLClustered
89087>>>>>>>
89087>>>>>>>            Get UtilIndexTempRenameSQLName hTable APIIndex.sSQLIndexName sDriverID          to bOK
89088>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber              to iSegmentsTo
89091>>>>>>>        Move (iSegmentsTo > 0) to bExists
89092>>>>>>>        If (bExists = True) Begin
89094>>>>>>>            If (bIsSQLTable = True and iSegmentsTo > 0) Begin
89096>>>>>>>//                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber                 to sSQLIndexName
89096>>>>>>>                Move APIIndex.sSQLIndexName                                                 to sSQLIndexName
89097>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
89100>>>>>>>                        Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
89101>>>>>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
89104>>>>>>>                    Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
89107>>>>>>>            End
89107>>>>>>>>
89107>>>>>>>        End
89107>>>>>>>>
89107>>>>>>>
89107>>>>>>>        Move hTable to iTableNo
89108>>>>>>>        Move False to Err
89109>>>>>>>        Move 0 to LastErr
89110>>>>>>>
89110>>>>>>>        Structure_Start hTable sDriverID
89111>>>>>>>            If (bExists = True) Begin
89113>>>>>>>                Delete_Index iTableNo APIIndex.iIndexNumber
89114>>>>>>>            End
89114>>>>>>>>
89114>>>>>>>
89114>>>>>>>            Create_Index hTable At APIIndex.iIndexNumber
89115>>>>>>>
89115>>>>>>>                If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
89117>>>>>>>                    Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType
89120>>>>>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
89123>>>>>>>                    Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
89126>>>>>>>                    Set_Attribute DF_INDEX_NAME            of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
89129>>>>>>>                End
89129>>>>>>>>
89129>>>>>>>
89129>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
89132>>>>>>>
89132>>>>>>>            for iCount from 0 to (iSegmentsFrom -1)
89138>>>>>>>>
89138>>>>>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom
89139>>>>>>>                If (iFieldFrom <> -1 ) Begin
89141>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
89144>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bAscending
89147>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bUppercase
89150>>>>>>>                End
89150>>>>>>>>
89150>>>>>>>            Loop
89151>>>>>>>>
89151>>>>>>>
89151>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89152>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89154>>>>>>>
89154>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89155>>>>>>>
89155>>>>>>>        Function_Return (Err = False)
89156>>>>>>>    End_Function
89157>>>>>>>
89157>>>>>>>    // If an SQL index is to be renamed we need to check that the name doesn't exist already, but
89157>>>>>>>    // with another index number. If we find one we temporarily renames it by adding "TMP" to the SQL name.
89157>>>>>>>    Function UtilIndexTempRenameSQLName Handle hTable String sSQLIndexName String sDriverID Returns Boolean
89159>>>>>>>        Integer iLastIndex iCount iTableNo iSegments
89159>>>>>>>        String sSQLIndexNameCompare sTmpIndexName
89159>>>>>>>        Boolean bIsOpen bExists bIsSQLDriver 
89159>>>>>>>
89159>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
89160>>>>>>>        
89160>>>>>>>        If (bIsSQLDriver = False) Begin
89162>>>>>>>            Function_Return False
89163>>>>>>>        End
89163>>>>>>>>
89163>>>>>>>
89163>>>>>>>        Move False to Err
89164>>>>>>>        Move hTable to iTableNo
89165>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
89168>>>>>>>        for iCount from 0 to iLastIndex
89174>>>>>>>>
89174>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iSegments
89177>>>>>>>            Move (iSegments > 0) to bExists
89178>>>>>>>            If (bExists = True) Begin
89180>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable iCount to sSQLIndexNameCompare
89183>>>>>>>                If (Lowercase(sSQLIndexName) = Lowercase(sSQLIndexNameCompare)) Begin
89185>>>>>>>                    Move (sSQLIndexNameCompare + String("_TMP")) to sTmpIndexName
89186>>>>>>>                    Structure_Start iTableNo sDriverID
89187>>>>>>>                        Set_Attribute DF_INDEX_NAME of iTableNo iCount to sTmpIndexName
89190>>>>>>>                    Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89192>>>>>>>                    Open hTable
89194>>>>>>>                End
89194>>>>>>>>
89194>>>>>>>            End
89194>>>>>>>>
89194>>>>>>>        Loop
89195>>>>>>>>
89195>>>>>>>
89195>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89198>>>>>>>        If (bIsOpen = False) Begin
89200>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
89201>>>>>>>        End
89201>>>>>>>>
89201>>>>>>>        If (bIsOpen = False) Begin
89203>>>>>>>            Function_Return False
89204>>>>>>>        End
89204>>>>>>>>
89204>>>>>>>
89204>>>>>>>        Function_Return (Err = False)
89205>>>>>>>    End_Function
89206>>>>>>>
89206>>>>>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
89206>>>>>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
89206>>>>>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
89208>>>>>>>        Integer iSize iCount
89208>>>>>>>        Integer iRetVal
89208>>>>>>>
89208>>>>>>>        Move 0 to iRetVal
89209>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
89212>>>>>>>        If (iRetVal = 0) Begin
89214>>>>>>>            Function_Return 0
89215>>>>>>>        End
89215>>>>>>>>
89215>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSize
89216>>>>>>>        Decrement iSize
89217>>>>>>>        for iCount from 0 to iSize
89223>>>>>>>>
89223>>>>>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
89225>>>>>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
89227>>>>>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
89228>>>>>>>                End
89228>>>>>>>>
89228>>>>>>>            End
89228>>>>>>>>
89228>>>>>>>        Loop
89229>>>>>>>>
89229>>>>>>>
89229>>>>>>>        Function_Return iRetVal
89230>>>>>>>    End_Function
89231>>>>>>>
89231>>>>>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
89233>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
89233>>>>>>>        Boolean bIsSQLTable
89233>>>>>>>        
89233>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89234>>>>>>>            If (bIsSQLTable = True) Begin
89236>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89239>>>>>>>            End
89239>>>>>>>>
89239>>>>>>>
89239>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89242>>>>>>>        If (iSegment = iNumSegments) Begin
89244>>>>>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89244>>>>>>>        End
89244>>>>>>>>
89244>>>>>>>
89244>>>>>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89247>>>>>>>            for iCurSegment from iSegment to (iNumSegments - 1)
89253>>>>>>>>
89253>>>>>>>                //*** Move index segment attributes
89253>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89256>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
89259>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
89262>>>>>>>
89262>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
89265>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
89268>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
89271>>>>>>>            Loop
89272>>>>>>>>
89272>>>>>>>
89272>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89275>>>>>>>        End
89275>>>>>>>>
89275>>>>>>>
89275>>>>>>>        Function_Return (Err = False)
89276>>>>>>>    End_Function
89277>>>>>>>
89277>>>>>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
89279>>>>>>>        Integer iCount iSize iIndex
89279>>>>>>>        String sDriverID
89279>>>>>>>        Boolean bOK bIsSQLTable bIsOpen
89279>>>>>>>
89279>>>>>>>        Move (SizeOfArray(APIIndex)) to iSize
89280>>>>>>>        If (iSize = 0) Begin
89282>>>>>>>            Function_Return True
89283>>>>>>>        End
89283>>>>>>>>
89283>>>>>>>
89283>>>>>>>        Get AutoConnectionIDLogin to bOK
89284>>>>>>>        Move False to Err
89285>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89288>>>>>>>        If (bIsOpen = False) Begin
89290>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
89291>>>>>>>            If (bIsOpen = False) Begin
89293>>>>>>>                Function_Return False
89294>>>>>>>            End
89294>>>>>>>>
89294>>>>>>>        End
89294>>>>>>>>
89294>>>>>>>
89294>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89297>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
89298>>>>>>>            If (bIsSQLTable = True) Begin
89300>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89303>>>>>>>            End
89303>>>>>>>>
89303>>>>>>>
89303>>>>>>>        Move False to Err
89304>>>>>>>        Move 0 to LastErr
89305>>>>>>>        Decrement iSize
89306>>>>>>>
89306>>>>>>>        Structure_Start hTable sDriverID
89307>>>>>>>            for iCount from 0 to iSize
89313>>>>>>>>
89313>>>>>>>//                Move False to bIsSQLPrimaryKey
89313>>>>>>>//                #IF (!@ > 180)   // DF 18.1 and up
89313>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89313>>>>>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
89313>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
89313>>>>>>>//                #ENDIF
89313>>>>>>>                // We can't delete if this is a primary key index:
89313>>>>>>>//                If (bIsSQLPrimaryKey = False) Begin
89313>>>>>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
89314>>>>>>>                    Delete_Index hTable iIndex
89315>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
89315>>>>>>>//                End
89315>>>>>>>            Loop
89316>>>>>>>>
89316>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89317>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89319>>>>>>>//        Move False to Err
89319>>>>>>>        Move 0 to LastErr
89320>>>>>>>
89320>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89321>>>>>>>        Function_Return (Err = False)
89322>>>>>>>    End_Function
89323>>>>>>>
89323>>>>>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
89325>>>>>>>        Boolean bOK
89325>>>>>>>
89325>>>>>>>        Get AutoConnectionIDLogin to bOK
89326>>>>>>>        Move False to Err
89327>>>>>>>        Get OpenTableExclusive hTable to bOK
89328>>>>>>>        If (bOK = False) Begin
89330>>>>>>>            Function_Return False
89331>>>>>>>        End
89331>>>>>>>>
89331>>>>>>>        Structure_Start hTable
89332>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
89335>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89336>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89338>>>>>>>
89338>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89339>>>>>>>        Function_Return (Err = False)
89340>>>>>>>    End_Function
89341>>>>>>>
89341>>>>>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
89343>>>>>>>        Integer iCase
89343>>>>>>>        Boolean bOK
89343>>>>>>>
89343>>>>>>>        If (bUppercase = True) Begin
89345>>>>>>>            Move DF_CASE_IGNORED to iCase
89346>>>>>>>        End
89346>>>>>>>>
89346>>>>>>>        Else Begin
89347>>>>>>>            Move DF_CASE_USED to iCase
89348>>>>>>>        End
89348>>>>>>>>
89348>>>>>>>
89348>>>>>>>        Get AutoConnectionIDLogin to bOK
89349>>>>>>>        Move False to Err
89350>>>>>>>        Get OpenTableExclusive hTable to bOK
89351>>>>>>>        If (bOK = False) Begin
89353>>>>>>>            Function_Return False
89354>>>>>>>        End
89354>>>>>>>>
89354>>>>>>>        Structure_Start hTable
89355>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
89358>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89359>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89361>>>>>>>
89361>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89362>>>>>>>        Function_Return (Err = False)
89363>>>>>>>    End_Function
89364>>>>>>>
89364>>>>>>>    // To delete an index
89364>>>>>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
89366>>>>>>>        Integer iTableNo iNumSegments
89366>>>>>>>        String sDriverID
89366>>>>>>>        Boolean bOK bIsSQLTable
89366>>>>>>>
89366>>>>>>>        Get AutoConnectionIDLogin to bOK
89367>>>>>>>        Move False to Err
89368>>>>>>>        Move hTable to iTableNo
89369>>>>>>>        Get OpenTableExclusive hTable to bOK
89370>>>>>>>        If (bOK = False) Begin
89372>>>>>>>            Function_Return False
89373>>>>>>>        End
89373>>>>>>>>
89373>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89376>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89377>>>>>>>            If (bIsSQLTable = True) Begin
89379>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89382>>>>>>>            End
89382>>>>>>>>
89382>>>>>>>
89382>>>>>>>        // Check to see if the index exists or not...
89382>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89385>>>>>>>        If (iNumSegments = 0) Begin
89387>>>>>>>            Function_Return True // Then nothing to do.
89388>>>>>>>        End
89388>>>>>>>>
89388>>>>>>>
89388>>>>>>>        Structure_Start hTable sDriverID
89389>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
89390>>>>>>>            Delete_Index iTableNo iIndex
89391>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
89392>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89393>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89395>>>>>>>
89395>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89396>>>>>>>        Function_Return (Err = False)
89397>>>>>>>    End_Function
89398>>>>>>>
89398>>>>>>>    // Delete an Index Segment
89398>>>>>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
89400>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
89400>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
89400>>>>>>>        Integer iIndexType
89400>>>>>>>        String sDriverID
89400>>>>>>>
89400>>>>>>>        Get AutoConnectionIDLogin to bOK
89401>>>>>>>        Move False to Err
89402>>>>>>>
89402>>>>>>>        Get OpenTableExclusive hTable to bOK
89403>>>>>>>        If (bOK = False) Begin
89405>>>>>>>            Function_Return False
89406>>>>>>>        End
89406>>>>>>>>
89406>>>>>>>
89406>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89407>>>>>>>            If (bIsSQLTable = True) Begin
89409>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89412>>>>>>>            End
89412>>>>>>>>
89412>>>>>>>
89412>>>>>>>        // Check to see if the index exists or not...
89412>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89415>>>>>>>        If (iNumSegments = 0) Begin
89417>>>>>>>            Function_Return False
89418>>>>>>>        End
89418>>>>>>>>
89418>>>>>>>
89418>>>>>>>        Move False to bIndexTemporary
89419>>>>>>>        Get psDriverID to sDriverID
89420>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
89421>>>>>>>        If (bSQLDriver) Begin
89423>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
89426>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
89429>>>>>>>                Move True to bIndexTemporary
89430>>>>>>>        End
89430>>>>>>>>
89430>>>>>>>
89430>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
89430>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
89432>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89435>>>>>>>            If (iSegment = iNumSegments) Begin
89437>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89440>>>>>>>            End
89440>>>>>>>>
89440>>>>>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89443>>>>>>>                For iCurSegment from iSegment to (iNumSegments - 1)
89449>>>>>>>>
89449>>>>>>>                    //*** Move index segment attributes
89449>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89452>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
89455>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
89458>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89461>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89464>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89467>>>>>>>                Loop
89468>>>>>>>>
89468>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89471>>>>>>>            End
89471>>>>>>>>
89471>>>>>>>        End
89471>>>>>>>>
89471>>>>>>>
89471>>>>>>>        Else Begin
89472>>>>>>>           Structure_Start hTable
89473>>>>>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89476>>>>>>>               If (iSegment = iNumSegments) Begin
89478>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89481>>>>>>>               End
89481>>>>>>>>
89481>>>>>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89484>>>>>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
89490>>>>>>>>
89490>>>>>>>                       //*** Move index segment attributes
89490>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89493>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
89496>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
89499>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89502>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89505>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89508>>>>>>>                   Loop
89509>>>>>>>>
89509>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89512>>>>>>>               End
89512>>>>>>>>
89512>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
89513>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89515>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89516>>>>>>>        End
89516>>>>>>>>
89516>>>>>>>
89516>>>>>>>        Function_Return (Err = False)
89517>>>>>>>    End_Function
89518>>>>>>>
89518>>>>>>>    // Add/Insert an Index Segment
89518>>>>>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
89520>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
89520>>>>>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
89520>>>>>>>        Integer iIndexType
89520>>>>>>>        String sDriverId
89520>>>>>>>
89520>>>>>>>        Get AutoConnectionIDLogin to bOK
89521>>>>>>>        Move False to Err
89522>>>>>>>
89522>>>>>>>        Get OpenTableExclusive hTable to bOK
89523>>>>>>>        If (bOK = False) Begin
89525>>>>>>>            Function_Return False
89526>>>>>>>        End
89526>>>>>>>>
89526>>>>>>>
89526>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89527>>>>>>>            If (bIsSQLTable = True) Begin
89529>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89532>>>>>>>            End
89532>>>>>>>>
89532>>>>>>>
89532>>>>>>>        Move False to bIndexTemporary
89533>>>>>>>        // Check to see if the index exists or not...
89533>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89536>>>>>>>        If (iNumSegments = 0) Begin
89538>>>>>>>            Function_Return False
89539>>>>>>>        End
89539>>>>>>>>
89539>>>>>>>
89539>>>>>>>        Get psDriverID to sDriverID
89540>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
89541>>>>>>>        If (bSQLDriver) Begin
89543>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
89546>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
89549>>>>>>>                Move True to bIndexTemporary
89550>>>>>>>        End
89550>>>>>>>>
89550>>>>>>>
89550>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
89550>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
89552>>>>>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89555>>>>>>>
89555>>>>>>>           If (iSegment > iNumSegments) Begin
89557>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89560>>>>>>>               Move (iNumSegments + 1) to iCurSegment
89561>>>>>>>           End
89561>>>>>>>>
89561>>>>>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
89564>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89567>>>>>>>               Move iNumSegments to iCurSegment
89568>>>>>>>
89568>>>>>>>               While (iCurSegment > iSegment)
89572>>>>>>>                   //*** Move index segment attributes
89572>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
89575>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
89578>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
89581>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
89584>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
89587>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
89590>>>>>>>                   Decrement iCurSegment
89591>>>>>>>               Loop
89592>>>>>>>>
89592>>>>>>>
89592>>>>>>>               //*** Now set new segment attributes
89592>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
89595>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
89598>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
89601>>>>>>>           End
89601>>>>>>>>
89601>>>>>>>        End
89601>>>>>>>>
89601>>>>>>>
89601>>>>>>>        Else Begin
89602>>>>>>>        Structure_Start hTable
89603>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89606>>>>>>>
89606>>>>>>>            If (iSegment > iNumSegments) Begin
89608>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89611>>>>>>>                Move (iNumSegments + 1) to iCurSegment
89612>>>>>>>            End
89612>>>>>>>>
89612>>>>>>>            Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
89615>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89618>>>>>>>                Move iNumSegments to iCurSegment
89619>>>>>>>
89619>>>>>>>                While (iCurSegment > iSegment)
89623>>>>>>>                    //*** Move index segment attributes
89623>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
89626>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
89629>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
89632>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89635>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89638>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89641>>>>>>>                    Decrement iCurSegment
89642>>>>>>>                Loop
89643>>>>>>>>
89643>>>>>>>
89643>>>>>>>                //*** Now set new segment attributes
89643>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
89646>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
89649>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
89652>>>>>>>            End
89652>>>>>>>>
89652>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89653>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89655>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89656>>>>>>>        End
89656>>>>>>>>
89656>>>>>>>
89656>>>>>>>        Function_Return (Err = False)
89657>>>>>>>    End_Function
89658>>>>>>>
89658>>>>>>>    // * Dummy function for the Studio's Code Explorer *
89658>>>>>>>    Function TABLE_UTILITY_FUNCTIONS Returns Boolean
89660>>>>>>>        Function_Return False
89661>>>>>>>    End_Function  
89662>>>>>>>    
89662>>>>>>>    // Preparation message before an SQL onversion. It will check and wash all embedded data tables and prepare them
89662>>>>>>>    // for an SQL conversion.
89662>>>>>>>    Function UtilPrepareDataFolderForSQLConversion Boolean bMoveMiscFilesToBackup Boolean bFixALLBogusFilelistEntries Boolean bConvertTo30Format Boolean bRepairAndReindex Boolean bFixBogusDates Returns Boolean
89664>>>>>>>        Boolean bConvertTo30FormatbOK bRepairAndReindexOK bFixBogusDatesOK bMoveMiscFilesToBackupOK
89664>>>>>>>        
89664>>>>>>>        Move True to bConvertTo30FormatbOK
89665>>>>>>>        Move True to bRepairAndReindexOK
89666>>>>>>>        Move True to bFixBogusDatesOK
89667>>>>>>>        Move True to bMoveMiscFilesToBackupOK
89668>>>>>>>        
89668>>>>>>>        If (bMoveMiscFilesToBackup = True) Begin   
89670>>>>>>>            Set Message_Text of ghoStatusPanel to "Moving misc. files to backup..."
89671>>>>>>>            Get UtilMoveMiscFilesToBackupFolder to bMoveMiscFilesToBackupOK
89672>>>>>>>        End                                                                                
89672>>>>>>>>
89672>>>>>>>        If (bFixALLBogusFilelistEntries = True) Begin
89674>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus Filelist.cfg entries..."
89675>>>>>>>            Get UtilTableFixALLBogusFilelistEntries to bFixALLBogusFilelistEntries
89676>>>>>>>        End
89676>>>>>>>>
89676>>>>>>>        If (bConvertTo30Format = True) Begin
89678>>>>>>>            Set Message_Text of ghoStatusPanel to "Converting .dat files from 2.3->..."
89679>>>>>>>            Get UtilTableConvertALLTablesFrom23Format to bConvertTo30FormatbOK
89680>>>>>>>        End                                                 
89680>>>>>>>>
89680>>>>>>>        If (bRepairAndReindex = True) Begin
89682>>>>>>>            Set Message_Text of ghoStatusPanel to "Repairing and reindexing..."
89683>>>>>>>            Get UtilTableRepairAndReindexALL to bRepairAndReindexOK
89684>>>>>>>        End  
89684>>>>>>>>
89684>>>>>>>        If (bFixBogusDates = True) Begin
89686>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
89687>>>>>>>            Get UtilTablesFixAllDateBogusValues True False to bFixBogusDatesOK
89688>>>>>>>        End                                    
89688>>>>>>>>
89688>>>>>>>        
89688>>>>>>>        Function_Return (bConvertTo30FormatbOK = True and bFixALLBogusFilelistEntries = True and bRepairAndReindexOK = True and bFixBogusDatesOK = True and bMoveMiscFilesToBackupOK = True)
89689>>>>>>>    End_Function
89690>>>>>>>
89690>>>>>>>    Function UtilTableConvertALLTablesFrom23Format Returns Boolean
89692>>>>>>>        Boolean bOK bFlexErrs bTemp
89692>>>>>>>        Handle hTable
89692>>>>>>>        String sTableName
89692>>>>>>>        Integer iCount iSize
89692>>>>>>>        
89692>>>>>>>        Move True to bOK
89693>>>>>>>        Move 0 to hTable    
89694>>>>>>>
89694>>>>>>>        Get UtilFilelistNoOfTables to iSize
89695>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89696>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89697>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89698>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89699>>>>>>>
89699>>>>>>>        Repeat
89699>>>>>>>>
89699>>>>>>>            Set Action_Text of ghoStatusPanel to "Checking if table is in 2.3 format..."
89700>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount  
89701>>>>>>>            Increment iCount
89702>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89705>>>>>>>            If (hTable > 0) Begin
89707>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89710>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
89711>>>>>>>                If (bFlexErrs = False) Begin
89713>>>>>>>                    Get UtilTableConvertFrom23Format hTable to bTemp
89714>>>>>>>                    If (bTemp = False) Begin
89716>>>>>>>                        Move False to bOK
89717>>>>>>>                    End
89717>>>>>>>>
89717>>>>>>>                End
89717>>>>>>>>
89717>>>>>>>            End
89717>>>>>>>>
89717>>>>>>>        Until (hTable = 0)
89719>>>>>>>        
89719>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89720>>>>>>>        Function_Return bOK
89721>>>>>>>    End_Function
89722>>>>>>>    
89722>>>>>>>    // Converts an embedded table from 2.3 -> 3.0.
89722>>>>>>>    // Returns: FALSE only if the table can't be opened or the conversion fails.
89722>>>>>>>    // It will return a TRUE if successful or the table is an SQL table.
89722>>>>>>>    Function UtilTableConvertFrom23Format Handle hTable Returns Boolean
89724>>>>>>>        Boolean bOK bIsEmbedded bIsAlias
89724>>>>>>>        String sRevision
89724>>>>>>>        
89724>>>>>>>        Get AutoConnectionIDLogin to bOK
89725>>>>>>>        If (bOK = False) Begin
89727>>>>>>>            Function_Return True
89728>>>>>>>        End
89728>>>>>>>>
89728>>>>>>>        Get OpenTableExclusive hTable to bOK
89729>>>>>>>        If (bOK = False) Begin
89731>>>>>>>            Function_Return True
89732>>>>>>>        End
89732>>>>>>>>
89732>>>>>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
89733>>>>>>>        If (bIsEmbedded = False) Begin
89735>>>>>>>            Function_Return True
89736>>>>>>>        End                             
89736>>>>>>>>
89736>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
89737>>>>>>>        If (bIsAlias = True) Begin
89739>>>>>>>            Function_Return True
89740>>>>>>>        End                     
89740>>>>>>>>
89740>>>>>>>        
89740>>>>>>>        Move False to Err
89741>>>>>>>        Get_Attribute DF_FILE_REVISION of hTable to sRevision
89744>>>>>>>        If (sRevision contains "2.3") Begin
89746>>>>>>>            Move False to Err
89747>>>>>>>            Set Private.phCurrentTable to hTable
89748>>>>>>>            Structure_Start hTable    
89749>>>>>>>                Set_Attribute DF_FILE_INTEGRITY_CHECK of hTable to True
89752>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table to 3.0/4.0"
89753>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
89755>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89756>>>>>>>        End
89756>>>>>>>>
89756>>>>>>>        
89756>>>>>>>        Function_Return (Err = False)
89757>>>>>>>    End_Function
89758>>>>>>>
89758>>>>>>>    Function UtilTableFixALLBogusFilelistEntries Returns Boolean
89760>>>>>>>        Boolean bIgnore bExists bOK bResponse
89760>>>>>>>        Handle hTable   
89760>>>>>>>        String sTableName
89760>>>>>>>        
89760>>>>>>>        Move False to Err 
89761>>>>>>>        Move True to bOK
89762>>>>>>>        Move 0 to hTable
89763>>>>>>>        Repeat
89763>>>>>>>>
89763>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89766>>>>>>>            If (hTable > 0) Begin
89768>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89771>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST")  to bIgnore
89772>>>>>>>                If (bIgnore = False) Begin
89774>>>>>>>                    Get _UtilTableExists hTable to bExists
89775>>>>>>>                    If (bExists = False) Begin
89777>>>>>>>                        Get ApiTableChangeFileListSlot "" "" "" hTable DATAFLEX_ID to bResponse
89778>>>>>>>                        If (bResponse = False) Begin
89780>>>>>>>                            Move False to bOK
89781>>>>>>>                        End
89781>>>>>>>>
89781>>>>>>>                        
89781>>>>>>>                    End
89781>>>>>>>>
89781>>>>>>>                End
89781>>>>>>>>
89781>>>>>>>            End
89781>>>>>>>>
89781>>>>>>>        Until (hTable = 0)                     
89783>>>>>>>        
89783>>>>>>>        Set Action_Text of ghoStatusPanel to "" 
89784>>>>>>>        Function_Return bOK
89785>>>>>>>    End_Function
89786>>>>>>>    
89786>>>>>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
89786>>>>>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
89786>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
89786>>>>>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
89786>>>>>>>    //
89786>>>>>>>    // The root of the problem is the following:
89786>>>>>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
89786>>>>>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
89786>>>>>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside
89786>>>>>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
89786>>>>>>>    // an SQL error will be thrown;
89786>>>>>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
89786>>>>>>>    Function UtilTablesFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
89788>>>>>>>        Boolean bOK bIsAlias bIsSQL
89788>>>>>>>        Integer iCount iSize iDateSize
89788>>>>>>>        Handle hTable
89788>>>>>>>        String sLogicalName
89788>>>>>>>        Integer[] aTablesToCheck aDateFields
89790>>>>>>>
89790>>>>>>>        Get _AllTablesDateCorrections to aTablesToCheck
89791>>>>>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
89792>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89793>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89794>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89795>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89796>>>>>>>
89796>>>>>>>        Move True to bOK
89797>>>>>>>        Decrement iSize
89798>>>>>>>        for iCount from 0 to iSize
89804>>>>>>>>
89804>>>>>>>            Move aTablesToCheck[iCount] to hTable
89805>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
89806>>>>>>>            Get UtilTableIsAlias hTable to bIsAlias
89807>>>>>>>            Get _UtilTableIsSql   hTable to bIsSQL
89808>>>>>>>
89808>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89811>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
89812>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
89813>>>>>>>
89813>>>>>>>            If (bIsAlias = False and bIsSQL = False) Begin
89815>>>>>>>                Get UtilCheckForDateFields hTable to aDateFields
89816>>>>>>>                Move (SizeOfArray(aDateFields)) to iDateSize
89817>>>>>>>                If (iDateSize > 0) Begin
89819>>>>>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
89820>>>>>>>                    Close hTable
89821>>>>>>>                End
89821>>>>>>>>
89821>>>>>>>            End
89821>>>>>>>>
89821>>>>>>>        Loop
89822>>>>>>>>
89822>>>>>>>
89822>>>>>>>        Close DF_ALL
89823>>>>>>>        Function_Return bOK
89824>>>>>>>    End_Function
89825>>>>>>>
89825>>>>>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
89825>>>>>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
89827>>>>>>>        Integer[] aDateFields aDateFieldsEmpty
89829>>>>>>>        Integer iSize iCount iType
89829>>>>>>>        Boolean bOpen bOK
89829>>>>>>>        
89829>>>>>>>        Get _UtilTableExists hTable to bOK
89830>>>>>>>        If (bOK = False) Begin
89832>>>>>>>            Set Private.phCurrentTable to hTable
89833>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
89834>>>>>>>>
89834>>>>>>>            Function_Return aDateFieldsEmpty
89835>>>>>>>        End
89835>>>>>>>>
89835>>>>>>>        Set Private.phCurrentTable to hTable
89836>>>>>>>        Set Private.piCurrentField to 0
89837>>>>>>>
89837>>>>>>>        Open hTable
89839>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89842>>>>>>>        If (bOpen = False) Begin
89844>>>>>>>            Function_Return aDateFieldsEmpty
89845>>>>>>>        End
89845>>>>>>>>
89845>>>>>>>
89845>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
89848>>>>>>>        For iCount from 1 to iSize
89854>>>>>>>>
89854>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
89857>>>>>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
89859>>>>>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
89860>>>>>>>            End
89860>>>>>>>>
89860>>>>>>>        Loop
89861>>>>>>>>
89861>>>>>>>
89861>>>>>>>        Function_Return aDateFields
89862>>>>>>>    End_Function
89863>>>>>>>
89863>>>>>>>    // Loops through all records for the passed hTable, and checks that all Date values
89863>>>>>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
89863>>>>>>>    // and the record is saved
89863>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
89863>>>>>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
89863>>>>>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
89865>>>>>>>        Integer iSize iCount iField iRecord iTotalRecords iDateFormat iDriverIndex
89865>>>>>>>        String sDriverID sDateMin
89865>>>>>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges 
89865>>>>>>>        Date dDate dDateMin
89865>>>>>>>        Integer[] iaChangeField
89866>>>>>>>
89866>>>>>>>        Get _UtilTableExists hTable to bOK
89867>>>>>>>        // I believe we should just skip files not found and not report an error.
89867>>>>>>>        // This is because a filelist may have entries but no files/tables on disk, but
89867>>>>>>>        // this may be adjusted by other calls to DUF in a later update package. 
89867>>>>>>>        // Especially considering that this call is probably done at the very
89867>>>>>>>        // beginning of a DUF update.
89867>>>>>>>        If (bOK = False) Begin
89869>>>>>>>//            Set Private.phCurrentTable to hTable
89869>>>>>>>//            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
89869>>>>>>>//            Function_Return False
89869>>>>>>>            Function_Return True
89870>>>>>>>        End
89870>>>>>>>>
89870>>>>>>>
89870>>>>>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the
89870>>>>>>>        // date format to "USA" = "MM/DD/YYYY"
89870>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
89873>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
89876>>>>>>>
89876>>>>>>>//        Send SetAllIndexesToBatch hTable True
89876>>>>>>>        Open hTable
89878>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
89881>>>>>>>        If (bOpened = False) Begin
89883>>>>>>>            Function_Return False
89884>>>>>>>        End
89884>>>>>>>>
89884>>>>>>>        
89884>>>>>>>        Set Private.phCurrentTable to hTable
89885>>>>>>>        Move 0 to iRecord
89886>>>>>>>        Move (SizeOfArray(aDateFields)) to iSize
89887>>>>>>>        Decrement iSize
89888>>>>>>>
89888>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89891>>>>>>>        Get DriverIndex sDriverID to iDriverIndex
89892>>>>>>>        If (iDriverIndex <> 0) Begin
89894>>>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDateMin
89897>>>>>>>            If (sDateMin = "") Begin
89899>>>>>>>                Move CS_DUFLowestAllowedDateValue to dDateMin
89900>>>>>>>            End
89900>>>>>>>>
89900>>>>>>>            Else Begin
89901>>>>>>>                If (IsDate(sDateMin)) Begin
89903>>>>>>>                    Move sDateMin to dDateMin
89904>>>>>>>                End
89904>>>>>>>>
89904>>>>>>>                Else Begin
89905>>>>>>>                    Move CS_DUFLowestAllowedDateValue to dDateMin
89906>>>>>>>                End
89906>>>>>>>>
89906>>>>>>>            End
89906>>>>>>>>
89906>>>>>>>        End
89906>>>>>>>>
89906>>>>>>>        Else Begin
89907>>>>>>>            Move CS_DUFLowestAllowedDateValue to dDateMin
89908>>>>>>>        End
89908>>>>>>>>
89908>>>>>>>
89908>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
89911>>>>>>>        Set piPosition   of ghoProgressBar to 0
89912>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 100
89913>>>>>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
89914>>>>>>>        Move False to Err
89915>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89916>>>>>>>
89916>>>>>>>        Clear hTable
89917>>>>>>>        Repeat
89917>>>>>>>>
89917>>>>>>>            Vfind hTable 0 GT
89919>>>>>>>            Move Found to bFound
89920>>>>>>>            If (bFound = True) Begin
89922>>>>>>>                Move False to bSaveChanges
89923>>>>>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField
89924>>>>>>>                Move (SizeOfArray(aDateFields)) to iSize
89925>>>>>>>                Decrement iSize
89926>>>>>>>                For iCount from 0 to iSize
89932>>>>>>>>
89932>>>>>>>                    Move aDateFields[iCount] to iField
89933>>>>>>>                    Get_Field_Value hTable iField to dDate
89936>>>>>>>                    If (bFixZeroDates = True) Begin
89938>>>>>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
89939>>>>>>>                    End
89939>>>>>>>>
89939>>>>>>>                    Else Begin
89940>>>>>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
89941>>>>>>>                    End
89941>>>>>>>>
89941>>>>>>>                    If (bChange = True) Begin
89943>>>>>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]
89944>>>>>>>                    End
89944>>>>>>>>
89944>>>>>>>                Loop
89945>>>>>>>>
89945>>>>>>>
89945>>>>>>>                // Only change Date fields that needs to be changed.
89945>>>>>>>                If (SizeOfArray(iaChangeField)) Begin
89947>>>>>>>                    Reread hTable
89951>>>>>>>                        Move (SizeOfArray(iaChangeField)) to iSize
89952>>>>>>>                        Decrement iSize
89953>>>>>>>                        For iCount from 0 to iSize
89959>>>>>>>>
89959>>>>>>>                            Move iaChangeField[iCount] to iField
89960>>>>>>>                            Set Private.piCurrentField to iField
89961>>>>>>>                            Set_Field_Value hTable iField to dDateMin
89964>>>>>>>                        Loop
89965>>>>>>>>
89965>>>>>>>                        Move False to Err
89966>>>>>>>                        SaveRecord hTable
89967>>>>>>>                    Unlock
89968>>>>>>>>
89968>>>>>>>                End
89968>>>>>>>>
89968>>>>>>>
89968>>>>>>>                Increment iRecord
89969>>>>>>>                // Increment the StatusPanel counter and check the
89969>>>>>>>                // cancel status every 100 records rather than every
89969>>>>>>>                // record, it's way faster.
89969>>>>>>>                If (Mod(iRecord, 100) = 0) Begin
89971>>>>>>>                    Send DoAdvance of ghoProgressBar
89972>>>>>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
89973>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
89974>>>>>>>                End
89974>>>>>>>>
89974>>>>>>>            End
89974>>>>>>>>
89974>>>>>>>        Until (bFound = False)
89976>>>>>>>
89976>>>>>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
89979>>>>>>>        If (bResetIndexesToOnLine = True) Begin
89981>>>>>>>            Send SetAllIndexesToBatch hTable False
89982>>>>>>>        End
89982>>>>>>>>
89982>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89983>>>>>>>
89983>>>>>>>        Function_Return (Err = False)
89984>>>>>>>    End_Function
89985>>>>>>>
89985>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
89985>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
89985>>>>>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
89987>>>>>>>        Boolean bIsSame
89987>>>>>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
89987>>>>>>>
89987>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
89988>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
89989>>>>>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
89990>>>>>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
89991>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
89992>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
89993>>>>>>>
89993>>>>>>>        If (bCompareFilelistUppercase = True) Begin
89995>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
89996>>>>>>>        End
89996>>>>>>>>
89996>>>>>>>        Else Begin
89997>>>>>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
89998>>>>>>>        End
89998>>>>>>>>
89998>>>>>>>        If (bIsSame = False) Begin
90000>>>>>>>            Function_Return False
90001>>>>>>>        End
90001>>>>>>>>
90001>>>>>>>
90001>>>>>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
90002>>>>>>>        If (bIsSame = False) Begin
90004>>>>>>>            Function_Return False
90005>>>>>>>        End
90005>>>>>>>>
90005>>>>>>>
90005>>>>>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
90006>>>>>>>        If (bIsSame = False) Begin
90008>>>>>>>            Function_Return False
90009>>>>>>>        End
90009>>>>>>>>
90009>>>>>>>
90009>>>>>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
90010>>>>>>>        If (bIsSame = False) Begin
90012>>>>>>>            Function_Return False
90013>>>>>>>        End
90013>>>>>>>>
90013>>>>>>>
90013>>>>>>>        Function_Return bIsSame
90014>>>>>>>    End_Function
90015>>>>>>>
90015>>>>>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
90017>>>>>>>        Handle hTableFrom hTableTo
90017>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
90017>>>>>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
90017>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
90017>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
90017>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
90018>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
90018>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
90019>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
90019>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
90020>>>>>>>
90020>>>>>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
90021>>>>>>>        If (bIsSame = True) Begin
90023>>>>>>>            Function_Return True
90024>>>>>>>        End
90024>>>>>>>>
90024>>>>>>>
90024>>>>>>>        Move False to bFilelistError
90025>>>>>>>        Move True to bIsSame
90026>>>>>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
90027>>>>>>>        Get pbCompareIndexAscending to bCompareIndexAscending
90028>>>>>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
90029>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
90030>>>>>>>        Set Private.phCurrentTable to hTableFrom
90031>>>>>>>        
90031>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
90032>>>>>>>
90032>>>>>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
90033>>>>>>>        Get _TableNameOnly sRootName             to sRootName
90034>>>>>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
90035>>>>>>>
90035>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
90035>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
90035>>>>>>>        If (bCodeGenerateMode = True) Begin
90037>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
90037>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
90039>>>>>>>                Function_Return False
90040>>>>>>>            End
90040>>>>>>>>
90040>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
90041>>>>>>>            If (bIsSame = False) Begin
90043>>>>>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
90044>>>>>>>                Move True to bFilelistError
90045>>>>>>>                Function_Return False
90046>>>>>>>            End
90046>>>>>>>>
90046>>>>>>>        End
90046>>>>>>>>
90046>>>>>>>
90046>>>>>>>        If (bCodeGenerateMode = False) Begin
90048>>>>>>>            // Then we want to create this table
90048>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
90050>>>>>>>                Function_Return False
90051>>>>>>>            End
90051>>>>>>>>
90051>>>>>>>
90051>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
90052>>>>>>>            If (bIsSame = False) Begin
90054>>>>>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
90055>>>>>>>>
90055>>>>>>>                Move True to bFilelistError
90056>>>>>>>                Function_Return False
90057>>>>>>>            End
90057>>>>>>>>
90057>>>>>>>        End
90057>>>>>>>>
90057>>>>>>>
90057>>>>>>>        // Check columns:
90057>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
90058>>>>>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
90059>>>>>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
90060>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
90061>>>>>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
90062>>>>>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
90063>>>>>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
90064>>>>>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
90065>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
90066>>>>>>>        If (bIsSame = False) Begin
90068>>>>>>>            Function_Return False
90069>>>>>>>        End
90069>>>>>>>>
90069>>>>>>>
90069>>>>>>>        // ...then check indexes:
90069>>>>>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
90070>>>>>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
90071>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
90072>>>>>>>        If (bIsSame = False) Begin
90074>>>>>>>            Function_Return False
90075>>>>>>>        End
90075>>>>>>>>
90075>>>>>>>
90075>>>>>>>        // ...and finally relationships:
90075>>>>>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
90076>>>>>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
90077>>>>>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
90078>>>>>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
90079>>>>>>>
90079>>>>>>>        Function_Return (bIsSame = True)
90080>>>>>>>    End_Function
90081>>>>>>>
90081>>>>>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
90081>>>>>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
90083>>>>>>>        Handle hTable
90083>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
90083>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
90083>>>>>>>
90083>>>>>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
90085>>>>>>>            Move True to bFilelistError
90086>>>>>>>            Function_Return False
90087>>>>>>>        End
90087>>>>>>>>
90087>>>>>>>
90087>>>>>>>        Move APITableCompare.hTable to hTable
90088>>>>>>>        Move True  to bIsSame
90089>>>>>>>        Move False to bFilelistError
90090>>>>>>>
90090>>>>>>>        If (APITableCompare.bExistsFrom = True) Begin
90092>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
90093>>>>>>>        End
90093>>>>>>>>
90093>>>>>>>        Else Begin
90094>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
90095>>>>>>>        End
90095>>>>>>>>
90095>>>>>>>        Get _TableNameOnly sRootName                                   to sRootName
90096>>>>>>>
90096>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
90097>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
90098>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
90099>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
90100>>>>>>>
90100>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
90100>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
90100>>>>>>>        If (bCodeGenerateMode = True) Begin
90102>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
90102>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
90104>>>>>>>                Function_Return False
90105>>>>>>>            End
90105>>>>>>>>
90105>>>>>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
90106>>>>>>>            If (bIsSame = False) Begin
90108>>>>>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
90109>>>>>>>                Move True to bFilelistError
90110>>>>>>>                Function_Return False
90111>>>>>>>            End
90111>>>>>>>>
90111>>>>>>>        End
90111>>>>>>>>
90111>>>>>>>
90111>>>>>>>        If (bCodeGenerateMode = False) Begin
90113>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
90115>>>>>>>                // Then we might want to create this table
90115>>>>>>>                Function_Return False
90116>>>>>>>            End
90116>>>>>>>>
90116>>>>>>>
90116>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
90117>>>>>>>            If (bIsSame = False) Begin
90119>>>>>>>                Function_Return False
90120>>>>>>>            End
90120>>>>>>>>
90120>>>>>>>
90120>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
90121>>>>>>>            If (bIsSame = False) Begin
90123>>>>>>>                Function_Return False
90124>>>>>>>            End
90124>>>>>>>>
90124>>>>>>>
90124>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
90125>>>>>>>            If (bIsSame = False) Begin
90127>>>>>>>                Function_Return False
90128>>>>>>>            End
90128>>>>>>>>
90128>>>>>>>
90128>>>>>>>            // Check table names et al.
90128>>>>>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
90129>>>>>>>            If (bIsSame = False) Begin
90131>>>>>>>                Function_Return False
90132>>>>>>>            End
90132>>>>>>>>
90132>>>>>>>        End
90132>>>>>>>>
90132>>>>>>>
90132>>>>>>>        // Check Columns:
90132>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
90133>>>>>>>        If (bIsSame = False) Begin
90135>>>>>>>            Function_Return False
90136>>>>>>>        End
90136>>>>>>>>
90136>>>>>>>
90136>>>>>>>        // ...then check Indexes:
90136>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
90137>>>>>>>        If (bIsSame = False) Begin
90139>>>>>>>            Function_Return False
90140>>>>>>>        End
90140>>>>>>>>
90140>>>>>>>
90140>>>>>>>        // ...and finally Relationships:
90140>>>>>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
90141>>>>>>>
90141>>>>>>>        Function_Return (bIsSame = True)
90142>>>>>>>    End_Function
90143>>>>>>>
90143>>>>>>>    // To fill a complete Table array structure (tAPITable[]) with data.
90143>>>>>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
90143>>>>>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
90143>>>>>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
90143>>>>>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
90145>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90145>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90145>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
90145>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
90147>>>>>>>        tAPIColumn[]    aApiColumns
90147>>>>>>>        tAPIColumn[]    aApiColumns
90148>>>>>>>        tAPIIndex[]     aApiIndexes
90148>>>>>>>        tAPIIndex[]     aApiIndexes
90149>>>>>>>        tAPIRelation[]  aApiRelations
90149>>>>>>>        tAPIRelation[]  aApiRelations
90150>>>>>>>        Handle hTable
90150>>>>>>>        Integer iCount
90150>>>>>>>        Boolean bUserCancel bOK
90150>>>>>>>        String sLogicalName sMessageText
90150>>>>>>>
90150>>>>>>>        Get AutoConnectionIDLogin to bOK
90151>>>>>>>        Move 0 to hTable
90152>>>>>>>        If (bFromTables = True) Begin
90154>>>>>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
90155>>>>>>>            If (bCompareUtil = True) Begin
90157>>>>>>>                Move (sMessageText * "(1 of 3)") to sMessageText
90158>>>>>>>            End
90158>>>>>>>>
90158>>>>>>>        End
90158>>>>>>>>
90158>>>>>>>        Else Begin
90159>>>>>>>            Move "Reading 'TO' Table Structure:" to sMessageText
90160>>>>>>>            If (bCompareUtil = True) Begin
90162>>>>>>>                Move (sMessageText * "(2 of 3)") to sMessageText
90163>>>>>>>            End
90163>>>>>>>>
90163>>>>>>>        End
90163>>>>>>>>
90163>>>>>>>        Set Message_Text of ghoStatusPanel to sMessageText
90164>>>>>>>
90164>>>>>>>        Get UtilFilelistNoOfTables to iCount
90165>>>>>>>        Set piMaximum of ghoProgressBar to iCount
90166>>>>>>>        Move 0 to iCount
90167>>>>>>>
90167>>>>>>>        Repeat
90167>>>>>>>>
90167>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90170>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
90172>>>>>>>
90172>>>>>>>                Open hTable
90174>>>>>>>                // ToDo: Needs to be revised
90174>>>>>>>                // For some reason tables may be reported as "unopened", while in
90174>>>>>>>                // fact the open was successful (!)
90174>>>>>>>//                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90174>>>>>>>//                If (bIsOpen = False) Begin
90174>>>>>>>//                    Move True to aApiTablesEmpty[0].bError
90174>>>>>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
90174>>>>>>>//                    Function_Return aApiTablesEmpty
90174>>>>>>>//                End
90174>>>>>>>
90174>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90177>>>>>>>                Set piPosition of ghoProgressBar to iCount
90178>>>>>>>                Send DoAdvance of ghoProgressBarOverall
90179>>>>>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
90180>>>>>>>
90180>>>>>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
90181>>>>>>>//                Close hTable DF_PERMANENT
90181>>>>>>>                Increment iCount
90182>>>>>>>            End
90182>>>>>>>>
90182>>>>>>>
90182>>>>>>>            If (bStatusPanel = True) Begin
90184>>>>>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
90185>>>>>>>                If (bUserCancel = True) Begin
90187>>>>>>>                    Move True to aApiTablesEmpty[0].bCancel
90188>>>>>>>                    Function_Return aApiTablesEmpty
90189>>>>>>>                End
90189>>>>>>>>
90189>>>>>>>            End
90189>>>>>>>>
90189>>>>>>>
90189>>>>>>>        Until (hTable = 0)
90191>>>>>>>
90191>>>>>>>        Function_Return aApiTables
90192>>>>>>>    End_Function
90193>>>>>>>
90193>>>>>>>    // Returns a 'single' table APITable struct.
90193>>>>>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
90195>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90195>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90195>>>>>>>        tAPITable         ApiTable ApiTableEmpty
90195>>>>>>>        tAPITable         ApiTable ApiTableEmpty
90195>>>>>>>        tAPIColumn[]     aApiColumns
90195>>>>>>>        tAPIColumn[]     aApiColumns
90196>>>>>>>        tAPIIndex[]      aApiIndexes
90196>>>>>>>        tAPIIndex[]      aApiIndexes
90197>>>>>>>        tAPIRelation[]   aApiRelations
90197>>>>>>>        tAPIRelation[]   aApiRelations
90198>>>>>>>        Boolean bIsOpen
90198>>>>>>>
90198>>>>>>>        Open hTable
90200>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90203>>>>>>>        If (bIsOpen = False) Begin
90205>>>>>>>            Move True to ApiTableEmpty.bError
90206>>>>>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90207>>>>>>>            Function_Return ApiTableEmpty
90208>>>>>>>        End
90208>>>>>>>>
90208>>>>>>>
90208>>>>>>>        // Fill Table Name Info
90208>>>>>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
90209>>>>>>>
90209>>>>>>>        // Fill columns
90209>>>>>>>        Get UtilColumnsStructFill hTable to aApiColumns
90210>>>>>>>        If (SizeOfArray(aApiColumns)) Begin
90212>>>>>>>            If (aApiColumns[0].bCancel = True) Begin
90214>>>>>>>                Move True to ApiTableEmpty.bError
90215>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90216>>>>>>>                Function_Return ApiTableEmpty
90217>>>>>>>            End
90217>>>>>>>>
90217>>>>>>>        End
90217>>>>>>>>
90217>>>>>>>
90217>>>>>>>        // Fill indexes
90217>>>>>>>        Get UtilIndexesStructFill hTable to aApiIndexes
90218>>>>>>>        If (SizeOfArray(aApiIndexes)) Begin
90220>>>>>>>            If (aApiIndexes[0].bCancel = True) Begin
90222>>>>>>>                Move True to ApiTableEmpty.bError
90223>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90224>>>>>>>                Function_Return ApiTableEmpty
90225>>>>>>>            End
90225>>>>>>>>
90225>>>>>>>        End
90225>>>>>>>>
90225>>>>>>>
90225>>>>>>>        // Fill relationships
90225>>>>>>>        Get UtilRelationsStructFill hTable to aApiRelations
90226>>>>>>>        If (SizeOfArray(aApiRelations)) Begin
90228>>>>>>>            If (aApiRelations[0].bCancel = True) Begin
90230>>>>>>>                Move True to ApiTableEmpty.bError
90231>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
90232>>>>>>>                Function_Return ApiTableEmpty
90233>>>>>>>            End
90233>>>>>>>>
90233>>>>>>>        End
90233>>>>>>>>
90233>>>>>>>
90233>>>>>>>        Move hTable             to ApiTable.hTable
90234>>>>>>>        Move bFromTables        to ApiTable.bFromTable
90235>>>>>>>        Move (not(bFromTables)) to ApiTable.bToTable
90236>>>>>>>
90236>>>>>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
90237>>>>>>>        Move aApiColumns        to ApiTable.aApiColumns
90238>>>>>>>        Move aApiIndexes        to ApiTable.aApiIndexes
90239>>>>>>>        Move aApiRelations      to ApiTable.aApiRelations
90240>>>>>>>
90240>>>>>>>        Function_Return ApiTable
90241>>>>>>>    End_Function
90242>>>>>>>
90242>>>>>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
90244>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
90244>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
90244>>>>>>>        Boolean bIsOpen
90244>>>>>>>
90244>>>>>>>        Open hTable
90246>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90249>>>>>>>        If (bIsOpen = False) Begin
90251>>>>>>>            Move True   to APITableNameInfoEmpty.bError
90252>>>>>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
90253>>>>>>>            Function_Return APITableNameInfoEmpty
90254>>>>>>>        End
90254>>>>>>>>
90254>>>>>>>
90254>>>>>>>        Move hTable                                  to APITableNameInfo.iTableNumber
90255>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
90258>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
90261>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
90264>>>>>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
90267>>>>>>>
90267>>>>>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
90268>>>>>>>        Get _UtilTableIsSql                   hTable to APITableNameInfo.bIsSQL
90269>>>>>>>
90269>>>>>>>        Function_Return APITableNameInfo
90270>>>>>>>    End_Function
90271>>>>>>>
90271>>>>>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
90273>>>>>>>        Integer iSize iCount iItem
90273>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90273>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90273>>>>>>>
90273>>>>>>>        Move -1 to iItem
90274>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
90275>>>>>>>        Decrement iSize
90276>>>>>>>        for iCount from 0 to iSize
90282>>>>>>>>
90282>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
90283>>>>>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
90285>>>>>>>                Move iCount to iItem
90286>>>>>>>                Move iSize  to iCount // We're done.
90287>>>>>>>            End
90287>>>>>>>>
90287>>>>>>>        Loop
90288>>>>>>>>
90288>>>>>>>
90288>>>>>>>        Function_Return iItem
90289>>>>>>>    End_Function
90290>>>>>>>
90290>>>>>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
90292>>>>>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
90295>>>>>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
90298>>>>>>>
90298>>>>>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
90301>>>>>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
90304>>>>>>>
90304>>>>>>>        Function_Return (EQ)
90305>>>>>>>    End_Function
90306>>>>>>>
90306>>>>>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
90308>>>>>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
90308>>>>>>>        Handle hTable
90308>>>>>>>        tAPITable[] aAPITableFromAndTo
90308>>>>>>>        tAPITable[] aAPITableFromAndTo
90309>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
90309>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
90309>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90309>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90309>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
90309>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
90310>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
90310>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
90311>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
90311>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
90312>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
90312>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
90313>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
90313>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
90313>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
90313>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
90316>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
90316>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
90319>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
90319>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
90322>>>>>>>
90322>>>>>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
90323>>>>>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
90324>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
90326>>>>>>>            Function_Return aAPITableCompare
90327>>>>>>>        End
90327>>>>>>>>
90327>>>>>>>
90327>>>>>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
90328>>>>>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
90329>>>>>>>
90329>>>>>>>        Move 0 to iItem
90330>>>>>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
90331>>>>>>>        Decrement iSize
90332>>>>>>>        for iCount from 0 to iSize
90338>>>>>>>>
90338>>>>>>>
90338>>>>>>>            Move iCount to iItemFrom
90339>>>>>>>            Move iCount to iItemTo
90340>>>>>>>            Move APITableEmpty to APITableFrom
90341>>>>>>>            Move APITableEmpty to APITableTo
90342>>>>>>>
90342>>>>>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
90344>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
90345>>>>>>>            End
90345>>>>>>>>
90345>>>>>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
90347>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
90348>>>>>>>            End
90348>>>>>>>>
90348>>>>>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
90350>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
90351>>>>>>>                Move (iCount + 1) to iItemTo
90352>>>>>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
90353>>>>>>>            End
90353>>>>>>>>
90353>>>>>>>            If (APITableFrom.hTable > APITableTo.hTable) Begin
90355>>>>>>>                Get FindTableNumber aAPITableTo APITableFrom.hTable to iItemTo
90356>>>>>>>                If (iItemTo <> -1) Begin
90358>>>>>>>                    Move aAPITableTo[iItemTo] to APITableTo
90359>>>>>>>                End
90359>>>>>>>>
90359>>>>>>>                Else Begin
90360>>>>>>>                    Move APITableEmpty to APITableTo
90361>>>>>>>                End
90361>>>>>>>>
90361>>>>>>>            End
90361>>>>>>>>
90361>>>>>>>
90361>>>>>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
90362>>>>>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
90363>>>>>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
90364>>>>>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
90365>>>>>>>
90365>>>>>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
90366>>>>>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
90367>>>>>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
90368>>>>>>>            Move APITableTo.aApiRelations   to aApiRelationTo
90369>>>>>>>
90369>>>>>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
90370>>>>>>>
90370>>>>>>>            If (hTable > 0) Begin
90372>>>>>>>
90372>>>>>>>                // Table info:
90372>>>>>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
90373>>>>>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
90374>>>>>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
90375>>>>>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
90376>>>>>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
90377>>>>>>>
90377>>>>>>>                // Column info:
90377>>>>>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
90378>>>>>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
90379>>>>>>>
90379>>>>>>>                // Index info:
90379>>>>>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
90380>>>>>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
90381>>>>>>>
90381>>>>>>>                // Relation info:
90381>>>>>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
90382>>>>>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
90383>>>>>>>
90383>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
90384>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
90385>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bError
90386>>>>>>>                If (iItemTo > iItemFrom) Begin
90388>>>>>>>                    Increment iCount
90389>>>>>>>                End
90389>>>>>>>>
90389>>>>>>>                Increment iItem
90390>>>>>>>            End
90390>>>>>>>>
90390>>>>>>>
90390>>>>>>>        Loop
90391>>>>>>>>
90391>>>>>>>
90391>>>>>>>        Function_Return aAPITableCompare
90392>>>>>>>    End_Function
90393>>>>>>>
90393>>>>>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
90395>>>>>>>        Integer iSize iCount iItem
90395>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90395>>>>>>>        tAPITableNameInfo ApiTableNameInfo
90395>>>>>>>
90395>>>>>>>        Move -1 to iItem
90396>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
90397>>>>>>>        Decrement iSize
90398>>>>>>>        For iCount from 0 to iSize
90404>>>>>>>>
90404>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
90405>>>>>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
90407>>>>>>>                Move iCount to iItem
90408>>>>>>>                Move iSize  to iCount // We're done.
90409>>>>>>>            End
90409>>>>>>>>
90409>>>>>>>        Loop
90410>>>>>>>>
90410>>>>>>>
90410>>>>>>>        Function_Return iItem
90411>>>>>>>    End_Function
90412>>>>>>>
90412>>>>>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
90414>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90414>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
90414>>>>>>>
90414>>>>>>>        If (APITableNameInfoFrom.iTableNumber = 0 and APITableNameInfoTo.iTableNumber = 0) Begin
90416>>>>>>>            Function_Return APITableNameInfoCompare
90417>>>>>>>        End
90417>>>>>>>>
90417>>>>>>>
90417>>>>>>>        // FROM database info:
90417>>>>>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
90419>>>>>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
90420>>>>>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
90421>>>>>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
90422>>>>>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
90423>>>>>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
90424>>>>>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
90425>>>>>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
90426>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
90427>>>>>>>        End
90427>>>>>>>>
90427>>>>>>>
90427>>>>>>>        // TO database info:
90427>>>>>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
90429>>>>>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
90430>>>>>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
90431>>>>>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
90432>>>>>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
90433>>>>>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
90434>>>>>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
90435>>>>>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
90436>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsTo
90437>>>>>>>        End
90437>>>>>>>>
90437>>>>>>>
90437>>>>>>>        Function_Return APITableNameInfoCompare
90438>>>>>>>    End_Function
90439>>>>>>>
90439>>>>>>>    // Note:
90439>>>>>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
90439>>>>>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
90439>>>>>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
90439>>>>>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
90439>>>>>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
90439>>>>>>>    Function UtilTableHandleToString Handle hTable Returns String
90441>>>>>>>        String sTableName
90441>>>>>>>        Boolean bOpen bExists bOK
90441>>>>>>>
90441>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
90442>>>>>>>        If (bExists = False) Begin
90444>>>>>>>            Function_Return ""
90445>>>>>>>        End
90445>>>>>>>>
90445>>>>>>>
90445>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90446>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90449>>>>>>>        If (bOpen = False) Begin
90451>>>>>>>            Get AutoConnectionIDLogin to bOK
90452>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90453>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
90454>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
90455>>>>>>>            Open hTable
90457>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90458>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
90459>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
90460>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
90463>>>>>>>        End
90463>>>>>>>>
90463>>>>>>>        If (bOpen = True) Begin
90465>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90466>>>>>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
90469>>>>>>>            // If blank it is an embedded table:
90469>>>>>>>            If (sTableName = "") Begin
90471>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
90474>>>>>>>                Move 0 to LastErr
90475>>>>>>>                Move False to Err
90476>>>>>>>            End
90476>>>>>>>>
90476>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90477>>>>>>>        End
90477>>>>>>>>
90477>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90478>>>>>>>        Move 0 to LastErr
90479>>>>>>>
90479>>>>>>>        Function_Return sTableName
90480>>>>>>>    End_Function
90481>>>>>>>
90481>>>>>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
90481>>>>>>>    // Returns 0 if unsuccessful.
90481>>>>>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
90481>>>>>>>    Function UtilTableNameToHandle String sTableName Returns Integer
90483>>>>>>>        String sValue sPrefixTableName sDriverID
90483>>>>>>>        Handle hTable hRetval
90483>>>>>>>
90483>>>>>>>        Get psDriverID to sDriverID
90484>>>>>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
90486>>>>>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
90487>>>>>>>        End
90487>>>>>>>>
90487>>>>>>>        Move 0 to hTable
90488>>>>>>>        Move 0 to hRetval
90489>>>>>>>        Repeat
90489>>>>>>>>
90489>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90492>>>>>>>            If (hTable <> 0) Begin
90494>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
90497>>>>>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
90499>>>>>>>                    Move hTable to hRetval
90500>>>>>>>                    Move 0 to hTable
90501>>>>>>>                End
90501>>>>>>>>
90501>>>>>>>            End
90501>>>>>>>>
90501>>>>>>>        Until (hTable = 0)
90503>>>>>>>
90503>>>>>>>        Function_Return hRetval
90504>>>>>>>    End_Function
90505>>>>>>>
90505>>>>>>>    // Use function to move all *.dat, *.k?? & *.hdr files to a "Data\Backup" folder
90505>>>>>>>    // _after_ all tables have successfully been converted to SQL (.int files)
90505>>>>>>>    Function UtilMoveAllEmbeddedToBackupFolder Returns Boolean
90507>>>>>>>        Boolean bOK bExists
90507>>>>>>>        String sDataPath sBackupFolder
90507>>>>>>>
90507>>>>>>>        Close DF_ALL DF_PERMANENT
90508>>>>>>>        Send DoAdvance of ghoProgressBar
90509>>>>>>>
90509>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
90510>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
90511>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
90512>>>>>>>        Get vFolderFormat sDataPath to sDataPath
90513>>>>>>>
90513>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
90514>>>>>>>        If (bExists = False) Begin
90516>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
90517>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
90518>>>>>>>            If (bExists = False) Begin
90520>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
90521>>>>>>>>
90521>>>>>>>                Function_Return False
90522>>>>>>>            End
90522>>>>>>>>
90522>>>>>>>        End
90522>>>>>>>>
90522>>>>>>>
90522>>>>>>>        Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
90523>>>>>>>        Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
90524>>>>>>>        Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
90525>>>>>>>        Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
90526>>>>>>>        // We need to wait for Windows before we can copy files back
90526>>>>>>>        Sleep 2  
90527>>>>>>>        
90527>>>>>>>        //...except for these files that needs to be copied back to the Data folder:
90527>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeMast.*")  sDataPath to bOK 
90528>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeType.*")  sDataPath to bOK                                 
90529>>>>>>>        Get vCopyFile (sBackupFolder + "\Flexerrs.*")  sDataPath to bOK                                 
90530>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr001.*")  sDataPath to bOK                                 
90531>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr002.*")  sDataPath to bOK                                 
90532>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr003.*")  sDataPath to bOK                                 
90533>>>>>>>//            Get vCopyFile (sBackupFolder + "\DbVersion.*") sDataPath to bOK  
90533>>>>>>>        
90533>>>>>>>
90533>>>>>>>        Set Message_Text of ghoStatusPanel to ""
90534>>>>>>>        Function_Return True
90535>>>>>>>    End_Function
90536>>>>>>>    
90536>>>>>>>    Function UtilTableRepairAndReindexALL Returns Boolean
90538>>>>>>>        Boolean bOK bRetval
90538>>>>>>>        Handle hTable
90538>>>>>>>        Integer iSize iCount
90538>>>>>>>        
90538>>>>>>>        Move True to bOK
90539>>>>>>>        Get UtilFilelistNoOfTables to iSize
90540>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
90541>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
90542>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
90543>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
90544>>>>>>>
90544>>>>>>>        Repeat
90544>>>>>>>>
90544>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
90545>>>>>>>            Increment iCount
90546>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90549>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin // 50 = Flexerrs.
90551>>>>>>>                Get UtilTableRepairAndReindex hTable to bRetval
90552>>>>>>>                If (bRetval = False) Begin
90554>>>>>>>                    Move False to bOK
90555>>>>>>>                End
90555>>>>>>>>
90555>>>>>>>            End
90555>>>>>>>>
90555>>>>>>>        Until (hTable = 0)
90557>>>>>>>                
90557>>>>>>>        Function_Return bOK
90558>>>>>>>    End_Function           
90559>>>>>>>    
90559>>>>>>>    // Checks if an Embedded (DataFlex) data-file needs to be repaired.
90559>>>>>>>    // After the header has been repaired - also makes a re-index.  
90559>>>>>>>    // Returns TRUE if successful OR the table was an an ALIAS or SQL table in case we do nothing.
90559>>>>>>>    Function UtilTableRepairAndReindex Handle hTable Returns Boolean
90561>>>>>>>        Boolean bOK bIsAlias bIsEmbedded bIsOpen bBadExists
90561>>>>>>>        Integer iRetval
90561>>>>>>>        String sRootName sFileName sDataPath
90561>>>>>>>        
90561>>>>>>>        Move False to Err
90562>>>>>>>        Move 0 to LastErr 
90563>>>>>>>        Move True to bOK
90564>>>>>>>        
90564>>>>>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
90565>>>>>>>        If (bIsEmbedded = False or hTable = 50) Begin // 50 = Flexerrs
90567>>>>>>>            Function_Return True
90568>>>>>>>        End
90568>>>>>>>>
90568>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias 
90569>>>>>>>        If (bIsAlias = True) Begin
90571>>>>>>>            Function_Return True
90572>>>>>>>        End
90572>>>>>>>>
90572>>>>>>>        
90572>>>>>>>        // Check for bad file and remove if exists
90572>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
90575>>>>>>>        Set private.phCurrentTable to hTable  
90576>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
90577>>>>>>>        
90577>>>>>>>        // This is important! Else it can happen that the table can't be opened,
90577>>>>>>>        // with a "4077 - File in use" error.
90577>>>>>>>        Close DF_ALL DF_PERMANENT    
90578>>>>>>>        Open hTable
90580>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90583>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90584>>>>>>>        If (bIsOpen = False) Begin
90586>>>>>>>            Error DFERR_PROGRAM ("Could not open table to be repaired and reindexed:" * String(sRootName))
90587>>>>>>>>
90587>>>>>>>            Function_Return False        
90588>>>>>>>        End
90588>>>>>>>>
90588>>>>>>>
90588>>>>>>>        Get vFilePathExists (sRootName + ".BAD")  to bBadExists
90589>>>>>>>        If (bBadExists = True) Begin
90591>>>>>>>            Get_File_Path (sRootName + ".BAD") to sFileName
90592>>>>>>>            Get vDeleteFile sFileName to iRetval
90593>>>>>>>        End
90593>>>>>>>>
90593>>>>>>>        
90593>>>>>>>        Set TableName_Text of ghoStatusPanel to ("Repairing and reindex Table Name:" * sRootName * "Number:" * String(hTable))
90594>>>>>>>        
90594>>>>>>>        Move False to Err
90595>>>>>>>        // **** Repair and reindex the table. ****
90595>>>>>>>        Get UtilTableRepairEmbedded hTable sRootName to bOK
90596>>>>>>>
90596>>>>>>>        // Check for bad file: if it exists, something went wrong
90596>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
90597>>>>>>>        Get vFolderFormat sDataPath to sDataPath
90598>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".BAD") to bBadExists
90599>>>>>>>        If (bBadExists = True) Begin
90601>>>>>>>            Error DFERR_PROGRAM ("Error while sorting data. .BAD file created:"  * String(sRootName) + ".BAD")
90602>>>>>>>>
90602>>>>>>>            Move False to bOK
90603>>>>>>>        End
90603>>>>>>>>
90603>>>>>>>        Close hTable
90604>>>>>>>
90604>>>>>>>        Function_Return bOK
90605>>>>>>>    End_Function
90606>>>>>>>
90606>>>>>>>    // Repair and reindex the named DataFlex data-table.
90606>>>>>>>    // No checks are done if the passed table name is an embedded or SQL,
90606>>>>>>>    // so use with care (make sure you only pass embedded table names).
90606>>>>>>>    Function UtilTableRepairEmbedded Handle hTable String sTableName Returns Boolean
90608>>>>>>>        String sMode
90608>>>>>>>        Integer iVoid
90608>>>>>>>
90608>>>>>>>        Set Message_Text of ghoStatusPanel to "Repair/Reindex in progress..."
90609>>>>>>>        Move "0" to sMode   // 0=Reindex after repair!    
90610>>>>>>>        Close hTable        // The table needs to be closed, else error 4177 "Table in use".
90611>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_REPAIR_FILE Callback ghoDbUpdateHandler Passing sTableName sMode 0 Result iVoid 
90616>>>>>>>        Set Message_Text of ghoStatusPanel to ""
90617>>>>>>>        Function_Return (iVoid = 0)
90618>>>>>>>    End_Function
90619>>>>>>>
90619>>>>>>>    // Returns _two_ arrays.
90619>>>>>>>    // Returns all files that are Master files in array ByRef iaFileIsMaster
90619>>>>>>>    // Also returns all files that are Alias files in a second array.
90619>>>>>>>    // IMPORTANT: All master & alias files _must_ have been included into
90619>>>>>>>    //            the DoSetAllMasterAndAlias message.
90619>>>>>>>    Function UtilTableAllMasterAndAliasFiles Integer[] ByRef iaFileIsMaster Returns Integer[]
90621>>>>>>>        Integer[] iaFileIsAlias
90622>>>>>>>        Integer hTable iFileAlias iSize
90622>>>>>>>        Boolean bOpen
90622>>>>>>>
90622>>>>>>>        Move 0 to hTable
90623>>>>>>>        Repeat
90623>>>>>>>>
90623>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90626>>>>>>>            If (hTable <> 0) Begin
90628>>>>>>>                Open hTable
90630>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
90633>>>>>>>                If (bOpen = True) Begin
90635>>>>>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iFileAlias
90638>>>>>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
90640>>>>>>>                        Move (SizeOfArray(iaFileIsMaster)) to iSize
90641>>>>>>>                        Move hTable to iaFileIsMaster[iSize]
90642>>>>>>>                    End
90642>>>>>>>>
90642>>>>>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
90645>>>>>>>                        Move (SizeOfArray(iaFileIsAlias)) to iSize
90646>>>>>>>                        Move hTable to iaFileIsAlias[iSize]
90647>>>>>>>                    End
90647>>>>>>>>
90647>>>>>>>                End
90647>>>>>>>>
90647>>>>>>>            End
90647>>>>>>>>
90647>>>>>>>        Until (hTable = 0)
90649>>>>>>>
90649>>>>>>>        Function_Return iaFileIsAlias
90650>>>>>>>    End_Function  
90651>>>>>>>    
90651>>>>>>>    // Is a repair of the data-header necessary? (Embedded tables only)
90651>>>>>>>    Function UtilTableRepairIsNeeded Handle hTable String sTableName Returns Integer
90653>>>>>>>        String sMode
90653>>>>>>>        Integer iRepairNeeded bIsOpen
90653>>>>>>>
90653>>>>>>>        Move "0" to sMode
90654>>>>>>>        Set private.phCurrentTable to hTable 
90655>>>>>>>        Close hTable
90656>>>>>>>        Open hTable
90658>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90661>>>>>>>        Call_Driver hTable DATAFLEX_ID Function FLEX_GET_REPAIRS_NEEDED Callback 0 Passing sTableName sMode 0 Result iRepairNeeded
90666>>>>>>>
90666>>>>>>>        Function_Return iRepairNeeded
90667>>>>>>>    End_Function
90668>>>>>>>
90668>>>>>>>    // Helper function
90668>>>>>>>    // Takes two params:
90668>>>>>>>    //   1. An array with all master table numbers  (Function UtilTableAllMasterAndAliasFiles)
90668>>>>>>>    //   2. An array with all alias table numbers   (Function UtilTableAllMasterAndAliasFiles)
90668>>>>>>>    // Returns:
90668>>>>>>>    //  DF_FILE_ALIAS_DEFAULT if no master or alias
90668>>>>>>>    //  DF_FILE_IS_MASTER if master
90668>>>>>>>    //  DF_FILE_IS_ALIAS if alias
90668>>>>>>>    Function UtilTableIsMasterAlias Handle hTable Integer[] iaFileIsMaster Integer[] iaFileIsAlias Returns Integer
90670>>>>>>>        Integer i iSize
90670>>>>>>>
90670>>>>>>>        Move (SizeOfArray(iaFileIsMaster)) to iSize
90671>>>>>>>        Decrement iSize
90672>>>>>>>        for i from 0 to iSize
90678>>>>>>>>
90678>>>>>>>            If (hTable = iaFileIsMaster[i]) Begin
90680>>>>>>>                Function_Return DF_FILE_IS_MASTER
90681>>>>>>>            End
90681>>>>>>>>
90681>>>>>>>        Loop
90682>>>>>>>>
90682>>>>>>>
90682>>>>>>>        Move (SizeOfArray(iaFileIsAlias)) to iSize
90683>>>>>>>        Decrement iSize
90684>>>>>>>        for i from 0 to iSize
90690>>>>>>>>
90690>>>>>>>            If (hTable = iaFileIsAlias[i]) Begin
90692>>>>>>>                Function_Return DF_FILE_IS_ALIAS
90693>>>>>>>            End
90693>>>>>>>>
90693>>>>>>>        Loop
90694>>>>>>>>
90694>>>>>>>
90694>>>>>>>        Function_Return DF_FILE_ALIAS_DEFAULT
90695>>>>>>>    End_Function
90696>>>>>>>
90696>>>>>>>    // Determine the available indexes of a table.
90696>>>>>>>    //
90696>>>>>>>    // Arguments:
90696>>>>>>>    //   Handle hTable - The number of the table
90696>>>>>>>    //
90696>>>>>>>    // Returns:
90696>>>>>>>    //   String - A string to be used with the sort command
90696>>>>>>>    //   to re-index all indexes of a table.
90696>>>>>>>    Function UtilTableIndexString Handle hTable Returns String
90698>>>>>>>        String  sSortString
90698>>>>>>>        Integer iLastIndex iNumSegments iCount
90698>>>>>>>
90698>>>>>>>        Move "" to sSortString
90699>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
90702>>>>>>>
90702>>>>>>>        for iCount from 1 to iLastIndex
90708>>>>>>>>
90708>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iNumSegments
90711>>>>>>>            If iNumSegments Begin
90713>>>>>>>                If (Length(sSortString)) ;                    Move (Append(sSortString, " ")) to sSortString
90716>>>>>>>                Move (Append(sSortString, iCount)) to sSortString
90717>>>>>>>            End
90717>>>>>>>>
90717>>>>>>>        Loop
90718>>>>>>>>
90718>>>>>>>
90718>>>>>>>        Function_Return sSortString
90719>>>>>>>    End_Function
90720>>>>>>>
90720>>>>>>>    
90720>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90720>>>>>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
90722>>>>>>>        Function_Return False
90723>>>>>>>    End_Function
90724>>>>>>>
90724>>>>>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
90724>>>>>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90726>>>>>>>        Boolean bIsSame
90726>>>>>>>        Integer iCount iColumns iColumn
90726>>>>>>>
90726>>>>>>>        Move True to bIsSame
90727>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
90728>>>>>>>        Set piMaximum of ghoProgressBar  to iColumns
90729>>>>>>>        Decrement iColumns
90730>>>>>>>
90730>>>>>>>        for iCount from 0 to iColumns
90736>>>>>>>>
90736>>>>>>>            Set piPosition of ghoProgressBar to iCount
90737>>>>>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
90738>>>>>>>            If (bIsSame = False) Begin
90740>>>>>>>                Function_Return False
90741>>>>>>>            End
90741>>>>>>>>
90741>>>>>>>        Loop
90742>>>>>>>>
90742>>>>>>>
90742>>>>>>>        Function_Return (bIsSame = True)
90743>>>>>>>    End_Function
90744>>>>>>>
90744>>>>>>>    // Compares a single column (For 'FROM' & 'TO' tables)
90744>>>>>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90746>>>>>>>        Integer iFromType iToType iDbType
90746>>>>>>>        tColumnType ColumnType
90746>>>>>>>        tColumnType ColumnType
90746>>>>>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
90746>>>>>>>
90746>>>>>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
90748>>>>>>>            Function_Return False
90749>>>>>>>        End
90749>>>>>>>>
90749>>>>>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
90751>>>>>>>            Function_Return False
90752>>>>>>>        End
90752>>>>>>>>
90752>>>>>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
90754>>>>>>>            Function_Return False
90755>>>>>>>        End                                                                
90755>>>>>>>>
90755>>>>>>>
90755>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = True) Begin
90757>>>>>>>            If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
90759>>>>>>>                Function_Return False
90760>>>>>>>            End
90760>>>>>>>>
90760>>>>>>>            If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
90762>>>>>>>                If ((APIColumnCompare.sDefaultValueFrom = ""   and APIColumnCompare.sDefaultValueTo = "''") or ;                    (APIColumnCompare.sDefaultValueFrom = "''" and APIColumnCompare.sDefaultValueTo = "")) Begin
90764>>>>>>>                    End
90764>>>>>>>>
90764>>>>>>>                Else Begin
90765>>>>>>>                    Function_Return False
90766>>>>>>>                End
90766>>>>>>>>
90766>>>>>>>            End
90766>>>>>>>>
90766>>>>>>>        End
90766>>>>>>>>
90766>>>>>>>
90766>>>>>>>        Get piDbType                       to iDbType
90767>>>>>>>        Move APIColumnCompare.iTypeFrom    to iFromType
90768>>>>>>>        Move APIColumnCompare.iTypeTo      to iToType
90769>>>>>>>
90769>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
90769>>>>>>>        // data types between Embedded and SQL.
90769>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
90771>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
90772>>>>>>>        End
90772>>>>>>>>
90772>>>>>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
90774>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
90775>>>>>>>        End
90775>>>>>>>>
90775>>>>>>>
90775>>>>>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
90776>>>>>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
90777>>>>>>>
90777>>>>>>>        // Make Date and DateTime comparison?
90777>>>>>>>        If (bCompareDate_DataTime = True) Begin
90779>>>>>>>            If (iFromType <> iToType) Begin
90781>>>>>>>                Function_Return False
90782>>>>>>>            End
90782>>>>>>>>
90782>>>>>>>        End
90782>>>>>>>>
90782>>>>>>>
90782>>>>>>>        // This is when not checking for Date/DateTime differences but all other other field types...
90782>>>>>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
90784>>>>>>>            If (iFromType <> iToType) Begin
90786>>>>>>>                Function_Return False
90787>>>>>>>            End
90787>>>>>>>>
90787>>>>>>>        End
90787>>>>>>>>
90787>>>>>>>
90787>>>>>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
90787>>>>>>>        If (bIsDateTypeFrom = False) Begin
90789>>>>>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
90791>>>>>>>                Function_Return False
90792>>>>>>>            End
90792>>>>>>>>
90792>>>>>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
90794>>>>>>>                Function_Return False
90795>>>>>>>            End
90795>>>>>>>>
90795>>>>>>>        End
90795>>>>>>>>
90795>>>>>>>
90795>>>>>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
90797>>>>>>>            Function_Return False
90798>>>>>>>        End
90798>>>>>>>>
90798>>>>>>>
90798>>>>>>>        Function_Return True
90799>>>>>>>    End_Function
90800>>>>>>>
90800>>>>>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
90802>>>>>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iCheckFieldNumber iDriverID
90802>>>>>>>        Boolean bIdentityKey bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
90802>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90802>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90804>>>>>>>        String sDriverID sRootName sLogicalName sDataType
90804>>>>>>>
90804>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90805>>>>>>>        Get piDbType to iDbType
90806>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90809>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
90812>>>>>>>
90812>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90815>>>>>>>        If (bIsOpen = False) Begin
90817>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90818>>>>>>>            Open hTable
90820>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90821>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90824>>>>>>>            If (bIsOpen = False) Begin
90826>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90827>>>>>>>                Move True to APIColumnsEmpty[0].bError
90828>>>>>>>                Function_Return APIColumnsEmpty
90829>>>>>>>            End
90829>>>>>>>>
90829>>>>>>>        End
90829>>>>>>>>
90829>>>>>>>
90829>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
90832>>>>>>>        Get IsSQLDriver    sDriverID to bSqlDriver
90833>>>>>>>        Get _UtilTableIsSqlByRootName sRootName to bIsSqlTable
90834>>>>>>>        If (bIsSqlTable = True) Begin
90836>>>>>>>            Get _UtilTableExists hTable to bExists
90837>>>>>>>            If (bExists = False) Begin
90839>>>>>>>                Move True to APIColumnsEmpty[0].bError
90840>>>>>>>                Function_Return APIColumnsEmpty
90841>>>>>>>            End
90841>>>>>>>>
90841>>>>>>>        End
90841>>>>>>>>
90841>>>>>>>//        Get DriverIndex sDriverID to iDriverID
90841>>>>>>>//        If (sDriverID = MSSQLDRV_ID) Begin
90841>>>>>>>//            Set_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE of iDriverId to 'datetime2'
90841>>>>>>>//        End
90841>>>>>>>
90841>>>>>>>        Move 0 to iCount
90842>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90845>>>>>>>        Set piMaximum of ghoProgressBar to iNumColumns
90846>>>>>>>
90846>>>>>>>        for iColumn from 1 to iNumColumns
90852>>>>>>>>
90852>>>>>>>            Move 0 to iOptions
90853>>>>>>>            Move False to bIdentityKey
90854>>>>>>>            Move False to Err
90855>>>>>>>            Move 0     to LastErr
90856>>>>>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
90857>>>>>>>            Set piPosition of ghoProgressBar to iColumn
90858>>>>>>>
90858>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90859>>>>>>>            If (bIsSqlTable = True) Begin 
90861>>>>>>>//                If (iType = DF_DATE) Begin
90861>>>>>>>//                    // Note: This is actually the same as SQL_DATETIME
90861>>>>>>>//                    Move SQL_DATE to iType
90861>>>>>>>//                    Move 3 to APIColumns[iCouknt].iPrecision
90861>>>>>>>//                End
90861>>>>>>>//                Else If (iType = DF_DATET Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iTypeIME) Begin
90861>>>>>>>//                    // In modern MS-SQL databases SQL_DATETIME will be = to "datetime2".
90861>>>>>>>//                    // By default MS-SQL will create such a field with 7 (!) decimal places.
90861>>>>>>>//                    // This is just a waste because DataFlex will truncate that to 3 decimal
90861>>>>>>>//                    // places. Therefore, we hard-code the precision to be only thee decimals.
90861>>>>>>>//                    Move SQL_DATETIME to iType
90861>>>>>>>//                    Move 3 to APIColumns[iCount].iPrecision
90861>>>>>>>//                End
90861>>>>>>>//                Move iType                                                to APIColumns[iCount].iType
90861>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to APIColumns[iCount].iType
90864>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
90867>>>>>>>                Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
90870>>>>>>>                Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue
90873>>>>>>>            End
90873>>>>>>>>
90873>>>>>>>            Else Begin
90874>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
90877>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90878>>>>>>>            End
90878>>>>>>>>
90878>>>>>>>
90878>>>>>>>            // If the array value is out of bounce it means that this column doesn't exist on the backend.
90878>>>>>>>            Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
90881>>>>>>>            Move (iCheckFieldNumber >= 0) to bExists
90882>>>>>>>            If (bExists = False) Begin
90884>>>>>>>                Move 0 to APIColumns[iCount].iType
90885>>>>>>>            End
90885>>>>>>>>
90885>>>>>>>            If (bExists = True) Begin
90887>>>>>>>                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
90890>>>>>>>            End
90890>>>>>>>>
90890>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90891>>>>>>>            If (bIdentityKey = True) Begin
90893>>>>>>>                Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
90894>>>>>>>            End
90894>>>>>>>>
90894>>>>>>>
90894>>>>>>>//            Else Begin
90894>>>>>>>//                Move False to Err
90894>>>>>>>//                Move 0     to LastErr
90894>>>>>>>//                If (bIsSqlTable = True) Begin
90894>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
90894>>>>>>>//                End
90894>>>>>>>//                Else Begin
90894>>>>>>>//                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
90894>>>>>>>//                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90894>>>>>>>//                End
90894>>>>>>>//                // If the array value is out of bounce it means that this column doesn't exist on the backend.
90894>>>>>>>//                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
90894>>>>>>>//                If (bExists = False) Begin
90894>>>>>>>//                    Move 0 to APIColumns[iCount].iType
90894>>>>>>>//                End
90894>>>>>>>//            End
90894>>>>>>>
90894>>>>>>>            If (bExists = True) Begin
90896>>>>>>>                Move iColumn to APIColumns[iCount].iFieldNumber
90897>>>>>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
90900>>>>>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
90900>>>>>>>//                If (bIsSqlTable = True) Begin
90900>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
90900>>>>>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90900>>>>>>>//                End
90900>>>>>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength 
90903>>>>>>>                If (APIColumns[iCount].iPrecision = 0) Begin
90905>>>>>>>                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90908>>>>>>>                End
90908>>>>>>>>
90908>>>>>>>
90908>>>>>>>                // If the length was zero we might have an Overlap(!) field.
90908>>>>>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
90908>>>>>>>                If (APIColumns[iCount].iLength = 0) Begin
90910>>>>>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
90913>>>>>>>                    If (iType = DF_OVERLAP) Begin
90915>>>>>>>                        Move 0 to APIColumns[iCount].iFieldNumber
90916>>>>>>>                        Move 0 to APIColumns[iCount].iLength
90917>>>>>>>                        Move 0 to APIColumns[iCount].iOptions
90918>>>>>>>                        Move 0 to APIColumns[iCount].iPrecision
90919>>>>>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
90920>>>>>>>                        Move "" to APIColumns[iCount].sFieldName
90921>>>>>>>                        Decrement iCount
90922>>>>>>>                    End
90922>>>>>>>>
90922>>>>>>>                End
90922>>>>>>>>
90922>>>>>>>            End
90922>>>>>>>>
90922>>>>>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
90923>>>>>>>            If (bUserCancel = True) Begin
90925>>>>>>>                Move True to APIColumnsEmpty[0].bCancel
90926>>>>>>>                Function_Return APIColumnsEmpty
90927>>>>>>>            End
90927>>>>>>>>
90927>>>>>>>            Increment iCount
90928>>>>>>>        Loop
90929>>>>>>>>
90929>>>>>>>
90929>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90930>>>>>>>        Function_Return APIColumns
90931>>>>>>>    End_Function
90932>>>>>>>     
90932>>>>>>>    // ToDo: Shouldn't this be the other way round? The From bit last? That is what should be of interest??
90932>>>>>>>    // *** 
90932>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO column arrays.
90932>>>>>>>    // The combined data will be sorted on the first struct member: iFieldNumber
90932>>>>>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
90934>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
90934>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
90935>>>>>>>        tAPIColumnCompare   APIColumnCompare
90935>>>>>>>        tAPIColumnCompare   APIColumnCompare
90935>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90935>>>>>>>
90935>>>>>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
90936>>>>>>>        Decrement iSizeFrom
90937>>>>>>>        for iCount from 0 to iSizeFrom
90943>>>>>>>>
90943>>>>>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
90944>>>>>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
90945>>>>>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
90946>>>>>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
90947>>>>>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
90948>>>>>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
90949>>>>>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
90950>>>>>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom
90951>>>>>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
90952>>>>>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
90953>>>>>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
90954>>>>>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
90955>>>>>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
90956>>>>>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
90957>>>>>>>        Loop
90958>>>>>>>>
90958>>>>>>>
90958>>>>>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
90959>>>>>>>        Decrement iSizeTo
90960>>>>>>>        for iCount from 0 to iSizeTo
90966>>>>>>>>
90966>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
90967>>>>>>>            // Search if the field number already exists in the "to" array; else add it. <
90967>>>>>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
90968>>>>>>>            If (iItem = -1) Begin
90970>>>>>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
90971>>>>>>>            End
90971>>>>>>>>
90971>>>>>>>
90971>>>>>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
90972>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
90973>>>>>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
90974>>>>>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
90975>>>>>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
90976>>>>>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
90977>>>>>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
90978>>>>>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
90979>>>>>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
90980>>>>>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
90981>>>>>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
90982>>>>>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
90983>>>>>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
90984>>>>>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
90985>>>>>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
90986>>>>>>>        Loop
90987>>>>>>>>
90987>>>>>>>
90987>>>>>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
90988>>>>>>>
90988>>>>>>>        Function_Return aAPIColumnCompare
90989>>>>>>>    End_Function
90990>>>>>>>
90990>>>>>>>    // Checks if a field name exists in a table definition
90990>>>>>>>    // Returns True if it does
90990>>>>>>>    // Sample:
90990>>>>>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
90990>>>>>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
90992>>>>>>>        Integer iNumColumns iColumn
90992>>>>>>>        String sColumn
90992>>>>>>>        Boolean bExists bOK bOpen
90992>>>>>>>
90992>>>>>>>        Get AutoConnectionIDLogin to bOK
90993>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90994>>>>>>>        Open hTable
90996>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90997>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91000>>>>>>>        If (bOpen = False) Begin
91002>>>>>>>            Function_Return False
91003>>>>>>>        End
91003>>>>>>>>
91003>>>>>>>
91003>>>>>>>        Move False to bExists
91004>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
91007>>>>>>>        for iColumn from 1 to iNumColumns
91013>>>>>>>>
91013>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
91016>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
91018>>>>>>>                Move iNumColumns to iColumn
91019>>>>>>>                Move True to bExists
91020>>>>>>>            End
91020>>>>>>>>
91020>>>>>>>        Loop
91021>>>>>>>>
91021>>>>>>>        Close hTable
91022>>>>>>>
91022>>>>>>>        Function_Return bExists
91023>>>>>>>    End_Function
91024>>>>>>>
91024>>>>>>>    // Returns the field/column number for the passed FieldName as an integer.
91024>>>>>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
91026>>>>>>>        Integer iNumColumns iColumn iRetval
91026>>>>>>>        String sColumn
91026>>>>>>>        Boolean bOK bOpen
91026>>>>>>>
91026>>>>>>>        Get AutoConnectionIDLogin to bOK
91027>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91028>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91029>>>>>>>        Open hTable
91031>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91032>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91035>>>>>>>        If (bOpen = False) Begin
91037>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
91038>>>>>>>            Function_Return False
91039>>>>>>>        End
91039>>>>>>>>
91039>>>>>>>
91039>>>>>>>        Move 0 to iColumn
91040>>>>>>>        Move 0 to iRetval
91041>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
91044>>>>>>>        for iColumn from 1 to iNumColumns
91050>>>>>>>>
91050>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
91053>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
91055>>>>>>>                Move iColumn to iRetval
91056>>>>>>>                Move iNumColumns to iColumn
91057>>>>>>>            End
91057>>>>>>>>
91057>>>>>>>        Loop
91058>>>>>>>>
91058>>>>>>>        Close hTable
91059>>>>>>>
91059>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91060>>>>>>>        Function_Return iRetval
91061>>>>>>>    End_Function
91062>>>>>>>
91062>>>>>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
91062>>>>>>>    // The reciprocal function is UtilColumnTypeToString.
91062>>>>>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
91064>>>>>>>        tColumnType RetvalType
91064>>>>>>>        tColumnType RetvalType
91064>>>>>>>
91064>>>>>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
91065>>>>>>>        Function_Return RetvalType.iSQLType
91066>>>>>>>    End_Function
91067>>>>>>>
91067>>>>>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
91067>>>>>>>    // The reciprocal function is UtilColumnTypeToString.
91067>>>>>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
91069>>>>>>>        tColumnType RetvalType
91069>>>>>>>        tColumnType RetvalType
91069>>>>>>>
91069>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91070>>>>>>>        Function_Return RetvalType.sSQLType
91071>>>>>>>    End_Function
91072>>>>>>>
91072>>>>>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
91074>>>>>>>        tColumnType RetvalType
91074>>>>>>>        tColumnType RetvalType
91074>>>>>>>
91074>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91075>>>>>>>        Function_Return RetvalType.sPrecision
91076>>>>>>>    End_Function
91077>>>>>>>
91077>>>>>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
91079>>>>>>>        tColumnType RetvalType
91079>>>>>>>        tColumnType RetvalType
91079>>>>>>>
91079>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91080>>>>>>>        // Nils 2019-02-15. This return value seems to have been wrong. The function should return False
91080>>>>>>>        // if the column type length is _not_ fixed.
91080>>>>>>>        Function_Return (RetvalType.bCanEditSize = False)
91081>>>>>>>    End_Function
91082>>>>>>>
91082>>>>>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
91084>>>>>>>        tColumnType RetvalType
91084>>>>>>>        tColumnType RetvalType
91084>>>>>>>        String sValue
91084>>>>>>>        Integer iRetval iPos
91084>>>>>>>
91084>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91085>>>>>>>        Move RetvalType.sPrecision to sValue
91086>>>>>>>        Move (Pos(".", sValue)) to iPos
91087>>>>>>>        If (iPos <> 0) Begin
91089>>>>>>>            Move (Left(sValue, (iPos -1))) to iRetval
91090>>>>>>>        End
91090>>>>>>>>
91090>>>>>>>        Else Begin
91091>>>>>>>            Move sValue to iRetval
91092>>>>>>>        End
91092>>>>>>>>
91092>>>>>>>        Function_Return iRetval
91093>>>>>>>    End_Function
91094>>>>>>>
91094>>>>>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
91096>>>>>>>        tColumnType RetvalType
91096>>>>>>>        tColumnType RetvalType
91096>>>>>>>        String sValue
91096>>>>>>>        Integer iRetval iPos
91096>>>>>>>
91096>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91097>>>>>>>        Move RetvalType.sPrecision to sValue
91098>>>>>>>        Move (Pos(".", sValue)) to iPos
91099>>>>>>>        If (iPos = 0) Begin
91101>>>>>>>            Function_Return 0
91102>>>>>>>        End
91102>>>>>>>>
91102>>>>>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
91103>>>>>>>
91103>>>>>>>        Function_Return iRetval
91104>>>>>>>    End_Function
91105>>>>>>>
91105>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91105>>>>>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
91107>>>>>>>        Function_Return False
91108>>>>>>>    End_Function
91109>>>>>>>
91109>>>>>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
91109>>>>>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
91111>>>>>>>        Boolean bIsSame
91111>>>>>>>        Integer iCount iSize
91111>>>>>>>
91111>>>>>>>        Move True to bIsSame
91112>>>>>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
91113>>>>>>>        Decrement iSize
91114>>>>>>>        For iCount from 0 to iSize
91120>>>>>>>>
91120>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91121>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
91122>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
91123>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
91124>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
91125>>>>>>>            If (bIsSame = False) Begin
91127>>>>>>>                Function_Return False
91128>>>>>>>            End
91128>>>>>>>>
91128>>>>>>>        Loop
91129>>>>>>>>
91129>>>>>>>
91129>>>>>>>        Function_Return bIsSame
91130>>>>>>>    End_Function
91131>>>>>>>
91131>>>>>>>    // Compares a single index for a 'FROM' and a 'TO' table.
91131>>>>>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
91133>>>>>>>        Boolean bIsSame
91133>>>>>>>        Integer iSegment
91133>>>>>>>
91133>>>>>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
91134>>>>>>>        If (bIsSame = False) Begin
91136>>>>>>>            Function_Return False
91137>>>>>>>        End
91137>>>>>>>>
91137>>>>>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
91138>>>>>>>        If (bIsSame = False) Begin
91140>>>>>>>            Function_Return False
91141>>>>>>>        End
91141>>>>>>>>
91141>>>>>>>
91141>>>>>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
91143>>>>>>>            // * We should probably not compare SQL index names?
91143>>>>>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
91143>>>>>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
91143>>>>>>>            //     Function_Return False
91143>>>>>>>            // End
91143>>>>>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
91144>>>>>>>            If (bIsSame = False) Begin
91146>>>>>>>                Function_Return False
91147>>>>>>>            End
91147>>>>>>>>
91147>>>>>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
91148>>>>>>>            If (bIsSame = False) Begin
91150>>>>>>>                Function_Return False
91151>>>>>>>            End
91151>>>>>>>>
91151>>>>>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
91152>>>>>>>            If (bIsSame = False) Begin
91154>>>>>>>                Function_Return False
91155>>>>>>>            End
91155>>>>>>>>
91155>>>>>>>            Move (Uppercase(APIIndexCompare.sSQLIndexNameFrom) = Uppercase(APIIndexCompare.sSQLIndexNameTo)) to bIsSame
91156>>>>>>>            If (bIsSame = False) Begin
91158>>>>>>>                Function_Return False
91159>>>>>>>            End
91159>>>>>>>>
91159>>>>>>>        End
91159>>>>>>>>
91159>>>>>>>
91159>>>>>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
91160>>>>>>>        Move (iSegment = -1) to bIsSame
91161>>>>>>>
91161>>>>>>>        Function_Return bIsSame
91162>>>>>>>    End_Function
91163>>>>>>>
91163>>>>>>>    // Compares each segment for the passed index.
91163>>>>>>>    // Returns -1 if same; else returns the index segment that differs.
91163>>>>>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
91165>>>>>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
91165>>>>>>>        Boolean bIsSame
91165>>>>>>>
91165>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
91166>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91167>>>>>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
91168>>>>>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo 
91169>>>>>>>        If (iNumSegmentsFrom <> iNumSegmentsTo) Begin
91171>>>>>>>            Function_Return -1
91172>>>>>>>        End
91172>>>>>>>>
91172>>>>>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
91173>>>>>>>
91173>>>>>>>        Decrement iNumSegments
91174>>>>>>>        for iSegment from 0 to iNumSegments
91180>>>>>>>>
91180>>>>>>>            Move False to bIsSame
91181>>>>>>>            If (iSegment < iNumSegmentsFrom and iSegment < iNumSegmentsTo) Begin
91183>>>>>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
91184>>>>>>>            End
91184>>>>>>>>
91184>>>>>>>            If (bIsSame = False) Begin
91186>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
91187>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91188>>>>>>>                Function_Return iSegment
91189>>>>>>>            End
91189>>>>>>>>
91189>>>>>>>        Loop
91190>>>>>>>>
91190>>>>>>>
91190>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91191>>>>>>>        Function_Return -1 // This means bIsSame = True
91192>>>>>>>    End_Function
91193>>>>>>>
91193>>>>>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
91195>>>>>>>        Boolean bIsSame
91195>>>>>>>
91195>>>>>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
91196>>>>>>>        If (bIsSame = False) Begin
91198>>>>>>>            Function_Return False
91199>>>>>>>        End
91199>>>>>>>>
91199>>>>>>>        If (bCompareIndexUppercase = True) Begin
91201>>>>>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
91202>>>>>>>            If (bIsSame = False) Begin
91204>>>>>>>                Function_Return False
91205>>>>>>>            End
91205>>>>>>>>
91205>>>>>>>        End
91205>>>>>>>>
91205>>>>>>>        If (bCompareIndexAscending = True) Begin
91207>>>>>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
91208>>>>>>>            If (bIsSame = False) Begin
91210>>>>>>>                Function_Return False
91211>>>>>>>            End
91211>>>>>>>>
91211>>>>>>>        End
91211>>>>>>>>
91211>>>>>>>
91211>>>>>>>        Function_Return True
91212>>>>>>>    End_Function
91213>>>>>>>
91213>>>>>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
91215>>>>>>>        Boolean bIsSame bOK
91215>>>>>>>        Integer iSize iSizeTo iCount
91215>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
91215>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
91216>>>>>>>
91216>>>>>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
91217>>>>>>>        If (iSize = 0) Begin
91219>>>>>>>            Function_Return True
91220>>>>>>>        End
91220>>>>>>>>
91220>>>>>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo
91221>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
91222>>>>>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
91223>>>>>>>
91223>>>>>>>        For iCount from 0 to (iSize - 1)
91229>>>>>>>>
91229>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
91230>>>>>>>            If (bIsSame = False) Begin
91232>>>>>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
91233>>>>>>>            End
91233>>>>>>>>
91233>>>>>>>        Loop
91234>>>>>>>>
91234>>>>>>>
91234>>>>>>>        // We probably should delete other indexes if they exists.
91234>>>>>>>        For iCount from (iSize +1) to iSizeTo
91240>>>>>>>>
91240>>>>>>>            Get ApiIndexRemove hTable iCount to bOK
91241>>>>>>>        Loop
91242>>>>>>>>
91242>>>>>>>
91242>>>>>>>        Function_Return bOK
91243>>>>>>>    End_Function
91244>>>>>>>
91244>>>>>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
91246>>>>>>>        tAPIIndex[] APIIndexes
91246>>>>>>>        tAPIIndex[] APIIndexes
91247>>>>>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
91247>>>>>>>        String sDriverID
91247>>>>>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable
91247>>>>>>>
91247>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91248>>>>>>>        Get psDriverID to sDriverID
91249>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
91250>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
91251>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91254>>>>>>>        If (bIsOpen = False) Begin
91256>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91257>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91258>>>>>>>            Open hTable
91260>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
91261>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91262>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91265>>>>>>>            If (bIsOpen = False) Begin
91267>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91268>>>>>>>                Move True to APIIndexes[0].bError
91269>>>>>>>                Function_Return APIIndexes
91270>>>>>>>            End
91270>>>>>>>>
91270>>>>>>>        End
91270>>>>>>>>
91270>>>>>>>
91270>>>>>>>        Move 0 to iCount
91271>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
91274>>>>>>>        For iIndex from 1 to iIndexes
91280>>>>>>>>
91280>>>>>>>            // This is a test that the index exists as there might be "holes" aka the index
91280>>>>>>>            // numbers doesn't not need to be consequitive:
91280>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
91283>>>>>>>            If (iNumSegments > 0) Begin
91285>>>>>>>
91285>>>>>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
91286>>>>>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
91289>>>>>>>                If (bIsSQLTable = True) Begin
91291>>>>>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
91294>>>>>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
91297>>>>>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
91300>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
91303>>>>>>>                End
91303>>>>>>>>
91303>>>>>>>
91303>>>>>>>                Move 0 to iSegmentCount
91304>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
91307>>>>>>>                For iSegment from 1 to iNumSegments
91313>>>>>>>>
91313>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
91316>>>>>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
91317>>>>>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
91320>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
91323>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
91326>>>>>>>                    Increment iSegmentCount
91327>>>>>>>                Loop
91328>>>>>>>>
91328>>>>>>>                Increment iCount
91329>>>>>>>            End
91329>>>>>>>>
91329>>>>>>>        Loop
91330>>>>>>>>
91330>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91331>>>>>>>
91331>>>>>>>        Function_Return APIIndexes
91332>>>>>>>    End_Function
91333>>>>>>>
91333>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
91333>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
91333>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
91333>>>>>>>    // have "holes" in the series of index numbers.
91333>>>>>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
91335>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
91335>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
91336>>>>>>>        tAPIIndexCompare   APIIndexCompare
91336>>>>>>>        tAPIIndexCompare   APIIndexCompare
91336>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
91336>>>>>>>
91336>>>>>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
91337>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
91338>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
91340>>>>>>>            Function_Return aAPIIndexCompare
91341>>>>>>>        End
91341>>>>>>>>
91341>>>>>>>
91341>>>>>>>        Decrement iSizeFrom
91342>>>>>>>        for iCount from 0 to iSizeFrom
91348>>>>>>>>
91348>>>>>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
91349>>>>>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
91350>>>>>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
91351>>>>>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
91352>>>>>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
91353>>>>>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
91354>>>>>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
91355>>>>>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
91356>>>>>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
91357>>>>>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
91358>>>>>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
91359>>>>>>>        Loop
91360>>>>>>>>
91360>>>>>>>
91360>>>>>>>        Decrement iSizeTo
91361>>>>>>>        for iCount from 0 to iSizeTo
91367>>>>>>>>
91367>>>>>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
91368>>>>>>>            // Search if the Index number already exists in the array; else add it.
91368>>>>>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
91369>>>>>>>            If (iItem = -1) Begin
91371>>>>>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
91372>>>>>>>            End
91372>>>>>>>>
91372>>>>>>>
91372>>>>>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
91373>>>>>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
91374>>>>>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
91375>>>>>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
91376>>>>>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
91377>>>>>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
91378>>>>>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
91379>>>>>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
91380>>>>>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
91381>>>>>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
91382>>>>>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
91383>>>>>>>        Loop
91384>>>>>>>>
91384>>>>>>>
91384>>>>>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
91385>>>>>>>
91385>>>>>>>        Function_Return aAPIIndexCompare
91386>>>>>>>    End_Function
91387>>>>>>>
91387>>>>>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
91387>>>>>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
91389>>>>>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
91389>>>>>>>        String sDriverID
91389>>>>>>>
91389>>>>>>>        Get psDriverID to sDriverID
91390>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
91391>>>>>>>        Get IsSQLDriver sDriverID to bIsSqlTable
91392>>>>>>>        If (bIsSqlTable = True) Begin
91394>>>>>>>            Get _UtilTableIsSql hTable to bIsSqlTable
91395>>>>>>>        End
91395>>>>>>>>
91395>>>>>>>
91395>>>>>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
91396>>>>>>>        If (bIsSame = False) Begin
91398>>>>>>>            Function_Return False
91399>>>>>>>        End
91399>>>>>>>>
91399>>>>>>>
91399>>>>>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
91401>>>>>>>            // Don't think we should do this. Or should we?
91401>>>>>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
91401>>>>>>>
91401>>>>>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
91402>>>>>>>            If (bIsSame = False) Begin
91404>>>>>>>                Function_Return False
91405>>>>>>>            End
91405>>>>>>>>
91405>>>>>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
91406>>>>>>>            If (bIsSame = False) Begin
91408>>>>>>>                Function_Return False
91409>>>>>>>            End
91409>>>>>>>>
91409>>>>>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
91410>>>>>>>            If (bIsSame = False) Begin
91412>>>>>>>                Function_Return False
91413>>>>>>>            End
91413>>>>>>>>
91413>>>>>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
91414>>>>>>>            If (bIsSame = False) Begin
91416>>>>>>>                Function_Return False
91417>>>>>>>            End
91417>>>>>>>>
91417>>>>>>>        End
91417>>>>>>>>
91417>>>>>>>
91417>>>>>>>        Function_Return bIsSame
91418>>>>>>>    End_Function
91419>>>>>>>
91419>>>>>>>    // DF_INDEX_SQL_TYPE values
91419>>>>>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
91419>>>>>>>    // returns a string with the name.
91419>>>>>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
91421>>>>>>>        String sRetval
91421>>>>>>>            Case Begin
91421>>>>>>>                Case (iIndexType = DF_INDEX_CLIENT)
91423>>>>>>>                    Move "DF_INDEX_CLIENT" to sRetval
91424>>>>>>>                    Case Break
91425>>>>>>>                Case (iIndexType = DF_INDEX_SERVER)
91428>>>>>>>                    Move "DF_INDEX_SERVER" to sRetval
91429>>>>>>>                    Case Break
91430>>>>>>>                Case (iIndexType = DF_INDEX_SERVER_ONLY)
91433>>>>>>>                    Move "DF_INDEX_SERVER_ONLY" to sRetval
91434>>>>>>>                    Case Break
91435>>>>>>>                Case (iIndexType = DF_INDEX_TEMPORARY)
91438>>>>>>>                    Move "DF_INDEX_TEMPORARY" to sRetval
91439>>>>>>>                    Case Break
91440>>>>>>>                Case Else
91440>>>>>>>                    Move "UNKNOWN INDEX TYPE" to sRetval
91441>>>>>>>            Case End
91441>>>>>>>        Function_Return sRetval
91442>>>>>>>    End_Function
91443>>>>>>>
91443>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91443>>>>>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
91445>>>>>>>        Function_Return False
91446>>>>>>>    End_Function
91447>>>>>>>
91447>>>>>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
91447>>>>>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
91449>>>>>>>        Boolean bIsSame
91449>>>>>>>        Integer iSize iCount
91449>>>>>>>
91449>>>>>>>        Move True to bIsSame
91450>>>>>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
91451>>>>>>>        Decrement iSize
91452>>>>>>>        For iCount from 0 to iSize
91458>>>>>>>>
91458>>>>>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
91459>>>>>>>            If (bIsSame = False) Begin
91461>>>>>>>                Function_Return False
91462>>>>>>>            End
91462>>>>>>>>
91462>>>>>>>        Loop
91463>>>>>>>>
91463>>>>>>>
91463>>>>>>>        Function_Return bIsSame
91464>>>>>>>    End_Function
91465>>>>>>>
91465>>>>>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
91465>>>>>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
91467>>>>>>>        Boolean bIsSame
91467>>>>>>>
91467>>>>>>>        Move True to bIsSame
91468>>>>>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
91470>>>>>>>            Function_Return False
91471>>>>>>>        End
91471>>>>>>>>
91471>>>>>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
91473>>>>>>>            Function_Return False
91474>>>>>>>        End
91474>>>>>>>>
91474>>>>>>>
91474>>>>>>>        // We could also compare field names, but I don't think that is necessary...
91474>>>>>>>
91474>>>>>>>        Function_Return bIsSame
91475>>>>>>>    End_Function
91476>>>>>>>
91476>>>>>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
91476>>>>>>>    // already exists.
91476>>>>>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
91478>>>>>>>        Boolean bOK
91478>>>>>>>        Integer iSizeTo iSize iCount iColumn
91478>>>>>>>        String sDriverID
91478>>>>>>>
91478>>>>>>>        Move True to bOK
91479>>>>>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
91480>>>>>>>        If (iSizeTo > 0) Begin
91482>>>>>>>            Get AutoConnectionIDLogin to bOK
91483>>>>>>>            Move False to Err
91484>>>>>>>            Open hTable Mode DF_EXCLUSIVE
91486>>>>>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
91489>>>>>>>            Decrement iSizeTo
91490>>>>>>>
91490>>>>>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
91490>>>>>>>            // for the "TO" database. But start by deleting all current "TO" relations:
91490>>>>>>>            Structure_Start hTable sDriverID
91491>>>>>>>                for iCount from 0 to iSizeTo
91497>>>>>>>>
91497>>>>>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
91498>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
91501>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
91504>>>>>>>                Loop
91505>>>>>>>>
91505>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
91506>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91508>>>>>>>            Set Action_Text of ghoStatusPanel to ""
91509>>>>>>>        End
91509>>>>>>>>
91509>>>>>>>
91509>>>>>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
91510>>>>>>>        Decrement iSize
91511>>>>>>>        for iCount from 0 to iSize
91517>>>>>>>>
91517>>>>>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
91518>>>>>>>        Loop
91519>>>>>>>>
91519>>>>>>>
91519>>>>>>>        Function_Return bOK
91520>>>>>>>    End_Function
91521>>>>>>>
91521>>>>>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
91523>>>>>>>        tAPIRelation[] APIRelations
91523>>>>>>>        tAPIRelation[] APIRelations
91524>>>>>>>        Integer iColumn iColumnTo iNumColumns iCount
91524>>>>>>>        Handle hParent
91524>>>>>>>        Boolean bIsOpen
91524>>>>>>>
91524>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91525>>>>>>>        Move 0 to iCount
91526>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91529>>>>>>>        If (bIsOpen = False) Begin
91531>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91532>>>>>>>            Open hTable
91534>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91535>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91538>>>>>>>            If (bIsOpen = False) Begin
91540>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91541>>>>>>>                Move True to APIRelations[0].bError
91542>>>>>>>                Function_Return APIRelations
91543>>>>>>>            End
91543>>>>>>>>
91543>>>>>>>        End
91543>>>>>>>>
91543>>>>>>>
91543>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
91546>>>>>>>        For iColumn from 1 to iNumColumns
91552>>>>>>>>
91552>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
91555>>>>>>>            If (hParent <> 0) Begin
91557>>>>>>>                Open hParent
91559>>>>>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
91560>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
91563>>>>>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
91564>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
91567>>>>>>>
91567>>>>>>>                Move hParent                                            to APIRelations[iCount].hTableTo
91568>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
91571>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
91574>>>>>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
91575>>>>>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
91578>>>>>>>                Move False                                              to APIRelations[iCount].bShouldChange
91579>>>>>>>                Move False                                              to APIRelations[iCount].bCancel
91580>>>>>>>                Move False                                              to APIRelations[iCount].bError
91581>>>>>>>                Close hParent
91582>>>>>>>                Increment iCount
91583>>>>>>>            End
91583>>>>>>>>
91583>>>>>>>        Loop
91584>>>>>>>>
91584>>>>>>>
91584>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91585>>>>>>>        Function_Return APIRelations
91586>>>>>>>    End_Function
91587>>>>>>>
91587>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO relation arrays.
91587>>>>>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
91587>>>>>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
91589>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
91589>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
91590>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
91590>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
91591>>>>>>>        tAPIRelationCompare   APIRelationCompare
91591>>>>>>>        tAPIRelationCompare   APIRelationCompare
91591>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
91591>>>>>>>
91591>>>>>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
91592>>>>>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
91593>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
91595>>>>>>>            Function_Return aAPIRelationCompare
91596>>>>>>>        End
91596>>>>>>>>
91596>>>>>>>
91596>>>>>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
91597>>>>>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(__UtilRelationArrayCompare))) to aAPIRelationFromAndTo
91598>>>>>>>
91598>>>>>>>        Decrement iSizeFrom
91599>>>>>>>        for iCount from 0 to iSizeFrom
91605>>>>>>>>
91605>>>>>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
91606>>>>>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
91607>>>>>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
91608>>>>>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
91609>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
91610>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
91611>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
91612>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
91613>>>>>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
91614>>>>>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
91615>>>>>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
91616>>>>>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
91617>>>>>>>        Loop
91618>>>>>>>>
91618>>>>>>>
91618>>>>>>>        Decrement iSizeTo
91619>>>>>>>        for iCount from 0 to iSizeTo
91625>>>>>>>>
91625>>>>>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
91626>>>>>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
91627>>>>>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
91628>>>>>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
91629>>>>>>>
91629>>>>>>>            // Search if the relation already exists in the array; else add it.
91629>>>>>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to iItem
91630>>>>>>>            If (iItem = -1) Begin
91632>>>>>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
91633>>>>>>>            End
91633>>>>>>>>
91633>>>>>>>
91633>>>>>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
91634>>>>>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
91635>>>>>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
91636>>>>>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
91637>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
91638>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
91639>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
91640>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
91641>>>>>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
91642>>>>>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
91643>>>>>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
91644>>>>>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
91645>>>>>>>        Loop
91646>>>>>>>>
91646>>>>>>>
91646>>>>>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to aAPIRelationCompare
91647>>>>>>>
91647>>>>>>>        Function_Return aAPIRelationCompare
91648>>>>>>>    End_Function
91649>>>>>>>
91649>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91649>>>>>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
91651>>>>>>>        Function_Return False
91652>>>>>>>    End_Function
91653>>>>>>>
91653>>>>>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
91653>>>>>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
91653>>>>>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
91653>>>>>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
91655>>>>>>>        Boolean bFound
91655>>>>>>>
91655>>>>>>>        Move False to Err
91656>>>>>>>        Open CodeMast
91658>>>>>>>        Open CodeType
91660>>>>>>>
91660>>>>>>>        If (bCodeType = True) Begin
91662>>>>>>>            Set Private.phCurrentTable to CODETYPE.File_Number
91663>>>>>>>            Clear CodeType
91664>>>>>>>            Move sTypeValue to CODETYPE.Type
91665>>>>>>>            Find eq CODETYPE by 1
91666>>>>>>>>
91666>>>>>>>            Move Found to bFound
91667>>>>>>>            If (bFound = True) Begin
91669>>>>>>>                Reread CodeType
91673>>>>>>>            End
91673>>>>>>>>
91673>>>>>>>            Else Begin
91674>>>>>>>                Clear CodeType
91675>>>>>>>            End
91675>>>>>>>>
91675>>>>>>>
91675>>>>>>>            Move sTypeValue to CODETYPE.Type
91676>>>>>>>            Move sValue2    to CODETYPE.Description
91677>>>>>>>            Move sValue3    to CODETYPE.Comment
91678>>>>>>>            SaveRecord CODETYPE
91679>>>>>>>
91679>>>>>>>            If (bFound = True) Begin
91681>>>>>>>                Unlock
91682>>>>>>>>
91682>>>>>>>            End
91682>>>>>>>>
91682>>>>>>>        End
91682>>>>>>>>
91682>>>>>>>
91682>>>>>>>        If (bCodeType = False) Begin
91684>>>>>>>            Set Private.phCurrentTable to CODEMAST.File_Number
91685>>>>>>>            Clear CODEMAST
91686>>>>>>>            Move sTypeValue to CODEMAST.Type
91687>>>>>>>            Move sValue2    to CODEMAST.Code
91688>>>>>>>            Find eq CODEMAST by 1
91689>>>>>>>>
91689>>>>>>>            Move Found to bFound
91690>>>>>>>            If (bFound = True) Begin
91692>>>>>>>                Reread CODEMAST
91696>>>>>>>            End
91696>>>>>>>>
91696>>>>>>>            Else Begin
91697>>>>>>>                Clear CODEMAST
91698>>>>>>>            End
91698>>>>>>>>
91698>>>>>>>
91698>>>>>>>            Move sTypeValue to CODEMAST.Type
91699>>>>>>>            Move sValue2    to CODEMAST.Code
91700>>>>>>>            Move sValue3    to CODEMAST.Description
91701>>>>>>>            SaveRecord CODEMAST
91702>>>>>>>
91702>>>>>>>            If (bFound = True) Begin
91704>>>>>>>                Unlock
91705>>>>>>>>
91705>>>>>>>            End
91705>>>>>>>>
91705>>>>>>>        End
91705>>>>>>>>
91705>>>>>>>
91705>>>>>>>        Close CodeMast
91706>>>>>>>        Close CodeType
91707>>>>>>>
91707>>>>>>>        Function_Return (Err = False)
91708>>>>>>>    End_Function
91709>>>>>>>
91709>>>>>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
91709>>>>>>>    // CodeType and then spins through all CodeMast records to change all related records.
91709>>>>>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
91711>>>>>>>        Boolean bFound
91711>>>>>>>
91711>>>>>>>        Move False to Err
91712>>>>>>>        Open CodeMast
91714>>>>>>>        Open CodeType
91716>>>>>>>
91716>>>>>>>        Clear CodeType
91717>>>>>>>        Move sFromValue to CODETYPE.Type
91718>>>>>>>        Find eq CODETYPE.Type
91719>>>>>>>>
91719>>>>>>>        If (Found = True) Begin
91721>>>>>>>            Reread CODETYPE
91725>>>>>>>                Move sToValue to CODETYPE.Type
91726>>>>>>>                SaveRecord CODETYPE
91727>>>>>>>            Unlock
91728>>>>>>>>
91728>>>>>>>        End
91728>>>>>>>>
91728>>>>>>>
91728>>>>>>>        Clear CODEMAST
91729>>>>>>>        Find gt CODEMAST by Recnum
91730>>>>>>>>
91730>>>>>>>        While (Found = True)
91734>>>>>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
91735>>>>>>>            If (bFound = True) Begin
91737>>>>>>>                Reread CODEMAST
91741>>>>>>>                    Move sToValue to CODEMAST.Type
91742>>>>>>>                    SaveRecord CODEMAST
91743>>>>>>>                Unlock
91744>>>>>>>>
91744>>>>>>>            End
91744>>>>>>>>
91744>>>>>>>            Find gt CODEMAST by Recnum
91745>>>>>>>>
91745>>>>>>>        Loop
91746>>>>>>>>
91746>>>>>>>
91746>>>>>>>        Close CodeMast
91747>>>>>>>        Close CodeType
91748>>>>>>>
91748>>>>>>>        Function_Return (Err = False)
91749>>>>>>>    End_Function
91750>>>>>>>
91750>>>>>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
91750>>>>>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
91752>>>>>>>        Boolean bFound
91752>>>>>>>
91752>>>>>>>        Move False to Err
91753>>>>>>>        Open CodeMast
91755>>>>>>>
91755>>>>>>>        Clear CODEMAST
91756>>>>>>>        Move sTypeValue to CODEMAST.Type
91757>>>>>>>        Move sValue2    to CODEMAST.Code
91758>>>>>>>        Find eq CODEMAST.Code
91759>>>>>>>>
91759>>>>>>>        Move Found to bFound
91760>>>>>>>        If (bFound = True) Begin
91762>>>>>>>            Delete CODEMAST
91763>>>>>>>        End
91763>>>>>>>>
91763>>>>>>>
91763>>>>>>>        Close CodeMast
91764>>>>>>>
91764>>>>>>>        Function_Return (Err = False)
91765>>>>>>>    End_Function
91766>>>>>>>
91766>>>>>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
91768>>>>>>>        Boolean bRecnum bToAnsi
91768>>>>>>>        Integer iCh
91768>>>>>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
91768>>>>>>>
91768>>>>>>>        If (Trim(sDataPath) = "") Begin
91770>>>>>>>            Function_Return False
91771>>>>>>>        End
91771>>>>>>>>
91771>>>>>>>
91771>>>>>>>        Move False to Err
91772>>>>>>>        Get psDriverID     to sDriverID
91773>>>>>>>        Get psConnectionID to sConnectionID
91774>>>>>>>        Get psSchema       to sSchemaName
91775>>>>>>>        Get True           to bRecnum
91776>>>>>>>        Get pbToANSI       to bToAnsi
91777>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
91778>>>>>>>        If (bToAnsi = False) Begin
91780>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
91781>>>>>>>        End
91781>>>>>>>>
91781>>>>>>>
91781>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91782>>>>>>>        Move "CodeMast.int"         to sFileName
91783>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91784>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91787>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91790>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
91793>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91796>>>>>>>            Writeln channel iCh ("")
91799>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91802>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91805>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91808>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91811>>>>>>>            Writeln channel iCh ("")
91814>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91817>>>>>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
91820>>>>>>>            Writeln channel iCh ("")
91823>>>>>>>        Send Seq_Close_Channel iCh
91824>>>>>>>
91824>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91825>>>>>>>        Move "CodeType.int"         to sFileName
91826>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91827>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91830>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91833>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
91836>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91839>>>>>>>            Writeln channel iCh ("")
91842>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91845>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91848>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91851>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91854>>>>>>>            Writeln channel iCh ("")
91857>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 0")
91860>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
91863>>>>>>>            Writeln channel iCh ("")
91866>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91869>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
91872>>>>>>>            Writeln channel iCh ("")
91875>>>>>>>        Send Seq_Close_Channel iCh
91876>>>>>>>
91876>>>>>>>        Function_Return (Err = False)
91877>>>>>>>    End_Function
91878>>>>>>>
91878>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91878>>>>>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
91880>>>>>>>        Function_Return False
91881>>>>>>>    End_Function
91882>>>>>>>
91882>>>>>>>    // Use function to move *.fd, termlist.*, collate.*, dfcollate.* files to a "Data\Backup" folder,
91882>>>>>>>    // and to remove all *.cch files (DAW SQL driver cache files. They will get recreated when needed.)
91882>>>>>>>    Function UtilMoveMiscFilesToBackupFolder Returns Boolean
91884>>>>>>>        Boolean bOK bExists
91884>>>>>>>        String sDataPath sBackupFolder
91884>>>>>>>
91884>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving misc. files to Backup folder."
91885>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
91886>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
91887>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91888>>>>>>>
91888>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91889>>>>>>>        If (bExists = False) Begin
91891>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
91892>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91893>>>>>>>            If (bExists = False) Begin
91895>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all misc. files to. You need to move them somewhere manually.")
91896>>>>>>>>
91896>>>>>>>                Function_Return False
91897>>>>>>>            End
91897>>>>>>>>
91897>>>>>>>            Get vMoveFile (sDataPath + "*.fd")         (sDataPath + sBackupFolder) to bOK  
91898>>>>>>>            Get vMoveFile (sDataPath + "*.bad")        (sDataPath + sBackupFolder) to bOK  
91899>>>>>>>            Get vMoveFile (sDataPath + "*.err")        (sDataPath + sBackupFolder) to bOK  
91900>>>>>>>            Get vMoveFile (sDataPath + "*.bak")        (sDataPath + sBackupFolder) to bOK
91901>>>>>>>            Get vMoveFile (sDataPath + "*.def")        (sDataPath + sBackupFolder) to bOK
91902>>>>>>>            Get vMoveFile (sDataPath + "*.fil")        (sDataPath + sBackupFolder) to bOK
91903>>>>>>>            Get vMoveFile (sDataPath + "*.hlp")        (sDataPath + sBackupFolder) to bOK
91904>>>>>>>            Get vMoveFile (sDataPath + "*.old")        (sDataPath + sBackupFolder) to bOK           
91905>>>>>>>            Get vMoveFile (sDataPath + "*.prn")        (sDataPath + sBackupFolder) to bOK           
91906>>>>>>>            Get vMoveFile (sDataPath + "*.sts")        (sDataPath + sBackupFolder) to bOK           
91907>>>>>>>            Get vMoveFile (sDataPath + "*.td")         (sDataPath + sBackupFolder) to bOK           
91908>>>>>>>            Get vMoveFile (sDataPath + "*.log")        (sDataPath + sBackupFolder) to bOK           
91909>>>>>>>            Get vMoveFile (sDataPath + "*.bat")        (sDataPath + sBackupFolder) to bOK           
91910>>>>>>>            Get vMoveFile (sDataPath + "*.cmd")        (sDataPath + sBackupFolder) to bOK           
91911>>>>>>>            Get vMoveFile (sDataPath + "*.zip")        (sDataPath + sBackupFolder) to bOK           
91912>>>>>>>            Get vMoveFile (sDataPath + "*.abs")        (sDataPath + sBackupFolder) to bOK           
91913>>>>>>>            Get vMoveFile (sDataPath + "termlist.*")   (sDataPath + sBackupFolder) to bOK
91914>>>>>>>            Get vMoveFile (sDataPath + "*.dfr")        (sDataPath + sBackupFolder) to bOK
91915>>>>>>>            Get vMoveFile (sDataPath + "vsutil.cfg")   (sDataPath + sBackupFolder) to bOK
91916>>>>>>>            Get vMoveFile (sDataPath + "collate.*")    (sDataPath + sBackupFolder) to bOK
91917>>>>>>>            Get vMoveFile (sDataPath + "df_collate.*") (sDataPath + sBackupFolder) to bOK
91918>>>>>>>            Get vDeleteFile (sDataPath + "*.cch")                                  to bOK
91919>>>>>>>        End
91919>>>>>>>>
91919>>>>>>>
91919>>>>>>>        Set Message_Text of ghoStatusPanel to ""
91920>>>>>>>        Function_Return True
91921>>>>>>>    End_Function
91922>>>>>>>    
91922>>>>>>>    // Check if the file exists in the Data folder,
91922>>>>>>>    // else creates it from memory as it has been compiled into the program as a resource:
91922>>>>>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
91924>>>>>>>        String sPath
91924>>>>>>>        Boolean bExists
91924>>>>>>>
91924>>>>>>>        Get psDataPathFirstPart to sPath
91925>>>>>>>        Move (sPath + sFileName) to sFileName
91926>>>>>>>        Get vFilePathExists sFileName to bExists
91927>>>>>>>
91927>>>>>>>        If (bExists = False) Begin
91929>>>>>>>            // Read from memory & create file on disk.
91929>>>>>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
91930>>>>>>>            Get vFilePathExists sFileName to bExists
91931>>>>>>>        End
91931>>>>>>>>
91931>>>>>>>        Function_Return bExists
91932>>>>>>>    End_Function
91933>>>>>>>
91933>>>>>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
91935>>>>>>>        tColumnType RetvalType
91935>>>>>>>        tColumnType RetvalType
91935>>>>>>>        Integer iRetval
91935>>>>>>>
91935>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91936>>>>>>>        Move RetvalType.iDataFlexType to iRetval
91937>>>>>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
91939>>>>>>>            If (iLength <= 255) Begin
91941>>>>>>>                Move DF_ASCII to iRetval
91942>>>>>>>            End
91942>>>>>>>>
91942>>>>>>>        End
91942>>>>>>>>
91942>>>>>>>        Function_Return iRetval
91943>>>>>>>    End_Function
91944>>>>>>>             
91944>>>>>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
91946>>>>>>>        String sRetval
91946>>>>>>>
91946>>>>>>>        Case Begin
91946>>>>>>>            Case (iDataType = DF_ASCII)
91948>>>>>>>                Move "DF_ASCII" to sRetval
91949>>>>>>>                Case Break
91950>>>>>>>            Case (iDataType = DF_BCD)
91953>>>>>>>                Move "DF_BCD" to sRetval
91954>>>>>>>                Case Break
91955>>>>>>>            Case (iDataType = DF_BINARY)
91958>>>>>>>                Move "DF_BINARY" to sRetval
91959>>>>>>>                Case Break
91960>>>>>>>            Case (iDataType = DF_DATE)
91963>>>>>>>                Move "DF_DATE" to sRetval
91964>>>>>>>                Case Break
91965>>>>>>>            Case (iDataType = DF_DATETIME)
91968>>>>>>>                Move "DF_DATETIME" to sRetval
91969>>>>>>>                Case Break
91970>>>>>>>            Case (iDataType = DF_TEXT)
91973>>>>>>>                Move "DF_TEXT" to sRetval
91974>>>>>>>                Case Break
91975>>>>>>>            Case Else
91975>>>>>>>                Move "" to sRetval
91976>>>>>>>        Case End
91976>>>>>>>
91976>>>>>>>        Function_Return sRetval
91977>>>>>>>    End_Function
91978>>>>>>>
91978>>>>>>>    // The default value used for a datatype as specified in the driver int file.
91978>>>>>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
91980>>>>>>>        String sRetval sServer
91980>>>>>>>        tColumnType RetvalType
91980>>>>>>>        tColumnType RetvalType
91980>>>>>>>        Integer iDriver iDataFlexType
91980>>>>>>>        Handle hDatabase
91980>>>>>>>
91980>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91981>>>>>>>        Move RetvalType.iDataFlexType to iDataFlexType
91982>>>>>>>        Get DriverIndex sDriverID to iDriver
91983>>>>>>>        Get psServer to sServer
91984>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91985>>>>>>>        If (hDatabase = 0) Begin
91987>>>>>>>            Function_Return ""
91988>>>>>>>        End
91988>>>>>>>>
91988>>>>>>>
91988>>>>>>>        Case Begin
91988>>>>>>>            Case (iDataFlexType = DF_ASCII)
91990>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
91993>>>>>>>                Case Break
91994>>>>>>>            Case (iDataFlexType = DF_BCD)
91997>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
92000>>>>>>>                Case Break
92001>>>>>>>            Case (iDataFlexType = DF_BINARY)
92004>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
92007>>>>>>>                Case Break
92008>>>>>>>            Case (iDataFlexType = DF_DATE)
92011>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
92014>>>>>>>                Case Break
92015>>>>>>>            Case (iDataFlexType = DF_DATETIME)
92018>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
92021>>>>>>>                Case Break
92022>>>>>>>            Case (iDataFlexType = DF_TEXT)
92025>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
92028>>>>>>>                Case Break
92029>>>>>>>            Case Else
92029>>>>>>>                Move "" to sRetval
92030>>>>>>>        Case End
92030>>>>>>>
92030>>>>>>>        Function_Return sRetval
92031>>>>>>>    End_Function
92032>>>>>>>
92032>>>>>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
92034>>>>>>>        String sDriverID sServer
92034>>>>>>>        tColumnType RetvalType
92034>>>>>>>        tColumnType RetvalType
92034>>>>>>>        Integer iDbType iDriver
92034>>>>>>>        Handle hDatabase
92034>>>>>>>
92034>>>>>>>        Get psDriverID to sDriverID
92035>>>>>>>        Get piDbType   to iDbType
92036>>>>>>>        Get DriverIndex sDriverID to iDriver
92037>>>>>>>        Get psServer to sServer
92038>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
92039>>>>>>>        If (hDatabase = 0) Begin
92041>>>>>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database. (Check that at least one connection is 'Enabled')"
92042>>>>>>>>
92042>>>>>>>            Procedure_Return
92043>>>>>>>        End
92043>>>>>>>>
92043>>>>>>>
92043>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
92046>>>>>>>
92046>>>>>>>    End_Procedure
92047>>>>>>>
92047>>>>>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
92049>>>>>>>        String sDriverID sServer
92049>>>>>>>        tColumnType RetvalType
92049>>>>>>>        tColumnType RetvalType
92049>>>>>>>        Integer iDbType iDriver
92049>>>>>>>        Handle hDatabase
92049>>>>>>>
92049>>>>>>>        Get psDriverID to sDriverID
92050>>>>>>>        Get piDbType   to iDbType
92051>>>>>>>        Get DriverIndex sDriverID to iDriver
92052>>>>>>>        Get psServer to sServer
92053>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
92054>>>>>>>        If (hDatabase = 0) Begin
92056>>>>>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
92057>>>>>>>>
92057>>>>>>>            Procedure_Return
92058>>>>>>>        End
92058>>>>>>>>
92058>>>>>>>
92058>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
92061>>>>>>>
92061>>>>>>>    End_Procedure
92062>>>>>>>
92062>>>>>>>    // Returns a struct array with the default column types for the SQL back-end and how they
92062>>>>>>>    // are mapped to the standard DataFlex data types.
92062>>>>>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
92062>>>>>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
92064>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
92064>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
92066>>>>>>>        String sDataType
92066>>>>>>>        Integer iDataType iDriverID iCount
92066>>>>>>>        Boolean bSQLDriver
92066>>>>>>>
92066>>>>>>>        Move 0 to iCount
92067>>>>>>>        Get DriverIndex sDriverID to iDriverID
92068>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
92069>>>>>>>        If (bSQLDriver = False) Begin
92071>>>>>>>            Function_Return EmptyArray
92072>>>>>>>        End
92072>>>>>>>>
92072>>>>>>>
92072>>>>>>>        // DF_ASCII
92072>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92074>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
92077>>>>>>>        End
92077>>>>>>>>
92077>>>>>>>        Else Begin
92078>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
92081>>>>>>>        End
92081>>>>>>>>
92081>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92082>>>>>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
92083>>>>>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
92084>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92085>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92086>>>>>>>        Increment iCount
92087>>>>>>>
92087>>>>>>>        // DF_BINARY
92087>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92089>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
92092>>>>>>>        End
92092>>>>>>>>
92092>>>>>>>        Else Begin
92093>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
92096>>>>>>>        End
92096>>>>>>>>
92096>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92097>>>>>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
92098>>>>>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
92099>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92100>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92101>>>>>>>        Increment iCount
92102>>>>>>>
92102>>>>>>>        // DF_DATE
92102>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92104>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
92107>>>>>>>        End
92107>>>>>>>>
92107>>>>>>>        Else Begin
92108>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
92111>>>>>>>        End
92111>>>>>>>>
92111>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92112>>>>>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
92113>>>>>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
92114>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92115>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92116>>>>>>>        Increment iCount
92117>>>>>>>
92117>>>>>>>        // DF_DATETIME
92117>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92119>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
92122>>>>>>>        End
92122>>>>>>>>
92122>>>>>>>        Else Begin
92123>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
92126>>>>>>>        End
92126>>>>>>>>
92126>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92127>>>>>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
92128>>>>>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
92129>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92130>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92131>>>>>>>        Increment iCount
92132>>>>>>>
92132>>>>>>>        // DF_NUMERIC
92132>>>>>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
92132>>>>>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
92132>>>>>>>        // we make them here all "Numeric"...
92132>>>>>>>        Case Begin
92132>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
92134>>>>>>>                Move SQL_NUMERIC to iDataType
92135>>>>>>>                Move "numeric"   to sDataType
92136>>>>>>>                Case Break
92137>>>>>>>            Case (sDriverID = DB2_DRV_ID)
92140>>>>>>>                Move SQL_NUMERIC to iDataType
92141>>>>>>>                Move "NUMERIC"   to sDataType
92142>>>>>>>                Case Break
92143>>>>>>>            Case Else
92143>>>>>>>                Move DF_BCD      to iDataType
92144>>>>>>>                Move "Numeric"   to sDataType
92145>>>>>>>        Case End
92145>>>>>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
92146>>>>>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
92147>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92148>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92149>>>>>>>        Increment iCount
92150>>>>>>>
92150>>>>>>>        // DF_TEXT
92150>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92152>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
92155>>>>>>>        End
92155>>>>>>>>
92155>>>>>>>        Else Begin
92156>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
92159>>>>>>>        End
92159>>>>>>>>
92159>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
92160>>>>>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
92161>>>>>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
92162>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
92163>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
92164>>>>>>>
92164>>>>>>>        Function_Return ColumnTypeArray
92165>>>>>>>    End_Function
92166>>>>>>>
92166>>>>>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
92168>>>>>>>        tColumnType[] ColumnTypeArray
92168>>>>>>>        tColumnType[] ColumnTypeArray
92169>>>>>>>        tColumnType   ColumnType
92169>>>>>>>        tColumnType   ColumnType
92169>>>>>>>        Integer iCount iSize
92169>>>>>>>
92169>>>>>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
92170>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
92171>>>>>>>        Decrement iSize
92172>>>>>>>
92172>>>>>>>        for iCount from 0 to iSize
92178>>>>>>>>
92178>>>>>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
92180>>>>>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
92181>>>>>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
92182>>>>>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
92183>>>>>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
92184>>>>>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
92185>>>>>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
92186>>>>>>>                Move iSize to iCount
92187>>>>>>>            End
92187>>>>>>>>
92187>>>>>>>        Loop
92188>>>>>>>>
92188>>>>>>>
92188>>>>>>>        Function_Return ColumnType
92189>>>>>>>    End_Function
92190>>>>>>>
92190>>>>>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
92190>>>>>>>    // An Alias file/table is a filelist number that share the same Physical filename
92190>>>>>>>    // but the Logical name is different.
92190>>>>>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
92190>>>>>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
92192>>>>>>>        String sRootName sRootNameCompare sLogicalName sLogicalNameCompare
92192>>>>>>>        Handle hInTable hMasterTable 
92192>>>>>>>        Boolean bIsAlias
92192>>>>>>>        
92192>>>>>>>        Move hTable to hInTable
92193>>>>>>>        Move False to bIsAlias
92194>>>>>>>        Move 0 to hMasterTable
92195>>>>>>>        
92195>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92198>>>>>>>        // Remove any prefix with a driver name.
92198>>>>>>>        Get _TableNameOnly sRootName to sRootName     
92199>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
92202>>>>>>>        Get _TableNameOnly sLogicalName to sLogicalName     
92203>>>>>>>        
92203>>>>>>>        // If the table has the same root and logical name it can't be an alias,
92203>>>>>>>        // so we can safely return a "False".
92203>>>>>>>        If (Uppercase(sRootName) <> Uppercase(sLogicalName)) Begin
92205>>>>>>>            Function_Return True
92206>>>>>>>        End
92206>>>>>>>>
92206>>>>>>>        
92206>>>>>>>        Function_Return False
92207>>>>>>>        
92207>>>>>>>        // Now we need to find a master table with the same root name (sRootName above),
92207>>>>>>>        // as the passed hTable root name.
92207>>>>>>>        // A master table always has the same root and logical name (except for any driver name prefix or .int suffix).
92207>>>>>>>//        Move 0 to hTable
92207>>>>>>>//        Repeat
92207>>>>>>>//            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92207>>>>>>>//            If (hTable > 0 and hTable <> 50) Begin
92207>>>>>>>//                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameCompare
92207>>>>>>>//                Get _TableNameOnly sRootNameCompare to sRootNameCompare
92207>>>>>>>//                // If we found another table with the same root and logical name
92207>>>>>>>//                // we have found a master table.
92207>>>>>>>//                If (Uppercase(sRootName) = Uppercase(sRootNameCompare)) Begin
92207>>>>>>>//                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameCompare
92207>>>>>>>//                    Get _TableNameOnly sLogicalNameCompare to sLogicalNameCompare     
92207>>>>>>>//                    If (Uppercase(sRootNameCompare) = Uppercase(sLogicalNameCompare)) Begin
92207>>>>>>>//                        Move hTable to hMasterTable   
92207>>>>>>>//                        Move 0 to hTable // To end the loop.
92207>>>>>>>//                    End
92207>>>>>>>//                End
92207>>>>>>>//            End
92207>>>>>>>//        Until (hTable = 0)
92207>>>>>>>//        
92207>>>>>>>//        If (hMasterTable <> 0 and hMasterTable <> hInTable) Begin
92207>>>>>>>//            Move True to bIsAlias
92207>>>>>>>//        End
92207>>>>>>>//        
92207>>>>>>>//        Function_Return bIsAlias
92207>>>>>>>    End_Function
92208>>>>>>>
92208>>>>>>>    // To Open a table with any driver.
92208>>>>>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
92208>>>>>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
92208>>>>>>>    //
92208>>>>>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
92208>>>>>>>    // The found flag is still used to indicate if the open was successful or not. The function
92208>>>>>>>    // returns a True if successful (table could be opened).
92208>>>>>>>    //
92208>>>>>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
92208>>>>>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
92208>>>>>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
92208>>>>>>>    // set properly we can open the table.
92208>>>>>>>    //
92208>>>>>>>    // DAW Driver Syntax:
92208>>>>>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
92208>>>>>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
92208>>>>>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
92208>>>>>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
92208>>>>>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
92208>>>>>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
92208>>>>>>>    //
92208>>>>>>>    // DAW Driver Sample:
92208>>>>>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
92208>>>>>>>    //
92208>>>>>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
92210>>>>>>>        String sTableNameOrg
92210>>>>>>>        Boolean bOpen bOK
92210>>>>>>>        tSQLConnection SQLConnection
92210>>>>>>>        tSQLConnection SQLConnection
92210>>>>>>>        
92210>>>>>>>        Move False to bOpen
92211>>>>>>>        Move sTableName to sTableNameOrg
92212>>>>>>>        If (hTable > 0) Begin
92214>>>>>>>            Send Ignore_Error of Error_Object_Id 20529
92215>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
92216>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
92217>>>>>>>            Send Ignore_Error of Error_Object_Id 10
92218>>>>>>>            Open hTable Mode iMode
92220>>>>>>>            Send Trap_Error of Error_Object_Id 20529
92221>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
92222>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
92223>>>>>>>            Send Trap_Error of Error_Object_Id 10
92224>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
92227>>>>>>>            If (bOpen = True) Begin
92229>>>>>>>                Function_Return True
92230>>>>>>>            End
92230>>>>>>>>
92230>>>>>>>        End
92230>>>>>>>>
92230>>>>>>>
92230>>>>>>>        Get UtilTableOpenAsIntFile hTable sTableName iMode to bOK 
92231>>>>>>>        If (hTable > 0) Begin
92233>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
92236>>>>>>>        End
92236>>>>>>>>
92236>>>>>>>
92236>>>>>>>        Function_Return bOpen
92237>>>>>>>    End_Function
92238>>>>>>>
92238>>>>>>>    Function UtilTableOpenAsIntFile Integer hTable String sTableName Integer iMode Returns Boolean
92240>>>>>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
92240>>>>>>>        Boolean bOpen bOK
92240>>>>>>>        tSQLConnection SQLConnection
92240>>>>>>>        tSQLConnection SQLConnection
92240>>>>>>>
92240>>>>>>>        If (hTable < 1) Begin
92242>>>>>>>            Function_Return False
92243>>>>>>>        End
92243>>>>>>>>
92243>>>>>>>
92243>>>>>>>        Move sTableName to sTableNameOrg
92244>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92245>>>>>>>        Move SQLConnection.sDriverID to sDriverID
92246>>>>>>>        Move SQLConnection.sConnectionString to sConnection
92247>>>>>>>        Move SQLConnection.sSchema to sSchema
92248>>>>>>>        If (sSchema = "") Begin
92250>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
92251>>>>>>>        End
92251>>>>>>>>
92251>>>>>>>
92251>>>>>>>        // We need to remove the ".int" part of the table name because
92251>>>>>>>        // the table name after the "#" in the connection syntax below wants the
92251>>>>>>>        // "bare" table name without any extension.
92251>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
92253>>>>>>>            If (Lowercase(sTableName) contains ".int") Begin
92255>>>>>>>                Get ParseFileExtension sTableName to sExt
92256>>>>>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
92257>>>>>>>            End
92257>>>>>>>>
92257>>>>>>>            Else Begin
92258>>>>>>>                Move sTableName to sTableNameShort
92259>>>>>>>                Move (Append(sTableName, ".int")) to sTableName
92260>>>>>>>            End
92260>>>>>>>>
92260>>>>>>>            Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
92261>>>>>>>            Move sConnection to sTableName
92262>>>>>>>        End
92262>>>>>>>>
92262>>>>>>>
92262>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
92263>>>>>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
92264>>>>>>>        If (hTable = 0) Begin
92266>>>>>>>            Get NextFreeFilelistSlot to hTable
92267>>>>>>>        End
92267>>>>>>>>
92267>>>>>>>
92267>>>>>>>        Case Begin
92267>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
92269>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92269>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
92271>>>>>>>                    Close hTable
92272>>>>>>>                    Open sTableName as hTable
92274>>>>>>>                End
92274>>>>>>>>
92274>>>>>>>                Else Begin
92275>>>>>>>                    Get OpenTableExclusive hTable to bOK
92276>>>>>>>                    If (bOK = False) Begin
92278>>>>>>>                        Function_Return False
92279>>>>>>>                    End
92279>>>>>>>>
92279>>>>>>>                End
92279>>>>>>>>
92279>>>>>>>                Case Break
92280>>>>>>>
92280>>>>>>>            Case (sDriverID = DB2_DRV_ID)
92283>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92283>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
92285>>>>>>>                    Close hTable
92286>>>>>>>                    Open sTableName as hTable
92288>>>>>>>                End
92288>>>>>>>>
92288>>>>>>>                Else Begin
92289>>>>>>>                    Get OpenTableExclusive hTable to bOK
92290>>>>>>>                    If (bOK = False) Begin
92292>>>>>>>                        Function_Return False
92293>>>>>>>                    End
92293>>>>>>>>
92293>>>>>>>                End
92293>>>>>>>>
92293>>>>>>>                Case Break
92294>>>>>>>
92294>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
92297>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92297>>>>>>>                If (iMode = DF_SHARE) Begin
92299>>>>>>>                    Close hTable
92300>>>>>>>                    Open sTableName as hTable
92302>>>>>>>                End
92302>>>>>>>>
92302>>>>>>>                Else Begin
92303>>>>>>>                    Get OpenTableExclusive hTable to bOK
92304>>>>>>>                    If (bOK = False) Begin
92306>>>>>>>                        Function_Return False
92307>>>>>>>                    End
92307>>>>>>>>
92307>>>>>>>                End
92307>>>>>>>>
92307>>>>>>>                Case Break
92308>>>>>>>
92308>>>>>>>            Case (sDriverID = DATAFLEX_ID)
92311>>>>>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
92313>>>>>>>                    Close hTable
92314>>>>>>>                    Open sTableName as hTable
92316>>>>>>>                End
92316>>>>>>>>
92316>>>>>>>                Else If (iMode = DF_EXCLUSIVE) Begin
92319>>>>>>>                    Get OpenTableExclusive hTable to bOK
92320>>>>>>>                    If (bOK = False) Begin
92322>>>>>>>                        Function_Return False
92323>>>>>>>                    End
92323>>>>>>>>
92323>>>>>>>                End
92323>>>>>>>>
92323>>>>>>>                Else Begin
92324>>>>>>>                    Open hTable
92326>>>>>>>                End
92326>>>>>>>>
92326>>>>>>>                Case Break
92327>>>>>>>
92327>>>>>>>            Case Else
92327>>>>>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
92328>>>>>>>>
92328>>>>>>>        Case End
92328>>>>>>>
92328>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
92329>>>>>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
92330>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
92332>>>>>>>            Move False to Found
92333>>>>>>>        End
92333>>>>>>>>
92333>>>>>>>        // If open failed, the Err is set to true,
92333>>>>>>>        // but we don't want that because it could end our loop.
92333>>>>>>>        Move False to Err
92334>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
92337>>>>>>>
92337>>>>>>>        Function_Return bOpen
92338>>>>>>>    End_Function
92339>>>>>>>
92339>>>>>>>    // Pass a table's logical name
92339>>>>>>>    // Returns True if the table exists in filelist.cfg.
92339>>>>>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
92341>>>>>>>        Handle hTable
92341>>>>>>>        Boolean bFound
92341>>>>>>>        String sCompareTable
92341>>>>>>>
92341>>>>>>>        Move False to bFound
92342>>>>>>>        Move 0 to hTable
92343>>>>>>>        Repeat
92343>>>>>>>>
92343>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92346>>>>>>>            If (hTable > 0) Begin
92348>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
92351>>>>>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
92353>>>>>>>                    Move True to bFound
92354>>>>>>>                End
92354>>>>>>>>
92354>>>>>>>            End
92354>>>>>>>>
92354>>>>>>>            If (bFound = True) ;                Break
92357>>>>>>>        Until (hTable = 0)
92359>>>>>>>
92359>>>>>>>        Function_Return (bFound = True)
92360>>>>>>>    End_Function
92361>>>>>>>
92361>>>>>>>    // Function will report the default driver "DATAFLEX" if table can't be opened
92361>>>>>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
92363>>>>>>>        Boolean bOK bExists
92363>>>>>>>        String sDriverID
92363>>>>>>>
92363>>>>>>>        Get _UtilTableExists hTable to bExists
92364>>>>>>>        If (bExists = False) Begin
92366>>>>>>>            Function_Return DATAFLEX_ID
92367>>>>>>>        End
92367>>>>>>>>
92367>>>>>>>        Get OpenTableExclusive hTable to bOK
92368>>>>>>>        If (bOK = False) Begin
92370>>>>>>>            Function_Return DATAFLEX_ID
92371>>>>>>>        End
92371>>>>>>>>
92371>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
92374>>>>>>>        Function_Return sDriverID
92375>>>>>>>    End_Function
92376>>>>>>>
92376>>>>>>>    // Number of tables in Filelist.cfg. Returns integger
92376>>>>>>>    Function UtilFilelistNoOfTables Returns Integer
92378>>>>>>>        Handle hTable
92378>>>>>>>        Integer iRetval
92378>>>>>>>
92378>>>>>>>        Move 0 to hTable
92379>>>>>>>        Move 0 to iRetval
92380>>>>>>>
92380>>>>>>>        Repeat
92380>>>>>>>>
92380>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92383>>>>>>>            If (hTable > 0) Begin
92385>>>>>>>                Increment iRetval
92386>>>>>>>            End
92386>>>>>>>>
92386>>>>>>>        Until (hTable = 0)
92388>>>>>>>
92388>>>>>>>        Function_Return iRetval
92389>>>>>>>    End_Function
92390>>>>>>>
92390>>>>>>>    // Checks if any of the tables in Filelist.cfg is an SQL driver and returns the first Driver ID.
92390>>>>>>>    Function UtilIsAnyFilelistEntrySQLtable Returns String
92392>>>>>>>        Handle hTable
92392>>>>>>>        String sRoot sDriverID
92392>>>>>>>        Boolean bIsSQLTable
92392>>>>>>>        Integer iPos
92392>>>>>>>
92392>>>>>>>        Move 0 to hTable
92393>>>>>>>        Move "" to sDriverID
92394>>>>>>>        Move False to bIsSQLTable
92395>>>>>>>
92395>>>>>>>        Repeat
92395>>>>>>>>
92395>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92398>>>>>>>            If (hTable > 0) Begin
92400>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
92403>>>>>>>                If (sRoot contains ":") Begin
92405>>>>>>>                    Move (Pos(":", sRoot)) to iPos
92406>>>>>>>                    Move (Left(sRoot, (iPos -1))) to sDriverID
92407>>>>>>>                End
92407>>>>>>>>
92407>>>>>>>                Get IsSQLDriver sDriverID to bIsSQLTable
92408>>>>>>>            End
92408>>>>>>>>
92408>>>>>>>
92408>>>>>>>        Until (hTable = 0 or bIsSQLTable = True)
92410>>>>>>>
92410>>>>>>>        Function_Return sDriverID
92411>>>>>>>    End_Function
92412>>>>>>>
92412>>>>>>>    Function UtilIsAllFilelistEntriesDataFlexTables Returns Boolean
92414>>>>>>>        String sRootName
92414>>>>>>>        Boolean bIsSQL
92414>>>>>>>        Handle hTable
92414>>>>>>>
92414>>>>>>>        Move False to bIsSQL
92415>>>>>>>        Move 0 to hTable
92416>>>>>>>        Repeat
92416>>>>>>>>
92416>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92419>>>>>>>            If (hTable > 0) Begin
92421>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92424>>>>>>>                Get _UtilTableIsSqlByRootName sRootName to bIsSQL
92425>>>>>>>                If (bIsSQL = True) Begin
92427>>>>>>>                    Move 0 to hTable
92428>>>>>>>                End
92428>>>>>>>>
92428>>>>>>>            End
92428>>>>>>>>
92428>>>>>>>        Until (hTable = 0)
92430>>>>>>>
92430>>>>>>>        Function_Return (bIsSQL = False)
92431>>>>>>>    End_Function
92432>>>>>>>
92432>>>>>>>    // * Dummy function for the Studio's Code Explorer *
92432>>>>>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
92434>>>>>>>        Function_Return False
92435>>>>>>>    End_Function
92436>>>>>>>
92436>>>>>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
92438>>>>>>>        String  sRetval
92438>>>>>>>        String[] sOverlapFieldsArray
92439>>>>>>>        Integer iType iColumn iColumns
92439>>>>>>>        Boolean bOpen bOverlap
92439>>>>>>>
92439>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
92442>>>>>>>        If (bOpen = False) Begin
92444>>>>>>>            Open hTable
92446>>>>>>>        End
92446>>>>>>>>
92446>>>>>>>
92446>>>>>>>        Move "" to sRetval
92447>>>>>>>
92447>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
92450>>>>>>>
92450>>>>>>>        for iColumn from 0 to iColumns
92456>>>>>>>>
92456>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
92459>>>>>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
92461>>>>>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
92464>>>>>>>                If (bOverlap) Begin
92466>>>>>>>                    If (sRetval <> "") Begin
92468>>>>>>>                        Append sRetval ","
92469>>>>>>>                    End
92469>>>>>>>>
92469>>>>>>>                    Append sRetval iColumn
92470>>>>>>>                End
92470>>>>>>>>
92470>>>>>>>            End
92470>>>>>>>>
92470>>>>>>>        Loop
92471>>>>>>>>
92471>>>>>>>
92471>>>>>>>        If (bOpen = False) Begin
92473>>>>>>>            Close hTable
92474>>>>>>>        End
92474>>>>>>>>
92474>>>>>>>
92474>>>>>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
92475>>>>>>>
92475>>>>>>>        Function_Return sOverlapFieldsArray
92476>>>>>>>    End_Function
92477>>>>>>>
92477>>>>>>>    Function UtilEnumerateODBCDrivers Returns String
92479>>>>>>>        Handle hoRegistry hoODBCDriverNames
92479>>>>>>>        Boolean bExists bKeyOpened
92479>>>>>>>        String sKey
92479>>>>>>>        String[] sDrivers
92480>>>>>>>        Integer iDriverNames iDriverName
92480>>>>>>>
92480>>>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
92481>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
92482>>>>>>>        Set pfAccessRights of hoRegistry to Key_Read
92483>>>>>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
92484>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
92485>>>>>>>        If (bExists) Begin
92487>>>>>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
92488>>>>>>>            If (bKeyOpened) Begin
92490>>>>>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
92491>>>>>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
92492>>>>>>>                If (iDriverNames > 0) Begin
92494>>>>>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
92495>>>>>>>                    Decrement iDriverNames
92496>>>>>>>                    for iDriverName from 0 to iDriverNames
92502>>>>>>>>
92502>>>>>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
92503>>>>>>>                    Loop
92504>>>>>>>>
92504>>>>>>>                End
92504>>>>>>>>
92504>>>>>>>                Send CloseKey of hoRegistry
92505>>>>>>>            End
92505>>>>>>>>
92505>>>>>>>        End
92505>>>>>>>>
92505>>>>>>>        Send Destroy of hoRegistry
92506>>>>>>>
92506>>>>>>>        Function_Return sDrivers
92507>>>>>>>    End_Function
92508>>>>>>>
92508>>>>>>>    Procedure IncreaseSortBufferSize
92510>>>>>>>        String sNull
92510>>>>>>>        Integer iSortBufferSize
92510>>>>>>>        Boolean bBufferSet
92510>>>>>>>
92510>>>>>>>        Move "" to sNull
92511>>>>>>>        Move (1024 * 128) to iSortBufferSize
92512>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
92517>>>>>>>
92517>>>>>>>    End_Procedure
92518>>>>>>>
92518>>>>>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
92520>>>>>>>        Integer iLastIndex iIndex iNumSegments
92520>>>>>>>        Boolean bOK
92520>>>>>>>        String sDriverID
92520>>>>>>>
92520>>>>>>>        If (hTable > 0) Begin
92522>>>>>>>            Get UtilDriverFromTableNumber hTable to sDriverID
92523>>>>>>>            Close hTable
92524>>>>>>>            Get OpenTableExclusive hTable to bOK
92525>>>>>>>            If (bOK = False) Begin
92527>>>>>>>                Procedure_Return
92528>>>>>>>            End
92528>>>>>>>>
92528>>>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
92531>>>>>>>            Structure_Start hTable sDriverID
92532>>>>>>>                for iIndex from 1 to iLastIndex
92538>>>>>>>>
92538>>>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
92541>>>>>>>                    If (iNumSegments > 0) Begin
92543>>>>>>>                        If (bSetToBatch = True) Begin
92545>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
92548>>>>>>>                        End
92548>>>>>>>>
92548>>>>>>>                        Else Begin
92549>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
92552>>>>>>>                        End
92552>>>>>>>>
92552>>>>>>>                    End
92552>>>>>>>>
92552>>>>>>>                Loop
92553>>>>>>>>
92553>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92555>>>>>>>        End
92555>>>>>>>>
92555>>>>>>>    End_Procedure
92556>>>>>>>
92556>>>>>>>    Function NextFreeFilelistSlot Returns Handle
92558>>>>>>>        Handle hTable
92558>>>>>>>
92558>>>>>>>        Move 0 to hTable
92559>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
92562>>>>>>>
92562>>>>>>>        Function_Return hTable
92563>>>>>>>    End_Function
92564>>>>>>>
92564>>>>>>>    // For debugging purposes. To print Sql statements as they are build...
92564>>>>>>>    Procedure DebugPrint String sStmt String sFileName
92566>>>>>>>        Integer iCh
92566>>>>>>>        Get Seq_Append_Output_Channel sFileName to iCh
92567>>>>>>>            Write channel iCh sStmt
92569>>>>>>>        Send Seq_Close_Channel iCh
92570>>>>>>>    End_Procedure
92571>>>>>>>
92571>>>>>>>    // Returns the integer number for the passed Driver ID that is
92571>>>>>>>    // needed by some database API calls.
92571>>>>>>>    Function DriverIndex String sDriverID Returns Integer
92573>>>>>>>        String  sCurrentDriver
92573>>>>>>>        Integer iNumberOfDrivers iDriver iCount
92573>>>>>>>
92573>>>>>>>        Move 0 to iDriver
92574>>>>>>>
92574>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
92577>>>>>>>        for iCount from 1 to iNumberOfDrivers
92583>>>>>>>>
92583>>>>>>>
92583>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
92586>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
92588>>>>>>>                Move iCount to iDriver
92589>>>>>>>            End
92589>>>>>>>>
92589>>>>>>>        Loop
92590>>>>>>>>
92590>>>>>>>
92590>>>>>>>        // In case it was not found, it wasn't loaded so we do that now.
92590>>>>>>>        If (iDriver = 0) Begin
92592>>>>>>>            Move False to Err
92593>>>>>>>            Load_Driver sDriverID
92594>>>>>>>            If (Err = False) Begin
92596>>>>>>>                Get_Attribute DF_NUMBER_DRIVERS to iDriver
92599>>>>>>>            End
92599>>>>>>>>
92599>>>>>>>        End
92599>>>>>>>>
92599>>>>>>>
92599>>>>>>>        Function_Return iDriver
92600>>>>>>>    End_Function
92601>>>>>>>
92601>>>>>>>
92601>>>>>>>    Function SqlServerClientVersionName for cMSSQLHandler Integer iClientVersion  Returns String
92603>>>>>>>        String  sSqlServerClientVersionName
92603>>>>>>>        
92603>>>>>>>        Case Begin
92603>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
92605>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientVersionName
92606>>>>>>>                Case Break
92607>>>>>>>
92607>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
92610>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
92611>>>>>>>                Case Break
92612>>>>>>>                
92612>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
92615>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
92616>>>>>>>                Case Break
92617>>>>>>>            
92617>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
92620>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
92621>>>>>>>                Case Break
92622>>>>>>>            
92622>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
92625>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
92626>>>>>>>                Case Break
92627>>>>>>>            
92627>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
92630>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
92631>>>>>>>                Case Break
92632>>>>>>>            
92632>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
92635>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
92636>>>>>>>                Case Break
92637>>>>>>>            
92637>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
92640>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
92641>>>>>>>                Case Break
92642>>>>>>>            
92642>>>>>>>            Case Else
92642>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
92643>>>>>>>        Case End
92643>>>>>>>        
92643>>>>>>>        Function_Return sSqlServerClientVersionName
92644>>>>>>>    End_Function
92645>>>>>>>
92645>>>>>>>    Function SqlServerClientDriverName for cMSSQLHandler Integer iClientVersion  Returns String
92647>>>>>>>        String  sSqlServerClientDriverName
92647>>>>>>>        
92647>>>>>>>        Case Begin
92647>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
92649>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientDriverName
92650>>>>>>>                Case Break
92651>>>>>>>
92651>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
92654>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
92655>>>>>>>                Case Break
92656>>>>>>>                
92656>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
92659>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
92660>>>>>>>                Case Break
92661>>>>>>>            
92661>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
92664>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
92665>>>>>>>                Case Break
92666>>>>>>>            
92666>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
92669>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
92670>>>>>>>                Case Break
92671>>>>>>>            
92671>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
92674>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
92675>>>>>>>                Case Break
92676>>>>>>>            
92676>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
92679>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
92680>>>>>>>                Case Break
92681>>>>>>>            
92681>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
92684>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
92685>>>>>>>                Case Break
92686>>>>>>>            
92686>>>>>>>            Case Else
92686>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
92687>>>>>>>        Case End
92687>>>>>>>        
92687>>>>>>>        Function_Return sSqlServerClientDriverName
92688>>>>>>>    End_Function
92689>>>>>>>    
92689>>>>>>>    Function MinMSSQLDRV_And_ClientVersion String sMSSQLDRVVersion Integer iClientVersion Boolean bShowErrorDialog Boolean bExitProgram Returns String
92691>>>>>>>        String sDriverID sVersion sClient sClientLowest sRetval
92691>>>>>>>        Integer iNumberOfDrivers iDriver iClient
92691>>>>>>>        Handle hoCLIHandler hoMSSQLHandler   
92691>>>>>>>        Boolean bOK
92691>>>>>>>        
92691>>>>>>>        Move "" to sRetval
92692>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLIHandler
92693>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMSSQLHandler
92694>>>>>>>        Load_Driver MSSQLDRV_ID
92695>>>>>>>
92695>>>>>>>        // Loop through all loaded drivers.
92695>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
92698>>>>>>>        For iDriver from 1 to iNumberOfDrivers
92704>>>>>>>>
92704>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
92707>>>>>>>            If (sDriverID = MSSQLDRV_ID) Begin
92709>>>>>>>                Set psDriverID of hoCLIHandler to sDriverID
92710>>>>>>>                Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient   
92713>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClientVersion to sClientLowest 
92714>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClient to sClient 
92715>>>>>>>                Get CKRevision of hoCLIHandler to sVersion
92716>>>>>>>                Move (SFormat (String(C_$DatabaseDriver), (sDriverID * "-" * (String(C_$Version) + ": " + String(sVersion))))) to sRetval
92717>>>>>>>                If (sClient <> "" and sRetval <> "") Begin
92719>>>>>>>                    Move (String(sRetval) + "\n" + String(C_$SQL_Client_Text) + "\n" + Trim(sClient)) to sRetval
92720>>>>>>>                End                                
92720>>>>>>>>
92720>>>>>>>                Else Begin
92721>>>>>>>                    Move (String(C_$SQL_Client_Text) + "\n" + Trim(sClient) * "(" + String(iClient) + ")") to sRetval
92722>>>>>>>                End
92722>>>>>>>>
92722>>>>>>>            End
92722>>>>>>>>
92722>>>>>>>        Loop
92723>>>>>>>>
92723>>>>>>>        Send Destroy of hoCLIHandler  
92724>>>>>>>        Send Destroy of hoMSSQLHandler  
92725>>>>>>>        If (bShowErrorDialog = True) Begin
92727>>>>>>>            Get IsFirstStringGreaterThanSecond sVersion sMSSQLDRVVersion to bOK
92728>>>>>>>            If (bOK = False or (iClient < iClientVersion)) Begin
92730>>>>>>>                Move (MSSQLDRV_ID + ".dll" * String(C_$SQL_Driver_Version_Min_Text) *  String(sMSSQLDRVVersion) + String("\n") + String(C_$SQL_Client_Version_Min_Text) + "\n" + String(sClientLowest) + String("\n\n") + String(C_$SQL_Versions_Are_Text) + String("\n") + String(sRetval)) to sRetval
92731>>>>>>>                If (bExitProgram = True) Begin
92733>>>>>>>                    Move (String(sRetval) + String("\n\n") + String(C_$PleaseAdjustTxt) * String(C_$ProgramWillExit_Text)) to sRetval
92734>>>>>>>                End
92734>>>>>>>>
92734>>>>>>>                Send Stop_Box sRetval  
92735>>>>>>>                If (bExitProgram = True) Begin
92737>>>>>>>                    Send Exit_Application
92738>>>>>>>                End
92738>>>>>>>>
92738>>>>>>>            End
92738>>>>>>>>
92738>>>>>>>        End
92738>>>>>>>>
92738>>>>>>>        
92738>>>>>>>        Function_Return sRetval
92739>>>>>>>    End_Function  
92740>>>>>>>    
92740>>>>>>>    // Returns True if first "." separated string is greater than the second.
92740>>>>>>>    // It checks from left to right, one part of the string at a time.
92740>>>>>>>    // E.g. if sVersion="20.1.31.10 and sSQLVersion="6.3.0.13" the function would return TRUE.
92740>>>>>>>    Function IsFirstStringGreaterThanSecond Global String sVersion String sSQLVersion Returns Boolean
92742>>>>>>>        String[] asVersion asSQLVersion          
92744>>>>>>>        Integer iSize iCount iVersion iSQLVersion
92744>>>>>>>        
92744>>>>>>>        Move (StrSplitToArray(sVersion, "."))    to asVersion
92745>>>>>>>        Move (StrSplitToArray(sSQLVersion, ".")) to asSQLVersion
92746>>>>>>>        Move (SizeOfArray(asVersion)) to iSize
92747>>>>>>>        // Make sure the two arrays are of the same size:
92747>>>>>>>        If (SizeOfArray(asSQLVersion) < iSize) Begin
92749>>>>>>>            Move (ResizeArray(asSQLVersion, iSize, 0)) to asSQLVersion
92750>>>>>>>        End
92750>>>>>>>>
92750>>>>>>>        Decrement iSize
92751>>>>>>>        for iCount from 0 to iSize
92757>>>>>>>>
92757>>>>>>>            Move asVersion[iCount]    to iVersion
92758>>>>>>>            Move asSQLVersion[iCount] to iSQLVersion
92759>>>>>>>            CompilerWarnings Off
92759>>>>>>>            If (iVersion > iSQLVersion) Break
92762>>>>>>>            CompilerWarnings On
92762>>>>>>>        Loop
92763>>>>>>>>
92763>>>>>>>        
92763>>>>>>>        Function_Return (iVersion >= iSQLVersion)
92764>>>>>>>    End_Function
92765>>>>>>>
92765>>>>>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
92765>>>>>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
92765>>>>>>>    //       so in that case we "cheat" and report those tables were opened OK.
92765>>>>>>>    Function OpenTableExclusive Handle hTable Returns Boolean
92767>>>>>>>        Integer iMode iErrorObject
92767>>>>>>>        Boolean bOpened bExitIfDebuggerActive
92767>>>>>>>        String sTableName 
92767>>>>>>>        Handle hoCurrentErrorHandler
92767>>>>>>>        
92767>>>>>>>        Move False to bExitIfDebuggerActive
92768>>>>>>>        If (ghoDbUpdateHandler <> 0) Begin
92770>>>>>>>            Get pbExitIfDebuggerActive of ghoDbUpdateHandler to bExitIfDebuggerActive
92771>>>>>>>        End
92771>>>>>>>>
92771>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92772>>>>>>>        // Can't open a table properly if run through the Debugger/Studio,
92772>>>>>>>        // so we generate an error here:
92772>>>>>>>        If (IsDebuggerPresent() and bExitIfDebuggerActive = True) Begin
92774>>>>>>>            Move Error_Object_Id to hoCurrentErrorHandler
92775>>>>>>>            Get piOrgErrorHandlerID to iErrorObject
92776>>>>>>>            If (iErrorObject <> 0) Begin
92778>>>>>>>                Move iErrorObject to Error_Object_Id
92779>>>>>>>            End
92779>>>>>>>>
92779>>>>>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio! You need to run this program from outside of the Studio."
92780>>>>>>>>
92780>>>>>>>            Move hoCurrentErrorHandler to Error_Object_Id
92781>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
92782>>>>>>>            Function_Return False
92783>>>>>>>        End
92783>>>>>>>>
92783>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92786>>>>>>>        If (bOpened) Begin
92788>>>>>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
92791>>>>>>>            If (iMode = DF_EXCLUSIVE) Begin
92793>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92794>>>>>>>                Function_Return True
92795>>>>>>>            End
92795>>>>>>>>
92795>>>>>>>            Close hTable
92796>>>>>>>        End
92796>>>>>>>>
92796>>>>>>>        Else Begin
92797>>>>>>>            Open hTable
92799>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
92802>>>>>>>            If (bOpened and IsDebuggerPresent()) Begin
92804>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
92807>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
92809>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
92810>>>>>>>                    Function_Return True
92811>>>>>>>                End
92811>>>>>>>>
92811>>>>>>>            End
92811>>>>>>>>
92811>>>>>>>
92811>>>>>>>        End
92811>>>>>>>>
92811>>>>>>>
92811>>>>>>>        Close hTable
92812>>>>>>>        Open hTable Mode DF_EXCLUSIVE
92814>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92817>>>>>>>
92817>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92818>>>>>>>        Function_Return bOpened
92819>>>>>>>    End_Function
92820>>>>>>>
92820>>>>>>>    Function AutoConnectionIDLogin Returns Boolean
92822>>>>>>>        String sConnectionID sConnectionString sDriverID
92822>>>>>>>        Boolean bExists bOK bSQLDriver
92822>>>>>>>        Handle hoCLI hoDriver
92822>>>>>>>        Integer iRetval
92822>>>>>>>        tSQLConnection SQLConnection
92822>>>>>>>        tSQLConnection SQLConnection
92822>>>>>>>
92822>>>>>>>        Get psDriverID to sDriverID
92823>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
92824>>>>>>>        If (bSQLDriver = False) Begin
92826>>>>>>>            Function_Return True
92827>>>>>>>        End
92827>>>>>>>>
92827>>>>>>>
92827>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92828>>>>>>>        Move SQLConnection.sDriverID                  to sDriverID
92829>>>>>>>        Move SQLConnection.sConnectionString          to sConnectionString
92830>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
92831>>>>>>>
92831>>>>>>>        Get IsConnectionID sConnectionID sDriverID to bExists
92832>>>>>>>        If (bExists = False) Begin
92834>>>>>>>            // We always start by deleting the current connection - if any - because the
92834>>>>>>>            // login details my have changed.
92834>>>>>>>            Get phoCLIHandler to hoCLI
92835>>>>>>>            Set psDriverID    of hoCLI to sDriverID
92836>>>>>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
92837>>>>>>>            Get AutoSetConnectionID sConnectionID to bOk
92838>>>>>>>            If (bOk = False) Begin
92840>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
92841>>>>>>>>
92841>>>>>>>                Function_Return False
92842>>>>>>>            End
92842>>>>>>>>
92842>>>>>>>            Move bOK to bExists
92843>>>>>>>        End
92843>>>>>>>>
92843>>>>>>>
92843>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
92844>>>>>>>        Set Name of hoDriver to "oDbUpdateDatabaseDriver"
92845>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
92846>>>>>>>        Get DbLogin of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
92847>>>>>>>        Send Destroy of hoDriver
92848>>>>>>>
92848>>>>>>>        Function_Return (bExists = True)
92849>>>>>>>    End_Function
92850>>>>>>>
92850>>>>>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
92850>>>>>>>    // Returns: False if nobody else is running
92850>>>>>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
92850>>>>>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
92850>>>>>>>    //      tables are not locked as DataFlex tables are.
92850>>>>>>>    Function IsDatabaseInUse Returns Boolean
92852>>>>>>>        Handle  hTable
92852>>>>>>>        String  sRootName sDatabase sSchema sDriverID
92852>>>>>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs bExists
92852>>>>>>>        Integer iCount iTables
92852>>>>>>>        String[] asTablesArray asTablesArrayEmpty
92854>>>>>>>        
92854>>>>>>>        Move 0 to iTables
92855>>>>>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
92856>>>>>>>        Get AutoConnectionIDLogin to bOK
92857>>>>>>>        Get UtilFilelistNoOfTables to iTables
92858>>>>>>>        Set piPosition   of ghoProgressBar to 0
92859>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 1
92860>>>>>>>        Set piMaximum    of ghoProgressBar to iTables
92861>>>>>>>        Close DF_ALL
92862>>>>>>>        Move 0 to hTable
92863>>>>>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92866>>>>>>>        Move False to bErr
92867>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92868>>>>>>>
92868>>>>>>>        Get psDriverID to sDriverID
92869>>>>>>>        Get psDatabase to sDatabase
92870>>>>>>>        Get psSchema   to sSchema
92871>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to asTablesArray
92872>>>>>>>        Set pasSQLDataTables to asTablesArray
92873>>>>>>>        Repeat
92873>>>>>>>>
92873>>>>>>>            Set piPosition of ghoProgressBar to iCount
92874>>>>>>>            Increment iCount
92875>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92878>>>>>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
92879>>>>>>>
92879>>>>>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
92879>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQLTable
92880>>>>>>>            Move False to bOpen
92881>>>>>>>            // _UtilTableExists_Ex is a variant of "_UtilTableExists", but it needs that the pasSQLDataTables
92881>>>>>>>            // property has been set/updated before usage! This makes the loop much faster.
92881>>>>>>>            Get _UtilTableExists_Ex hTable to bExists
92882>>>>>>>            // Don't bother about CodeType (253, CodeMast (254) or) FlexErrs (Normally table 50)
92882>>>>>>>            If (bIsSQLTable = False and bExists = True and hTable <> 0 and hTable <> 253 and hTable <> 254 and bFlexErrs = False) Begin
92884>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92885>>>>>>>                Open hTable
92887>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
92890>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92891>>>>>>>                If (bOpen = True) Begin
92893>>>>>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
92893>>>>>>>                    Get UtilTableIsAlias hTable to bAlias
92894>>>>>>>                    If (bAlias = False) Begin
92896>>>>>>>                        Close hTable
92897>>>>>>>                        Get OpenTableExclusive hTable to bOpen
92898>>>>>>>                        If (bOpen = False) Begin
92900>>>>>>>                            Move True to bErr
92901>>>>>>>                        End
92901>>>>>>>>
92901>>>>>>>                    End
92901>>>>>>>>
92901>>>>>>>                End
92901>>>>>>>>
92901>>>>>>>            End
92901>>>>>>>>
92901>>>>>>>            Close hTable
92902>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92905>>>>>>>            If (bErr = True ) ;                Break
92908>>>>>>>        Until (not(hTable))
92910>>>>>>>
92910>>>>>>>        // Reset the temporary used data tables property to blank:
92910>>>>>>>        Set pasSQLDataTables to asTablesArrayEmpty
92911>>>>>>>        Set Action_Text of ghoStatusPanel to ""
92912>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92913>>>>>>>        Move False to Err
92914>>>>>>>
92914>>>>>>>        Function_Return bErr
92915>>>>>>>    End_Function
92916>>>>>>>
92916>>>>>>>End_Class
92917>>>>>Use for_all.pkg // Handy to have available in the OnUpdate event.
Including file: for_all.pkg    (C:\Program Files\DataFlex 24.0\Pkg\for_all.pkg)
92917>>>>>>>// This module contains the command definitions for the FOR_ALL construct.
92917>>>>>>>//
92917>>>>>>>// FOR_ALL is used to select and process a set of records in a database file;
92917>>>>>>>// FOR_ALL constructs may be nested. FOR_ALL is intended to work in
92917>>>>>>>// conjunction with constraint-clauses.
92917>>>>>>>//
92917>>>>>>>// SYNTAX:
92917>>>>>>>//
92917>>>>>>>//  For_All <File> BY|DOWN <Index> {AS QUE|QUEUE} {DO}
92917>>>>>>>//    <Constraints...>
92917>>>>>>>//    {DO}
92917>>>>>>>//      <loop body>
92917>>>>>>>//  End_For_All
92917>>>>>>>//
92917>>>>>>>// This set of macros implements a constraint-oriented file enumeration
92917>>>>>>>// syntax.  For example, to list all Customers by name in reverse order:
92917>>>>>>>//
92917>>>>>>>//   For_All Customer DOWN Customer.Customer_Name DO
92917>>>>>>>//     showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92917>>>>>>>//   End_For_All
92917>>>>>>>//
92917>>>>>>>// To list only Customers with a Balance greater than their credit limit:
92917>>>>>>>//
92917>>>>>>>//   For_All Customer BY Index.1
92917>>>>>>>//     CONSTRAIN Customer.Balance GT Customer.Credit_Limit
92917>>>>>>>//     DO
92917>>>>>>>//       showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92917>>>>>>>//   End_For_All
92917>>>>>>>//
92917>>>>>>>// Constraint clauses are:
92917>>>>>>>//
92917>>>>>>>//   CONSTRAIN <File> RELATES TO <File> ...
92917>>>>>>>//   CONSTRAIN <File> AS <Expression>
92917>>>>>>>//   CONSTRAIN <File.Field> AS <Expression>
92917>>>>>>>//   CONSTRAIN <File.Field> BETWEEN <lowBound> AND <highBound>
92917>>>>>>>//
92917>>>>>>>// For example, to list all customers with a bad status whose names start
92917>>>>>>>// with "A" and which have not made a payment in thirty days:
92917>>>>>>>//
92917>>>>>>>//    For_All Customer BY Index.2       //Index.2 = <Status>+<Name>
92917>>>>>>>//      CONSTRAIN Customer.Status EQ BAD
92917>>>>>>>//      CONSTRAIN Customer.Customer_Name GE "A"
92917>>>>>>>//      CONSTRAIN Customer.Customer_Name LT "B"
92917>>>>>>>//      CONSTRAIN Customer.Last_Pymt_Date LE (Today - 30)
92917>>>>>>>//      DO
92917>>>>>>>//        showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92917>>>>>>>//    End_For_All
92917>>>>>>>//
92917>>>>>>>
92917>>>>>>>
92917>>>>>>>//This command starts the loop process body when constraints are used;
92917>>>>>>>//If no constraints are required, DO should be specified on the FOR_ALL
92917>>>>>>>//command line, and not on a line by itself
92917>>>>>>>//
92917>>>>>>>
92917>>>>>>>//Ends a For_All loop
92917>>>>>>>//
92917>>>>>>>
92917>>>>>>>
92917>>>>>
92917>>>>>
92917>>>>>Class cDbUpdateVersion is a cObject
92918>>>>>
92918>>>>>    Procedure Construct_Object    
92920>>>>>        Boolean bOnCreateExecuted bUseCustomDbVersion bUseIntFilesBackup
92920>>>>>        String[] aSQLQueryMessages
92921>>>>>        
92921>>>>>        Forward Send Construct_Object
92923>>>>>
92923>>>>>        // cDbUpdateHandler object event.
92923>>>>>        Delegate Get Private.pbOnCreateExecuted to bOnCreateExecuted
92925>>>>>        If (bOnCreateExecuted = False) Begin    
92927>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
92929>>>>>            If (bUseCustomDbVersion = False) Begin
92931>>>>>                Delegate Send AutoCreateDbVersionTable 
92933>>>>>            End
92933>>>>>>
92933>>>>>            Get pbUseIntFilesBackup to bUseIntFilesBackup
92934>>>>>            If (bUseIntFilesBackup = True) Begin
92936>>>>>                Delegate Send AutoCreateIntFilesTable
92938>>>>>            End    
92938>>>>>>
92938>>>>>            Delegate Send OnCreate
92940>>>>>            Delegate Set Private.pbOnCreateExecuted to True
92942>>>>>        End
92942>>>>>>
92942>>>>>
92942>>>>>        // Don't touch! It is used by class logic to indicate if the OnUpdate
92942>>>>>        // event was triggered, thus an actual change of the database was made.
92942>>>>>        Property Boolean pbVersionUpdate False
92943>>>>>
92943>>>>>        // This property must be manually set within each cDbUpdateVersion object
92943>>>>>        // by the programmer, to a consecutive number.
92943>>>>>        Property Number pnVersionNumber
92944>>>>>
92944>>>>>        Property Boolean pbUseConnectionID True
92945>>>>>        Property Boolean private.pbToANSI   True
92946>>>>>        Property Boolean private.pbRecnum   True
92947>>>>>        Property Boolean private.pbCopyData True
92948>>>>>        Property Boolean private.pbApiTableUpdateAuto False
92949>>>>>        Property Boolean private.pbCompareDate_DateTime False
92950>>>>>        Property Boolean private.pbCompareIndexAscending False
92951>>>>>        Property Boolean private.pbCompareIndexUppercase False
92952>>>>>        Property String private.psSchema
92953>>>>>        Property String private.psBaseTableSpace
92954>>>>>        Property String private.psLongTableSpace
92955>>>>>        Property String private.psIndexTableSpace
92956>>>>>
92956>>>>>        // Driver default value settings:
92956>>>>>        Property String private.psDriverDefaultValueASCII    ""
92957>>>>>        Property String private.psDriverDefaultValueBinary   ""
92958>>>>>        Property String private.psDriverDefaultValueDate     ""
92959>>>>>        Property String private.psDriverDefaultValueDateTime ""
92960>>>>>        Property String private.psDriverDefaultValueNumeric  ""
92961>>>>>        Property String private.psDriverDefaultValueText     ""
92962>>>>>
92962>>>>>        // Driver "nullability" settings:
92962>>>>>        Property Boolean private.pbDriverDefaultNullableASCII    False
92963>>>>>        Property Boolean private.pbDriverDefaultNullableBinary   False
92964>>>>>        Property Boolean private.pbDriverDefaultNullableDate     False
92965>>>>>        Property Boolean private.pbDriverDefaultNullableDateTime False
92966>>>>>        Property Boolean private.pbDriverDefaultNullableNumeric  False
92967>>>>>        Property Boolean private.pbDriverDefaultNullableText     False
92968>>>>>
92968>>>>>        // paSQLQueryMessages is a property of the container class cDbUpdateHandler.
92968>>>>>        // It is being used to gather ESQL message replies, and is output to the log file
92968>>>>>        // if pbVerboseState = True in the cDbUpdateHandler object.
92968>>>>>        // (See: Procedure Set pbDatabaseWasUpdated in the cDbUpdateHandler class)
92968>>>>>        // We reset it here for each cDbUpdateVersion object
92968>>>>>        Delegate Set paSQLQueryMessages to aSQLQueryMessages
92970>>>>>    End_Procedure
92971>>>>>
92971>>>>>    // *** Main hook event message ***
92971>>>>>    // Place your database update logic here!
92971>>>>>    Procedure OnUpdate
92973>>>>>    End_Procedure
92974>>>>>
92974>>>>>    // These properties also exists in the cDbUpdateFunctionLibray that is
92974>>>>>    // imported to the cDbUpdateHandler container class which should be a
92974>>>>>    // parent object to this object. To have the Studio's Property Panel
92974>>>>>    // "behave" aka show these properties we need to duplicate them in this
92974>>>>>    // class and "relay" them to the parent object.
92974>>>>>    Procedure Set pbToANSI Boolean bState
92976>>>>>        Set private.pbToANSI  to bState
92977>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92978>>>>>        Delegate Set pbToANSI to bState
92980>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92981>>>>>    End_Procedure
92982>>>>>
92982>>>>>    Function pbToANSI Returns Boolean
92984>>>>>        Function_Return (private.pbToAnsi(Self))
92985>>>>>    End_Function
92986>>>>>
92986>>>>>    Procedure Set pbRecnum Boolean bState
92988>>>>>        Set private.pbRecnum  to bState
92989>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92990>>>>>        Delegate Set pbRecnum to bState
92992>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92993>>>>>    End_Procedure
92994>>>>>
92994>>>>>    Function pbRecnum Returns Boolean
92996>>>>>        Function_Return (private.pbRecnum(Self))
92997>>>>>    End_Function
92998>>>>>
92998>>>>>    Procedure Set pbCopyData Boolean bState
93000>>>>>        Set private.pbCopyData  to bState
93001>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93002>>>>>        Delegate Set pbCopyData to bState
93004>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93005>>>>>    End_Procedure
93006>>>>>
93006>>>>>    Function pbCopyData Returns Boolean
93008>>>>>        Function_Return (private.pbCopyData(Self))
93009>>>>>    End_Function
93010>>>>>
93010>>>>>    // ToDo: Should we put these four properties under another "Property Panel" section?
93010>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
93012>>>>>        Set private.pbApiTableUpdateAuto  to bState
93013>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93014>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
93015>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93016>>>>>    End_Procedure
93017>>>>>
93017>>>>>    Function pbApiTableUpdateAuto Returns Boolean
93019>>>>>        Function_Return (private.pbApiTableUpdateAuto(Self))
93020>>>>>    End_Function
93021>>>>>
93021>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
93023>>>>>        Set private.pbCompareDate_DateTime  to bState
93024>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93025>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
93026>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93027>>>>>    End_Procedure
93028>>>>>
93028>>>>>    Function pbCompareDate_DateTime Returns Boolean
93030>>>>>        Function_Return (private.pbCompareDate_DateTime(Self))
93031>>>>>    End_Function
93032>>>>>
93032>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
93034>>>>>        Set private.pbCompareIndexAscending  to bState
93035>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93036>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
93037>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93038>>>>>    End_Procedure
93039>>>>>
93039>>>>>    Function pbCompareIndexAscending Returns Boolean
93041>>>>>        Function_Return (private.pbCompareIndexAscending(Self))
93042>>>>>    End_Function
93043>>>>>
93043>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
93045>>>>>        Set private.pbCompareIndexUppercase  to bState
93046>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93047>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
93048>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93049>>>>>    End_Procedure
93050>>>>>
93050>>>>>    Function pbCompareIndexUppercase Returns Boolean
93052>>>>>        Function_Return (private.pbCompareIndexUppercase(Self))
93053>>>>>    End_Function
93054>>>>>
93054>>>>>    Procedure Set psSchema String sValue
93056>>>>>        Set private.psSchema  to sValue
93057>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93058>>>>>        Delegate Set psSchema to sValue
93060>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93061>>>>>    End_Procedure
93062>>>>>
93062>>>>>    // First retrieve the private value that might have been set in the object.
93062>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93062>>>>>    // it might have been specified in the SQLConnections.ini file.
93062>>>>>    Function psSchema Returns String
93064>>>>>        String sValue
93064>>>>>        Get private.psSchema to sValue
93065>>>>>        If (sValue = "") Begin
93067>>>>>            Get psSchema of ghoSQLConnectionHandler to sValue
93068>>>>>        End
93068>>>>>>
93068>>>>>        Function_Return sValue
93069>>>>>    End_Function
93070>>>>>
93070>>>>>    Procedure Set psBaseTableSpace String sValue
93072>>>>>        Set private.psBaseTableSpace  to sValue
93073>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93074>>>>>        Delegate Set psBaseTableSpace to sValue
93076>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93077>>>>>    End_Procedure
93078>>>>>
93078>>>>>    // First retrieve the private value that might have been set in the object.
93078>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93078>>>>>    // it might have been specified in the SQLConnections.ini file.
93078>>>>>    Function psBaseTableSpace Returns String
93080>>>>>        String sValue
93080>>>>>        Get private.psBaseTableSpace to sValue
93081>>>>>        If (sValue = "") Begin
93083>>>>>            Get psBaseTableSpace of ghoSQLConnectionHandler to sValue
93084>>>>>        End
93084>>>>>>
93084>>>>>        Function_Return sValue
93085>>>>>    End_Function
93086>>>>>
93086>>>>>    Procedure Set psLongTableSpace String sValue
93088>>>>>        Set private.psLongTableSpace  to sValue
93089>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93090>>>>>        Delegate Set psLongTableSpace to sValue
93092>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93093>>>>>    End_Procedure
93094>>>>>
93094>>>>>    // First retrieve the private value that might have been set in the object.
93094>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93094>>>>>    // it might have been specified in the SQLConnections.ini file.
93094>>>>>    Function psLongTableSpace Returns String
93096>>>>>        String sValue
93096>>>>>        Get private.psLongTableSpace to sValue
93097>>>>>        If (sValue = "") Begin
93099>>>>>            Get psLongTableSpace of ghoSQLConnectionHandler to sValue
93100>>>>>        End
93100>>>>>>
93100>>>>>        Function_Return sValue
93101>>>>>    End_Function
93102>>>>>
93102>>>>>    Procedure Set psIndexTableSpace String sValue
93104>>>>>        Set private.psIndexTableSpace  to sValue
93105>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93106>>>>>        Delegate Set psIndexTableSpace to sValue
93108>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93109>>>>>    End_Procedure
93110>>>>>
93110>>>>>    // First retrieve the private value that might have been set in the object.
93110>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93110>>>>>    // it might have been specified in the SQLConnections.ini file.
93110>>>>>    Function psIndexTableSpace Returns String
93112>>>>>        String sValue
93112>>>>>        Get private.psIndexTableSpace to sValue
93113>>>>>        If (sValue = "") Begin
93115>>>>>            Get psIndexTableSpace of ghoSQLConnectionHandler to sValue
93116>>>>>        End
93116>>>>>>
93116>>>>>        Function_Return sValue
93117>>>>>    End_Function
93118>>>>>
93118>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
93120>>>>>        Set private.psDriverDefaultValueASCII  to sValue
93121>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93122>>>>>        Delegate Set psDriverDefaultValueASCII to sValue
93124>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93125>>>>>    End_Procedure
93126>>>>>
93126>>>>>    // First retrieve the private value that might have been set in the object.
93126>>>>>    // If blank; get it from the parent object
93126>>>>>    Function psDriverDefaultValueASCII Returns String
93128>>>>>        String sValue
93128>>>>>        Get private.psDriverDefaultValueASCII to sValue
93129>>>>>        If (sValue = "") Begin
93131>>>>>            Delegate Get psDriverDefaultValueASCII to sValue
93133>>>>>        End
93133>>>>>>
93133>>>>>        Function_Return sValue
93134>>>>>    End_Function
93135>>>>>
93135>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
93137>>>>>        Set private.psDriverDefaultValueBinary  to sValue
93138>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93139>>>>>        Delegate Set psDriverDefaultValueBinary to sValue
93141>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93142>>>>>    End_Procedure
93143>>>>>
93143>>>>>    // First retrieve the private value that might have been set in the object.
93143>>>>>    // If blank; get it from the parent object
93143>>>>>    Function psDriverDefaultValueBinary Returns String
93145>>>>>        String sValue
93145>>>>>        Get private.psDriverDefaultValueBinary to sValue
93146>>>>>        If (sValue = "") Begin
93148>>>>>            Delegate Get psDriverDefaultValueBinary to sValue
93150>>>>>        End
93150>>>>>>
93150>>>>>        Function_Return sValue
93151>>>>>    End_Function
93152>>>>>
93152>>>>>    Procedure Set psDriverDefaultValueDate String sValue
93154>>>>>        Set private.psDriverDefaultValueDate  to sValue
93155>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93156>>>>>        Delegate Set psDriverDefaultValueDate to sValue
93158>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93159>>>>>    End_Procedure
93160>>>>>
93160>>>>>    // First retrieve the private value that might have been set in the object.
93160>>>>>    // If blank; get it from the parent object
93160>>>>>    Function psDriverDefaultValueDate Returns String
93162>>>>>        String sValue
93162>>>>>        Get private.psDriverDefaultValueDate to sValue
93163>>>>>        If (sValue = "") Begin
93165>>>>>            Delegate Get psDriverDefaultValueDate to sValue
93167>>>>>        End
93167>>>>>>
93167>>>>>        Function_Return sValue
93168>>>>>    End_Function
93169>>>>>
93169>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
93171>>>>>        Set private.psDriverDefaultValueDateTime  to sValue
93172>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93173>>>>>        Delegate Set psDriverDefaultValueDateTime to sValue
93175>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93176>>>>>    End_Procedure
93177>>>>>
93177>>>>>    // First retrieve the private value that might have been set in the object.
93177>>>>>    // If blank; get it from the parent object
93177>>>>>    Function psDriverDefaultValueDateTime Returns String
93179>>>>>        String sValue
93179>>>>>        Get private.psDriverDefaultValueDateTime to sValue
93180>>>>>        If (sValue = "") Begin
93182>>>>>            Delegate Get psDriverDefaultValueDateTime to sValue
93184>>>>>        End
93184>>>>>>
93184>>>>>        Function_Return sValue
93185>>>>>    End_Function
93186>>>>>
93186>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
93188>>>>>        Set private.psDriverDefaultValueNumeric  to sValue
93189>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93190>>>>>        Delegate Set psDriverDefaultValueNumeric to sValue
93192>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93193>>>>>    End_Procedure
93194>>>>>
93194>>>>>    // First retrieve the private value that might have been set in the object.
93194>>>>>    // If blank; get it from the parent object
93194>>>>>    Function psDriverDefaultValueNumeric Returns String
93196>>>>>        String sValue
93196>>>>>        Get private.psDriverDefaultValueNumeric to sValue
93197>>>>>        If (sValue = "") Begin
93199>>>>>            Delegate Get psDriverDefaultValueNumeric to sValue
93201>>>>>        End
93201>>>>>>
93201>>>>>        Function_Return sValue
93202>>>>>    End_Function
93203>>>>>
93203>>>>>    Procedure Set psDriverDefaultValueText String sValue
93205>>>>>        Set private.psDriverDefaultValueText  to sValue
93206>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93207>>>>>        Delegate Set psDriverDefaultValueText to sValue
93209>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93210>>>>>    End_Procedure
93211>>>>>
93211>>>>>    // First retrieve the private value that might have been set in the object.
93211>>>>>    // If blank; get it from the parent object
93211>>>>>    Function psDriverDefaultValueText Returns String
93213>>>>>        String sValue
93213>>>>>        Get private.psDriverDefaultValueText to sValue
93214>>>>>        If (sValue = "") Begin
93216>>>>>            Delegate Get psDriverDefaultValueText to sValue
93218>>>>>        End
93218>>>>>>
93218>>>>>        Function_Return sValue
93219>>>>>    End_Function
93220>>>>>
93220>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
93222>>>>>        Set private.pbDriverDefaultNullableASCII  to bState
93223>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93224>>>>>        Delegate Set pbDriverDefaultNullableASCII to bState
93226>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93227>>>>>    End_Procedure
93228>>>>>
93228>>>>>    // First retrieve the private value that might have been set in the object.
93228>>>>>    // If blank; get it from the parent object
93228>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
93230>>>>>        Boolean bState
93230>>>>>        Get private.pbDriverDefaultNullableASCII to bState
93231>>>>>        If (bState = False) Begin
93233>>>>>            Delegate Get pbDriverDefaultNullableASCII to bState
93235>>>>>        End
93235>>>>>>
93235>>>>>        Function_Return bState
93236>>>>>    End_Function
93237>>>>>
93237>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
93239>>>>>        Set private.pbDriverDefaultNullableBinary  to bState
93240>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93241>>>>>        Delegate Set pbDriverDefaultNullableBinary to bState
93243>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93244>>>>>    End_Procedure
93245>>>>>
93245>>>>>    // First retrieve the private value that might have been set in the object.
93245>>>>>    // If blank; get it from the parent object
93245>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
93247>>>>>        Boolean bState
93247>>>>>        Get private.pbDriverDefaultNullableBinary to bState
93248>>>>>        If (bState = False) Begin
93250>>>>>            Delegate Get pbDriverDefaultNullableBinary to bState
93252>>>>>        End
93252>>>>>>
93252>>>>>        Function_Return bState
93253>>>>>    End_Function
93254>>>>>
93254>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
93256>>>>>        Set private.pbDriverDefaultNullableDate  to bState
93257>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93258>>>>>        Delegate Set pbDriverDefaultNullableDate to bState
93260>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93261>>>>>    End_Procedure
93262>>>>>
93262>>>>>    // First retrieve the private value that might have been set in the object.
93262>>>>>    // If blank; get it from the parent object
93262>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
93264>>>>>        Boolean bState
93264>>>>>        Get private.pbDriverDefaultNullableDate to bState
93265>>>>>        If (bState = False) Begin
93267>>>>>            Delegate Get pbDriverDefaultNullableDate to bState
93269>>>>>        End
93269>>>>>>
93269>>>>>        Function_Return bState
93270>>>>>    End_Function
93271>>>>>
93271>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
93273>>>>>        Set private.pbDriverDefaultNullableDateTime  to bState
93274>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93275>>>>>        Delegate Set pbDriverDefaultNullableDateTime to bState
93277>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93278>>>>>    End_Procedure
93279>>>>>
93279>>>>>    // First retrieve the private value that might have been set in the object.
93279>>>>>    // If blank; get it from the parent object
93279>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
93281>>>>>        Boolean bState
93281>>>>>        Get private.pbDriverDefaultNullableDateTime to bState
93282>>>>>        If (bState = False) Begin
93284>>>>>            Delegate Get pbDriverDefaultNullableDateTime to bState
93286>>>>>        End
93286>>>>>>
93286>>>>>        Function_Return bState
93287>>>>>    End_Function
93288>>>>>
93288>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
93290>>>>>        Set private.pbDriverDefaultNullableNumeric  to bState
93291>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93292>>>>>        Delegate Set pbDriverDefaultNullableNumeric to bState
93294>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93295>>>>>    End_Procedure
93296>>>>>
93296>>>>>    // First retrieve the private value that might have been set in the object.
93296>>>>>    // If blank; get it from the parent object
93296>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
93298>>>>>        Boolean bState
93298>>>>>        Get private.pbDriverDefaultNullableNumeric to bState
93299>>>>>        If (bState = False) Begin
93301>>>>>            Delegate Get pbDriverDefaultNullableNumeric to bState
93303>>>>>        End
93303>>>>>>
93303>>>>>        Function_Return bState
93304>>>>>    End_Function
93305>>>>>
93305>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
93307>>>>>        Set private.pbDriverDefaultNullableText  to bState
93308>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93309>>>>>        Delegate Set pbDriverDefaultNullableText to bState
93311>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93312>>>>>    End_Procedure
93313>>>>>
93313>>>>>    // First retrieve the private value that might have been set in the object.
93313>>>>>    // If blank; get it from the parent object
93313>>>>>    Function pbDriverDefaultNullableText Returns Boolean
93315>>>>>        Boolean bState
93315>>>>>        Get private.pbDriverDefaultNullableText to bState
93316>>>>>        If (bState = False) Begin
93318>>>>>            Delegate Get pbDriverDefaultNullableText to bState
93320>>>>>        End
93320>>>>>>
93320>>>>>        Function_Return bState
93321>>>>>    End_Function
93322>>>>>
93322>>>>>    Function ApiTableConvertToSQL Handle hTable Returns Boolean
93324>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK
93324>>>>>        String sDriverID sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace
93324>>>>>
93324>>>>>        Get psDriverID to sDriverID
93325>>>>>        Get psSchema to sSchema
93326>>>>>
93326>>>>>        Get psBaseTableSpace to sBaseTableSpace
93327>>>>>        If (sBaseTableSpace <> "") Begin
93329>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93330>>>>>            Delegate Set psBaseTableSpace to sBaseTableSpace
93332>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93333>>>>>        End
93333>>>>>>
93333>>>>>
93333>>>>>        Get psLongTableSpace to sLongTableSpace
93334>>>>>        If (sLongTableSpace <> "") Begin
93336>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93337>>>>>            Delegate Set psLongTableSpace to sLongTableSpace
93339>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93340>>>>>        End
93340>>>>>>
93340>>>>>
93340>>>>>        Get psIndexTableSpace to sIndexTableSpace
93341>>>>>        If (sIndexTableSpace <> "") Begin
93343>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93344>>>>>            Delegate Set psIndexTableSpace to sIndexTableSpace
93346>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93347>>>>>        End
93347>>>>>>
93347>>>>>
93347>>>>>        Get pbUseConnectionID to bUseConnectionID
93348>>>>>        Get pbToANSI          to bToANSI
93349>>>>>        Get pbRecnum          to bRecnum
93350>>>>>        Get pbCopyData        to bCopyData
93351>>>>>
93351>>>>>        Get ApiTableConvertToSQL_Ex hTable sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
93352>>>>>
93352>>>>>        Function_Return bOK
93353>>>>>    End_Function
93354>>>>>
93354>>>>>//    Function ApiTableMoveAllToBackupFolder Returns Boolean
93354>>>>>//        Boolean bOK bExists
93354>>>>>//        String sDataPath sBackupFolder
93354>>>>>//        
93354>>>>>//        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
93354>>>>>//        Move CS_DUFBackupDataFolder to sBackupFolder
93354>>>>>//        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
93354>>>>>//        Get vFolderFormat sDataPath to sDataPath
93354>>>>>//        
93354>>>>>//        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
93354>>>>>//        If (bExists = False) Begin
93354>>>>>//            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
93354>>>>>//            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
93354>>>>>//            If (bExists = False) Begin
93354>>>>>//                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
93354>>>>>//                Function_Return False
93354>>>>>//            End                                                                                                                                            
93354>>>>>//            Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
93354>>>>>//            Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
93354>>>>>//            Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
93354>>>>>//            Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
93354>>>>>//        End
93354>>>>>//        
93354>>>>>//        Set Message_Text of ghoStatusPanel to ""
93354>>>>>//        Function_Return bOK
93354>>>>>//    End_Function
93354>>>>>//
93354>>>>>    // This is automatically called after the OnUpdate
93354>>>>>    // event has been executed. It will automatically update the
93354>>>>>    // version database field/column with the "pnVersionNumber"
93354>>>>>    // value of the parent cDbUpdateHandler class - if it has been changed.
93354>>>>>    Procedure UpdateVersionColumnValue
93356>>>>>        Number nVersion nCurrentValue
93356>>>>>        Integer hTable iColumn
93356>>>>>        Boolean bVersionUpdate bDbUpdateErrorHasOccured bUseCustomDbVersion
93356>>>>>
93356>>>>>        Move False to Err
93357>>>>>        Move 0 to LastErr
93358>>>>>        // This is a property of the container class; cDbUpdateHandler that gets set when
93358>>>>>        // an error occurres when processing ESQL or database API messages of the cDbUpdateFunctionLibrary.
93358>>>>>        Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
93360>>>>>        Get pbVersionUpdate to bVersionUpdate
93361>>>>>
93361>>>>>        If (bVersionUpdate = True and bDbUpdateErrorHasOccured = False) Begin
93363>>>>>            Get pnVersionNumber to nVersion
93364>>>>>            Delegate Get piDbVersionFileNumber  to hTable
93366>>>>>            Delegate Get piDbVersionFieldNumber to iColumn
93368>>>>>            // NB! We need to permanently close tables as they e.g. now might no longer be embedded
93368>>>>>            // but instead SQL tables. If we don't the "old" embedded table will be opened instead.
93368>>>>>            Close DF_ALL DF_PERMANENT
93369>>>>>
93369>>>>>            Open hTable
93371>>>>>
93371>>>>>            // It is then the developer responsibility to take care of finding
93371>>>>>            // the correct record that is to be updated (The DbVersion table is not used). 
93371>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
93373>>>>>            If (bUseCustomDbVersion = True) Begin
93375>>>>>                Delegate Send OnFindVersionRecord   // cDbUpdateHandler object event (Programmer's hook!).
93377>>>>>            End
93377>>>>>>
93377>>>>>
93377>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
93380>>>>>            If (nCurrentValue < nVersion) Begin
93382>>>>>                Lock
93383>>>>>>
93383>>>>>                    If (bUseCustomDbVersion = False) Begin
93385>>>>>                        Vfind hTable Recnum GE                            
93387>>>>>                    End
93387>>>>>>
93387>>>>>                    Set_Field_Value hTable iColumn to nVersion
93390>>>>>                    SaveRecord hTable
93391>>>>>                Unlock
93392>>>>>>
93392>>>>>            End
93392>>>>>>
93392>>>>>            Close hTable
93393>>>>>        End
93393>>>>>>
93393>>>>>    End_Procedure
93394>>>>>
93394>>>>>// Property of the container object (cDbUpdateHandler)
93394>>>>>Register_Function piCurrentErrorHandlerID Returns Integer
93394>>>>>
93394>>>>>    Procedure End_Construct_Object
93396>>>>>        Forward Send End_Construct_Object
93398>>>>>        Send ProcessUpdate True
93399>>>>>    End_Procedure
93400>>>>>    
93400>>>>>    Procedure ProcessUpdate Boolean bShouldTestForDuplicateVersionNumbers
93402>>>>>        Number nVersion nCurrentValue
93402>>>>>        Integer hTable iColumn iSize iDbVersionFileNumber iStatus iErrorObject
93402>>>>>        Boolean bStopOnFirstError bDbUpdateErrorHasOccured bContinueOnError bOpened 
93402>>>>>        Boolean bSystemTable bUseCustomDbVersion bTableExists bOnPreUpdateExecuted bExitIfDebuggerActive
93402>>>>>        String sObjectName
93402>>>>>        tDbVersionInfo[] dbVersionInfoArray
93402>>>>>        tDbVersionInfo[] dbVersionInfoArray
93403>>>>>
93403>>>>>        Move 0 to nCurrentValue
93404>>>>>        Delegate Set Private.pbUpdateVersionObjectError to False
93406>>>>>
93406>>>>>        Delegate Get pbExitIfDebuggerActive to bExitIfDebuggerActive
93408>>>>>        If (IsDebuggerPresent() and bExitIfDebuggerActive = True) Begin
93410>>>>>            Delegate Get piOrgErrorHandlerID to iErrorObject
93412>>>>>            If (iErrorObject <> 0) Begin
93414>>>>>                Move iErrorObject to Error_Object_Id
93415>>>>>            End
93415>>>>>>
93415>>>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio! You need to run this program from outside of the Studio."
93416>>>>>>
93416>>>>>            Send Exit_Application
93417>>>>>        End
93417>>>>>>
93417>>>>>        // If the programmer forgot to set the version number we do not allow for the application
93417>>>>>        // to continue to run, as this potentially could endanger the integrity of the database. E.g. if
93417>>>>>        // one database update is depended on an earlier update and that earlier version
93417>>>>>        // update was never executed it could lead to disastrous results.
93417>>>>>        // This is a programmer error and should be discovered before any customer sees it. Thus no point in translating...
93417>>>>>        Get pnVersionNumber to nVersion
93418>>>>>        If (nVersion < 0) Begin
93420>>>>>            Get piCurrentErrorHandlerID to Error_Object_Id
93421>>>>>            Move (Name(Self)) to sObjectName
93422>>>>>            Error DFERR_PROGRAM ("The pnVersionNumber property was not set properly by the programmer for the following object; Program will now exit!\n\n" + sObjectName)
93423>>>>>>
93423>>>>>            Send Exit_Application
93424>>>>>        End
93424>>>>>>
93424>>>>>
93424>>>>>        // These are send to the parent container object (cDbUpdateHandler). The order is very sensitive!
93424>>>>>        // Hook event for the developer to e.g. create a database before the update events starts.
93424>>>>>        Delegate Get Private.pbOnPreUpdateExecuted to bOnPreUpdateExecuted
93426>>>>>        If (bOnPreUpdateExecuted = False) Begin
93428>>>>>            Delegate Send OnPreUpdate
93430>>>>>            Delegate Set Private.pbOnPreUpdateExecuted to True
93432>>>>>        End
93432>>>>>>
93432>>>>>        
93432>>>>>        Delegate Get piDbVersionFileNumber to iDbVersionFileNumber
93434>>>>>        
93434>>>>>        Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
93436>>>>>        If (bUseCustomDbVersion = True) Begin
93438>>>>>            Get _UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
93439>>>>>            If (bTableExists = False) Begin
93441>>>>>                Delegate Send OnCreateCustomDbVersionTable
93443>>>>>            End
93443>>>>>>
93443>>>>>        End
93443>>>>>>
93443>>>>>        
93443>>>>>        // We now check that two or more cDbVersion objects does not have the same pnVersionNumber.
93443>>>>>        // Note that the paDbVersionInfoArray is a property of the container object (cDbUpdateHandler)
93443>>>>>        If (bShouldTestForDuplicateVersionNumbers = True) Begin
93445>>>>>            Delegate Get paDbVersionInfoArray to dbVersionInfoArray
93447>>>>>            Move (SizeOfArray(dbVersionInfoArray)) to iSize
93448>>>>>            Move nVersion to dbVersionInfoArray[iSize].nVersionNumber
93449>>>>>            Move (Self)   to dbVersionInfoArray[iSize].hObject
93450>>>>>            Delegate Set paDbVersionInfoArray to dbVersionInfoArray
93452>>>>>            Delegate Send CheckForDuplicates nVersion   // cDbUpdateHandler object event.
93454>>>>>        End
93454>>>>>>
93454>>>>>
93454>>>>>        Delegate Get piDbVersionFileNumber  to hTable
93456>>>>>        Delegate Get piDbVersionFieldNumber to iColumn
93458>>>>>
93458>>>>>        Open hTable
93460>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
93463>>>>>        If (bOpened = False) Begin
93465>>>>>            Send Stop_Box CS_DUF_DbUpdateTableMissing
93466>>>>>            Send Exit_Application
93467>>>>>        End
93467>>>>>>
93467>>>>>        
93467>>>>>        // It can happen that the table isn't initialized with a record even though it is a system table,
93467>>>>>        // in case we take care of it here.
93467>>>>>        Get_Attribute DF_FILE_STATUS of hTable to iStatus
93470>>>>>        If (iStatus = DF_FILE_INACTIVE) Begin
93472>>>>>            Vfind hTable 0 GT
93474>>>>>        End
93474>>>>>>
93474>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemTable
93477>>>>>        If (bSystemTable = True) Begin
93479>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
93482>>>>>        End
93482>>>>>>
93482>>>>>        Else Begin
93483>>>>>            If (bUseCustomDbVersion = True) Begin
93485>>>>>                Send OnFindVersionRecord
93486>>>>>                Get_Field_Value hTable iColumn to nCurrentValue
93489>>>>>            End
93489>>>>>>
93489>>>>>        End
93489>>>>>>
93489>>>>>
93489>>>>>        Close hTable
93490>>>>>
93490>>>>>        // We also guard from missing 'DatabaseVersionInfoTable' and column properties settings.
93490>>>>>        // If not set we do nothing.
93490>>>>>        If (nCurrentValue < nVersion) Begin
93492>>>>>
93492>>>>>            // If pbStopOnFirstError is True in the parent, the idea is that we do _no_ further
93492>>>>>            // execution of database update code. So if true _and_ one error
93492>>>>>            // has already occured; we're out of here.
93492>>>>>            Delegate Get pbStopOnFirstError        to bStopOnFirstError
93494>>>>>            Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
93496>>>>>            If (bStopOnFirstError = True) Begin
93498>>>>>                If (bDbUpdateErrorHasOccured = True) Begin
93500>>>>>                    Procedure_Return
93501>>>>>                End
93501>>>>>>
93501>>>>>            End
93501>>>>>>
93501>>>>>
93501>>>>>            // This is send to the parent container object (cDbUpdateHandler)
93501>>>>>            Delegate Send InitDatabaseUpdate (Self)    // cDbUpdateHandler object event.
93503>>>>>
93503>>>>>            // If the parent property pbContinueOnError = False, an update
93503>>>>>            // of a following cDbUpdateVersion object should not take place and we're out of here.
93503>>>>>            Delegate Get pbContinueOnError to bContinueOnError
93505>>>>>            If (bContinueOnError = False and bDbUpdateErrorHasOccured = True) Begin
93507>>>>>                Procedure_Return
93508>>>>>            End
93508>>>>>>
93508>>>>>
93508>>>>>            Delegate Set pnCurrentVersionUpdate to nVersion
93510>>>>>
93510>>>>>            Set Title_Text of ghoStatusPanel to (CS_DUF_UpdateVersion * CS_DUF_UpdateFromVersion * String(nCurrentValue) * CS_DUF_UpdateToVersion * String(nVersion))
93511>>>>>
93511>>>>>            // *** Programmer's main hook event for database update functions:
93511>>>>>            Send OnUpdate
93512>>>>>
93512>>>>>            Set pbVersionUpdate to True
93513>>>>>            Send UpdateVersionColumnValue
93514>>>>>            Delegate Set pbDatabaseWasUpdated to True   // cDbUpdateHandler property.
93516>>>>>        End
93516>>>>>>
93516>>>>>
93516>>>>>    End_Procedure
93517>>>>>
93517>>>>>End_Class
93518>>>Use cDbUpdateUserCount.pkg
Including file: cDbUpdateUserCount.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.pkg)
93518>>>>>//****************************************************************************
93518>>>>>// $Module type: Class
93518>>>>>// $Module name: cDbUpdateUserCount.pkg
93518>>>>>// $Author     : Emil Stojanov Quantaris B.V.
93518>>>>>//
93518>>>>>//               Collected from DAW's newsgroups.
93518>>>>>//
93518>>>>>// Description : It uses the windows API to lock bytes in a file.
93518>>>>>//               If the application or PC craches it will release the lock
93518>>>>>//               automatically.
93518>>>>>//
93518>>>>>// Note 1      : It will count the number of running app's, so if a
93518>>>>>//               user starts the app twice on one machine it will count as two users.
93518>>>>>// Note 2      : The class was originally named cUserCount by Emil Stojanov.
93518>>>>>//               However, to not conflict with any other usage of this class it was
93518>>>>>//               renamed to "fit" into the "Database Update Framework" (cDbUpdateHandler
93518>>>>>//               and cDbUpdateVersion classes)
93518>>>>>//
93518>>>>>// $Rev History:
93518>>>>>//    2008-10-17  Module header created (Militaty data format)
93518>>>>>//    2008-10-17  Minor changes by Nils G Svedmyr. Created UI text constants
93518>>>>>//                for easy translation to other languages.
93518>>>>>//                Added the tUserCount struct for easier passing of parameters.
93518>>>>>//                Added the ApplicationPath message.
93518>>>>>//****************************************************************************
93518>>>>>Use LanguageText.pkg
93518>>>>>Use cDbUpdateUserCount.inc
Including file: cDbUpdateUserCount.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.inc)
93518>>>>>>>Use GlobalFunctionsProcedures.pkg
93518>>>>>>>// Sample:
93518>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
93518>>>>>>>
93518>>>>>>>
93518>>>>>>>// Symbols used by UserCounting
93518>>>>>>>    Define GENERIC_READ         for |CI$80000000
93518>>>>>>>    Define GENERIC_WRITE        for |CI$40000000
93518>>>>>>>    Define GENERIC_EXECUTE      for |CI$20000000
93518>>>>>>>    Define GENERIC_ALL          for |CI$10000000
93518>>>>>>>    Define CREATE_NEW           for 1
93518>>>>>>>    Define CREATE_ALWAYS        for 2
93518>>>>>>>    Define OPEN_EXISTING        for 3
93518>>>>>>>    Define OPEN_ALWAYS          for 4
93518>>>>>>>    Define TRUNCATE_EXISTING    for 5
93518>>>>>>>    Define FILE_BEGIN           for 0
93518>>>>>>>    Define FILE_CURRENT         for 1
93518>>>>>>>    Define FILE_END             for 2
93518>>>>>>>    Define FILE_SHARE_READ      for |CI$00000001
93518>>>>>>>    Define FILE_SHARE_WRITE     for |CI$00000002
93518>>>>>>>    Define FILE_SHARE_DELETE    for |CI$00000004
93518>>>>>>>    Define FILE_FLAG_WRITE_THROUGH            for |CI$80000000
93518>>>>>>>    Define _MAX_PATH  for 260
93518>>>>>>>    Define _MAX_DRIVE for 3
93518>>>>>>>    Define _MAX_DIR   for 256
93518>>>>>>>    Define _MAX_FNAME for 256
93518>>>>>>>    Define _MAX_EXT   for 256
93518>>>>>>>
93518>>>>>>>External_Function Win32_CreateFile "CreateFileA" KERNEL32.DLL ;    Pointer lpFileName ;              // file name    DWord dwDesiredAccess ;           // access mode    DWord dwShareMode ;               // share mode    Pointer lpSecurityAttributes ;    // SD    DWord dwCreationDisposition ;     // how to create    DWord dwFlagsAndAttributes ;      // file attributes    Handle hTemplateFile ;            // handle to template file    Returns Handle
93519>>>>>>>
93519>>>>>>>External_Function Win32_ReadFile "ReadFile" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Pointer lpBuffer ;              // pointer to the buffer that receives the data    dWord nNumberOfBytesToRead ;    // number of bytes to read    Pointer lpNumberOfBytesRead ;   // number of bytes read    Pointer lpOverlapped ;          // pointer to an overlapped structure    Returns Integer
93520>>>>>>>
93520>>>>>>>External_Function Win32_WriteFile "WriteFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    Pointer lpBuffer ;                  // pointer to buffer containing data to write    dWord nNumberOfBytesToWrite ;       // number of bytes to write    Pointer lpNumberOfBytesWritten ;    // number of bytes written    Pointer lpOverlapped ;              // pointer to an overlapped structure    Returns Integer
93521>>>>>>>
93521>>>>>>>External_Function Win32_LockFile "LockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToLockLow ;     // low-order word of length    dWord nNumberOfBytesToLockHigh ;    // high-order word of length    Returns Integer
93522>>>>>>>
93522>>>>>>>External_Function Win32_UnlockFile "UnlockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToUnLockLow ;   // low-order word of length    dWord nNumberOfBytesToUnLockHigh ;  // high-order word of length    Returns Integer
93523>>>>>>>
93523>>>>>>>External_Function Win32_SetFilePointer "SetFilePointer" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Integer lDistanceToMove ;       // bytes to move pointer (low-order 32-bits)    Pointer lpDistanceToMoveHigh ;  // bytes to move pointer (high-order 32-bits)    dWord dwMoveMethod ;            // starting point    Returns dWord
93524>>>>>>>
93524>>>>>>>External_Function Win32_CloseHandle "CloseHandle" KERNEL32.DLL ;    Handle hObject ;    // handle to object    Returns Integer
93525>>>>>>>
93525>>>>>>>External_Function SetDefaultPrinterEf "SetDefaultPrinterA" winspool.drv Pointer lpPrinter Returns Boolean
93526>>>>>>>// Sample:
93526>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
93526>>>>>>>Function DoSetDefaultPrinter String sPrinter Returns Boolean
93528>>>>>>>    Boolean bReturn
93528>>>>>>>    Move (Utf8ToAnsi(sPrinter)) to sPrinter
93529>>>>>>>    Move (sPrinter + (Character(0))) to sPrinter
93530>>>>>>>    Move (SetDefaultPrinterEf(AddressOf(sPrinter))) to bReturn
93531>>>>>>>    Function_Return bReturn
93532>>>>>>>End_Function
93533>>>>>Use vWin32fh.pkg
93533>>>>>Use seq_chnl.pkg
93533>>>>>
93533>>>>>// User interface constant strings:
93533>>>>>    Define CS_UserCountError            for "User count error:"
93533>>>>>    Define CS_UnableToInitUserCountSys  for "Unable to initialize user counting system!"
93533>>>>>    Define CS_UnableResetUserCountSys   for "Error resetting usercounting system!"
93533>>>>>    Define CS_ErrorAdvancingPointer     for "Error advancing file pointer!"
93533>>>>>    Define CS_MaxNoOfUserExceeded       for "Maximum number of users exceeded!"
93533>>>>>
93533>>>>>
93533>>>>>
93533>>>>>
93533>>>>>
93533>>>>>
93533>>>>>
93533>>>>>
93533>>>>>
93533>>>>>
93533>>>>>
93533>>>>>
93533>>>>>
93533>>>>>    Struct tUserCount
93533>>>>>        Integer iUserCount
93533>>>>>        Integer iError
93533>>>>>        String  sErrorTxt
93533>>>>>    End_Struct
93533>>>>>
93533>>>>>    Define CI_UserCountMaxUsers for 9999
93533>>>>>
93533>>>>>Class cDbUpdateUserCount is a cObject
93534>>>>>    Procedure Construct_Object
93536>>>>>        Forward Send Construct_Object
93538>>>>>
93538>>>>>        Property String  psLockFileName
93539>>>>>        Property Integer piMaxUsers
93540>>>>>        Property Boolean pbCheckDataFlexUserCount True
93541>>>>>
93541>>>>>        Property Handle  phUserCountFile
93542>>>>>        Property Integer pdwLockPosition
93543>>>>>    End_Procedure
93544>>>>>
93544>>>>>    Function IsProgramRunning Returns Boolean
93546>>>>>        tUserCount UserCount
93546>>>>>        tUserCount UserCount
93546>>>>>
93546>>>>>        Get CheckUserCount to UserCount
93547>>>>>
93547>>>>>        Function_Return (UserCount.iUserCount > 1)
93548>>>>>    End_Function
93549>>>>>
93549>>>>>    // Returns the full path of the Application (no trailing "\")
93549>>>>>    Function ApplicationPath Returns String
93551>>>>>        String sApplicationFileName sPath
93551>>>>>        Integer iNumChars iRetval
93551>>>>>
93551>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
93552>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
93553>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
93554>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
93555>>>>>        Move (CString(sApplicationFileName)) to sPath
93556>>>>>
93556>>>>>        Function_Return sPath
93557>>>>>    End_Function
93558>>>>>
93558>>>>>    Function OpenUserCountFile String sFileName Returns Handle
93560>>>>>        Handle  hFile
93560>>>>>        Pointer pFileName
93560>>>>>        String sPath sFile
93560>>>>>        Integer iCh
93560>>>>>
93560>>>>>        Move (Addressof(sFileName)) to pFileName
93561>>>>>        Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
93562>>>>>
93562>>>>>        // If lock file doesn't exist, create it.
93562>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
93564>>>>>            Get ApplicationPath to sPath
93565>>>>>            Get vFolderFormat sPath to sPath
93566>>>>>            Move (sPath + psLockFileName(Self)) to sFile
93567>>>>>            Get Seq_Open_Output_Channel sFile to iCh
93568>>>>>            If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
93570>>>>>                Function_Return 0
93571>>>>>            End
93571>>>>>>
93571>>>>>            Direct_Output channel iCh sFile
93573>>>>>                Write channel iCh ""
93575>>>>>            Send Seq_Close_Channel iCh
93576>>>>>            Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
93577>>>>>        End
93577>>>>>>
93577>>>>>
93577>>>>>        Function_Return hFile
93578>>>>>    End_Function
93579>>>>>
93579>>>>>    Function CloseUserCountFile Handle hFile Returns Integer
93581>>>>>        Integer iReturnValue 
93581>>>>>        Boolean bOK
93581>>>>>
93581>>>>>        Move (Win32_CloseHandle(hFile)) to iReturnValue
93582>>>>>        If (iReturnValue = 0) Begin
93584>>>>>            Move False to bOK
93585>>>>>        End
93585>>>>>>
93585>>>>>        Else Begin
93586>>>>>            Move True to bOK
93587>>>>>        End
93587>>>>>>
93587>>>>>        Function_Return bOK
93588>>>>>    End_Function
93589>>>>>
93589>>>>>    Function UnlockUserCountFile Handle hFile dWord dwLockPos Returns Integer
93591>>>>>        Integer iReturnValue
93591>>>>>        Boolean bOK
93591>>>>>
93591>>>>>        Move (Win32_UnLockFile(hFile, dwLockPos, 0, 1, 0)) to iReturnValue
93592>>>>>        If (iReturnValue = 0) Begin
93594>>>>>            Move False to bOK
93595>>>>>        End
93595>>>>>>
93595>>>>>        Else Begin
93596>>>>>            Move True to bOK
93597>>>>>        End           
93597>>>>>>
93597>>>>>        Function_Return bOK
93598>>>>>    End_Function
93599>>>>>
93599>>>>>    Function ReSetUserCountPointer Handle hFile Returns dWord
93601>>>>>        dWord dwCurrPos
93601>>>>>
93601>>>>>        Move (Win32_SetFilePointer(hFile, 0, 0, FILE_BEGIN)) to dwCurrPos
93602>>>>>        Function_Return dwCurrPos
93603>>>>>    End_Function
93604>>>>>
93604>>>>>    Function SetUserCountPointer Handle hFile Integer iAdvance Returns dWord
93606>>>>>        DWord dwCurrPos
93606>>>>>
93606>>>>>        Move (Win32_SetFilePointer(hFile, iAdvance, 0, FILE_CURRENT)) to dwCurrPos
93607>>>>>        Function_Return dwCurrPos
93608>>>>>    End_Function
93609>>>>>
93609>>>>>    Function ReadUserCountFile Handle hFile Returns Boolean
93611>>>>>        Integer iReturnValue                               
93611>>>>>        Boolean bOK
93611>>>>>        String  sBuffer
93611>>>>>        Pointer pBuffer
93611>>>>>        String  sSize
93611>>>>>        Pointer pSize
93611>>>>>
93611>>>>>        Move (Repeat((Character(0)),5)) to sBuffer
93612>>>>>        Move (AddressOf(sBuffer)) to pBuffer
93613>>>>>
93613>>>>>        Move (Repeat((Character(0)),4)) to sSize
93614>>>>>        Move (AddressOf(sSize)) to pSize
93615>>>>>
93615>>>>>        Move (Win32_ReadFile(hFile, pBuffer, 1, pSize, 0)) to iReturnValue
93616>>>>>        If (iReturnValue = 0) Begin
93618>>>>>            Move False to bOK
93619>>>>>        End
93619>>>>>>
93619>>>>>        Else Begin
93620>>>>>            Move True to bOK
93621>>>>>        End                 
93621>>>>>>
93621>>>>>        Function_Return bOK
93622>>>>>    End_Function
93623>>>>>
93623>>>>>    Function LockUserCountFile Handle hFile dWord dwFilePos Returns Integer
93625>>>>>        Integer iReturnValue
93625>>>>>
93625>>>>>        Move (Win32_LockFile(hFile, dwFilePos, 0, 1, 0)) to iReturnValue
93626>>>>>        Function_Return iReturnValue
93627>>>>>    End_Function
93628>>>>>
93628>>>>>    Procedure DoCheckUserCount
93630>>>>>        tUserCount UserCount
93630>>>>>        tUserCount UserCount
93630>>>>>
93630>>>>>        Get CheckUserCount to UserCount
93631>>>>>        // If all is fine, we're done.
93631>>>>>        If (UserCount.iError = 0) Begin
93633>>>>>            Procedure_Return
93634>>>>>        End
93634>>>>>>
93634>>>>>
93634>>>>>        Send UserError (CS_UserCountError * String(UserCount.iError) + "\n" + UserCount.sErrorTxt)
93635>>>>>
93635>>>>>        If (UserCount.iUserCount = CI_UserCountMaxUsers) Begin
93637>>>>>            Abort
93638>>>>>>
93638>>>>>        End
93638>>>>>>
93638>>>>>    End_Procedure
93639>>>>>
93639>>>>>    Function CheckUserCount Returns tUserCount
93641>>>>>        Handle  hFile
93641>>>>>        String  sPath sFile
93641>>>>>        Integer iResult
93641>>>>>        DWord   dwFilePos
93641>>>>>        Integer bLocked
93641>>>>>        Integer iMaxUsers
93641>>>>>        Integer iCurUser
93641>>>>>        tUserCount UserCount
93641>>>>>        tUserCount UserCount
93641>>>>>
93641>>>>>        Move 0 to UserCount.iError
93642>>>>>
93642>>>>>        Get phUserCountFile to hFile
93643>>>>>        If (not(hFile)) Begin
93645>>>>>            Get ApplicationPath to sPath
93646>>>>>            Get vFolderFormat sPath to sPath
93647>>>>>            Move (sPath + psLockFileName(Self)) to sFile
93648>>>>>            Get OpenUserCountFile sFile to hFile
93649>>>>>            If (hFile = INVALID_HANDLE_VALUE) Begin
93651>>>>>                Move 1 to UserCount.iUserCount
93652>>>>>                Move 1 to UserCount.iError
93653>>>>>                Move CS_UnableToInitUserCountSys to UserCount.sErrorTxt
93654>>>>>                Function_Return UserCount
93655>>>>>            End
93655>>>>>>
93655>>>>>            Else Begin
93656>>>>>                Move False to bLocked
93657>>>>>                Set phUserCountFile to hFile
93658>>>>>                Get piMaxUsers to iMaxUsers
93659>>>>>
93659>>>>>                // Set Filepointer to beginning of the file
93659>>>>>                Get ResetUserCountPointer hFile to dwFilePos
93660>>>>>                If (dwFilePos = -1) Begin
93662>>>>>                    Move 1 to UserCount.iUserCount
93663>>>>>                    Move 2 to UserCount.iError
93664>>>>>                    Move CS_UnableResetUserCountSys to UserCount.sErrorTxt
93665>>>>>                    Function_Return UserCount
93666>>>>>                End
93666>>>>>>
93666>>>>>                For iCurUser from 1 to iMaxUsers
93672>>>>>>
93672>>>>>                    Get LockUserCountFile hFile dwFilePos to iResult
93673>>>>>                    If (not(iResult)) Begin  // byte is locked
93675>>>>>                        Get SetUserCountPointer hFile 10 to dwFilePos
93676>>>>>                        If (dwFilePos = -1) Begin
93678>>>>>                            Move 1 to UserCount.iUserCount
93679>>>>>                            Move 3 to UserCount.iError
93680>>>>>                            Move CS_ErrorAdvancingPointer to UserCount.sErrorTxt
93681>>>>>                            Function_Return UserCount
93682>>>>>                        End
93682>>>>>>
93682>>>>>                    End
93682>>>>>>
93682>>>>>                    Else Begin  // byte is not locked
93683>>>>>                        Set pdwLockPosition to dwFilePos
93684>>>>>                        Move True to bLocked
93685>>>>>                        Move iMaxUsers to iCurUser
93686>>>>>                    End
93686>>>>>>
93686>>>>>                Loop
93687>>>>>>
93687>>>>>                If (not(bLocked)) Begin
93689>>>>>                    Move CI_UserCountMaxUsers to UserCount.iUserCount
93690>>>>>                    Move 4 to UserCount.iError
93691>>>>>                    Move CS_MaxNoOfUserExceeded to UserCount.sErrorTxt
93692>>>>>                    Function_Return UserCount
93693>>>>>                End
93693>>>>>>
93693>>>>>            End
93693>>>>>>
93693>>>>>        End
93693>>>>>>
93693>>>>>
93693>>>>>        Function_Return UserCount
93694>>>>>    End_Function
93695>>>>>
93695>>>>>
93695>>>>>    Procedure DoReleaseUserCount
93697>>>>>        Integer iResult
93697>>>>>        Handle  hFile
93697>>>>>        DWord   dwLockPos
93697>>>>>
93697>>>>>        Get phUserCountFile to hFile
93698>>>>>        Get pdwLockPosition to dwLockPos
93699>>>>>        If (hFile) Begin
93701>>>>>            If (dwLockPos) Begin
93703>>>>>                Get UnlockUserCountFile hFile dwLockPos to iResult
93704>>>>>            End
93704>>>>>>
93704>>>>>            Get CloseUserCountFile hFile to iResult
93705>>>>>        End
93705>>>>>>
93705>>>>>    End_Procedure
93706>>>>>
93706>>>>>    Function CurrentNumberOfUsers Returns Integer
93708>>>>>        Handle  hFile
93708>>>>>        Integer iMaxUsers
93708>>>>>        DWord   dwFilePos
93708>>>>>        Integer iCurUser
93708>>>>>        Integer iResult
93708>>>>>        Integer iNumberOfLocks
93708>>>>>        String  sPath sFile
93708>>>>>
93708>>>>>        Move 0 to iNumberOfLocks
93709>>>>>
93709>>>>>        Get ApplicationPath to sPath
93710>>>>>        Get vFolderFormat sPath to sPath
93711>>>>>        Move (sPath + psLockFileName(Self)) to sFile
93712>>>>>        Get OpenUserCountFile sFile to hFile
93713>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
93715>>>>>            Send UserError CS_UnableToInitUserCountSys
93716>>>>>            Abort
93717>>>>>>
93717>>>>>        End
93717>>>>>>
93717>>>>>
93717>>>>>        If (hFile > 0) Begin
93719>>>>>            Get piMaxUsers To iMaxUsers
93720>>>>>
93720>>>>>            // Set Filepointer to beginning of the file
93720>>>>>            Get ResetUserCountPointer hFile to dwFilePos
93721>>>>>            If (dwFilePos = -1) Begin
93723>>>>>                Send UserError CS_UnableResetUserCountSys
93724>>>>>                Abort
93725>>>>>>
93725>>>>>            End
93725>>>>>>
93725>>>>>            For iCurUser from 1 to iMaxUsers
93731>>>>>>
93731>>>>>                Get LockUserCountFile hFile dwFilePos to iResult
93732>>>>>                If (Not(iResult)) Begin  // byte is locked
93734>>>>>                    Increment iNumberOfLocks
93735>>>>>                End
93735>>>>>>
93735>>>>>                Else Begin  // byte is not locked
93736>>>>>                    Get UnlockUserCountFile hFile dwFilePos to iResult
93737>>>>>                End
93737>>>>>>
93737>>>>>                Get SetUserCountPointer hFile 10 to dwFilePos
93738>>>>>                If (dwFilePos = -1) Begin
93740>>>>>                    Send UserError CS_ErrorAdvancingPointer
93741>>>>>                    Abort
93742>>>>>>
93742>>>>>                End
93742>>>>>>
93742>>>>>            Loop
93743>>>>>>
93743>>>>>        End
93743>>>>>>
93743>>>>>        Get CloseUserCountFile hFile to iResult
93744>>>>>        Function_Return iNumberOfLocks
93745>>>>>    End_Function
93746>>>>>
93746>>>>>End_Class
93747>>>Use cDbUpdateFunctionLibrary.pkg
93747>>>
93747>>>//{ DataBindable=True }
93747>>>Class cDbUpdateHandler is a cDbUpdateFunctionLibrary
93748>>>
93748>>>    Procedure Construct_Object
93750>>>        tUserCount UserCount
93750>>>        tUserCount UserCount
93750>>>        Integer iUserCount
93750>>>        Handle ho                     
93750>>>
93750>>>        Forward Send Construct_Object
93752>>>        Move Self to ghoDbUpdateHandler  
93753>>>        
93753>>>        // Latin1_General_CI_AS = General Insensitive collation
93753>>>        // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.   
93753>>>        // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
93753>>>        // Good read about which collation to select:
93753>>>        // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
93753>>>        Property String psCollation "Latin1_General_CS_AS" //"SQL_Latin1_General_Cp1_CS_AS"
93754>>>
93754>>>        // Struct array that will contain pnVersionNumbers & object id's of
93754>>>        // all child cDbVersion objects.
93754>>>        Property tDbVersionInfo[] paDbVersionInfoArray
93755>>>
93755>>>        Property Integer Error_Processing_State False  // internal usage
93756>>>        
93756>>>        Property Boolean Private.pbDbVersionCheckDone False
93757>>>
93757>>>        Property Boolean pbUseCustomDbVersion False  
93758>>>        
93758>>>        // If this property = True _and_ no DbVersion table exists 
93758>>>        // when the framework is started, a DbVersion table will be created automatically.
93758>>>        Property Boolean pbAutoCreateDbVersionTable True
93759>>>
93759>>>        // Connected to the pbAutoCreateDbVersionTable property. If it is true,
93759>>>        // the Filelist.cfg slot number indicated by this property will be used
93759>>>        // if a DbVersion table is to be created. If this value = -1 at runtime
93759>>>        // an Unhandled Exception Error will be genereted and the program halted. So
93759>>>        // this property _must_ be set in the cDbUpdateHandler object if pbAutoCreateDbVersionTable = True,
93759>>>        // to a value that corresponds to a free Filelist.cfg slot number.
93759>>>        Property Integer Private.piDbVersionFileNumber -1
93760>>>        Property Integer Private.piDbVersionFieldNumber 1
93761>>>
93761>>>        Property Handle  piIntFilesFileNumber -1
93762>>>        Property Boolean pbRestoreIntFilesNow False   
93763>>>        // In parallell with the above property, the pbSaveIntFilesNow can be set. That same property
93763>>>        // also needs to be created in the ghoApplication object.
93763>>>        Property Boolean pbSaveIntFilesNow False
93764>>>        Property Boolean pbUseIntFilesBackup False   
93765>>>        Property Boolean Private.pbIntFilesTablesCheckDone False
93766>>>        
93766>>>        // This is a message of the cDbUpdateFunctionLibrary_Mixin class
93766>>>        // that creates all library properties
93766>>>        Send CreateDbUpdateLibraryProperties
93767>>>
93767>>>        Property tDbUpdateHandlerMasterAlias[] paDbUpdateHandlerMasterAlias
93768>>>
93768>>>        // Error handling:
93768>>>        Property Boolean Private.pbOnCreateExecuted False
93769>>>        Property Boolean Private.pbOnPreUpdateExecuted False
93770>>>        Property Boolean Private.pbProcessingError False
93771>>>        Property Boolean pbDbUpdateErrorHasOccured False
93772>>>        // Don't touch. It is being used by the cDbUpdateVersion
93772>>>        // subclass to tell if that particular update was a success or not.
93772>>>        Property Boolean Private.pbUpdateVersionObjectError False
93773>>>        Property String[] paSQLQueryMessages
93774>>>        
93774>>>        Property Boolean pbExitIfDebuggerActive True
93775>>>        Property Integer piOrgErrorHandlerID Error_Object_Id
93776>>>        Move Self to Error_Object_Id
93777>>>        // Error handling:
93777>>>        // Temporarily redirect all errors to this object so we can silently
93777>>>        // log all errors that might appear while updating the database.
93777>>>        // We temporarily redirect all errors to this object so we can
93777>>>        // log and write errors to the log file. It will be reset after
93777>>>        // the database updates have been finished.
93777>>>        Property Integer piCurrentErrorHandlerID Error_Object_Id
93778>>>
93778>>>        Property Handle phoLogFile (Create(Self,RefClass(cDbUpdateLogFile)))
93779>>>
93779>>>        // Error Reporting Related
93779>>>        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
93779>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
93780>>>
93780>>>        // If the pbContinueOnError = False, an update
93780>>>        // of another cDbUpdateVersion object will _not_ be
93780>>>        // performed if an error occured in a previous
93780>>>        // cDbUpdateVersion object.
93780>>>        Property Boolean pbContinueOnError False
93781>>>        // Stops execution in other cDbUpdateVersion objecs,
93781>>>        // if errors occurred in one cDbUpdateVersion object.
93781>>>        Property Boolean pbStopOnFirstError False
93782>>>        // If True errors that occured while updating the database
93782>>>        // will be shown in the default app for .txt files when done.
93782>>>        // Note: The log file will _always_ be created in the Data folder.
93782>>>        Property Boolean pbShowErrorLogPostRun True
93783>>>
93783>>>        // Be _very_ careful to set this property to true!
93783>>>        // If = True, no question will be asked if the update
93783>>>        // should begin. Also, even if the pbShowErrorLogPostRun=True,
93783>>>        // the error log won't be shown. The logfile itself will still be created though.
93783>>>        // You have to know what you're doing!
93783>>>        Property Boolean pbSilentMode False
93784>>>        
93784>>>        Property Boolean pbEnableCancelButton False
93785>>>
93785>>>        // Don't touch! Very private. The value is used by the error log to write for which
93785>>>        // cDbUpdateVersion object an error occured.
93785>>>        Property Number pnCurrentVersionUpdate 0
93786>>>
93786>>>        // The user counting logic is used to safe-guard agains anybody else is
93786>>>        // using the application when a database update is to be performed.
93786>>>        // (Garters & suspenders!)
93786>>>        Property Handle phoUserCountSystem (Create(Self,RefClass(cDbUpdateUserCount)))
93787>>>        Set psLockFileName of (phoUserCountSystem(Self)) to "DbUpdateUserCount.ucf"
93788>>>        Set piMaxUsers     of (phoUserCountSystem(Self)) to (CI_UserCountMaxUsers -1) // Large number!
93789>>>
93789>>>        // This lock file is used to guard against somebody else tries to start the
93789>>>        // application while updates are in progress.
93789>>>        Property Handle phoDatabaseUpdateLock (Create(Self,RefClass(cDbUpdateUserCount)))
93790>>>        Set psLockFileName of (phoDatabaseUpdateLock(Self)) to "DbUpdateLock.ucf"
93791>>>        Set piMaxUsers     of (phoDatabaseUpdateLock(Self)) to 1
93792>>>                                                                                      // Only the current user allowed.
93792>>>        // Properties for the table & column of a system file field/column where
93792>>>        // the database version update number gets saved.
93792>>>        Property Integer Private.Data_File  0
93793>>>        Property Integer Private.Data_Field 0
93794>>>
93794>>>        // Property that is used to indicate that we have already
93794>>>        // started the database update.
93794>>>        Property Boolean Private.pbDatabaseUpdateStarted False
93795>>>
93795>>>        // Don't touch! It is used by the child class cDbUpdateVersion logic to indicate that
93795>>>        // at least one OnUpdate child event has been triggered. Thus at least one active
93795>>>        // change of the database has been made.
93795>>>        Property Boolean Private.pbDatabaseWasUpdated False
93796>>>
93796>>>        // We need to trigger the user counting system so that a bit in the
93796>>>        // user counting file is locked. This is to guard that not more than one user
93796>>>        // is currently runnning the program.
93796>>>        Get CheckUserCount of (phoUserCountSystem(Self)) to UserCount
93797>>>
93797>>>        Get CurrentNumberOfUsers of (phoDatabaseUpdateLock(Self)) to iUserCount
93798>>>        If (iUserCount > 0) Begin
93800>>>            Send Stop_Box CS_DUF_UpdateInProgressTxt
93801>>>            Send Exit_Application
93802>>>        End
93802>>>>
93802>>>
93802>>>        Set pbHandleQueryErrors to False
93803>>>            
93803>>>        Property Handle phoSQLConnectionHandler 0
93804>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
93804>>>        // we will create one as it is used for all ConnectionID, ConnectionString
93804>>>        // etc information.
93804>>>        If (ghoSQLConnectionHandler = 0) Begin
93806>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
93807>>>            Set phoSQLConnectionHandler to ho
93808>>>        End             
93808>>>>
93808>>>        
93808>>>        Set Icon to "Default.ico"
93809>>>    End_Procedure
93810>>>
93810>>>    Procedure End_Construct_Object
93812>>>        Forward Send End_Construct_Object
93814>>>        If (Private.pbOnCreateExecuted(Self) = False) Begin  
93816>>>            Send OnCreate
93817>>>            Set Private.pbOnCreateExecuted to True
93818>>>        End
93818>>>>
93818>>>        Send Cleanup
93819>>>    End_Procedure
93820>>>    
93820>>>    // Programmers hook event!
93820>>>    Procedure OnCreate
93822>>>    End_Procedure        
93823>>>                                 
93823>>>    // Note: If you get a compile Error 4295: "xxx Can't include resource FILELISTBACKUPFILE.CFG",
93823>>>    //       you will need to manually make a copy of the Filelist.cfg in the Data folder -> "FilelistBackupFile.cfg"
93823>>>    Include_Resource FilelistBackupFile.cfg as res_EmbeddedFilelistCfg type DF_RESOURCE_TYPE_BINARY
93823>>>    // *** MAIN .Int file (and Filelist.cfg) Integrity Check Message ***
93823>>>    //                                                
93823>>>    // The logic is activated by setting the property "pbUseIntFilesBackup = True" in the
93823>>>    // cDbUpdateHandler object.
93823>>>    //
93823>>>    // Checks that all .int files are intact, or else writes new copies to disk. 
93823>>>    // Also checks that there is a Filelist.cfg, and if missing writes a new copy to disk.
93823>>>    //
93823>>>    // If not done previously the piIntFilesFileNumber will be created and filled with data
93823>>>    // from the current set of .int files - iif (if-and-only-if) this is a development
93823>>>    // machine. Which is decided by checking if the DdSrc folder exists. And a copy
93823>>>    // of Filelist.cfg is made for backup purposes.
93823>>>    //
93823>>>    // Note: If an error occurrs the application will exit, as it means that at least one
93823>>>    // .int file is in error or the Filelist.cfg was missing and couldn't be recreated.
93823>>>
93823>>>    // Note: Include_Resource is a compiler directive!
93823>>>    // It will embedd the Filelist.cfg from the developers machine
93823>>>    // into the executable.        
93823>>>    //
93823>>>    // There is a pickle with the Filelist.cfg as it is "busy" as it is open in the Studio,
93823>>>    // when we get here and then the compiler can't embedd it!        
93823>>>    // NOTE: This relies on the "WriteDateTimeHeaderFile" program and that each Project has
93823>>>    //       been setup to run it as the "Before Compilation Process:" (See: Project - Project Properties - Compiler tab-page)
93823>>>    Function SaveUpdateIntFiles String ByRef sErrorText Returns Boolean
93825>>>        Boolean bCheckIntFiles bExists bOK bSaved bIsSQL bFileListExist bResult bDevelop bZipExists bIntFilesTablesCheckDone bNewer bIsIntFileTable  bIsAlias
93825>>>        String sPaths sDataPath sIntFileName sRootName sFileListName sFileListNameBackup sDDSrcPath sCurrentFolder
93825>>>        String sFileListZipFile sParam sProgram sFile 
93825>>>        Integer iDataPaths iCount iSize
93825>>>        Handle hTable hIntFilesTable                    
93825>>>        UChar[] asFileListArray 
93826>>>        String[] asSavedIntFile
93827>>>        tDUFIntFile[] DUFIntFiles
93827>>>        tDUFIntFile[] DUFIntFiles
93828>>>
93828>>>        // This will automatically create the piIntFilesFileNumber if not exists.
93828>>>        // It is used to save data from the current set of .int files.
93828>>>        // We do this on both developer & client machines.
93828>>>        Get IsIntFileTable to bIsIntFileTable
93829>>>        If (bIsIntFileTable = False) Begin
93831>>>            Send AutoCreateIntFilesTable
93832>>>            Get Private.pbIntFilesTablesCheckDone to bOK
93833>>>            If (bOK = False) Begin
93835>>>                Function_Return False
93836>>>            End
93836>>>>
93836>>>        End                                                       
93836>>>>
93836>>>        
93836>>>        Get _UtilNumberOfFileListTables to iSize
93837>>>        Send StartStatusPanel "" "" iSize
93838>>>        Set Progress_Bar_Overall_Visible_State of ghoStatusPanel to False
93839>>>
93839>>>        // Check Filelist.cfg & backup file
93839>>>        Get psFileList of (phoWorkspace(ghoApplication)) to sFileListName
93840>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath 
93841>>>        Move (sDataPath + "\" + CS_FilelistBackupFile)   to sFileListNameBackup
93842>>>        Get IsFileTimeNewer sFileListName sFileListNameBackup to bNewer
93843>>>
93843>>>        Move (IsDebuggerPresent()) to bDevelop
93844>>>        // Is this a client machine?
93844>>>        If (bDevelop = False) Begin
93846>>>            If (bNewer = True) Begin
93848>>>                // Create filelist.cfg from resource backup file.
93848>>>                Get ReadFileListResource "res_EmbeddedFilelistCfg" to asFileListArray
93849>>>                Get WriteFileListResource asFileListArray sFileListName to bOK  
93850>>>            End
93850>>>>
93850>>>        End
93850>>>>
93850>>>
93850>>>        Else If (bDevelop = True) Begin
93853>>>            Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
93854>>>            If (bNewer = True) Begin
93856>>>                Get vDeleteFile sFileListNameBackup to bOK
93857>>>                Get vCopyFile sFileListName sFileListNameBackup to bOK
93858>>>                Move "A new backup copy of the Filelist.cfg file was made. In order to include a backup copy of the file into the program, as a resource, you will need to re-compile/restart the program." to sErrorText
93859>>>            End
93859>>>>
93859>>>        End
93859>>>>
93859>>>        
93859>>>        Move True to bResult 
93860>>>
93860>>>        Get piIntFilesFileNumber to hIntFilesTable
93861>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
93862>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths
93863>>>
93863>>>        For iCount from 1 to iDataPaths
93869>>>>
93869>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
93870>>>            Get vFolderFormat sDataPath to sDataPath 
93871>>>            Get vFolderExists sDataPath to bExists
93872>>>            If (bExists = True) Begin                  
93874>>>                Move 0 to hTable
93875>>>                Repeat
93875>>>>
93875>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
93878>>>                    If (hTable <> 0 and hTable <> 50) Begin
93880>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
93883>>>                        Set Message_Text of ghoStatusPanel to ("Saving/updating IntFilesTable:" * String(sIntFileName))
93884>>>                        Send DoAdvance of ghoProgressBar
93885>>>                        Get _UtilTableIsSqlByRootName sIntFileName to bIsSQL
93886>>>                        Get UtilTableIsAlias hTable to bIsAlias 
93887>>>                        If (bIsSQL = True and bIsAlias = False) Begin
93889>>>                            If (bIsSQL = True) Begin     
93891>>>                                Get _TableNameOnly sIntFileName to sIntFileName
93892>>>                                Move (sIntFileName + ".int")    to sIntFileName
93893>>>                                Get IsIntFileSaved sIntFileName to bSaved  
93894>>>                                Move True to bOK            
93895>>>                                
93895>>>                                // Save .int file to database if not done previously (both on development- and customer-machines).
93895>>>                                If (bSaved = False) Begin
93897>>>                                    Get SaveIntFileData sDataPath sIntFileName to bOK
93898>>>                                    If (bOK = False) Begin
93900>>>                                        Move ("The 'SaveIntFileData' function for the internal database table:" * String(sIntFileName) * "failed.") to sErrorText
93901>>>                                        Error DFERR_PROGRAM sErrorText
93902>>>>
93902>>>                                        Move False to bResult    
93903>>>                                    End
93903>>>>
93903>>>                                End         
93903>>>>
93903>>>                                Else Begin
93904>>>                                    Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
93905>>>                                    If (SizeOfArray(asSavedIntFile) <> 0) Begin
93907>>>                                        Get UpdateIntFileData sDataPath sIntFileName asSavedIntFile to bOK
93908>>>                                        If (bOK = False) Begin
93910>>>                                            Move False to bResult
93911>>>                                            Move ("Could not update .int file data to the internal database table:" * String(sIntFileName)) to sErrorText
93912>>>                                            Error DFERR_PROGRAM sErrorText
93913>>>>
93913>>>                                        End
93913>>>>
93913>>>                                    End
93913>>>>
93913>>>                                End
93913>>>>
93913>>>                            End
93913>>>>
93913>>>                        End
93913>>>>
93913>>>                    End
93913>>>>
93913>>>                Until (hTable = 0)
93915>>>            End
93915>>>>
93915>>>        Loop       
93916>>>>
93916>>>        
93916>>>        Send StopStatusPanel
93917>>>        // If an error occured we need to exit the application as we cannot start with an uncomplete set of .int files.
93917>>>        If (bResult = False) Begin  
93919>>>            Function_Return False
93920>>>        End 
93920>>>>
93920>>>        Send LogError ("The *.int file backup table was updated:" * String(CS_IntFilesTableLogicalName)) False
93921>>>        Function_Return True
93922>>>    End_Function
93923>>>
93923>>>    // It checks that *.int files on disk corresponds with the content in the
93923>>>    // .int file backup table piIntFilesFileNumber.
93923>>>    Function RestoreIntFiles String ByRef sErrorText Returns Boolean
93925>>>        Boolean bCheckIntFiles bIsIntFileTable bExists bIsSQL bRestored bOK
93925>>>        String sPaths sDataPath sIntFileName 
93925>>>        String[] asSavedIntFile
93926>>>        Integer iDataPaths iCount iRetval iSize
93926>>>        Handle hTable hIntFilesTable
93926>>>
93926>>>        Get IsIntFileTable to bIsIntFileTable
93927>>>        If (bIsIntFileTable = False) Begin
93929>>>            Send Info_Box "The 'IntFilesTable' has not been created. Thus no backup info for .int files exists. The property pbUseIntFilesBackup must have been set to True in the cDbUpdateHandler object for automatic creation of the table and save of all .int files."
93930>>>            Function_Return False
93931>>>        End
93931>>>>
93931>>>        
93931>>>        Get YesNo_Box "This will restore the content of all .int files. Current .int files will be compared to the content in the backup table. If different, files on disk will be updated. Cash files (.cch) will be removed and a backup Filelist.cfg will be installed.\n\n Continue?" to iRetval
93932>>>        If (iRetval <> MBR_Yes) Begin
93934>>>            Function_Return False
93935>>>        End
93935>>>>
93935>>>        
93935>>>        Get _UtilNumberOfFileListTables to iSize
93936>>>        Send StartStatusPanel "" "" iSize
93937>>>        Set Progress_Bar_Overall_Visible_State of ghoStatusPanel to False
93938>>>
93938>>>        Move False to bRestored
93939>>>        Get piIntFilesFileNumber to hIntFilesTable
93940>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
93941>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths
93942>>>
93942>>>        For iCount from 1 to iDataPaths
93948>>>>
93948>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
93949>>>            Get vFolderFormat sDataPath to sDataPath 
93950>>>            Get vFolderExists sDataPath to bExists
93951>>>            If (bExists = True) Begin                  
93953>>>                Move 0 to hTable
93954>>>                Repeat
93954>>>>
93954>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable    
93957>>>                    If (hTable <> 0) Begin
93959>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
93962>>>                        Set Message_Text of ghoStatusPanel to ("Checking info for." * String(sIntFileName))
93963>>>                        Send DoAdvance of ghoProgressBar
93964>>>                        Get _UtilTableIsSqlByRootName sIntFileName to bIsSQL
93965>>>                        If (bIsSQL = True) Begin     
93967>>>                            Get _TableNameOnly sIntFileName to sIntFileName
93968>>>                            Move (sIntFileName + ".int")    to sIntFileName
93969>>>                            Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
93970>>>                            If (SizeOfArray(asSavedIntFile) <> 0) Begin
93972>>>                                Set Message_Text of ghoStatusPanel to ("Restoring .int file:" * String(sIntFileName))
93973>>>                                Get CreateIntFileFromSavedData sIntFileName sDataPath to bOK
93974>>>                                If (bRestored = False and bOK = True) Begin
93976>>>                                    Move True to bRestored
93977>>>                                End
93977>>>>
93977>>>                                If (bOK = False) Begin 
93979>>>                                    Move ("Could not create the .int file" * String(sIntFileName) * "from the internal database table:" * String(CS_IntFilesTableLogicalName)) to sErrorText
93980>>>                                    Error DFERR_PROGRAM sErrorText
93981>>>>
93981>>>                                End
93981>>>>
93981>>>                            End
93981>>>>
93981>>>                        End
93981>>>>
93981>>>                    End
93981>>>>
93981>>>                Until (hTable = 0)
93983>>>            End
93983>>>>
93983>>>        Loop       
93984>>>>
93984>>>        
93984>>>        Send StopStatusPanel
93985>>>        Function_Return bRestored
93986>>>    End_Function
93987>>>
93987>>>    Function IsIntFileTable Returns Boolean
93989>>>        Boolean bExists
93989>>>        Handle hTable
93989>>>        String sLogicalName
93989>>>        Move False to bExists
93990>>>        Get piIntFilesFileNumber to hTable
93991>>>        If (hTable > 0) Begin
93993>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
93996>>>            Move (sLogicalName = CS_IntFilesTableLogicalName) to bExists
93997>>>        End
93997>>>>
93997>>>        Function_Return bExists    
93998>>>    End_Function
93999>>>    
93999>>>    // To update currently saved IntFile data to the database.
93999>>>    // Because it is much easier, we first delete all current records and
93999>>>    // then saves the changed .int file to the database.
93999>>>    Function UpdateIntFileData String sDataPath String sIntFileName String[] asSavedIntFile Returns Boolean
94001>>>        Boolean bOK
94001>>>        Move False to bOK
94002>>>        Move (Lowercase(sIntFileName)) to sIntFileName
94003>>>        Get DeleteIntFileData sDataPath sIntFileName to bOK
94004>>>        If (bOK = True) Begin
94006>>>            Get SaveIntFileData sDataPath sIntFileName to bOK
94007>>>        End
94007>>>>
94007>>>        Function_Return bOK
94008>>>    End_Function
94009>>>    
94009>>>    // Note: We use vFind here as the IntFileName may not yet have been created,
94009>>>    //       and thus we cannot compile.
94009>>>    Function IsIntFileSaved String sIntFileName Returns Boolean
94011>>>        Handle hTable
94011>>>        Boolean bOK
94011>>>        Integer iColumn iIndex   
94011>>>        String sFileName
94011>>>        
94011>>>        Move (Lowercase(sIntFileName)) to sIntFileName
94012>>>        Move False to bOK  
94013>>>        Get piIntFilesFileNumber to hTable
94014>>>        Move 2              to iColumn // This is the "InfFileName" field no.
94015>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
94016>>>
94016>>>        Open hTable
94018>>>        Set_Field_Value hTable iColumn to sIntFileName
94021>>>        Vfind hTable iIndex GE
94023>>>        Get_Field_Value hTable iColumn to sFileName
94026>>>        If (Trim(sIntFileName) = Trim(sFileName)) Begin
94028>>>            Move True to bOK    
94029>>>        End
94029>>>>
94029>>>        Close hTable
94030>>>        
94030>>>        Function_Return bOK       
94031>>>    End_Function   
94032>>>    
94032>>>    // Checks that the passed .int file is the same as what is saved in the database.
94032>>>    // If not same, the return string array will contain the read .int file,
94032>>>    // else the returned array will be empty.
94032>>>    Function HasIntFileChanged String sDataPath String sIntFileName Returns String[]
94034>>>        String[] asIntFileOrg asIntFile asSavedIntFile asReturnIntFile
94038>>>        Boolean bIsSame
94038>>>        
94038>>>        Move (Lowercase(sIntFileName)) to sIntFileName
94039>>>        Get ReadIntFile sDataPath sIntFileName to asIntFileOrg   
94040>>>        Get RetrieveIntFileData sDataPath sIntFileName to asSavedIntFile
94041>>>        Get RemoveBlankLines asIntFileOrg   to asIntFile
94042>>>        Get RemoveBlankLines asSavedIntFile to asSavedIntFile
94043>>>        
94043>>>        Move (IsSameArray(asIntFile, asSavedIntFile)) to bIsSame
94044>>>        If (bIsSame = False) Begin
94046>>>            Move asIntFileOrg to asReturnIntFile    
94047>>>        End
94047>>>>
94047>>>        
94047>>>        Function_Return asReturnIntFile    
94048>>>    End_Function                                   
94049>>>    
94049>>>    Function SaveIntFileData String sPath String sIntFileName Returns Boolean
94051>>>        Handle hTable
94051>>>        Boolean bOK bErr
94051>>>        Integer iIDCol iFileCol iTextCol iIndex iIDIdx iSize iCount 
94051>>>        Number iID
94051>>>        String sFileName
94051>>>        String[] asIntFile
94052>>>        
94052>>>        // Note: We will lowercase all .int file names, to not get into having duplicates in the database
94052>>>        Move (Lowercase(sIntFileName)) to sIntFileName
94053>>>        
94053>>>        Move Err to bErr
94054>>>        Move False to Err
94055>>>        Move False to bOK
94056>>>        Get piIntFilesFileNumber to hTable  
94057>>>        Move 1              to iIDCol
94058>>>        Move 2              to iFileCol
94059>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
94060>>>        Move 1              to iIDIdx   // Main ID index.
94061>>>        Move 2              to iIndex   // This is the IntFileName + ID index.
94062>>>
94062>>>        Get ReadIntFile sPath sIntFileName to asIntFile
94063>>>        Move (SizeOfArray(asIntFile)) to iSize
94064>>>        If (iSize = 0) Begin
94066>>>            Function_Return False
94067>>>        End
94067>>>>
94067>>>        Decrement iSize
94068>>>        Open hTable  
94070>>>                  
94070>>>        // Find the last used ID no:
94070>>>        Fill_Field hTable iIDCol with DF_HIGH
94072>>>        Vfind hTable iIDIdx LE
94074>>>        Get_Field_Value hTable iIDCol to iID 
94077>>>        // This only happens the very first time we save a record.
94077>>>        If (iID = 999999999999) Begin
94079>>>            Move 0 to iID
94080>>>        End
94080>>>>
94080>>>        Increment iID
94081>>>        
94081>>>        Lock
94082>>>>
94082>>>            For iCount from 0 to iSize
94088>>>>
94088>>>                Clear hTable
94089>>>                Set_Field_Value hTable iIDCol   to iID     
94092>>>                Set_Field_Value hTable iFileCol to sIntFileName
94095>>>                Set_Field_Value hTable iTextCol to asIntFile[iCount]
94098>>>                SaveRecord hTable
94099>>>                Increment iID
94100>>>            Loop
94101>>>>
94101>>>        Unlock
94102>>>>
94102>>>        Close hTable
94103>>>        
94103>>>        Move (not(Err)) to bOK
94104>>>        Move bErr to Err
94105>>>        
94105>>>        Function_Return bOK
94106>>>    End_Function
94107>>>    
94107>>>    // Deletes all records for the passed sIntFileName value,
94107>>>    // from the piIntFilesFileNumber.
94107>>>    // Returns True if no errors occured.
94107>>>    Function DeleteIntFileData String sPath String sIntFileName Returns Boolean
94109>>>        Handle hTable
94109>>>        Boolean bOK bErr bFound
94109>>>        Integer iFileCol iIndex
94109>>>        String sVal
94109>>>        String[] asIntFile
94110>>>        
94110>>>        Move (Trim(Lowercase(sIntFileName))) to sIntFileName
94111>>>        Move Err to bErr
94112>>>        Move False to Err
94113>>>        Move False to bOK
94114>>>        Move 2              to iFileCol
94115>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
94116>>>        Get piIntFilesFileNumber to hTable  
94117>>>        Open hTable  
94119>>>                  
94119>>>        // Find the first record
94119>>>        Set_Field_Value hTable iFileCol to sIntFileName
94122>>>        Vfind hTable iIndex GE
94124>>>        Get_Field_Value hTable iFileCol to sVal
94127>>>        Move (Trim(Lowercase(sVal))) to sVal
94128>>>        Move (Found and sVal = sIntFileName) to bFound
94129>>>        While (bFound = True)
94133>>>            Delete hTable
94134>>>            Vfind hTable iIndex GT
94136>>>            Get_Field_Value hTable iFileCol to sVal
94139>>>            Move (Trim(Lowercase(sVal))) to sVal
94140>>>            Move (Found and sVal = sIntFileName) to bFound
94141>>>        Loop
94142>>>>
94142>>>        Unlock
94143>>>>
94143>>>        Close hTable
94144>>>        
94144>>>        Move (not(Err)) to bOK
94145>>>        Move bErr to Err
94146>>>        
94146>>>        Function_Return bOK
94147>>>    End_Function
94148>>>
94148>>>    // Returns all saved piIntFilesFileNumber records for the passed 
94148>>>    // sIntFileName value as a string array.
94148>>>    Function RetrieveIntFileData String sPath String sIntFileName Returns String[]
94150>>>        Handle hTable
94150>>>        Boolean bOK bErr bFound
94150>>>        Integer iFileCol iTextCol iIndex
94150>>>        String sVal sFileName
94150>>>        String[] asIntFile asEmptyArray
94152>>>        
94152>>>        Move (Trim(Lowercase(sIntFileName))) to sIntFileName
94153>>>        Move Err to bErr
94154>>>        Move False to Err
94155>>>        Move False to bOK
94156>>>        Move 2              to iFileCol
94157>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
94158>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
94159>>>        Get piIntFilesFileNumber to hTable  
94160>>>        Open hTable  
94162>>>        
94162>>>        // Find the first record
94162>>>        Set_Field_Value hTable iFileCol to sIntFileName
94165>>>        Vfind hTable iIndex GE
94167>>>        Get_Field_Value hTable iFileCol to sFileName
94170>>>        Move (Trim(Lowercase(sFileName))) to sFileName
94171>>>        Move (Found and sFileName = sIntFileName) to bFound
94172>>>        While (bFound = True)
94176>>>            Get_Field_Value hTable iFileCol   to sFileName
94179>>>            Move (Trim(Lowercase(sFileName))) to sFileName
94180>>>            Move (Found and sFileName = sIntFileName) to bFound
94181>>>            If (bFound = True) Begin
94183>>>                Get_Field_Value hTable iTextCol to sVal
94186>>>                Move (Trim(sVal)) to asIntFile[SizeOfArray(asIntFile)]
94187>>>            End
94187>>>>
94187>>>            Vfind hTable iIndex GT
94189>>>        Loop
94190>>>>
94190>>>        
94190>>>        Close hTable
94191>>>        Move (not(Err)) to bOK
94192>>>        If (bOK = False) Begin
94194>>>            Move asEmptyArray to asIntFile
94195>>>        End
94195>>>>
94195>>>        Move bErr to Err               
94196>>>        
94196>>>        Function_Return asIntFile
94197>>>    End_Function
94198>>>
94198>>>    // Reads the passed sIntFileName from disk and returns its value
94198>>>    // as a string array.
94198>>>    Function ReadIntFile String sPath String sIntFileName Returns String[]
94200>>>        String[] asIntFile       
94201>>>        String sFileName sLine
94201>>>        Integer iCh iSize iCount
94201>>>        
94201>>>        Move (Lowercase(sIntFileName)) to sIntFileName
94202>>>        Get vFolderFormat sPath to sPath
94203>>>        If (not(sIntFileName contains ".")) Begin
94205>>>            Move (sIntFileName + ".int") to sIntFileName
94206>>>        End
94206>>>>
94206>>>        Move (sPath + sIntFileName) to sFileName
94207>>>        Get Seq_Open_input_Channel sFileName to iCh
94208>>>        If (iCh < 0) Begin
94210>>>            Function_Return asIntFile
94211>>>        End                                 
94211>>>>
94211>>>        
94211>>>        Repeat
94211>>>>
94211>>>            Readln channel iCh sLine
94213>>>            If (SeqEof = False) Begin
94215>>>                Move (Trim(sLine)) to asIntFile[SizeOfArray(asIntFile)]
94216>>>            End
94216>>>>
94216>>>        Until (SeqEof = True)
94218>>>        Send Seq_Close_Channel iCh    
94219>>>        
94219>>>        Function_Return asIntFile
94220>>>    End_Function
94221>>>    
94221>>>    // Reads the Filelist.cfg from memeory as a resource.
94221>>>    // The Filelist.cfg has been compiled into the program.
94221>>>    Function ReadFileListResource String sMemFileName Returns UChar[]
94223>>>        Integer iCh iCount
94223>>>        Number nByteCount
94223>>>        String[] asFileListArray sEmptyArray
94225>>>        String sLine
94225>>>        UChar[] uCharData
94226>>>        
94226>>>        Move False to Err
94227>>>        Get Seq_New_Channel to iCh
94228>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
94230>>>            Error DFERR_PROGRAM 'No channel available...'
94231>>>>
94231>>>            Function_Return sEmptyArray
94232>>>        End
94232>>>>
94232>>>
94232>>>        // First decide the size of the script
94232>>>        Direct_Input channel iCh ("Resource: " + sMemFileName)
94234>>>        Read_Block channel iCh uCharData -1 // -1 means that all data should be read.
94236>>>        Close_Input channel iCh
94238>>>        Send Seq_Release_Channel iCh
94239>>>
94239>>>        Function_Return uCharData
94240>>>    End_Function    
94241>>>    
94241>>>    // Writes a copy of the workspace Filelist.cfg to disk.
94241>>>    // It does so by reading from a memory resource, as the file has
94241>>>    // been compiled into the program.
94241>>>    Function WriteFileListResource UChar[] asFileListArray String sFileListName Returns Boolean
94243>>>        Boolean bOK bErr
94243>>>        Integer iSize iCh
94243>>>        
94243>>>        Move Err to bErr
94244>>>        Move False to Err
94245>>>        Move False to bOK
94246>>>        Move (SizeOfArray(asFileListArray)) to iSize
94247>>>        If (iSize = 0) Begin
94249>>>            Function_Return False
94250>>>        End
94250>>>>
94250>>>
94250>>>        Get Seq_New_Channel to iCh
94251>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
94253>>>            Error DFERR_PROGRAM 'No channel available...'
94254>>>>
94254>>>            Function_Return False
94255>>>        End                      
94255>>>>
94255>>>        
94255>>>        Direct_Output channel iCh sFileListName
94257>>>        Writeln channel iCh asFileListArray
94260>>>                
94260>>>        Close_Input channel iCh
94262>>>        Send Seq_Release_Channel iCh
94263>>>        Move (not(Err)) to bOK
94264>>>        Move bErr to Err
94265>>>        
94265>>>        Function_Return bOK
94266>>>    End_Function
94267>>>
94267>>>    // Writes an .int for the passed sIntFileName file to disk by reading data from the piIntFilesFileNumber data table.
94267>>>    // It first deletes the .cch file (if any).
94267>>>    Function CreateIntFileFromSavedData String sIntFileName String sDataPath Returns Boolean
94269>>>        Boolean bOK bFound bExists bErr
94269>>>        Integer iCh iSize iCount
94269>>>        String sFileName sCCHFileName sVal
94269>>>        String[] asIntFile
94270>>>        
94270>>>        Move (Lowercase(sIntFileName)) to sIntFileName
94271>>>        Move Err to bErr   
94272>>>        Move False to Err
94273>>>        Move False to bOK
94274>>>
94274>>>        Get RetrieveIntFileData sDataPath sIntFileName to asIntFile
94275>>>        Move (SizeOfArray(asIntFile)) to iSize
94276>>>        If (iSize = 0) Begin
94278>>>            Function_Return False        
94279>>>        End                      
94279>>>>
94279>>>        Decrement iSize
94280>>>        
94280>>>        Get Seq_New_Channel to iCh
94281>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
94283>>>            Function_Return False
94284>>>        End   
94284>>>>
94284>>>        
94284>>>        // Before we start to actually create the new .int file, make sure we delete
94284>>>        // the .cch file.                                     
94284>>>        Move (Uppercase(sIntFileName)) to sCCHFileName
94285>>>        Move (Replace(".INT", sCCHFileName, ".CCH")) to sCCHFileName
94286>>>        Get vFilePathExists (sDataPath + sCCHFileName) to bExists
94287>>>        If (bExists = True) Begin
94289>>>            Get vDeleteFile (sDataPath + sCCHFileName) to bOK
94290>>>            If (bOK = False) Begin
94292>>>                Function_Return False
94293>>>            End
94293>>>>
94293>>>        End
94293>>>>
94293>>>        
94293>>>        Direct_Output channel iCh (sDataPath + sIntFileName)
94295>>>        For iCount from 0 to iSize
94301>>>>
94301>>>            Writeln channel iCh asIntFile[iCount]
94304>>>        Loop
94305>>>>
94305>>>        
94305>>>        Close_Input channel iCh
94307>>>        Send Seq_Release_Channel iCh
94308>>>        Move (not(Err)) to bOK
94309>>>        Move bErr to Err
94310>>>        
94310>>>        Function_Return bOK
94311>>>    End_Function   
94312>>>              
94312>>>    // Automatically writes .int files to disk that is missing.
94312>>>    // We only need to make this test this once, but because the message is called
94312>>>    // from each child cDbUpdateVersion object (and it needs to be called from there),
94312>>>    // we use property Private.pbIntFilesTablesCheckDone to ensure it is only run once.
94312>>>    Procedure AutoCreateIntFilesTable
94314>>>        Integer hTable 
94314>>>        Boolean bIntFilesTablesCheckDone bTableExists bOK
94314>>>        String sInfoTxt 
94314>>>        
94314>>>        Get piIntFilesFileNumber to hTable  
94315>>>        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
94316>>>        If (bIntFilesTablesCheckDone = True) Begin
94318>>>            Procedure_Return
94319>>>        End
94319>>>>
94319>>>
94319>>>        If (hTable < 1) Begin
94321>>>            Set Private.pbIntFilesTablesCheckDone to False
94322>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94323>>>            Error DFERR_PROGRAM "The piIntFilesFileNumber has been set! The property MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object.\nProgram will now exit!"
94324>>>>
94324>>>            Send Exit_Application
94325>>>        End
94325>>>>
94325>>>        
94325>>>        Get IsIntFileTable hTable to bTableExists
94326>>>        If (bTableExists = True) Begin
94328>>>            Set Private.pbIntFilesTablesCheckDone to True
94329>>>            Procedure_Return
94330>>>        End
94330>>>>
94330>>>
94330>>>        Send SubCreateIntFilesTable hTable
94331>>>    End_Procedure
94332>>>                
94332>>>    Procedure SubCreateIntFilesTable Handle hTable
94334>>>        String sTableName sColumnName sInfoTxt sDriverID sDataPath
94334>>>        Boolean bTableExists bOK bUseConnectionID bExists
94334>>>        tAPIColumn[] APIColumn
94334>>>        tAPIColumn[] APIColumn
94335>>>
94335>>>        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
94336>>>        If (bTableExists = True) Begin
94338>>>            Procedure_Return
94339>>>        End
94339>>>>
94339>>>
94339>>>        Move False to Err
94340>>>        Get psDriverID to sDriverID
94341>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
94342>>>
94342>>>        Move CS_IntFilesTableLogicalName to sTableName
94343>>>
94343>>>        Move 1                  to APIColumn[0].iFieldNumber
94344>>>        Move "ID"               to APIColumn[0].sFieldName
94345>>>        Move DF_BCD             to APIColumn[0].iType
94346>>>        Move False              to APIColumn[0].bIsSQLType
94347>>>        Move 12                 to APIColumn[0].iLength
94348>>>        Move 0                  to APIColumn[0].iPrecision
94349>>>
94349>>>        Move 2                  to APIColumn[1].iFieldNumber
94350>>>        Move "IntFileName"      to APIColumn[1].sFieldName
94351>>>        Move DF_ASCII           to APIColumn[1].iType
94352>>>        Move False              to APIColumn[1].bIsSQLType
94353>>>        Move 50                 to APIColumn[1].iLength
94354>>>        Move 0                  to APIColumn[1].iPrecision
94355>>>
94355>>>        Move 3                  to APIColumn[2].iFieldNumber
94356>>>        Move "IntLineText"      to APIColumn[2].sFieldName
94357>>>        Move DF_ASCII           to APIColumn[2].iType
94358>>>        Move False              to APIColumn[2].bIsSQLType
94359>>>        Move 100                to APIColumn[2].iLength
94360>>>        Move 0                  to APIColumn[2].iPrecision
94361>>>
94361>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
94362>>>        
94362>>>        If (bOK = True) Begin
94364>>>//        If (bOK = True and Err = False) Begin
94364>>>            Move ("Int Files Table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
94365>>>        End
94365>>>>
94365>>>        Else Begin
94366>>>            Set Private.pbIntFilesTablesCheckDone to False
94367>>>            Move ("ERROR" * "Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
94368>>>            Error DFERR_PROGRAM sInfoTxt
94369>>>>
94369>>>            Procedure_Return
94370>>>        End
94370>>>>
94370>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
94371>>>        
94371>>>        Open hTable
94373>>>        Get ApiIndexCreate hTable 1 1 1   to bOK     // Index 1 = ID
94374>>>        If (bOK = True) Begin
94376>>>            Get ApiIndexCreate hTable 2 2 2 1 to bOK // Index 2 = InteFileName, ID.
94377>>>        End
94377>>>>
94377>>>        If (bOK = False) Begin
94379>>>            Set Private.pbIntFilesTablesCheckDone to False
94380>>>            Move ("ERROR" * "Indexes for Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
94381>>>            Error DFERR_PROGRAM sInfoTxt
94382>>>>
94382>>>            Procedure_Return
94383>>>        End
94383>>>>
94383>>>        
94383>>>        // Check if the new .int file was created. If so and a .dat file exists - delete it.
94383>>>        If (sDriverID <> DATAFLEX_ID) Begin
94385>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
94386>>>            Get vFolderFormat sDataPath to sDataPath
94387>>>            Move (CS_IntFilesTableLogicalName + ".int") to sTableName
94388>>>            Get vFilePathExists (sDataPath + sTableName) to bExists
94389>>>            If (bExists = True) Begin
94391>>>                Move CS_IntFilesTableLogicalName to sTableName
94392>>>                Get vFilePathExists (sDataPath + sTableName + ".dat") to bExists
94393>>>                If (bExists = True) Begin
94395>>>                    Get vDeleteFile (sDataPath + sTableName + ".dat") to bOK
94396>>>                    Get vDeleteFile (sDataPath + sTableName + ".hdr") to bOK
94397>>>                    Get vDeleteFile (sDataPath + sTableName + ".k??") to bOK
94398>>>                End
94398>>>>
94398>>>            End
94398>>>>
94398>>>        End
94398>>>>
94398>>>        
94398>>>        Set Private.pbIntFilesTablesCheckDone to True
94399>>>    End_Procedure
94400>>>
94400>>>    Procedure AutoCreateDbVersionTable
94402>>>        Boolean bDbVersionCheckDone bUseCustomDbVersion bAutoCreateDbVersionTable bTableExists
94402>>>        Integer iDbVersionFileNumber
94402>>>
94402>>>        Get Private.pbDbVersionCheckDone to bDbVersionCheckDone
94403>>>        If (bDbVersionCheckDone = True) Begin
94405>>>            Procedure_Return
94406>>>        End
94406>>>>
94406>>>        Get pbUseCustomDbVersion to bUseCustomDbVersion
94407>>>        If (bUseCustomDbVersion = True) Begin
94409>>>            Procedure_Return
94410>>>        End
94410>>>>
94410>>>
94410>>>        Get piDbVersionFileNumber to iDbVersionFileNumber
94411>>>        Get pbAutoCreateDbVersionTable to bAutoCreateDbVersionTable
94412>>>        If (bAutoCreateDbVersionTable = True and iDbVersionFileNumber < 1) Begin
94414>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94415>>>            Error DFERR_PROGRAM "The iDbVersionFileSlotNumber = -1. It MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object. Could not auto-create the DbVersion table.\nProgram will now exit!"
94416>>>>
94416>>>            Send Exit_Application
94417>>>        End
94417>>>>
94417>>>
94417>>>        If (bAutoCreateDbVersionTable = True) Begin
94419>>>            Get _UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
94420>>>            If (bTableExists = True) Begin
94422>>>                Set Private.pbDbVersionCheckDone to True
94423>>>                Procedure_Return
94424>>>            End
94424>>>>
94424>>>            Send CreateDbVersionTable iDbVersionFileNumber
94425>>>        End
94425>>>>
94425>>>
94425>>>        // We only need to these DbVersion checks once, but because this message is called
94425>>>        // from each child cDbUpdateVersion object (and it needs to be called from there),
94425>>>        // we use a property to only run these tests once.
94425>>>        Set Private.pbDbVersionCheckDone to True
94426>>>    End_Procedure
94427>>>
94427>>>    Procedure CreateDbVersionTable Handle hTable
94429>>>        String sTableName sColumnName sInfoTxt sDriverID 
94429>>>        Boolean bTableExists bOK bUseConnectionID
94429>>>        tAPIColumn[] APIColumn
94429>>>        tAPIColumn[] APIColumn
94430>>>
94430>>>        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
94431>>>        If (bTableExists = True) Begin
94433>>>            Procedure_Return
94434>>>        End
94434>>>>
94434>>>
94434>>>        Get psDriverID to sDriverID
94435>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
94436>>>
94436>>>        Move "DbVersion"        to sTableName
94437>>>        Move 1                  to APIColumn[0].iFieldNumber
94438>>>        Move "DatabaseVersion"  to APIColumn[0].sFieldName
94439>>>        Move DF_BCD             to APIColumn[0].iType
94440>>>        Move False              to APIColumn[0].bIsSQLType
94441>>>        Move 4                  to APIColumn[0].iLength
94442>>>        Move 2                  to APIColumn[0].iPrecision
94443>>>
94443>>>        Move False to Err                                
94444>>>        
94444>>>        // Note: We always create an embedded DbVersion table. To do this we temporarily need to set the psDriverID to "DATAFLEX".
94444>>>        // To convert the DbVersion table to SQL, use the 'ApiTableConvertToSQL' function.
94444>>>        Set psDriverID to DATAFLEX_ID
94445>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
94446>>>        Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
94447>>>        Set psDriverID to sDriverID
94448>>>        
94448>>>        If (bOK = True and Err = False) Begin
94450>>>            Move ("DbVersion table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
94451>>>        End
94451>>>>
94451>>>        Else Begin
94452>>>            Move "The DbVersion table creation failed!" to sInfoTxt
94453>>>        End
94453>>>>
94453>>>
94453>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
94454>>>    End_Procedure
94455>>>
94455>>>    Procedure Set pbVerboseState Boolean bVerboseState
94457>>>        Handle ho
94457>>>        Get phoLogFile to ho
94458>>>        Set pbVerboseState of ho to bVerboseState
94459>>>    End_Procedure
94460>>>
94460>>>    Function pbVerboseState Returns Boolean
94462>>>        Boolean bVerboseState
94462>>>        Handle ho
94462>>>        Get phoLogFile to ho
94463>>>        Get pbVerboseState of ho to bVerboseState
94464>>>        Function_Return bVerboseState
94465>>>    End_Function
94466>>>
94466>>>    // Callback functionality used when e.g. calling driver functions directly.
94466>>>    // Note that this overrules the callback function of the cDbUpdateFunctionLibrary class.
94466>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
94468>>>        Integer iPerc
94468>>>        Number nReady nTotal nVersion
94468>>>        Boolean bVerboseState
94468>>>        Handle hoLogFile
94468>>>
94468>>>        Get pbVerboseState to bVerboseState
94469>>>        Get pnCurrentVersionUpdate to nVersion
94470>>>        Get phoLogFile     to hoLogFile
94471>>>        Send DoAdvance of ghoProgressBar
94472>>>
94472>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
94474>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
94475>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
94476>>>        End
94476>>>>
94476>>>        If (sCallback_Text contains "Creating index") Begin
94478>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
94479>>>        End
94479>>>>
94479>>>        If (bVerboseState = True and (iCallback_Type <> DF_Message_Progress_Value)) Begin
94481>>>            Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94482>>>        End
94482>>>>
94482>>>        If (iCallback_Type <> DF_Message_Progress_Value) Begin
94484>>>            Set Message_Text of ghoStatusPanel to sCallback_Text
94485>>>            Set Action_Text  of ghoStatusPanel to ""
94486>>>        End
94486>>>>
94486>>>
94486>>>        Case Begin
94486>>>            Case (iCallback_Type = DF_Message_Progress_Title)
94488>>>                Set Action_Text  of ghoStatusPanel to ""
94489>>>                Case Break
94490>>>            Case (iCallback_Type = DF_Message_Progress_Value)
94493>>>                //*** Interpret numbers
94493>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
94494>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
94495>>>                Move ((nReady/nTotal) * 100)                                                      to iPerc
94496>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% (Total:") * String(nTotal) + ")")
94497>>>                Set piPosition of ghoProgressBar to iPerc
94498>>>                Case Break
94499>>>//            Case Else
94499>>>//                Set Message_Text of ghoStatusPanel to ""
94499>>>//                Set Action_Text  of ghoStatusPanel to ""
94499>>>        Case End
94499>>>
94499>>>        Send ProcessEvents of ghoStatusPanel
94500>>>        Function_Return False
94501>>>    End_Function
94502>>>
94502>>>    // This was made to be a procedure/function pair so we
94502>>>    // at the same time can set the property of the cDbUpdateFunctionLibrary
94502>>>
94502>>>    Procedure Set piDbType Integer iDbType
94504>>>        If (ghoSQLConnectionHandler = 0) Begin
94506>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94507>>>>
94507>>>            Procedure_Return
94508>>>        End
94508>>>>
94508>>>        Set piDbType of ghoSQLConnectionHandler to iDbType
94509>>>    End_Procedure
94510>>>
94510>>>    Function piDbType Returns Integer
94512>>>        Integer iDbType
94512>>>        If (ghoSQLConnectionHandler = 0) Begin
94514>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94515>>>>
94515>>>            Function_Return ""
94516>>>        End
94516>>>>
94516>>>        Get piDbType of ghoSQLConnectionHandler to iDbType
94517>>>        Function_Return iDbType
94518>>>    End_Function
94519>>>
94519>>>    Procedure Set psDriverID String sDriverID
94521>>>        If (ghoSQLConnectionHandler = 0) Begin
94523>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94524>>>>
94524>>>            Procedure_Return
94525>>>        End
94525>>>>
94525>>>        Set psDriverID of ghoSQLConnectionHandler to sDriverID
94526>>>    End_Procedure
94527>>>
94527>>>    Function psDriverID Returns String
94529>>>        String sValue
94529>>>        If (ghoSQLConnectionHandler = 0) Begin
94531>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94532>>>>
94532>>>            Function_Return ""
94533>>>        End
94533>>>>
94533>>>        Get psDriverID of ghoSQLConnectionHandler to sValue
94534>>>        Function_Return sValue
94535>>>    End_Function
94536>>>    
94536>>>    Procedure Set pbUseDriverCacheFiles Boolean bUseDriverCacheFiles
94538>>>        If (ghoSQLConnectionHandler = 0) Begin
94540>>>            Procedure_Return
94541>>>        End  
94541>>>>
94541>>>        Set Private.pbUseDriverCacheFiles of ghoSQLConnectionHandler to bUseDriverCacheFiles
94542>>>    End_Procedure
94543>>>
94543>>>    Function pbUseDriverCacheFiles Returns Boolean
94545>>>        String sDriverID
94545>>>        Integer iDriver
94545>>>        Boolean bUseDriverCacheFiles        
94545>>>        Move True to bUseDriverCacheFiles
94546>>>        If (ghoSQLConnectionHandler = 0) Begin
94548>>>            Function_Return False
94549>>>        End
94549>>>>
94549>>>        Get psDriverID of ghoSQLConnectionHandler to sDriverID
94550>>>        If (sDriverID = DATAFLEX_ID) Begin
94552>>>            Function_Return False
94553>>>        End
94553>>>>
94553>>>        Get DriverIndex of ghoSQLConnectionHandler sDriverID to iDriver
94554>>>        If (iDriver <> 0) Begin
94556>>>            Get_Attribute DF_DRIVER_USE_CACHE of iDriver to bUseDriverCacheFiles 
94559>>>        End
94559>>>>
94559>>>        Function_Return bUseDriverCacheFiles 
94560>>>    End_Function
94561>>>
94561>>>    Procedure Set pbIgnoreDriverUcaseSupport Boolean bState
94563>>>        If (ghoSQLConnectionHandler = 0) Begin
94565>>>            Procedure_Return
94566>>>        End  
94566>>>>
94566>>>        Set Private.pbIgnoreDriverUcaseSupport of ghoSQLConnectionHandler to bState
94567>>>    End_Procedure
94568>>>
94568>>>    Function pbIgnoreDriverUcaseSupport Returns Boolean
94570>>>        String sDriverID
94570>>>        Integer iDriver
94570>>>        Boolean bIgnoreDriverUcaseSupport        
94570>>>        Move True to bIgnoreDriverUcaseSupport
94571>>>        If (ghoSQLConnectionHandler = 0) Begin
94573>>>            Function_Return False
94574>>>        End
94574>>>>
94574>>>        Get psDriverID of ghoSQLConnectionHandler to sDriverID
94575>>>        If (sDriverID = DATAFLEX_ID) Begin
94577>>>            Function_Return False
94578>>>        End
94578>>>>
94578>>>        Get DriverIndex of ghoSQLConnectionHandler sDriverID to iDriver
94579>>>        If (iDriver <> 0) Begin
94581>>>            Get_Attribute DF_DRIVER_IGNORE_UCASE_SUPPORT of iDriver to bIgnoreDriverUcaseSupport 
94584>>>        End
94584>>>>
94584>>>        Function_Return bIgnoreDriverUcaseSupport 
94585>>>    End_Function
94586>>>
94586>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
94588>>>        If (ghoSQLConnectionHandler = 0) Begin
94590>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94591>>>>
94591>>>            Procedure_Return
94592>>>        End
94592>>>>
94592>>>        Send CreateSQLConnection of ghoSQLConnectionHandler sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
94593>>>    End_Procedure
94594>>>
94594>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
94596>>>        Integer iRetval
94596>>>        If (ghoSQLConnectionHandler = 0) Begin
94598>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94599>>>>
94599>>>            Function_Return 2
94600>>>        End
94600>>>>
94600>>>
94600>>>        Get RedirectConnection of ghoSQLConnectionHandler to iRetval
94601>>>        Function_Return iRetval
94602>>>    End_Function
94603>>>
94603>>>    Procedure Set psConnectionID String sValue
94605>>>        If (ghoSQLConnectionHandler = 0) Begin
94607>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94608>>>>
94608>>>            Procedure_Return
94609>>>        End
94609>>>>
94609>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
94610>>>    End_Procedure
94611>>>
94611>>>    Function psConnectionID Returns String
94613>>>        String sValue
94613>>>        If (ghoSQLConnectionHandler = 0) Begin
94615>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94616>>>>
94616>>>            Function_Return ""
94617>>>        End
94617>>>>
94617>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
94618>>>
94618>>>        Function_Return sValue
94619>>>    End_Function
94620>>>
94620>>>    // These "properties" are settings of the cCLIHandler class, but are being
94620>>>    // relayed to the ghoSQLConnectionHandler object
94620>>>    // simply by changing one of its parameters.
94620>>>    Procedure Set psServer String sValue
94622>>>        If (ghoSQLConnectionHandler = 0) Begin
94624>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94625>>>>
94625>>>            Procedure_Return
94626>>>        End
94626>>>>
94626>>>        Set psServer of ghoSQLConnectionHandler to sValue
94627>>>    End_Procedure
94628>>>
94628>>>    Function psServer Returns String
94630>>>        String sValue
94630>>>        If (ghoSQLConnectionHandler = 0) Begin
94632>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94633>>>>
94633>>>            Function_Return ""
94634>>>        End
94634>>>>
94634>>>        Get psServer of ghoSQLConnectionHandler to sValue
94635>>>
94635>>>        Function_Return sValue
94636>>>    End_Function
94637>>>
94637>>>    Procedure Set psDatabase String sValue
94639>>>        If (ghoSQLConnectionHandler = 0) Begin
94641>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94642>>>>
94642>>>            Procedure_Return
94643>>>        End
94643>>>>
94643>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
94644>>>    End_Procedure
94645>>>
94645>>>    Function psDatabase Returns String
94647>>>        String sValue
94647>>>        If (ghoSQLConnectionHandler = 0) Begin
94649>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94650>>>>
94650>>>            Function_Return ""
94651>>>        End
94651>>>>
94651>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
94652>>>
94652>>>        Function_Return sValue
94653>>>    End_Function
94654>>>
94654>>>    Procedure Set psUserID String sValue
94656>>>        If (ghoSQLConnectionHandler = 0) Begin
94658>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94659>>>>
94659>>>            Procedure_Return
94660>>>        End
94660>>>>
94660>>>        Set psUserID of ghoSQLConnectionHandler to sValue
94661>>>    End_Procedure
94662>>>
94662>>>    Function psUserID Returns String
94664>>>        String sValue
94664>>>        If (ghoSQLConnectionHandler = 0) Begin
94666>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94667>>>>
94667>>>            Function_Return ""
94668>>>        End
94668>>>>
94668>>>        Get psUserID of ghoSQLConnectionHandler to sValue
94669>>>
94669>>>        Function_Return sValue
94670>>>    End_Function
94671>>>
94671>>>    Procedure Set psPassword String sValue
94673>>>        If (ghoSQLConnectionHandler = 0) Begin
94675>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94676>>>>
94676>>>            Procedure_Return
94677>>>        End
94677>>>>
94677>>>        Set psPassword of ghoSQLConnectionHandler to sValue
94678>>>    End_Procedure
94679>>>
94679>>>    Function psPassword Returns String
94681>>>        String sValue
94681>>>        If (ghoSQLConnectionHandler = 0) Begin
94683>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94684>>>>
94684>>>            Function_Return ""
94685>>>        End
94685>>>>
94685>>>        Get psPassword of ghoSQLConnectionHandler to sValue
94686>>>
94686>>>        Function_Return sValue
94687>>>    End_Function
94688>>>
94688>>>    Procedure Set pbTrusted Boolean bValue
94690>>>        If (ghoSQLConnectionHandler = 0) Begin
94692>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94693>>>>
94693>>>            Procedure_Return
94694>>>        End
94694>>>>
94694>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
94695>>>    End_Procedure
94696>>>
94696>>>    Function pbTrusted Returns Boolean
94698>>>        Boolean bValue
94698>>>        If (ghoSQLConnectionHandler = 0) Begin
94700>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94701>>>>
94701>>>            Function_Return False
94702>>>        End
94702>>>>
94702>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
94703>>>
94703>>>        Function_Return bValue
94704>>>    End_Function
94705>>>
94705>>>    Procedure Set psConnectionString String sValue
94707>>>        If (ghoSQLConnectionHandler = 0) Begin
94709>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94710>>>>
94710>>>            Procedure_Return
94711>>>        End
94711>>>>
94711>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
94712>>>    End_Procedure
94713>>>
94713>>>    Function psConnectionString Returns String
94715>>>        String sValue
94715>>>        If (ghoSQLConnectionHandler = 0) Begin
94717>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94718>>>>
94718>>>            Function_Return ""
94719>>>        End
94719>>>>
94719>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
94720>>>
94720>>>        Function_Return sValue
94721>>>    End_Function
94722>>>
94722>>>    Function piConnectionOptions Returns Integer
94724>>>        Integer iValue
94724>>>        If (ghoSQLConnectionHandler = 0) Begin
94726>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94727>>>>
94727>>>            Function_Return 0
94728>>>        End
94728>>>>
94728>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
94729>>>
94729>>>        Function_Return iValue
94730>>>    End_Function
94731>>>
94731>>>
94731>>>    Procedure Set pbCheckDataFlexUserCount Boolean bState
94733>>>        Set pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
94734>>>    End_Procedure
94735>>>
94735>>>    Function pbCheckDataFlexUserCount Returns Boolean
94737>>>        Boolean bState
94737>>>        Get pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
94738>>>        Function_Return bState
94739>>>    End_Function
94740>>>
94740>>>    Procedure Set psLogTextFile String sValue
94742>>>        Set psLogTextFile of (phoLogFile(Self)) to sValue
94743>>>    End_Procedure
94744>>>
94744>>>    Function psLogTextFile Returns String
94746>>>        String sValue
94746>>>        Get psLogTextFile of (phoLogFile(Self)) to sValue
94747>>>        Function_Return sValue
94748>>>    End_Function
94749>>>
94749>>>    Procedure Set psEditorProgram String sValue
94751>>>        Set psEditorProgram of (phoLogFile(Self)) to sValue
94752>>>    End_Procedure
94753>>>
94753>>>    Function psEditorProgram Returns String
94755>>>        String sValue
94755>>>        Get psEditorProgram of (phoLogFile(Self)) to sValue
94756>>>        Function_Return sValue
94757>>>    End_Function
94758>>>
94758>>>    Procedure Set pbUseDataTableLog Boolean bState
94760>>>        Set pbUseDataTableLog of (phoLogFile(Self)) to bState
94761>>>    End_Procedure
94762>>>
94762>>>    Function pbUseDataTableLog Returns Boolean
94764>>>        Boolean bState
94764>>>        Get pbUseDataTableLog of (phoLogFile(Self)) to bState
94765>>>        Function_Return bState
94766>>>    End_Function
94767>>>
94767>>>    Procedure Set pbQuickWrite Boolean bState
94769>>>        Set pbQuickWrite of (phoLogFile(Self)) to bState
94770>>>    End_Procedure
94771>>>
94771>>>    Function pbQuickWrite Returns Boolean
94773>>>        Boolean bState
94773>>>        Get pbQuickWrite of (phoLogFile(Self)) to bState
94774>>>        Function_Return bState
94775>>>    End_Function
94776>>>
94776>>>    Procedure Set pbDatabaseWasUpdated Boolean bState
94778>>>        Boolean bUpdateVersionObjectError bVerboseState
94778>>>        Integer iSize iCount
94778>>>        Number nVersion
94778>>>        String[] aSQLQueryMessages
94779>>>
94779>>>        Get Private.pbUpdateVersionObjectError to bUpdateVersionObjectError
94780>>>        Set Private.pbDatabaseWasUpdated to bState
94781>>>        // If no errors occurred in the current cDbUpdateVersion object - write
94781>>>        // to the log that it was OK.
94781>>>        If (bUpdateVersionObjectError = False) Begin
94783>>>            Get pnCurrentVersionUpdate to nVersion
94784>>>            Send LogError of (phoLogFile(Self)) nVersion 0 CS_SuccessfulUpdate 0 False
94785>>>        End
94785>>>>
94785>>>
94785>>>        Get pbVerboseState to bVerboseState
94786>>>        If (bVerboseState = True) Begin
94788>>>            Get paSQLQueryMessages to aSQLQueryMessages
94789>>>            Move (SizeOfArray(aSQLQueryMessages)) to iSize
94790>>>            Decrement iSize
94791>>>            For iCount from 0 to iSize
94797>>>>
94797>>>                Send LogError of (phoLogFile(Self)) nVersion 0 aSQLQueryMessages[iCount] 0 False
94798>>>            Loop
94799>>>>
94799>>>        End
94799>>>>
94799>>>
94799>>>    End_Procedure 
94800>>>
94800>>>    // Returns the current DbVersion value (system table)
94800>>>    // Note: If the DbVersion table doesn't exist yet,
94800>>>    //       it will return -1.
94800>>>    Function CurrentDbVersion Returns Number
94802>>>        Boolean bInUse bActive
94802>>>        Integer iStatus iColumn
94802>>>        Number nVersion
94802>>>        Handle hTable
94802>>>        
94802>>>        Move -1 to nVersion
94803>>>        Get piDbVersionFileNumber  to hTable
94804>>>        Get piDbVersionFieldNumber to iColumn
94805>>>        Get _UtilTableNumberIsInUse hTable to bInUse
94806>>>        If (bInUse = True) Begin
94808>>>            Open hTable
94810>>>            Get_Attribute DF_FILE_STATUS of hTable to iStatus
94813>>>            If (iStatus = DF_FILE_INACTIVE) Begin
94815>>>                Vfind hTable 0 GT
94817>>>            End
94817>>>>
94817>>>            Get_Field_Value hTable iColumn to nVersion
94820>>>        End
94820>>>>
94820>>>        Function_Return nVersion
94821>>>    End_Function
94822>>>         
94822>>>    
94822>>>    Procedure Set piDbVersionFileNumber Integer iFileNumber
94824>>>        Set Private.piDbVersionFileNumber to iFileNumber
94825>>>    End_Procedure                                         
94826>>>    
94826>>>    Function piDbVersionFileNumber Returns Integer
94828>>>        Function_Return (Private.piDbVersionFileNumber(Self))
94829>>>    End_Function
94830>>>
94830>>>    Procedure Set piDbVersionFieldNumber Integer iFieldNumber
94832>>>        Set Private.piDbVersionFieldNumber to iFieldNumber
94833>>>    End_Procedure                                         
94834>>>    
94834>>>    Function piDbVersionFieldNumber Returns Integer
94836>>>        Function_Return (Private.piDbVersionFieldNumber(Self))
94837>>>    End_Function
94838>>>
94838>>>    Function pbDatabaseWasUpdated Returns Boolean
94840>>>        Function_Return (Private.pbDatabaseWasUpdated(Self))
94841>>>    End_Function
94842>>>    
94842>>>    // Takes a string array as parameter and returns a new
94842>>>    // string array without any empty rows and all rows trimmed.
94842>>>    // This is e.g. used by the HasIntFileChanged message to compare
94842>>>    // two .int file arrays. 
94842>>>    Function RemoveBlankLines String[] asIntFile Returns String[]
94844>>>        Integer iSize iCount iRow
94844>>>        String sVal        
94844>>>        String[] asRetValArray
94845>>>        
94845>>>        Move (SizeOfArray(asIntFile)) to iSize
94846>>>        If (iSize = 0) Begin
94848>>>            Function_Return asRetValArray
94849>>>        End                          
94849>>>>
94849>>>        Decrement iSize         
94850>>>        Move 0 to iRow
94851>>>        
94851>>>        For iCount from 0  to iSize
94857>>>>
94857>>>            Move asIntFile[iCount] to sVal
94858>>>            Move (Trim(sVal)) to sVal
94859>>>            If (sVal <> "") Begin
94861>>>                Move sVal to asRetValArray[iRow]
94862>>>                Increment iRow        
94863>>>            End
94863>>>>
94863>>>        Loop
94864>>>>
94864>>>        
94864>>>        Function_Return asRetValArray
94865>>>    End_Function
94866>>>    
94866>>>    //
94866>>>    Procedure ReinitializeFramework  
94868>>>        tDbVersionInfo[] aDbVersionInfoArray
94868>>>        tDbVersionInfo[] aDbVersionInfoArray
94869>>>        Handle hoDbVersionObject
94869>>>        Integer iSize iCount
94869>>>        
94869>>>        Set Private.pbDatabaseUpdateStarted to False
94870>>>        Get paDbVersionInfoArray to aDbVersionInfoArray
94871>>>        Move (SizeOfArray(aDbVersionInfoArray)) to iSize
94872>>>        Decrement iSize
94873>>>        
94873>>>        For iCount from 0 to iSize
94879>>>>
94879>>>            Move aDbVersionInfoArray[0].hObject to hoDbVersionObject
94880>>>            Send ProcessUpdate                  of hoDbVersionObject False
94881>>>        Loop
94882>>>>
94882>>>        Send Cleanup
94883>>>    End_Procedure
94884>>>    
94884>>>    Procedure StartStatusPanel String sMsg String sMsg2 Integer iSze
94886>>>        Integer iSize
94886>>>        String sMessage sMessage2
94886>>>        
94886>>>        // Make it optional to pass an argument
94886>>>        If (num_arguments > 0) Begin
94888>>>            Move sMsg to sMessage
94889>>>        End
94889>>>>
94889>>>
94889>>>        // Make it optional to pass a second argument
94889>>>        If (num_arguments > 1) Begin
94891>>>            Move sMsg2 to sMessage2
94892>>>        End
94892>>>>
94892>>>
94892>>>        Move 0 to iSize
94893>>>        // Make it optional to pass a third argument
94893>>>        If (num_arguments > 2) Begin
94895>>>            Move iSze to iSize
94896>>>        End                   
94896>>>>
94896>>>        If (iSize = -1) Begin
94898>>>            Set Progress_Bar_Overall_Visible_State of ghoStatusPanel to False
94899>>>        End
94899>>>>
94899>>>        If (iSize <> 0) Begin
94901>>>            Set Progress_Bar_Visible_State of ghoStatusPanel to True
94902>>>            Set piMaximum                  of ghoStatusPanel to iSize 
94903>>>            Set piAdvanceBy                of ghoStatusPanel to 1
94904>>>            Set Progress_Bar_Overall_Visible_State of ghoStatusPanel to True
94905>>>        End
94905>>>>
94905>>>
94905>>>        Send EnableCancelButton     of ghoStatusPanel (pbEnableCancelButton(Self))
94906>>>        Send Initialize_StatusPanel of ghoStatusPanel ("   " + CS_DUF_WorkingUpdateText) sMessage sMessage2 
94907>>>        Send Update_StatusPanel of ghoStatusPanel ""
94908>>>        Send Start_StatusPanel of ghoStatusPanel
94909>>>    End_Procedure
94910>>>    
94910>>>    Procedure StopStatusPanel
94912>>>        Send Stop_StatusPanel of ghoStatusPanel
94913>>>    End_Procedure
94914>>>    
94914>>>    // This event is triggered by the cDbUpdateVersion child class when
94914>>>    // a database change is to be started, and is considered private.
94914>>>    // It is only executed once for the first cDbUpateVersion object!
94914>>>    Procedure InitDatabaseUpdate Handle hDbUpdateVersionObject
94916>>>        Boolean bDatabaseUpdateStarted bInUse bExists bCheckDataFlexUserCount
94916>>>        Integer iRetval iDataFlexUsers iUserCount
94916>>>        Handle hoUserCountSystem
94916>>>        tUserCount UserCount
94916>>>        tUserCount UserCount
94916>>>        DateTime dtUpdateStarted
94916>>>        tSQLConnection SQLConnection
94916>>>        tSQLConnection SQLConnection
94916>>>
94916>>>        // *Important:* If we already started the update; we do no further checking.
94916>>>        Get Private.pbDatabaseUpdateStarted to bDatabaseUpdateStarted
94917>>>        If (bDatabaseUpdateStarted = True) Begin
94919>>>            Procedure_Return
94920>>>        End
94920>>>>
94920>>>
94920>>>        // If not silent mode; Ask user if OK to start database update.
94920>>>        If (pbSilentMode(Self) = False) Begin
94922>>>            Get YesNo_Box CS_DUF_DatabaseNeedsUpdate CS_DUF_HeaderUpdateText to iRetval
94923>>>            If (iRetval <> MBR_Yes) Begin
94925>>>                Send Exit_Application
94926>>>            End
94926>>>>
94926>>>        End
94926>>>>
94926>>>        
94926>>>        Send StartStatusPanel "" "" 1
94927>>>        // This will save the status of all open tables including Master/Alias settings,
94927>>>        // so we can restore them later;
94927>>>        Send SaveOpenTables
94928>>>
94928>>>        Move 0 to iDataFlexUsers
94929>>>        // Make various tests to check that the database is not in use.
94929>>>        Get IsDatabaseInUse of hDbUpdateVersionObject to bInUse
94930>>>        // We also use our own user counting mechanism to guard against the
94930>>>        // database isn't opened already as we need exclusive access to the tables.:
94930>>>        Get phoUserCountSystem to hoUserCountSystem
94931>>>        Get CheckUserCount of hoUserCountSystem to UserCount
94932>>>        Get CurrentNumberOfUsers of hoUserCountSystem to iUserCount
94933>>>
94933>>>        Get pbCheckDataFlexUserCount of hoUserCountSystem to bCheckDataFlexUserCount
94934>>>        // Check DataFlex user count to see if anybody else is using the DataFlex license...
94934>>>        If (bCheckDataFlexUserCount = True) Begin
94936>>>            Get_Current_User_Count to iDataFlexUsers
94937>>>            // For some reason DataFlex - in some cases - might think that 2 users
94937>>>            // are in use while debugging from the Studio.
94937>>>            If (IsDebuggerPresent() and iDataFlexUsers = 2) Begin
94939>>>                Decrement iDataFlexUsers
94940>>>            End
94940>>>>
94940>>>        End 
94940>>>>
94940>>>        Else Begin
94941>>>            Move 1 to iDataFlexUsers 
94942>>>            Move 1 to iUserCount
94943>>>            Move False to bInUse
94944>>>        End
94944>>>>
94944>>>
94944>>>        If (pbSilentMode(Self) = False and iDataFlexUsers > 1) Begin
94946>>>            Get YesNo_Box CS_DUF_DatabaseInUseShort to iRetval
94947>>>            If (iRetval <> MBR_Yes) Begin
94949>>>                Send Exit_Application
94950>>>            End
94950>>>>
94950>>>        End
94950>>>>
94950>>>
94950>>>        If (bInUse = True or (UserCount.iError <> 0) or (iUserCount > 1)) Begin
94952>>>            Send Stop_Box CS_DUF_DatabaseInUseText
94953>>>            Send Exit_Application
94954>>>        End
94954>>>>
94954>>>
94954>>>        // This will put a look on the DbUpdateLock.ucf file.
94954>>>        // It is released when the update process is finished
94954>>>        Get CheckUserCount of (phoDatabaseUpdateLock(Self)) to UserCount
94955>>>
94955>>>        Move (CurrentDateTime()) to dtUpdateStarted
94956>>>        Set pdtUpdateStart of (phoLogFile(Self)) to dtUpdateStarted
94957>>>        Set Private.pbDatabaseUpdateStarted to True
94958>>>
94958>>>        // We need to close all tables before starting to make changes.
94958>>>        Close DF_ALL DF_PERMANENT
94959>>>
94959>>>        // If these properties has not exclicitly been set in the object, set them
94959>>>        // to settings from the SQLConnections.ini file;
94959>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
94960>>>        If (psSchema(Self) = "") Begin
94962>>>            Set psSchema            to SQLConnection.sSchema
94963>>>        End
94963>>>>
94963>>>        If (psBaseTableSpace(Self) = "") Begin
94965>>>            Set psBaseTableSpace    to SQLConnection.sBaseTableSpace
94966>>>        End
94966>>>>
94966>>>        If (psLongTableSpace(Self) = "") Begin
94968>>>            Set psLongTableSpace    to SQLConnection.sLongTableSpace
94969>>>        End
94969>>>>
94969>>>        If (psIndexTableSpace(Self) = "") Begin
94971>>>            Set psIndexTableSpace   to SQLConnection.sIndexTableSpace
94972>>>        End
94972>>>>
94972>>>        If (SQLConnection.sDriverID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
94974>>>            Procedure_Return
94975>>>        End
94975>>>>
94975>>>
94975>>>        Get SQLUtilCheckIfDatabaseExists of hDbUpdateVersionObject SQLConnection.sDatabase to bExists
94976>>>        If (SQLConnection.sDatabase <> "" and bExists = False) Begin
94978>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94979>>>            Send StopStatusPanel
94980>>>            // ToDo: NS 2019-09-23 I think we should always show an error message to the user if this occur (!)
94980>>>            Send Stop_Box (CS_DUF_DatabaseConnStringSpec + SQLConnection.sDatabase + CS_DUF_DatabaseDoesntExist )
94981>>>//            Error DFERR_PROGRAM ("The database specified in the connection string: '" + SQLConnection.sDatabase + "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit.")
94981>>>            Send Exit_Application
94982>>>        End
94982>>>>
94982>>>    End_Procedure
94983>>>
94983>>>    // *** Hook message for pre-processing ***
94983>>>    // Event to be used to auto-create a version table when "DUF_Use_Custom_DbVersion" is used.
94983>>>    // Aka, when another table than the standard "DbVersion" is used.
94983>>>    Procedure OnCreateCustomDbVersionTable
94985>>>    End_Procedure
94986>>>    
94986>>>    // *** Hook message for pre-processing ***
94986>>>    // The programmer can use this event for putting code that
94986>>>    // needs to be executed _before_ code in any of the cDbUpdateVersion
94986>>>    // child objects are executed.
94986>>>    Procedure OnPreUpdate
94988>>>    End_Procedure
94989>>>
94989>>>    // *** Hook message for post-processing ***
94989>>>    // The programmer should use this event for putting code that
94989>>>    // needs to be executed _after_ all database updates have finished.
94989>>>    Procedure OnPostUpdate
94991>>>    End_Procedure
94992>>>
94992>>>    // *** Hook message for custom DbVersion record find ***
94992>>>    // The programmer can use this event for putting code that
94992>>>    // needs to be executed to find a *custom* DbVersion table record.
94992>>>    // By default the DbVersion table is used but this can be
94992>>>    // customized by adding this line to the code;
94992>>>    // "Define DUF_Use_Custom_DbVersion" before the line "Use cDbUpdateHandler.pkg"
94992>>>    // Note: You do _not_ need to use this event if the DbVersion table is used
94992>>>    //       to save the current database version to. Only if you use your own
94992>>>    //       table _and_ it is not a system table (contains only one record).
94992>>>    Procedure OnFindVersionRecord
94994>>>        // Open MyTable
94994>>>        // Move xx to MyTable.Field1
94994>>>        // Move yy to MyTable.Field2
94994>>>        // Find le MyTable by Index.x
94994>>>    End_Procedure
94995>>>
94995>>>    // Hook event for writing header error text (pre-update) to
94995>>>    // a datatable. Only called if the pbUseDataTableLog property = True.
94995>>>    // Don't forget to Open the table first (!) as all
94995>>>    // tables have been closed at this stage.
94995>>>    // The start date & time is passed.
94995>>>    Procedure OnErrorWriteHeader_DataTable DateTime dtUpdateStart
94997>>>    End_Procedure
94998>>>
94998>>>    // Hook event to log errors to a database table.
94998>>>    // Only called if the pbUseDataTableLog = True.
94998>>>    // Don't forget to Open the table first (!) as all
94998>>>    // tables have been closed at this stage.
94998>>>    // If pbQuickWrite = True the DbUpdateErrorArray
94998>>>    // will contain just one row, as it is called for each error
94998>>>    // that occurred. Else it is called once at the end after all updates
94998>>>    // have run and contains all errors.
94998>>>    Procedure OnErrorWriteRow_DataTable tDbUpdateError[] DbUpdateErrorArray
95000>>>    End_Procedure
95001>>>
95001>>>    // Automatically send after all processing is done, but before the OnPostUpdate event.
95001>>>    Procedure Cleanup
95003>>>        Boolean bDatabaseWasUpdated bError bUseIntFilesBackup bOK
95003>>>        String sErrorText
95003>>>        
95003>>>        Move "" to sErrorText
95004>>>        Send AutoCreateDbVersionTable
95005>>>        Send RestoreOpenTables
95006>>>
95006>>>        // The function library have two purposes; one is to use it in the
95006>>>        // Database Update Framework, but it can also be used on its own.
95006>>>        // If that is the case it has its own error handling system, which
95006>>>        // we temporarily disbled when running updates because we have
95006>>>        // error handling/logging here too... We now restore its setting.
95006>>>        If (ghoDbUpdateFunctionLibrary > 0) Begin
95008>>>            Set pbHandleQueryErrors of ghoDbUpdateFunctionLibrary to True
95009>>>        End
95009>>>>
95009>>>        Set pbHandleQueryErrors to True
95010>>>
95010>>>        Get pbDatabaseWasUpdated to bDatabaseWasUpdated
95011>>>        Get pbDbUpdateErrorHasOccured to bError
95012>>>        // Note: We make backup of .int files even if an error occured.
95012>>>        If (bDatabaseWasUpdated = True) Begin
95014>>>            // Check/create/update *.int files backup table:
95014>>>            Get pbUseIntFilesBackup to bUseIntFilesBackup
95015>>>            If (bUseIntFilesBackup = True) Begin
95017>>>                Get SaveUpdateIntFiles (&sErrorText) to bOK
95018>>>                If (bOK = False) Begin
95020>>>                    Send LogError sErrorText True
95021>>>                End
95021>>>>
95021>>>                Else If (sErrorText <> "") Begin
95024>>>                    Send LogError sErrorText False
95025>>>                End
95025>>>>
95025>>>            End
95025>>>>
95025>>>        End            
95025>>>>
95025>>>            
95025>>>        If (bDatabaseWasUpdated = True or bError = True) Begin
95027>>>
95027>>>            // We should always create the log as it also contains info about
95027>>>            // the update being successful.
95027>>>            Send WriteErrorLog of (phoLogFile(Self))
95028>>>
95028>>>            // This is a programmer's hook message:
95028>>>            Send OnPostUpdate
95029>>>
95029>>>            Send StopStatusPanel
95030>>>            If (pbSilentMode(Self) = False) Begin
95032>>>                If (bError = True) Begin
95034>>>                    If (pbShowErrorLogPostRun(Self) = True) Begin
95036>>>                        Send ShowErrorLog of (phoLogFile(Self))
95037>>>                    End
95037>>>>
95037>>>                    Send Info_Box CS_DUF_DbUpdatedErrorText
95038>>>                    Send Exit_Application
95039>>>                End
95039>>>>
95039>>>                Else Begin
95040>>>                    If (Private.pbDatabaseWasUpdated(Self) = True) Begin
95042>>>                        Send Info_Box CS_DUF_DatabaseUpdatedText
95043>>>                    End
95043>>>>
95043>>>                    Else Begin
95044>>>                        Send Info_Box CS_DUF_DatabaseCheckedText
95045>>>                    End
95045>>>>
95045>>>                End
95045>>>>
95045>>>            End
95045>>>>
95045>>>        End
95045>>>>
95045>>>
95045>>>        // Restore the standard error handler:
95045>>>        Get piOrgErrorHandlerID to Error_Object_Id
95046>>>    End_Procedure
95047>>>
95047>>>    // We do this _before_ we close the database to make changes, and save
95047>>>    // all 'Master' & 'Alias' tables settings so we can restore when
95047>>>    // we reopen the database.
95047>>>    Procedure SaveOpenTables
95049>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
95049>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
95050>>>        Get _MasterAndAliasFiles to aDbUpdateHandlerMasterAlias
95051>>>        Set paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
95052>>>    End_Procedure
95053>>>
95053>>>    // Returns a struct array with all currently open tables and a "state" that indicates if the table
95053>>>    // was opened DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER or DF_FILE_IS_ALIAS
95053>>>    Function _MasterAndAliasFiles Returns tDbUpdateHandlerMasterAlias[]
95055>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
95055>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
95056>>>        Integer hTable iMasterAliasType iSize
95056>>>        Boolean bOpen
95056>>>
95056>>>        Move 0 to hTable
95057>>>        Repeat
95057>>>>
95057>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
95060>>>            If (hTable <> 0) Begin
95062>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
95065>>>                If (bOpen = True) Begin
95067>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iMasterAliasType
95070>>>                    Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
95071>>>                    Move hTable to aDbUpdateHandlerMasterAlias[iSize].hTable
95072>>>                    Move iMasterAliasType to aDbUpdateHandlerMasterAlias[iSize].iMode
95073>>>                End
95073>>>>
95073>>>            End
95073>>>>
95073>>>        Until (hTable = 0)
95075>>>
95075>>>        Function_Return aDbUpdateHandlerMasterAlias
95076>>>    End_Function
95077>>>
95077>>>    // Message that re-opens all files in the filelist.cfg and restores any master & alias attributes.
95077>>>    // Takes one parameter:
95077>>>    //   A struct array with all master & alias
95077>>>    Procedure RestoreOpenTables
95079>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
95079>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
95080>>>        Integer hTable iFileAlias iSize iCount
95080>>>        Boolean bOpen
95080>>>        String sRootName
95080>>>
95080>>>        Move 0 to hTable
95081>>>        Get paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
95082>>>        Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
95083>>>        Decrement iSize
95084>>>        For iCount from 0 to iSize
95090>>>>
95090>>>            Move aDbUpdateHandlerMasterAlias[iCount].hTable to hTable
95091>>>            // We also need to check that the table hasn't been removed...
95091>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
95094>>>            If (hTable <> 0 and sRootName <> "") Begin
95096>>>                Open hTable
95098>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
95101>>>                If (bOpen = True) Begin
95103>>>                    Move aDbUpdateHandlerMasterAlias[iCount].iMode to iFileAlias
95104>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
95106>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_MASTER
95109>>>                    End
95109>>>>
95109>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
95112>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_ALIAS
95115>>>                    End
95115>>>>
95115>>>                End
95115>>>>
95115>>>            End
95115>>>>
95115>>>        Loop
95116>>>>
95116>>>    End_Procedure
95117>>>
95117>>>    // This checks for both duplicate pnVersionNumbers _and_ that
95117>>>    // the cDbVersion object pnVersionNumber's all are consecutive (higher than the previous).
95117>>>    Procedure CheckForDuplicates Number nVersion
95119>>>        tDbVersionInfo[] DbVersionInfoArray
95119>>>        tDbVersionInfo[] DbVersionInfoArray
95120>>>        Integer iCount iSize iHits iDuplicateIndex
95120>>>        Number nCompare
95120>>>        Handle hObject1 hObject2
95120>>>        String sObjectName1 sObjectName2
95120>>>        Boolean bObjectOrderError
95120>>>
95120>>>        Get paDbVersionInfoArray to DbVersionInfoArray
95121>>>        Move (SizeOfArray(DbVersionInfoArray)) to iSize
95122>>>        Decrement iSize
95123>>>        Move 0 to iHits
95124>>>        Move 0 to nCompare
95125>>>        Move False to bObjectOrderError
95126>>>        For iCount from 0 to iSize
95132>>>>
95132>>>            If (nVersion = DbVersionInfoArray[iCount].nVersionNumber) Begin
95134>>>                Increment iHits
95135>>>                If (iHits > 1) Begin
95137>>>                    Move iCount to iDuplicateIndex
95138>>>                    If (nCompare <> 0) Begin
95140>>>                        Move (nCompare >= DbVersionInfoArray[iCount].nVersionNumber) to bObjectOrderError
95141>>>                    End
95141>>>>
95141>>>                End
95141>>>>
95141>>>            End
95141>>>>
95141>>>            Move DbVersionInfoArray[iCount].nVersionNumber to nCompare
95142>>>        Loop
95143>>>>
95143>>>        If (iHits > 1) Begin
95145>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
95146>>>            Move DbVersionInfoArray[(iDuplicateIndex   )].hObject to hObject1
95147>>>            Move DbVersionInfoArray[(iDuplicateIndex -1)].hObject to hObject2
95148>>>            Move (Name(hObject1)) to sObjectName1
95149>>>            Move (Name(hObject2)) to sObjectName2
95150>>>            Error DFERR_PROGRAM ("Duplicate version numbers! The SAME pnVersionNumber value was set for the following two objects; Program will now exit!\n\n" + sObjectName1 + "\n" + sObjectName2)
95151>>>>
95151>>>            Send Exit_Application
95152>>>        End
95152>>>>
95152>>>        Else If (bObjectOrderError = True) Begin
95155>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
95156>>>            Error DFERR_PROGRAM ("cDbVersion objects out of order! One or more of the cDbVersion objects has been placed out of order. This means that at least one pnVersionNumber is HIGHER than the following object's pnVersionNumber.\nProgram will now exit!")
95157>>>>
95157>>>            Send Exit_Application
95158>>>        End
95158>>>>
95158>>>    End_Procedure
95159>>>
95159>>>    // We take care of all errors in the Error_Report below and
95159>>>    // collect them all to an array property. So just ignore any
95159>>>    // "Ignore_Error" & "Trap_Error" messages that might be send/used
95159>>>    // in some other package.
95159>>>    Procedure Ignore_Error Integer iError
95161>>>    End_Procedure
95162>>>
95162>>>    Procedure Trap_Error Integer iError
95164>>>    End_Procedure
95165>>>
95165>>>    // Build complete error description from Flexerrs and user error message.
95165>>>    Function Error_Description Integer Error# String ErrMsg Returns String
95167>>>        String Full_Error_Text
95167>>>        
95167>>>        Move (Trim(ErrMsg)) to ErrMsg
95168>>>        Move (Trim(Error_Text(DESKTOP, Error#))) to Full_Error_Text
95169>>>        
95169>>>        If (ErrMsg <> "") Begin
95171>>>            
95171>>>            If ((Full_Error_Text<>"" ) and ;                Error_Text_Available( DESKTOP, Error# ) ) Begin
95173>>>                // Make sure last character of error text is a separating symbol.
95173>>>                // if not, add a "." So we have format of "error-text. error-detail"
95173>>>                If (Pos(Right(Full_Error_Text,1),".,:;") =0) ;                    Move (Full_Error_Text - ".") to Full_Error_Text
95176>>>                Move (Full_Error_Text * ErrMsg)  to Full_Error_Text
95177>>>            End
95177>>>>
95177>>>            Else ;                Move ErrMsg to Full_Error_Text
95179>>>            
95179>>>        End
95179>>>>
95179>>>        
95179>>>        Function_Return Full_Error_Text
95180>>>    End_Function
95181>>>
95181>>>    // While we update the database we collect all errors in
95181>>>    // the struct array paDbUpdateErrorArray.
95181>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
95183>>>        Number nVersion
95183>>>        Handle hoLogFile 
95183>>>        
95183>>>        If (Private.pbProcessingError(Self)) Begin
95185>>>            Procedure_Return
95186>>>        End
95186>>>>
95186>>>
95186>>>        // The UtilTableNameFromHandleToString function does a:
95186>>>        // "Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName" call
95186>>>        // and it generates an error if the table is of the embedded type.
95186>>>        // As we don't want to trigger an error in that very specific case,
95186>>>        // we just ignore it here.
95186>>>        //
95186>>>        // If no report mode, just set the err indicator to false.
95186>>>        If (Error_Report_Mode(Self) = DUF_ERROR_NO_REPORT) Begin
95188>>>            Set Private.pbProcessingError to False
95189>>>            Procedure_Return
95190>>>        End
95190>>>>
95190>>>
95190>>>        If (iErrorNumber = DFERR_UNSUPPORTED_ATTRIBUTE) Begin
95192>>>            Set Private.pbProcessingError to False
95193>>>            Procedure_Return
95194>>>        End
95194>>>>
95194>>>
95194>>>        Set Private.pbProcessingError to True
95195>>>        Set Private.pbUpdateVersionObjectError to True
95196>>>
95196>>>        Set pbDbUpdateErrorHasOccured to True
95197>>>        Get pnCurrentVersionUpdate to nVersion
95198>>>        Get phoLogFile to hoLogFile
95199>>>        Send LogError of hoLogFile nVersion iErrorNumber sErrorText iErrorLine True
95200>>>
95200>>>        Set Private.pbProcessingError to False
95201>>>    End_Procedure
95202>>>
95202>>>End_Class
95203>
95203>Object oHtmlHelp is a cHtmlHelp
95205>    Set pbAlwaysOnTop to False
95206>
95206>    // Overriden class message to also handle internet HTML Help links;
95206>    // which in which case we should not try to find the path to the help file.
95206>    Function GetHelpFile Returns String
95209>        String sHelpFile
95209>
95209>        Get psHelpFile of ghoApplication to sHelpFile
95210>        If (sHelpFile <> "" and not(sHelpFile contains "http:")) Begin
95212>            Get_File_Path sHelpFile to sHelpFile
95213>        End
95213>        Function_Return sHelpFile
95214>    End_Function
95215>
95215>End_Object
95216>
95216>Object oApplication is a cApplication
95218>    Set peHelpType to htHtmlHelp
95219>
95219>    // Note: These help file settings gets changed by the Help toolbar button(s).
95219>    Set psHelpFile to "Developer5.chm"
95220>
95220>    Set pbPreserveEnvironment to True
95221>    Set psProduct to "Database Update Framework Lab"
95222>    Set psCompany to "RDC Tools International" 
95223>
95223>    Object oConnection is a cConnection
95225>        Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (C:\Program Files\DataFlex 24.0\Pkg\LoginEncryption.pkg)
95225>>>Use cLoginEncryption.pkg
95225>>>
95225>>>Object oLoginEncryption is a cLoginEncryption
95227>>>
95227>>>    // this must be created in your appsrc directory and must contain an encryption
95227>>>    // key that is set to psEncryptPassword. It will look something like this
95227>>>    //
95227>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
95227>>>    //  
Including file: LoginEncryptionKey.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\LoginEncryptionKey.inc)
95227>>>>// Studio generated login encryption key
95227>>>>Set psEncryptPassword to "%sLm*XHVF>f0yB.:.PHrBx6L)8x70i7zAN{q._WC"
95228>>>>
95228>>>    
95228>>>    // use this to register this object to your cConnection Object. This object
95228>>>    // must be created after the cConnection object
95228>>>    Move Self to ghoLoginEncryption
95229>>>End_Object
95230>        Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (C:\Program Files\DataFlex 24.0\Pkg\DatabaseLoginDialog.dg)
95230>>>
95230>>>Use Windows.pkg
95230>>>Use cConnection.pkg
95230>>>Use dfLine.pkg
95230>>>
95230>>>Object oDatabaseLoginDialog is a ModalPanel
95232>>>    Set Label to "Database Login"
95233>>>    Set Location to 2 2
95234>>>    Set Size to 110 211
95235>>>    
95235>>>    Property String psId
95237>>>    Property Boolean pbOk False
95239>>>    Property Boolean pbChanged False
95241>>>    Property Boolean pbAllowRemember True
95243>>>    
95243>>>    // this registers this object with the cConnection object.
95243>>>    Move Self to ghoLoginConnectDialog
95244>>>    
95244>>>    Object oUserIDForm is a Form
95246>>>        Set Label to "User Name"
95247>>>        Set Size to 12 85
95248>>>        Set Location to 34 79
95249>>>        Set Label_Col_Offset to 64
95250>>>        Set peAnchors to anTopLeftRight
95251>>>    End_Object
95252>>>    
95252>>>    Object oPwdForm is a Form
95254>>>        Set Size to 12 85
95255>>>        Set Location to 49 79
95256>>>        Set Label_Col_Offset to 64
95257>>>        Set Password_State to True
95258>>>        Set peAnchors to anTopLeftRight
95259>>>        Set Label to "Password"
95260>>>    End_Object
95261>>>    
95261>>>    Object oTrustedConnection is a CheckBox
95263>>>        Set Size to 10 50
95264>>>        Set Location to 65 79
95265>>>        Set Label to "Trusted Connection"
95266>>>    End_Object
95267>>>    
95267>>>    Object oRemember is a CheckBox
95269>>>        Set Size to 10 50
95270>>>        Set Location to 79 14
95271>>>        Set Label to "Remember and don't ask again"
95272>>>        Set Checked_State to True
95273>>>    End_Object
95274>>>    
95274>>>    Object oLogin_btn is a Button
95276>>>        Set Label to "&Login"
95277>>>        Set Location to 92 102
95278>>>        Set peAnchors to anBottomRight
95279>>>        Set Default_State to True
95280>>>        
95280>>>        Procedure OnClick
95283>>>            Boolean bTrust
95283>>>            String sUser sPwd sConn sErr sId
95283>>>            Integer iError
95283>>>            Get psId to sId
95284>>>            Get Value of oUserIDForm to sUser
95285>>>            Get Value of oPwdForm to sPwd
95286>>>            Get Checked_State of oTrustedConnection to bTrust
95287>>>            
95287>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
95288>>>            If (iError=0) Begin
95290>>>                Set pbOk to True
95291>>>                Set pbChanged to True
95292>>>                Send Close_Panel
95293>>>            End
95293>>>>
95293>>>            Else Begin
95294>>>                Get psErrorText of ghoConnection to sErr
95295>>>                Send UserError sErr "Login Error"
95296>>>            End
95296>>>>
95296>>>        End_Procedure
95297>>>    End_Object
95298>>>    
95298>>>    Object oCancel_btn is a Button
95300>>>        Set Label to "&Cancel"
95301>>>        Set Location to 92 157
95302>>>        Set peAnchors to anBottomRight
95303>>>        
95303>>>        Procedure OnClick
95306>>>            Send Close_Panel
95307>>>        End_Procedure
95308>>>    End_Object
95309>>>    
95309>>>    Object oConnectionIdInfo is a TextBox
95311>>>        Set Size to 10 50
95312>>>        Set Location to 4 14
95313>>>        Set Label to 'Connection Id='
95314>>>    End_Object
95315>>>    
95315>>>    Object oConnectionServerInfo is a TextBox
95317>>>        Set Size to 10 50
95318>>>        Set Location to 16 14
95319>>>        Set Label to 'Server'
95320>>>    End_Object
95321>>>    
95321>>>    Object oLineControl1 is a LineControl
95323>>>        Set Size to 2 202
95324>>>        Set Location to 29 5
95325>>>    End_Object
95326>>>    
95326>>>    Function LoginConnectIdDialog String sId Returns Boolean
95329>>>        Boolean bOk bChanged bTrusted bAllowRemember bRemember
95329>>>        String sUser sPwd sDescription
95329>>>        tConnection Connect
95329>>>        tConnection Connect
95329>>>        
95329>>>        Get pbAllowRemember to bAllowRemember
95330>>>        
95330>>>        
95330>>>        If not bAllowRemember Begin
95332>>>            Set Enabled_State of oRemember to bRemember
95333>>>            Set Visible_State of oRemember to bRemember
95334>>>        End
95334>>>>
95334>>>        
95334>>>        Get ConnectionIdInfo of ghoConnection sId to Connect
95335>>>        Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
95336>>>        Set Value of oConnectionServerInfo to Connect.sString
95337>>>        
95337>>>        Set psId to sId
95338>>>        Set pbOk to False
95339>>>        Set pbChanged to False
95340>>>        Set Value of oUserIDForm to Connect.sUID
95341>>>        Set Value of oPwdForm to ""
95342>>>        
95342>>>        Send Popup
95343>>>        
95343>>>        Get pbOk to bOk
95344>>>        Get pbChanged to bChanged
95345>>>        If (bChanged and bOk) Begin
95347>>>            If bAllowRemember Begin
95349>>>                Get Checked_State of oRemember to bRemember
95350>>>                If bRemember Begin
95352>>>                    Get Checked_State of oTrustedConnection to bTrusted
95353>>>                    If not (bTrusted) Begin
95355>>>                        Get Value of oUserIDForm to sUser
95356>>>                        Get Value of oPwdForm to sPwd
95357>>>                    End
95357>>>>
95357>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
95358>>>                End
95358>>>>
95358>>>            End
95358>>>>
95358>>>        End
95358>>>>
95358>>>        Function_Return bOk
95359>>>    End_Function
95360>>>    
95360>>>    
95360>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
95361>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
95362>>>End_Object
95363>>>
95363>    End_Object
95364>
95364>End_Object   
95365>
95365>Object oDbUpdateHandler is a cDbUpdateHandler 
95367>    Set piDbVersionFileNumber to 255
95368>    Set piDbVersionFieldNumber to 1
95369>    
95369>End_Object
95370>
95370>Object oCJSkinFramework is a cCJSkinFramework
95372>    Set pbLoadPreference to True
95373>End_Object
95374>
95374>Object oToolTipController is a cToolTipController
95376>    Set piDurationPopup to 10000
95377>    Set piMaxWidth to 500
95378>    Move Self to ghoToolTipController
95379>End_Object
95380>
95380>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files\DataFlex 24.0\Pkg\oEditContextMenu.pkg)
95380>>>Use cCJStandardMenuItemClasses.pkg
95380>>>
95380>>>Object oEditContextMenu is a cCJContextMenu
95382>>>    
95382>>>    Move Self to Default_Form_Floating_Menu_ID
95383>>>    
95383>>>    Object oUndoMenuItem is a cCJUndoMenuItem
95385>>>    End_Object
95386>>>    
95386>>>    Object oCutMenuItem is a cCJCutMenuItem
95388>>>        Set pbControlBeginGroup to True
95389>>>    End_Object
95390>>>    
95390>>>    Object oCopyMenuItem is a cCJCopyMenuItem
95392>>>    End_Object
95393>>>
95393>>>    Object oPasteMenuItem is a cCJPasteMenuItem
95395>>>    End_Object
95396>>>
95396>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
95398>>>    End_Object
95399>>>
95399>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
95401>>>        Set pbControlBeginGroup to True
95402>>>    End_Object
95403>>>
95403>>>End_Object
95404>>>
95404>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files\DataFlex 24.0\Pkg\oDEOEditContextMenu17.pkg)
95404>>>Use Windows.pkg
95404>>>Use cCJStandardMenuItemClasses.pkg
95404>>>Use cCJDeoMenuItemClasses.pkg
95404>>>
95404>>>
95404>>>Object oDEOEditContextMenu17 is a cCJContextMenu
95406>>>    
95406>>>    Move Self to Default_dbFloating_Menu_ID
95407>>>    
95407>>>    Object oUndoMenuItem is a cCJUndoMenuItem
95409>>>    End_Object
95410>>>    
95410>>>    Object oCutMenuItem is a cCJCutMenuItem
95412>>>        Set pbControlBeginGroup to True
95413>>>    End_Object
95414>>>    
95414>>>    Object oCopyMenuItem is a cCJCopyMenuItem
95416>>>    End_Object
95417>>>
95417>>>    Object oPasteMenuItem is a cCJPasteMenuItem
95419>>>    End_Object
95420>>>
95420>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
95422>>>    End_Object
95423>>>
95423>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
95425>>>        Set pbControlBeginGroup to True
95426>>>    End_Object
95427>>>
95427>>>    Object oPromptMenuItem is a cCJPromptMenuItem
95429>>>        Set pbControlBeginGroup to True
95430>>>    End_Object
95431>>>
95431>>>    Object oFindNextMenu is a cCJFindNextMenuItem
95433>>>        Set pbControlBeginGroup to True
95434>>>    End_Object
95435>>>
95435>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
95437>>>    End_Object
95438>>>
95438>>>    Object oClearMenuItem is a cCJClearMenuItem
95440>>>        Set pbControlBeginGroup to True
95441>>>    End_Object
95442>>>
95442>>>    Object oClearAllMenu is a cCJClearAllMenuItem
95444>>>    End_Object
95445>>>
95445>>>    Object oSaveMenu is a cCJSaveMenuItem
95447>>>    End_Object
95448>>>    
95448>>>    Object oDeleteMenu is a cCJDeleteMenuItem
95450>>>    End_Object
95451>>>
95451>>>    Object oRememberitem is a cCJRememberFieldMenuItem
95453>>>        Set pbControlBeginGroup to True
95454>>>    End_Object
95455>>>
95455>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
95457>>>    End_Object
95458>>>
95458>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
95460>>>    End_Object
95461>>>
95461>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
95463>>>    End_Object
95464>>>
95464>>>End_Object
95465>Use cSkinComboBoxCJMenuItem.pkg
Including file: cSkinComboBoxCJMenuItem.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cSkinComboBoxCJMenuItem.pkg)
95465>>>Use cCJCommandBarSystem.pkg
95465>>>Use Wingdi.pkg
95465>>>Use LanguageText.pkg
95465>>>
95465>>>// User interface constant strings:
95465>>>Define CS_NoSkinShort For "-None"
95465>>>Define CS_NoSkinLong  For "Do not use a skin"
95465>>>
95465>>>
95465>>>
95465>>>
95465>>>
95465>>>
95465>>>
95465>>>
95465>>>
95465>>>
95465>>>Class cSkinComboBoxCJMenuItem is a cCJMenuItem
95466>>>
95466>>>    Procedure Construct_Object
95468>>>        Forward Send Construct_Object
95470>>>
95470>>>        Set peControlType to xtpControlComboBox
95471>>>
95471>>>        Property tSkinInformation[] pSkins
95472>>>
95472>>>    End_Procedure
95473>>>
95473>>>    Procedure End_Construct_Object
95475>>>        Forward Send End_Construct_Object
95477>>>    End_Procedure
95478>>>
95478>>>    // Custom array sort for the tSkinInformation struct array.
95478>>>    // Used by LoadSkins message to sort the skin array alphabetically after it has been loaded.
95478>>>    // Why?
95478>>>    // First of all, structs can't be used with the standard SortArray function, that is why we need to
95478>>>    // create a custom sort algorithm.
95478>>>    // Secondly the list of skins would else be sorted in the alphabetical order by the file names.
95478>>>    // However, it is not always the case that the skin description (sName) is the same as the file name.
95478>>>    // If it isn't (which is almost always the case if you have many skin files) the list will look
95478>>>    // randomly ordered. This custom sort method will take care of that.
95478>>>    Function SkinSort tSkinInformation sDescription tSkinInformation sSearchDescription Returns Integer
95480>>>        If ((sDescription.sName * sDescription.sSkinIni) > (sSearchDescription.sName * sSearchDescription.sSkinIni)) Begin
95482>>>            Function_Return (GT)
95483>>>        End
95483>>>>
95483>>>        If ((sDescription.sName * sDescription.sSkinIni) < (sSearchDescription.sName * sSearchDescription.sSkinIni)) Begin
95485>>>            Function_Return (LT)
95486>>>        End
95486>>>>
95486>>>        Function_Return (EQ)
95487>>>    End_Function
95488>>>
95488>>>    Procedure OnCreateControl Handle hoObj
95490>>>        Forward Send OnCreateControl hoObj
95492>>>
95492>>>        Send LoadSkins
95493>>>        Send FillComboList hoObj
95494>>>    End_Procedure
95495>>>
95495>>>    // Load all skins. We will only look for skins in expected
95495>>>    // directory which is the Programs folder.
95495>>>    // Important: When loading skins they will be sorted alphabetically. (See Skinsort function above).
95495>>>    // This is not the case with the 'standard' VDF behaviour.
95495>>>    Procedure LoadSkins
95497>>>        Integer iCount iItems iSize
95497>>>        Boolean bFound
95497>>>        String sFile sIni sSkin
95497>>>        tSkinInformation[] SkinsArray SkinsArrayNoLarge
95497>>>        tSkinInformation[] SkinsArray SkinsArrayNoLarge
95499>>>        tSkinInformation NoneRow
95499>>>        tSkinInformation NoneRow
95499>>>
95499>>>        If (ghoSkinFramework > 0) Begin
95501>>>            Get EnumerateSkins of ghoSkinFramework "" True   to SkinsArray
95502>>>
95502>>>            Move (SortArray(SkinsArray, Self, get_SkinSort)) to SkinsArray
95503>>>            Move CS_NoSkinShort to NoneRow.sName
95504>>>            Move CS_NoSkinLong  to NoneRow.sSkinfile
95505>>>            Move CS_NoSkinLong  to NoneRow.sSkinIni
95506>>>            Move (InsertInArray(SkinsArray, 0, NoneRow))     to SkinsArray
95507>>>
95507>>>            // Get the currently loaded skin.
95507>>>            Get psSkinFile of ghoSkinFramework to sFile
95508>>>            Get psSkinIni  of ghoSkinFramework to sIni
95509>>>
95509>>>            // Remove all Extra Large and Large skins from the array.
95509>>>            Move (SizeOfArray(SkinsArray)) to iItems
95510>>>            Decrement iItems
95511>>>            For iCount From 0 to iItems
95517>>>>
95517>>>                Move SkinsArray[iCount].sSkinIni to sSkin
95518>>>                Move (Uppercase(sSkin) contains " LARGE") to bFound
95519>>>                If (bFound = False) Begin
95521>>>                    Move (SizeOfArray(SkinsArrayNoLarge)) to iSize
95522>>>                    Move SkinsArray[iCount].sName         to SkinsArrayNoLarge[iSize].sName
95523>>>                    Move SkinsArray[iCount].sSkinfile     to SkinsArrayNoLarge[iSize].sSkinfile
95524>>>                    Move SkinsArray[iCount].sSkinIni      to SkinsArrayNoLarge[iSize].sSkinIni
95525>>>                End
95525>>>>
95525>>>            Loop
95526>>>>
95526>>>            Set pSkins to SkinsArrayNoLarge
95527>>>        End
95527>>>>
95527>>>    End_Procedure
95528>>>
95528>>>    // Fills the CodeJock combobox with all skins from the current Programs folder.
95528>>>    Procedure FillComboList Handle hoCombo
95530>>>        Integer iCount iItems iCurrent iTxtEntentSize
95530>>>        String  sFile sIni sCurrSkin
95530>>>        String  sSkin sSkinText
95530>>>        tSkinInformation[] SkinsArray
95530>>>        tSkinInformation[] SkinsArray
95531>>>        Integer iSize
95531>>>
95531>>>        If (ghoSkinFramework < 1) Begin
95533>>>            Procedure_Return
95534>>>        End
95534>>>>
95534>>>
95534>>>        // Get the currently loaded skin.
95534>>>        Get psSkinFile of ghoSkinFramework to sFile
95535>>>        Get psSkinIni  of ghoSkinFramework to sIni
95536>>>        Get pSkins to SkinsArray
95537>>>        Move (SizeOfArray(SkinsArray)) to iItems
95538>>>        Decrement iItems
95539>>>        Send ComClear of hoCombo
95540>>>
95540>>>        For iCount From 0 to iItems
95546>>>>
95546>>>            Move SkinsArray[iCount].sSkinIni  to sSkin
95547>>>            Move (Replace(".ini", sSkin, "")) to sSkin
95548>>>            Move (SkinsArray[iCount].sName * "-" * sSkin) to sSkinText
95549>>>            Send ComAddItem of hoCombo sSkinText (iCount +1)
95550>>>            Get Text_Extent sSkinText to iSize
95551>>>            If (iSize > iTxtEntentSize) Begin
95553>>>                Move iSize to iTxtEntentSize
95554>>>            End
95554>>>>
95554>>>            Move (SkinsArray[iCount].sSkinFile * "-" * SkinsArray[iCount].sSkinIni) to sCurrSkin
95555>>>            If (sCurrSkin = (sFile * "-" * sIni)) Begin
95557>>>                Move iCount to iCurrent
95558>>>            End
95558>>>>
95558>>>        Loop
95559>>>>
95559>>>
95559>>>        Move (Low(iTxtEntentSize) + 30)  to iSize
95560>>>        Set ComDropDownWidth of hoCombo  to iSize
95561>>>        Set ComWidth         of hoCombo  to (iSize + 100)
95562>>>        Set ComListIndex     of hoCombo  to (iCurrent +1)
95563>>>    End_Procedure
95564>>>
95564>>>    // Event for when an item is selected from the comboform
95564>>>    Procedure OnExecute Variant vCommandBarControl
95566>>>        Handle  hoCombo
95566>>>        Integer iSelection
95566>>>        String  sSkinFile sSkinIni
95566>>>        tSkinInformation[] SkinsArray
95566>>>        tSkinInformation[] SkinsArray
95567>>>
95567>>>        // Create and bind proxy control
95567>>>        Get CreateProxyControl vCommandBarControl to hoCombo
95568>>>        // Get the current selection
95568>>>        Get ComListIndex of hoCombo to iSelection
95569>>>        Decrement iSelection
95570>>>        Get pSkins to SkinsArray
95571>>>        Move SkinsArray[iSelection].sSkinfile to sSkinFile
95572>>>        Move SkinsArray[iSelection].sSkinIni  to sSkinIni
95573>>>
95573>>>        Send DoChangeSkin sSkinFile sSkinIni
95574>>>
95574>>>        // Dispose of the proxy control
95574>>>        Send Destroy of hoCombo
95575>>>    End_Procedure
95576>>>
95576>>>    // Send this message to change the current skin.
95576>>>    Procedure DoChangeSkin String sSkinFile String sSkinIni
95578>>>        Handle hoClient
95578>>>
95578>>>        Set psSkinFile of ghoSkinFramework to sSkinFile
95579>>>        Set psSkinIni  of ghoSkinFramework to sSkinIni
95580>>>        Send ApplySkin of ghoSkinFramework
95581>>>
95581>>>        // Note: The following line is essential for the resizing logic
95581>>>        // to function properly when changing a skin and a view is maximized.
95581>>>        Move (Client_Id(phoMainPanel(ghoApplication))) to hoClient
95582>>>        Set Size of hoClient to (Hi(Size(hoClient))) (Low(Size(hoClient) +2))
95583>>>        Set Size of hoClient to (Hi(Size(hoClient))) (Low(Size(hoClient) -2))
95584>>>    End_Procedure
95585>>>
95585>>>    // Returns: DPI setting as an integer.
95585>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
95585>>>    //                      iDPI=120 is "Medium setting" 125%
95585>>>    //                      iDPI= 144 is "Large setting" 150%
95585>>>    Function GetCurrentDPI Returns Integer
95587>>>        Handle hDC
95587>>>        Integer iPixelsX
95587>>>        Move (GetDC(0)) to hDC
95588>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
95589>>>        Move (ReleaseDC(0, hDC)) to hDC
95590>>>        Function_Return iPixelsX
95591>>>    End_Function
95592>>>
95592>>>End_Class
95593>
95593>Object oMain is a Panel
95595>    Set Label to "Test Program - The Database Update Framework"
95596>    Set Location to 2 2
95597>    Set Size to 309 493
95598>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
95599>    Set Icon to "TestTools.ico"
95600>
95600>    Property Handle phoViewMenu 0
95602>    Property Handle phoReportMenu 0
95604>
95604>    Object oCommandBarSystem is a cCJCommandBarSystem
95606>        Set pbTimerUpdate to True
95607>            Set pbAutoResizeIcons to True
95608>            Set pbTabbedWorkspaces to True // Switch on for DF 19 to see the new tabbed-view look.
95609>            Set peVisualTheme to xtpThemeOffice2013Publisher
95610>            Set pbLargeIcons to True
95611>
95611>        Procedure OnCreateCommandBars
95614>            Handle hoOptions
95614>            Forward Send OnCreateCommandBars
95616>                Get OptionsObject to hoOptions
95617>                Send ComSetIconSize of hoOptions False 32 32  // Set icon size for Toolbar buttons.
95618>        End_Procedure
95619>
95619>
95619>    Procedure OnCreateTabbedWorkspace Handle hoTabWorkspace Handle hoTabPaintManager
95622>        Set ComShowIcons of hoTabPaintManager to True
95623>
95623>        // This will truncate the middle part of long items
95623>        Set ComDrawTextPathEllipsis of hoTabPaintManager to True
95624>    End_Procedure
95625>
95625>        // This is needed to get the "Key_Shift+Key_Tab" key combination to activate
95625>        // the previous tab workspace view.
95625>        Object oPreviousTabAction is a cCJAction
95627>            Set piShortCutKey to (xtpKey_Shift + xtpKey_Ctrl) VK_TAB
95628>            Procedure OnExecute Variant vCommandBarControl
95631>                Handle hoCommandBars hoClientArea
95631>                Forward Send OnExecute vCommandBarControl
95633>                Get CommandBarSystemObject to hoCommandBars
95634>                Get ClientAreaObject of hoCommandBars to hoClientArea
95635>                If hoClientArea Begin
95637>                    Send Switch_Next_View of hoClientArea
95638>                End
95638>            End_Procedure
95639>        End_Object
95640>
95640>        Object oToolBar is a cCJToolbar
95642>            Set psTitle to "Edit Toolbar"
95643>            Set pbGripper to False
95644>            Set peStretched to stStretch
95645>
95645>            Object oCutToolbarItem is a cCJCutMenuItem  
95647>                Set psImage to "ActionCut.ico"
95648>            End_Object
95649>
95649>            Object oCopyToolbarItem is a cCJCopyMenuItem
95651>                Set psImage to "ActionCopy.ico"
95652>            End_Object
95653>
95653>            Object oPasteToolbarItem is a cCJPasteMenuItem
95655>                Set psImage to "ActionPaste.ico"
95656>            End_Object
95657>
95657>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
95659>                Set psImage to "ActionDelete.ico"
95660>                Set pbControlBeginGroup to True
95661>            End_Object
95662>
95662>            Object oTheme_tb is a cCJMenuItem
95664>                Set peControlType to xtpControlLabel
95665>                Set psCaption to "Theme:"
95666>                Set pbControlBeginGroup to True
95667>            End_Object
95668>
95668>            Object oThemeItem is a cCJMenuItem
95670>                Set peControlType to xtpControlComboBox
95671>                Set psToolTip to "Select a theme to change the appearance of menu- and toolbars."
95672>
95672>                Procedure OnCreateControl Handle hoObj
95675>                    Integer iItem eTheme
95675>                    Set ComWidth of hoObj to 250
95676>                    Send FillComboList hoObj
95677>                    Get peVisualTheme to eTheme
95678>                    Get FindDataItem hoObj eTheme to iItem
95679>                    Set ComListIndex of hoObj to (If(iItem,iItem,1))
95680>                End_Procedure
95681>
95681>                Function FindDataItem Handle hoCombo Integer eVal Returns Integer
95684>                    Integer iCount i eTheme
95684>                    Get ComListCount of hoCombo to iCount
95685>                    For i from 1 to iCount
95691>                        Get ComItemData of hoCombo i to eTheme
95692>                        If (eTheme=eVal) Begin
95694>                            Send SetTheTheme eTheme
95695>                            Function_Return i
95696>                        End
95696>                    Loop
95697>                    Function_Return 0
95698>                End_Function
95699>
95699>                Procedure AddTheme Handle hoCombo String sText Integer eTheme
95702>                    Integer iCount
95702>                    Get ComListCount of hoCombo to iCount
95703>                    Increment iCount
95704>                    Send ComAddItem  of hoCombo sText iCount
95705>                    Set ComItemData  of hoCombo iCount to  eTheme
95706>                End_Procedure
95707>
95707>                Procedure FillComboList Handle hoCombo
95710>                    Send ComClear     of hoCombo
95711>                        Send AddTheme hoCombo "xtpThemeOffice2013Word" xtpThemeOffice2013Word
95712>                        Send AddTheme hoCombo "xtpThemeOffice2013Outlook" xtpThemeOffice2013Outlook
95713>                        Send AddTheme hoCombo "xtpThemeOffice2013Excel" xtpThemeOffice2013Excel
95714>                        Send AddTheme hoCombo "xtpThemeOffice2013PowerPoint" xtpThemeOffice2013PowerPoint
95715>                        Send AddTheme hoCombo "xtpThemeOffice2013Publisher" xtpThemeOffice2013Publisher
95716>                        Send AddTheme hoCombo "xtpThemeOffice2013OneNote" xtpThemeOffice2013OneNote
95717>                        Send AddTheme hoCombo "xtpThemeOffice2013Access" xtpThemeOffice2013Access
95718>                        Send AddTheme hoCombo "xtpThemeOffice2003" xtpThemeOffice2003
95719>                        Send AddTheme hoCombo "xtpThemeOffice2000" xtpThemeOffice2000
95720>                        Send AddTheme hoCombo "xtpThemeOfficeXP" xtpThemeOfficeXP
95721>    
95721>                        Send AddTheme hoCombo "xtpThemeOffice2010Blue" xtpThemeOffice2010Blue
95722>                        Send AddTheme hoCombo "xtpThemeOffice2010Black" xtpThemeOffice2010Black
95723>                        Send AddTheme hoCombo "xtpThemeOffice2010Silver" xtpThemeOffice2010Silver
95724>    
95724>                        Send AddTheme hoCombo "xtpThemeOffice2007Aqua" xtpThemeOffice2007Aqua
95725>                        Send AddTheme hoCombo "xtpThemeOffice2007Black" xtpThemeOffice2007Black
95726>                        Send AddTheme hoCombo "xtpThemeOffice2007Blue" xtpThemeOffice2007Blue
95727>                        Send AddTheme hoCombo "xtpThemeOffice2007Silver" xtpThemeOffice2007Silver
95728>    
95728>                        Send AddTheme hoCombo "xtpThemeVisualStudio2015Blue" xtpThemeVisualStudio2015Blue
95729>                        Send AddTheme hoCombo "xtpThemeVisualStudio2015Light" xtpThemeVisualStudio2015Light
95730>                        Send AddTheme hoCombo "xtpThemeVisualStudio2015Dark" xtpThemeVisualStudio2015Dark
95731>    
95731>                        Send AddTheme hoCombo "xtpThemeVisualStudio2012Light" xtpThemeVisualStudio2012Light
95732>                        Send AddTheme hoCombo "xtpThemeVisualStudio2012Dark" xtpThemeVisualStudio2012Dark
95733>    
95733>                        Send AddTheme hoCombo "xtpThemeVisualStudio2008" xtpThemeVisualStudio2008
95734>                        Send AddTheme hoCombo "xtpThemeVisualStudio6" xtpThemeVisualStudio6
95735>    
95735>                        Send AddTheme hoCombo "xtpThemeWindows7" xtpThemeWindows7
95736>    
95736>                        Send AddTheme hoCombo "xtpThemeWhidbey" xtpThemeWhidbey
95737>    
95737>                        Send AddTheme hoCombo "xtpThemeNativeWinXP" xtpThemeNativeWinXP
95738>                End_Procedure
95739>
95739>                Function CurrentTheme Handle vCommandBarControl Returns Integer
95742>                    Handle hMessage hoCombo
95742>                    Integer iIndex
95742>                    // create and bind  proxy control
95742>                    Get CreateProxyControl vCommandBarControl to hoCombo
95743>                    // get the current selection
95743>                    Get ComListIndex of hoCombo to iIndex
95744>                    // note the index selections are 1 based
95744>                    If (iIndex > 0) Begin
95746>                        // get the ItemData for the selected item and send that message
95746>                        Get ComItemData of hoCombo iIndex to hMessage
95747>                        Function_Return hMessage
95748>                    End
95748>                    // dispose of the proxy control
95748>                    Send Destroy of hoCombo
95749>                    Function_Return 0
95750>                End_Function
95751>
95751>                Procedure OnExecute Variant vCommandBarControl
95754>                    Integer eTheme
95754>                    Integer iColor
95754>                    Get CurrentTheme vCommandBarControl to eTheme
95755>                    Set peVisualTheme of ghoCommandBars to eTheme
95756>                    Send ComRecalcLayout of ghoCommandBars
95757>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
95758>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
95760>                End_Procedure
95761>
95761>                Procedure SetTheTheme Integer eTheme
95764>                    Integer iColor
95764>                    Set peVisualTheme of ghoCommandBars to eTheme
95765>                    Send ComRecalcLayout of ghoCommandBars
95766>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
95767>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
95769>                End_Procedure
95770>
95770>                Function ConvertSystemColor Integer iColor Returns Integer
95773>                    Integer iSysColor
95773>                    If (iColor = clDefault or iColor = clNone) Begin    // If default color then use -1
95775>                        Move clNone to iColor
95776>                    End
95776>                    Else If (iColor < 0) Begin    // If it is a system color (<0) then convert this into an RGB value
95779>                        Move (iColor iand |CI$7FFFFFFF) to iSysColor    // extract the system color constant
95780>                        Move (GetSysColor(iSysColor)) to iColor
95781>                    End
95781>                    Function_Return iColor
95782>                End_Function
95783>
95783>            End_Object
95784>
95784>            Object oAbout_MenuItem is a cCJMenuItem
95786>                Set psCaption to "About"
95787>                Set psToolTip to "About Info"
95788>                Set psDescription to "About the program"
95789>                Set psImage to "ActionAbout.ico"
95790>                Set pbControlBeginGroup to True
95791>                Procedure OnExecute Variant vCommandBarControl
95794>                    Forward Send OnExecute vCommandBarControl
95796>                    Send Activate_About of (Client_Id(ghoCommandBars))
95797>                End_Procedure
95798>            End_Object
95799>
95799>            Object oHelpMenuItem is a cCJHelpMenuItem
95801>                Set peControlType to xtpControlSplitButtonPopup
95802>                Set psImage to "ActionHelp.ico"
95803>
95803>                Procedure OnExecute Variant vCommandBarControl
95806>                    Forward Send OnExecute vCommandBarControl
95808>                    Set psHelpFile of ghoApplication to "DataFlex.chm"
95809>                    Send ShowProgramHelp
95810>                End_Procedure
95811>
95811>                Object oHelpMenuItemLocal is a cCJMenuItem
95813>                    Set psCaption to "Local HTML Help"
95814>                    Set psImage to "ActionHelp.ico"
95815>                    Procedure OnExecute Variant vCommandBarControl
95818>                        Set psHelpFile of ghoApplication to "DataFlex.chm"
95819>                        Send ShowProgramHelp
95820>                    End_Procedure
95821>                End_Object
95822>
95822>                Object oHelpMenuItemInternetBrowser is a cCJMenuItem
95824>                    Set psCaption to "Internet Online HTML Help"
95825>                    Set psImage to "ActionHelp.ico"
95826>                    Procedure OnExecute Variant vCommandBarControl
95829>                        Send vShellExecute "open" "http://www.rdctools.com/HTMLHelp/Developer5.htm" "" ""
95830>                    End_Procedure
95831>
95831>                End_Object
95832>            End_Object
95833>
95833>            Object oExitMenuItem is a cCJExitMenuItem
95835>                Set psImage to "ActionExit.ico"
95836>                Set psToolTip to "Exit application"
95837>                Set psDescription to "Exit the program (Alt+F4)"
95838>                Set pbControlBeginGroup to True
95839>            End_Object
95840>        End_Object
95841>
95841>//        Object oSpacerBar is a cCJToolbar
95841>//            Set pbDockNextTo to False
95841>//            Set pbShowExpandButton to False
95841>//            Set pbGripper to False
95841>//            Set peStretched to stStretch
95841>//            Set pbCustomizable to False
95841>//            Set pbCloseable to False
95841>//            Set pbEnableDocking to False
95841>//            Set pbHideWrap to True
95841>//
95841>//            Object oFiller is a cCJMenuItem
95841>//            End_Object
95841>//
95841>//        End_Object
95841>
95841>        Object oStatusBar is a cCJStatusBar
95843>
95843>            Object oStatusPane1 is a cCJStatusBarPane
95845>                Set piID to sbpIDIdlePane
95846>                Set pbStyleStretch to True
95847>            End_Object
95848>            Object oStatusPane2 is a cCJStatusBarPane
95850>                Set phoViewPane to Self
95851>                Set pbStyleStretch to True
95852>            End_Object
95853>
95853>        End_Object
95854>
95854>    End_Object
95855>
95855>    Object oClientArea is a ClientArea
95857>
95857>//        Use Dd_debug.dg // This Provides access to dd debugger by pressing ctrl+d within any view. Good for debugging
95857>
95857>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\StdAbout.pkg)
95857>>>// This provides a quick and simple way to create an about package for a program.
95857>>>// You need to create a message inside you client area called Activate_About.
95857>>>// Within this message you should send the message DoAbout passing needed
95857>>>// string information.
95857>>>//
95857>>>//       Procedure Activate_About
95857>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
95857>>>//       End_Procedure
95857>>>//    where: sTitle =     Name of application. If none provided, uses caption
95857>>>//                        bar title
95857>>>//           sVersion   = Version Line. If none provided, will be blank
95857>>>//           sCopyRight = Copyright Line. If none provided, will be blank
95857>>>//           sAuthor    = Author name, blank if none provided
95857>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
95857>>>//                        is used.
95857>>>// It is expected that you will place this in your own object package. For
95857>>>// example an order about package may look like this:
95857>>>//
95857>>>//   // OrderAbout.pkg
95857>>>//   Use StdAbout.pkg
95857>>>//   Procedure Activate_About
95857>>>//      String sTitle sCopyright sVersion sAuthor
95857>>>//      Move "My Order Entry System" to sTitle
95857>>>//      Move "Version 2.1" to sVersion
95857>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
95857>>>//      Move "John Smith"  to sAuthor
95857>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
95857>>>//   end_procedure
95857>>>//   // end of file.
95857>>>
95857>>>Use DfAbout.pkg
95857>>>
95857>>>// *************************************************************************
95857>>>//  Public message. This is the default message. It is expected that you will
95857>>>//   create your own message to override this
95857>>>// *************************************************************************
95857>>>
95857>>>Procedure Activate_About
95860>>>    Send DoAbout "" "" "" "" "" "" "" "" "" ""
95861>>>End_Procedure
95862>>>
95862>>>// *************************************************************************
95862>>>//  Public message. It is expected that you will send this message (most
95862>>>//  likely from Activate_About. This creates an about object, activates it
95862>>>//  and destroys it when done. It is not exepected that you will augment this.
95862>>>// *************************************************************************
95862>>>// Sample usage:
95862>>>//   The first two params will automatically be filled from the application settings if not provided.
95862>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
95862>>>
95862>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;    String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
95865>>>    Integer hoObj hoMain iArgs
95865>>>    String sValue
95865>>>
95865>>>    // Create object
95865>>>    Object About is an AboutDialog
95867>>>    // Uncomment these two lines if you would like to have a resizable About object.
95867>>>    //            Set Border_Style to Border_Thick
95867>>>    //            Set peAnchors to anAll
95867>>>
95867>>>    // Add checking for the number of arguments passed to avoid runtime errors
95867>>>    // if one of them is not passed. This makes the interface
95867>>>    // more flexible.
95867>>>        Move num_arguments to iArgs
95868>>>
95868>>>        // If no title is passed use the label of the main panel (if a main panel exists).
95868>>>        If (iArgs > 0 and sTitle = "") Begin
95870>>>            Get Main_Window of Desktop to hoMain
95871>>>            If hoMain Begin
95873>>>                Get Label of hoMain to sValue
95874>>>            End
95874>>>>
95874>>>        End
95874>>>>
95874>>>        Else If (iArgs > 0 and sTitle <> "") Begin
95877>>>            Move sTitle to sValue
95878>>>        End
95878>>>>
95878>>>        Else If (iArgs = 0) Begin
95881>>>            Get Main_Window of Desktop to hoMain
95882>>>            If hoMain Begin
95884>>>                Get Label of hoMain to sValue
95885>>>            End
95885>>>>
95885>>>        End
95885>>>>
95885>>>
95885>>>        If (sValue <> "") Begin
95887>>>            Send Add_LineLn sValue
95888>>>        End
95888>>>>
95888>>>        Move "" to sValue
95889>>>
95889>>>        // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
95889>>>        // For this to work the Project Properties Version must have been set in the Studio.
95889>>>        If (iArgs < 2) Begin
95891>>>            Move "" to sValue
95892>>>        End
95892>>>>
95892>>>        Else Begin
95893>>>            Move sVersion to sValue
95894>>>        End
95894>>>>
95894>>>        Set Version to sValue
95895>>>
95895>>>        If (iArgs > 2 and sCopyRight <> "") Begin
95897>>>            Send Add_LineLn sCopyRight
95898>>>        End
95898>>>>
95898>>>
95898>>>        // If only the five "standard" params were passed we don't add an extra linefeed;
95898>>>        // else we do.
95898>>>        If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
95900>>>            Send Add_Line sAuthor
95901>>>        End
95901>>>>
95901>>>        Else If (iArgs > 5 and sAuthor <> "") Begin
95904>>>            Send Add_LineLn sAuthor
95905>>>        End
95905>>>>
95905>>>
95905>>>        // Square bitmaps of 80x80 works best
95905>>>        If (iArgs > 4 and sBitmap <> "") Begin
95907>>>            Set Logo to sBitMap
95908>>>        End
95908>>>>
95908>>>
95908>>>        // Here starts handling of the five optional params:
95908>>>        If (iArgs = 6 and sParam6  <> "") Begin
95910>>>            Send Add_Line sParam6
95911>>>        End
95911>>>>
95911>>>        Else If (iArgs > 6 and sParam6  <> "") Begin
95914>>>            Send Add_LineLn sParam6
95915>>>        End
95915>>>>
95915>>>
95915>>>        If (iArgs = 7 and sParam7  <> "") Begin
95917>>>            Send Add_Line sParam7
95918>>>        End
95918>>>>
95918>>>        Else If (iArgs > 7 and sParam7  <> "") Begin
95921>>>            Send Add_LineLn sParam7
95922>>>        End
95922>>>>
95922>>>
95922>>>        If (iArgs = 8 and sParam8  <> "") Begin
95924>>>            Send Add_Line sParam8
95925>>>        End
95925>>>>
95925>>>        Else If (iArgs > 8 and sParam8  <> "") Begin
95928>>>            Send Add_LineLn sParam8
95929>>>        End
95929>>>>
95929>>>
95929>>>        If (iArgs = 9 and sParam9  <> "") Begin
95931>>>            Send Add_Line sParam9
95932>>>        End
95932>>>>
95932>>>        Else If (iArgs > 9 and sParam9  <> "") Begin
95935>>>            Send Add_LineLn sParam9
95936>>>        End
95936>>>>
95936>>>
95936>>>        If (iArgs = 10 and sParam10 <> "") Begin
95938>>>            Send Add_Line sParam10
95939>>>        End
95939>>>>
95939>>>
95939>>>        Move Self to hoObj
95940>>>    End_Object
95941>>>
95941>>>    Send Popup   of hoObj // Popup the about object
95942>>>    Send Destroy of hoObj // When done, it will be destroyed
95943>>>End_Procedure
95944>        Use DatabaseSelection.dg
Including file: DatabaseSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DatabaseSelection.dg)
95944>>>Use Windows.pkg
95944>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJGridPromptList.pkg)
95944>>>>>Use Windows.pkg
95944>>>>>Use cCJGrid.pkg
95944>>>>>Use umPromptRelational.pkg
95944>>>>>
95944>>>>>Class cCJGridPromptList is a cCJGrid
95945>>>>>    
95945>>>>>    Procedure Construct_Object
95947>>>>>        Forward Send Construct_Object
95949>>>>>        
95949>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
95950>>>>>        Property Boolean Private_pbAutoOrdering True
95951>>>>>        Property Boolean pbAutoSearch True  // pops up search window
95952>>>>>        Property Integer peUpdateMode umPromptValue
95953>>>>>        Property Integer piUpdateColumn 0
95954>>>>>        Property Integer piInitialColumn -1
95955>>>>>        Property String  psSeedValue ''
95956>>>>>        Property Handle phmPromptUpdateCallback 0
95957>>>>>        Property Integer phoInvokingObject
95958>>>>>        
95958>>>>>        Property Boolean pbStoredAutoSeed
95959>>>>>        Property Boolean pbStoredAutoOrdering
95960>>>>>        Property Boolean pbStoredAutoSearch
95961>>>>>        Property Integer peStoredUpdateMode
95962>>>>>        Property Integer piStoredUpdateColumn
95963>>>>>        Property Integer piStoredInitialColumn
95964>>>>>        Property Handle  phmStoredPromptUpdateCallback
95965>>>>>        Property Boolean pbStoredSelectionEnable
95966>>>>>        Property Boolean pbStoredMultipleSelection
95967>>>>>        
95967>>>>>        // internally set by list
95967>>>>>        // these must be set upon closing the list and can be used for manual list updates
95967>>>>>        Property Boolean pbCanceled
95968>>>>>        Property Integer[] pSelectedRows
95969>>>>>        
95969>>>>>        Property Boolean pbNeedsNewOrdering
95970>>>>>        Property Boolean pbRequestSearch
95971>>>>>        Property tGridKeyPair[] pSearchKeys
95972>>>>>        
95972>>>>>        // these properties makes a prompt list a prompt list
95972>>>>>        // and should not be changed.
95972>>>>>        Set pbEditOnKeyNavigation to False
95973>>>>>        Set pbEditOnClick to False
95974>>>>>        Set pbReadOnly to True
95975>>>>>        Set pbFocusSubItems to True
95976>>>>>        
95976>>>>>        // these could maybe be changed
95976>>>>>        Set pbShadeSortColumn to True
95977>>>>>        Set pbHeaderReorders to True
95978>>>>>        Set pbHeaderTogglesDirection to True
95979>>>>>        Set pbHeaderSelectsColumn to True
95980>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
95981>>>>>        Set piFocusCellBackColor to clNone
95982>>>>>        Set piFocusCellForeColor to clNone
95983>>>>>        Set piFocusCellRectangleColor to clBlack
95984>>>>>        Set pbUseFocusCellRectangle to False
95985>>>>>        Set pbSelectionEnable to True
95986>>>>>        
95986>>>>>        On_Key kEnter Send Ok
95987>>>>>        On_Key kCancel Send Cancel
95988>>>>>        
95988>>>>>    End_Procedure
95989>>>>>    
95989>>>>>    // reorder list automatically on column change
95989>>>>>    // this also set pbFocusSubItems which is required to make the two states work
95989>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
95991>>>>>        Set Private_pbAutoOrdering to bAutoOrder
95992>>>>>        Set pbFocusSubItems to bAutoOrder
95993>>>>>    End_Procedure
95994>>>>>    
95994>>>>>    Function pbAutoOrdering Returns Boolean
95996>>>>>        Boolean bAutoOrder
95996>>>>>        Get Private_pbAutoOrdering to bAutoOrder
95997>>>>>        Function_Return bAutoOrder
95998>>>>>    End_Function
95999>>>>>    
95999>>>>>    // augmented to handle auto-ordering and invoking the search popup list
95999>>>>>    Procedure OnIdle
96001>>>>>        Boolean bNeedsReorder bSearch bOldToggle
96001>>>>>        Handle hoCol
96001>>>>>        Integer iKy1 iKy2 iCol
96001>>>>>        
96001>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
96002>>>>>        If bNeedsReorder Begin
96004>>>>>            Get SelectedColumn to iCol
96005>>>>>            If (iCol<>-1) Begin
96007>>>>>                
96007>>>>>                Get pbHeaderTogglesDirection to bOldToggle
96008>>>>>                Set pbHeaderTogglesDirection to False
96009>>>>>                Send HeaderReorder iCol
96010>>>>>                Set pbHeaderTogglesDirection to bOldToggle
96011>>>>>                
96011>>>>>                Set pbNeedsNewOrdering to False
96012>>>>>            End
96012>>>>>>
96012>>>>>        End
96012>>>>>>
96012>>>>>        
96012>>>>>        Get pbRequestSearch to bSearch
96013>>>>>        If bSearch Begin
96015>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
96016>>>>>        End
96016>>>>>>
96016>>>>>        
96016>>>>>        Forward Send OnIdle
96018>>>>>    End_Procedure
96019>>>>>    
96019>>>>>    Procedure OnStoreDefaults
96021>>>>>        Integer iVal
96021>>>>>        Boolean bVal
96021>>>>>        
96021>>>>>        Get pbAutoSeed to bVal
96022>>>>>        Set pbStoredAutoSeed to bVal
96023>>>>>        
96023>>>>>        Get pbAutoOrdering to bVal
96024>>>>>        Set pbStoredAutoOrdering to bVal
96025>>>>>        
96025>>>>>        Get pbAutoSearch to bVal
96026>>>>>        Set pbStoredAutoSearch to bVal
96027>>>>>        
96027>>>>>        Get peUpdateMode to iVal
96028>>>>>        Set peStoredUpdateMode to iVal
96029>>>>>        
96029>>>>>        Get piUpdateColumn to iVal
96030>>>>>        Set piStoredUpdateColumn to iVal
96031>>>>>        
96031>>>>>        Get piInitialColumn to iVal
96032>>>>>        Set piStoredInitialColumn to iVal
96033>>>>>        
96033>>>>>        Get phmPromptUpdateCallback to iVal
96034>>>>>        Set phmStoredPromptUpdateCallback to iVal
96035>>>>>        
96035>>>>>        Get pbSelectionEnable to bVal
96036>>>>>        Set pbStoredSelectionEnable to bVal
96037>>>>>        
96037>>>>>        Get pbMultipleSelection to bVal
96038>>>>>        Set pbStoredMultipleSelection to bVal
96039>>>>>        
96039>>>>>    End_Procedure
96040>>>>>    
96040>>>>>    Procedure OnRestoreDefaults
96042>>>>>        Integer iVal
96042>>>>>        Boolean bVal
96042>>>>>        
96042>>>>>        Get pbStoredAutoSeed to bVal
96043>>>>>        Set pbAutoSeed to bVal
96044>>>>>        
96044>>>>>        Get pbStoredAutoOrdering to bVal
96045>>>>>        Set pbAutoOrdering to bVal
96046>>>>>        
96046>>>>>        Get pbStoredAutoSearch to bVal
96047>>>>>        Set pbAutoSearch to bVal
96048>>>>>        
96048>>>>>        Get peStoredUpdateMode to iVal
96049>>>>>        Set peUpdateMode to iVal
96050>>>>>        
96050>>>>>        Get piStoredUpdateColumn to iVal
96051>>>>>        Set piUpdateColumn to iVal
96052>>>>>        
96052>>>>>        Get piStoredInitialColumn to iVal
96053>>>>>        Set piInitialColumn to iVal
96054>>>>>        
96054>>>>>        Get phmStoredPromptUpdateCallback to iVal
96055>>>>>        Set phmPromptUpdateCallback to iVal
96056>>>>>        
96056>>>>>        Get pbStoredSelectionEnable to bVal
96057>>>>>        Set pbSelectionEnable to bVal
96058>>>>>        
96058>>>>>        Get pbStoredMultipleSelection to bVal
96059>>>>>        Set pbMultipleSelection to bVal
96060>>>>>        
96060>>>>>    End_Procedure
96061>>>>>    
96061>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
96061>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
96061>>>>>    // Suitable for augmentation
96061>>>>>    Procedure OnSeedData
96063>>>>>        Integer iUpdateColumn iSortColumn
96063>>>>>        Boolean bSeed bAuto
96063>>>>>        String sValue
96063>>>>>        Handle hoCol
96063>>>>>        
96063>>>>>        Get piUpdateColumn to iUpdateColumn
96064>>>>>        Get psSeedValue to sValue
96065>>>>>        Get pbAutoSeed to bSeed
96066>>>>>        Get piSortColumn to iSortColumn
96067>>>>>        Get pbAutoOrdering to bAuto
96068>>>>>        // if not yet sorted and this is auto ordering we will
96068>>>>>        // sort the data for the search column. We do this to make the
96068>>>>>        // column search GE logic work properly.
96068>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
96070>>>>>            Get ColumnObject iUpdateColumn to hoCol
96071>>>>>            Send SortGridByColumn hoCol False
96072>>>>>        End
96072>>>>>>
96072>>>>>        
96072>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
96074>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0
96075>>>>>        End
96075>>>>>>
96075>>>>>        Else Begin
96076>>>>>            Send MovetoFirstRow
96077>>>>>        End
96077>>>>>>
96077>>>>>        
96077>>>>>    End_Procedure
96078>>>>>    
96078>>>>>    Procedure OnMoveValueOutByValue
96080>>>>>        String sValue
96080>>>>>        Handle hoInvokingObject hoCol  hoDataSource
96080>>>>>        Integer iRow iCol
96080>>>>>        Integer[] SelRowsIndexes
96081>>>>>        
96081>>>>>        Get phoInvokingObject to hoInvokingObject
96082>>>>>        Get pSelectedRows to SelRowsIndexes
96083>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
96085>>>>>            Get piUpdateColumn to iCol
96086>>>>>            Get ColumnObject iCol to hoCol
96087>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
96088>>>>>            Set Value of hoInvokingObject to sValue
96089>>>>>            Set Item_Changed_State of hoInvokingObject to True
96090>>>>>        End
96090>>>>>>
96090>>>>>    End_Procedure
96091>>>>>    
96091>>>>>    Procedure OnMoveValueOutByCustom
96093>>>>>    End_Procedure
96094>>>>>    
96094>>>>>    // augment to popup a search window when allowed
96094>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
96096>>>>>        Boolean bSubFocus bAutoSearch bChar
96096>>>>>        Integer iVal
96096>>>>>        
96096>>>>>        Get pbFocusSubItems to bSubFocus
96097>>>>>        Get pbAutoSearch to bAutoSearch
96098>>>>>        Forward Send OnComKeyDown llKeyCode llShift
96100>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
96102>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
96104>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
96105>>>>>                Move (iVal<>0) to bChar
96106>>>>>            End
96106>>>>>>
96106>>>>>            If bChar Begin
96108>>>>>                // this can get called multiple times before a search dialog pops up
96108>>>>>                Send AddToSearchKeys llKeyCode llShift
96109>>>>>            End
96109>>>>>>
96109>>>>>        End
96109>>>>>>
96109>>>>>    End_Procedure
96110>>>>>    
96110>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
96112>>>>>        Boolean bAutoSearch
96112>>>>>        Integer iKeyCode iShiftCode
96112>>>>>        Get pbAutoSearch to bAutoSearch
96113>>>>>        If bAutoSearch Begin
96115>>>>>            // this can get called multiple times before a search dialog pops up
96115>>>>>            Get piLastKey to iKeyCode
96116>>>>>            Get piLastKey2 to iShiftCode
96117>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
96118>>>>>        End
96118>>>>>>
96118>>>>>        Move True to llCancel
96119>>>>>    End_Procedure
96120>>>>>    
96120>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
96122>>>>>        Send ClearSearchRequest // kill any deferred search popup
96123>>>>>        Forward Send OnComRowDblClick llRow llItem
96125>>>>>    End_Procedure
96126>>>>>    
96126>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
96128>>>>>        Send Ok
96129>>>>>    End_Procedure
96130>>>>>    
96130>>>>>    
96130>>>>>    // we don't want a menu for prompt lists
96130>>>>>    Function CreateContextMenu Returns Handle
96132>>>>>        Function_Return 0
96133>>>>>    End_Function
96134>>>>>    
96134>>>>>    // if we use auto-ordering, change the order when the column changes
96134>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
96136>>>>>        Boolean bAutoOrder
96136>>>>>        Forward Send ColumnChanged iOld iNew
96138>>>>>        Get pbAutoOrdering to bAutoOrder
96139>>>>>        If bAutoOrder Begin
96141>>>>>            // will be reordered in idle event
96141>>>>>            Set pbNeedsNewOrdering to True
96142>>>>>        End
96142>>>>>>
96142>>>>>    End_Procedure
96143>>>>>    
96143>>>>>    
96143>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
96145>>>>>        Integer eMode
96145>>>>>        Integer[] SelRowsIndexes
96146>>>>>        Set pbCanceled to True // assume cancel unless changed
96147>>>>>        Set pSelectedRows to SelRowsIndexes // empty
96148>>>>>        Get peUpdateMode to eMode
96149>>>>>        If (eMode<>umPromptNonInvoking) Begin
96151>>>>>            Send OnStoreDefaults
96152>>>>>        End
96152>>>>>>
96152>>>>>        Send InitializePromptList
96153>>>>>        Forward Send Add_Focus hoParent
96155>>>>>        Send LoadData
96156>>>>>        Set psSeedValue to ""
96157>>>>>    End_Procedure
96158>>>>>    
96158>>>>>    // called before the list is activated.
96158>>>>>    Procedure InitializePromptList
96160>>>>>        Integer hoInvokingObject
96160>>>>>        Boolean bAutoColumn bAutoSeed
96160>>>>>        Integer i iOldMode eUpdateMode
96160>>>>>        String sValue
96160>>>>>        
96160>>>>>        Get peUpdateMode to eUpdateMode
96161>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
96163>>>>>            Get Focus of Desktop to hoInvokingObject
96164>>>>>            If (hoInvokingObject<=Desktop) Begin
96166>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
96167>>>>>>
96167>>>>>                Procedure_Return
96168>>>>>            End
96168>>>>>>
96168>>>>>            
96168>>>>>            Set phoInvokingObject to hoInvokingObject
96169>>>>>            
96169>>>>>            Send Prompt_Callback to hoInvokingObject Self
96170>>>>>            Get peUpdateMode to eUpdateMode
96171>>>>>        End
96171>>>>>>
96171>>>>>        
96171>>>>>        Send ClearSearchRequest // clear the search keys
96172>>>>>        Set pbNeedsNewOrdering to False
96173>>>>>        
96173>>>>>        Get pbAutoSeed to bAutoSeed
96174>>>>>        
96174>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
96176>>>>>            Get Value of hoInvokingObject to sValue
96177>>>>>            Set psSeedValue to sValue
96178>>>>>        End
96178>>>>>>
96178>>>>>        
96178>>>>>    End_Procedure
96179>>>>>    
96179>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
96179>>>>>    Procedure LoadData
96181>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
96181>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
96181>>>>>        Integer eUpdateMode
96181>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder
96181>>>>>        
96181>>>>>        Get phoDataSource to hoDataSource
96182>>>>>        Get peUpdateMode to eUpdateMode
96183>>>>>        Get phoInvokingObject to hoInvokingObject
96184>>>>>        Get pbAutoSeed to bAutoSeed
96185>>>>>        Get piInitialColumn to iInitialColumn
96186>>>>>        Get piUpdateColumn to iUpdateColumn
96187>>>>>        Get RowCount of hoDataSource to iRows
96188>>>>>        
96188>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
96188>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
96188>>>>>        If (iInitialColumn=-1) Begin
96190>>>>>            Move iUpdateColumn to iInitialColumn
96191>>>>>        End
96191>>>>>>
96191>>>>>        If (iInitialColumn>=0) Begin
96193>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
96194>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
96195>>>>>        End
96195>>>>>>
96195>>>>>        Send OnSeedData // find a good starting place for the row
96196>>>>>        Get pbFocusSubItems to bSubFocus
96197>>>>>        If bSubFocus Begin
96199>>>>>            // if column focus, which is normal, go to initialcolumn
96199>>>>>            If hoInitialColumn Begin
96201>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
96202>>>>>            End
96202>>>>>>
96202>>>>>            Else Begin
96203>>>>>                Send MoveToFirstEnterableColumn
96204>>>>>            End
96204>>>>>>
96204>>>>>        End
96204>>>>>>
96204>>>>>        
96204>>>>>    End_Procedure
96205>>>>>    
96205>>>>>    // This is only called in a successful close
96205>>>>>    Procedure ClosePromptList
96207>>>>>        Handle hoDataSource hoInvokingObject
96207>>>>>        Handle hmCallBack
96207>>>>>        Integer iRow eUpdateMode
96207>>>>>        Integer[] SelRowsIndexes
96208>>>>>        
96208>>>>>        Get phoDataSource to hoDataSource
96209>>>>>        Get phoInvokingObject to hoInvokingObject
96210>>>>>        
96210>>>>>        If (pbMultipleSelection(Self)) Begin
96212>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
96213>>>>>        End
96213>>>>>>
96213>>>>>        Else Begin
96214>>>>>            Get SelectedRow of hoDataSource to iRow
96215>>>>>            If (iRow<>-1) Begin
96217>>>>>                Move iRow to SelRowsIndexes[0]
96218>>>>>            End
96218>>>>>>
96218>>>>>        End
96218>>>>>>
96218>>>>>        
96218>>>>>        Set pbCanceled to False
96219>>>>>        Set pSelectedRows to SelRowsIndexes
96220>>>>>        
96220>>>>>        Get peUpdateMode to eUpdateMode
96221>>>>>        // if non-invoking there is by definition, no move value out
96221>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
96223>>>>>            
96223>>>>>            If (eUpdateMode=umPromptValue) Begin
96225>>>>>                Send OnMoveValueOutByValue
96226>>>>>            End
96226>>>>>>
96226>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
96229>>>>>                Send OnMoveValueOutByCustom
96230>>>>>            End
96230>>>>>>
96230>>>>>            Get phmPromptUpdateCallback to hmCallBack
96231>>>>>            If hmCallBack Begin
96233>>>>>                Send hmCallBack of hoInvokingObject Self
96234>>>>>            End
96234>>>>>>
96234>>>>>        End
96234>>>>>>
96234>>>>>        
96234>>>>>        Send Close_Panel
96235>>>>>    End_Procedure
96236>>>>>    
96236>>>>>    // augment to send OnRestoreDefaults.
96236>>>>>    Procedure Release_Focus
96238>>>>>        Integer eUpdateMode
96238>>>>>        Get peUpdateMode to eUpdateMode
96239>>>>>        Forward Send Release_Focus
96241>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
96243>>>>>            Send OnRestoreDefaults
96244>>>>>        End
96244>>>>>>
96244>>>>>    End_Procedure
96245>>>>>    
96245>>>>>    Function SelectedRowIds Returns RowID[]
96247>>>>>        RowID[] SelectedRowids
96248>>>>>        Integer[] SelectedRows
96249>>>>>        Integer i iRows
96249>>>>>        Handle hoDataSource
96249>>>>>        Get phoDataSource to hoDataSource
96250>>>>>        Get pSelectedRows to SelectedRows
96251>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
96252>>>>>        For i from 0 to (iRows-1)
96258>>>>>>
96258>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
96259>>>>>        Loop
96260>>>>>>
96260>>>>>        Function_Return SelectedRowids
96261>>>>>    End_Function
96262>>>>>    
96262>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
96264>>>>>        String[] SelectedValues
96265>>>>>        Integer[] SelectedRows
96266>>>>>        Integer i iRows
96266>>>>>        Handle hoCol
96266>>>>>        Get ColumnObject iCol to hoCol
96267>>>>>        Get pSelectedRows to SelectedRows
96268>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
96269>>>>>        For i from 0 to (iRows-1)
96275>>>>>>
96275>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
96276>>>>>        Loop
96277>>>>>>
96277>>>>>        Function_Return SelectedValues
96278>>>>>    End_Function
96279>>>>>    
96279>>>>>    Procedure Ok Returns Integer
96281>>>>>        Send ClosePromptList
96282>>>>>    End_Procedure
96283>>>>>    
96283>>>>>    Procedure Cancel Returns Integer
96285>>>>>        Send Close_Panel
96286>>>>>    End_Procedure
96287>>>>>    
96287>>>>>    Procedure Search
96289>>>>>        Send Activate // give focus back to list so focus things are correct
96290>>>>>        Send Request_Search 0 0
96291>>>>>    End_Procedure
96292>>>>>    
96292>>>>>    // do a search using the current keys in the search key buffer for the sort column.
96292>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
96292>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
96292>>>>>    Procedure Request_SearchEx
96294>>>>>        tGridKeyPair[] Keys
96294>>>>>        tGridKeyPair[] Keys
96295>>>>>        Integer iCol
96295>>>>>        Handle hoCol hoSearchDialog
96295>>>>>        Boolean bOk
96295>>>>>        String sValue
96295>>>>>        
96295>>>>>        Get piSortColumn to iCol
96296>>>>>        If (iCol<>-1) Begin
96298>>>>>            Get ColumnObject iCol to hoCol
96299>>>>>            Get pSearchKeys to Keys
96300>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
96301>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
96302>>>>>            If bOk Begin
96304>>>>>                Send RequestFindColumnValue iCol sValue True 0
96305>>>>>            End
96305>>>>>>
96305>>>>>            Send Destroy of hoSearchDialog
96306>>>>>        End
96306>>>>>>
96306>>>>>        Send ClearSearchRequest // clear the search keys
96307>>>>>    End_Procedure
96308>>>>>    
96308>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
96308>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
96310>>>>>        tGridKeyPair[] Keys
96310>>>>>        tGridKeyPair[] Keys
96311>>>>>        tGridKeyPair KeyPair
96311>>>>>        tGridKeyPair KeyPair
96311>>>>>        Set pbRequestSearch to True
96312>>>>>        Move iKeyCode to KeyPair.KeyCode
96313>>>>>        Move iShiftCode to KeyPair.ShiftCode
96314>>>>>        Get pSearchKeys to Keys
96315>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
96316>>>>>        Set pSearchKeys to Keys
96317>>>>>    End_Procedure
96318>>>>>    
96318>>>>>    Procedure ClearSearchRequest
96320>>>>>        tGridKeyPair[] SearchKeys
96320>>>>>        tGridKeyPair[] SearchKeys
96321>>>>>        Set pSearchKeys to SearchKeys
96322>>>>>        Set pbRequestSearch to False
96323>>>>>    End_Procedure
96324>>>>>    
96324>>>>>End_Class
96325>>>>>
96325>>>Use cDbUpdateFunctionLibrary.pkg
96325>>>Use MSSqldrv.pkg
96325>>>Use db2_drv.pkg
96325>>>Use odbc_drv.pkg
96325>>>Use cRDCModalPanel.pkg
Including file: cRDCModalPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\cRDCModalPanel.pkg)
96325>>>>>//****************************************************************************
96325>>>>>// $Module type: Class
96325>>>>>// $Module name: cRDCModalPanel
96325>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
96325>>>>>// Created     : 2014-03-17 @ 12:33
96325>>>>>//
96325>>>>>// Description :
96325>>>>>//
96325>>>>>// $Rev History:
96325>>>>>//    2014-03-17  Module header created
96325>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
96325>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
96325>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
96325>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
96325>>>>>// in the help folder for more details.
96325>>>>>//
96325>>>>>//****************************************************************************
96325>>>>>Use Windows.pkg
96325>>>>>Use cCJCommandBarSystem.pkg   
96325>>>>>Use cCJSkinFramework.pkg
96325>>>>>
96325>>>>>Class cRDCModalPanel is a ModalPanel
96326>>>>>
96326>>>>>    Procedure Construct_Object
96328>>>>>        Forward Send Construct_Object
96330>>>>>
96330>>>>>        Set Maximize_Icon to True
96331>>>>>        Set Minimize_Icon to False
96332>>>>>        Set Border_Style to Border_Thick
96333>>>>>        Set Locate_Mode to Center_On_Parent
96334>>>>>
96334>>>>>        Property String Private_Icon
96335>>>>>        Property Handle phoDialogCommandbar
96336>>>>>    End_Procedure
96337>>>>>
96337>>>>>    Procedure Set Icon String sIcon
96339>>>>>        Forward Set Icon to sIcon
96341>>>>>        Set Private_Icon to sIcon
96342>>>>>    End_Procedure
96343>>>>>
96343>>>>>    Function Icon Returns String
96345>>>>>        String sIcon
96345>>>>>        Get Private_Icon to sIcon
96346>>>>>        Function_Return sIcon
96347>>>>>    End_Function
96348>>>>>
96348>>>>>    Procedure Page Integer iPageObject
96350>>>>>        String sIcon
96350>>>>>        Integer hWnd
96350>>>>>        
96350>>>>>        Forward Send Page iPageObject
96352>>>>>        Get Private_Icon to sIcon
96353>>>>>        If (sIcon <> "") Begin
96355>>>>>            Set Icon to sIcon
96356>>>>>        End
96356>>>>>>
96356>>>>>
96356>>>>>        Get Window_Handle to hWnd
96357>>>>>
96357>>>>>        If ((ghoSkinFramework <> 0) and (hWnd <> 0)) Begin
96359>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
96360>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
96361>>>>>        End
96361>>>>>>
96361>>>>>    End_Procedure
96362>>>>>
96362>>>>>    // Put a status bar at the bottom of the panel, which makes
96362>>>>>    // status_help work and puts a gripper in the lower right corner.
96362>>>>>    Procedure End_Construct_Object
96364>>>>>        Integer iStyle iSize iOffset
96364>>>>>
96364>>>>>        Forward Send End_Construct_Object
96366>>>>>
96366>>>>>        Get Border_Style to iStyle
96367>>>>>        Move 8 to iOffset
96368>>>>>        If (iStyle = Border_Thick) Begin
96370>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
96372>>>>>                Object oStatusBar is a cCJStatusBar
96374>>>>>                    Set phoDialogCommandbar to Self
96375>>>>>                    Object oStatusIdle is a cCJStatusBarPane
96377>>>>>                        Set piId to sbpIDIdlePane
96378>>>>>                        Set pbStyleStretch to True
96379>>>>>                    End_Object
96380>>>>>                End_Object
96381>>>>>            End_Object
96382>>>>>            Get Size to iSize
96383>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
96384>>>>>            Set piMinSize to (Hi(iSize) + iOffset) (Low(iSize))
96385>>>>>        End
96385>>>>>>
96385>>>>>
96385>>>>>    End_Procedure
96386>>>>>
96386>>>>>    Procedure Popup
96388>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
96389>>>>>        Forward Send Popup
96391>>>>>    End_Procedure
96392>>>>>
96392>>>>>End_Class
96393>>>
96393>>>Object oDatabaseSelection_sl is a cRDCModalPanel
96395>>>    Set Label to "SQL Database Selection"
96396>>>    Set Size to 119 183
96397>>>    Set piMinSize to 89 170
96398>>>    Set Location to 2 2
96399>>>    Set Border_Style to Border_Thick
96400>>>    Set Icon to "DatabaseLookup.ico"
96401>>>
96401>>>    Property String[] psTheData
96403>>>
96403>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
96405>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
96407>>>        End_Object
96408>>>    End
96408>>>>
96408>>>
96408>>>    Object oSelList is a cCJGridPromptList
96410>>>        Set Size to 89 167
96411>>>        Set Location to 6 6
96412>>>        Set peAnchors to anAll
96413>>>        Set pbAllowColumnRemove to False
96414>>>        Set pbUseAlternateRowBackgroundColor to True
96415>>>        Set pbGrayIfDisable to False
96416>>>        Set pbHeaderReorders to False
96417>>>        Set pbHeaderSelectsColumn to False
96418>>>        Set pbHeaderTogglesDirection to False
96419>>>        Set pbShadeSortColumn to False
96420>>>        Set piFocusCellBackColor to clDkGray
96421>>>
96421>>>        Object oName is a cCJGridColumn
96423>>>            Set piWidth to 334
96424>>>            Set psCaption to "Database Name"
96425>>>        End_Object
96426>>>
96426>>>        Procedure Activating
96429>>>            tDataSourceRow[] MyData
96429>>>            tDataSourceRow[] MyData
96430>>>            Handle hoDataSource
96430>>>            String[] sTheData
96431>>>            Integer iCount iSize
96431>>>
96431>>>            Send Cursor_Wait of Cursor_Control
96432>>>            Forward Send Activating
96434>>>
96434>>>            Get psTheData to sTheData
96435>>>            Move (SizeOfArray(sTheData)) to iSize
96436>>>            Decrement iSize
96437>>>            For iCount from 0 to iSize
96443>>>>
96443>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
96444>>>            Loop
96445>>>>
96445>>>
96445>>>            Get phoDataSource to hoDataSource
96446>>>            Send InitializeData of hoDataSource MyData
96447>>>            Send Cursor_Ready of Cursor_Control
96448>>>        End_Procedure
96449>>>
96449>>>    End_Object
96450>>>
96450>>>    Object oOK_Btn is a Button
96452>>>        Set Size to 14 50
96453>>>        Set Label    to "&OK"
96454>>>        Set Location to 98 68
96455>>>        Set peAnchors To anBottomRight
96456>>>
96456>>>        Procedure OnClick
96459>>>            Send Ok of oSelList
96460>>>        End_Procedure
96461>>>
96461>>>    End_Object
96462>>>
96462>>>    Object oCancel_Btn is a Button
96464>>>        Set Size to 14 50
96465>>>        Set Label    to "&Cancel"
96466>>>        Set Location to 98 123
96467>>>        Set peAnchors to anBottomRight
96468>>>
96468>>>        Procedure OnClick
96471>>>            Send Close_Panel
96472>>>        End_Procedure
96473>>>
96473>>>    End_Object
96474>>>
96474>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96475>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96476>>>End_Object
96477>        Use SQLDatabaseBackup.dg
Including file: SQLDatabaseBackup.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLDatabaseBackup.dg)
96477>>>// Note: At the bottom of this package there's a general purpose access method for this dialog.
96477>>>Use Windows.pkg
96477>>>Use vWin32fh.pkg
96477>>>
96477>>>Object oSQLDatabaseBackup_dg is a ModalPanel
96479>>>    Set Size to 104 298
96480>>>    Set Label to "SQL Database Backup"
96481>>>    Set piMinSize to 89 211
96482>>>    Set Location to 2 4
96483>>>    Set Border_Style To Border_Thick
96484>>>
96484>>>    Property Boolean pbOK False
96486>>>    Property String  psDatabase
96488>>>    Property String  psPath
96490>>>    Property String  psBackupName
96492>>>
96492>>>    Object oDatabase_fm is a Form
96494>>>        Set Size to 13 204
96495>>>        Set Location to 14 71
96496>>>        Set Label_Justification_Mode to JMode_Right
96497>>>        Set Label_Col_Offset to 2
96498>>>        Set Label to "Database Name"
96499>>>        Set Enabled_State to False
96500>>>        Set peAnchors to anTopLeftRight
96501>>>
96501>>>        Procedure Page Integer iPageObject
96504>>>            String sValue
96504>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sValue
96505>>>            Set Value to sValue
96506>>>            Set psDatabase to sValue
96507>>>            Forward Send Page iPageObject
96509>>>        End_Procedure
96510>>>
96510>>>    End_Object
96511>>>
96511>>>    Object oBackupName_fm is a Form
96513>>>        Set Size to 13 204
96514>>>        Set Location to 29 71
96515>>>        Set Label_Justification_Mode to JMode_Right
96516>>>        Set Label_Col_Offset to 2
96517>>>        Set Label to "Backup Name"
96518>>>        Set peAnchors to anTopLeftRight
96519>>>
96519>>>        Procedure Page Integer iPageObject
96522>>>            String sValue
96522>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sValue
96523>>>            Set Value to sValue
96524>>>            Forward Send Page iPageObject
96526>>>        End_Procedure
96527>>>
96527>>>        Procedure OnChange
96530>>>            String sValue
96530>>>            Get Value to sValue
96531>>>            Set psBackupName to sValue
96532>>>        End_Procedure
96533>>>
96533>>>    End_Object
96534>>>
96534>>>    Object oUseDefaultBackupFolder_cb is a CheckBox
96536>>>        Set Size to 10 50
96537>>>        Set Location to 50 71
96538>>>        Set Label to "Use Default SQL Backup Folder"
96539>>>        Set Checked_State to True
96540>>>
96540>>>        Procedure OnChange
96543>>>            Boolean bChecked
96543>>>            Get Checked_State to bChecked
96544>>>            Set Enabled_State of oPath_fm to (bChecked = False)
96545>>>        End_Procedure
96546>>>
96546>>>    End_Object
96547>>>
96547>>>    Object oPath_fm is a Form
96549>>>        Set Size to 13 204
96550>>>        Set Location to 62 71
96551>>>        Set Label_Justification_Mode to JMode_Right
96552>>>        Set Label_Col_Offset to 2
96553>>>        Set Label to "Path"
96554>>>        Set Prompt_Button_Mode to PB_PromptOn
96555>>>        Set peAnchors to anTopLeftRight
96556>>>        Set Enabled_State to False
96557>>>
96557>>>        Procedure Page Integer iPageObject
96560>>>            String sValue
96560>>>            Get psDataPathFirstPart of ghoDbUpdateFunctionLibrary to sValue
96561>>>            Get vFolderFormat sValue to sValue
96562>>>            Move (sValue + "Backup") to sValue
96563>>>            Set Value to sValue
96564>>>            Forward Send Page iPageObject
96566>>>        End_Procedure
96567>>>
96567>>>        Procedure Prompt
96570>>>            String sPath sFileMask sRetval
96570>>>
96570>>>            Get Value to sPath
96571>>>            Move "Database Backup files (*.bak)|*.bak" to sFileMask
96572>>>            Get vSelect_File sFileMask "Please select a .bak file" sPath to sRetval
96573>>>            If (sRetval <> "") Begin
96575>>>                Get ParseFolderName sRetval to sPath
96576>>>                If (Right(sPath, 1) ="\") Begin
96578>>>                    Move (Left(sPath, Length(sPath) -1)) to sPath
96579>>>                End
96579>>>>
96579>>>                Set Value to sPath
96580>>>            End
96580>>>>
96580>>>        End_Procedure
96581>>>
96581>>>        Procedure OnChange
96584>>>            String sValue
96584>>>            Get Value to sValue
96585>>>            Set psPath to sValue
96586>>>        End_Procedure
96587>>>
96587>>>    End_Object
96588>>>
96588>>>    Object oOK_Btn is a Button
96590>>>        Set Label    to "&OK"
96591>>>        Set Location to 81 169
96592>>>        Set peAnchors to anBottomRight
96593>>>
96593>>>        Procedure OnClick
96596>>>            Set pbOK to True
96597>>>            Send Close_Panel
96598>>>        End_Procedure
96599>>>
96599>>>    End_Object
96600>>>
96600>>>    Object oCancel_Btn is a Button
96602>>>        Set Label    to "&Cancel"
96603>>>        Set Location to 81 224
96604>>>        Set peAnchors to anBottomRight
96605>>>
96605>>>        Procedure OnClick
96608>>>            Set pbOK to False
96609>>>            Send Close_Panel
96610>>>        End_Procedure
96611>>>
96611>>>    End_Object
96612>>>
96612>>>    Object oButton1 is a Button
96614>>>        Set Size to 14 96
96615>>>        Set Location to 80 32
96616>>>        Set Label to "Enum table types"
96617>>>
96617>>>        Procedure OnClick
96620>>>            String sDriverID
96620>>>            tSQLConnection SQLConnection
96620>>>            tSQLConnection SQLConnection
96620>>>            Get pSQLConnection of ghoDbUpdateFunctionLibrary to SQLConnection
96621>>>            Send ShowAllTablesAndColumns SQLConnection.sDriverID SQLConnection.sConnectionString
96622>>>        End_Procedure
96623>>>
96623>>>        Procedure ShowAllTablesAndColumns String sDriver String sLogin
96626>>>            Handle hoCLIHandler
96626>>>            Integer iNumTables iTableCount
96626>>>
96626>>>            Get Create U_cCLIHandler to hoCLIhandler
96627>>>            If (hoCLIHandler > 0) Begin
96629>>>                Set psDriverID of hoCLIHandler to sDriver
96630>>>                Get EnumerateTables of hoCLIHandler sLogin to iNumTables
96631>>>                For iTableCount from 1 to iNumTables
96637>>>>
96637>>>                    Show (TableName(hoCLIHandler, iTableCount)) "; "
96639>>>                    Show (SchemaName(hoCLIHandler, iTableCount)) "; "
96641>>>                    Show (TableType(hoCLIHandler, iTableCount)) "; "
96643>>>                    Showln (TableComment(hoCLIHandler, iTableCount))
96645>>>//                    Get EnumerateColumns of hoCLIHandler sLogin (TableName(hoCLIHandler, iTableCount)) to iNumColumns
96645>>>//                    For iColumnCount from 1 to iNumColumns
96645>>>//                        Showln " " (ColumnName(hoCLIHandler, iColumnCount))
96645>>>//                    Loop
96645>>>                    Showln
96646>>>                Loop
96647>>>>
96647>>>                Send Destroy of hoCLIHandler
96648>>>            End
96648>>>>
96648>>>        End_Procedure
96649>>>
96649>>>    End_Object
96650>>>
96650>>>    Procedure Page Integer iPageObject
96653>>>        Set Icon to "DbBackup.ico"
96654>>>        Forward Send Page iPageObject
96656>>>    End_Procedure
96657>>>
96657>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96658>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96659>>>
96659>>>End_Object
96660>>>
96660>>>// *** General purpose access method for this dialog ***
96660>>>Function MakeSQLDatabaseBackup Returns Boolean
96663>>>    Handle ho
96663>>>    Boolean bOK bDefault
96663>>>    String sDatabase sPath sBackupName
96663>>>
96663>>>    Move (oSQLDatabaseBackup_dg(Self)) to ho
96664>>>    Set pbOK of ho to False
96665>>>    Send Popup of ho
96666>>>
96666>>>    Get pbOk of ho to bOK
96667>>>    If (bOK = True) Begin
96669>>>        Get Value of (oDatabase_fm(ho))   to sDatabase
96670>>>        Get Value of (oBackupName_fm(ho)) to sBackupName
96671>>>        Get Checked_State of (oUseDefaultBackupFolder_cb(ho)) to bDefault
96672>>>        If (bDefault = False) Begin
96674>>>            Get Value of (oPath_fm(ho)) to sPath
96675>>>        End
96675>>>>
96675>>>        Get SqlDatabaseBackupToDisk of ghoDbUpdateFunctionLibrary sDatabase sBackupName sPath True to bOK
96676>>>    End
96676>>>>
96676>>>
96676>>>    Function_Return bOK
96677>>>End_Function
96678>        Use SQLConnections.vw
Including file: SQLConnections.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLConnections.vw)
96678>>>Use Windows.pkg
96678>>>Use DFClient.pkg
96678>>>Use cDbScrollingContainer.pkg
Including file: cDbScrollingContainer.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cDbScrollingContainer.pkg)
96678>>>>>// Provides support for db aware scrolling containers.
96678>>>>>// Scrolling containers is provided by creating two objects,
96678>>>>>// a host (dbScrollingContainer) and a scrolling clientarea (dbScrollingClientArea)
96678>>>>>// The host has no public interface, you just drop the object. It should have only one child object
96678>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
96678>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
96678>>>>>
96678>>>>>Use DFClient.pkg
96678>>>>>Use cScrollingContainerMixin.pkg
Including file: cScrollingContainerMixin.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cScrollingContainerMixin.pkg)
96678>>>>>>>// Mixin classes for scrolling container support:
96678>>>>>>>// cScrollingContainerMixin & cScrollingClientAreaMixin
96678>>>>>>>// These are used by cSrollingContainer / cScrollingClientArea and
96678>>>>>>>// dbScrollingContainer / dbScrollingClientArea.
96678>>>>>>>// The scrolling container has no public interface, you just drop the object. It should have only one child object
96678>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
96678>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
96678>>>>>>>
96678>>>>>>>Use Windows.pkg
96678>>>>>>>Use Winuser.pkg
96678>>>>>>>Use tWinStructs.pkg
96678>>>>>>>
96678>>>>>>>Register_Function pbTabbedWorkspaces Returns Boolean
96678>>>>>>>Register_Function pbCenterTabbedViews Returns Boolean
96678>>>>>>>// support for the scrolling client area mixin object.
96678>>>>>>>
96678>>>>>>>Class cScrollingClientAreaMixin is a Mixin
96679>>>>>>>    
96679>>>>>>>    Procedure Define_cScrollingClientAreaMixin
96681>>>>>>>        
96681>>>>>>>        Set pbSizeToClientArea to False // should already be set to this, but just in case.
96682>>>>>>>        Set Border_Style to Border_None
96683>>>>>>>        
96683>>>>>>>        Property Boolean pbAutoScroll True
96684>>>>>>>        Property Boolean pbAutoScrollFocus True
96685>>>>>>>        Property Integer piAutoScrollMarginX 5
96686>>>>>>>        Property Integer piAutoScrollMarginY 5
96687>>>>>>>        Property Integer piAutoScrollMinX 0
96688>>>>>>>        Property Integer piAutoScrollMinY 0
96689>>>>>>>        Property Boolean pbShowDisabledScrollBar False
96690>>>>>>>        
96690>>>>>>>        
96690>>>>>>>        Property Integer piLineScrollUnit  5 // minimum scrolling unit for line up/down and mouse wheel
96691>>>>>>>        Property Integer piMinimumHeight 0 // the minimum height that doesn't need scrolling
96692>>>>>>>        Property Integer piMinimumWidth 0 //(the minimum width that doesn't need scrolling
96693>>>>>>>        // keeps track of scrolling
96693>>>>>>>        Property Integer piCurrentVertScrolled 0
96694>>>>>>>        Property Integer piCurrentHorzScrolled 0
96695>>>>>>>        Property Integer piWheelDelta 0               // internal, accumulates mouse wheel clicks
96696>>>>>>>        Delegate Set phoScrollingClientArea to Self
96698>>>>>>>        
96698>>>>>>>        // set this true to make this a tabbed workspace view (design time)
96698>>>>>>>        Property Boolean pbTabWorkspaceView False
96699>>>>>>>        // set this false to stop auto-determination of pbTabWorkspaceView (design time)
96699>>>>>>>        Property Boolean pbAutoSetTabWorkspaceView True
96700>>>>>>>    End_Procedure
96701>>>>>>>    
96701>>>>>>>    // low level event sent from windows.
96701>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
96703>>>>>>>        Integer iWheelDelta iKeys iDelta iClicks
96703>>>>>>>        Move (low(abs(wParam))) to iKeys           // any keys down when pressed
96704>>>>>>>        Move (hi(abs(wParam))) to iDelta           // number of click units
96705>>>>>>>        If (wParam<0) Begin
96707>>>>>>>            Move (-iDelta) to iDelta     // can be up or down
96708>>>>>>>        End
96708>>>>>>>>
96708>>>>>>>        Get  piWheelDelta to iWheelDelta           // Current accumulated micro clicks
96709>>>>>>>        Move (iWheelDelta+iDelta) to iWheelDelta
96710>>>>>>>        // C_WHEELDATA is 120 as defined by MS as the delta to react to. Once click is usually 120
96710>>>>>>>        Move (iWheelDelta/C_WHEELDELTA) to iClicks // Number of clicks to react to
96711>>>>>>>        Set  piWheelDelta to (mod(iWheelDelta,C_WHEELDELTA)) // remainder unused microclicks
96712>>>>>>>        // If we have enough Clicks send OnMouseWheel
96712>>>>>>>        If (iClicks<>0) Begin
96714>>>>>>>            Send OnMouseWheel iClicks iKeys
96715>>>>>>>        End
96715>>>>>>>>
96715>>>>>>>        // tell windows that we've handled the event.
96715>>>>>>>        Set Windows_Override_State to True
96716>>>>>>>    End_Procedure
96717>>>>>>>    
96717>>>>>>>    
96717>>>>>>>    // should be sent by DF message OnWMMouseWheel , which is sent by WM_MOUSEWHEEL
96717>>>>>>>    Procedure OnMouseWheel Integer iClicks Integer iKey
96719>>>>>>>        Integer iLineScrollUnit
96719>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96720>>>>>>>        Send VScroll (-iClicks*iLineScrollUnit*2) // (If(iClicks>0,False,True)) (abs(iClicks))
96721>>>>>>>    End_Procedure
96722>>>>>>>    
96722>>>>>>>    // should be sent by WM_VSCROLL
96722>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
96724>>>>>>>        Boolean bOk
96724>>>>>>>        tWinScrollInfo ScrollInfo
96724>>>>>>>        tWinScrollInfo ScrollInfo
96724>>>>>>>        Integer iLineScrollUnit
96724>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96725>>>>>>>        Get GetScrollBarInfo True (&ScrollInfo) to bOk
96726>>>>>>>        If bOk Begin
96728>>>>>>>            
96728>>>>>>>            Case Begin
96728>>>>>>>                Case (iType=SB_PAGEDOWN)
96730>>>>>>>                    Send VScroll ScrollInfo.nPage
96731>>>>>>>                    Case Break
96732>>>>>>>                
96732>>>>>>>                Case (iType=SB_PAGEUP)
96735>>>>>>>                    Send VScroll (-Integer(ScrollInfo.nPage))
96736>>>>>>>                    Case Break
96737>>>>>>>                
96737>>>>>>>                Case (iType=SB_LINEDOWN)
96740>>>>>>>                    Send VScroll iLineScrollUnit
96741>>>>>>>                    Case Break
96742>>>>>>>                
96742>>>>>>>                Case (iType=SB_LINEUP)
96745>>>>>>>                    Send VScroll (-iLineScrollUnit)
96746>>>>>>>                    Case Break
96747>>>>>>>                
96747>>>>>>>                Case (iType=SB_BOTTOM)
96750>>>>>>>                    Send VScroll (ScrollInfo.nMax-ScrollInfo.nPos)
96751>>>>>>>                    Case Break
96752>>>>>>>                
96752>>>>>>>                Case (iType=SB_Top)
96755>>>>>>>                    Send VScroll (-ScrollInfo.nPos)
96756>>>>>>>                    Case Break
96757>>>>>>>                
96757>>>>>>>                Case (iType=SB_THUMBPOSITION)
96760>>>>>>>                    Case Break
96761>>>>>>>                
96761>>>>>>>                Case (iType=SB_THUMBTRACK)
96764>>>>>>>                    Send VScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
96765>>>>>>>                    Case Break
96766>>>>>>>            Case End
96766>>>>>>>        End
96766>>>>>>>>
96766>>>>>>>    End_Procedure
96767>>>>>>>    
96767>>>>>>>    // should be sent by WM_HSCROLL
96767>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
96769>>>>>>>        Boolean bOk
96769>>>>>>>        tWinScrollInfo ScrollInfo
96769>>>>>>>        tWinScrollInfo ScrollInfo
96769>>>>>>>        Integer iLineScrollUnit
96769>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
96770>>>>>>>        Get GetScrollBarInfo False (&ScrollInfo) to bOk
96771>>>>>>>        If bOk Begin
96773>>>>>>>            
96773>>>>>>>            Case Begin
96773>>>>>>>                Case (iType=SB_PAGEDOWN)
96775>>>>>>>                    Send hScroll ScrollInfo.nPage
96776>>>>>>>                    Case Break
96777>>>>>>>                
96777>>>>>>>                Case (iType=SB_PAGEUP)
96780>>>>>>>                    Send hScroll (-Integer(ScrollInfo.nPage))
96781>>>>>>>                    Case Break
96782>>>>>>>                
96782>>>>>>>                Case (iType=SB_LINEDOWN)
96785>>>>>>>                    Send hScroll iLineScrollUnit
96786>>>>>>>                    Case Break
96787>>>>>>>                
96787>>>>>>>                Case (iType=SB_LINEUP)
96790>>>>>>>                    Send hScroll (-iLineScrollUnit)
96791>>>>>>>                    Case Break
96792>>>>>>>                
96792>>>>>>>                Case (iType=SB_BOTTOM)
96795>>>>>>>                    Send hScroll (ScrollInfo.nMax-ScrollInfo.nPos)
96796>>>>>>>                    Case Break
96797>>>>>>>                
96797>>>>>>>                Case (iType=SB_Top)
96800>>>>>>>                    Send hScroll (-ScrollInfo.nPos)
96801>>>>>>>                    Case Break
96802>>>>>>>                
96802>>>>>>>                Case (iType=SB_THUMBPOSITION)
96805>>>>>>>                    Case Break
96806>>>>>>>                
96806>>>>>>>                Case (iType=SB_THUMBTRACK)
96809>>>>>>>                    Send hScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
96810>>>>>>>                    Case Break
96811>>>>>>>            Case End
96811>>>>>>>        End
96811>>>>>>>>
96811>>>>>>>    End_Procedure
96812>>>>>>>    
96812>>>>>>>    
96812>>>>>>>    // this calls SetScrollInfo with proper info
96812>>>>>>>    Procedure SetScrollBarInfo Boolean bVert Integer iRangeMin Integer iRangeMax Integer iPageSize
96814>>>>>>>        tWinScrollInfo ScrollInfo
96814>>>>>>>        tWinScrollInfo ScrollInfo
96814>>>>>>>        Integer iVoid
96814>>>>>>>        Handle hWnd
96814>>>>>>>        Boolean bShow
96814>>>>>>>        
96814>>>>>>>        Delegate Get Window_Handle to hWnd
96816>>>>>>>        If (hWnd <> 0) Begin
96818>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
96819>>>>>>>            
96819>>>>>>>            Move (SIF_RANGE ior SIF_POS ior SIF_PAGE ) to ScrollInfo.fMask
96820>>>>>>>            Get pbShowDisabledScrollBar to bShow
96821>>>>>>>            If bShow Begin
96823>>>>>>>                Move (ScrollInfo.fMask ior SIF_DISABLENOSCROLL) to ScrollInfo.fMask
96824>>>>>>>            End
96824>>>>>>>>
96824>>>>>>>            Move iRangeMin to ScrollInfo.nMin
96825>>>>>>>            Move iRangeMax to ScrollInfo.nMax
96826>>>>>>>            Move iPageSize to ScrollInfo.nPage
96827>>>>>>>            Move 0 to ScrollInfo.nPos
96828>>>>>>>            Move (SetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo), True)) to iVoid
96829>>>>>>>            
96829>>>>>>>        End
96829>>>>>>>>
96829>>>>>>>    End_Procedure
96830>>>>>>>    
96830>>>>>>>    // this wraps GetScrollInfo
96830>>>>>>>    Function GetScrollBarInfo Boolean bVert tWinScrollInfo ByRef ScrollInfo Returns Boolean
96832>>>>>>>        Boolean bOk
96832>>>>>>>        Handle hWnd
96832>>>>>>>        
96832>>>>>>>        Delegate Get Window_Handle to hWnd
96834>>>>>>>        If (hWnd <> 0) Begin
96836>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
96837>>>>>>>            Move (SIF_ALL) to ScrollInfo.fMask
96838>>>>>>>            Move (GetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo))) to bOk
96839>>>>>>>        End
96839>>>>>>>>
96839>>>>>>>        Function_Return bOk
96840>>>>>>>    End_Function
96841>>>>>>>    
96841>>>>>>>    // this wraps SetScrollPos
96841>>>>>>>    Procedure SetScrollBarPosInfo Boolean bVert Integer iPos
96843>>>>>>>        Integer iVoid
96843>>>>>>>        Handle hWnd
96843>>>>>>>        
96843>>>>>>>        Delegate Get Window_Handle to hWnd
96845>>>>>>>        If (hWnd <> 0) Begin
96847>>>>>>>            Move (SetScrollPos(hWnd, If(bVert,SB_VERT,SB_HORZ), iPos, True)) to iVoid
96848>>>>>>>        End
96848>>>>>>>>
96848>>>>>>>    End_Procedure
96849>>>>>>>    
96849>>>>>>>    // scrolling containers don't do anhcors. However, this gets called every time the parent's
96849>>>>>>>    // guiSize changes. We can use that to scroll or resize the scrolling client as needed.
96849>>>>>>>    Procedure DoapplyAnchors Integer Arg1 Integer Arg2
96851>>>>>>>        Send ScrollClientArea
96852>>>>>>>    End_Procedure
96853>>>>>>>    
96853>>>>>>>    // augment to handle the scrolling area initialization.
96853>>>>>>>    Procedure Add_Focus Handle hoParent
96855>>>>>>>        Forward Send Add_Focus hoParent
96857>>>>>>>        // at this the scrolling container and client area should both be paged.
96857>>>>>>>        // child objects ae also paged with initial anchors applied
96857>>>>>>>        Send CalculateAutoScrollMinimums
96858>>>>>>>    End_Procedure
96859>>>>>>>    
96859>>>>>>>    Procedure Page Integer iPage
96861>>>>>>>        Forward Send Page iPage
96863>>>>>>>        If iPage Begin
96865>>>>>>>            // at this the scrolling container and client area should both be paged
96865>>>>>>>            // but the child controls are not paged. We don't want scrollbars when
96865>>>>>>>            // the child items are paged (else they may get anchored oddly)
96865>>>>>>>            // Prior to 19.0 these were set in Add_focus which meant that the child objects were
96865>>>>>>>            // already paged with scrollbars present. This would result in scrollbars appearing
96865>>>>>>>            // before they were really needed. This should be more accurate
96865>>>>>>>            Send SetScrollBarInfo True 0 0 0
96866>>>>>>>            Send SetScrollBarInfo False 0 0 0
96867>>>>>>>        End
96867>>>>>>>>
96867>>>>>>>    End_Procedure
96868>>>>>>>    
96868>>>>>>>    // determine scrolling minimums and set the client area as required.
96868>>>>>>>    
96868>>>>>>>    Procedure CalculateAutoScrollMinimums
96870>>>>>>>        Integer iMinX iMinY iSiz iLoc iMargin
96870>>>>>>>        Integer iAutoMinX iAutoMinY
96870>>>>>>>        Boolean bAutoScroll
96870>>>>>>>        Handle hoNext hoFirst
96870>>>>>>>        
96870>>>>>>>        Get pbAutoScroll to bAutoScroll
96871>>>>>>>        Get piAutoScrollMinX to iAutoMinX
96872>>>>>>>        Get piAutoScrollMinY to iAutoMinY
96873>>>>>>>        Get DialogToGui iAutoMinY iAutoMinX to iSiz
96874>>>>>>>        Move (Hi(iSiz)) to iAutoMinY
96875>>>>>>>        Move (Low(iSiz)) to iAutoMinX
96876>>>>>>>        Set piMinimumHeight to iAutoMinY
96877>>>>>>>        Set piMinimumWidth to iAutoMinX
96878>>>>>>>        
96878>>>>>>>        If (bAutoScroll and (iAutoMinX=0 or iAutoMinY=0)) Begin
96880>>>>>>>            
96880>>>>>>>            Get Next_Level to hoFirst
96881>>>>>>>            Move hoFirst to hoNext
96882>>>>>>>            If (hoFirst) Begin
96884>>>>>>>                Repeat
96884>>>>>>>>
96884>>>>>>>                    Get GuiWindowSize of hoNext to iSiz
96885>>>>>>>                    Get GuiLocation of hoNext to iLoc
96886>>>>>>>                    Move (Hi(iLoc)+Hi(iSiz) max iMinY) to iMinY
96887>>>>>>>                    Move (Low(iLoc)+Low(iSiz) max iMinX) to iMinx
96888>>>>>>>                    Get Next_Focus of hoNext to hoNext
96889>>>>>>>                Until (hoNext=0 or hoNext=hoFirst)
96891>>>>>>>                
96891>>>>>>>                If (iAutoMinY=0) Begin
96893>>>>>>>                    Get piAutoScrollMarginY to iMargin
96894>>>>>>>                    Set piMinimumHeight to (iMinY+iMargin)
96895>>>>>>>                End
96895>>>>>>>>
96895>>>>>>>                
96895>>>>>>>                If (iAutoMinX=0) Begin
96897>>>>>>>                    Get piAutoScrollMarginX to iMargin
96898>>>>>>>                    Set piMinimumWidth to (iMinX+iMargin)
96899>>>>>>>                    
96899>>>>>>>                End
96899>>>>>>>>
96899>>>>>>>            End
96899>>>>>>>>
96899>>>>>>>        End
96899>>>>>>>>
96899>>>>>>>        
96899>>>>>>>        // before setting the client area, unset all anchors so DoApplyAnchors will not do anything
96899>>>>>>>        Broadcast Set pbAnchorCreated to False
96901>>>>>>>        Send ScrollClientArea
96902>>>>>>>        // after the scroll set up, reinitialize all anchors.
96902>>>>>>>        Broadcast Send DoCreateAnchors
96904>>>>>>>    End_Procedure
96905>>>>>>>    
96905>>>>>>>    // Scroll the client area and adjust the client area size as needed. This does all the
96905>>>>>>>    // work of scrolling.
96905>>>>>>>    
96905>>>>>>>    Procedure ScrollClientArea
96907>>>>>>>        Integer iSiz
96907>>>>>>>        Integer iHeight iHCur iHCuriDelta iOrig iRange bOk
96907>>>>>>>        Integer iWidth iWCur iWDelta iWOrig
96907>>>>>>>        Integer iSzY iSzX iLocX iLocY
96907>>>>>>>        
96907>>>>>>>        Delegate Get GuiClientSize to iSiz
96909>>>>>>>        Move (Hi(iSiz)) to iHeight
96910>>>>>>>        Move (Low(iSiz)) to iWidth
96911>>>>>>>        
96911>>>>>>>        // Vertical scrolling
96911>>>>>>>        
96911>>>>>>>        Get piMinimumHeight to iOrig
96912>>>>>>>        Get piMinimumWidth to iWOrig
96913>>>>>>>        
96913>>>>>>>        If (iOrig<>0 or iWOrig<>0) Begin
96915>>>>>>>            
96915>>>>>>>            If (iOrig<>0) Begin
96917>>>>>>>                Get piCurrentVertScrolled to iHCur
96918>>>>>>>                // If the size got bigger and we've scrolled, we want to scroll up
96918>>>>>>>                If (iHCur<>0 and (iHCur+iHeight>iOrig)) Begin
96920>>>>>>>                    Move (iOrig-iHeight max 0) to iHCur
96921>>>>>>>                    Set piCurrentVertScrolled to iHCur
96922>>>>>>>                End
96922>>>>>>>>
96922>>>>>>>                If (iHCur<>0 or iOrig>iHeight) Begin
96924>>>>>>>                    Send SetScrollBarInfo True 0 iOrig (iHeight min iOrig)
96925>>>>>>>                    Send SetScrollBarPosInfo True iHCur
96926>>>>>>>                End
96926>>>>>>>>
96926>>>>>>>                Else Begin
96927>>>>>>>                    Send SetScrollBarInfo True 0 0 0 //iOrig (iHeight min iOrig)
96928>>>>>>>                End
96928>>>>>>>>
96928>>>>>>>            End
96928>>>>>>>>
96928>>>>>>>            
96928>>>>>>>            // Horiz scrolling
96928>>>>>>>            
96928>>>>>>>            Get piCurrentHorzScrolled to iWCur
96929>>>>>>>            // If the size got bigger and we've scrolled, we want to scroll left
96929>>>>>>>            If (iWCur<>0 and (iWCur+iWidth>iWOrig)) Begin
96931>>>>>>>                Move (iWOrig-iWidth max 0) to iWCur
96932>>>>>>>                Set piCurrentHorzScrolled to iWCur
96933>>>>>>>            End
96933>>>>>>>>
96933>>>>>>>            If (iWCur<>0 or iWOrig>iWidth) Begin
96935>>>>>>>                Send SetScrollBarInfo False 0 iWOrig (iWidth min iWOrig)
96936>>>>>>>                Send SetScrollBarPosInfo False iWCur
96937>>>>>>>            End
96937>>>>>>>>
96937>>>>>>>            Else Begin
96938>>>>>>>                Send SetScrollBarInfo False 0 0 0
96939>>>>>>>            End
96939>>>>>>>>
96939>>>>>>>        End
96939>>>>>>>>
96939>>>>>>>        
96939>>>>>>>        // this could change depending on scrollbars appearing or not
96939>>>>>>>        Delegate Get GuiClientSize to iSiz
96941>>>>>>>        
96941>>>>>>>        // size of container is the the minimum allowed size (if scrolling is needed)
96941>>>>>>>        // or it is the actual size of the container (if scrolling not needed and it is bigger)
96941>>>>>>>        // This is required to make anchors work sensibly
96941>>>>>>>        Move (hi(iSiz) max iOrig) to iSzY
96942>>>>>>>        Move (low(iSiz) max iWOrig) to iSzX
96943>>>>>>>        Move (-iHCur) to iLocY
96944>>>>>>>        Move (-iWCur) to iLocX
96945>>>>>>>        
96945>>>>>>>        // Allow chance to make modifications
96945>>>>>>>        Send AdjustSizesLocs (&iSzY) (&iSzX) (&iLocY) (&iLocX)
96946>>>>>>>        
96946>>>>>>>        Set GuiSize to iSzY iSzX
96947>>>>>>>        // if we've scrolled, we need to reposition the container
96947>>>>>>>        Set GuiLocation to iLocY iLocX
96948>>>>>>>    End_Procedure
96949>>>>>>>    
96949>>>>>>>    // note that scrolling never changes the size of the scrolling client.
96949>>>>>>>    // this way, it does not interfere with anchors.
96949>>>>>>>    
96949>>>>>>>    Procedure VScroll Integer iDelta
96951>>>>>>>        Integer iHeight iCur iOrig iSiz
96951>>>>>>>        Delegate Get GuiClientSize to iSiz
96953>>>>>>>        Move (hi(iSiz)) to iHeight
96954>>>>>>>        Get piCurrentVertScrolled to iCur
96955>>>>>>>        Get piMinimumHeight to iOrig
96956>>>>>>>        If (iOrig=0 or  Hi(iSiz)>=iOrig) Begin
96958>>>>>>>            Procedure_Return
96959>>>>>>>        End
96959>>>>>>>>
96959>>>>>>>        // make sure delta is within range
96959>>>>>>>        If (iDelta+iCur<0) Begin
96961>>>>>>>            Move (-iCur) to iDelta
96962>>>>>>>        End
96962>>>>>>>>
96962>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
96965>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
96966>>>>>>>        End
96966>>>>>>>>
96966>>>>>>>        If (iDelta=0) ;            Procedure_Return
96969>>>>>>>        
96969>>>>>>>        Move (iCur + iDelta) to iCur
96970>>>>>>>        Set piCurrentVertScrolled to iCur
96971>>>>>>>        Send SetScrollBarPosInfo True iCur
96972>>>>>>>        Get GuiLocation to iSiz
96973>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Integer)-iDelta) (cast(low(iSiz),Integer))
96974>>>>>>>        Send ScrollClientArea
96975>>>>>>>    End_Procedure
96976>>>>>>>    
96976>>>>>>>    
96976>>>>>>>    Procedure HScroll Integer iDelta
96978>>>>>>>        Integer iHeight iCur iOrig iSiz
96978>>>>>>>        Delegate Get GuiClientSize to iSiz
96980>>>>>>>        Move (low(iSiz)) to iHeight
96981>>>>>>>        Get piCurrentHorzScrolled to iCur
96982>>>>>>>        Get piMinimumWidth to iOrig
96983>>>>>>>        If (iOrig=0 or  low(iSiz)>=iOrig) Begin
96985>>>>>>>            Procedure_Return
96986>>>>>>>        End
96986>>>>>>>>
96986>>>>>>>        If (iDelta+iCur<0) Begin
96988>>>>>>>            Move (-iCur) to iDelta
96989>>>>>>>        End
96989>>>>>>>>
96989>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
96992>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
96993>>>>>>>        End
96993>>>>>>>>
96993>>>>>>>        If (iDelta=0) ;            Procedure_Return
96996>>>>>>>        
96996>>>>>>>        Move (iCur + iDelta) to iCur
96997>>>>>>>        Set piCurrentHorzScrolled to iCur
96998>>>>>>>        Send SetScrollBarPosInfo False iCur
96999>>>>>>>        Get GuiLocation to iSiz
97000>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)) (cast(low(iSiz),Short) -iDelta)
97001>>>>>>>        Send ScrollClientArea
97002>>>>>>>    End_Procedure
97003>>>>>>>    
97003>>>>>>>    // make sure client is a 0,0
97003>>>>>>>    Procedure ScrollHome
97005>>>>>>>        Send SetVScrollbox SB_TOP 0
97006>>>>>>>        Send SetHScrollbox SB_TOP 0
97007>>>>>>>    End_Procedure
97008>>>>>>>    
97008>>>>>>>    // get relative GUI location of this object to the parent one passed.
97008>>>>>>>    Procedure LocationRelativeTo Handle hoContainer Handle hoControl Integer ByRef iLocY Integer ByRef iLocX
97010>>>>>>>        Integer ivoid
97010>>>>>>>        tWinRect Rect0 Rect1
97010>>>>>>>        tWinRect Rect0 Rect1
97010>>>>>>>        Move (GetWindowRect(window_handle(hoContainer),addressof(Rect0))) to ivoid
97011>>>>>>>        Move (GetWindowRect(window_handle(hoControl),addressof(Rect1))) to ivoid
97012>>>>>>>        Move ((Rect1.top) - (Rect0.top)) to iLocY
97013>>>>>>>        Move ((rect1.left) - (rect0.left)) to iLocX
97014>>>>>>>    End_Procedure
97015>>>>>>>    
97015>>>>>>>    // This scrolls this object into visual range.
97015>>>>>>>    Procedure ScrollObjectInRange Handle hoControl
97017>>>>>>>        Handle hoScrollingContainer
97017>>>>>>>        Integer iCurrentVertScrolled iCurrentHorzScrolled
97017>>>>>>>        Integer iViewHeight iViewWidth
97017>>>>>>>        Integer iRelLocHeight iRelLocWidth
97017>>>>>>>        Integer iSize iControlHeight iControlWidth
97017>>>>>>>        Integer iScroll
97017>>>>>>>        Integer iMarginX iMarginY
97017>>>>>>>        Integer iScrollingContainerWindowSize iScrollingContainerClientSize
97017>>>>>>>        
97017>>>>>>>        Get piAutoScrollMarginX to iMarginX
97018>>>>>>>        Get piAutoScrollMarginY to iMarginY
97019>>>>>>>        
97019>>>>>>>        // the scrolling container
97019>>>>>>>        Move Self to hoScrollingContainer
97020>>>>>>>        // the amount the SC is currently scrolled
97020>>>>>>>        Get piCurrentVertScrolled of hoScrollingContainer to iCurrentVertScrolled
97021>>>>>>>        Get piCurrentHorzScrolled of hoScrollingContainer to iCurrentHorzScrolled
97022>>>>>>>        
97022>>>>>>>        // size of view's client area (this is the viewport area)
97022>>>>>>>        Get GuiClientSize of (Parent(hoScrollingContainer)) to iSize
97023>>>>>>>        Move (hi(iSize)) to iViewHeight
97024>>>>>>>        Move (low(iSize)) to iViewWidth
97025>>>>>>>        
97025>>>>>>>        // get this object's location relative to the scrolling container
97025>>>>>>>        Send LocationRelativeTo hoScrollingContainer hoControl (&iRelLocHeight) (&iRelLocWidth)
97026>>>>>>>        
97026>>>>>>>        // we expect that the client size is the window size but just in case
97026>>>>>>>        Get GuiWindowSize of hoScrollingContainer to iScrollingContainerWindowSize
97027>>>>>>>        Get GuiClientSize of hoScrollingContainer to iScrollingContainerClientSize
97028>>>>>>>        Move (iRelLocHeight - (Hi(iScrollingContainerWindowSize)-Hi(iScrollingContainerClientSize))) to iRelLocHeight
97029>>>>>>>        Move (iRelLocWidth - (Low(iScrollingContainerWindowSize)-Low(iScrollingContainerClientSize))) to iRelLocWidth
97030>>>>>>>        
97030>>>>>>>        // the outer size of the control object
97030>>>>>>>        Get GUIWindowSize of hoControl to iSize
97031>>>>>>>        Move (hi(iSize)) to iControlHeight
97032>>>>>>>        Move (low(iSize)) to iControlWidth
97033>>>>>>>        
97033>>>>>>>        // the general idea is to make the control fully visible but to scroll as little as possible.
97033>>>>>>>        
97033>>>>>>>        // Vertical Scroll
97033>>>>>>>        
97033>>>>>>>        // Vertical Scroll down
97033>>>>>>>        // if the bottom of the control plus a bottom margin does not fit make it fit at the bottom
97033>>>>>>>        If (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled >iViewHeight) Begin
97035>>>>>>>            
97035>>>>>>>            // set scroll amount so that the bottom of the control is visible
97035>>>>>>>            Move (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled - iViewHeight ) to iScroll
97036>>>>>>>            
97036>>>>>>>            // See if this amount, scrolls the top out of range. If so just scroll enough so that the
97036>>>>>>>            // top of the object appears at the bottom
97036>>>>>>>            If (iRelLocHeight - iCurrentVertScrolled < iScroll) Begin
97038>>>>>>>                Move (iRelLocHeight + iMarginY  - iCurrentVertScrolled - iViewHeight  ) to iScroll
97039>>>>>>>            End
97039>>>>>>>>
97039>>>>>>>            // if the scroll amnt is negative it's best to just keep it where it is.
97039>>>>>>>            If (iScroll>0) Begin
97041>>>>>>>                Send VScroll of hoScrollingContainer iScroll
97042>>>>>>>            End
97042>>>>>>>>
97042>>>>>>>        End
97042>>>>>>>>
97042>>>>>>>        // else vertical scroll up
97042>>>>>>>        // We scroll if the top of the object is not visible.
97042>>>>>>>        Else If (iRelLocHeight + iMarginY < iCurrentVertScrolled) Begin
97045>>>>>>>            // if we scroll we will scroll enough to see the top of the object.
97045>>>>>>>            Move (iRelLocHeight -iMarginY - iCurrentVertScrolled ) to iScroll
97046>>>>>>>            If (iScroll<0) Begin
97048>>>>>>>                Send VScroll of hoScrollingContainer (iScroll max (-iCurrentVertScrolled))
97049>>>>>>>            End
97049>>>>>>>>
97049>>>>>>>        End
97049>>>>>>>>
97049>>>>>>>        
97049>>>>>>>        // Horizonal Scroll
97049>>>>>>>        
97049>>>>>>>        // if the right side of the control does not fit, scroll it so it fits
97049>>>>>>>        If (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled >iViewWidth) Begin
97051>>>>>>>            Move (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled - iViewWidth ) to iScroll
97052>>>>>>>            If (iRelLocWidth - iCurrentHorzScrolled - iScroll<0) Begin
97054>>>>>>>                Move (iRelLocWidth  - iCurrentHorzScrolled - iMarginX ) to iScroll
97055>>>>>>>            End
97055>>>>>>>>
97055>>>>>>>            If (iScroll>0) Begin
97057>>>>>>>                Send HScroll of hoScrollingContainer iScroll
97058>>>>>>>            End
97058>>>>>>>>
97058>>>>>>>        End
97058>>>>>>>>
97058>>>>>>>        If (iRelLocWidth - iMarginX  - iCurrentHorzScrolled <0) Begin
97060>>>>>>>            // if this can fit by moving all the way to left, do so.
97060>>>>>>>            If (iRelLocWidth + iControlWidth + iMarginX <= iViewWidth) Begin
97062>>>>>>>                Move (-iCurrentHorzScrolled) to iScroll
97063>>>>>>>            End
97063>>>>>>>>
97063>>>>>>>            Else Begin
97064>>>>>>>                Move (iRelLocWidth - iCurrentHorzScrolled - iMarginX) to iScroll
97065>>>>>>>            End
97065>>>>>>>>
97065>>>>>>>            If (iScroll<0) Begin
97067>>>>>>>                Send HScroll of hoScrollingContainer (iScroll max (-iCurrentHorzScrolled))
97068>>>>>>>            End
97068>>>>>>>>
97068>>>>>>>        End
97068>>>>>>>>
97068>>>>>>>        
97068>>>>>>>        
97068>>>>>>>    End_Procedure
97069>>>>>>>    
97069>>>>>>>    // when we receive this message, we might need to scroll to bring the new focus in to view.
97069>>>>>>>    Procedure NotifyFocusSetInContainer Handle hoControl
97071>>>>>>>        Boolean bScrollOnFocus
97071>>>>>>>        Get pbAutoScrollFocus to bScrollOnFocus
97072>>>>>>>        If bScrollOnFocus Begin
97074>>>>>>>            Send ScrollObjectInRange hoControl
97075>>>>>>>        End
97075>>>>>>>>
97075>>>>>>>        Delegate Send NotifyFocusSetInContainer hoControl
97077>>>>>>>    End_Procedure
97078>>>>>>>    
97078>>>>>>>    
97078>>>>>>>    Function CenterTabWorkspaceView Returns Boolean
97080>>>>>>>        Boolean bCenter
97080>>>>>>>        Get pbCenterTabbedViews of ghoCommandBars to bCenter
97081>>>>>>>        Function_Return bCenter
97082>>>>>>>    End_Function
97083>>>>>>>    
97083>>>>>>>    Procedure AdjustSizesLocs Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
97085>>>>>>>        Boolean bTabWorkspaceView
97085>>>>>>>        Get pbTabWorkspaceView to bTabWorkspaceView
97086>>>>>>>        If bTabWorkspaceView Begin
97088>>>>>>>            Send AdjustTabWorkspaceView (&iHeight) (&iWidth) (&iLocY) (&iLocX)
97089>>>>>>>        End
97089>>>>>>>>
97089>>>>>>>    End_Procedure
97090>>>>>>>    
97090>>>>>>>    Function ParentView Returns Handle
97092>>>>>>>        Function_Return (Parent(Parent(Self)))
97093>>>>>>>    End_Function
97094>>>>>>>    
97094>>>>>>>    Procedure AdjustTabWorkspaceView Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
97096>>>>>>>        Integer iSize iMax iDiff
97096>>>>>>>        Handle hoView
97096>>>>>>>        Boolean bCenter bModal
97096>>>>>>>        Get ParentView to hoView
97097>>>>>>>        Get Block_Mouse_State of hoView to bModal
97098>>>>>>>        If not bModal Begin
97100>>>>>>>            Get CenterTabWorkspaceView to bCenter
97101>>>>>>>            Get GuiSize of hoView to iSize
97102>>>>>>>            Get piMaxSize of hoView to iMax
97103>>>>>>>            Get DialogToGui (Hi(iMax)) (Low(iMax)) to iMax
97104>>>>>>>            If (Low(iMax) and Low(iMax)<=Low(isize)) Begin
97106>>>>>>>                If bCenter Begin
97108>>>>>>>                    Move ((Low(iSize)-Low(iMax))/2) to iLocX
97109>>>>>>>                End
97109>>>>>>>>
97109>>>>>>>                Move (Low(iMax)) to iWidth
97110>>>>>>>            End
97110>>>>>>>>
97110>>>>>>>            If (Hi(iMax) and Hi(iMax)<=Hi(iSize)) Begin
97112>>>>>>>                If bCenter Begin
97114>>>>>>>                    Move ((Hi(iSize)-Hi(iMax))/2) to iLocY
97115>>>>>>>                    Move (iLocy min 25) to  iLocY
97116>>>>>>>                End
97116>>>>>>>>
97116>>>>>>>                Move (Hi(imax)) to iHeight
97117>>>>>>>            End
97117>>>>>>>>
97117>>>>>>>        End
97117>>>>>>>>
97117>>>>>>>    End_Procedure
97118>>>>>>>    
97118>>>>>>>    // Automatically determine if this is a scrolling tabbed workspace view
97118>>>>>>>    // If determines this by checking pbAutoSetTabWorkspaceView is set (it can be
97118>>>>>>>    // set to stop this), if we have a global commandbar object and we are using tabbed
97118>>>>>>>    // workspaces. We also make sure that the expected view object is a framework view class
97118>>>>>>>    // This should almost always yield the right answer.
97118>>>>>>>    // This is called by the scrolling container's end_constructor
97118>>>>>>>    Procedure AutoSetTabWorkspaceView
97120>>>>>>>        Boolean bTabView bIsView bAutoSetTabWorkspaceView
97120>>>>>>>        Handle hoParent
97120>>>>>>>        Integer iSize
97120>>>>>>>        Get pbAutoSetTabWorkspaceView to bAutoSetTabWorkspaceView
97121>>>>>>>        If (ghoCommandBars and bAutoSetTabWorkspaceView) Begin
97123>>>>>>>            Get pbTabbedWorkspaces of ghoCommandBars to bTabView
97124>>>>>>>            // not that pbTabbedWorkspaces is a designtime only property. You can not
97124>>>>>>>            // change this after the commandbar is paged.
97124>>>>>>>            If (bTabView) Begin
97126>>>>>>>                Get ParentView to hoParent
97127>>>>>>>                Get IsObjectOfClass of hoParent (RefClass(MdiDialog)) to bIsView
97128>>>>>>>                If (bIsView) Begin
97130>>>>>>>                    // set this as a tab workspace view
97130>>>>>>>                    Set pbTabWorkspaceView to True
97131>>>>>>>                    // when tab workspaces are enabled we always enable auto-scrolling
97131>>>>>>>                    // when tab workspaces are not enabled, pbScroll is whatever it is
97131>>>>>>>                    Set pbAutoScroll to True
97132>>>>>>>                    
97132>>>>>>>                End
97132>>>>>>>>
97132>>>>>>>            End
97132>>>>>>>>
97132>>>>>>>        End
97132>>>>>>>>
97132>>>>>>>    End_Procedure
97133>>>>>>>    
97133>>>>>>>End_Class
97134>>>>>>>
97134>>>>>>>// Container scrolling class support. Nothing in here is public
97134>>>>>>>Class cScrollingContainerMixin is a Mixin
97135>>>>>>>    
97135>>>>>>>    Procedure Define_cScrollingContainerMixin
97137>>>>>>>        Forward Set Border_Style to Border_None
97139>>>>>>>        Set pbSizeToClientArea to False // scrollbars and clientsize do not mix
97140>>>>>>>        Forward Set peAnchors to anAll
97142>>>>>>>        
97142>>>>>>>        // forcing scrollbars right away seems to make painting better
97142>>>>>>>        Set Window_Style WS_HSCROLL to True
97143>>>>>>>        Set Window_Style WS_VSCROLL to True
97144>>>>>>>        
97144>>>>>>>        Property Handle phoScrollingClientArea 0
97145>>>>>>>    End_Procedure
97146>>>>>>>    
97146>>>>>>>    // if anchors are changed, it will not work. We won't let that happen
97146>>>>>>>    Procedure Set peAnchors Integer eAnchors
97148>>>>>>>    End_Procedure
97149>>>>>>>    
97149>>>>>>>    // if a border style is set, it will not work. We won't let that happen
97149>>>>>>>    Procedure Set Border_Style Integer eStyle
97151>>>>>>>    End_Procedure
97152>>>>>>>    
97152>>>>>>>    // redirect scrollbar events and wheel events to the scrolling client area
97152>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
97154>>>>>>>        Handle hoClient
97154>>>>>>>        Get phoScrollingClientArea to hoClient
97155>>>>>>>        If hoClient Begin
97157>>>>>>>            Send OnMouseWheel of hoClient wParam lParam
97158>>>>>>>        End
97158>>>>>>>>
97158>>>>>>>    End_Procedure
97159>>>>>>>    
97159>>>>>>>    // should be sent by WM_VSCROLL
97159>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
97161>>>>>>>        Handle hoClient
97161>>>>>>>        Get phoScrollingClientArea to hoClient
97162>>>>>>>        If hoClient Begin
97164>>>>>>>            Send SetVScrollbox of hoClient iType iNewPos
97165>>>>>>>        End
97165>>>>>>>>
97165>>>>>>>    End_Procedure
97166>>>>>>>    
97166>>>>>>>    // should be sent by WM_HSCROLL
97166>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
97168>>>>>>>        Handle hoClient
97168>>>>>>>        Get phoScrollingClientArea to hoClient
97169>>>>>>>        If hoClient Begin
97171>>>>>>>            Send SetHScrollbox of hoClient iType iNewPos
97172>>>>>>>        End
97172>>>>>>>>
97172>>>>>>>    End_Procedure
97173>>>>>>>    
97173>>>>>>>    // augmented to adjust its size to the size of the parent client area.
97173>>>>>>>    // After this is set, anchors will handle any further resizing.
97173>>>>>>>    Procedure Page Integer iState
97175>>>>>>>        Integer iSiz iHeight iWidth
97175>>>>>>>        Integer iTop iBottom iLeft iRight iFontSize
97175>>>>>>>        Boolean bGroup
97175>>>>>>>        Handle hoClient
97175>>>>>>>        If (iState =1) Begin
97177>>>>>>>            Delegate Get Window_Style BS_GROUPBOX to bGroup
97179>>>>>>>            // We have special code to support groups because they
97179>>>>>>>            // draw a border inside of the client rectangle
97179>>>>>>>            If bGroup Begin
97181>>>>>>>                Get Physical_FontSize to iFontSize
97182>>>>>>>                Move (Hi(iFontSize)) to iTop
97183>>>>>>>                Move 2 to iLeft
97184>>>>>>>                Move 2 to iRight
97185>>>>>>>                Move 2 to iBottom
97186>>>>>>>            End
97186>>>>>>>>
97186>>>>>>>            // We use GetContainerClientSize instead of GuiClientSize because
97186>>>>>>>            // GetContainerClientSize has a special augmentation in tab pages that
97186>>>>>>>            // makes anchors work properly with unpaged tab-pages
97186>>>>>>>            Delegate Get GetContainerClientSize to iSiz
97188>>>>>>>            Set GuiSize to (Hi(iSiz)-(iTop+iBottom)) (Low(iSiz)-(iLeft+iRight))
97189>>>>>>>            Set GuiLocation to iTop iLeft
97190>>>>>>>            Send Adjust_Logicals
97191>>>>>>>        End
97191>>>>>>>>
97191>>>>>>>        Forward Send Page iState
97193>>>>>>>    End_Procedure
97194>>>>>>>    
97194>>>>>>>    Procedure End_Construct_Object
97196>>>>>>>        Handle hoClient
97196>>>>>>>        Forward Send End_Construct_Object
97198>>>>>>>        Get phoScrollingClientArea to hoClient
97199>>>>>>>        If (hoClient) Begin
97201>>>>>>>            Send AutoSetTabWorkspaceView of hoClient
97202>>>>>>>        End
97202>>>>>>>>
97202>>>>>>>    End_Procedure
97203>>>>>>>    
97203>>>>>>>End_Class
97204>>>>>
97204>>>>>Class cDbScrollingClientArea is a dbContainer3d
97205>>>>>    Import_Class_Protocol cScrollingClientAreaMixin
97206>>>>>    Procedure Construct_Object
97208>>>>>        Forward Send Construct_Object
97210>>>>>        Send Define_cScrollingClientAreaMixin
97211>>>>>    End_Procedure
97212>>>>>End_Class
97213>>>>>
97213>>>>>
97213>>>>>
97213>>>>>Class cDbScrollingContainer is a dbContainer3d
97214>>>>>    Import_Class_Protocol cScrollingContainerMixin
97215>>>>>    Procedure Construct_Object
97217>>>>>        Forward Send Construct_Object
97219>>>>>        Send Define_cScrollingContainerMixin
97220>>>>>    End_Procedure
97221>>>>>End_Class
97222>>>Use cDbUpdateFunctionLibrary.pkg
97222>>>Use cRDCButtonDPI.pkg
Including file: cRDCButtonDPI.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButtonDPI.pkg)
97222>>>>>//****************************************************************************
97222>>>>>// $Module type: Package
97222>>>>>// $Module name: cRDCButtonDPI.pkg
97222>>>>>//
97222>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
97222>>>>>// Copyright (c) 2013 RDC Tools International
97222>>>>>// E-mail      : support@rdctools.com
97222>>>>>// Web-site    : http://www.rdctools.com
97222>>>>>//
97222>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
97222>>>>>//
97222>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
97222>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
97222>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
97222>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
97222>>>>>// in the help folder for more details.
97222>>>>>//
97222>>>>>//****************************************************************************
97222>>>>>Use cRDCButton.pkg
Including file: cRDCButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButton.pkg)
97222>>>>>>>//****************************************************************************
97222>>>>>>>// $Module type: Package
97222>>>>>>>// $Module name: cRDCButton.pkg
97222>>>>>>>//
97222>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
97222>>>>>>>// Copyright (c) 2013 RDC Tools International
97222>>>>>>>// E-mail      : support@rdctools.com
97222>>>>>>>// Web-site    : http://www.rdctools.com
97222>>>>>>>//
97222>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
97222>>>>>>>//
97222>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
97222>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
97222>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
97222>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
97222>>>>>>>// in the help folder for more details.
97222>>>>>>>//
97222>>>>>>>//****************************************************************************
97222>>>>>>>Use Windows.pkg
97222>>>>>>>Use Enclient.pkg
97222>>>>>>>Use errornum.inc
97222>>>>>>>
97222>>>>>>>Class cButtonIdleHandler is a cIdleHandler
97223>>>>>>>    Procedure Construct_Object
97225>>>>>>>        Forward Send Construct_Object
97227>>>>>>>
97227>>>>>>>    End_Procedure
97228>>>>>>>
97228>>>>>>>    Procedure OnIdle
97230>>>>>>>        Delegate Send DoUpdate
97232>>>>>>>    End_Procedure
97233>>>>>>>
97233>>>>>>>End_Class
97234>>>>>>>
97234>>>>>>>Class cRDCButton is a Button
97235>>>>>>>
97235>>>>>>>    Procedure Construct_Object
97237>>>>>>>        Forward Send Construct_Object
97239>>>>>>>
97239>>>>>>>        Property Boolean pbAutoEnable True
97240>>>>>>>
97240>>>>>>>        Property Boolean pbEnabled True
97241>>>>>>>
97241>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cButtonIdleHandler)))
97242>>>>>>>
97242>>>>>>>        On_Key kCancel Send CancelIfPopupObject
97243>>>>>>>    End_Procedure
97244>>>>>>>
97244>>>>>>>    Procedure CancelIfPopupObject
97246>>>>>>>        Boolean bIsInPopupObject
97246>>>>>>>        Delegate Get Popup_State to bIsInPopupObject
97248>>>>>>>        If (bIsInPopupObject = True) Begin
97250>>>>>>>            Send Close_Panel
97251>>>>>>>        End
97251>>>>>>>>
97251>>>>>>>    End_Procedure
97252>>>>>>>
97252>>>>>>>    Procedure End_Construct_Object
97254>>>>>>>        String sTooltip sStatus_Help
97254>>>>>>>
97254>>>>>>>        Forward Send End_Construct_Object
97256>>>>>>>
97256>>>>>>>        Get psToolTip   to sTooltip
97257>>>>>>>        Get Status_Help to sStatus_Help
97258>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
97260>>>>>>>            Set psToolTip to sStatus_Help
97261>>>>>>>        End
97261>>>>>>>>
97261>>>>>>>        If (sTooltip <> "" and sStatus_Help = "") Begin
97263>>>>>>>            Set Status_Help to sToolTip
97264>>>>>>>        End
97264>>>>>>>>
97264>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
97265>>>>>>>    End_Procedure
97266>>>>>>>
97266>>>>>>>    Procedure DoUpdate
97268>>>>>>>        If (pbAutoEnable(Self) = False) Begin
97270>>>>>>>            Procedure_Return
97271>>>>>>>        End
97271>>>>>>>>
97271>>>>>>>        Set Enabled_State to (IsEnabled(Self))
97272>>>>>>>    End_Procedure
97273>>>>>>>
97273>>>>>>>    Function IsEnabled Returns Boolean
97275>>>>>>>        Boolean bEnabled
97275>>>>>>>        Get pbEnabled to bEnabled
97276>>>>>>>        Function_Return bEnabled
97277>>>>>>>    End_Function
97278>>>>>>>
97278>>>>>>>    // Enable the idle handler timer when the button is activated
97278>>>>>>>    Procedure Activating
97280>>>>>>>        Forward Send Activating
97282>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
97283>>>>>>>    End_Procedure
97284>>>>>>>
97284>>>>>>>    // Disable the idle handler when the button is deactivated
97284>>>>>>>    Procedure Deactivating
97286>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
97287>>>>>>>        Forward Send Deactivating
97289>>>>>>>    End_Procedure
97290>>>>>>>
97290>>>>>>>End_Class
97291>>>>>
97291>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
97291>>>>>Class cRDCButtonDPI is a cRDCButton
97292>>>>>    Procedure Construct_Object
97294>>>>>        Integer iIconSize
97294>>>>>        Forward Send Construct_Object
97296>>>>>        Set piImageMarginLeft to 10
97297>>>>>    End_Procedure
97298>>>>>
97298>>>>>    // Returns: DPI setting as an integer.
97298>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
97298>>>>>    //                      iDPI=120 is "Medium setting" 125%
97298>>>>>    //                      iDPI= 144 is "Large setting" 150%
97298>>>>>    Function GetCurrentDPI Returns Integer
97300>>>>>        Handle hDC
97300>>>>>        Integer iPixelsX
97300>>>>>        Move (GetDC(0)) to hDC
97301>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
97302>>>>>        Move (ReleaseDC(0, hDC)) to hDC
97303>>>>>        Function_Return iPixelsX
97304>>>>>    End_Function
97305>>>>>
97305>>>>>    Function GetCorrectIconSize Returns Integer
97307>>>>>        Integer iPixelsX iIndex iSize
97307>>>>>        Integer[] iaSizes
97308>>>>>
97308>>>>>        Move 16 to iaSizes[0]
97309>>>>>        Move 24 to iaSizes[1]
97310>>>>>        Move 32 to iaSizes[2]
97311>>>>>        Move 48 to iaSizes[3]
97312>>>>>        Move 64 to iaSizes[4]
97313>>>>>
97313>>>>>        Get piImageSize to iSize  // the "100%" size
97314>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
97315>>>>>        Move (0 max iIndex) to iIndex
97316>>>>>        Get GetCurrentDPI to iPixelsX
97317>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
97317>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
97317>>>>>        // will increment iIndex as many times as we need here.
97317>>>>>        Case Begin
97317>>>>>            Case (iPixelsX > 144)
97319>>>>>                Increment iIndex
97320>>>>>            Case (iPixelsX = 144)
97323>>>>>                Increment iIndex
97324>>>>>            Case (iPixelsX = 120)
97327>>>>>                Increment iIndex
97328>>>>>        Case End
97328>>>>>        Move (iIndex min 4) to iIndex
97329>>>>>        Function_Return iaSizes[iIndex]
97330>>>>>    End_Function
97331>>>>>
97331>>>>>    Procedure Set psToolTip String sToolTip
97333>>>>>        String sStatusHelp
97333>>>>>
97333>>>>>        Get Status_Help to sStatusHelp
97334>>>>>        If (sStatusHelp = "") Begin
97336>>>>>            Set Status_Help to sToolTip
97337>>>>>        End
97337>>>>>>
97337>>>>>
97337>>>>>        Forward Set psToolTip to sToolTip
97339>>>>>    End_Procedure
97340>>>>>
97340>>>>>End_Class
97341>>>Use DatabaseSelection.dg
97341>>>Use ServerSelection.dg
Including file: ServerSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ServerSelection.dg)
97341>>>>>Use Windows.pkg
97341>>>>>Use cCJGridPromptList.pkg
97341>>>>>Use MSSqldrv.pkg
97341>>>>>Use db2_drv.pkg
97341>>>>>Use odbc_drv.pkg    
97341>>>>>Use cRDCModalPanel.pkg
97341>>>>>Use cDbUpdateFunctionLibrary.pkg
97341>>>>>
97341>>>>>Object oServerSelection_sl is a cRDCModalPanel
97343>>>>>    Set Size to 105 225
97344>>>>>    Set Label to "Database Server/DSN Selection"
97345>>>>>    Set piMinSize to 89 211
97346>>>>>    Set Location to 2 2
97347>>>>>    Set Icon to "ServerLookup.ico"
97348>>>>>
97348>>>>>    Property String[] psTheData
97350>>>>>
97350>>>>>    Object oSelList is a cCJGridPromptList
97352>>>>>        Set Size to 72 215
97353>>>>>        Set Location to 6 6
97354>>>>>        Set peAnchors to anAll
97355>>>>>        Set pbAllowColumnRemove to False
97356>>>>>        Set pbUseAlternateRowBackgroundColor to True
97357>>>>>        Set pbGrayIfDisable to False
97358>>>>>        Set pbHeaderReorders to False
97359>>>>>        Set pbHeaderSelectsColumn to False
97360>>>>>        Set pbHeaderTogglesDirection to False
97361>>>>>        Set pbShadeSortColumn to False
97362>>>>>        Set piFocusCellBackColor to clDkGray
97363>>>>>
97363>>>>>        Object oName is a cCJGridColumn
97365>>>>>            Set piWidth to 358
97366>>>>>            Set psCaption to "Name"
97367>>>>>        End_Object
97368>>>>>
97368>>>>>        Procedure Activating
97371>>>>>            tDataSourceRow[] MyData
97371>>>>>            tDataSourceRow[] MyData
97372>>>>>            Handle hoDataSource
97372>>>>>            String[] sTheData
97373>>>>>            Integer iCount iSize
97373>>>>>
97373>>>>>            Send Cursor_Wait of Cursor_Control
97374>>>>>            Get psTheData to sTheData
97375>>>>>            Move (SizeOfArray(sTheData)) to iSize
97376>>>>>            Decrement iSize
97377>>>>>            For iCount from 0 to iSize
97383>>>>>>
97383>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
97384>>>>>            Loop
97385>>>>>>
97385>>>>>
97385>>>>>            Forward Send Activating
97387>>>>>
97387>>>>>            Get phoDataSource to hoDataSource
97388>>>>>            Send InitializeData of hoDataSource MyData
97389>>>>>            Send Cursor_Ready of Cursor_Control
97390>>>>>        End_Procedure
97391>>>>>
97391>>>>>    End_Object
97392>>>>>
97392>>>>>    Object oOK_Btn is a Button
97394>>>>>        Set Size to 14 50
97395>>>>>        Set Label    to "&OK"
97396>>>>>        Set Location to 85 116
97397>>>>>        Set peAnchors To anBottomRight
97398>>>>>
97398>>>>>        Procedure OnClick
97401>>>>>            Send Ok of oSelList
97402>>>>>        End_Procedure
97403>>>>>
97403>>>>>    End_Object
97404>>>>>
97404>>>>>    Object oCancel_Btn is a Button
97406>>>>>        Set Size to 14 50
97407>>>>>        Set Label    to "&Cancel"
97408>>>>>        Set Location to 85 171
97409>>>>>        Set peAnchors to anBottomRight
97410>>>>>
97410>>>>>        Procedure OnClick
97413>>>>>            Send Close_Panel
97414>>>>>        End_Procedure
97415>>>>>
97415>>>>>    End_Object
97416>>>>>
97416>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
97417>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
97418>>>>>End_Object
97419>>>Use SQLConnections.dg
Including file: SQLConnections.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLConnections.dg)
97419>>>>>Use Windows.pkg
97419>>>>>Use cCJGridPromptList.pkg
97419>>>>>Use cDbUpdateFunctionLibrary.pkg
97419>>>>>Use MSSqldrv.pkg
97419>>>>>Use db2_drv.pkg
97419>>>>>Use odbc_drv.pkg
97419>>>>>Use cCJGridColumn.pkg
97419>>>>>
97419>>>>>Object oSQLConnections is a ModalPanel
97421>>>>>    Set Label to "SQL Connections"
97422>>>>>    Set Size to 121 397
97423>>>>>    Set piMinSize to 89 185
97424>>>>>    Set Location to 2 2
97425>>>>>    Set Border_Style to Border_Thick
97426>>>>>
97426>>>>>    Property tSQLConnection[] psTheData
97428>>>>>
97428>>>>>//    If (ghoDbUpdateFunctionLibrary = 0) Begin
97428>>>>>//        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
97428>>>>>//        End_Object
97428>>>>>//    End
97428>>>>>
97428>>>>>    Object oSelListSQLConnections is a cCJGridPromptList
97430>>>>>        Set Size to 90 377
97431>>>>>        Set Location to 6 6
97432>>>>>        Set peAnchors to anAll
97433>>>>>        Set pbAllowColumnRemove to False
97434>>>>>        Set pbUseAlternateRowBackgroundColor to True
97435>>>>>        Set pbGrayIfDisable to False
97436>>>>>        Set pbHeaderReorders to False
97437>>>>>        Set pbHeaderSelectsColumn to False
97438>>>>>        Set pbHeaderTogglesDirection to False
97439>>>>>        Set pbShadeSortColumn to False
97440>>>>>        Set piFocusCellBackColor to clDkGray  
97441>>>>>        Set pbRestoreLayout to True
97442>>>>>        Set psLayoutSection to "oSQLConnections_oSelListSQLConnections"
97443>>>>>
97443>>>>>        Object oID_Col is a cCJGridColumn
97445>>>>>            Set piWidth to 132
97446>>>>>            Set psCaption to "ID"
97447>>>>>        End_Object
97448>>>>>
97448>>>>>        Object oDbType_Col is a cCJGridColumn
97450>>>>>            Set piWidth to 182
97451>>>>>            Set psCaption to "Database Type"
97452>>>>>        End_Object
97453>>>>>
97453>>>>>        Object oServer_Col is a cCJGridColumn
97455>>>>>            Set piWidth to 296
97456>>>>>            Set psCaption to "Server/DSN"
97457>>>>>        End_Object
97458>>>>>
97458>>>>>        Object oDatabase_Col is a cCJGridColumn
97460>>>>>            Set piWidth to 211
97461>>>>>            Set psCaption to "Database"
97462>>>>>        End_Object
97463>>>>>
97463>>>>>        Object oDriverID_Col is a cCJGridColumn
97465>>>>>            Set piWidth to 121
97466>>>>>            Set psCaption to "Driver ID"
97467>>>>>        End_Object
97468>>>>>
97468>>>>>        Procedure Activating
97471>>>>>            tDataSourceRow[] MyData
97471>>>>>            tDataSourceRow[] MyData
97472>>>>>            Handle hoDataSource
97472>>>>>            Integer iCount iSize iPos
97472>>>>>            String sDriverID sConnectionID sValue
97472>>>>>            tSQLConnection[] sTheData
97472>>>>>            tSQLConnection[] sTheData
97473>>>>>
97473>>>>>            Send Cursor_Wait of Cursor_Control
97474>>>>>            Forward Send Activating
97476>>>>>
97476>>>>>            Get psTheData to sTheData
97477>>>>>            Move (SizeOfArray(sTheData)) to iSize
97478>>>>>            Decrement iSize
97479>>>>>            For iCount from 0 to iSize
97485>>>>>>
97485>>>>>                Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary sTheData[iCount].iDbType to sValue
97486>>>>>                Move sTheData[iCount].sConnectionID to MyData[iCount].sValue[0]
97487>>>>>                Move sValue                         to MyData[iCount].sValue[1]
97488>>>>>                Move sTheData[iCount].sServer       to MyData[iCount].sValue[2]
97489>>>>>                Move sTheData[iCount].sDatabase     to MyData[iCount].sValue[3]
97490>>>>>                Move sTheData[iCount].sDriverID     to MyData[iCount].sValue[4]
97491>>>>>            Loop
97492>>>>>>
97492>>>>>
97492>>>>>            Get phoDataSource to hoDataSource
97493>>>>>            Send InitializeData of hoDataSource MyData
97494>>>>>            Send Cursor_Ready of Cursor_Control
97495>>>>>        End_Procedure
97496>>>>>
97496>>>>>    End_Object
97497>>>>>
97497>>>>>    Object oOK_Btn is a Button
97499>>>>>        Set Label    to "&OK"
97500>>>>>        Set Location to 101 280
97501>>>>>        Set peAnchors to anBottomRight
97502>>>>>
97502>>>>>        Procedure OnClick
97505>>>>>            Send Ok of oSelListSQLConnections
97506>>>>>        End_Procedure
97507>>>>>
97507>>>>>    End_Object
97508>>>>>
97508>>>>>    Object oCancel_Btn is a Button
97510>>>>>        Set Label    to "&Cancel"
97511>>>>>        Set Location to 101 335
97512>>>>>        Set peAnchors to anBottomRight
97513>>>>>
97513>>>>>        Procedure OnClick
97516>>>>>            Send Close_Panel
97517>>>>>        End_Procedure
97518>>>>>
97518>>>>>    End_Object
97519>>>>>
97519>>>>>    Procedure Page Integer iPageObject
97522>>>>>        Set Icon to "SQLConnections.ico"
97523>>>>>        Forward Send Page iPageObject
97525>>>>>    End_Procedure
97526>>>>>
97526>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
97527>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
97528>>>>>End_Object
97529>>>
97529>>>Activate_View Activate_oSQLConnections_vw for oSQLConnections_vw
97539>>>>
97539>>>Object oSQLConnections_vw is a dbView
97541>>>    Set Border_Style to Border_Thick
97542>>>    Set Size to 251 427
97543>>>    Set Location to 2 2
97544>>>    Set Label to "SQL Connections"
97545>>>    Set pbAutoActivate to True
97546>>>    Set Icon to "SQLConnections.ico"
97547>>>
97547>>>    Object oScrollingContainer1 is a cDbScrollingContainer
97549>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
97551>>>
97551>>>            Object oCurrentSettings_grp is a Group
97553>>>                Set Size to 232 402
97554>>>                Set Location to 6 12
97555>>>                Set Label to "Current Connection Settings"
97556>>>                Set peAnchors to anAll
97557>>>
97557>>>                Object oConnectionID_fm is a Form
97559>>>                    Set Size to 12 100
97560>>>                    Set Location to 12 68
97561>>>                    Set Label to "Connection ID"
97562>>>                    Set Label_Col_Offset to 2
97563>>>                    Set Label_Justification_Mode to JMode_Right
97564>>>                    Set Prompt_Button_Mode to PB_PromptOn
97565>>>                    Set Prompt_Object to (oSQLConnections(Self))
97566>>>
97566>>>                    Procedure Prompt
97569>>>                        String[] sTheData
97570>>>                        String sCurrentVal sNewVal
97570>>>                        Handle hoIniFile ho
97570>>>                        Integer iSize iCount
97570>>>                        tSQLConnection[] SQLConnectionArray
97570>>>                        tSQLConnection[] SQLConnectionArray
97571>>>
97571>>>                        Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to hoIniFile
97572>>>                        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
97573>>>                        Get Value to sCurrentVal
97574>>>                        Get Prompt_Object to ho
97575>>>                        Set psTheData of ho to SQLConnectionArray
97576>>>
97576>>>                        Forward Send Prompt
97578>>>                        Get Value to sNewVal
97579>>>                        If (sCurrentVal <> sNewVal) Begin
97581>>>                            Send Cursor_Wait of Cursor_Control
97582>>>                            Set psConnectionID of ghoSQLConnectionHandler to sNewVal
97583>>>                            Broadcast Recursive Send Refresh of (phoMainPanel(ghoApplication))
97585>>>                            Send Cursor_Ready of Cursor_Control
97586>>>                            Send KeyAction of oTestLogin_btn
97587>>>                        End
97587>>>>
97587>>>                    End_Procedure   
97588>>>                    
97588>>>                    Procedure PromptUpdate Handle hoPrompt
97591>>>                        String[] sSelectedNames                    
97592>>>                
97592>>>                        Get SelectedColumnValues of hoPrompt 2 to sSelectedNames // Col 2 = Server column
97593>>>                        If (SizeOfArray(sSelectedNames)) Begin
97595>>>                            Set psServer of ghoSQLConnectionHandler to sSelectedNames[0] 
97596>>>                            Delegate Send Page True // Broadcast sends refresh
97598>>>                        End
97598>>>>
97598>>>                    End_Procedure   
97599>>>
97599>>>                    Procedure Prompt_Callback Handle hoPrompt
97602>>>                        String sServer
97602>>>                        Set peUpdateMode of hoPrompt to umPromptCustom
97603>>>                        Set piUpdateColumn of hoPrompt to 2 // The server column
97604>>>                        Get Value of oServer_fm to sServer
97605>>>                        Set psSeedValue of hoPrompt to sServer
97606>>>                        Set phmPromptUpdateCallback of hoPrompt to (RefProc(PromptUpdate))
97607>>>                    End_Procedure
97608>>>
97608>>>                    Procedure Refresh
97611>>>                        String sValue
97611>>>                        Get psConnectionID of ghoSQLConnectionHandler to sValue
97612>>>                        Set Value to sValue
97613>>>                    End_Procedure
97614>>>
97614>>>                End_Object
97615>>>
97615>>>                Object oDriverID_cf is a ComboForm
97617>>>                    Set Size to 12 91
97618>>>                    Set Location to 12 222
97619>>>                    Set Label_Col_Offset to 2
97620>>>                    Set Label_Justification_Mode to JMode_Right
97621>>>                    Set Label to "Driver ID"
97622>>>                    Set Entry_State to False
97623>>>                    Set Enabled_State to False
97624>>>
97624>>>                    Procedure Combo_Fill_List
97627>>>                        Send Combo_Add_Item MSSQLDRV_ID
97628>>>                        Send Combo_Add_Item DB2_DRV_ID
97629>>>                        Send Combo_Add_Item ODBC_DRV_ID
97630>>>                    End_Procedure
97631>>>
97631>>>                    Procedure OnChange
97634>>>                        String sValue sOrgValue
97634>>>                        Boolean bEnabled bChecked
97634>>>
97634>>>                        Get Value to sValue
97635>>>                        Get psDriverID of ghoSQLConnectionHandler to sOrgValue
97636>>>                        If (sValue <> "" and sValue <> sOrgValue and sValue <> "None") Begin
97638>>>                            Set psDriverID of ghoSQLConnectionHandler to sValue
97639>>>                        End
97639>>>>
97639>>>                        Move (sValue <> "None") to bEnabled
97640>>>                        Broadcast Set Enabled_State of (Parent(Self)) to bEnabled
97642>>>                        Set Enabled_State to False
97643>>>                        Set Enabled_State of oConnectionString_fm to False
97644>>>                        Set Enabled_State of oDatabase_fm to (sValue <> DB2_DRV_ID)
97645>>>
97645>>>                        Get Checked_State of oTrusted_cb  to bChecked
97646>>>                        Set Enabled_State of oUserID_fm   to (bChecked = False)
97647>>>                        Set Enabled_State of oPassword_fm to (bChecked = False)
97648>>>                    End_Procedure
97649>>>
97649>>>                    Procedure Refresh
97652>>>                        String sValue
97652>>>
97652>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
97653>>>                        Set Value to sValue
97654>>>                    End_Procedure
97655>>>
97655>>>                End_Object
97656>>>
97656>>>                Object oServer_fm is a Form
97658>>>                    Set Size to 12 100
97659>>>                    Set Location to 26 68
97660>>>                    Set Label to "Server"
97661>>>                    Set Label_Col_Offset to 2
97662>>>                    Set Label_Justification_Mode to JMode_Right
97663>>>                    Set Prompt_Button_Mode to PB_PromptOn
97664>>>                    Set Prompt_Object to (oServerSelection_sl(Self))
97665>>>
97665>>>                    Procedure Refresh
97668>>>                        String sValue
97668>>>                        Get psServer of ghoSQLConnectionHandler to sValue
97669>>>                        Set Value to sValue
97670>>>                    End_Procedure
97671>>>
97671>>>                    Procedure Prompt
97674>>>                        String[] sTheData
97675>>>                        String sDriverID
97675>>>                        Handle ho
97675>>>
97675>>>                        Send Cursor_Wait of Cursor_Control
97676>>>                        Get Prompt_Object to ho
97677>>>                        Get Value of oDriverID_cf to sDriverID
97678>>>                        Get SqlUtilEnumerateServers of ghoDbUpdateFunctionLibrary sDriverID 2 to sTheData
97679>>>                        Set psTheData of ho to sTheData
97680>>>                        Send Cursor_Ready of Cursor_Control
97681>>>
97681>>>                        Forward Send Prompt
97683>>>                    End_Procedure
97684>>>
97684>>>                End_Object
97685>>>
97685>>>                Object oDatabase_fm is a Form
97687>>>                    Set Size to 12 91
97688>>>                    Set Location to 26 222
97689>>>                    Set Label to "Database"
97690>>>                    Set Label_Col_Offset to 2
97691>>>                    Set Label_Justification_Mode to JMode_Right
97692>>>                    Set Prompt_Button_Mode to PB_PromptOn
97693>>>                    Set Prompt_Object to (oDatabaseSelection_sl(Self))
97694>>>                    Set peAnchors to anNone
97695>>>                    Set Entry_State to False
97696>>>
97696>>>                    Procedure Refresh
97699>>>                        String sDatabase
97699>>>
97699>>>                        Get psDatabase of ghoSQLConnectionHandler to sDatabase
97700>>>                        Set Value to sDatabase
97701>>>                    End_Procedure
97702>>>
97702>>>                    Procedure Prompt
97705>>>                        String[] sTheData
97706>>>                        Handle ho
97706>>>                        String sDriverID
97706>>>
97706>>>                        Get Value of oDriverID_cf to sDriverID
97707>>>                        Get SqlUtilEnumerateDatabases of ghoDbUpdateFunctionLibrary sDriverID to sTheData
97708>>>
97708>>>                        Get Prompt_Object to ho
97709>>>                        Set psTheData of ho to sTheData
97710>>>
97710>>>                        Forward Send Prompt
97712>>>                    End_Procedure
97713>>>
97713>>>                    Procedure OnChange
97716>>>                        String sValue sOrgValue
97716>>>                        Get Value to sValue
97717>>>                        Get psDatabase of ghoSQLConnectionHandler to sOrgValue
97718>>>                        If (Uppercase(Trim(sValue)) <> Uppercase(Trim(sOrgValue))) Begin
97720>>>                            Set psDatabase of ghoSQLConnectionHandler to sValue
97721>>>                            Get psConnectionString of ghoSQLConnectionHandler to sValue
97722>>>                            Set Value of oConnectionString_fm to sValue
97723>>>                        End
97723>>>>
97723>>>                    End_Procedure
97724>>>
97724>>>                End_Object
97725>>>
97725>>>                Object oTrusted_cb is a CheckBox
97727>>>                    Set Size to 10 50
97728>>>                    Set Location to 45 68
97729>>>                    Set Label to "Use Trusted Connection"
97730>>>
97730>>>                    Procedure Refresh
97733>>>                        Boolean bValue
97733>>>                        Get pbTrusted of ghoSQLConnectionHandler to bValue
97734>>>                        Set Checked_State to bValue
97735>>>                    End_Procedure
97736>>>
97736>>>                    Procedure OnChange
97739>>>                        Boolean bChecked
97739>>>
97739>>>                        Get Checked_State to bChecked
97740>>>                        Set Enabled_State of oUserID_fm   to (bChecked = False)
97741>>>                        Set Enabled_State of oPassword_fm to (bChecked = False)
97742>>>                    End_Procedure
97743>>>
97743>>>                End_Object
97744>>>
97744>>>                Object oUserID_fm is a Form
97746>>>                    Set Size to 12 100
97747>>>                    Set Location to 57 68
97748>>>                    Set Label to "UserID"
97749>>>                    Set Label_Col_Offset to 2
97750>>>                    Set Label_Justification_Mode to JMode_Right
97751>>>
97751>>>                    Procedure Refresh
97754>>>                        String sValue
97754>>>                        Get psUserID of ghoSQLConnectionHandler to sValue
97755>>>                        Set Value to sValue
97756>>>                    End_Procedure
97757>>>
97757>>>                End_Object
97758>>>
97758>>>                Object oPassword_fm is a Form
97760>>>                    Set Size to 12 91
97761>>>                    Set Location to 57 222
97762>>>                    Set Label to "Password"
97763>>>                    Set Label_Col_Offset to 2
97764>>>                    Set Label_Justification_Mode to JMode_Right
97765>>>                    // Set psToolTip to "Note: The password form does _not_ have it's password state set to True because the view is for testing purposes only. And we can see the password - if set - from the connection string as well."
97765>>>                    Set psToolTip to "Press the 'Toggle Password' button to reveal the password"
97766>>>                    Set Password_State to True
97767>>>
97767>>>                    Procedure Refresh
97770>>>                        String sValue
97770>>>                        Get psPassword of ghoSQLConnectionHandler to sValue
97771>>>                        Set Value to sValue
97772>>>                    End_Procedure
97773>>>
97773>>>                End_Object
97774>>>
97774>>>                Object oViewPassword_btn is a cRDCButtonDPI
97776>>>                    Set Size to 12 19
97777>>>                    Set Location to 57 317
97778>>>                    Set psToolTip to "Toggle password"
97779>>>                    Set psImage to "ViewPassword.ico"
97780>>>                    Set piImageMarginLeft to 0
97781>>>
97781>>>                    Procedure OnClick
97784>>>                        Boolean bState
97784>>>                        Get Password_State of oPassword_fm to bState
97785>>>                        Send Page_Object   of oPassword_fm False
97786>>>                        Set Password_State of oPassword_fm to (not(bState))
97787>>>                        Send Page_Object   of oPassword_fm True
97788>>>                    End_Procedure
97789>>>
97789>>>                End_Object
97790>>>
97790>>>                Object oTestLogin_btn is a cRDCButtonDPI
97792>>>                    Set Size to 12 56
97793>>>                    Set Location to 57 340
97794>>>                    Set Label to "Test Login"
97795>>>                    Set peAnchors to anNone
97796>>>                    Set psToolTip to "Changes the connection string with any changes made and tries to login to the server with the connection string."
97797>>>                    Set FontWeight to fw_Bold
97798>>>                    Set psImage to "ActionLogin.ico"
97799>>>                    Set piImageMarginLeft to 0
97800>>>
97800>>>                    Procedure OnClick
97803>>>                        tSQLConnection SQLConnection
97803>>>                        tSQLConnection SQLConnection
97803>>>                        String sServer sDatabase sDriverID sUserID sPassword sConnectionID sConnectionString
97803>>>                        Boolean bTrusted bLoginSuccessful
97803>>>                        Integer iDriverID
97803>>>                        Handle hoDriver
97803>>>
97803>>>                        Get Value of oDriverID_cf        to SQLConnection.sDriverID
97804>>>                        Get Value of oConnectionID_fm    to SQLConnection.sConnectionID
97805>>>                        Get Value of oServer_fm          to SQLConnection.sServer
97806>>>                        Get Value of oDatabase_fm        to SQLConnection.sDatabase
97807>>>                        Get Checked_State of oTrusted_cb to SQLConnection.bTrusted
97808>>>                        Get Value of oUserID_fm          to SQLConnection.sUserID
97809>>>                        Get Value of oPassword_fm        to SQLConnection.sPassword
97810>>>
97810>>>                        Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
97811>>>
97811>>>                        Get DriverIndex of ghoSQLConnectionHandler SQLConnection.sDriverID to iDriverID
97812>>>                        If (iDriverID = 0) Begin
97814>>>                            Send Info_Box ("The driver" * SQLConnection.sDriverID * "could not be loaded. Is the driver installed? And equally imporant; Is the corresponding database server or client software installed?")
97815>>>                            Procedure_Return
97816>>>                        End
97816>>>>
97816>>>
97816>>>                        Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to True
97819>>>                        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
97820>>>                        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
97821>>>                        Set psDriverID of hoDriver to SQLConnection.sDriverID
97822>>>                        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bLoginSuccessful
97823>>>                        Send Destroy   of hoDriver
97824>>>
97824>>>                        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
97825>>>                        If (LastErr <> CLIERR_LOGIN_UNSUCCESSFUL) Begin
97827>>>                            Move (Replace(("PWD=" + SQLConnection.sPassword), sConnectionString, "PWD=***")) to sConnectionString
97828>>>                            Set Value of oConnectionString_fm to sConnectionString
97829>>>                            Send Info_Box "Login Successful!"
97830>>>                        End
97830>>>>
97830>>>                        Else Begin
97831>>>                            Send Info_Box "Nope, that didn't work. Login failed."
97832>>>                        End
97832>>>>
97832>>>                        Broadcast Recursive Send Combo_Fill_List of (Client_Id(phoMainPanel(ghoApplication)))
97834>>>                        Move 0 to LastErr
97835>>>                    End_Procedure
97836>>>
97836>>>                End_Object
97837>>>
97837>>>                Object oConnectionString_fm is a Form
97839>>>                    Set Size to 12 328
97840>>>                    Set Location to 82 68
97841>>>                    Set Label to "Connection String"    
97842>>>                    Set Label_Col_Offset to 2
97843>>>                    Set Label_Justification_Mode to JMode_Right
97844>>>                    Set peAnchors to anTopLeftRight
97845>>>                    Set Enabled_State to False
97846>>>
97846>>>                    Procedure Refresh
97849>>>                        String sValue
97849>>>                        tSQLConnection SQLConnection
97849>>>                        tSQLConnection SQLConnection
97849>>>
97849>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97850>>>                        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
97851>>>                        Set Value to sValue
97852>>>                    End_Procedure
97853>>>
97853>>>                End_Object
97854>>>
97854>>>                Object oInfo_tb is a TextBox
97856>>>                    Set Auto_Size_State to False
97857>>>                    Set Size to 18 303
97858>>>                    Set Location to 106 8
97859>>>                    Set Label to "Note: The above settings was read from the SQLConnections.ini file when the object was created and are properties of the 'ghoSQLConnectionHandler' object."
97860>>>                    Set Justification_Mode to JMode_Left
97861>>>                    Set FontItalics to True
97862>>>                End_Object
97863>>>
97863>>>                Object oRunSQLConnectionsProgram_btn is a cRDCButtonDPI
97865>>>                    Set Size to 21 83
97866>>>                    Set Location to 106 315
97867>>>                    Set Label to "SQL Connections"
97868>>>                    Set peAnchors to anNone
97869>>>                    Set psImage to "SQLConnections.ico"
97870>>>
97870>>>                    Procedure OnClick 
97873>>>                        Runprogram Background "DUFSQLConnections.exe"
97874>>>                    End_Procedure
97875>>>
97875>>>                End_Object
97876>>>
97876>>>                Object oGetCollation_btn is a Button
97878>>>                    Set Size to 27 91
97879>>>                    Set Location to 154 38
97880>>>                    Set Label to 'Get Database Collation'
97881>>>                
97881>>>                    Procedure OnClick
97884>>>                        String sCollation sDatabase
97884>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase 
97885>>>                        Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary sDatabase False to sCollation 
97886>>>                        Set Value of oGetCollation_fm to sCollation
97887>>>                    End_Procedure
97888>>>                
97888>>>                End_Object
97889>>>
97889>>>                Object oGetCollation_fm is a Form
97891>>>                    Set Size to 12 148
97892>>>                    Set Location to 162 143
97893>>>                    Set Label to "Current SQL Collation Name"
97894>>>                    Set Label_Col_Offset to 0
97895>>>                    Set Label_Row_Offset to 1
97896>>>                    Set Label_Justification_Mode to JMode_Top
97897>>>                End_Object
97898>>>        
97898>>>                Object oSetCollation_btn is a Button
97900>>>                    Set Size to 27 91
97901>>>                    Set Location to 188 38
97902>>>                    Set Label to "Set Database Collation"
97903>>>                
97903>>>                    Procedure OnClick
97906>>>                        String sCollation sDatabase sErrorText
97906>>>                        Boolean bOK
97906>>>                        Integer iRetval  
97906>>>                        tSqlErrorArray aSqlErrorArray
97906>>>                        tSqlErrorArray aSqlErrorArray
97906>>>                        
97906>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase  
97907>>>                        Get Value of oSetCollation_fm to sCollation
97908>>>                        Get YesNo_Box ("This will permanently change SQL collation for the selected database:" * String(sDatabase) * "Are you sure you want to do this?") to iRetval
97909>>>                        If (iRetval <> MBR_Yes) Begin
97911>>>                            Procedure_Return
97912>>>                        End
97912>>>>
97912>>>                        Get SqlDatabaseCollationChange of ghoDbUpdateFunctionLibrary sDatabase sCollation to bOK
97913>>>                        If (bOK = True) Begin
97915>>>                            Send Info_Box ("Changing the collation for database:" * String(sDatabase) * "was successful.")
97916>>>                        End
97916>>>>
97916>>>                        Else Begin                   
97917>>>                            Get paSqlErrorArray of ghoDbUpdateFunctionLibrary to aSqlErrorArray
97918>>>                            Move ("Embedded SQL Statement:" * String(aSqlErrorArray.sSqlStatementArray[0])) to sErrorText
97919>>>                            Move (sErrorText + "\n")                  to sErrorText
97920>>>                            Move (sErrorText + "\n" + "SQL Error:" * String(aSqlErrorArray.sSqlErrorArray[0])) to sErrorText
97921>>>                            Send Info_Box ("Changing the collation for database:" * String(sDatabase) * "failed." + "\n" + sErrorText)
97922>>>                        End
97922>>>>
97922>>>
97922>>>                    End_Procedure
97923>>>                
97923>>>                End_Object
97924>>>
97924>>>                Object oSetCollation_fm is a Form
97926>>>                    Set Size to 12 148
97927>>>                    Set Location to 197 143
97928>>>                    Set Label to "New SQL Collation Name"
97929>>>                    Set Label_Col_Offset to 0
97930>>>                    Set Label_Row_Offset to 1
97931>>>                    Set Label_Justification_Mode to JMode_Top
97932>>>                End_Object
97933>>>
97933>>>                Procedure Page Integer iPageObject
97936>>>                    Broadcast Recursive Send Refresh of (phoMainPanel(ghoApplication))
97938>>>                    Forward Send Page iPageObject
97940>>>                End_Procedure
97941>>>
97941>>>            End_Object
97942>>>
97942>>>        End_Object
97943>>>        
97943>>>    End_Object
97944>>>
97944>>>End_Object
97945>        Use SQLFunctions.vw
Including file: SQLFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SQLFunctions.vw)
97945>>>Use Windows.pkg
97945>>>Use DFClient.pkg
97945>>>Use Dfspnfrm.pkg
97945>>>Use cDbScrollingContainer.pkg
97945>>>Use cRDCButtonDPI.pkg
97945>>>Use cDbUpdateFunctionLibrary.pkg
97945>>>Use SQLDatabaseBackup.dg
97945>>>
97945>>>Activate_View Activate_oSQLFunctions_vw for oSQLFunctions_vw
97955>>>>
97955>>>Object oSQLFunctions_vw is a dbView
97957>>>    Set Border_Style to Border_Thick
97958>>>    Set Size to 260 426
97959>>>    Set Location to -4 2
97960>>>    Set Label to "Functions"
97961>>>    Set pbAutoActivate to True
97962>>>    Set Icon to "Sql.ico"
97963>>>
97963>>>    Procedure OnSetFocus
97966>>>        String sValue
97966>>>        tSQLConnection SQLConnection
97966>>>        tSQLConnection SQLConnection
97966>>>
97966>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97967>>>        Set Value of oSQLDatabase_fm to SQLConnection.sDatabase
97968>>>        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
97969>>>        Set Value of oSQLConnectionString_fm to sValue
97970>>>    End_Procedure
97971>>>
97971>>>    Object oScrollingContainer1 is a cDbScrollingContainer
97973>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
97975>>>
97975>>>            Object oSQLFunctionTests_grp is a Group
97977>>>                Set Size to 243 402
97978>>>                Set Location to 7 12
97979>>>                Set Label to "Tests: Change SQL Database with Specialized SQL Functions"
97980>>>                Set peAnchors to anAll
97981>>>
97981>>>                Object oSQLConnectionString_fm is a Form
97983>>>                    Set Size to 12 375
97984>>>                    Set Location to 23 14
97985>>>                    Set Label to "Current Connection String Settings:"
97986>>>                    Set Label_Col_Offset to 0
97987>>>                    Set Label_Justification_Mode to JMode_Top
97988>>>                    Set peAnchors to anTopLeftRight
97989>>>                    Set Enabled_State to False
97990>>>                    Set Label_Row_Offset to 1
97991>>>                End_Object
97992>>>
97992>>>                Object oSQLDatabase_fm is a Form
97994>>>                    Set Size to 12 86
97995>>>                    Set Location to 50 14
97996>>>                    Set Label to "Database:"
97997>>>                    Set Label_Col_Offset to 0
97998>>>                    Set Label_Justification_Mode to JMode_Top
97999>>>                    Set Label_Row_Offset to 1
98000>>>                    Set FontWeight to fw_Bold
98001>>>                    Set Enabled_State to False
98002>>>                End_Object
98003>>>
98003>>>                Object oDriverID2_cf is a ComboForm
98005>>>                    Set Size to 12 91
98006>>>                    Set Location to 50 121
98007>>>                    Set Label_Col_Offset to 0
98008>>>                    Set Label_Justification_Mode to JMode_Top
98009>>>                    Set Label to "Driver ID:"
98010>>>                    Set Entry_State to False
98011>>>                    Set Enabled_State to False
98012>>>                    Set Label_Row_Offset to 1
98013>>>
98013>>>                    Procedure Combo_Fill_List
98016>>>                        Send Combo_Add_Item MSSQLDRV_ID
98017>>>                        Send Combo_Add_Item DB2_DRV_ID
98018>>>                        Send Combo_Add_Item ODBC_DRV_ID
98019>>>                    End_Procedure
98020>>>
98020>>>                    Procedure Refresh
98023>>>                        String sValue
98023>>>
98023>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
98024>>>                        Set Value to sValue
98025>>>                    End_Procedure
98026>>>
98026>>>                End_Object
98027>>>
98027>>>                Object oBackupSQLDatabase_btn is a cRDCButtonDPI
98029>>>                    Set Size to 12 109
98030>>>                    Set Location to 50 220
98031>>>                    Set Label to "Backup MS-SQL Database"
98032>>>                    Set psImage to "DbBackup.ico"
98033>>>
98033>>>                    Procedure OnClick
98036>>>                        Boolean bOK
98036>>>
98036>>>                        // SQLDatabaseBackup dialog:
98036>>>                        Get MakeSQLDatabaseBackup to bOK
98037>>>
98037>>>                        If (bOK = True) Begin
98039>>>                            Send Info_Box "The backup of the database was successful!"
98040>>>                        End
98040>>>>
98040>>>                        Else Begin
98041>>>                            Send Info_Box "The database was not backup up"
98042>>>                        End
98042>>>>
98042>>>                    End_Procedure
98043>>>
98043>>>                End_Object
98044>>>
98044>>>                Object oDatabaseInfo_tb is a TextBox
98046>>>                    Set Auto_Size_State to False
98047>>>                    Set Size to 25 96
98048>>>                    Set Location to 64 14
98049>>>                    Set Label to "(Change database on the SQL Connections tabpage)"
98050>>>                    Set Justification_Mode to JMode_Left
98051>>>                End_Object
98052>>>
98052>>>                Object oSQLInfo_tb is a TextBox
98054>>>                    Set Auto_Size_State to False
98055>>>                    Set Size to 37 270
98056>>>                    Set Location to 76 118
98057>>>                    Set Label to "Note: The DataFlex database API is NOT used here. Instead all is done with specialized embedded SQL (ESQL) funtions from the cDbUpdateFunctionLibrary. This is because an API 'Structure_End' command could drop and rebuild the whole table (!). That can take a long time..."
98058>>>                    Set Justification_Mode to JMode_Left
98059>>>                End_Object
98060>>>
98060>>>                Object oSQLTableName_cf is a ComboForm
98062>>>                    Set Size to 12 96
98063>>>                    Set Location to 106 14
98064>>>                    Set Label_Col_Offset to 0
98065>>>                    Set Label_Justification_Mode to JMode_Top
98066>>>                    Set Label to "Select Table:"
98067>>>                    Set Label_Row_Offset to 1
98068>>>                    Set Entry_State to False
98069>>>
98069>>>                    Procedure OnDropDown
98072>>>                        Send DoCombo_Fill_List
98073>>>                    End_Procedure
98074>>>
98074>>>                    Procedure OnCloseUp
98077>>>                        Send Delete_Data of oSQLColumnName_cf
98078>>>                    End_Procedure
98079>>>
98079>>>                    Procedure DoCombo_Fill_List
98082>>>                        String[] sTablesArray
98083>>>                        String sDriverID
98083>>>                        Integer iCount iSize
98083>>>
98083>>>                        Send Delete_Data
98084>>>                        Get Value of oDriverID2_cf to sDriverID
98085>>>                        Get _SqlUtilEnumerateTables of ghoDbUpdateFunctionLibrary sDriverID to sTablesArray
98086>>>                        Move (SizeOfArray(sTablesArray)) to iSize
98087>>>                        Decrement iSize
98088>>>                        For iCount from 0 to iSize
98094>>>>
98094>>>                            Send Combo_Add_Item sTablesArray[iCount]
98095>>>                        Loop
98096>>>>
98096>>>                    End_Procedure
98097>>>
98097>>>                    // DataFlex bug. It has been here as long as I can remember and _never_ seems to be fixed :-(
98097>>>                    // Augmented Value function.
98097>>>                    // We need to use Wincombo_x messages. Probably due to sync reasons.
98097>>>                    // When e.g. OnCloseUp is fired the data_value still holds the old value.
98097>>>                    Function Value Integer iItem Returns String
98100>>>                        String sValue
98100>>>                        Get WinCombo_Current_Item to iItem
98101>>>                        Get WinCombo_Value iItem  to sValue
98102>>>                        Function_Return sValue
98103>>>                    End_Function
98104>>>
98104>>>                End_Object
98105>>>
98105>>>                Object oSQLColumnName_cf is a ComboForm
98107>>>                    Set Size to 12 96
98108>>>                    Set Location to 134 14
98109>>>                    Set Label_Col_Offset to 0
98110>>>                    Set Label_Justification_Mode to JMode_Top
98111>>>                    Set Label to "Select Column:"
98112>>>                    Set Label_Row_Offset to 1
98113>>>                    Set Entry_State to False
98114>>>
98114>>>                    Procedure DoCombo_Fill_List
98117>>>                        String[] sColumnsArray
98118>>>                        String sTableName sDriverID
98118>>>                        Integer iCount iSize
98118>>>
98118>>>                        Send Delete_Data
98119>>>                        Get Value of oDriverID2_cf    to sDriverID
98120>>>                        Get Value of oSQLTableName_cf to sTableName
98121>>>                        Get _SqlUtilEnumerateColumns of ghoDbUpdateFunctionLibrary sDriverID sTableName to sColumnsArray
98122>>>                        Move (SizeOfArray(sColumnsArray)) to iSize
98123>>>                        Decrement iSize
98124>>>                        For iCount from 0 to iSize
98130>>>>
98130>>>                            Send Combo_Add_Item sColumnsArray[iCount]
98131>>>                        Loop
98132>>>>
98132>>>                        If (iSize > 1) Begin
98134>>>                            Set Current_Item to 1
98135>>>                        End
98135>>>>
98135>>>                    End_Procedure
98136>>>
98136>>>                    Procedure OnDropDown
98139>>>                        Send DoCombo_Fill_List
98140>>>                    End_Procedure
98141>>>                End_Object
98142>>>
98142>>>                Object oSQLRenameColumnTo_fm is a Form
98144>>>                    Set Size to 12 96
98145>>>                    Set Location to 134 116
98146>>>                    Set Label_Col_Offset to 0
98147>>>                    Set Label_Justification_Mode to JMode_Top
98148>>>                    Set Label to "Rename Column To:"
98149>>>                    Set Label_Row_Offset to 1
98150>>>                    Set Value to "NewColumnName"
98151>>>                End_Object
98152>>>
98152>>>                Object oSQLRenameColumn_btn is a cRDCButtonDPI
98154>>>                    Set Size to 12 69
98155>>>                    Set Location to 134 220
98156>>>                    Set Label to "Rename Column"
98157>>>                    Set psToolTip to "Test of SQLColumnRename function"
98158>>>                    Set MultiLineState to True
98159>>>
98159>>>                    Procedure OnClick
98162>>>                        Boolean bOk
98162>>>                        Handle hTable
98162>>>                        String sTableName sColumnName sNewColumnName sDriverID
98162>>>
98162>>>                        Get Value of oSQLTableName_cf to sTableName
98163>>>                        If (sTableName = "") Begin
98165>>>                            Send Info_Box "You need to select a table first..."
98166>>>                            Procedure_Return
98167>>>                        End
98167>>>>
98167>>>                        Get Value of oSQLColumnName_cf to sColumnName
98168>>>                        If (Uppercase(sColumnName) = "RECNUM" or sColumnName = "") Begin
98170>>>                            Send Info_Box "You need to select a column (and 'RECNUM' cannot be used)"
98171>>>                            Procedure_Return
98172>>>                        End
98172>>>>
98172>>>                        Get Value of oSQLRenameColumnTo_fm to sNewColumnName
98173>>>                        If (Trim(sNewColumnName) = "") Begin
98175>>>                            Send Info_Box "You need to enter a column name to rename to..."
98176>>>                            Procedure_Return
98177>>>                        End
98177>>>>
98177>>>
98177>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98178>>>                        If (hTable = 0) Begin
98180>>>                            Send Info_Box "Sorry, no free fileslot in filelist.cfg could be found. Cannot continue changing table."
98181>>>                            Procedure_Return
98182>>>                        End
98182>>>>
98182>>>
98182>>>                        Get Value of oDriverID2_cf to sDriverID
98183>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98184>>>                        Get SqlColumnRenameByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName sNewColumnName to bOk
98185>>>                        If (bOk = True) Begin
98187>>>                            // Better delete the combo values after a successful rename as it looks odd to show the old column name...
98187>>>                            Send Delete_Data of oSQLColumnName_cf
98188>>>                            Send Info_Box ("Column" * sColumnName + ", was successfully renamed to" * sNewColumnName * "for table:" * sTableName)
98189>>>                        End
98189>>>>
98189>>>                        Else Begin
98190>>>                            Send Info_Box "Nope, that didn't work..."
98191>>>                        End
98191>>>>
98191>>>
98191>>>                    End_Procedure
98192>>>
98192>>>                End_Object
98193>>>
98193>>>                Object oSQLRemoveColumn_btn is a cRDCButtonDPI
98195>>>                    Set Size to 12 91
98196>>>                    Set Location to 134 297
98197>>>                    Set Label to "Drop Column"
98198>>>                    Set psToolTip to "Test of SQLColumnRemove function"
98199>>>                    Set psImage to "DeleteColumn.ico"
98200>>>
98200>>>                    Procedure OnClick
98203>>>                        Boolean bOk
98203>>>                        String sTableName sColumnName sDriverID
98203>>>                        Integer iRetval
98203>>>
98203>>>                        Get Value of oDriverID2_cf              to sDriverID
98204>>>                        Get Value of oSQLTableName_cf           to sTableName
98205>>>                        Get Value of oSQLColumnName_cf          to sColumnName
98206>>>
98206>>>                        If (sTableName = "" or sColumnName = "") Begin
98208>>>                            Send Info_Box "You first need to select a table and a column."
98209>>>                            Procedure_Return
98210>>>                        End
98210>>>>
98210>>>
98210>>>                        Get YesNo_Box ("This will remove (drop) the column named:" * sColumnName * "from table:" * sTableName + ". Are you sure?") to iRetval
98211>>>                        If (iRetval <> MBR_Yes) Begin
98213>>>                            Procedure_Return
98214>>>                        End
98214>>>>
98214>>>
98214>>>                        Get SqlColumnRemoveByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName to bOk
98215>>>
98215>>>                        If (bOk = True) Begin
98217>>>                            // Better delete the combo values after a successful operation as it looks odd to show the old column name...
98217>>>                            Send Delete_Data of oSQLColumnName_cf
98218>>>                            Send Info_Box ("Column" * sColumnName + ", was successfully removed")
98219>>>                        End
98219>>>>
98219>>>                        Else Begin
98220>>>                            Send Info_Box ("The column could NOT be removed. Either the column" * sColumnName * "doesn't exists or the current Database is incorrect?")
98221>>>                            Procedure_Return
98222>>>                        End
98222>>>>
98222>>>
98222>>>                    End_Procedure
98223>>>
98223>>>                End_Object
98224>>>
98224>>>                Object oSQLAddColumnName_fm is a Form
98226>>>                    Set Size to 12 96
98227>>>                    Set Location to 177 14
98228>>>                    Set Label_Col_Offset to 0
98229>>>                    Set Label_Justification_Mode to JMode_Top
98230>>>                    Set Label to "Column Name:"
98231>>>                    Set Label_Row_Offset to 1
98232>>>                    Set Value to "NewColumn"
98233>>>                End_Object
98234>>>
98234>>>                Object oSQLColumnType_cf is a ComboForm
98236>>>                    Set Size to 12 96
98237>>>                    Set Location to 177 116
98238>>>                    Set Label_Col_Offset to 0
98239>>>                    Set Label_Justification_Mode to JMode_Top
98240>>>                    Set Label_Row_Offset to 1
98241>>>                    Set Label to "Type:"
98242>>>                    Set Entry_State to False
98243>>>
98243>>>                    Procedure Combo_Fill_List
98246>>>                        tColumnType[] ColumnTypeArray
98246>>>                        tColumnType[] ColumnTypeArray
98247>>>                        Integer iSize iCount iDbType
98247>>>                        String sDriverID
98247>>>
98247>>>                        Send Delete_Data
98248>>>                        Get Value of oDriverID2_cf to sDriverID
98249>>>                        Get piDbType of ghoDbUpdateFunctionLibrary to iDbType
98250>>>                        Get _UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary sDriverID iDbType to ColumnTypeArray
98251>>>                        Move (SizeOfArray(ColumnTypeArray)) to iSize
98252>>>                        Decrement iSize
98253>>>                        For iCount from 0 to iSize
98259>>>>
98259>>>                            Send Combo_Add_Item ColumnTypeArray[iCount].sSQLType
98260>>>                        Loop
98261>>>>
98261>>>                        If (iSize > 0) Begin
98263>>>                            Set Value to ColumnTypeArray[0].sSQLType
98264>>>                        End
98264>>>>
98264>>>                    End_Procedure
98265>>>
98265>>>                    Procedure OnChange
98268>>>                        Integer iType iSize iDec
98268>>>                        tSQLConnection SQLConnection
98268>>>                        tSQLConnection SQLConnection
98268>>>                        Boolean bFixed
98268>>>
98268>>>                        Get SelectedType to iType
98269>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98270>>>                        Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to iSize
98271>>>                        Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to iDec
98272>>>                        Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to bFixed
98273>>>
98273>>>                        Set Enabled_State of oSQLLength_sf   to (bFixed = False)
98274>>>                        Set Enabled_State of oSQLDecimals_sf to (bFixed = False)
98275>>>                        Set Value         of oSQLLength_sf   to iSize
98276>>>                        If (iDec = 0) Begin
98278>>>                            Set Value     of oSQLDecimals_sf to ""
98279>>>                        End
98279>>>>
98279>>>                        Else Begin
98280>>>                            Set Value     of oSQLDecimals_sf to iDec
98281>>>                        End
98281>>>>
98281>>>                        If (bFixed = False) Begin
98283>>>                            Set Enabled_State of oSQLDecimals_sf to (iDec <> 0)
98284>>>                        End
98284>>>>
98284>>>                    End_Procedure
98285>>>
98285>>>                    Function SelectedType Returns Integer
98288>>>                        String sValue sDriverID
98288>>>                        Integer iType iDbType
98288>>>
98288>>>                        Get Value to sValue
98289>>>                        Get psDriverID of ghoSQLConnectionHandler to sDriverID
98290>>>                        Get piDbType   of ghoSQLConnectionHandler to iDbType
98291>>>                        Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary sDriverID iDbType sValue to iType
98292>>>
98292>>>                        Function_Return iType
98293>>>                    End_Function
98294>>>
98294>>>                End_Object
98295>>>
98295>>>                Object oSQLAddColumn_btn is a cRDCButtonDPI
98297>>>                    Set Size to 12 69
98298>>>                    Set Location to 177 220
98299>>>                    Set Label to "Add Column"
98300>>>                    Set psToolTip to "Test of SQLColumnAdd function"
98301>>>                    Set psImage to "AddColumn.ico"
98302>>>
98302>>>                    Procedure OnClick
98305>>>                        Boolean bOk bInitialize
98305>>>                        Handle hTable
98305>>>                        String sTableName sColumnName sType sColumnValue sDriverID
98305>>>                        Integer iType iLength iDecimals
98305>>>
98305>>>                        Get Value of oDriverID2_cf              to sDriverID
98306>>>                        Get Value of oSQLTableName_cf           to sTableName
98307>>>                        Get Value of oSQLAddColumnName_fm       to sColumnName
98308>>>                        Get SelectedType  of oSQLColumnType_cf  to iType
98309>>>                        Get Value         of oSQLColumnType_cf  to sType
98310>>>                        Get Checked_State of oSQLInitializeColumnValue_cb to bInitialize
98311>>>                        Get Value         of oSQLColumnValue_fm to sColumnValue
98312>>>                        Get Value         of oSQLLength_sf      to iLength
98313>>>                        Get Value         of oSQLDecimals_sf    to iDecimals
98314>>>
98314>>>                        If (sTableName <> "") Begin
98316>>>                            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98317>>>                            If (hTable = 0) Begin
98319>>>                                Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98320>>>                            End
98320>>>>
98320>>>                        End
98320>>>>
98320>>>                        If (hTable = 0) Begin
98322>>>                            Send Info_Box "You first need to select a table before you can add a column to it."
98323>>>                            Procedure_Return
98324>>>                        End
98324>>>>
98324>>>                        If (sColumnName = "") Begin
98326>>>                            Send Info_Box "You need to enter a column name"
98327>>>                            Procedure_Return
98328>>>                        End
98328>>>>
98328>>>
98328>>>                        Get SqlColumnAddByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName iType iLength iDecimals bInitialize sColumnValue to bOk
98329>>>
98329>>>                        If (bOk = True) Begin
98331>>>                            Send Info_Box ("New column" * sColumnName * sType * String(iLength) + ", was successfully added to" * sTableName)
98332>>>                        End
98332>>>>
98332>>>                        Else Begin
98333>>>                            Send Info_Box ("The column could NOT be added. Either column" * sColumnName * "already exists or the current Database is incorrect?")
98334>>>                            Procedure_Return
98335>>>                        End
98335>>>>
98335>>>
98335>>>                    End_Procedure
98336>>>
98336>>>                End_Object
98337>>>
98337>>>//                Object oTest_btn is a cRDCButtonDPI
98337>>>//                    Set Size to 13 92
98337>>>//                    Set Location to 177 298
98337>>>//                    Set Label to "Test SQL script button"
98337>>>//
98337>>>//                    Procedure OnClick
98337>>>//                        Boolean bOK
98337>>>//                        String sTableName sColumnName
98337>>>//
98337>>>//                        Get Value of oSQLTableName_cf      to sTableName
98337>>>//                        Get Value of oSQLAddColumnName_fm  to sColumnName
98337>>>////                        Get SqlUtilDefaultConstraintsMSSQL of ghoDbUpdateFunctionLibrary sTableName sColumnName to bOK
98337>>>//
98337>>>//                    End_Procedure
98337>>>//
98337>>>//                End_Object
98337>>>
98337>>>                Object oSQLLength_sf is a SpinForm
98339>>>                    Set Label to "Length:"
98340>>>                    Set Size to 12 40
98341>>>                    Set Location to 202 16
98342>>>                    Set Label_Col_Offset to 0
98343>>>                    Set Label_Justification_Mode to JMode_Top
98344>>>                    Set Label_Row_Offset to 1
98345>>>                    Set Value to "10"
98346>>>                    Set Maximum_Position to 500
98347>>>                    Set Minimum_Position to 1
98348>>>                End_Object
98349>>>
98349>>>                Object oSQLDecimals_sf is a SpinForm
98351>>>                    Set Label to "Decimals:"
98352>>>                    Set Size to 12 33
98353>>>                    Set Location to 202 60
98354>>>                    Set Label_Col_Offset to 0
98355>>>                    Set Label_Justification_Mode to JMode_Top
98356>>>                    Set Label_Row_Offset to 1
98357>>>                    Set Value to "0"
98358>>>                    Set Maximum_Position to 16
98359>>>                    Set Minimum_Position to 1
98360>>>                End_Object
98361>>>
98361>>>                Object oSQLInitializeColumnValue_cb is a CheckBox
98363>>>                    Set Size to 12 85
98364>>>                    Set Location to 202 116
98365>>>                    Set Label to "Initialize Column Value"
98366>>>
98366>>>                    Procedure OnChange
98369>>>                        Boolean bChecked
98369>>>
98369>>>                        Get Checked_State to bChecked
98370>>>                        Set Enabled_State of oSQLColumnValue_fm to bChecked
98371>>>                    End_Procedure
98372>>>
98372>>>                End_Object
98373>>>
98373>>>                Object oSQLColumnValue_fm is a Form
98375>>>                    Set Size to 12 96
98376>>>                    Set Location to 218 116
98377>>>                    Set Label_Col_Offset to 2
98378>>>                    Set Label_Justification_Mode to JMode_Right
98379>>>                    Set Label to "Column Value"
98380>>>                    Set psToolTip to "When a new column is added the new column can be initialized with a value for all existing records."
98381>>>                    Set Enabled_State to False
98382>>>                End_Object
98383>>>
98383>>>                Object oEnumRelations_btn is a cRDCButtonDPI
98385>>>                    Set Size to 12 91
98386>>>                    Set Location to 116 297
98387>>>                    Set Label to "Test Enum SQL Relations"
98388>>>
98388>>>                    Procedure OnClick
98391>>>                        tSQLRelation[] SQLRelationArray
98391>>>                        tSQLRelation[] SQLRelationArray
98392>>>                        String sTableName sDriverID
98392>>>                        Integer iSize iCount
98392>>>
98392>>>                        Get Value of oDriverID2_cf to sDriverID
98393>>>                        Get Value of oSQLTableName_cf to sTableName
98394>>>                        Get _SqlUtilEnumerateRelations of ghoDbUpdateFunctionLibrary sTableName sDriverID to SQLRelationArray
98395>>>                        Move (SizeOfArray(SQLRelationArray)) to iSize
98396>>>                        Decrement iSize
98397>>>                        For iCount from 0 to iSize
98403>>>>
98403>>>                            Showln "Tablename.FieldName = " SQLRelationArray[iCount].sFileName "." SQLRelationArray[iCount].sFieldName " Number: " SQLRelationArray[iCount].iFileNumber "." SQLRelationArray[iCount].iFieldNumber
98412>>>                        Loop
98413>>>>
98413>>>                        If (iSize < 1) Begin
98415>>>                            Send Info_Box ("No SQL Foreign keys found for table:" * sTableName)
98416>>>                        End
98416>>>>
98416>>>
98416>>>                    End_Procedure
98417>>>
98417>>>                End_Object
98418>>>
98418>>>                Object oEnumerateLoggedInUsers is a cRDCButtonDPI
98420>>>                    Set Size to 12 101
98421>>>                    Set Location to 177 297
98422>>>                    Set Label to "Enumerate Logged In Users"
98423>>>
98423>>>                    Procedure OnClick
98426>>>                        tSQLLoggedInUser[] SQLLoggedInUser
98426>>>                        tSQLLoggedInUser[] SQLLoggedInUser
98427>>>                        String sDriverID sDatabase
98427>>>                        Integer iSize iCount
98427>>>
98427>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98428>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase
98429>>>                        Get SqlUtilEnumerateLoggedInUsers of ghoDbUpdateFunctionLibrary sDriverID sDatabase to SQLLoggedInUser
98430>>>                        Move (SizeOfArray(SQLLoggedInUser)) to iSize
98431>>>                        Decrement iSize
98432>>>
98432>>>                        Showln "SQL User Name" " and Program:"
98435>>>                        For iCount from 0 to iSize
98441>>>>
98441>>>                            Showln SQLLoggedInUser[iCount].sUser " " SQLLoggedInUser[iCount].sProgram
98445>>>                        Loop
98446>>>>
98446>>>                    End_Procedure
98447>>>
98447>>>                End_Object
98448>>>
98448>>>                Object oEnumerateTablesAndViews is a cRDCButtonDPI
98450>>>                    Set Size to 12 101
98451>>>                    Set Location to 193 297
98452>>>                    Set Label to "Is Table or View?"
98453>>>
98453>>>                    Procedure OnClick
98456>>>                        String sDriverID sTableName
98456>>>                        Handle hTable
98456>>>                        Boolean bViewTableType
98456>>>
98456>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98457>>>                        Get Value of oSQLTableName_cf to sTableName
98458>>>                        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98459>>>                        If (hTable = 0) Begin
98461>>>                            Procedure_Return
98462>>>                        End
98462>>>>
98462>>>                        Get SQLUtilTableIsViewType of ghoDbUpdateFunctionLibrary sDriverID hTable to bViewTableType
98463>>>                        Send Info_Box ("The table" * sTableName * "is a" * If(bViewTableType = True, "View Table Type", "Standard Table (not view)"))
98464>>>                    End_Procedure
98465>>>
98465>>>                End_Object
98466>>>
98466>>>            End_Object
98467>>>
98467>>>        End_Object
98468>>>
98468>>>    End_Object
98469>>>
98469>>>End_Object
98470>        Use APIFunctions.vw
Including file: APIFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\APIFunctions.vw)
98470>>>Use Windows.pkg
98470>>>Use DFClient.pkg
98470>>>Use Dfspnfrm.pkg
98470>>>Use Dfline.pkg
98470>>>Use cDbScrollingContainer.pkg
98470>>>Use cRDCButtonDPI.pkg
98470>>>Use cDbUpdateFunctionLibrary.pkg
98470>>>
98470>>>Define CI_Table1_FileNo for 401
98470>>>Define CI_View1_FileNo  for 402
98470>>>
98470>>>Activate_View Activate_oAPIFunctions_vw for oAPIFunctions_vw
98480>>>>
98480>>>Object oAPIFunctions_vw is a dbView
98482>>>    Set Border_Style to Border_Thick
98483>>>    Set Size to 237 424
98484>>>    Set Location to 17 2
98485>>>    Set Label to "API Functions"
98486>>>    Set pbAutoActivate to True
98487>>>    Set Icon to "APIFunctions.ico"
98488>>>
98488>>>    Property String psTableName ""
98490>>>
98490>>>    Procedure OnSetFocus
98493>>>        String sValue
98493>>>        tSQLConnection SQLConnection
98493>>>        tSQLConnection SQLConnection
98493>>>
98493>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98494>>>        Set Value of oApiDatabase_fm to SQLConnection.sDatabase
98495>>>        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
98496>>>        Set Value of oApiConnectionString_fm to sValue
98497>>>    End_Procedure
98498>>>
98498>>>    Object oScrollingContainer1 is a cDbScrollingContainer
98500>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
98502>>>
98502>>>            Object oApiFunctions_grp is a Group
98504>>>                Set Size to 222 402
98505>>>                Set Location to 6 12
98506>>>                Set Label to "Tests: Change MS-SQL Database with Database API Functions"
98507>>>                Set peAnchors to anAll
98508>>>
98508>>>                Object oApiConnectionString_fm is a Form
98510>>>                    Set Size to 12 368
98511>>>                    Set Location to 23 14
98512>>>                    Set Label to "Current Connection String Settings:"
98513>>>                    Set Label_Col_Offset to 0
98514>>>                    Set Label_Justification_Mode to JMode_Top
98515>>>                    Set peAnchors to anTopLeftRight
98516>>>                    Set Enabled_State to False
98517>>>                    Set Label_Row_Offset to 1
98518>>>                End_Object
98519>>>
98519>>>                Object oApiDatabase_fm is a Form
98521>>>                    Set Size to 12 86
98522>>>                    Set Location to 50 14
98523>>>                    Set Label to "Database:"
98524>>>                    Set Label_Col_Offset to 0
98525>>>                    Set Label_Justification_Mode to JMode_Top
98526>>>                    Set Label_Row_Offset to 1
98527>>>                    Set Enabled_State to False
98528>>>                    Set FontWeight to fw_Bold
98529>>>//                    Set Label_FontWeight to fw_Bold
98529>>>
98529>>>                    Procedure Page Integer iPageObject
98532>>>                        String sValue
98532>>>                        Get psDatabase of ghoSQLConnectionHandler to sValue
98533>>>                        Set Value to sValue
98534>>>
98534>>>                        Forward Send Page iPageObject
98536>>>                    End_Procedure
98537>>>
98537>>>                End_Object
98538>>>
98538>>>                Object oDriverID3_cf is a ComboForm
98540>>>                    Set Size to 12 91
98541>>>                    Set Location to 51 121
98542>>>                    Set Label_Col_Offset to 0
98543>>>                    Set Label_Justification_Mode to JMode_Top
98544>>>                    Set Label to "Driver ID:"
98545>>>                    Set Entry_State to False
98546>>>                    Set Enabled_State to False
98547>>>                    Set Label_Row_Offset to 1
98548>>>                    Set Enabled_State to False
98549>>>
98549>>>                    Procedure Combo_Fill_List
98552>>>                        Send Combo_Add_Item MSSQLDRV_ID
98553>>>                        Send Combo_Add_Item DB2_DRV_ID
98554>>>                        Send Combo_Add_Item ODBC_DRV_ID
98555>>>                    End_Procedure
98556>>>
98556>>>                    Procedure Refresh
98559>>>                        String sValue
98559>>>
98559>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
98560>>>                        Set Value to sValue
98561>>>                    End_Procedure
98562>>>
98562>>>                End_Object
98563>>>
98563>>>                Object oDatabaseInfo_tb is a TextBox
98565>>>                    Set Auto_Size_State to False
98566>>>                    Set Size to 25 96
98567>>>                    Set Location to 64 14
98568>>>                    Set Label to "(Change database on the SQL Connections tabpage)"
98569>>>                    Set Justification_Mode to JMode_Left
98570>>>                End_Object
98571>>>
98571>>>                Object oApiTableName_fm is a Form
98573>>>                    Set Size to 12 77
98574>>>                    Set Location to 114 14
98575>>>                    Set Label_Col_Offset to 0
98576>>>                    Set Label_Justification_Mode to JMode_Top
98577>>>                    Set Label to "Table Name:"
98578>>>                    Set Label_Row_Offset to 1
98579>>>                    Set Value to "NewTable"
98580>>>                    Procedure OnChange
98583>>>                        String sValue
98583>>>                        Get Value to sValue
98584>>>                        Set psTableName to sValue
98585>>>                    End_Procedure
98586>>>                    Send OnChange
98587>>>                End_Object
98588>>>
98588>>>                Object oApiAddNewTable_btn is a cRDCButtonDPI
98590>>>                    Set Size to 12 69
98591>>>                    Set Location to 114 271
98592>>>                    Set Label to "Add Table"
98593>>>                    Set psImage to "ActionAddTable.ico"
98594>>>
98594>>>                    Procedure OnClick
98597>>>                        Boolean bOk
98597>>>                        Handle hTable
98597>>>                        String sTableName sDriverID
98597>>>
98597>>>                        Get Value of oDriverID3_cf to sDriverID
98598>>>                        Get Value of oApiTableName_fm to sTableName
98599>>>                        Move (Trim(sTableName)) to sTableName
98600>>>                        If (sTableName = "") Begin
98602>>>                            Send Info_Box "You first need to enter a table name."
98603>>>                            Procedure_Return
98604>>>                        End
98604>>>>
98604>>>
98604>>>                        Send Cursor_Wait of Cursor_Control
98605>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98606>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98607>>>                        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True to bOk
98608>>>                        If (bOk = True) Begin
98610>>>                            Send Info_Box ("Test table" * sTableName * "was successfully created and put in filelist slot:" * String(hTable))
98611>>>                        End
98611>>>>
98611>>>                        Else Begin
98612>>>                            Send Cursor_Ready of Cursor_Control
98613>>>                            Send Info_Box ("Nope, the test table" * sTableName * "could not be created, or does it already exist?") "Error"
98614>>>                            Procedure_Return
98615>>>                        End
98615>>>>
98615>>>
98615>>>                    End_Procedure
98616>>>
98616>>>                End_Object
98617>>>
98617>>>                Object oApiAddColumn_fm is a Form
98619>>>                    Set Size to 12 77
98620>>>                    Set Location to 141 14
98621>>>                    Set Label_Col_Offset to 0
98622>>>                    Set Label_Justification_Mode to JMode_Top
98623>>>                    Set Label to "Column Name:"
98624>>>                    Set Label_Row_Offset to 1
98625>>>                    Set Value to "NewColumn"
98626>>>                End_Object
98627>>>
98627>>>                Object oApiColumnType_cf is a ComboForm
98629>>>                    Set Size to 12 85
98630>>>                    Set Location to 141 96
98631>>>                    Set Label_Col_Offset to 0
98632>>>                    Set Label_Justification_Mode to JMode_Top
98633>>>                    Set Label_Row_Offset to 1
98634>>>                    Set Label to "Type:"
98635>>>                    Set Entry_State to False
98636>>>
98636>>>                    Procedure Combo_Fill_List
98639>>>                        tColumnType[] ColumnTypeArray
98639>>>                        tColumnType[] ColumnTypeArray
98640>>>                        Integer iSize iCount
98640>>>
98640>>>                        Send Delete_Data
98641>>>                        Get _UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex to ColumnTypeArray
98642>>>                        Move (SizeOfArray(ColumnTypeArray)) to iSize
98643>>>                        Decrement iSize
98644>>>                        For iCount from 0 to iSize
98650>>>>
98650>>>                            Send Combo_Add_Item ColumnTypeArray[iCount].sSQLType
98651>>>                        Loop
98652>>>>
98652>>>                        Set Value to ColumnTypeArray[0].sSQLType
98653>>>                    End_Procedure
98654>>>
98654>>>                    Procedure OnChange
98657>>>                        Integer iType iSize iDec
98657>>>                        tSQLConnection SQLConnection
98657>>>                        tSQLConnection SQLConnection
98657>>>                        Boolean bFixed
98657>>>
98657>>>                        Get SelectedType to iType
98658>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98659>>>                        Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to iSize
98660>>>                        Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to iDec
98661>>>                        Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to bFixed
98662>>>
98662>>>                        Set Enabled_State of oApiLength_sf   to (bFixed = False)
98663>>>                        Set Enabled_State of oApiDecimals_sf to (bFixed = False)
98664>>>                        Set Value         of oApiLength_sf   to iSize
98665>>>                        If (iDec = 0) Begin
98667>>>                            Set Value     of oApiDecimals_sf to ""
98668>>>                        End
98668>>>>
98668>>>                        Else Begin
98669>>>                            Set Value     of oApiDecimals_sf to iDec
98670>>>                        End
98670>>>>
98670>>>                        If (bFixed = False) Begin
98672>>>                            Set Enabled_State of oApiDecimals_sf to (iDec <> 0)
98673>>>                        End
98673>>>>
98673>>>                    End_Procedure
98674>>>
98674>>>                    Function SelectedType Returns Integer
98677>>>                        String sValue
98677>>>                        Integer iType
98677>>>
98677>>>                        Get Value to sValue
98678>>>                        Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex sValue to iType
98679>>>
98679>>>                        Function_Return iType
98680>>>                    End_Function
98681>>>
98681>>>                End_Object
98682>>>
98682>>>                Object oApiLength_sf is a SpinForm
98684>>>                    Set Label to "Length:"
98685>>>                    Set Size to 12 35
98686>>>                    Set Location to 141 186
98687>>>                    Set Label_Col_Offset to 0
98688>>>                    Set Label_Justification_Mode to JMode_Top
98689>>>                    Set Label_Row_Offset to 1
98690>>>                    Set Value to "10"
98691>>>                    Set Maximum_Position to 500
98692>>>                    Set Minimum_Position to 1
98693>>>                End_Object
98694>>>
98694>>>                Object oApiDecimals_sf is a SpinForm
98696>>>                    Set Label to "Decimals:"
98697>>>                    Set Size to 12 33
98698>>>                    Set Location to 141 225
98699>>>                    Set Label_Col_Offset to 0
98700>>>                    Set Label_Justification_Mode to JMode_Top
98701>>>                    Set Label_Row_Offset to 1
98702>>>                    Set Value to "0"
98703>>>                    Set Maximum_Position to 16
98704>>>                    Set Minimum_Position to 1
98705>>>                End_Object
98706>>>
98706>>>                Object oApiAddColumn_btn is a cRDCButtonDPI
98708>>>                    Set Size to 12 69
98709>>>                    Set Location to 141 271
98710>>>                    Set Label to "Add Column"
98711>>>                    Set psToolTip to "ApiColumnAdd function"
98712>>>                    Set psImage to "ActionAddColumn.ico"
98713>>>
98713>>>                    Procedure OnClick
98716>>>                        Boolean bOk
98716>>>                        Handle hTable
98716>>>                        String sTableName sColumnName sType sDriverID
98716>>>                        Integer iType iLength iDecimals
98716>>>
98716>>>                        Get Value of oDriverID3_cf            to sDriverID
98717>>>                        Get Value of oApiTableName_fm         to sTableName
98718>>>                        Get Value of oApiAddColumn_fm         to sColumnName
98719>>>                        Get SelectedType of oApiColumnType_cf to iType
98720>>>                        Get Value        of oApiLength_sf     to iLength
98721>>>                        Get Value        of oApiDecimals_sf   to iDecimals
98722>>>
98722>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98723>>>                        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98724>>>                        If (hTable = 0) Begin
98726>>>                            Send Info_Box "You first need to create the new table by pressing the 'Create New Table...' button, before you can add a column to it."
98727>>>                            Procedure_Return
98728>>>                        End
98728>>>>
98728>>>                        If (sColumnName = "") Begin
98730>>>                            Send Info_Box "You need to enter a column name"
98731>>>                            Procedure_Return
98732>>>                        End
98732>>>>
98732>>>
98732>>>                        Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable sColumnName iType iLength iDecimals to bOk
98733>>>                        If (bOk = True) Begin
98735>>>                            Send Info_Box ("Column" * sColumnName * sType * String(iLength) + ", was successfully added to" * sTableName * "(at filelist slot:" * String(hTable) + ")")
98736>>>                        End
98736>>>>
98736>>>                        Else Begin
98737>>>                            Send Info_Box ("The column could NOT be added. Either column" * sColumnName * "already exists or the current Database is incorrect?")
98738>>>                            Procedure_Return
98739>>>                        End
98739>>>>
98739>>>
98739>>>                    End_Procedure
98740>>>
98740>>>                End_Object
98741>>>
98741>>>                Object oApiAddTableAndColumns_btn is a cRDCButtonDPI
98743>>>                    Set Size to 26 77
98744>>>                    Set Location to 184 14
98745>>>                    Set Label to "Create 'New' Table with Three Columns"
98746>>>                    Set MultiLineState to True
98747>>>                    Set psImage to "ActionAddTable.ico"
98748>>>
98748>>>                    Procedure OnClick
98751>>>                        Boolean bOk
98751>>>                        Handle hTable
98751>>>                        String sTableName sDriverID
98751>>>
98751>>>                        Get Value of oDriverID3_cf to sDriverID
98752>>>                        Get Value of oApiTableName_fm to sTableName
98753>>>                        Move (Trim(sTableName)) to sTableName
98754>>>                        If (sTableName = "") Begin
98756>>>                            Send Info_Box "You first need to enter a table name."
98757>>>                            Procedure_Return
98758>>>                        End
98758>>>>
98758>>>
98758>>>                        Send Cursor_Wait of Cursor_Control
98759>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
98760>>>
98760>>>                        Set psDriverID       of ghoDbUpdateFunctionLibrary to sDriverID
98761>>>                        Get ApiTableCreate   of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True to bOk
98762>>>                        If (bOk = True) Begin
98764>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col1Ascii"   DF_ASCII 10 0 to bOk
98765>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col2Date"    DF_DATE   6 0 to bOk
98766>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col3Numeric" DF_BCD    6 2 to bOk
98767>>>                        End
98767>>>>
98767>>>                        Send Cursor_Ready of Cursor_Control
98768>>>
98768>>>                        If (bOk = True) Begin
98770>>>                            Send Info_Box ("Test table" * sTableName * "with Columns: 'Col1 ASCII 10', 'Col2 Date' and 'Col3 Numeric 6,2' was successfully created and put in filelist slot:" * String(CI_Table1_FileNo))
98771>>>                        End
98771>>>>
98771>>>                        Else Begin
98772>>>                            Send Cursor_Ready of Cursor_Control
98773>>>                            Send Info_Box ("Nope, the test table" * sTableName * "could not be created") "Error"
98774>>>                            Procedure_Return
98775>>>                        End
98775>>>>
98775>>>
98775>>>                    End_Procedure
98776>>>
98776>>>                End_Object
98777>>>
98777>>>                Object oApiRemoveTable_btn is a cRDCButtonDPI
98779>>>                    Set Size to 26 77
98780>>>                    Set Location to 184 96
98781>>>                    Set Label to "Remove 'New' Table"
98782>>>                    Set psImage to "ActionDeleteTable.ico"
98783>>>                    Set MultiLineState to True
98784>>>
98784>>>                    Procedure OnClick
98787>>>                        Boolean bOk
98787>>>                        Integer iRetval
98787>>>                        Handle hTable
98787>>>                        String sTableName sDriverID
98787>>>
98787>>>                        Get Value of oDriverID3_cf to sDriverID
98788>>>                        Get Value of oApiTableName_fm to sTableName
98789>>>                        Get YesNo_Box ("Are you sure you want to PERMANENTLY DELETE the table named:" * String(sTableName) + "?") to iRetval
98790>>>                        If (iRetval = MBR_Yes) Begin
98792>>>                            Send Cursor_Wait of Cursor_Control
98793>>>                            Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98794>>>                            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
98795>>>                            Get ApiTableRemove of ghoDbUpdateFunctionLibrary hTable to bOk
98796>>>                            Send Cursor_Ready of Cursor_Control
98797>>>                            If (bOk = True) Begin
98799>>>                                Send Info_Box "Table removed"
98800>>>                            End
98800>>>>
98800>>>                            Else Begin
98801>>>                                Send Info_Box "Nope, that didnt' work. Either the table doesn't exist or your rights aren't sufficient."
98802>>>                            End
98802>>>>
98802>>>                        End
98802>>>>
98802>>>                    End_Procedure
98803>>>
98803>>>                End_Object
98804>>>
98804>>>                Object oLineControl1 is a LineControl
98806>>>                    Set Size to 2 387
98807>>>                    Set Location to 96 6
98808>>>                    Set peAnchors to anTopLeftRight
98809>>>                End_Object
98810>>>
98810>>>                Object oLineControl2 is a LineControl
98812>>>                    Set Size to 3 248
98813>>>                    Set Location to 171 9
98814>>>                End_Object
98815>>>
98815>>>                Object oTestError_fm is a Form
98817>>>                    Set Size to 13 64
98818>>>                    Set Location to 186 180
98819>>>                    Set Form_Datatype to 0 
98820>>>                    On_Key kEnter send KeyAction of oFindErrorText_Btn
98821>>>                End_Object
98822>>>
98822>>>Register_Function FetchErrorDescription Integer iError Returns String
98822>>>                Object oFindErrorText_Btn is a Button
98824>>>                    Set Size to 13 70
98825>>>                    Set Location to 186 248
98826>>>                    Set Label to "Find Error Text"
98827>>>                
98827>>>                    Procedure OnClick
98830>>>                        String sRetval
98830>>>                        Integer iError 
98830>>>                        Handle hoLogFile
98830>>>                        
98830>>>                        Get phoLogFile of ghoDbUpdateFunctionLibrary to hoLogFile
98831>>>                        Get Value of oTestError_fm to iError
98832>>>                        Get FetchErrorDescription of hoLogFile iError to sRetval 
98833>>>                        Set Value of oErrorText_fm to sRetval    
98834>>>                    End_Procedure
98835>>>                
98835>>>                End_Object
98836>>>
98836>>>                Object oErrorText_fm is a Form
98838>>>                    Set Size to 13 213
98839>>>                    Set Location to 202 180
98840>>>                End_Object
98841>>>
98841>>>            End_Object
98842>>>
98842>>>        End_Object
98843>>>
98843>>>    End_Object
98844>>>
98844>>>End_Object
98845>        Use UtilFunctions.vw
Including file: UtilFunctions.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\UtilFunctions.vw)
98845>>>
98845>>>Use Windows.pkg
98845>>>Use DFClient.pkg
98845>>>Use Dfline.pkg
98845>>>Use cDbScrollingContainer.pkg
98845>>>Use cRDCButtonDPI.pkg
98845>>>Use cDbUpdateFunctionLibrary.pkg
98845>>>Use Dftreevw.pkg
98845>>>Use Working.pkg
Including file: Working.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Working.pkg)
98845>>>>>// COPYRIGHT (c) 2003-2017 RDC Tools International
98845>>>>>//
98845>>>>>// This program is free software; you can redistribute it and/or
98845>>>>>// modify it under the terms of the GNU General Public License
98845>>>>>// as published by the Free Software Foundation; version 2
98845>>>>>// of the License.
98845>>>>>
98845>>>>>// This program is distributed in the hope that it will be useful,
98845>>>>>// but WITHOUT ANY WARRANTY; without even the implied warranty of
98845>>>>>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
98845>>>>>// GNU General Public License for more details.
98845>>>>>
98845>>>>>// You should have received a copy of the GNU General Public License
98845>>>>>// along with this program; (See the GPL.txt file in the Help directory) if not, write to the Free Software
98845>>>>>// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
98845>>>>>Use Windows.pkg
98845>>>>>
98845>>>>>Object oWorkingMessagePanel is a ToolPanel
98847>>>>>    Set Label    to "Working"
98848>>>>>    Set Size to 48 150
98849>>>>>    Set Locate_Mode to CENTER_ON_PARENT
98850>>>>>    Set Popup_State to True
98851>>>>>
98851>>>>>    Object oWorkingMessage is a Textbox
98853>>>>>        Set Label to "Working message..."
98854>>>>>        Set Location to 15 5
98855>>>>>        Set Size to 27 123
98856>>>>>        Set Auto_Size_State to False
98857>>>>>        Set Justification_Mode to JMode_Center
98858>>>>>        Set FontWeight to fw_Bold
98859>>>>>    End_Object
98860>>>>>
98860>>>>>End_Object
98861>>>>>
98861>>>>>Procedure StartWorkingMessage Global String sText
98863>>>>>    Send Close_Panel of (oWorkingMessagePanel(Self))
98864>>>>>    Set Label  of (oWorkingMessage(oWorkingMessagePanel(Self))) to sText
98865>>>>>    Send Popup of (oWorkingMessagePanel(Self))
98866>>>>>End_Procedure
98867>>>>>
98867>>>>>Procedure StopWorkingMessage Global
98869>>>>>    Send Close_Panel of (oWorkingMessagePanel(Self))
98870>>>>>End_Procedure
98871>>>Use DUFStatusPanel.pkg
98871>>>Use cCharTranslate.pkg
98871>>>
98871>>>Struct tFilelistDUF
98871>>>    Integer iFileNumber
98871>>>    String sLogicalName
98871>>>    String sRootName
98871>>>    String sDisplayName
98871>>>End_Struct
98871>>>
98871>>>Activate_View Activate_oUtilFunctions_vw for oUtilFunctions_vw
98881>>>>
98881>>>Object oUtilFunctions_vw is a dbView
98883>>>    Set Border_Style to Border_Thick
98884>>>    Set Size to 291 428
98885>>>    Set Location to 2 1
98886>>>    Set Label to "Utility Functions"
98887>>>    Set pbAutoActivate to True
98888>>>    Set Icon to "TestTools.ico"
98889>>>    Set pbAcceptDropFiles to True
98890>>>
98890>>>    Object oScrollingContainer1 is a cDbScrollingContainer
98892>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
98894>>>
98894>>>            Object oSQL_grp is a Group
98896>>>                Set Size to 88 402
98897>>>                Set Location to 7 12
98898>>>                Set Label to "Run SQL Database Scripts Embedded as Resources"
98899>>>                Set peAnchors to anTopLeftRight
98900>>>
98900>>>                Object oCreateOrderEntry_btn is a cRDCButtonDPI
98902>>>                    Set Size to 14 219
98903>>>                    Set Location to 13 13
98904>>>                    Set Label to "Create New SQL Database [OrderEntry] Complete with Data"
98905>>>                    Set psToolTip to "Creates the full Order Entry Sample database from the DataFlex samples complete with data with the name: [OrderEntry]"
98906>>>                    Set psImage to "ActionCreateDatabase.ico"
98907>>>
98907>>>                    Procedure OnClick
98910>>>                        String sInfoText sDriverID
98910>>>                        Boolean bOK
98910>>>                        TimeSpan tsTotalQueryTime
98910>>>                        Integer iRetval
98910>>>
98910>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98910>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98910>>>                        SQLIncludeScriptFile ..\Scripts\CreateOrderEntry.sql as CreateOrderEntry.sql
98910>>>                        Get YesNo_Box "This will run the 'CreateOrderEntry.sql' script from the 'Script' workspace folder which will create the [OrderEntry] database from the DataFlex samples for Microsoft SQL Server, complete with data. If it exists it will first be dropped, then re-created and populated with new data. Continue?" to iRetval
98911>>>                        If (iRetval <> MBR_Yes) Begin
98913>>>                            Procedure_Return
98914>>>                        End
98914>>>>
98914>>>
98914>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98915>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
98917>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
98918>>>                            Procedure_Return
98919>>>                        End
98919>>>>
98919>>>
98919>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
98920>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateOrderEntry.sql" MSSQLDRV_ID False to bOK
98921>>>                        Send StopWorkingMessage
98922>>>
98922>>>                        If (bOK = True) Begin
98924>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98925>>>                            Move ("Success! DataFlex Order Entry Sample Database was created as [OrderEntry]. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98926>>>                        End
98926>>>>
98926>>>
98926>>>                        Else Begin
98927>>>                            Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98928>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98929>>>                        End
98929>>>>
98929>>>
98929>>>                        Send Info_Box sInfoText
98930>>>                    End_Procedure
98931>>>
98931>>>                End_Object
98932>>>
98932>>>                Object oCreateNorthWind_btn is a cRDCButtonDPI
98934>>>                    Set Size to 14 219
98935>>>                    Set Location to 33 13
98936>>>                    Set Label to "Create New SQL Database [NorthWind] Complete with Data"
98937>>>                    Set psToolTip to "Creates the full NorthWind Sample database from the DataFlex samples complete with data with the name: [NorthWind]"
98938>>>                    Set psImage to "ActionCreateDatabase.ico"
98939>>>
98939>>>                    Procedure OnClick
98942>>>                        String sInfoText sDriverID
98942>>>                        Boolean bOK
98942>>>                        TimeSpan tsTotalQueryTime
98942>>>                        Integer iRetval
98942>>>
98942>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98942>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98942>>>                        SQLIncludeScriptFile ..\Scripts\CreateNorthWindDatabase.sql as CreateNorthWindDatabase.sql
98942>>>
98942>>>                        Get YesNo_Box "This will run the 'CreateNorthWindDatabase.sql' script from the 'Script' workspace folder and it will create the [NorthWind] sample database in Microsoft SQL Server, complete with data. If it exists it will first be dropped, then re-created and populated with new data. Continue?" to iRetval
98943>>>                        If (iRetval <> MBR_Yes) Begin
98945>>>                            Procedure_Return
98946>>>                        End
98946>>>>
98946>>>
98946>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98947>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
98949>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
98950>>>                            Procedure_Return
98951>>>                        End
98951>>>>
98951>>>
98951>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
98952>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateNorthWindDatabase.sql" MSSQLDRV_ID False to bOK
98953>>>                        Send StopWorkingMessage
98954>>>
98954>>>                        If (bOK = True) Begin
98956>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98957>>>                            Move ("Success! The Northwind Sample Database was created as [NorthWind]. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98958>>>                        End
98958>>>>
98958>>>
98958>>>                        Else Begin
98959>>>                            Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98960>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98961>>>                        End
98961>>>>
98961>>>
98961>>>                        Send Info_Box sInfoText
98962>>>                    End_Procedure
98963>>>
98963>>>                End_Object
98964>>>
98964>>>                Object oCreateFullChinookDatabase_btn is a cRDCButtonDPI
98966>>>                    Set Size to 14 219
98967>>>                    Set Location to 53 13
98968>>>                    Set Label to "Create New SQL Database [Chinook] Complete with Data"
98969>>>                    Set psToolTip to "Creates the Chinook demo database complete with data in Microsoft SQL Server. Note: If it exists it will first be dropped then recreated. Note: These scripts were part of Data Access Europe's '' training class."
98970>>>                    Set psImage to "ActionCreateDatabase.ico"
98971>>>
98971>>>                    Procedure OnClick
98974>>>                        String sInfoText sDriverID
98974>>>                        Boolean bOK
98974>>>                        TimeSpan tsTotalQueryTime
98974>>>                        Integer iRetval
98974>>>
98974>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
98974>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
98974>>>                        SQLIncludeScriptFile ..\Scripts\CreateChinookDatabase.sql as CreateChinookDatabase.sql
98974>>>
98974>>>                        Get YesNo_Box "This will run the 'CreateChinookDatabase.sql' script from the 'Script' workspace folder which will create the [Chinook] sample database complete with data. If it exists it will first be dropped, then re-created and populated with new data.\n\nContinue?" to iRetval
98975>>>                        If (iRetval <> MBR_Yes) Begin
98977>>>                            Procedure_Return
98978>>>                        End
98978>>>>
98978>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98979>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
98981>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
98982>>>                            Procedure_Return
98983>>>                        End
98983>>>>
98983>>>
98983>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
98984>>>
98984>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateChinookDatabase.sql" MSSQLDRV_ID False to bOK
98985>>>
98985>>>                        Send StopWorkingMessage
98986>>>                        If (bOK = True) Begin
98988>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
98989>>>                            Move ("Success! The script was run OK. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
98990>>>                        End
98990>>>>
98990>>>
98990>>>                        Else Begin
98991>>>                            Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
98992>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
98993>>>                        End
98993>>>>
98993>>>
98993>>>                        Send Info_Box sInfoText
98994>>>                    End_Procedure
98995>>>
98995>>>                End_Object
98996>>>
98996>>>                Object oInfo_tb is a TextBox
98998>>>                    Set Auto_Size_State to False
98999>>>                    Set Size to 25 158
99000>>>                    Set Location to 53 238
99001>>>                    Set Label to "Note: The Chinook script was provided by Data Access Europe as part of their 'Web Touch Training' course."
99002>>>                    Set Justification_Mode to JMode_Left
99003>>>                    Set peAnchors to anTopLeftRight
99004>>>                End_Object
99005>>>
99005>>>        //  This will choke the computer so don't try it!
99005>>>        //        Object oCreateAdventureWorksDatabase_btn is a cRDCButtonDPI
99005>>>        //            Set Size to 14 312
99005>>>        //            Set Location to 97 45
99005>>>        //            Set Label to "Create [AdventureWorks] Database and Populate with Data"
99005>>>        //            Set psToolTip to "Creates the Adenture Works database complete with data in Microsoft SQL Server. Note: If it exists it will first be dropped then recreated."
99005>>>        //
99005>>>        //            Procedure OnClick
99005>>>        //                String sInfoText
99005>>>        //                Boolean bOK
99005>>>        //                TimeSpan tsTotalQueryTime
99005>>>        //                Integer iRetval
99005>>>        //
99005>>>        //                // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
99005>>>        //                // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
99005>>>        ////                SQLIncludeScriptFile ..\Scripts\CreateAdventureWorks.sql as CreateAdventureWorks.sql
99005>>>        //Procedure_Return
99005>>>        //                Get YesNo_Box "This will create the [AdventurWorks] sample database complete with data. If it exists it will first be dropped, then re-created and populated with new data.\n\nContinue?" to iRetval
99005>>>        //                If (iRetval <> MBR_Yes) Begin
99005>>>        //                    Procedure_Return
99005>>>        //                End
99005>>>        //
99005>>>        //                Send StartWorkingMessage "Executing SQL Script. Please wait..."
99005>>>        //                Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateAdventureWorks.sql" MSSQLDRV_ID False to bOK
99005>>>        //                Send StopWorkingMessage
99005>>>        //
99005>>>        //                If (bOK = True) Begin
99005>>>        //                    Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
99005>>>        //                    Move ("Success! The script was run OK. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
99005>>>        //                End
99005>>>        //
99005>>>        //                Else Begin
99005>>>        //                    Send _UtilShowErrorList of ghoDbUpdateFunctionLibrary
99005>>>        //                    Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
99005>>>        //                End
99005>>>        //
99005>>>        //                Send Info_Box sInfoText
99005>>>        //            End_Procedure
99005>>>        //
99005>>>        //        End_Object
99005>>>
99005>>>            End_Object
99006>>>
99006>>>            Object oChangeIntFiles_grp is a Group
99008>>>                Set Size to 65 402
99009>>>                Set Location to 102 12
99010>>>                Set Label to "Change Old .int files to use Connection ID's"
99011>>>                Set peAnchors to anTopLeftRight
99012>>>
99012>>>                Object oSelectDataPath_fm is a Form
99014>>>                    Set Size to 12 300
99015>>>                    Set Location to 22 13
99016>>>                    Set Label to "Select path to a Data folder with .int files (Select one '.int' file):"
99017>>>                    Set Label_Col_Offset to 0
99018>>>                    Set Label_Row_Offset to 1
99019>>>                    Set Label_Justification_Mode to JMode_Top
99020>>>
99020>>>                    // This is very strange but for some reason the tooltip is _not_ displayed if PB_PromptOn is set...
99020>>>        //            Set Prompt_Button_Mode to PB_PromptOn
99020>>>                    Set psToolTip to "You can use this if you have .int files that currently have content like; 'SERVER=xxx; DATABASE=yyy' et.al. and you need to change them to use a connection ID like; 'SERVER_NAME DFCONNID=MyConnID'"
99021>>>                    Set peAnchors to anTopLeftRight
99022>>>
99022>>>                    Procedure Prompt
99025>>>                        String sPath sFileMask sRetval
99025>>>
99025>>>                        Get psDataPathFirstPart to sPath
99026>>>                        Move "Database intermediate files (*.int)|*.int" to sFileMask
99027>>>                        Get vSelect_File sFileMask "Please select an .int file from the data folder" sPath to sRetval
99028>>>                        If (sRetval <> "") Begin
99030>>>                            Get ParseFolderName sRetval to sPath
99031>>>                            If (Right(sPath, 1) ="\") Begin
99033>>>                                Move (Left(sPath, Length(sPath) -1)) to sPath
99034>>>                            End
99034>>>>
99034>>>                            Set Value to sPath
99035>>>                        End
99035>>>>
99035>>>                    End_Procedure
99036>>>
99036>>>                    // Returns the first datapath found in the psDataPath property.
99036>>>                    // The returned path always ends with a "\"
99036>>>                    Function psDataPathFirstPart Returns String
99039>>>                        String sDataPath
99039>>>                        Integer iCount
99039>>>
99039>>>                        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
99040>>>                        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
99041>>>                        If (iCount > 1) Begin
99043>>>                            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
99044>>>                        End
99044>>>>
99044>>>                        If (sDataPath <> "") Begin
99046>>>                            Get vFolderFormat sDataPath to sDataPath
99047>>>                        End
99047>>>>
99047>>>
99047>>>                        Function_Return sDataPath
99048>>>                    End_Function
99049>>>
99049>>>                End_Object
99050>>>
99050>>>                Object oSelectFolder_btn is a cRDCButtonDPI
99052>>>                    Set Size to 13 73
99053>>>                    Set Location to 22 320
99054>>>                    Set Label to "Select Folder"
99055>>>                    Set psToolTip to "Please select an .int file from the data folder"
99056>>>                    Set peAnchors to anTopRight
99057>>>                    Set psImage to "ActionOpen.ico"
99058>>>
99058>>>                    Procedure OnClick
99061>>>                        Send Prompt to oSelectDataPath_fm
99062>>>                    End_Procedure
99063>>>
99063>>>                End_Object
99064>>>
99064>>>                Object oConnectionID_fm is a Form
99066>>>                    Set Size to 13 111
99067>>>                    Set Location to 38 202
99068>>>                    Set Label_Col_Offset to 2
99069>>>                    Set Label_Justification_Mode to JMode_Right
99070>>>                    Set Label to "Change to DFConnID:"
99071>>>                    Set psToolTip to "Please enter your Connection ID (DFCONNID=) that should replace the SERVER_NAME settings for all .int files in the selected folder."
99072>>>                    Set peAnchors to anTopRight
99073>>>                End_Object
99074>>>
99074>>>                Object oChangeAllIntFiles_btn is a cRDCButtonDPI
99076>>>                    Set Size to 13 68
99077>>>                    Set Location to 38 320
99078>>>                    Set Label to "GO !"
99079>>>                    Set psToolTip to "Changes or updates all .int files in the selected folder - except for DAW driver .int files (MSSQL_DRV.int, DB2_DRV.int & ODBC_DRV.int) - to use 'SERVER_NAME DFCONNID=xxx'"
99080>>>                    Set FontWeight to fw_Bold
99081>>>                    Set peAnchors to anTopRight
99082>>>
99082>>>                    Procedure OnClick
99085>>>                        String sDataPath sConnectionID
99085>>>                        Boolean bExists bActive
99085>>>                        Integer iRetval iChangedFiles
99085>>>
99085>>>                        Get Value of oSelectDataPath_fm to sDataPath
99086>>>                        Get vFolderExists sDataPath to bExists
99087>>>                        If (bExists = False) Begin
99089>>>                            Send Info_Box ("The data folder doesn't exist!\n" + sDataPath)
99090>>>                            Procedure_Return
99091>>>                        End
99091>>>>
99091>>>                        Get Value of oConnectionID_fm to sConnectionID
99092>>>                        Move (Trim(sConnectionID)) to sConnectionID
99093>>>                        If (sConnectionID = "") Begin
99095>>>                            Send Info_Box "You need to specify a Connection_ID to use for the .int files."
99096>>>                            Procedure_Return
99097>>>                        End
99097>>>>
99097>>>
99097>>>                        Get YesNo_Box ("Do you want to change all .int files in folder:\n" + sDataPath + "\n\nTo use 'DFCONNID=" + sConnectionID +"' ?") to iRetval
99098>>>                        If (iRetval <> MBR_Yes) Begin
99100>>>                            Procedure_Return
99101>>>                        End
99101>>>>
99101>>>                        Get YesNo_Box "All '.CCH' files will first be deleted. Continue?" to iRetval
99102>>>                        If (iRetval <> MBR_Yes) Begin
99104>>>                            Procedure_Return
99105>>>                        End
99105>>>>
99105>>>
99105>>>                        Get vDeleteFile (sDataPath + "\*.cch") to iRetval
99106>>>                        If (iRetval <> 0) Begin
99108>>>                            Send Info_Box "Could not delete .cch files!"
99109>>>                            Procedure_Return
99110>>>                        End
99110>>>>
99110>>>
99110>>>                        Send Initialize_StatusPanel of ghoStatusPanel "The Database Update Framework" "Changing Connection ID's in .int files" ""
99111>>>                        Send Start_StatusPanel of ghoStatusPanel
99112>>>                        Get SqlUtilChangeIntFilesToConnectionIDs of ghoDbUpdateFunctionLibrary sDataPath sConnectionID True to iChangedFiles
99113>>>
99113>>>                        Get Active_State of ghoStatusPanel to bActive
99114>>>                        If (bActive = False) Begin
99116>>>                            Send Info_Box "Process interupted..."
99117>>>                        End
99117>>>>
99117>>>                        Else Begin
99118>>>                            Send Stop_StatusPanel of ghoStatusPanel
99119>>>                            Send Info_Box ("Ready!" * String(iChangedFiles) * String(".int files changed."))
99120>>>                        End
99120>>>>
99120>>>                    End_Procedure
99121>>>
99121>>>                End_Object
99122>>>
99122>>>            End_Object
99123>>>
99123>>>            Object oRemoveFilelistDriverIDs_grp is a Group
99125>>>                Set Size to 59 402
99126>>>                Set Location to 171 12
99127>>>                Set Label to "Remove Database Identifications from Filelist.cfg"
99128>>>                Set peAnchors to anTopLeftRight
99129>>>//                Set TextColor to clGreen
99129>>>//
99129>>>//                Procedure Page Integer iPage
99129>>>//                    Integer ia iz
99129>>>//                    Forward Send Page iPage
99129>>>//                    Move 0 to iz
99129>>>//                    Move (AddressOf(iz)) to ia
99129>>>//                    Move (SetWindowTheme(Window_Handle(Self),ia,ia)) to iPage
99129>>>//                End_Procedure
99129>>>
99129>>>                Object oFilelistPath_fm is a Form
99131>>>                    Set Size to 13 299
99132>>>                    Set Location to 22 13
99133>>>                    Set Label to "Path and Filelist.cfg Name:"
99134>>>                    Set Label_Col_Offset to 0
99135>>>                    Set Label_Row_Offset to 1
99136>>>                    Set Label_Justification_Mode to JMode_Top
99137>>>
99137>>>                    // This is very strange but for some reason the tooltip is _not_ displayed if PB_PromptOn is set...
99137>>>        //            Set Prompt_Button_Mode to PB_PromptOn
99137>>>                    Set psToolTip to "You can use this if you have entries in a Filelist.cfg with driver prefixes like 'MSSQLDRV;Customer' and you need to remove them all."
99138>>>                    Set peAnchors to anTopLeftRight
99139>>>
99139>>>                    Procedure Prompt
99142>>>                        String sFileName sPath sFileMask sRetval
99142>>>
99142>>>                        Get Value to sFileName
99143>>>                        Get ParseFolderName sFileName to sPath
99144>>>                        Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
99145>>>                        Get vSelect_File sFileMask "Please select a Filelist.cft file" sPath to sRetval
99146>>>                        If (sRetval <> "") Begin
99148>>>                            Set Value to sRetval
99149>>>                            Set_Attribute DF_FILELIST_NAME to sRetval
99152>>>                        End
99152>>>>
99152>>>                    End_Procedure
99153>>>
99153>>>                    Procedure OnCreate
99156>>>                        String sFilelist
99156>>>                        Get_Attribute DF_FILELIST_NAME to sFilelist
99159>>>                        Set Value to sFilelist
99160>>>                    End_Procedure
99161>>>                    Send OnCreate
99162>>>
99162>>>                End_Object
99163>>>
99163>>>                Object oSelectFilelist_btn is a cRDCButtonDPI
99165>>>                    Set Size to 13 73
99166>>>                    Set Location to 22 319
99167>>>                    Set Label to "Select Filelist.cfg"
99168>>>                    Set psToolTip to "Please select a Filelist.cfg file to be changed"
99169>>>                    Set peAnchors to anTopRight
99170>>>
99170>>>                    Procedure OnClick
99173>>>                        Send Prompt to oFilelistPath_fm
99174>>>                    End_Procedure
99175>>>
99175>>>                End_Object
99176>>>
99176>>>                Object oInfo_tb is a TextBox
99178>>>                    Set Size to 9 207
99179>>>                    Set Location to 40 138
99180>>>                    Set Label to "Remove database driver identifications from Filelist.cfg:"
99181>>>                    Set peAnchors to anTopRight
99182>>>                End_Object
99183>>>
99183>>>                Object oChangeFilelist_btn is a cRDCButtonDPI
99185>>>                    Set Size to 13 68
99186>>>                    Set Location to 38 319
99187>>>                    Set Label to "GO !"
99188>>>                    Set FontWeight to fw_Bold
99189>>>                    Set peAnchors to anTopRight
99190>>>                    Set psToolTip to 'Removes all database driver identificatins from Filelist.cfg, such as: "MSSQLDRV:MyTable"'
99191>>>
99191>>>                    Procedure OnClick
99194>>>                        String sFileList
99194>>>                        Integer iRetval iCount
99194>>>                        Boolean bExits
99194>>>
99194>>>                        Get Value of oFilelistPath_fm to sFileList
99195>>>                        Get vFilePathExists sFileList to bExits
99196>>>                        If (bExits = False) Begin
99198>>>                            Send Info_Box ("Sorry, the Filelist.cfg does not exist;\n" + sFileList)
99199>>>                            Procedure_Return
99200>>>                        End
99200>>>>
99200>>>
99200>>>                        Get YesNo_Box ("Are you sure you want to remove all driver identifications for the following Filelist.cfg?\n" + sFileList) to iRetval
99201>>>                        If (iRetval <> MBR_Yes) Begin
99203>>>                            Procedure_Return
99204>>>                        End
99204>>>>
99204>>>                        Send Cursor_Wait of Cursor_Control
99205>>>
99205>>>                        Get SqlUtilFilelistRemoveDriverInfo of ghoDbUpdateFunctionLibrary sFileList to iCount
99206>>>
99206>>>                        Send Cursor_Ready of Cursor_Control
99207>>>                        If (iCount <> 0) Begin
99209>>>                            Send Info_Box ("Ready!" * String(iCount) * "Filelist.cfg entries adjusted.")
99210>>>                        End
99210>>>>
99210>>>                        Else Begin
99211>>>                            Send Info_Box "Ready. No driver based Filelist entries found."
99212>>>                        End
99212>>>>
99212>>>
99212>>>                    End_Procedure
99213>>>
99213>>>                End_Object
99214>>>
99214>>>            End_Object
99215>>>
99215>>>            Object oOutput_grp is a Group
99217>>>                Set Size to 47 402
99218>>>                Set Location to 234 12
99219>>>                Set Label to "Print sekected Filelist.cfg as a Text file"
99220>>>                Set peAnchors to anTopLeftRight
99221>>>
99221>>>                Object oOutput_rg is a RadioGroup
99223>>>                    Set Location to 18 13
99224>>>                    Set Size to 25 288
99225>>>                    Set Label to "Filelist Output Order"
99226>>>
99226>>>                    Object oRadio1 is a Radio
99228>>>                        Set Label to "Filelist Number"
99229>>>                        Set Size to 10 61
99230>>>                        Set Location to 10 7
99231>>>                    End_Object
99232>>>
99232>>>                    Object oRadio2 is a Radio
99234>>>                        Set Label to "Logical Name"
99235>>>                        Set Size to 10 61
99236>>>                        Set Location to 10 77
99237>>>                    End_Object
99238>>>
99238>>>                    Object oRadio3 is a Radio
99240>>>                        Set Label to "Root Name"
99241>>>                        Set Size to 10 61
99242>>>                        Set Location to 10 147
99243>>>                    End_Object
99244>>>
99244>>>                    Object oRadio4 is a Radio
99246>>>                        Set Label to "Display Name"
99247>>>                        Set Size to 10 62
99248>>>                        Set Location to 10 213
99249>>>                    End_Object
99250>>>
99250>>>                    Procedure Notify_Select_State Integer iToItem Integer iFromItem
99253>>>                        Forward Send Notify_Select_State iToItem iFromItem
99255>>>                        Set piSortOrder of oPrintFilelist_btn to iToItem
99256>>>                    End_Procedure
99257>>>
99257>>>                End_Object
99258>>>                
99258>>>                Object oPrintFilelist_btn is a cRDCButtonDPI
99260>>>                    Set Size to 13 78
99261>>>                    Set Location to 26 315
99262>>>                    Set Label to "Print to Filelist.txt"
99263>>>                    Set psToolTip to "Writes the content of Filelist.cfg to a textfile and shows the textfile in the editor program asociated with *.txt files."
99264>>>                    Set psImage to "ActionDocument.ico"
99265>>>
99265>>>                    Property Integer piSortOrder 0 // Property gets set by the radio group object.
99267>>>
99267>>>                    // Custom array sort function.
99267>>>                    // iSortOrder = 0 -> Filelist number order
99267>>>                    // iSortOrder = 1 -> Logical name order
99267>>>                    // iSortOrder = 2 -> Root name order
99267>>>                    // iSortOrder = 3 -> Display name order
99267>>>                    Function CompareSortFilelist tFilelistDUF FilelistDUF1 tFilelistDUF FilelistDUF2 Returns Integer
99270>>>                        Integer iSortOrder
99270>>>
99270>>>                        Get piSortOrder to iSortOrder
99271>>>
99271>>>                        Case Begin
99271>>>                            Case (iSortOrder = 0)
99273>>>                                If (FilelistDUF1.iFileNumber  > FilelistDUF2.iFileNumber) Begin
99275>>>                                    Function_Return (GT)
99276>>>                                End
99276>>>>
99276>>>                                If (FilelistDUF1.iFileNumber  < FilelistDUF2.iFileNumber) Begin
99278>>>                                    Function_Return (LT)
99279>>>                                End
99279>>>>
99279>>>                                Function_Return (EQ)
99280>>>                            Case (iSortOrder = 1)
99283>>>                                If (Uppercase(FilelistDUF1.sLogicalName) > Uppercase(FilelistDUF2.sLogicalName)) Begin
99285>>>                                    Function_Return (GT)
99286>>>                                End
99286>>>>
99286>>>                                If (Uppercase(FilelistDUF1.sLogicalName) < Uppercase(FilelistDUF2.sLogicalName)) Begin
99288>>>                                    Function_Return (LT)
99289>>>                                End
99289>>>>
99289>>>                                Function_Return (EQ)
99290>>>                            Case (iSortOrder = 2)
99293>>>                                If (Uppercase(FilelistDUF1.sRootName)    > Uppercase(FilelistDUF2.sRootName)) Begin
99295>>>                                    Function_Return (GT)
99296>>>                                End
99296>>>>
99296>>>                                If (Uppercase(FilelistDUF1.sRootName)    < Uppercase(FilelistDUF2.sRootName)) Begin
99298>>>                                    Function_Return (LT)
99299>>>                                End
99299>>>>
99299>>>                                Function_Return (EQ)
99300>>>                            Case (iSortOrder = 3)
99303>>>                                If (Uppercase(FilelistDUF1.sDisplayName) > Uppercase(FilelistDUF2.sDisplayName)) Begin
99305>>>                                    Function_Return (GT)
99306>>>                                End
99306>>>>
99306>>>                                If (Uppercase(FilelistDUF1.sDisplayName) < Uppercase(FilelistDUF2.sDisplayName)) Begin
99308>>>                                    Function_Return (LT)
99309>>>                                End
99309>>>>
99309>>>                                Function_Return (EQ)
99310>>>                        Case End
99310>>>
99310>>>                    End_Function
99311>>>
99311>>>                    Procedure OnClick
99314>>>                        String sFileList sRootName sLogicalName sDisplayName sPath sOutputName sTable sExt
99314>>>                        Integer iCh iCount iSize
99314>>>                        Handle hTable
99314>>>                        tFilelistDUF[] FilelistDUFArray FilelistDUFSorted
99314>>>                        tFilelistDUF[] FilelistDUFArray FilelistDUFSorted
99316>>>
99316>>>                        Get Value of oFilelistPath_fm to sFileList
99317>>>                        Move (Trim(sFileList)) to sFileList
99318>>>                        If (sFileList = "") Begin
99320>>>                            Send Info_Box "You need to select a Filelist.cfg file first"
99321>>>                            Procedure_Return
99322>>>                        End
99322>>>>
99322>>>
99322>>>                        Get ParseFolderName sFileList to sPath
99323>>>                        Get vFolderFormat sPath to sPath
99324>>>                        Get ParseFileName sFileList to sOutputName
99325>>>                        Get ParseFileExtension sFileList to sExt
99326>>>                        Move (Replace(sExt, sOutputName, "")) to sOutputName
99327>>>                        Move (sOutputName + "txt")           to sOutputName
99328>>>                        Get Seq_Open_Output_Channel (sPath + sOutputName) to iCh
99329>>>                        If (iCh < 0) Begin
99331>>>                            Procedure_Return
99332>>>                        End
99332>>>>
99332>>>
99332>>>                        Move 0 to hTable
99333>>>                        Writeln channel iCh sFileList
99336>>>                        Writeln channel iCh "[Table No:]            [LogicalName:]        [RootName:]                             [DisplayName:]"
99339>>>                        Writeln channel iCh "==================================================================================================="
99342>>>                        Writeln channel iCh
99344>>>
99344>>>                        Move 0 to iCount
99345>>>                        Repeat
99345>>>>
99345>>>                            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
99348>>>                            If (hTable > 0) Begin
99350>>>                                Move hTable                                  to FilelistDUFArray[iCount].iFileNumber
99351>>>                                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to FilelistDUFArray[iCount].sLogicalName
99354>>>                                Get_Attribute DF_FILE_ROOT_NAME    of hTable to FilelistDUFArray[iCount].sRootName
99357>>>                                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to FilelistDUFArray[iCount].sDisplayName
99360>>>                                Increment iCount
99361>>>                            End
99361>>>>
99361>>>                        Until (hTable = 0)
99363>>>
99363>>>                        Move (SortArray(FilelistDUFArray, Self, (RefFunc(CompareSortFilelist)))) to FilelistDUFSorted
99364>>>                        Move (SizeOfArray(FilelistDUFSorted)) to iSize
99365>>>                        Decrement iSize
99366>>>
99366>>>                        For iCount from 0 to iSize
99372>>>>
99372>>>                            Move FilelistDUFSorted[iCount].iFileNumber  to hTable
99373>>>                            Move FilelistDUFSorted[iCount].sLogicalName to sLogicalName
99374>>>                            Move FilelistDUFSorted[iCount].sRootName    to sRootName
99375>>>                            Move FilelistDUFSorted[iCount].sDisplayName to sDisplayName
99376>>>
99376>>>                            Get PadLeft (String(hTable))        09 to sTable
99377>>>                            Get PadLeft (String(sLogicalName)) (27 - Length(sTable))       to sLogicalName
99378>>>                            Get PadLeft (String(sRootName))    (46 - Length(sLogicalName)) to sRootName
99379>>>                            Get PadLeft (String(sDisplayName)) (72 - Length(sRootName))    to sDisplayName
99380>>>
99380>>>                            Writeln channel iCh sTable (Utf8ToAnsi(sRootName)) (Utf8ToAnsi(sLogicalName)) (Utf8ToAnsi(sDisplayName))
99386>>>                        Loop
99387>>>>
99387>>>
99387>>>                        Writeln channel iCh "==================================================================================================="
99390>>>                        Writeln channel iCh "Total Number of Tables in Filelist.cfg: " (iSize + 1)
99394>>>                        Close_Output
99395>>>
99395>>>                        Send vShellExecute "open" sOutputName "" sPath
99396>>>                    End_Procedure
99397>>>
99397>>>                    Function PadLeft String sString Integer iLength String sOptChar Returns String
99400>>>                        String sChar
99400>>>
99400>>>                        If (Num_Arguments >= 3) Begin
99402>>>                            Move sOptChar to sChar
99403>>>                        End
99403>>>>
99403>>>                        Else Begin
99404>>>                            Move " " to sChar
99405>>>                        End
99405>>>>
99405>>>
99405>>>                        While (Length(sString) < iLength)
99409>>>                            Move (sChar + sString) to sString
99410>>>                        Loop
99411>>>>
99411>>>
99411>>>                        Function_Return sString
99412>>>                    End_Function
99413>>>
99413>>>                End_Object
99414>>>            End_Object
99415>>>
99415>>>        End_Object
99416>>>
99416>>>    End_Object
99417>>>
99417>>>    Procedure OnFileDropped String sFilename Boolean bLast
99420>>>        String sTest
99420>>>        Forward Send OnFileDropped sFilename bLast
99422>>>        If (bLast = True) Begin
99424>>>            Get ParseFileName sFilename to sTest
99425>>>            If (Uppercase(sTest) <> "FILELIST.CFG") Begin
99427>>>                Send Info_Box "Sorry, only Filist.cfg files can be dropped here..."
99428>>>                Procedure_Return
99429>>>            End
99429>>>>
99429>>>            Set Value of oFilelistPath_fm to sFilename
99430>>>        End
99430>>>>
99430>>>    End_Procedure
99431>>>
99431>>>End_Object
99432>
99432>        Procedure Activate_About
99435>            Send DoAbout "" "" ("Copyright 2016-2023" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "TestTools.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com" ("This tool was created with DataFlex" * String(C_DFVersion) * "from Data Access Worldwide. Please visit http://www.dataaccess.com for a free personal copy of DataFlex.")
99436>        End_Procedure
99437>
99437>        On_Key Key_Ctrl+Key_Tab           Send Switch_Prior_View
99438>        On_Key Key_Ctrl+Key_Shift+Key_Tab Send Switch_Next_View
99439>        On_Key Key_Ctrl+Key_W             Send Close_Panel
99440>    End_Object
99441>
99441>    // Note that we have overriden the cHtmlHelp "GetHelpFile" function
99441>    // in the oHtmlHelp object, so we need to explitetly send the message
99441>    // to that object.
99441>    Procedure ShowProgramHelp
99444>        Send DoDisplayKeyword of oHtmlHelp "DbUpdateFrameworkTests" //"cDbUpdateFunctionLibrary"
99445>    End_Procedure
99446>
99446>    On_Key Key_F1 Send ShowProgramHelp
99447>End_Object
99448>
99448>// *** Note: If you get a compile error: "Can't include the resource COMPILEHEADER.H",
99448>//     you will need to compile the "WriteDateTimeHeaderFile" program first. ***
99448>Start_UI
99449>
Including Resources...
Summary
Memory Available: 76896759808
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 52922
Total Resources: 10
Total Commands : 99448
Total Windows  : 0
Total Pages    : 0
Static Data    : 846831
Message area   : 639840
Total Blocks   : 80776
